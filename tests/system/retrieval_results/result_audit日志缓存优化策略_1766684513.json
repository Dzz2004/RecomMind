{
  "query": "audit日志缓存优化策略",
  "timestamp": "2025-12-26 01:41:53",
  "retrieved_files": [
    {
      "source_file": "kernel/audit.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:49:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `audit.c`\n\n---\n\n# audit.c 技术文档\n\n## 文件概述\n\n`audit.c` 是 Linux 内核审计子系统的核心实现文件，负责提供内核与用户空间审计守护进程（auditd）之间的通信网关。该文件实现了审计记录的生成、队列管理、速率控制、网络命名空间支持以及与安全模块（如 SELinux）的集成。系统调用相关的审计逻辑已移至 `auditsc.c`，本文件聚焦于通用审计基础设施。\n\n## 核心功能\n\n### 主要全局变量\n- `audit_enabled`：审计系统启用状态（导出符号）\n- `audit_ever_enabled`：标记审计是否曾被启用\n- `audit_failure`：审计失败时的行为策略（如打印内核日志）\n- `audit_rate_limit`：每秒允许发送的审计记录上限（防 DoS）\n- `audit_backlog_limit`：待发送审计消息队列的最大长度\n- `audit_lost`：原子计数器，记录丢失的审计记录数量\n- `audit_sig_uid/audit_sig_pid/audit_sig_sid`：关闭审计系统的用户身份信息\n\n### 核心数据结构\n- `struct audit_net`：每个网络命名空间的审计专用数据（含 netlink socket）\n- `struct auditd_connection`：内核与 auditd 守护进程的连接状态（RCU 保护）\n- `struct audit_buffer`：审计记录的临时格式化缓冲区\n- `struct audit_reply`：审计响应消息结构\n- `struct audit_ctl_mutex`：序列化用户空间请求的互斥锁（带所有者跟踪）\n\n### 关键函数\n- `auditd_test_task()`：检查指定任务是否为注册的 auditd 守护进程\n- `audit_ctl_lock()/audit_ctl_unlock()`：获取/释放审计控制锁\n- `audit_ctl_owner_current()`：检查当前任务是否持有审计控制锁\n- `auditd_pid_vnr()`：获取 auditd 在当前 PID 命名空间中的 PID\n\n### 队列系统\n- `audit_queue`：待发送审计消息的主队列\n- `audit_retry_queue`：因单播发送失败需重试的消息队列\n- `audit_hold_queue`：等待新 auditd 连接建立时暂存的消息队列\n\n## 关键实现\n\n### 初始化状态机\n审计系统通过 `audit_initialized` 三态变量控制初始化流程：\n- `AUDIT_DISABLED` (-1)：显式禁用\n- `AUDIT_UNINITIALIZED` (0)：初始状态\n- `AUDIT_INITIALIZED` (1)：完成初始化（需在 `skb_init` 后）\n\n### RCU 保护的 auditd 连接\n`auditd_conn` 指针通过 RCU 机制保护，读操作使用 `rcu_read_lock()`，写操作需持有 `auditd_conn_lock` 自旋锁。这种设计确保高并发场景下连接状态的安全访问。\n\n### 背压与速率控制\n- **速率限制**：通过 `audit_rate_limit` 限制每秒发送记录数\n- **背压机制**：当队列长度超过 `audit_backlog_limit` 时阻塞生产者，并累计等待时间到 `audit_backlog_wait_time_actual`\n- **内存保护**：使用 `audit_buffer_cache` slab 缓存减少内存分配开销\n\n### 锁所有权跟踪\n`audit_ctl_mutex` 扩展标准 mutex，记录锁所有者 (`owner`)。此设计避免在 `audit_log_start()` 等路径中因递归锁导致死锁，确保审计日志生成不会阻塞持有控制锁的任务。\n\n### 网络命名空间支持\n通过 `audit_net_id` 实现 per-netns 审计 socket，每个网络命名空间拥有独立的 auditd 通信通道，符合内核网络命名空间隔离原则。\n\n## 依赖关系\n\n- **核心依赖**：\n  - `<linux/audit.h>`：审计子系统公共接口\n  - `<net/netlink.h>`：Netlink 通信机制\n  - `<linux/security.h>`：LSM（Linux Security Module）集成点\n- **子系统交互**：\n  - **LSM 框架**：作为安全事件的消费者（如 SELinux 策略拒绝事件）\n  - **PID 命名空间**：通过 `pid_vnr()` 获取命名空间内 PID\n  - **RCU 机制**：用于 auditd 连接状态的无锁读取\n  - **kthread**：`kauditd_task` 内核线程处理消息队列\n- **配套文件**：\n  - `auditsc.c`：系统调用审计逻辑\n  - `audit.h`（本地）：内部头文件\n\n## 使用场景\n\n1. **安全事件记录**：当 LSM（如 SELinux/AppArmor）触发安全策略拒绝时，通过 `audit_log_*` 系列函数生成审计记录\n2. **系统调用审计**：配合 `auditsc.c` 记录符合规则的系统调用（需启用 syscall auditing）\n3. **用户空间交互**：\n   - 接收 auditctl 配置命令（规则加载/查询）\n   - 向 auditd 发送审计事件（通过 Netlink）\n   - 处理 auditd 守护进程的生命周期事件（启动/停止）\n4. **内核自检**：通过 `audit_failure` 配置项处理审计子系统内部错误（如内存不足）\n5. **容器环境支持**：在 PID/net 命名空间中为每个容器提供独立的审计上下文",
      "similarity": 0.567790687084198,
      "chunks": [
        {
          "chunk_id": 10,
          "file_path": "kernel/audit.c",
          "start_line": 1834,
          "end_line": 1958,
          "content": [
            "static inline void audit_get_stamp(struct audit_context *ctx,",
            "\t\t\t\t   struct timespec64 *t, unsigned int *serial)",
            "{",
            "\tif (!ctx || !auditsc_get_stamp(ctx, t, serial)) {",
            "\t\tktime_get_coarse_real_ts64(t);",
            "\t\t*serial = audit_serial();",
            "\t}",
            "}",
            "static inline int audit_expand(struct audit_buffer *ab, int extra)",
            "{",
            "\tstruct sk_buff *skb = ab->skb;",
            "\tint oldtail = skb_tailroom(skb);",
            "\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);",
            "\tint newtail = skb_tailroom(skb);",
            "",
            "\tif (ret < 0) {",
            "\t\taudit_log_lost(\"out of memory in audit_expand\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tskb->truesize += newtail - oldtail;",
            "\treturn newtail;",
            "}",
            "static void audit_log_vformat(struct audit_buffer *ab, const char *fmt,",
            "\t\t\t      va_list args)",
            "{",
            "\tint len, avail;",
            "\tstruct sk_buff *skb;",
            "\tva_list args2;",
            "",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tBUG_ON(!ab->skb);",
            "\tskb = ab->skb;",
            "\tavail = skb_tailroom(skb);",
            "\tif (avail == 0) {",
            "\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);",
            "\t\tif (!avail)",
            "\t\t\tgoto out;",
            "\t}",
            "\tva_copy(args2, args);",
            "\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);",
            "\tif (len >= avail) {",
            "\t\t/* The printk buffer is 1024 bytes long, so if we get",
            "\t\t * here and AUDIT_BUFSIZ is at least 1024, then we can",
            "\t\t * log everything that printk could have logged. */",
            "\t\tavail = audit_expand(ab,",
            "\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));",
            "\t\tif (!avail)",
            "\t\t\tgoto out_va_end;",
            "\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);",
            "\t}",
            "\tif (len > 0)",
            "\t\tskb_put(skb, len);",
            "out_va_end:",
            "\tva_end(args2);",
            "out:",
            "\treturn;",
            "}",
            "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "",
            "\tif (!ab)",
            "\t\treturn;",
            "\tva_start(args, fmt);",
            "\taudit_log_vformat(ab, fmt, args);",
            "\tva_end(args);",
            "}",
            "void audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,",
            "\t\tsize_t len)",
            "{",
            "\tint i, avail, new_len;",
            "\tunsigned char *ptr;",
            "\tstruct sk_buff *skb;",
            "",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tBUG_ON(!ab->skb);",
            "\tskb = ab->skb;",
            "\tavail = skb_tailroom(skb);",
            "\tnew_len = len<<1;",
            "\tif (new_len >= avail) {",
            "\t\t/* Round the buffer request up to the next multiple */",
            "\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);",
            "\t\tavail = audit_expand(ab, new_len);",
            "\t\tif (!avail)",
            "\t\t\treturn;",
            "\t}",
            "",
            "\tptr = skb_tail_pointer(skb);",
            "\tfor (i = 0; i < len; i++)",
            "\t\tptr = hex_byte_pack_upper(ptr, buf[i]);",
            "\t*ptr = 0;",
            "\tskb_put(skb, len << 1); /* new string is twice the old string */",
            "}",
            "void audit_log_n_string(struct audit_buffer *ab, const char *string,",
            "\t\t\tsize_t slen)",
            "{",
            "\tint avail, new_len;",
            "\tunsigned char *ptr;",
            "\tstruct sk_buff *skb;",
            "",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tBUG_ON(!ab->skb);",
            "\tskb = ab->skb;",
            "\tavail = skb_tailroom(skb);",
            "\tnew_len = slen + 3;\t/* enclosing quotes + null terminator */",
            "\tif (new_len > avail) {",
            "\t\tavail = audit_expand(ab, new_len);",
            "\t\tif (!avail)",
            "\t\t\treturn;",
            "\t}",
            "\tptr = skb_tail_pointer(skb);",
            "\t*ptr++ = '\"';",
            "\tmemcpy(ptr, string, slen);",
            "\tptr += slen;",
            "\t*ptr++ = '\"';",
            "\t*ptr = 0;",
            "\tskb_put(skb, slen + 2);\t/* don't include null terminator */",
            "}"
          ],
          "function_name": "audit_get_stamp, audit_expand, audit_log_vformat, audit_log_format, audit_log_n_hex, audit_log_n_string",
          "description": "提供审计上下文的时间戳和序列号获取，扩展skb缓冲区以容纳更多日志数据，实现格式化字符串和二进制数据的审计日志记录",
          "similarity": 0.6367174386978149
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/audit.c",
          "start_line": 2238,
          "end_line": 2362,
          "content": [
            "void audit_put_tty(struct tty_struct *tty)",
            "{",
            "\ttty_kref_put(tty);",
            "}",
            "void audit_log_task_info(struct audit_buffer *ab)",
            "{",
            "\tconst struct cred *cred;",
            "\tchar comm[sizeof(current->comm)];",
            "\tstruct tty_struct *tty;",
            "",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tcred = current_cred();",
            "\ttty = audit_get_tty();",
            "\taudit_log_format(ab,",
            "\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"",
            "\t\t\t \" euid=%u suid=%u fsuid=%u\"",
            "\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",",
            "\t\t\t task_ppid_nr(current),",
            "\t\t\t task_tgid_nr(current),",
            "\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),",
            "\t\t\t from_kuid(&init_user_ns, cred->uid),",
            "\t\t\t from_kgid(&init_user_ns, cred->gid),",
            "\t\t\t from_kuid(&init_user_ns, cred->euid),",
            "\t\t\t from_kuid(&init_user_ns, cred->suid),",
            "\t\t\t from_kuid(&init_user_ns, cred->fsuid),",
            "\t\t\t from_kgid(&init_user_ns, cred->egid),",
            "\t\t\t from_kgid(&init_user_ns, cred->sgid),",
            "\t\t\t from_kgid(&init_user_ns, cred->fsgid),",
            "\t\t\t tty ? tty_name(tty) : \"(none)\",",
            "\t\t\t audit_get_sessionid(current));",
            "\taudit_put_tty(tty);",
            "\taudit_log_format(ab, \" comm=\");",
            "\taudit_log_untrustedstring(ab, get_task_comm(comm, current));",
            "\taudit_log_d_path_exe(ab, current->mm);",
            "\taudit_log_task_context(ab);",
            "}",
            "void audit_log_path_denied(int type, const char *operation)",
            "{",
            "\tstruct audit_buffer *ab;",
            "",
            "\tif (!audit_enabled || audit_dummy_context())",
            "\t\treturn;",
            "",
            "\t/* Generate log with subject, operation, outcome. */",
            "\tab = audit_log_start(audit_context(), GFP_KERNEL, type);",
            "\tif (!ab)",
            "\t\treturn;",
            "\taudit_log_format(ab, \"op=%s\", operation);",
            "\taudit_log_task_info(ab);",
            "\taudit_log_format(ab, \" res=0\");",
            "\taudit_log_end(ab);",
            "}",
            "static int audit_set_loginuid_perm(kuid_t loginuid)",
            "{",
            "\t/* if we are unset, we don't need privs */",
            "\tif (!audit_loginuid_set(current))",
            "\t\treturn 0;",
            "\t/* if AUDIT_FEATURE_LOGINUID_IMMUTABLE means never ever allow a change*/",
            "\tif (is_audit_feature_set(AUDIT_FEATURE_LOGINUID_IMMUTABLE))",
            "\t\treturn -EPERM;",
            "\t/* it is set, you need permission */",
            "\tif (!capable(CAP_AUDIT_CONTROL))",
            "\t\treturn -EPERM;",
            "\t/* reject if this is not an unset and we don't allow that */",
            "\tif (is_audit_feature_set(AUDIT_FEATURE_ONLY_UNSET_LOGINUID)",
            "\t\t\t\t && uid_valid(loginuid))",
            "\t\treturn -EPERM;",
            "\treturn 0;",
            "}",
            "static void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,",
            "\t\t\t\t   unsigned int oldsessionid,",
            "\t\t\t\t   unsigned int sessionid, int rc)",
            "{",
            "\tstruct audit_buffer *ab;",
            "\tuid_t uid, oldloginuid, loginuid;",
            "\tstruct tty_struct *tty;",
            "",
            "\tif (!audit_enabled)",
            "\t\treturn;",
            "",
            "\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_LOGIN);",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tuid = from_kuid(&init_user_ns, task_uid(current));",
            "\toldloginuid = from_kuid(&init_user_ns, koldloginuid);",
            "\tloginuid = from_kuid(&init_user_ns, kloginuid);",
            "\ttty = audit_get_tty();",
            "",
            "\taudit_log_format(ab, \"pid=%d uid=%u\", task_tgid_nr(current), uid);",
            "\taudit_log_task_context(ab);",
            "\taudit_log_format(ab, \" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\",",
            "\t\t\t oldloginuid, loginuid, tty ? tty_name(tty) : \"(none)\",",
            "\t\t\t oldsessionid, sessionid, !rc);",
            "\taudit_put_tty(tty);",
            "\taudit_log_end(ab);",
            "}",
            "int audit_set_loginuid(kuid_t loginuid)",
            "{",
            "\tunsigned int oldsessionid, sessionid = AUDIT_SID_UNSET;",
            "\tkuid_t oldloginuid;",
            "\tint rc;",
            "",
            "\toldloginuid = audit_get_loginuid(current);",
            "\toldsessionid = audit_get_sessionid(current);",
            "",
            "\trc = audit_set_loginuid_perm(loginuid);",
            "\tif (rc)",
            "\t\tgoto out;",
            "",
            "\t/* are we setting or clearing? */",
            "\tif (uid_valid(loginuid)) {",
            "\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);",
            "\t\tif (unlikely(sessionid == AUDIT_SID_UNSET))",
            "\t\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);",
            "\t}",
            "",
            "\tcurrent->sessionid = sessionid;",
            "\tcurrent->loginuid = loginuid;",
            "out:",
            "\taudit_log_set_loginuid(oldloginuid, loginuid, oldsessionid, sessionid, rc);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "audit_put_tty, audit_log_task_info, audit_log_path_denied, audit_set_loginuid_perm, audit_log_set_loginuid, audit_set_loginuid",
          "description": "记录任务详细信息到审计日志，处理路径访问拒绝事件，管理登录UID变更并触发审计日志记录",
          "similarity": 0.623542845249176
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/audit.c",
          "start_line": 540,
          "end_line": 667,
          "content": [
            "static void kauditd_printk_skb(struct sk_buff *skb)",
            "{",
            "\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);",
            "\tchar *data = nlmsg_data(nlh);",
            "",
            "\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())",
            "\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);",
            "}",
            "static void kauditd_rehold_skb(struct sk_buff *skb, __always_unused int error)",
            "{",
            "\t/* put the record back in the queue */",
            "\tskb_queue_tail(&audit_hold_queue, skb);",
            "}",
            "static void kauditd_hold_skb(struct sk_buff *skb, int error)",
            "{",
            "\t/* at this point it is uncertain if we will ever send this to auditd so",
            "\t * try to send the message via printk before we go any further */",
            "\tkauditd_printk_skb(skb);",
            "",
            "\t/* can we just silently drop the message? */",
            "\tif (!audit_default)",
            "\t\tgoto drop;",
            "",
            "\t/* the hold queue is only for when the daemon goes away completely,",
            "\t * not -EAGAIN failures; if we are in a -EAGAIN state requeue the",
            "\t * record on the retry queue unless it's full, in which case drop it",
            "\t */",
            "\tif (error == -EAGAIN) {",
            "\t\tif (!audit_backlog_limit ||",
            "\t\t    skb_queue_len(&audit_retry_queue) < audit_backlog_limit) {",
            "\t\t\tskb_queue_tail(&audit_retry_queue, skb);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\taudit_log_lost(\"kauditd retry queue overflow\");",
            "\t\tgoto drop;",
            "\t}",
            "",
            "\t/* if we have room in the hold queue, queue the message */",
            "\tif (!audit_backlog_limit ||",
            "\t    skb_queue_len(&audit_hold_queue) < audit_backlog_limit) {",
            "\t\tskb_queue_tail(&audit_hold_queue, skb);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* we have no other options - drop the message */",
            "\taudit_log_lost(\"kauditd hold queue overflow\");",
            "drop:",
            "\tkfree_skb(skb);",
            "}",
            "static void kauditd_retry_skb(struct sk_buff *skb, __always_unused int error)",
            "{",
            "\tif (!audit_backlog_limit ||",
            "\t    skb_queue_len(&audit_retry_queue) < audit_backlog_limit) {",
            "\t\tskb_queue_tail(&audit_retry_queue, skb);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* we have to drop the record, send it via printk as a last effort */",
            "\tkauditd_printk_skb(skb);",
            "\taudit_log_lost(\"kauditd retry queue overflow\");",
            "\tkfree_skb(skb);",
            "}",
            "static void auditd_reset(const struct auditd_connection *ac)",
            "{",
            "\tunsigned long flags;",
            "\tstruct sk_buff *skb;",
            "\tstruct auditd_connection *ac_old;",
            "",
            "\t/* if it isn't already broken, break the connection */",
            "\tspin_lock_irqsave(&auditd_conn_lock, flags);",
            "\tac_old = rcu_dereference_protected(auditd_conn,",
            "\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));",
            "\tif (ac && ac != ac_old) {",
            "\t\t/* someone already registered a new auditd connection */",
            "\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);",
            "\t\treturn;",
            "\t}",
            "\trcu_assign_pointer(auditd_conn, NULL);",
            "\tspin_unlock_irqrestore(&auditd_conn_lock, flags);",
            "",
            "\tif (ac_old)",
            "\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);",
            "",
            "\t/* flush the retry queue to the hold queue, but don't touch the main",
            "\t * queue since we need to process that normally for multicast */",
            "\twhile ((skb = skb_dequeue(&audit_retry_queue)))",
            "\t\tkauditd_hold_skb(skb, -ECONNREFUSED);",
            "}",
            "static int auditd_send_unicast_skb(struct sk_buff *skb)",
            "{",
            "\tint rc;",
            "\tu32 portid;",
            "\tstruct net *net;",
            "\tstruct sock *sk;",
            "\tstruct auditd_connection *ac;",
            "",
            "\t/* NOTE: we can't call netlink_unicast while in the RCU section so",
            "\t *       take a reference to the network namespace and grab local",
            "\t *       copies of the namespace, the sock, and the portid; the",
            "\t *       namespace and sock aren't going to go away while we hold a",
            "\t *       reference and if the portid does become invalid after the RCU",
            "\t *       section netlink_unicast() should safely return an error */",
            "",
            "\trcu_read_lock();",
            "\tac = rcu_dereference(auditd_conn);",
            "\tif (!ac) {",
            "\t\trcu_read_unlock();",
            "\t\tkfree_skb(skb);",
            "\t\trc = -ECONNREFUSED;",
            "\t\tgoto err;",
            "\t}",
            "\tnet = get_net(ac->net);",
            "\tsk = audit_get_sk(net);",
            "\tportid = ac->portid;",
            "\trcu_read_unlock();",
            "",
            "\trc = netlink_unicast(sk, skb, portid, 0);",
            "\tput_net(net);",
            "\tif (rc < 0)",
            "\t\tgoto err;",
            "",
            "\treturn rc;",
            "",
            "err:",
            "\tif (ac && rc == -ECONNREFUSED)",
            "\t\tauditd_reset(ac);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "kauditd_printk_skb, kauditd_rehold_skb, kauditd_hold_skb, kauditd_retry_skb, auditd_reset, auditd_send_unicast_skb",
          "description": "处理审计消息的重试机制和队列管理，包含消息缓冲、丢弃策略及连接中断后的数据迁移逻辑。",
          "similarity": 0.6101559400558472
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/audit.c",
          "start_line": 1668,
          "end_line": 1768,
          "content": [
            "static void __net_exit audit_net_exit(struct net *net)",
            "{",
            "\tstruct audit_net *aunet = net_generic(net, audit_net_id);",
            "",
            "\t/* NOTE: you would think that we would want to check the auditd",
            "\t * connection and potentially reset it here if it lives in this",
            "\t * namespace, but since the auditd connection tracking struct holds a",
            "\t * reference to this namespace (see auditd_set()) we are only ever",
            "\t * going to get here after that connection has been released */",
            "",
            "\tnetlink_kernel_release(aunet->sk);",
            "}",
            "static int __init audit_init(void)",
            "{",
            "\tint i;",
            "",
            "\tif (audit_initialized == AUDIT_DISABLED)",
            "\t\treturn 0;",
            "",
            "\taudit_buffer_cache = KMEM_CACHE(audit_buffer, SLAB_PANIC);",
            "",
            "\tskb_queue_head_init(&audit_queue);",
            "\tskb_queue_head_init(&audit_retry_queue);",
            "\tskb_queue_head_init(&audit_hold_queue);",
            "",
            "\tfor (i = 0; i < AUDIT_INODE_BUCKETS; i++)",
            "\t\tINIT_LIST_HEAD(&audit_inode_hash[i]);",
            "",
            "\tmutex_init(&audit_cmd_mutex.lock);",
            "\taudit_cmd_mutex.owner = NULL;",
            "",
            "\tpr_info(\"initializing netlink subsys (%s)\\n\",",
            "\t\taudit_default ? \"enabled\" : \"disabled\");",
            "\tregister_pernet_subsys(&audit_net_ops);",
            "",
            "\taudit_initialized = AUDIT_INITIALIZED;",
            "",
            "\tkauditd_task = kthread_run(kauditd_thread, NULL, \"kauditd\");",
            "\tif (IS_ERR(kauditd_task)) {",
            "\t\tint err = PTR_ERR(kauditd_task);",
            "\t\tpanic(\"audit: failed to start the kauditd thread (%d)\\n\", err);",
            "\t}",
            "",
            "\taudit_log(NULL, GFP_KERNEL, AUDIT_KERNEL,",
            "\t\t\"state=initialized audit_enabled=%u res=1\",",
            "\t\t audit_enabled);",
            "",
            "\treturn 0;",
            "}",
            "static int __init audit_enable(char *str)",
            "{",
            "\tif (!strcasecmp(str, \"off\") || !strcmp(str, \"0\"))",
            "\t\taudit_default = AUDIT_OFF;",
            "\telse if (!strcasecmp(str, \"on\") || !strcmp(str, \"1\"))",
            "\t\taudit_default = AUDIT_ON;",
            "\telse {",
            "\t\tpr_err(\"audit: invalid 'audit' parameter value (%s)\\n\", str);",
            "\t\taudit_default = AUDIT_ON;",
            "\t}",
            "",
            "\tif (audit_default == AUDIT_OFF)",
            "\t\taudit_initialized = AUDIT_DISABLED;",
            "\tif (audit_set_enabled(audit_default))",
            "\t\tpr_err(\"audit: error setting audit state (%d)\\n\",",
            "\t\t       audit_default);",
            "",
            "\tpr_info(\"%s\\n\", audit_default ?",
            "\t\t\"enabled (after initialization)\" : \"disabled (until reboot)\");",
            "",
            "\treturn 1;",
            "}",
            "static int __init audit_backlog_limit_set(char *str)",
            "{",
            "\tu32 audit_backlog_limit_arg;",
            "",
            "\tpr_info(\"audit_backlog_limit: \");",
            "\tif (kstrtouint(str, 0, &audit_backlog_limit_arg)) {",
            "\t\tpr_cont(\"using default of %u, unable to parse %s\\n\",",
            "\t\t\taudit_backlog_limit, str);",
            "\t\treturn 1;",
            "\t}",
            "",
            "\taudit_backlog_limit = audit_backlog_limit_arg;",
            "\tpr_cont(\"%d\\n\", audit_backlog_limit);",
            "",
            "\treturn 1;",
            "}",
            "static void audit_buffer_free(struct audit_buffer *ab)",
            "{",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tkfree_skb(ab->skb);",
            "\tkmem_cache_free(audit_buffer_cache, ab);",
            "}",
            "unsigned int audit_serial(void)",
            "{",
            "\tstatic atomic_t serial = ATOMIC_INIT(0);",
            "",
            "\treturn atomic_inc_return(&serial);",
            "}"
          ],
          "function_name": "audit_net_exit, audit_init, audit_enable, audit_backlog_limit_set, audit_buffer_free, audit_serial",
          "description": "完成审计模块的初始化和清理工作，包含缓冲区缓存创建、队列初始化、kauditd线程启动等初始化流程，提供审计状态设置接口及全局参数配置功能。",
          "similarity": 0.5898832678794861
        },
        {
          "chunk_id": 13,
          "file_path": "kernel/audit.c",
          "start_line": 2394,
          "end_line": 2450,
          "content": [
            "int audit_signal_info(int sig, struct task_struct *t)",
            "{",
            "\tkuid_t uid = current_uid(), auid;",
            "",
            "\tif (auditd_test_task(t) &&",
            "\t    (sig == SIGTERM || sig == SIGHUP ||",
            "\t     sig == SIGUSR1 || sig == SIGUSR2)) {",
            "\t\taudit_sig_pid = task_tgid_nr(current);",
            "\t\tauid = audit_get_loginuid(current);",
            "\t\tif (uid_valid(auid))",
            "\t\t\taudit_sig_uid = auid;",
            "\t\telse",
            "\t\t\taudit_sig_uid = uid;",
            "\t\tsecurity_current_getsecid_subj(&audit_sig_sid);",
            "\t}",
            "",
            "\treturn audit_signal_info_syscall(t);",
            "}",
            "void audit_log_end(struct audit_buffer *ab)",
            "{",
            "\tstruct sk_buff *skb;",
            "\tstruct nlmsghdr *nlh;",
            "",
            "\tif (!ab)",
            "\t\treturn;",
            "",
            "\tif (audit_rate_check()) {",
            "\t\tskb = ab->skb;",
            "\t\tab->skb = NULL;",
            "",
            "\t\t/* setup the netlink header, see the comments in",
            "\t\t * kauditd_send_multicast_skb() for length quirks */",
            "\t\tnlh = nlmsg_hdr(skb);",
            "\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;",
            "",
            "\t\t/* queue the netlink packet and poke the kauditd thread */",
            "\t\tskb_queue_tail(&audit_queue, skb);",
            "\t\twake_up_interruptible(&kauditd_wait);",
            "\t} else",
            "\t\taudit_log_lost(\"rate limit exceeded\");",
            "",
            "\taudit_buffer_free(ab);",
            "}",
            "void audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,",
            "\t       const char *fmt, ...)",
            "{",
            "\tstruct audit_buffer *ab;",
            "\tva_list args;",
            "",
            "\tab = audit_log_start(ctx, gfp_mask, type);",
            "\tif (ab) {",
            "\t\tva_start(args, fmt);",
            "\t\taudit_log_vformat(ab, fmt, args);",
            "\t\tva_end(args);",
            "\t\taudit_log_end(ab);",
            "\t}",
            "}"
          ],
          "function_name": "audit_signal_info, audit_log_end, audit_log",
          "description": "处理信号审计信息，完成审计缓冲区的净连接消息封装与发送，作为审计日志记录的主要入口函数",
          "similarity": 0.5843557119369507
        }
      ]
    },
    {
      "source_file": "kernel/audit_tree.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:51:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `audit_tree.c`\n\n---\n\n# audit_tree.c 技术文档\n\n## 1. 文件概述\n\n`audit_tree.c` 是 Linux 内核审计子系统中用于实现**目录树监控**（audit tree watching）的核心模块。该文件提供了对整个目录树（而不仅仅是单个 inode）进行审计监控的能力，通过将审计规则与目录路径关联，并在文件系统事件（如创建、删除、重命名等）发生时高效匹配规则。其核心机制基于 `fsnotify` 框架，在 inode 级别挂载通知标记（mark），并通过引用计数、RCU（Read-Copy-Update）和哈希表等技术保证高并发下的安全性和性能。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct audit_tree`**  \n  表示一个被监控的目录树。包含路径名、引用计数、关联的规则列表、关联的 chunk 列表等。\n  \n- **`struct audit_chunk`**  \n  表示与一个或多个 inode 关联的监控单元。每个 chunk 通过 `fsnotify_mark` 附加到 inode 上，并维护多个 `audit_tree` 的所有者关系（`owners[]` 数组）。\n\n- **`struct audit_tree_mark`**  \n  封装 `fsnotify_mark`，作为 chunk 与 inode 之间的桥梁，属于 `fsnotify` 框架的扩展标记类型。\n\n- **`struct audit_node`**  \n  嵌入在 `audit_chunk` 中，表示 chunk 与某个 `audit_tree` 的关联关系，包含 owner 指针和索引。\n\n### 主要函数\n\n- **`alloc_tree(const char *s)`**  \n  分配并初始化一个新的 `audit_tree` 实例。\n\n- **`get_tree()` / `put_tree()`**  \n  对 `audit_tree` 进行引用计数管理，`put_tree` 在引用归零时使用 RCU 安全释放。\n\n- **`audit_tree_lookup(const struct inode *inode)`**  \n  在 RCU 读临界区内，根据 inode 查找对应的 `audit_chunk`，并增加其引用计数。\n\n- **`audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)`**  \n  检查给定 chunk 是否属于指定的 audit tree。\n\n- **`alloc_chunk(int count)`**  \n  分配包含指定数量 `audit_node` 的 chunk。\n\n- **`insert_hash(struct audit_chunk *chunk)`**  \n  将 chunk 插入全局哈希表，用于快速查找。\n\n- **`audit_mark_put_chunk()` / `audit_put_chunk()`**  \n  安全释放 chunk 的引用，结合 RCU 机制确保并发安全。\n\n- **`replace_mark_chunk()` / `replace_chunk()`**  \n  在标记或 chunk 更新时进行原子替换（代码片段中 `replace_chunk` 未完整）。\n\n## 3. 关键实现\n\n### 哈希与查找机制\n- 使用 `inode->i_fsnotify_marks` 的地址作为哈希键（`inode_to_key`），确保每个 inode 对应唯一键。\n- 全局哈希表 `chunk_hash_heads[HASH_SIZE]`（大小为 128）配合 `hash_lock` 自旋锁保护写操作。\n- 查找操作（`audit_tree_lookup`）在 RCU 读锁下进行，通过 `READ_ONCE()` 和 `smp_wmb()` 保证内存可见性。\n\n### 引用计数与生命周期管理\n- `audit_tree` 使用 `refcount_t` 管理引用，来源包括：关联的审计规则、chunk 中的 owner 引用。\n- `audit_chunk` 使用 `atomic_long_t refs`，其中一份引用由 `fsnotify_mark` 持有。\n- 所有释放操作均通过 RCU（`call_rcu` / `kfree_rcu`）延迟执行，确保并发读取安全。\n\n### 与 fsnotify 集成\n- 每个被监控的 inode 通过 `audit_tree_mark`（继承 `fsnotify_mark`）关联一个 `audit_chunk`。\n- 当 inode 被删除或 untag 时，`fsnotify` 框架回调 `audit_tree_destroy_watch` 释放 mark。\n- `mark->mask = FS_IN_IGNORED` 表示仅用于内部结构关联，不主动监听事件（实际事件由审计规则触发匹配）。\n\n### 循环链表组织\n- `tree->chunks`：链接所有包含该 tree 的 chunk 中的 `audit_node.list`。\n- `chunk->trees`：链接所有以该 chunk 为根的 tree 的 `same_root` 链表。\n- `tree->rules`：链接所有引用该 tree 的审计规则。\n- 这些链表分别由 `hash_lock` 或 `audit_filter_mutex` 保护。\n\n### 索引位标记\n- `audit_node.index` 的最高位（MSB）用于标记“可能需要回滚”的临时状态，辅助复杂操作（如树重构）的清理逻辑。\n\n## 4. 依赖关系\n\n- **`<linux/fsnotify_backend.h>`**：依赖 fsnotify 框架实现 inode 级别事件通知和标记管理。\n- **`<linux/namei.h>` / `<linux/mount.h>`**：用于路径解析和挂载点处理（虽未在片段中直接调用，但 audit 树需处理跨挂载点语义）。\n- **`audit.h`**：与审计核心模块交互，提供 `audit_tree_path()` 等接口供规则匹配使用。\n- **`<linux/rcupdate.h>`**：使用 RCU 机制保证并发安全。\n- **`<linux/slab.h>`**：使用 `kmem_cache` 高效分配 `audit_tree_mark` 对象。\n\n## 5. 使用场景\n\n- **审计规则匹配**：当用户通过 `auditctl` 添加 `-w /path/to/dir -p wa -k key` 类型规则时，内核将 `/path/to/dir` 注册为 `audit_tree`。\n- **路径遍历监控**：在 `audit_inode()` 和 `audit_inode_child()` 中，内核收集路径上所有 inode 对应的 `audit_chunk`，用于后续与 `AUDIT_TREE` 类型规则匹配。\n- **动态目录结构变更**：当目录树内发生文件创建、删除、重命名或 inode 删除时，通过 fsnotify 机制触发 chunk 更新或 prune（修剪）操作，由专用内核线程 `prune_thread` 处理延迟清理。\n- **资源回收**：当审计规则被删除或监控目录被移除时，相关 `audit_tree` 和 `audit_chunk` 通过引用计数和 RCU 安全释放，避免内存泄漏。",
      "similarity": 0.5581626296043396,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/audit_tree.c",
          "start_line": 569,
          "end_line": 709,
          "content": [
            "static void prune_tree_chunks(struct audit_tree *victim, bool tagged)",
            "{",
            "\tspin_lock(&hash_lock);",
            "\twhile (!list_empty(&victim->chunks)) {",
            "\t\tstruct audit_node *p;",
            "\t\tstruct audit_chunk *chunk;",
            "\t\tstruct fsnotify_mark *mark;",
            "",
            "\t\tp = list_first_entry(&victim->chunks, struct audit_node, list);",
            "\t\t/* have we run out of marked? */",
            "\t\tif (tagged && !(p->index & (1U<<31)))",
            "\t\t\tbreak;",
            "\t\tchunk = find_chunk(p);",
            "\t\tmark = chunk->mark;",
            "\t\tremove_chunk_node(chunk, p);",
            "\t\t/* Racing with audit_tree_freeing_mark()? */",
            "\t\tif (!mark)",
            "\t\t\tcontinue;",
            "\t\tfsnotify_get_mark(mark);",
            "\t\tspin_unlock(&hash_lock);",
            "",
            "\t\tuntag_chunk(chunk, mark);",
            "\t\tfsnotify_put_mark(mark);",
            "",
            "\t\tspin_lock(&hash_lock);",
            "\t}",
            "\tspin_unlock(&hash_lock);",
            "}",
            "static void prune_one(struct audit_tree *victim)",
            "{",
            "\tprune_tree_chunks(victim, false);",
            "\tput_tree(victim);",
            "}",
            "static void trim_marked(struct audit_tree *tree)",
            "{",
            "\tstruct list_head *p, *q;",
            "\tspin_lock(&hash_lock);",
            "\tif (tree->goner) {",
            "\t\tspin_unlock(&hash_lock);",
            "\t\treturn;",
            "\t}",
            "\t/* reorder */",
            "\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {",
            "\t\tstruct audit_node *node = list_entry(p, struct audit_node, list);",
            "\t\tq = p->next;",
            "\t\tif (node->index & (1U<<31)) {",
            "\t\t\tlist_del_init(p);",
            "\t\t\tlist_add(p, &tree->chunks);",
            "\t\t}",
            "\t}",
            "\tspin_unlock(&hash_lock);",
            "",
            "\tprune_tree_chunks(tree, true);",
            "",
            "\tspin_lock(&hash_lock);",
            "\tif (!tree->root && !tree->goner) {",
            "\t\ttree->goner = 1;",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t\tkill_rules(audit_context(), tree);",
            "\t\tlist_del_init(&tree->list);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\tprune_one(tree);",
            "\t} else {",
            "\t\tspin_unlock(&hash_lock);",
            "\t}",
            "}",
            "int audit_remove_tree_rule(struct audit_krule *rule)",
            "{",
            "\tstruct audit_tree *tree;",
            "\ttree = rule->tree;",
            "\tif (tree) {",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_del_init(&rule->rlist);",
            "\t\tif (list_empty(&tree->rules) && !tree->goner) {",
            "\t\t\ttree->root = NULL;",
            "\t\t\tlist_del_init(&tree->same_root);",
            "\t\t\ttree->goner = 1;",
            "\t\t\tlist_move(&tree->list, &prune_list);",
            "\t\t\trule->tree = NULL;",
            "\t\t\tspin_unlock(&hash_lock);",
            "\t\t\taudit_schedule_prune();",
            "\t\t\treturn 1;",
            "\t\t}",
            "\t\trule->tree = NULL;",
            "\t\tspin_unlock(&hash_lock);",
            "\t\treturn 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "void audit_trim_trees(void)",
            "{",
            "\tstruct list_head cursor;",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tlist_add(&cursor, &tree_list);",
            "\twhile (cursor.next != &tree_list) {",
            "\t\tstruct audit_tree *tree;",
            "\t\tstruct path path;",
            "\t\tstruct audit_node *node;",
            "\t\tstruct path *paths;",
            "\t\tstruct path array[16];",
            "\t\tint err;",
            "",
            "\t\ttree = container_of(cursor.next, struct audit_tree, list);",
            "\t\tget_tree(tree);",
            "\t\tlist_move(&cursor, &tree->list);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\terr = kern_path(tree->pathname, 0, &path);",
            "\t\tif (err)",
            "\t\t\tgoto skip_it;",
            "",
            "\t\tpaths = collect_paths(&path, array, 16);",
            "\t\tpath_put(&path);",
            "\t\tif (IS_ERR(paths))",
            "\t\t\tgoto skip_it;",
            "",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_for_each_entry(node, &tree->chunks, list) {",
            "\t\t\tstruct audit_chunk *chunk = find_chunk(node);",
            "\t\t\t/* this could be NULL if the watch is dying else where... */",
            "\t\t\tnode->index |= 1U<<31;",
            "\t\t\tfor (struct path *p = paths; p->dentry; p++) {",
            "\t\t\t\tstruct inode *inode = p->dentry->d_inode;",
            "\t\t\t\tif (inode_to_key(inode) == chunk->key) {",
            "\t\t\t\t\tnode->index &= ~(1U<<31);",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tspin_unlock(&hash_lock);",
            "\t\ttrim_marked(tree);",
            "\t\tdrop_collected_paths(paths, array);",
            "skip_it:",
            "\t\tput_tree(tree);",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t}",
            "\tlist_del(&cursor);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "}"
          ],
          "function_name": "prune_tree_chunks, prune_one, trim_marked, audit_remove_tree_rule, audit_trim_trees",
          "description": "实现审计树的周期性清理机制，扫描并移除冗余chunk，通过标记位判断是否保留。结合路径收集和哈希表遍历，确保审计数据及时回收，防止内存泄露和性能下降。",
          "similarity": 0.6080288887023926
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/audit_tree.c",
          "start_line": 1006,
          "end_line": 1081,
          "content": [
            "static void evict_chunk(struct audit_chunk *chunk)",
            "{",
            "\tstruct audit_tree *owner;",
            "\tstruct list_head *postponed = audit_killed_trees();",
            "\tint need_prune = 0;",
            "\tint n;",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tspin_lock(&hash_lock);",
            "\twhile (!list_empty(&chunk->trees)) {",
            "\t\towner = list_entry(chunk->trees.next,",
            "\t\t\t\t   struct audit_tree, same_root);",
            "\t\towner->goner = 1;",
            "\t\towner->root = NULL;",
            "\t\tlist_del_init(&owner->same_root);",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tif (!postponed) {",
            "\t\t\tkill_rules(audit_context(), owner);",
            "\t\t\tlist_move(&owner->list, &prune_list);",
            "\t\t\tneed_prune = 1;",
            "\t\t} else {",
            "\t\t\tlist_move(&owner->list, postponed);",
            "\t\t}",
            "\t\tspin_lock(&hash_lock);",
            "\t}",
            "\tlist_del_rcu(&chunk->hash);",
            "\tfor (n = 0; n < chunk->count; n++)",
            "\t\tlist_del_init(&chunk->owners[n].list);",
            "\tspin_unlock(&hash_lock);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\tif (need_prune)",
            "\t\taudit_schedule_prune();",
            "}",
            "static int audit_tree_handle_event(struct fsnotify_mark *mark, u32 mask,",
            "\t\t\t\t   struct inode *inode, struct inode *dir,",
            "\t\t\t\t   const struct qstr *file_name, u32 cookie)",
            "{",
            "\treturn 0;",
            "}",
            "static void audit_tree_freeing_mark(struct fsnotify_mark *mark,",
            "\t\t\t\t    struct fsnotify_group *group)",
            "{",
            "\tstruct audit_chunk *chunk;",
            "",
            "\tfsnotify_group_lock(mark->group);",
            "\tspin_lock(&hash_lock);",
            "\tchunk = mark_chunk(mark);",
            "\treplace_mark_chunk(mark, NULL);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(mark->group);",
            "\tif (chunk) {",
            "\t\tevict_chunk(chunk);",
            "\t\taudit_mark_put_chunk(chunk);",
            "\t}",
            "",
            "\t/*",
            "\t * We are guaranteed to have at least one reference to the mark from",
            "\t * either the inode or the caller of fsnotify_destroy_mark().",
            "\t */",
            "\tBUG_ON(refcount_read(&mark->refcnt) < 1);",
            "}",
            "static int __init audit_tree_init(void)",
            "{",
            "\tint i;",
            "",
            "\taudit_tree_mark_cachep = KMEM_CACHE(audit_tree_mark, SLAB_PANIC);",
            "",
            "\taudit_tree_group = fsnotify_alloc_group(&audit_tree_ops, 0);",
            "\tif (IS_ERR(audit_tree_group))",
            "\t\taudit_panic(\"cannot initialize fsnotify group for rectree watches\");",
            "",
            "\tfor (i = 0; i < HASH_SIZE; i++)",
            "\t\tINIT_LIST_HEAD(&chunk_hash_heads[i]);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "evict_chunk, audit_tree_handle_event, audit_tree_freeing_mark, audit_tree_init",
          "description": "实现审计块管理与初始化，evict_chunk负责移除失效块关联的树结构并触发展开修剪，audit_tree_handle_event处理文件系统事件但当前无实际逻辑，audit_tree_freeing_mark在释放标记时触发块回收，audit_tree_init初始化缓存与fsnotify组结构。",
          "similarity": 0.5873285531997681
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/audit_tree.c",
          "start_line": 325,
          "end_line": 451,
          "content": [
            "static void remove_chunk_node(struct audit_chunk *chunk, struct audit_node *p)",
            "{",
            "\tstruct audit_tree *owner = p->owner;",
            "",
            "\tif (owner->root == chunk) {",
            "\t\tlist_del_init(&owner->same_root);",
            "\t\towner->root = NULL;",
            "\t}",
            "\tlist_del_init(&p->list);",
            "\tp->owner = NULL;",
            "\tput_tree(owner);",
            "}",
            "static int chunk_count_trees(struct audit_chunk *chunk)",
            "{",
            "\tint i;",
            "\tint ret = 0;",
            "",
            "\tfor (i = 0; i < chunk->count; i++)",
            "\t\tif (chunk->owners[i].owner)",
            "\t\t\tret++;",
            "\treturn ret;",
            "}",
            "static void untag_chunk(struct audit_chunk *chunk, struct fsnotify_mark *mark)",
            "{",
            "\tstruct audit_chunk *new;",
            "\tint size;",
            "",
            "\tfsnotify_group_lock(audit_tree_group);",
            "\t/*",
            "\t * mark_mutex stabilizes chunk attached to the mark so we can check",
            "\t * whether it didn't change while we've dropped hash_lock.",
            "\t */",
            "\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED) ||",
            "\t    mark_chunk(mark) != chunk)",
            "\t\tgoto out_mutex;",
            "",
            "\tsize = chunk_count_trees(chunk);",
            "\tif (!size) {",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_del_init(&chunk->trees);",
            "\t\tlist_del_rcu(&chunk->hash);",
            "\t\treplace_mark_chunk(mark, NULL);",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_detach_mark(mark);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\taudit_mark_put_chunk(chunk);",
            "\t\tfsnotify_free_mark(mark);",
            "\t\treturn;",
            "\t}",
            "",
            "\tnew = alloc_chunk(size);",
            "\tif (!new)",
            "\t\tgoto out_mutex;",
            "",
            "\tspin_lock(&hash_lock);",
            "\t/*",
            "\t * This has to go last when updating chunk as once replace_chunk() is",
            "\t * called, new RCU readers can see the new chunk.",
            "\t */",
            "\treplace_chunk(new, chunk);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\taudit_mark_put_chunk(chunk);",
            "\treturn;",
            "",
            "out_mutex:",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "}",
            "static int create_chunk(struct inode *inode, struct audit_tree *tree)",
            "{",
            "\tstruct fsnotify_mark *mark;",
            "\tstruct audit_chunk *chunk = alloc_chunk(1);",
            "",
            "\tif (!chunk) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tmark = alloc_mark();",
            "\tif (!mark) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tkfree(chunk);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tif (fsnotify_add_inode_mark_locked(mark, inode, 0)) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn -ENOSPC;",
            "\t}",
            "",
            "\tspin_lock(&hash_lock);",
            "\tif (tree->goner) {",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_detach_mark(mark);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_free_mark(mark);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn 0;",
            "\t}",
            "\treplace_mark_chunk(mark, chunk);",
            "\tchunk->owners[0].index = (1U << 31);",
            "\tchunk->owners[0].owner = tree;",
            "\tget_tree(tree);",
            "\tlist_add(&chunk->owners[0].list, &tree->chunks);",
            "\tif (!tree->root) {",
            "\t\ttree->root = chunk;",
            "\t\tlist_add(&tree->same_root, &chunk->trees);",
            "\t}",
            "\tchunk->key = inode_to_key(inode);",
            "\t/*",
            "\t * Inserting into the hash table has to go last as once we do that RCU",
            "\t * readers can see the chunk.",
            "\t */",
            "\tinsert_hash(chunk);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\t/*",
            "\t * Drop our initial reference. When mark we point to is getting freed,",
            "\t * we get notification through ->freeing_mark callback and cleanup",
            "\t * chunk pointing to this mark.",
            "\t */",
            "\tfsnotify_put_mark(mark);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "remove_chunk_node, chunk_count_trees, untag_chunk, create_chunk",
          "description": "实现文件节点标记的增删改查逻辑，包含chunk创建、旧chunk清理及哈希表更新。通过锁保护确保操作原子性，处理标记失效场景并释放无效资源，维持审计系统状态有效性。",
          "similarity": 0.5788382291793823
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/audit_tree.c",
          "start_line": 111,
          "end_line": 218,
          "content": [
            "static inline void get_tree(struct audit_tree *tree)",
            "{",
            "\trefcount_inc(&tree->count);",
            "}",
            "static inline void put_tree(struct audit_tree *tree)",
            "{",
            "\tif (refcount_dec_and_test(&tree->count))",
            "\t\tkfree_rcu(tree, head);",
            "}",
            "static void free_chunk(struct audit_chunk *chunk)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < chunk->count; i++) {",
            "\t\tif (chunk->owners[i].owner)",
            "\t\t\tput_tree(chunk->owners[i].owner);",
            "\t}",
            "\tkfree(chunk);",
            "}",
            "void audit_put_chunk(struct audit_chunk *chunk)",
            "{",
            "\tif (atomic_long_dec_and_test(&chunk->refs))",
            "\t\tfree_chunk(chunk);",
            "}",
            "static void __put_chunk(struct rcu_head *rcu)",
            "{",
            "\tstruct audit_chunk *chunk = container_of(rcu, struct audit_chunk, head);",
            "\taudit_put_chunk(chunk);",
            "}",
            "static void audit_mark_put_chunk(struct audit_chunk *chunk)",
            "{",
            "\tcall_rcu(&chunk->head, __put_chunk);",
            "}",
            "static void audit_tree_destroy_watch(struct fsnotify_mark *mark)",
            "{",
            "\tkmem_cache_free(audit_tree_mark_cachep, audit_mark(mark));",
            "}",
            "static unsigned long inode_to_key(const struct inode *inode)",
            "{",
            "\t/* Use address pointed to by connector->obj as the key */",
            "\treturn (unsigned long)&inode->i_fsnotify_marks;",
            "}",
            "static void insert_hash(struct audit_chunk *chunk)",
            "{",
            "\tstruct list_head *list;",
            "",
            "\t/*",
            "\t * Make sure chunk is fully initialized before making it visible in the",
            "\t * hash. Pairs with a data dependency barrier in READ_ONCE() in",
            "\t * audit_tree_lookup().",
            "\t */",
            "\tsmp_wmb();",
            "\tWARN_ON_ONCE(!chunk->key);",
            "\tlist = chunk_hash(chunk->key);",
            "\tlist_add_rcu(&chunk->hash, list);",
            "}",
            "bool audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)",
            "{",
            "\tint n;",
            "\tfor (n = 0; n < chunk->count; n++)",
            "\t\tif (chunk->owners[n].owner == tree)",
            "\t\t\treturn true;",
            "\treturn false;",
            "}",
            "static void replace_mark_chunk(struct fsnotify_mark *mark,",
            "\t\t\t       struct audit_chunk *chunk)",
            "{",
            "\tstruct audit_chunk *old;",
            "",
            "\tassert_spin_locked(&hash_lock);",
            "\told = mark_chunk(mark);",
            "\taudit_mark(mark)->chunk = chunk;",
            "\tif (chunk)",
            "\t\tchunk->mark = mark;",
            "\tif (old)",
            "\t\told->mark = NULL;",
            "}",
            "static void replace_chunk(struct audit_chunk *new, struct audit_chunk *old)",
            "{",
            "\tstruct audit_tree *owner;",
            "\tint i, j;",
            "",
            "\tnew->key = old->key;",
            "\tlist_splice_init(&old->trees, &new->trees);",
            "\tlist_for_each_entry(owner, &new->trees, same_root)",
            "\t\towner->root = new;",
            "\tfor (i = j = 0; j < old->count; i++, j++) {",
            "\t\tif (!old->owners[j].owner) {",
            "\t\t\ti--;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\towner = old->owners[j].owner;",
            "\t\tnew->owners[i].owner = owner;",
            "\t\tnew->owners[i].index = old->owners[j].index - j + i;",
            "\t\tif (!owner) /* result of earlier fallback */",
            "\t\t\tcontinue;",
            "\t\tget_tree(owner);",
            "\t\tlist_replace_init(&old->owners[j].list, &new->owners[i].list);",
            "\t}",
            "\treplace_mark_chunk(old->mark, new);",
            "\t/*",
            "\t * Make sure chunk is fully initialized before making it visible in the",
            "\t * hash. Pairs with a data dependency barrier in READ_ONCE() in",
            "\t * audit_tree_lookup().",
            "\t */",
            "\tsmp_wmb();",
            "\tlist_replace_rcu(&old->hash, &new->hash);",
            "}"
          ],
          "function_name": "get_tree, put_tree, free_chunk, audit_put_chunk, __put_chunk, audit_mark_put_chunk, audit_tree_destroy_watch, inode_to_key, insert_hash, audit_tree_match, replace_mark_chunk, replace_chunk",
          "description": "提供对audit_tree和audit_chunk的引用计数管理，包含分配/释放chunk逻辑，处理标记替换及哈希表插入。通过RCU机制确保并发安全性，维护规则匹配所需的数据结构一致性。",
          "similarity": 0.5706508755683899
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/audit_tree.c",
          "start_line": 874,
          "end_line": 993,
          "content": [
            "int audit_tag_tree(char *old, char *new)",
            "{",
            "\tstruct list_head cursor, barrier;",
            "\tint failed = 0;",
            "\tstruct path path1, path2;",
            "\tstruct path array[16];",
            "\tstruct path *paths;",
            "\tint err;",
            "",
            "\terr = kern_path(new, 0, &path2);",
            "\tif (err)",
            "\t\treturn err;",
            "\tpaths = collect_paths(&path2, array, 16);",
            "\tpath_put(&path2);",
            "\tif (IS_ERR(paths))",
            "\t\treturn PTR_ERR(paths);",
            "",
            "\terr = kern_path(old, 0, &path1);",
            "\tif (err) {",
            "\t\tdrop_collected_paths(paths, array);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tlist_add(&barrier, &tree_list);",
            "\tlist_add(&cursor, &barrier);",
            "",
            "\twhile (cursor.next != &tree_list) {",
            "\t\tstruct audit_tree *tree;",
            "\t\tint good_one = 0;",
            "",
            "\t\ttree = container_of(cursor.next, struct audit_tree, list);",
            "\t\tget_tree(tree);",
            "\t\tlist_move(&cursor, &tree->list);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\terr = kern_path(tree->pathname, 0, &path2);",
            "\t\tif (!err) {",
            "\t\t\tgood_one = path_is_under(&path1, &path2);",
            "\t\t\tpath_put(&path2);",
            "\t\t}",
            "",
            "\t\tif (!good_one) {",
            "\t\t\tput_tree(tree);",
            "\t\t\tmutex_lock(&audit_filter_mutex);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tfailed = tag_mounts(paths, tree);",
            "\t\tif (failed) {",
            "\t\t\tput_tree(tree);",
            "\t\t\tmutex_lock(&audit_filter_mutex);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t\tspin_lock(&hash_lock);",
            "\t\tif (!tree->goner) {",
            "\t\t\tlist_move(&tree->list, &tree_list);",
            "\t\t}",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tput_tree(tree);",
            "\t}",
            "",
            "\twhile (barrier.prev != &tree_list) {",
            "\t\tstruct audit_tree *tree;",
            "",
            "\t\ttree = container_of(barrier.prev, struct audit_tree, list);",
            "\t\tget_tree(tree);",
            "\t\tlist_move(&tree->list, &barrier);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\tif (!failed) {",
            "\t\t\tstruct audit_node *node;",
            "\t\t\tspin_lock(&hash_lock);",
            "\t\t\tlist_for_each_entry(node, &tree->chunks, list)",
            "\t\t\t\tnode->index &= ~(1U<<31);",
            "\t\t\tspin_unlock(&hash_lock);",
            "\t\t} else {",
            "\t\t\ttrim_marked(tree);",
            "\t\t}",
            "",
            "\t\tput_tree(tree);",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t}",
            "\tlist_del(&barrier);",
            "\tlist_del(&cursor);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\tpath_put(&path1);",
            "\tdrop_collected_paths(paths, array);",
            "\treturn failed;",
            "}",
            "static void audit_schedule_prune(void)",
            "{",
            "\twake_up_process(prune_thread);",
            "}",
            "void audit_kill_trees(struct audit_context *context)",
            "{",
            "\tstruct list_head *list = &context->killed_trees;",
            "",
            "\taudit_ctl_lock();",
            "\tmutex_lock(&audit_filter_mutex);",
            "",
            "\twhile (!list_empty(list)) {",
            "\t\tstruct audit_tree *victim;",
            "",
            "\t\tvictim = list_entry(list->next, struct audit_tree, list);",
            "\t\tkill_rules(context, victim);",
            "\t\tlist_del_init(&victim->list);",
            "",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\tprune_one(victim);",
            "",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t}",
            "",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\taudit_ctl_unlock();",
            "}"
          ],
          "function_name": "audit_tag_tree, audit_schedule_prune, audit_kill_trees",
          "description": "提供审计树状态同步与清理机制，audit_tag_tree用于路径变更时同步树结构，audit_schedule_prune唤醒修剪线程，audit_kill_trees处理上下文中被终止的审计树，通过互斥锁保护并发访问并执行规则清理。",
          "similarity": 0.5621660947799683
        }
      ]
    },
    {
      "source_file": "mm/damon/reclaim.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:50:20\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `damon\\reclaim.c`\n\n---\n\n# `damon/reclaim.c` 技术文档\n\n## 1. 文件概述\n\n`damon/reclaim.c` 是 Linux 内核中基于 **DAMON（Data Access MONitor）** 框架实现的**自动内存回收模块**。该模块通过监控物理内存区域的访问模式，识别长时间未被访问的“冷”内存页，并主动将其回收（page-out），从而释放系统内存资源。其核心目标是在不影响系统性能的前提下，智能地回收低价值内存，提升内存利用率。\n\n该模块以可加载内核模块（LKM）形式存在，通过一组可调参数控制其行为，并支持基于水位线（watermarks）的条件激活机制，避免在内存充足时进行不必要的回收操作。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`enabled`**: 全局开关，控制 DAMON_RECLAIM 功能是否启用。\n- **`commit_inputs`**: 触发参数重载的标志位，用于运行时动态更新配置（除 `enabled` 外）。\n- **`min_age`**: 冷内存判定阈值（微秒），默认 120 秒。\n- **`damon_reclaim_quota`**: 回收配额控制结构，限制单位时间内的最大回收量（默认每秒最多 128 MiB）和 CPU 时间开销（默认最多 10 ms）。\n- **`damon_reclaim_wmarks`**: 水位线配置，基于空闲内存比率决定是否激活回收（高/中/低水位分别为 50%/40%/20%）。\n- **`damon_reclaim_mon_attrs`**: DAMON 监控属性，定义采样间隔（5ms）、聚合间隔（100ms）等。\n- **`monitor_region_start/end`**: 目标监控内存区域的物理地址范围，默认为系统最大连续 RAM 区域。\n- **`skip_anon`**: 布尔标志，若为真则跳过匿名页（anonymous pages）的回收。\n- **`kdamond_pid`**: DAMON 工作线程的 PID，未启用时为 -1。\n- **`damon_reclaim_stat`**: 统计信息结构，记录尝试回收区域数、成功回收区域数及配额超限次数。\n\n### 主要函数\n\n- **`damon_reclaim_new_scheme()`**: 创建 DAMOS（DAMON Operation Scheme）策略，定义“冷内存”模式（大小 ≥ PAGE_SIZE、访问次数为 0、年龄 ≥ `min_age`）并指定操作为 `DAMOS_PAGEOUT`。\n- **`damon_reclaim_apply_parameters()`**: 应用所有用户配置参数到 DAMON 上下文（`ctx`），包括监控属性、回收策略、过滤器（如 `skip_anon`）和监控区域。\n- **`damon_reclaim_turn()`**: 启动或停止 DAMON_RECLAIM 的核心监控与回收逻辑。\n- **`damon_reclaim_enabled_store()`**: `enabled` 参数的 setter 回调，处理启用/禁用逻辑。\n- **`damon_reclaim_handle_commit_inputs()`**: 处理 `commit_inputs` 标志，触发运行时参数重载。\n- **`damon_reclaim_after_aggregation()` / `damon_reclaim_after_wmarks_check()`**: DAMON 回调函数，在聚合后和水位检查后更新统计信息并处理参数提交。\n- **`damon_reclaim_init()`**: 模块初始化函数，创建 DAMON 上下文和目标，注册回调，并根据初始 `enabled` 状态决定是否启动。\n\n## 3. 关键实现\n\n### 冷内存识别与回收策略\n- 通过 `damon_reclaim_new_scheme()` 定义 DAMOS 策略：\n  - **访问模式匹配**：区域大小 ≥ `PAGE_SIZE`、访问次数 = 0、年龄 ≥ `min_age / aggr_interval`（转换为聚合周期单位）。\n  - **操作类型**：`DAMOS_PAGEOUT`，即对匹配区域执行页面回收。\n  - **配额控制**：使用 `damon_reclaim_quota` 限制回收速度和 CPU 开销，确保系统稳定性。\n  - **水位激活**：仅当空闲内存比率低于 `high` 水位（50%）时激活策略，高于 `low` 水位（20%）时停用。\n\n### 动态参数更新机制\n- 用户可通过写入 `commit_inputs=Y` 触发运行时参数重载（`min_age`、配额、水位、监控区域等）。\n- `damon_reclaim_handle_commit_inputs()` 在 DAMON 的聚合后或水位检查后回调中执行重载，确保线程安全。\n- 重载时保留旧策略的配额状态（如已消耗的配额），避免统计中断。\n\n### 匿名页过滤\n- 若 `skip_anon=Y`，通过 `DAMOS_FILTER_TYPE_ANON` 过滤器排除匿名页（如进程堆栈、堆内存），仅回收文件缓存等页面。\n\n### 监控区域自动配置\n- 默认使用 `damon_set_region_biggest_system_ram_default()` 自动选择系统中最大的连续物理 RAM 区域作为监控目标，用户也可通过 `monitor_region_start/end` 手动指定。\n\n## 4. 依赖关系\n\n- **DAMON 核心框架** (`<linux/damon.h>`): 依赖 DAMON 提供的内存访问监控、策略引擎（DAMOS）、配额管理、水位控制等基础设施。\n- **内核模块通用接口** (`modules-common.h`): 使用 `DEFINE_DAMON_MODULES_*` 宏简化参数声明和统计暴露。\n- **内存管理子系统**: 通过 `DAMOS_PAGEOUT` 操作与 MM 子系统交互，实际执行页面回收。\n- **参数解析工具** (`<linux/kstrtox.h>`): 用于解析用户输入的布尔值和数值参数。\n\n## 5. 使用场景\n\n- **内存压力缓解**: 在内存紧张但尚未触发传统 LRU 回收或 OOM Killer 之前，提前回收长期未使用的冷内存，延缓内存压力。\n- **容器/虚拟机内存优化**: 在容器或 VM 中部署，自动回收应用未使用的缓存内存，提高宿主机内存密度。\n- **大内存系统调优**: 在 TB 级内存服务器上，减少因缓存膨胀导致的内存浪费，提升整体内存效率。\n- **低延迟敏感场景**: 通过配额限制（`ms=10`）确保回收操作不会显著影响关键任务的延迟。\n- **调试与监控**: 通过 `kdamond_pid` 和统计参数（`reclaim_tried_regions` 等）监控 DAMON_RECLAIM 的运行状态和效果。",
      "similarity": 0.5544402003288269,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/damon/reclaim.c",
          "start_line": 153,
          "end_line": 254,
          "content": [
            "static void damon_reclaim_copy_quota_status(struct damos_quota *dst,",
            "\t\tstruct damos_quota *src)",
            "{",
            "\tdst->total_charged_sz = src->total_charged_sz;",
            "\tdst->total_charged_ns = src->total_charged_ns;",
            "\tdst->charged_sz = src->charged_sz;",
            "\tdst->charged_from = src->charged_from;",
            "\tdst->charge_target_from = src->charge_target_from;",
            "\tdst->charge_addr_from = src->charge_addr_from;",
            "}",
            "static int damon_reclaim_apply_parameters(void)",
            "{",
            "\tstruct damos *scheme, *old_scheme;",
            "\tstruct damos_filter *filter;",
            "\tint err = 0;",
            "",
            "\terr = damon_set_attrs(ctx, &damon_reclaim_mon_attrs);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\t/* Will be freed by next 'damon_set_schemes()' below */",
            "\tscheme = damon_reclaim_new_scheme();",
            "\tif (!scheme)",
            "\t\treturn -ENOMEM;",
            "\tif (!list_empty(&ctx->schemes)) {",
            "\t\tdamon_for_each_scheme(old_scheme, ctx)",
            "\t\t\tdamon_reclaim_copy_quota_status(&scheme->quota,",
            "\t\t\t\t\t&old_scheme->quota);",
            "\t}",
            "\tif (skip_anon) {",
            "\t\tfilter = damos_new_filter(DAMOS_FILTER_TYPE_ANON, true);",
            "\t\tif (!filter) {",
            "\t\t\t/* Will be freed by next 'damon_set_schemes()' below */",
            "\t\t\tdamon_destroy_scheme(scheme);",
            "\t\t\treturn -ENOMEM;",
            "\t\t}",
            "\t\tdamos_add_filter(scheme, filter);",
            "\t}",
            "\tdamon_set_schemes(ctx, &scheme, 1);",
            "",
            "\treturn damon_set_region_biggest_system_ram_default(target,",
            "\t\t\t\t\t&monitor_region_start,",
            "\t\t\t\t\t&monitor_region_end);",
            "}",
            "static int damon_reclaim_turn(bool on)",
            "{",
            "\tint err;",
            "",
            "\tif (!on) {",
            "\t\terr = damon_stop(&ctx, 1);",
            "\t\tif (!err)",
            "\t\t\tkdamond_pid = -1;",
            "\t\treturn err;",
            "\t}",
            "",
            "\terr = damon_reclaim_apply_parameters();",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = damon_start(&ctx, 1, true);",
            "\tif (err)",
            "\t\treturn err;",
            "\tkdamond_pid = ctx->kdamond->pid;",
            "\treturn 0;",
            "}",
            "static int damon_reclaim_enabled_store(const char *val,",
            "\t\tconst struct kernel_param *kp)",
            "{",
            "\tbool is_enabled = enabled;",
            "\tbool enable;",
            "\tint err;",
            "",
            "\terr = kstrtobool(val, &enable);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif (is_enabled == enable)",
            "\t\treturn 0;",
            "",
            "\t/* Called before init function.  The function will handle this. */",
            "\tif (!ctx)",
            "\t\tgoto set_param_out;",
            "",
            "\terr = damon_reclaim_turn(enable);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "set_param_out:",
            "\tenabled = enable;",
            "\treturn err;",
            "}",
            "static int damon_reclaim_handle_commit_inputs(void)",
            "{",
            "\tint err;",
            "",
            "\tif (!commit_inputs)",
            "\t\treturn 0;",
            "",
            "\terr = damon_reclaim_apply_parameters();",
            "\tcommit_inputs = false;",
            "\treturn err;",
            "}"
          ],
          "function_name": "damon_reclaim_copy_quota_status, damon_reclaim_apply_parameters, damon_reclaim_turn, damon_reclaim_enabled_store, damon_reclaim_handle_commit_inputs",
          "description": "实现DAMON_RECLAIM参数动态应用、启停切换及配额状态复制逻辑，通过回调机制协调监控上下文与回收策略，支持运行时参数更新和资源回收操作。",
          "similarity": 0.4948311448097229
        },
        {
          "chunk_id": 2,
          "file_path": "mm/damon/reclaim.c",
          "start_line": 269,
          "end_line": 298,
          "content": [
            "static int damon_reclaim_after_aggregation(struct damon_ctx *c)",
            "{",
            "\tstruct damos *s;",
            "",
            "\t/* update the stats parameter */",
            "\tdamon_for_each_scheme(s, c)",
            "\t\tdamon_reclaim_stat = s->stat;",
            "",
            "\treturn damon_reclaim_handle_commit_inputs();",
            "}",
            "static int damon_reclaim_after_wmarks_check(struct damon_ctx *c)",
            "{",
            "\treturn damon_reclaim_handle_commit_inputs();",
            "}",
            "static int __init damon_reclaim_init(void)",
            "{",
            "\tint err = damon_modules_new_paddr_ctx_target(&ctx, &target);",
            "",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tctx->callback.after_wmarks_check = damon_reclaim_after_wmarks_check;",
            "\tctx->callback.after_aggregation = damon_reclaim_after_aggregation;",
            "",
            "\t/* 'enabled' has set before this function, probably via command line */",
            "\tif (enabled)",
            "\t\terr = damon_reclaim_turn(true);",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "damon_reclaim_after_aggregation, damon_reclaim_after_wmarks_check, damon_reclaim_init",
          "description": "注册DAMON框架的回调函数以实现回收策略的动态调整，初始化阶段绑定自定义回调至上下文，确保在监控周期关键节点触发参数重载和回收策略更新。",
          "similarity": 0.4909881353378296
        },
        {
          "chunk_id": 0,
          "file_path": "mm/damon/reclaim.c",
          "start_line": 1,
          "end_line": 152,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * DAMON-based page reclamation",
            " *",
            " * Author: SeongJae Park <sj@kernel.org>",
            " */",
            "",
            "#define pr_fmt(fmt) \"damon-reclaim: \" fmt",
            "",
            "#include <linux/damon.h>",
            "#include <linux/kstrtox.h>",
            "#include <linux/module.h>",
            "",
            "#include \"modules-common.h\"",
            "",
            "#ifdef MODULE_PARAM_PREFIX",
            "#undef MODULE_PARAM_PREFIX",
            "#endif",
            "#define MODULE_PARAM_PREFIX \"damon_reclaim.\"",
            "",
            "/*",
            " * Enable or disable DAMON_RECLAIM.",
            " *",
            " * You can enable DAMON_RCLAIM by setting the value of this parameter as ``Y``.",
            " * Setting it as ``N`` disables DAMON_RECLAIM.  Note that DAMON_RECLAIM could",
            " * do no real monitoring and reclamation due to the watermarks-based activation",
            " * condition.  Refer to below descriptions for the watermarks parameter for",
            " * this.",
            " */",
            "static bool enabled __read_mostly;",
            "",
            "/*",
            " * Make DAMON_RECLAIM reads the input parameters again, except ``enabled``.",
            " *",
            " * Input parameters that updated while DAMON_RECLAIM is running are not applied",
            " * by default.  Once this parameter is set as ``Y``, DAMON_RECLAIM reads values",
            " * of parametrs except ``enabled`` again.  Once the re-reading is done, this",
            " * parameter is set as ``N``.  If invalid parameters are found while the",
            " * re-reading, DAMON_RECLAIM will be disabled.",
            " */",
            "static bool commit_inputs __read_mostly;",
            "module_param(commit_inputs, bool, 0600);",
            "",
            "/*",
            " * Time threshold for cold memory regions identification in microseconds.",
            " *",
            " * If a memory region is not accessed for this or longer time, DAMON_RECLAIM",
            " * identifies the region as cold, and reclaims.  120 seconds by default.",
            " */",
            "static unsigned long min_age __read_mostly = 120000000;",
            "module_param(min_age, ulong, 0600);",
            "",
            "static struct damos_quota damon_reclaim_quota = {",
            "\t/* use up to 10 ms time, reclaim up to 128 MiB per 1 sec by default */",
            "\t.ms = 10,",
            "\t.sz = 128 * 1024 * 1024,",
            "\t.reset_interval = 1000,",
            "\t/* Within the quota, page out older regions first. */",
            "\t.weight_sz = 0,",
            "\t.weight_nr_accesses = 0,",
            "\t.weight_age = 1",
            "};",
            "DEFINE_DAMON_MODULES_DAMOS_QUOTAS(damon_reclaim_quota);",
            "",
            "static struct damos_watermarks damon_reclaim_wmarks = {",
            "\t.metric = DAMOS_WMARK_FREE_MEM_RATE,",
            "\t.interval = 5000000,\t/* 5 seconds */",
            "\t.high = 500,\t\t/* 50 percent */",
            "\t.mid = 400,\t\t/* 40 percent */",
            "\t.low = 200,\t\t/* 20 percent */",
            "};",
            "DEFINE_DAMON_MODULES_WMARKS_PARAMS(damon_reclaim_wmarks);",
            "",
            "static struct damon_attrs damon_reclaim_mon_attrs = {",
            "\t.sample_interval = 5000,\t/* 5 ms */",
            "\t.aggr_interval = 100000,\t/* 100 ms */",
            "\t.ops_update_interval = 0,",
            "\t.min_nr_regions = 10,",
            "\t.max_nr_regions = 1000,",
            "};",
            "DEFINE_DAMON_MODULES_MON_ATTRS_PARAMS(damon_reclaim_mon_attrs);",
            "",
            "/*",
            " * Start of the target memory region in physical address.",
            " *",
            " * The start physical address of memory region that DAMON_RECLAIM will do work",
            " * against.  By default, biggest System RAM is used as the region.",
            " */",
            "static unsigned long monitor_region_start __read_mostly;",
            "module_param(monitor_region_start, ulong, 0600);",
            "",
            "/*",
            " * End of the target memory region in physical address.",
            " *",
            " * The end physical address of memory region that DAMON_RECLAIM will do work",
            " * against.  By default, biggest System RAM is used as the region.",
            " */",
            "static unsigned long monitor_region_end __read_mostly;",
            "module_param(monitor_region_end, ulong, 0600);",
            "",
            "/*",
            " * Skip anonymous pages reclamation.",
            " *",
            " * If this parameter is set as ``Y``, DAMON_RECLAIM does not reclaim anonymous",
            " * pages.  By default, ``N``.",
            " */",
            "static bool skip_anon __read_mostly;",
            "module_param(skip_anon, bool, 0600);",
            "",
            "/*",
            " * PID of the DAMON thread",
            " *",
            " * If DAMON_RECLAIM is enabled, this becomes the PID of the worker thread.",
            " * Else, -1.",
            " */",
            "static int kdamond_pid __read_mostly = -1;",
            "module_param(kdamond_pid, int, 0400);",
            "",
            "static struct damos_stat damon_reclaim_stat;",
            "DEFINE_DAMON_MODULES_DAMOS_STATS_PARAMS(damon_reclaim_stat,",
            "\t\treclaim_tried_regions, reclaimed_regions, quota_exceeds);",
            "",
            "static struct damon_ctx *ctx;",
            "static struct damon_target *target;",
            "",
            "static struct damos *damon_reclaim_new_scheme(void)",
            "{",
            "\tstruct damos_access_pattern pattern = {",
            "\t\t/* Find regions having PAGE_SIZE or larger size */",
            "\t\t.min_sz_region = PAGE_SIZE,",
            "\t\t.max_sz_region = ULONG_MAX,",
            "\t\t/* and not accessed at all */",
            "\t\t.min_nr_accesses = 0,",
            "\t\t.max_nr_accesses = 0,",
            "\t\t/* for min_age or more micro-seconds */",
            "\t\t.min_age_region = min_age /",
            "\t\t\tdamon_reclaim_mon_attrs.aggr_interval,",
            "\t\t.max_age_region = UINT_MAX,",
            "\t};",
            "",
            "\treturn damon_new_scheme(",
            "\t\t\t&pattern,",
            "\t\t\t/* page out those, as soon as found */",
            "\t\t\tDAMOS_PAGEOUT,",
            "\t\t\t/* for each aggregation interval */",
            "\t\t\t0,",
            "\t\t\t/* under the quota. */",
            "\t\t\t&damon_reclaim_quota,",
            "\t\t\t/* (De)activate this according to the watermarks. */",
            "\t\t\t&damon_reclaim_wmarks);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义DAMON_RECLAIM模块的全局参数和配置，包括启用状态、冷内存识别时间阈值、配额限制、水印条件及监控属性，用于控制基于DAMON的页面回收行为。",
          "similarity": 0.4603832960128784
        }
      ]
    }
  ]
}