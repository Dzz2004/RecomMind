{
  "query": "页面置换算法",
  "timestamp": "2025-12-25 23:39:10",
  "retrieved_files": [
    {
      "source_file": "mm/shuffle.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:21:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `shuffle.c`\n\n---\n\n# shuffle.c 技术文档\n\n## 1. 文件概述\n\n`shuffle.c` 实现了 Linux 内核内存管理子系统中的**页面分配随机化（Page Allocation Shuffling）**功能。该机制通过在内存初始化阶段对空闲页面链表进行 Fisher-Yates 洗牌操作，降低物理页帧分配的可预测性，从而增强系统安全性，抵御基于内存布局预测的攻击（如堆喷射、地址泄露等）。该功能默认关闭，可通过内核启动参数 `shuffle=1` 启用。\n\n## 2. 核心功能\n\n### 数据结构与全局变量\n- `page_alloc_shuffle_key`：静态分支键（static key），用于运行时启用/禁用洗牌逻辑，减少未启用时的性能开销。\n- `shuffle_param`：模块参数布尔值，控制是否启用洗牌功能。\n- `shuffle_param_ops`：自定义模块参数操作集，用于处理 `shuffle` 参数的设置和读取。\n\n### 主要函数\n- `shuffle_param_set()`：解析并设置 `shuffle` 内核参数，若启用则激活 `page_alloc_shuffle_key`。\n- `shuffle_valid_page()`：验证指定 PFN 的页面是否满足洗牌条件（属于 buddy 系统、同 zone、空闲、相同 order 和 migratetype）。\n- `__shuffle_zone()`：对指定内存区域（zone）执行 Fisher-Yates 洗牌算法，随机交换同阶空闲页面。\n- `__shuffle_free_memory()`：遍历节点（pgdat）中所有 zone，依次调用 `shuffle_zone()` 进行洗牌。\n- `shuffle_pick_tail()`：提供轻量级随机位生成器，用于在分配时决定从链表头部还是尾部取页（增强运行时随机性）。\n\n## 3. 关键实现\n\n### 洗牌算法（Fisher-Yates）\n- **粒度**：以 `SHUFFLE_ORDER`（通常为 0，即单页）为单位进行洗牌。\n- **范围**：遍历 zone 内所有按 order 对齐的 PFN，对每个有效页面 `page_i` 随机选择另一个有效页面 `page_j` 进行交换。\n- **有效性校验**：通过 `shuffle_valid_page()` 确保交换双方均为 buddy 系统管理的空闲页，且具有相同的迁移类型（migratetype）。\n- **重试机制**：最多尝试 `SHUFFLE_RETRY`（10 次）寻找有效的随机目标页，避免因内存空洞导致失败。\n- **锁优化**：每处理 100 个页面后释放 zone 自旋锁并调度，防止长时间持锁影响系统响应。\n\n### 随机性来源\n- 使用 `get_random_long()` 获取高质量伪随机数作为洗牌索引。\n- `shuffle_pick_tail()` 使用无锁的 64 位随机状态生成器，每次返回最低位并右移，用于运行时分配策略的微调。\n\n### 安全性权衡\n- 明确承认不消除模运算偏差（modulo bias）或 PRNG 偏差，目标是“提高攻击门槛”而非完美随机。\n- 仅在内存初始化阶段（`__meminit`）执行一次洗牌，不影响运行时分配性能。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/mm.h>`、`<linux/mmzone.h>`：内存管理核心数据结构（`struct zone`, `struct page`）。\n  - `<linux/random.h>`：提供 `get_random_long()` 和 `get_random_u64()`。\n  - `\"internal.h\"`、`\"shuffle.h\"`：内核 MM 子系统内部接口及洗牌功能声明。\n- **功能依赖**：\n  - Buddy 分配器：依赖 `PageBuddy()`、`buddy_order()` 等接口判断页面状态。\n  - 页面迁移类型（Migratetype）：确保洗牌不破坏不同迁移类型页面的隔离。\n  - 静态分支（Static Keys）：通过 `static_branch_enable()` 动态启用洗牌路径。\n\n## 5. 使用场景\n\n- **安全加固**：在需要防范物理地址预测攻击的场景（如虚拟化宿主机、安全敏感设备）中启用，增加攻击者利用内存布局漏洞的难度。\n- **内核初始化**：在 `free_area_init_core()` 等内存子系统初始化流程中调用 `__shuffle_free_memory()`，对初始空闲内存进行一次性洗牌。\n- **运行时分配辅助**：`shuffle_pick_tail()` 被页面分配器调用，决定从空闲链表头/尾取页，进一步增加分配时序的不可预测性。\n- **调试支持**：通过 `pr_debug()` 输出洗牌失败或迁移类型不匹配的日志，便于问题诊断（需开启 `DEBUG_SHUFFLE`）。",
      "similarity": 0.5729565620422363,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/shuffle.c",
          "start_line": 16,
          "end_line": 121,
          "content": [
            "static __meminit int shuffle_param_set(const char *val,",
            "\t\tconst struct kernel_param *kp)",
            "{",
            "\tif (param_set_bool(val, kp))",
            "\t\treturn -EINVAL;",
            "\tif (*(bool *)kp->arg)",
            "\t\tstatic_branch_enable(&page_alloc_shuffle_key);",
            "\treturn 0;",
            "}",
            "void __meminit __shuffle_zone(struct zone *z)",
            "{",
            "\tunsigned long i, flags;",
            "\tunsigned long start_pfn = z->zone_start_pfn;",
            "\tunsigned long end_pfn = zone_end_pfn(z);",
            "\tconst int order = SHUFFLE_ORDER;",
            "\tconst int order_pages = 1 << order;",
            "",
            "\tspin_lock_irqsave(&z->lock, flags);",
            "\tstart_pfn = ALIGN(start_pfn, order_pages);",
            "\tfor (i = start_pfn; i < end_pfn; i += order_pages) {",
            "\t\tunsigned long j;",
            "\t\tint migratetype, retry;",
            "\t\tstruct page *page_i, *page_j;",
            "",
            "\t\t/*",
            "\t\t * We expect page_i, in the sub-range of a zone being added",
            "\t\t * (@start_pfn to @end_pfn), to more likely be valid compared to",
            "\t\t * page_j randomly selected in the span @zone_start_pfn to",
            "\t\t * @spanned_pages.",
            "\t\t */",
            "\t\tpage_i = shuffle_valid_page(z, i, order);",
            "\t\tif (!page_i)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (retry = 0; retry < SHUFFLE_RETRY; retry++) {",
            "\t\t\t/*",
            "\t\t\t * Pick a random order aligned page in the zone span as",
            "\t\t\t * a swap target. If the selected pfn is a hole, retry",
            "\t\t\t * up to SHUFFLE_RETRY attempts find a random valid pfn",
            "\t\t\t * in the zone.",
            "\t\t\t */",
            "\t\t\tj = z->zone_start_pfn +",
            "\t\t\t\tALIGN_DOWN(get_random_long() % z->spanned_pages,",
            "\t\t\t\t\t\torder_pages);",
            "\t\t\tpage_j = shuffle_valid_page(z, j, order);",
            "\t\t\tif (page_j && page_j != page_i)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (retry >= SHUFFLE_RETRY) {",
            "\t\t\tpr_debug(\"%s: failed to swap %#lx\\n\", __func__, i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Each migratetype corresponds to its own list, make sure the",
            "\t\t * types match otherwise we're moving pages to lists where they",
            "\t\t * do not belong.",
            "\t\t */",
            "\t\tmigratetype = get_pageblock_migratetype(page_i);",
            "\t\tif (get_pageblock_migratetype(page_j) != migratetype) {",
            "\t\t\tpr_debug(\"%s: migratetype mismatch %#lx\\n\", __func__, i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tlist_swap(&page_i->lru, &page_j->lru);",
            "",
            "\t\tpr_debug(\"%s: swap: %#lx -> %#lx\\n\", __func__, i, j);",
            "",
            "\t\t/* take it easy on the zone lock */",
            "\t\tif ((i % (100 * order_pages)) == 0) {",
            "\t\t\tspin_unlock_irqrestore(&z->lock, flags);",
            "\t\t\tcond_resched();",
            "\t\t\tspin_lock_irqsave(&z->lock, flags);",
            "\t\t}",
            "\t}",
            "\tspin_unlock_irqrestore(&z->lock, flags);",
            "}",
            "void __meminit __shuffle_free_memory(pg_data_t *pgdat)",
            "{",
            "\tstruct zone *z;",
            "",
            "\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)",
            "\t\tshuffle_zone(z);",
            "}",
            "bool shuffle_pick_tail(void)",
            "{",
            "\tstatic u64 rand;",
            "\tstatic u8 rand_bits;",
            "\tbool ret;",
            "",
            "\t/*",
            "\t * The lack of locking is deliberate. If 2 threads race to",
            "\t * update the rand state it just adds to the entropy.",
            "\t */",
            "\tif (rand_bits == 0) {",
            "\t\trand_bits = 64;",
            "\t\trand = get_random_u64();",
            "\t}",
            "",
            "\tret = rand & 1;",
            "",
            "\trand_bits--;",
            "\trand >>= 1;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "shuffle_param_set, __shuffle_zone, __shuffle_free_memory, shuffle_pick_tail",
          "description": "shuffle_param_set设置参数并启用/禁用静态键；__shuffle_zone在内存区随机交换页面以打乱物理顺序；__shuffle_free_memory初始化时调用__shuffle_zone；shuffle_pick_tail生成随机布尔值用于选择尾部页",
          "similarity": 0.5728610754013062
        },
        {
          "chunk_id": 0,
          "file_path": "mm/shuffle.c",
          "start_line": 1,
          "end_line": 15,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright(c) 2018 Intel Corporation. All rights reserved.",
            "",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/random.h>",
            "#include <linux/moduleparam.h>",
            "#include \"internal.h\"",
            "#include \"shuffle.h\"",
            "",
            "DEFINE_STATIC_KEY_FALSE(page_alloc_shuffle_key);",
            "",
            "static bool shuffle_param;",
            ""
          ],
          "function_name": null,
          "description": "定义静态键用于控制页面分配随机化功能，并声明参数变量shuffle_param，用于启用或禁用相关机制",
          "similarity": 0.5008167028427124
        }
      ]
    },
    {
      "source_file": "mm/migrate.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:46:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `migrate.c`\n\n---\n\n# migrate.c 技术文档\n\n## 1. 文件概述\n\n`migrate.c` 是 Linux 内核内存管理子系统中实现**页面迁移（Page Migration）**功能的核心文件。该机制最初为支持内存热插拔（Memory Hotplug）而设计，现广泛应用于内存紧缩（Compaction）、NUMA 负载均衡、透明大页（THP）整理、内存碎片整理以及用户空间发起的迁移请求等场景。其核心目标是在不中断应用程序的前提下，将物理页从一个位置安全地迁移到另一个位置，并更新所有对该页的引用。\n\n## 2. 核心功能\n\n### 主要函数\n- `isolate_movable_page()`：尝试隔离一个可移动页面，供迁移使用。\n- `putback_movable_pages()`：将之前隔离但未成功迁移的页面放回其原始 LRU 列表或由驱动程序管理。\n- `isolate_folio_to_list()`：将指定 folio 隔离并加入到给定列表中，支持普通页、可移动页和巨页。\n- `remove_migration_pte()`：在迁移完成后，将页表项（PTE/PMD）中的迁移交换项恢复为指向新物理页的有效页表项。\n\n### 关键数据结构与接口\n- `movable_operations`：定义了可移动页面（如 balloon、ZSMALLOC 等）的驱动回调接口，包括 `isolate_page()` 和 `putback_page()`。\n- `isolate_mode_t`：隔离模式标志，用于控制隔离行为（如 `ISOLATE_UNEVICTABLE`）。\n- 迁移交换项（Migration Swap Entry）：一种特殊的 swap entry，用于在页表中标记正在迁移的页面，保留访问权限、脏位、软脏位等元信息。\n\n## 3. 关键实现\n\n### 页面隔离机制\n- **可移动页识别**：通过 `__folio_test_movable()` 检查 folio 是否属于可移动类型（如 balloon、ZSMALLOC），这类页面不由标准 LRU 管理。\n- **并发安全**：使用 `folio_trylock()` 获取 folio 锁，防止在释放或迁移过程中被重复隔离。通过内存屏障（`smp_rmb()`）确保与 SLAB 分配器的同步。\n- **隔离标记**：成功隔离后设置 `PG_isolated` 标志，防止其他路径误操作。\n\n### 迁移 PTE 处理\n- **元信息保留**：在 `remove_migration_pte()` 中，从旧的迁移 PTE 中提取并重建新 PTE 的属性：\n  - 软脏位（soft-dirty）\n  - 访问/脏位（young/dirty）\n  - 写权限（writable）\n  - 用户态缺页调试写保护（UFFD-WP）\n- **设备私有内存支持**：对 `device_private` 页面（如 GPU 内存），生成特殊的设备私有交换项而非普通 PTE。\n- **巨页支持**：通过 `CONFIG_ARCH_ENABLE_THP_MIGRATION` 支持 PMD 级别的 THP 迁移，调用 `remove_migration_pmd()`。\n\n### 回滚与清理\n- `putback_movable_pages()` 遍历隔离列表，根据页面类型执行不同回滚逻辑：\n  - 巨页：调用 `folio_putback_active_hugetlb()`\n  - 可移动页：调用驱动注册的 `putback_page()` 回调\n  - 普通 LRU 页：减少 `NR_ISOLATED_ANON/FILE` 统计并放回 LRU\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`, `<linux/pagemap.h>`, `<linux/rmap.h>`, `<linux/swap.h>` 等进行页表操作、反向映射、LRU 管理。\n- **特殊内存类型**：\n  - HugeTLB：通过 `hugetlb.h` 和 `hugetlb_cgroup.h` 支持巨页迁移。\n  - KSM：与内核同页合并模块交互。\n  - Balloon：通过 `balloon_compaction.h` 支持 virtio-balloon 内存回收。\n  - Device Private：支持异构内存架构（如 GPU）。\n- **系统设施**：依赖 CPUSET、内存策略（mempolicy）、OOM killer、compaction、userfaultfd 等子系统协同工作。\n- **架构支持**：包含 `asm/tlbflush.h` 用于 TLB 刷新，`CONFIG_ARCH_ENABLE_THP_MIGRATION` 提供架构级 THP 迁移支持。\n\n## 5. 使用场景\n\n- **内存紧缩（Compaction）**：在分配高阶内存失败时，通过迁移页面整理出连续物理内存。\n- **NUMA Balancing**：将进程页面迁移到其运行 CPU 所属的本地 NUMA 节点，提升性能。\n- **内存热移除（Memory Hotplug）**：在移除物理内存前，将其上的活跃页面迁移到其他节点。\n- **用户空间迁移**：通过 `migrate_pages()` 系统调用，允许特权进程主动迁移指定进程的页面。\n- **透明大页（THP）整理**：合并小页为 THP 或拆分 THP 时涉及页面迁移。\n- **内存 Tiering**：在异构内存系统（如 PMEM + DRAM）中，根据访问热度迁移页面。",
      "similarity": 0.5619794726371765,
      "chunks": [
        {
          "chunk_id": 8,
          "file_path": "mm/migrate.c",
          "start_line": 1316,
          "end_line": 1505,
          "content": [
            "static int migrate_folio_move(free_folio_t put_new_folio, unsigned long private,",
            "\t\t\t      struct folio *src, struct folio *dst,",
            "\t\t\t      enum migrate_mode mode, enum migrate_reason reason,",
            "\t\t\t      struct list_head *ret)",
            "{",
            "\tint rc;",
            "\tint old_page_state = 0;",
            "\tstruct anon_vma *anon_vma = NULL;",
            "\tbool is_lru = !__folio_test_movable(src);",
            "\tstruct list_head *prev;",
            "",
            "\t__migrate_folio_extract(dst, &old_page_state, &anon_vma);",
            "\tprev = dst->lru.prev;",
            "\tlist_del(&dst->lru);",
            "",
            "\trc = move_to_new_folio(dst, src, mode);",
            "\tif (rc)",
            "\t\tgoto out;",
            "",
            "\tif (unlikely(!is_lru))",
            "\t\tgoto out_unlock_both;",
            "",
            "\t/*",
            "\t * When successful, push dst to LRU immediately: so that if it",
            "\t * turns out to be an mlocked page, remove_migration_ptes() will",
            "\t * automatically build up the correct dst->mlock_count for it.",
            "\t *",
            "\t * We would like to do something similar for the old page, when",
            "\t * unsuccessful, and other cases when a page has been temporarily",
            "\t * isolated from the unevictable LRU: but this case is the easiest.",
            "\t */",
            "\tfolio_add_lru(dst);",
            "\tif (old_page_state & PAGE_WAS_MLOCKED)",
            "\t\tlru_add_drain();",
            "",
            "\tif (old_page_state & PAGE_WAS_MAPPED)",
            "\t\tremove_migration_ptes(src, dst, false);",
            "",
            "out_unlock_both:",
            "\tfolio_unlock(dst);",
            "\tset_page_owner_migrate_reason(&dst->page, reason);",
            "\t/*",
            "\t * If migration is successful, decrease refcount of dst,",
            "\t * which will not free the page because new page owner increased",
            "\t * refcounter.",
            "\t */",
            "\tfolio_put(dst);",
            "",
            "\t/*",
            "\t * A folio that has been migrated has all references removed",
            "\t * and will be freed.",
            "\t */",
            "\tlist_del(&src->lru);",
            "\t/* Drop an anon_vma reference if we took one */",
            "\tif (anon_vma)",
            "\t\tput_anon_vma(anon_vma);",
            "\tfolio_unlock(src);",
            "\tmigrate_folio_done(src, reason);",
            "",
            "\treturn rc;",
            "out:",
            "\t/*",
            "\t * A folio that has not been migrated will be restored to",
            "\t * right list unless we want to retry.",
            "\t */",
            "\tif (rc == -EAGAIN) {",
            "\t\tlist_add(&dst->lru, prev);",
            "\t\t__migrate_folio_record(dst, old_page_state, anon_vma);",
            "\t\treturn rc;",
            "\t}",
            "",
            "\tmigrate_folio_undo_src(src, old_page_state & PAGE_WAS_MAPPED,",
            "\t\t\t       anon_vma, true, ret);",
            "\tmigrate_folio_undo_dst(dst, true, put_new_folio, private);",
            "",
            "\treturn rc;",
            "}",
            "static int unmap_and_move_huge_page(new_folio_t get_new_folio,",
            "\t\tfree_folio_t put_new_folio, unsigned long private,",
            "\t\tstruct folio *src, int force, enum migrate_mode mode,",
            "\t\tint reason, struct list_head *ret)",
            "{",
            "\tstruct folio *dst;",
            "\tint rc = -EAGAIN;",
            "\tint page_was_mapped = 0;",
            "\tstruct anon_vma *anon_vma = NULL;",
            "\tstruct address_space *mapping = NULL;",
            "",
            "\tif (folio_ref_count(src) == 1) {",
            "\t\t/* page was freed from under us. So we are done. */",
            "\t\tfolio_putback_active_hugetlb(src);",
            "\t\treturn MIGRATEPAGE_SUCCESS;",
            "\t}",
            "",
            "\tdst = get_new_folio(src, private);",
            "\tif (!dst)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (!folio_trylock(src)) {",
            "\t\tif (!force)",
            "\t\t\tgoto out;",
            "\t\tswitch (mode) {",
            "\t\tcase MIGRATE_SYNC:",
            "\t\tcase MIGRATE_SYNC_NO_COPY:",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tfolio_lock(src);",
            "\t}",
            "",
            "\t/*",
            "\t * Check for pages which are in the process of being freed.  Without",
            "\t * folio_mapping() set, hugetlbfs specific move page routine will not",
            "\t * be called and we could leak usage counts for subpools.",
            "\t */",
            "\tif (hugetlb_folio_subpool(src) && !folio_mapping(src)) {",
            "\t\trc = -EBUSY;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tif (folio_test_anon(src))",
            "\t\tanon_vma = folio_get_anon_vma(src);",
            "",
            "\tif (unlikely(!folio_trylock(dst)))",
            "\t\tgoto put_anon;",
            "",
            "\tif (folio_mapped(src)) {",
            "\t\tenum ttu_flags ttu = 0;",
            "",
            "\t\tif (!folio_test_anon(src)) {",
            "\t\t\t/*",
            "\t\t\t * In shared mappings, try_to_unmap could potentially",
            "\t\t\t * call huge_pmd_unshare.  Because of this, take",
            "\t\t\t * semaphore in write mode here and set TTU_RMAP_LOCKED",
            "\t\t\t * to let lower levels know we have taken the lock.",
            "\t\t\t */",
            "\t\t\tmapping = hugetlb_folio_mapping_lock_write(src);",
            "\t\t\tif (unlikely(!mapping))",
            "\t\t\t\tgoto unlock_put_anon;",
            "",
            "\t\t\tttu = TTU_RMAP_LOCKED;",
            "\t\t}",
            "",
            "\t\ttry_to_migrate(src, ttu);",
            "\t\tpage_was_mapped = 1;",
            "",
            "\t\tif (ttu & TTU_RMAP_LOCKED)",
            "\t\t\ti_mmap_unlock_write(mapping);",
            "\t}",
            "",
            "\tif (!folio_mapped(src))",
            "\t\trc = move_to_new_folio(dst, src, mode);",
            "",
            "\tif (page_was_mapped)",
            "\t\tremove_migration_ptes(src,",
            "\t\t\trc == MIGRATEPAGE_SUCCESS ? dst : src, false);",
            "",
            "unlock_put_anon:",
            "\tfolio_unlock(dst);",
            "",
            "put_anon:",
            "\tif (anon_vma)",
            "\t\tput_anon_vma(anon_vma);",
            "",
            "\tif (rc == MIGRATEPAGE_SUCCESS) {",
            "\t\tmove_hugetlb_state(src, dst, reason);",
            "\t\tput_new_folio = NULL;",
            "\t}",
            "",
            "out_unlock:",
            "\tfolio_unlock(src);",
            "out:",
            "\tif (rc == MIGRATEPAGE_SUCCESS)",
            "\t\tfolio_putback_active_hugetlb(src);",
            "\telse if (rc != -EAGAIN)",
            "\t\tlist_move_tail(&src->lru, ret);",
            "",
            "\t/*",
            "\t * If migration was not successful and there's a freeing callback, use",
            "\t * it.  Otherwise, put_page() will drop the reference grabbed during",
            "\t * isolation.",
            "\t */",
            "\tif (put_new_folio)",
            "\t\tput_new_folio(dst, private);",
            "\telse",
            "\t\tfolio_putback_active_hugetlb(dst);",
            "",
            "\treturn rc;",
            "}"
          ],
          "function_name": "migrate_folio_move, unmap_and_move_huge_page",
          "description": "执行实际页面迁移操作，包含大页迁移特殊处理与列表结构调整逻辑",
          "similarity": 0.6867843270301819
        },
        {
          "chunk_id": 5,
          "file_path": "mm/migrate.c",
          "start_line": 694,
          "end_line": 828,
          "content": [
            "void folio_migrate_copy(struct folio *newfolio, struct folio *folio)",
            "{",
            "\tfolio_copy(newfolio, folio);",
            "\tfolio_migrate_flags(newfolio, folio);",
            "}",
            "int migrate_folio_extra(struct address_space *mapping, struct folio *dst,",
            "\t\tstruct folio *src, enum migrate_mode mode, int extra_count)",
            "{",
            "\tint rc;",
            "",
            "\tBUG_ON(folio_test_writeback(src));\t/* Writeback must be complete */",
            "",
            "\trc = folio_migrate_mapping(mapping, dst, src, extra_count);",
            "",
            "\tif (rc != MIGRATEPAGE_SUCCESS)",
            "\t\treturn rc;",
            "",
            "\tif (mode != MIGRATE_SYNC_NO_COPY)",
            "\t\tfolio_migrate_copy(dst, src);",
            "\telse",
            "\t\tfolio_migrate_flags(dst, src);",
            "\treturn MIGRATEPAGE_SUCCESS;",
            "}",
            "int migrate_folio(struct address_space *mapping, struct folio *dst,",
            "\t\tstruct folio *src, enum migrate_mode mode)",
            "{",
            "\treturn migrate_folio_extra(mapping, dst, src, mode, 0);",
            "}",
            "static bool buffer_migrate_lock_buffers(struct buffer_head *head,",
            "\t\t\t\t\t\t\tenum migrate_mode mode)",
            "{",
            "\tstruct buffer_head *bh = head;",
            "\tstruct buffer_head *failed_bh;",
            "",
            "\tdo {",
            "\t\tif (!trylock_buffer(bh)) {",
            "\t\t\tif (mode == MIGRATE_ASYNC)",
            "\t\t\t\tgoto unlock;",
            "\t\t\tif (mode == MIGRATE_SYNC_LIGHT && !buffer_uptodate(bh))",
            "\t\t\t\tgoto unlock;",
            "\t\t\tlock_buffer(bh);",
            "\t\t}",
            "",
            "\t\tbh = bh->b_this_page;",
            "\t} while (bh != head);",
            "",
            "\treturn true;",
            "",
            "unlock:",
            "\t/* We failed to lock the buffer and cannot stall. */",
            "\tfailed_bh = bh;",
            "\tbh = head;",
            "\twhile (bh != failed_bh) {",
            "\t\tunlock_buffer(bh);",
            "\t\tbh = bh->b_this_page;",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static int __buffer_migrate_folio(struct address_space *mapping,",
            "\t\tstruct folio *dst, struct folio *src, enum migrate_mode mode,",
            "\t\tbool check_refs)",
            "{",
            "\tstruct buffer_head *bh, *head;",
            "\tint rc;",
            "\tint expected_count;",
            "",
            "\thead = folio_buffers(src);",
            "\tif (!head)",
            "\t\treturn migrate_folio(mapping, dst, src, mode);",
            "",
            "\t/* Check whether page does not have extra refs before we do more work */",
            "\texpected_count = folio_expected_refs(mapping, src);",
            "\tif (folio_ref_count(src) != expected_count)",
            "\t\treturn -EAGAIN;",
            "",
            "\tif (!buffer_migrate_lock_buffers(head, mode))",
            "\t\treturn -EAGAIN;",
            "",
            "\tif (check_refs) {",
            "\t\tbool busy;",
            "\t\tbool invalidated = false;",
            "",
            "recheck_buffers:",
            "\t\tbusy = false;",
            "\t\tspin_lock(&mapping->private_lock);",
            "\t\tbh = head;",
            "\t\tdo {",
            "\t\t\tif (atomic_read(&bh->b_count)) {",
            "\t\t\t\tbusy = true;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tbh = bh->b_this_page;",
            "\t\t} while (bh != head);",
            "\t\tif (busy) {",
            "\t\t\tif (invalidated) {",
            "\t\t\t\trc = -EAGAIN;",
            "\t\t\t\tgoto unlock_buffers;",
            "\t\t\t}",
            "\t\t\tspin_unlock(&mapping->private_lock);",
            "\t\t\tinvalidate_bh_lrus();",
            "\t\t\tinvalidated = true;",
            "\t\t\tgoto recheck_buffers;",
            "\t\t}",
            "\t}",
            "",
            "\trc = folio_migrate_mapping(mapping, dst, src, 0);",
            "\tif (rc != MIGRATEPAGE_SUCCESS)",
            "\t\tgoto unlock_buffers;",
            "",
            "\tfolio_attach_private(dst, folio_detach_private(src));",
            "",
            "\tbh = head;",
            "\tdo {",
            "\t\tfolio_set_bh(bh, dst, bh_offset(bh));",
            "\t\tbh = bh->b_this_page;",
            "\t} while (bh != head);",
            "",
            "\tif (mode != MIGRATE_SYNC_NO_COPY)",
            "\t\tfolio_migrate_copy(dst, src);",
            "\telse",
            "\t\tfolio_migrate_flags(dst, src);",
            "",
            "\trc = MIGRATEPAGE_SUCCESS;",
            "unlock_buffers:",
            "\tif (check_refs)",
            "\t\tspin_unlock(&mapping->private_lock);",
            "\tbh = head;",
            "\tdo {",
            "\t\tunlock_buffer(bh);",
            "\t\tbh = bh->b_this_page;",
            "\t} while (bh != head);",
            "",
            "\treturn rc;",
            "}"
          ],
          "function_name": "folio_migrate_copy, migrate_folio_extra, migrate_folio, buffer_migrate_lock_buffers, __buffer_migrate_folio",
          "description": "实现页面迁移时的数据复制与标志迁移，处理缓冲区锁定及迁移逻辑",
          "similarity": 0.6527427434921265
        },
        {
          "chunk_id": 6,
          "file_path": "mm/migrate.c",
          "start_line": 869,
          "end_line": 1034,
          "content": [
            "int buffer_migrate_folio(struct address_space *mapping,",
            "\t\tstruct folio *dst, struct folio *src, enum migrate_mode mode)",
            "{",
            "\treturn __buffer_migrate_folio(mapping, dst, src, mode, false);",
            "}",
            "int buffer_migrate_folio_norefs(struct address_space *mapping,",
            "\t\tstruct folio *dst, struct folio *src, enum migrate_mode mode)",
            "{",
            "\treturn __buffer_migrate_folio(mapping, dst, src, mode, true);",
            "}",
            "int filemap_migrate_folio(struct address_space *mapping,",
            "\t\tstruct folio *dst, struct folio *src, enum migrate_mode mode)",
            "{",
            "\tint ret;",
            "",
            "\tret = folio_migrate_mapping(mapping, dst, src, 0);",
            "\tif (ret != MIGRATEPAGE_SUCCESS)",
            "\t\treturn ret;",
            "",
            "\tif (folio_get_private(src))",
            "\t\tfolio_attach_private(dst, folio_detach_private(src));",
            "",
            "\tif (mode != MIGRATE_SYNC_NO_COPY)",
            "\t\tfolio_migrate_copy(dst, src);",
            "\telse",
            "\t\tfolio_migrate_flags(dst, src);",
            "\treturn MIGRATEPAGE_SUCCESS;",
            "}",
            "static int writeout(struct address_space *mapping, struct folio *folio)",
            "{",
            "\tstruct writeback_control wbc = {",
            "\t\t.sync_mode = WB_SYNC_NONE,",
            "\t\t.nr_to_write = 1,",
            "\t\t.range_start = 0,",
            "\t\t.range_end = LLONG_MAX,",
            "\t\t.for_reclaim = 1",
            "\t};",
            "\tint rc;",
            "",
            "\tif (!mapping->a_ops->writepage)",
            "\t\t/* No write method for the address space */",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!folio_clear_dirty_for_io(folio))",
            "\t\t/* Someone else already triggered a write */",
            "\t\treturn -EAGAIN;",
            "",
            "\t/*",
            "\t * A dirty folio may imply that the underlying filesystem has",
            "\t * the folio on some queue. So the folio must be clean for",
            "\t * migration. Writeout may mean we lose the lock and the",
            "\t * folio state is no longer what we checked for earlier.",
            "\t * At this point we know that the migration attempt cannot",
            "\t * be successful.",
            "\t */",
            "\tremove_migration_ptes(folio, folio, false);",
            "",
            "\trc = mapping->a_ops->writepage(&folio->page, &wbc);",
            "",
            "\tif (rc != AOP_WRITEPAGE_ACTIVATE)",
            "\t\t/* unlocked. Relock */",
            "\t\tfolio_lock(folio);",
            "",
            "\treturn (rc < 0) ? -EIO : -EAGAIN;",
            "}",
            "static int fallback_migrate_folio(struct address_space *mapping,",
            "\t\tstruct folio *dst, struct folio *src, enum migrate_mode mode)",
            "{",
            "\tif (folio_test_dirty(src)) {",
            "\t\t/* Only writeback folios in full synchronous migration */",
            "\t\tswitch (mode) {",
            "\t\tcase MIGRATE_SYNC:",
            "\t\tcase MIGRATE_SYNC_NO_COPY:",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\treturn -EBUSY;",
            "\t\t}",
            "\t\treturn writeout(mapping, src);",
            "\t}",
            "",
            "\t/*",
            "\t * Buffers may be managed in a filesystem specific way.",
            "\t * We must have no buffers or drop them.",
            "\t */",
            "\tif (!filemap_release_folio(src, GFP_KERNEL))",
            "\t\treturn mode == MIGRATE_SYNC ? -EAGAIN : -EBUSY;",
            "",
            "\treturn migrate_folio(mapping, dst, src, mode);",
            "}",
            "static int move_to_new_folio(struct folio *dst, struct folio *src,",
            "\t\t\t\tenum migrate_mode mode)",
            "{",
            "\tint rc = -EAGAIN;",
            "\tbool is_lru = !__folio_test_movable(src);",
            "",
            "\tVM_BUG_ON_FOLIO(!folio_test_locked(src), src);",
            "\tVM_BUG_ON_FOLIO(!folio_test_locked(dst), dst);",
            "",
            "\tif (likely(is_lru)) {",
            "\t\tstruct address_space *mapping = folio_mapping(src);",
            "",
            "\t\tif (!mapping)",
            "\t\t\trc = migrate_folio(mapping, dst, src, mode);",
            "\t\telse if (mapping_inaccessible(mapping))",
            "\t\t\trc = -EOPNOTSUPP;",
            "\t\telse if (mapping->a_ops->migrate_folio)",
            "\t\t\t/*",
            "\t\t\t * Most folios have a mapping and most filesystems",
            "\t\t\t * provide a migrate_folio callback. Anonymous folios",
            "\t\t\t * are part of swap space which also has its own",
            "\t\t\t * migrate_folio callback. This is the most common path",
            "\t\t\t * for page migration.",
            "\t\t\t */",
            "\t\t\trc = mapping->a_ops->migrate_folio(mapping, dst, src,",
            "\t\t\t\t\t\t\t\tmode);",
            "\t\telse",
            "\t\t\trc = fallback_migrate_folio(mapping, dst, src, mode);",
            "\t} else {",
            "\t\tconst struct movable_operations *mops;",
            "",
            "\t\t/*",
            "\t\t * In case of non-lru page, it could be released after",
            "\t\t * isolation step. In that case, we shouldn't try migration.",
            "\t\t */",
            "\t\tVM_BUG_ON_FOLIO(!folio_test_isolated(src), src);",
            "\t\tif (!folio_test_movable(src)) {",
            "\t\t\trc = MIGRATEPAGE_SUCCESS;",
            "\t\t\tfolio_clear_isolated(src);",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tmops = folio_movable_ops(src);",
            "\t\trc = mops->migrate_page(&dst->page, &src->page, mode);",
            "\t\tWARN_ON_ONCE(rc == MIGRATEPAGE_SUCCESS &&",
            "\t\t\t\t!folio_test_isolated(src));",
            "\t}",
            "",
            "\t/*",
            "\t * When successful, old pagecache src->mapping must be cleared before",
            "\t * src is freed; but stats require that PageAnon be left as PageAnon.",
            "\t */",
            "\tif (rc == MIGRATEPAGE_SUCCESS) {",
            "\t\tif (__folio_test_movable(src)) {",
            "\t\t\tVM_BUG_ON_FOLIO(!folio_test_isolated(src), src);",
            "",
            "\t\t\t/*",
            "\t\t\t * We clear PG_movable under page_lock so any compactor",
            "\t\t\t * cannot try to migrate this page.",
            "\t\t\t */",
            "\t\t\tfolio_clear_isolated(src);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Anonymous and movable src->mapping will be cleared by",
            "\t\t * free_pages_prepare so don't reset it here for keeping",
            "\t\t * the type to work PageAnon, for example.",
            "\t\t */",
            "\t\tif (!folio_mapping_flags(src))",
            "\t\t\tsrc->mapping = NULL;",
            "",
            "\t\tif (likely(!folio_is_zone_device(dst)))",
            "\t\t\tflush_dcache_folio(dst);",
            "\t}",
            "out:",
            "\treturn rc;",
            "}"
          ],
          "function_name": "buffer_migrate_folio, buffer_migrate_folio_norefs, filemap_migrate_folio, writeout, fallback_migrate_folio, move_to_new_folio",
          "description": "处理文件映射页面迁移，包含脏页写回、后备迁移策略及页面状态转移逻辑",
          "similarity": 0.6461219787597656
        },
        {
          "chunk_id": 15,
          "file_path": "mm/migrate.c",
          "start_line": 2559,
          "end_line": 2665,
          "content": [
            "static bool migrate_balanced_pgdat(struct pglist_data *pgdat,",
            "\t\t\t\t   unsigned long nr_migrate_pages)",
            "{",
            "\tint z;",
            "",
            "\tfor (z = pgdat->nr_zones - 1; z >= 0; z--) {",
            "\t\tstruct zone *zone = pgdat->node_zones + z;",
            "",
            "\t\tif (!managed_zone(zone))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Avoid waking kswapd by allocating pages_to_migrate pages. */",
            "\t\tif (!zone_watermark_ok(zone, 0,",
            "\t\t\t\t       high_wmark_pages(zone) +",
            "\t\t\t\t       nr_migrate_pages,",
            "\t\t\t\t       ZONE_MOVABLE, 0))",
            "\t\t\tcontinue;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "int migrate_misplaced_folio_prepare(struct folio *folio,",
            "\t\tstruct vm_area_struct *vma, int node)",
            "{",
            "\tint nr_pages = folio_nr_pages(folio);",
            "\tpg_data_t *pgdat = NODE_DATA(node);",
            "",
            "\tif (folio_is_file_lru(folio)) {",
            "\t\t/*",
            "\t\t * Do not migrate file folios that are mapped in multiple",
            "\t\t * processes with execute permissions as they are probably",
            "\t\t * shared libraries.",
            "\t\t *",
            "\t\t * See folio_likely_mapped_shared() on possible imprecision",
            "\t\t * when we cannot easily detect if a folio is shared.",
            "\t\t */",
            "\t\tif ((vma->vm_flags & VM_EXEC) &&",
            "\t\t    folio_likely_mapped_shared(folio))",
            "\t\t\treturn -EACCES;",
            "",
            "\t\t/*",
            "\t\t * Do not migrate dirty folios as not all filesystems can move",
            "\t\t * dirty folios in MIGRATE_ASYNC mode which is a waste of",
            "\t\t * cycles.",
            "\t\t */",
            "\t\tif (folio_test_dirty(folio))",
            "\t\t\treturn -EAGAIN;",
            "\t}",
            "",
            "\t/* Avoid migrating to a node that is nearly full */",
            "\tif (!migrate_balanced_pgdat(pgdat, nr_pages)) {",
            "\t\tint z;",
            "",
            "\t\tif (!(sysctl_numa_balancing_mode & NUMA_BALANCING_MEMORY_TIERING))",
            "\t\t\treturn -EAGAIN;",
            "\t\tfor (z = pgdat->nr_zones - 1; z >= 0; z--) {",
            "\t\t\tif (managed_zone(pgdat->node_zones + z))",
            "\t\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * If there are no managed zones, it should not proceed",
            "\t\t * further.",
            "\t\t */",
            "\t\tif (z < 0)",
            "\t\t\treturn -EAGAIN;",
            "",
            "\t\twakeup_kswapd(pgdat->node_zones + z, 0,",
            "\t\t\t      folio_order(folio), ZONE_MOVABLE);",
            "\t\treturn -EAGAIN;",
            "\t}",
            "",
            "\tif (!folio_isolate_lru(folio))",
            "\t\treturn -EAGAIN;",
            "",
            "\tnode_stat_mod_folio(folio, NR_ISOLATED_ANON + folio_is_file_lru(folio),",
            "\t\t\t    nr_pages);",
            "\treturn 0;",
            "}",
            "int migrate_misplaced_folio(struct folio *folio, struct vm_area_struct *vma,",
            "\t\t\t    int node)",
            "{",
            "\tpg_data_t *pgdat = NODE_DATA(node);",
            "\tint nr_remaining;",
            "\tunsigned int nr_succeeded;",
            "\tLIST_HEAD(migratepages);",
            "\tstruct mem_cgroup *memcg = get_mem_cgroup_from_folio(folio);",
            "\tstruct lruvec *lruvec = mem_cgroup_lruvec(memcg, pgdat);",
            "",
            "\tlist_add(&folio->lru, &migratepages);",
            "\tnr_remaining = migrate_pages(&migratepages, alloc_misplaced_dst_folio,",
            "\t\t\t\t     NULL, node, MIGRATE_ASYNC,",
            "\t\t\t\t     MR_NUMA_MISPLACED, &nr_succeeded);",
            "\tif (nr_remaining && !list_empty(&migratepages))",
            "\t\tputback_movable_pages(&migratepages);",
            "\tif (nr_succeeded) {",
            "\t\tcount_vm_numa_events(NUMA_PAGE_MIGRATE, nr_succeeded);",
            "\t\tcount_memcg_events(memcg, NUMA_PAGE_MIGRATE, nr_succeeded);",
            "\t\tif ((sysctl_numa_balancing_mode & NUMA_BALANCING_MEMORY_TIERING)",
            "\t\t    && !node_is_toptier(folio_nid(folio))",
            "\t\t    && node_is_toptier(node))",
            "\t\t\tmod_lruvec_state(lruvec, PGPROMOTE_SUCCESS, nr_succeeded);",
            "\t}",
            "\tmem_cgroup_put(memcg);",
            "\tBUG_ON(!list_empty(&migratepages));",
            "\treturn nr_remaining ? -EAGAIN : 0;",
            "}"
          ],
          "function_name": "migrate_balanced_pgdat, migrate_misplaced_folio_prepare, migrate_misplaced_folio",
          "description": "该代码段实现了NUMA架构下页面迁移的辅助逻辑，包含三个关键函数：  \n1. `migrate_balanced_pgdat` 判断目标节点的zone是否具备足够的可用内存以支持迁移操作，避免触发kswapd唤醒；  \n2. `migrate_misplaced_folio_prepare` 准备迁移不适当页面（如共享库、脏页等），并根据节点负载决定是否唤醒kswapd；  \n3. `migrate_misplaced_folio` 执行实际迁移，通过`migrate_pages`接口完成跨节点页面移动，并更新统计信息。  \n注：代码上下文不完整，部分依赖函数（如`alloc_misplaced_dst_folio`）未展示。",
          "similarity": 0.6076277494430542
        },
        {
          "chunk_id": 10,
          "file_path": "mm/migrate.c",
          "start_line": 1671,
          "end_line": 1914,
          "content": [
            "static int migrate_pages_batch(struct list_head *from,",
            "\t\tnew_folio_t get_new_folio, free_folio_t put_new_folio,",
            "\t\tunsigned long private, enum migrate_mode mode, int reason,",
            "\t\tstruct list_head *ret_folios, struct list_head *split_folios,",
            "\t\tstruct migrate_pages_stats *stats, int nr_pass)",
            "{",
            "\tint retry = 1;",
            "\tint thp_retry = 1;",
            "\tint nr_failed = 0;",
            "\tint nr_retry_pages = 0;",
            "\tint pass = 0;",
            "\tbool is_thp = false;",
            "\tbool is_large = false;",
            "\tstruct folio *folio, *folio2, *dst = NULL, *dst2;",
            "\tint rc, rc_saved = 0, nr_pages;",
            "\tLIST_HEAD(unmap_folios);",
            "\tLIST_HEAD(dst_folios);",
            "\tbool nosplit = (reason == MR_NUMA_MISPLACED);",
            "",
            "\tVM_WARN_ON_ONCE(mode != MIGRATE_ASYNC &&",
            "\t\t\t!list_empty(from) && !list_is_singular(from));",
            "",
            "\tfor (pass = 0; pass < nr_pass && retry; pass++) {",
            "\t\tretry = 0;",
            "\t\tthp_retry = 0;",
            "\t\tnr_retry_pages = 0;",
            "",
            "\t\tlist_for_each_entry_safe(folio, folio2, from, lru) {",
            "\t\t\tis_large = folio_test_large(folio);",
            "\t\t\tis_thp = is_large && folio_test_pmd_mappable(folio);",
            "\t\t\tnr_pages = folio_nr_pages(folio);",
            "",
            "\t\t\tcond_resched();",
            "",
            "\t\t\t/*",
            "\t\t\t * The rare folio on the deferred split list should",
            "\t\t\t * be split now. It should not count as a failure:",
            "\t\t\t * but increment nr_failed because, without doing so,",
            "\t\t\t * migrate_pages() may report success with (split but",
            "\t\t\t * unmigrated) pages still on its fromlist; whereas it",
            "\t\t\t * always reports success when its fromlist is empty.",
            "\t\t\t * stats->nr_thp_failed should be increased too,",
            "\t\t\t * otherwise stats inconsistency will happen when",
            "\t\t\t * migrate_pages_batch is called via migrate_pages()",
            "\t\t\t * with MIGRATE_SYNC and MIGRATE_ASYNC.",
            "\t\t\t *",
            "\t\t\t * Only check it without removing it from the list.",
            "\t\t\t * Since the folio can be on deferred_split_scan()",
            "\t\t\t * local list and removing it can cause the local list",
            "\t\t\t * corruption. Folio split process below can handle it",
            "\t\t\t * with the help of folio_ref_freeze().",
            "\t\t\t *",
            "\t\t\t * nr_pages > 2 is needed to avoid checking order-1",
            "\t\t\t * page cache folios. They exist, in contrast to",
            "\t\t\t * non-existent order-1 anonymous folios, and do not",
            "\t\t\t * use _deferred_list.",
            "\t\t\t */",
            "\t\t\tif (nr_pages > 2 &&",
            "\t\t\t   !list_empty(&folio->_deferred_list)) {",
            "\t\t\t\tif (!try_split_folio(folio, split_folios, mode)) {",
            "\t\t\t\t\tnr_failed++;",
            "\t\t\t\t\tstats->nr_thp_failed += is_thp;",
            "\t\t\t\t\tstats->nr_thp_split += is_thp;",
            "\t\t\t\t\tstats->nr_split++;",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t}",
            "",
            "\t\t\t/*",
            "\t\t\t * Large folio migration might be unsupported or",
            "\t\t\t * the allocation might be failed so we should retry",
            "\t\t\t * on the same folio with the large folio split",
            "\t\t\t * to normal folios.",
            "\t\t\t *",
            "\t\t\t * Split folios are put in split_folios, and",
            "\t\t\t * we will migrate them after the rest of the",
            "\t\t\t * list is processed.",
            "\t\t\t */",
            "\t\t\tif (!thp_migration_supported() && is_thp) {",
            "\t\t\t\tnr_failed++;",
            "\t\t\t\tstats->nr_thp_failed++;",
            "\t\t\t\tif (!try_split_folio(folio, split_folios, mode)) {",
            "\t\t\t\t\tstats->nr_thp_split++;",
            "\t\t\t\t\tstats->nr_split++;",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t\tstats->nr_failed_pages += nr_pages;",
            "\t\t\t\tlist_move_tail(&folio->lru, ret_folios);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\trc = migrate_folio_unmap(get_new_folio, put_new_folio,",
            "\t\t\t\t\tprivate, folio, &dst, mode, reason,",
            "\t\t\t\t\tret_folios);",
            "\t\t\t/*",
            "\t\t\t * The rules are:",
            "\t\t\t *\tSuccess: folio will be freed",
            "\t\t\t *\tUnmap: folio will be put on unmap_folios list,",
            "\t\t\t *\t       dst folio put on dst_folios list",
            "\t\t\t *\t-EAGAIN: stay on the from list",
            "\t\t\t *\t-ENOMEM: stay on the from list",
            "\t\t\t *\tOther errno: put on ret_folios list",
            "\t\t\t */",
            "\t\t\tswitch(rc) {",
            "\t\t\tcase -ENOMEM:",
            "\t\t\t\t/*",
            "\t\t\t\t * When memory is low, don't bother to try to migrate",
            "\t\t\t\t * other folios, move unmapped folios, then exit.",
            "\t\t\t\t */",
            "\t\t\t\tnr_failed++;",
            "\t\t\t\tstats->nr_thp_failed += is_thp;",
            "\t\t\t\t/* Large folio NUMA faulting doesn't split to retry. */",
            "\t\t\t\tif (is_large && !nosplit) {",
            "\t\t\t\t\tint ret = try_split_folio(folio, split_folios, mode);",
            "",
            "\t\t\t\t\tif (!ret) {",
            "\t\t\t\t\t\tstats->nr_thp_split += is_thp;",
            "\t\t\t\t\t\tstats->nr_split++;",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t} else if (reason == MR_LONGTERM_PIN &&",
            "\t\t\t\t\t\t   ret == -EAGAIN) {",
            "\t\t\t\t\t\t/*",
            "\t\t\t\t\t\t * Try again to split large folio to",
            "\t\t\t\t\t\t * mitigate the failure of longterm pinning.",
            "\t\t\t\t\t\t */",
            "\t\t\t\t\t\tretry++;",
            "\t\t\t\t\t\tthp_retry += is_thp;",
            "\t\t\t\t\t\tnr_retry_pages += nr_pages;",
            "\t\t\t\t\t\t/* Undo duplicated failure counting. */",
            "\t\t\t\t\t\tnr_failed--;",
            "\t\t\t\t\t\tstats->nr_thp_failed -= is_thp;",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "",
            "\t\t\t\tstats->nr_failed_pages += nr_pages + nr_retry_pages;",
            "\t\t\t\t/* nr_failed isn't updated for not used */",
            "\t\t\t\tstats->nr_thp_failed += thp_retry;",
            "\t\t\t\trc_saved = rc;",
            "\t\t\t\tif (list_empty(&unmap_folios))",
            "\t\t\t\t\tgoto out;",
            "\t\t\t\telse",
            "\t\t\t\t\tgoto move;",
            "\t\t\tcase -EAGAIN:",
            "\t\t\t\tretry++;",
            "\t\t\t\tthp_retry += is_thp;",
            "\t\t\t\tnr_retry_pages += nr_pages;",
            "\t\t\t\tbreak;",
            "\t\t\tcase MIGRATEPAGE_SUCCESS:",
            "\t\t\t\tstats->nr_succeeded += nr_pages;",
            "\t\t\t\tstats->nr_thp_succeeded += is_thp;",
            "\t\t\t\tbreak;",
            "\t\t\tcase MIGRATEPAGE_UNMAP:",
            "\t\t\t\tlist_move_tail(&folio->lru, &unmap_folios);",
            "\t\t\t\tlist_add_tail(&dst->lru, &dst_folios);",
            "\t\t\t\tbreak;",
            "\t\t\tdefault:",
            "\t\t\t\t/*",
            "\t\t\t\t * Permanent failure (-EBUSY, etc.):",
            "\t\t\t\t * unlike -EAGAIN case, the failed folio is",
            "\t\t\t\t * removed from migration folio list and not",
            "\t\t\t\t * retried in the next outer loop.",
            "\t\t\t\t */",
            "\t\t\t\tnr_failed++;",
            "\t\t\t\tstats->nr_thp_failed += is_thp;",
            "\t\t\t\tstats->nr_failed_pages += nr_pages;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tnr_failed += retry;",
            "\tstats->nr_thp_failed += thp_retry;",
            "\tstats->nr_failed_pages += nr_retry_pages;",
            "move:",
            "\t/* Flush TLBs for all unmapped folios */",
            "\ttry_to_unmap_flush();",
            "",
            "\tretry = 1;",
            "\tfor (pass = 0; pass < nr_pass && retry; pass++) {",
            "\t\tretry = 0;",
            "\t\tthp_retry = 0;",
            "\t\tnr_retry_pages = 0;",
            "",
            "\t\tdst = list_first_entry(&dst_folios, struct folio, lru);",
            "\t\tdst2 = list_next_entry(dst, lru);",
            "\t\tlist_for_each_entry_safe(folio, folio2, &unmap_folios, lru) {",
            "\t\t\tis_thp = folio_test_large(folio) && folio_test_pmd_mappable(folio);",
            "\t\t\tnr_pages = folio_nr_pages(folio);",
            "",
            "\t\t\tcond_resched();",
            "",
            "\t\t\trc = migrate_folio_move(put_new_folio, private,",
            "\t\t\t\t\t\tfolio, dst, mode,",
            "\t\t\t\t\t\treason, ret_folios);",
            "\t\t\t/*",
            "\t\t\t * The rules are:",
            "\t\t\t *\tSuccess: folio will be freed",
            "\t\t\t *\t-EAGAIN: stay on the unmap_folios list",
            "\t\t\t *\tOther errno: put on ret_folios list",
            "\t\t\t */",
            "\t\t\tswitch(rc) {",
            "\t\t\tcase -EAGAIN:",
            "\t\t\t\tretry++;",
            "\t\t\t\tthp_retry += is_thp;",
            "\t\t\t\tnr_retry_pages += nr_pages;",
            "\t\t\t\tbreak;",
            "\t\t\tcase MIGRATEPAGE_SUCCESS:",
            "\t\t\t\tstats->nr_succeeded += nr_pages;",
            "\t\t\t\tstats->nr_thp_succeeded += is_thp;",
            "\t\t\t\tbreak;",
            "\t\t\tdefault:",
            "\t\t\t\tnr_failed++;",
            "\t\t\t\tstats->nr_thp_failed += is_thp;",
            "\t\t\t\tstats->nr_failed_pages += nr_pages;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tdst = dst2;",
            "\t\t\tdst2 = list_next_entry(dst, lru);",
            "\t\t}",
            "\t}",
            "\tnr_failed += retry;",
            "\tstats->nr_thp_failed += thp_retry;",
            "\tstats->nr_failed_pages += nr_retry_pages;",
            "",
            "\trc = rc_saved ? : nr_failed;",
            "out:",
            "\t/* Cleanup remaining folios */",
            "\tdst = list_first_entry(&dst_folios, struct folio, lru);",
            "\tdst2 = list_next_entry(dst, lru);",
            "\tlist_for_each_entry_safe(folio, folio2, &unmap_folios, lru) {",
            "\t\tint old_page_state = 0;",
            "\t\tstruct anon_vma *anon_vma = NULL;",
            "",
            "\t\t__migrate_folio_extract(dst, &old_page_state, &anon_vma);",
            "\t\tmigrate_folio_undo_src(folio, old_page_state & PAGE_WAS_MAPPED,",
            "\t\t\t\t       anon_vma, true, ret_folios);",
            "\t\tlist_del(&dst->lru);",
            "\t\tmigrate_folio_undo_dst(dst, true, put_new_folio, private);",
            "\t\tdst = dst2;",
            "\t\tdst2 = list_next_entry(dst, lru);",
            "\t}",
            "",
            "\treturn rc;",
            "}"
          ],
          "function_name": "migrate_pages_batch",
          "description": "实现批量迁移页面逻辑，支持大页分裂与异步迁移模式，通过循环处理页表项并根据迁移结果更新统计信息，包括成功/失败计数及THP相关指标。",
          "similarity": 0.6068794131278992
        }
      ]
    },
    {
      "source_file": "mm/page_io.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:03:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page_io.c`\n\n---\n\n# page_io.c 技术文档\n\n## 1. 文件概述\n\n`page_io.c` 是 Linux 内核内存管理子系统中负责页面交换 I/O 操作的核心文件。该文件实现了将匿名页写入交换设备（swap-out）和从交换设备读回内存（swap-in）的底层机制，包括基于 `bio` 的块设备交换路径和基于文件系统的直接 I/O 交换路径。此外，还提供了通用的交换文件激活逻辑，用于在启用交换文件时构建物理块到交换页的映射。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `__end_swap_bio_write()` / `end_swap_bio_write()`：处理交换写操作完成的回调，处理写错误并结束写回。\n- `__end_swap_bio_read()` / `end_swap_bio_read()`：处理交换读操作完成的回调，设置页面 uptodate 状态或报告读错误。\n- `generic_swapfile_activate()`：为基于文件的交换设备（如 swapfile）构建连续的物理块映射，填充 `swap_info_struct`。\n- `swap_writepage()`：页面写回交换区的主入口函数，支持 zswap 压缩缓存、内存控制组限制等特性。\n- `swap_writepage_fs()`：通过文件系统直接 I/O 路径（如 swap-over-NFS）执行交换写操作。\n- `sio_pool_init()`：初始化用于异步交换 I/O 的内存池。\n- `sio_write_complete()`：处理基于 kiocb 的异步交换写完成回调。\n\n### 关键数据结构\n\n- `struct swap_iocb`：封装用于文件系统交换 I/O 的 `kiocb` 和 `bio_vec` 数组，支持批量交换页写入。\n- `sio_pool`：`mempool_t` 类型的内存池，用于分配 `swap_iocb` 结构，避免高内存压力下分配失败。\n\n## 3. 关键实现\n\n### 交换 I/O 完成处理\n- 写操作失败时，页面被重新标记为 dirty 并清除 `PG_reclaim` 标志，防止被错误回收，同时输出限频警告日志。\n- 读操作失败仅输出警告；成功则设置 `PG_uptodate` 并解锁页面。\n\n### 交换文件激活 (`generic_swapfile_activate`)\n- 遍历交换文件的逻辑块，使用 `bmap()` 获取物理块号。\n- 验证每个 PAGE_SIZE 对齐区域的物理块是否连续且对齐。\n- 通过 `add_swap_extent()` 将有效的交换页范围注册到交换子系统。\n- 计算交换空间的物理跨度（`span`），用于优化交换分配策略。\n\n### 交换写入路径选择\n- 默认使用 `__swap_writepage()`（基于 `bio` 的块设备路径）。\n- 若启用了 zswap 且压缩存储成功，则跳过磁盘 I/O。\n- 若内存控制组禁用 zswap 回写，则返回 `AOP_WRITEPAGE_ACTIVATE` 以保留页面在内存中。\n- 对于 NFS 等不支持 `bmap` 的文件系统，使用 `swap_writepage_fs()` 路径，通过 `kiocb` 异步 DIO 写入。\n\n### 异步交换 I/O 批处理\n- `swap_writepage_fs()` 支持通过 `wbc->swap_plug` 合并多个相邻页面的写请求到同一个 `swap_iocb`。\n- 利用 `mempool` 保证在内存紧张时仍能分配 I/O 控制块。\n- 完成回调中处理部分写入错误，标记所有相关页面为 dirty 并结束写回。\n\n### 资源统计与控制\n- 通过 `count_swpout_vm_event()` 更新透明大页（THP）和普通页的交换出计数。\n- 在配置了 MEMCG 和 BLK_CGROUP 时，通过 `bio_associate_blkg_from_page()` 将 I/O 请求关联到页面所属的 blkcg，实现 I/O 资源隔离。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/swap.h>`、`<linux/pagemap.h>` 等，与页面回收、反向映射、内存控制组紧密集成。\n- **块设备层**：通过 `<linux/bio.h>`、`<linux/blkdev.h>` 与块 I/O 子系统交互。\n- **文件系统接口**：使用 `bmap()` 和 `kiocb` 与具体文件系统（如 ext4、xfs）或网络文件系统（如 NFS）协作。\n- **压缩子系统**：集成 `<linux/zswap.h>`，支持透明压缩交换缓存。\n- **资源控制器**：依赖 MEMCG 和 BLK_CGROUP 实现内存与 I/O 的多租户隔离。\n- **内部头文件**：包含本地 `\"swap.h\"` 获取交换子系统私有接口。\n\n## 5. 使用场景\n\n- **系统内存不足时**：页面回收机制调用 `swap_writepage()` 将匿名页换出到交换设备。\n- **启用交换文件时**：`swapon` 系统调用执行 `generic_swapfile_activate()` 初始化交换文件的物理布局。\n- **从交换区缺页中断**：当访问已换出页面时，内核通过 `end_swap_bio_read` 路径将数据读回内存。\n- **容器环境**：在启用内存和 I/O 控制组的系统中，确保交换 I/O 正确归属到对应 cgroup。\n- **使用压缩交换缓存**：当 zswap 启用时，优先尝试压缩页面而非立即写入慢速交换设备。\n- **网络交换场景**：在无本地块设备的环境中（如云实例使用 NFS 作为交换后端），通过 `swap_writepage_fs()` 路径完成交换。",
      "similarity": 0.5585793852806091,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/page_io.c",
          "start_line": 1,
          "end_line": 29,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  linux/mm/page_io.c",
            " *",
            " *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds",
            " *",
            " *  Swap reorganised 29.12.95, ",
            " *  Asynchronous swapping added 30.12.95. Stephen Tweedie",
            " *  Removed race in async swapping. 14.4.1996. Bruno Haible",
            " *  Add swap of shared pages through the page cache. 20.2.1998. Stephen Tweedie",
            " *  Always use brw_page, life becomes simpler. 12 May 1998 Eric Biederman",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swapops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/psi.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/zswap.h>",
            "#include \"swap.h\"",
            ""
          ],
          "function_name": null,
          "description": "声明头文件并引入交换页面管理模块的基本依赖，为后续交换操作提供基础框架。",
          "similarity": 0.5734313726425171
        },
        {
          "chunk_id": 5,
          "file_path": "mm/page_io.c",
          "start_line": 543,
          "end_line": 553,
          "content": [
            "void __swap_read_unplug(struct swap_iocb *sio)",
            "{",
            "\tstruct iov_iter from;",
            "\tstruct address_space *mapping = sio->iocb.ki_filp->f_mapping;",
            "\tint ret;",
            "",
            "\tiov_iter_bvec(&from, ITER_DEST, sio->bvec, sio->pages, sio->len);",
            "\tret = mapping->a_ops->swap_rw(&sio->iocb, &from);",
            "\tif (ret != -EIOCBQUEUED)",
            "\t\tsio_read_complete(&sio->iocb, ret);",
            "}"
          ],
          "function_name": "__swap_read_unplug",
          "description": "该函数是处理交换读取操作的关键函数，在页置换过程中将从交换设备读取的数据通过I/O向量传递至文件地址空间。  \n它通过构建iov_iter并调用address_space的a_ops->swap_rw接口进行实际的数据读取，并根据返回状态触发相应的完成回调。  \n注：swap_rw的具体实现依赖于对应文件系统的a_ops，此处上下文不完整。",
          "similarity": 0.5678873062133789
        },
        {
          "chunk_id": 3,
          "file_path": "mm/page_io.c",
          "start_line": 298,
          "end_line": 400,
          "content": [
            "static void swap_writepage_fs(struct folio *folio, struct writeback_control *wbc)",
            "{",
            "\tstruct swap_iocb *sio = NULL;",
            "\tstruct swap_info_struct *sis = swp_swap_info(folio->swap);",
            "\tstruct file *swap_file = sis->swap_file;",
            "\tloff_t pos = folio_file_pos(folio);",
            "",
            "\tcount_swpout_vm_event(folio);",
            "\tfolio_start_writeback(folio);",
            "\tfolio_unlock(folio);",
            "\tif (wbc->swap_plug)",
            "\t\tsio = *wbc->swap_plug;",
            "\tif (sio) {",
            "\t\tif (sio->iocb.ki_filp != swap_file ||",
            "\t\t    sio->iocb.ki_pos + sio->len != pos) {",
            "\t\t\tswap_write_unplug(sio);",
            "\t\t\tsio = NULL;",
            "\t\t}",
            "\t}",
            "\tif (!sio) {",
            "\t\tsio = mempool_alloc(sio_pool, GFP_NOIO);",
            "\t\tinit_sync_kiocb(&sio->iocb, swap_file);",
            "\t\tsio->iocb.ki_complete = sio_write_complete;",
            "\t\tsio->iocb.ki_pos = pos;",
            "\t\tsio->pages = 0;",
            "\t\tsio->len = 0;",
            "\t}",
            "\tbvec_set_folio(&sio->bvec[sio->pages], folio, folio_size(folio), 0);",
            "\tsio->len += folio_size(folio);",
            "\tsio->pages += 1;",
            "\tif (sio->pages == ARRAY_SIZE(sio->bvec) || !wbc->swap_plug) {",
            "\t\tswap_write_unplug(sio);",
            "\t\tsio = NULL;",
            "\t}",
            "\tif (wbc->swap_plug)",
            "\t\t*wbc->swap_plug = sio;",
            "}",
            "static void swap_writepage_bdev_sync(struct folio *folio,",
            "\t\tstruct writeback_control *wbc, struct swap_info_struct *sis)",
            "{",
            "\tstruct bio_vec bv;",
            "\tstruct bio bio;",
            "",
            "\tbio_init(&bio, sis->bdev, &bv, 1,",
            "\t\t REQ_OP_WRITE | REQ_SWAP | wbc_to_write_flags(wbc));",
            "\tbio.bi_iter.bi_sector = swap_folio_sector(folio);",
            "\tbio_add_folio_nofail(&bio, folio, folio_size(folio), 0);",
            "",
            "\tbio_associate_blkg_from_page(&bio, folio);",
            "\tcount_swpout_vm_event(folio);",
            "",
            "\tfolio_start_writeback(folio);",
            "\tfolio_unlock(folio);",
            "",
            "\tsubmit_bio_wait(&bio);",
            "\t__end_swap_bio_write(&bio);",
            "}",
            "static void swap_writepage_bdev_async(struct folio *folio,",
            "\t\tstruct writeback_control *wbc, struct swap_info_struct *sis)",
            "{",
            "\tstruct bio *bio;",
            "",
            "\tbio = bio_alloc(sis->bdev, 1,",
            "\t\t\tREQ_OP_WRITE | REQ_SWAP | wbc_to_write_flags(wbc),",
            "\t\t\tGFP_NOIO);",
            "\tbio->bi_iter.bi_sector = swap_folio_sector(folio);",
            "\tbio->bi_end_io = end_swap_bio_write;",
            "\tbio_add_folio_nofail(bio, folio, folio_size(folio), 0);",
            "",
            "\tbio_associate_blkg_from_page(bio, folio);",
            "\tcount_swpout_vm_event(folio);",
            "\tfolio_start_writeback(folio);",
            "\tfolio_unlock(folio);",
            "\tsubmit_bio(bio);",
            "}",
            "void __swap_writepage(struct folio *folio, struct writeback_control *wbc)",
            "{",
            "\tstruct swap_info_struct *sis = swp_swap_info(folio->swap);",
            "",
            "\tVM_BUG_ON_FOLIO(!folio_test_swapcache(folio), folio);",
            "\t/*",
            "\t * ->flags can be updated non-atomicially (scan_swap_map_slots),",
            "\t * but that will never affect SWP_FS_OPS, so the data_race",
            "\t * is safe.",
            "\t */",
            "\tif (data_race(sis->flags & SWP_FS_OPS))",
            "\t\tswap_writepage_fs(folio, wbc);",
            "\telse if (sis->flags & SWP_SYNCHRONOUS_IO)",
            "\t\tswap_writepage_bdev_sync(folio, wbc, sis);",
            "\telse",
            "\t\tswap_writepage_bdev_async(folio, wbc, sis);",
            "}",
            "void swap_write_unplug(struct swap_iocb *sio)",
            "{",
            "\tstruct iov_iter from;",
            "\tstruct address_space *mapping = sio->iocb.ki_filp->f_mapping;",
            "\tint ret;",
            "",
            "\tiov_iter_bvec(&from, ITER_SOURCE, sio->bvec, sio->pages, sio->len);",
            "\tret = mapping->a_ops->swap_rw(&sio->iocb, &from);",
            "\tif (ret != -EIOCBQUEUED)",
            "\t\tsio_write_complete(&sio->iocb, ret);",
            "}"
          ],
          "function_name": "swap_writepage_fs, swap_writepage_bdev_sync, swap_writepage_bdev_async, __swap_writepage, swap_write_unplug",
          "description": "__swap_writepage根据配置选择同步/异步块设备写入路径，通过bio结构执行交换页面写入操作，支持批量提交优化。",
          "similarity": 0.5678117871284485
        },
        {
          "chunk_id": 4,
          "file_path": "mm/page_io.c",
          "start_line": 406,
          "end_line": 537,
          "content": [
            "static void sio_read_complete(struct kiocb *iocb, long ret)",
            "{",
            "\tstruct swap_iocb *sio = container_of(iocb, struct swap_iocb, iocb);",
            "\tint p;",
            "",
            "\tif (ret == sio->len) {",
            "\t\tfor (p = 0; p < sio->pages; p++) {",
            "\t\t\tstruct folio *folio = page_folio(sio->bvec[p].bv_page);",
            "",
            "\t\t\tcount_mthp_stat(folio_order(folio), MTHP_STAT_SWPIN);",
            "\t\t\tcount_memcg_folio_events(folio, PSWPIN, folio_nr_pages(folio));",
            "\t\t\tfolio_mark_uptodate(folio);",
            "\t\t\tfolio_unlock(folio);",
            "\t\t}",
            "\t\tcount_vm_events(PSWPIN, sio->pages);",
            "\t} else {",
            "\t\tfor (p = 0; p < sio->pages; p++) {",
            "\t\t\tstruct folio *folio = page_folio(sio->bvec[p].bv_page);",
            "",
            "\t\t\tfolio_unlock(folio);",
            "\t\t}",
            "\t\tpr_alert_ratelimited(\"Read-error on swap-device\\n\");",
            "\t}",
            "\tmempool_free(sio, sio_pool);",
            "}",
            "static void swap_read_folio_fs(struct folio *folio, struct swap_iocb **plug)",
            "{",
            "\tstruct swap_info_struct *sis = swp_swap_info(folio->swap);",
            "\tstruct swap_iocb *sio = NULL;",
            "\tloff_t pos = folio_file_pos(folio);",
            "",
            "\tif (plug)",
            "\t\tsio = *plug;",
            "\tif (sio) {",
            "\t\tif (sio->iocb.ki_filp != sis->swap_file ||",
            "\t\t    sio->iocb.ki_pos + sio->len != pos) {",
            "\t\t\tswap_read_unplug(sio);",
            "\t\t\tsio = NULL;",
            "\t\t}",
            "\t}",
            "\tif (!sio) {",
            "\t\tsio = mempool_alloc(sio_pool, GFP_KERNEL);",
            "\t\tinit_sync_kiocb(&sio->iocb, sis->swap_file);",
            "\t\tsio->iocb.ki_pos = pos;",
            "\t\tsio->iocb.ki_complete = sio_read_complete;",
            "\t\tsio->pages = 0;",
            "\t\tsio->len = 0;",
            "\t}",
            "\tbvec_set_folio(&sio->bvec[sio->pages], folio, folio_size(folio), 0);",
            "\tsio->len += folio_size(folio);",
            "\tsio->pages += 1;",
            "\tif (sio->pages == ARRAY_SIZE(sio->bvec) || !plug) {",
            "\t\tswap_read_unplug(sio);",
            "\t\tsio = NULL;",
            "\t}",
            "\tif (plug)",
            "\t\t*plug = sio;",
            "}",
            "static void swap_read_folio_bdev_sync(struct folio *folio,",
            "\t\tstruct swap_info_struct *sis)",
            "{",
            "\tstruct bio_vec bv;",
            "\tstruct bio bio;",
            "",
            "\tbio_init(&bio, sis->bdev, &bv, 1, REQ_OP_READ);",
            "\tbio.bi_iter.bi_sector = swap_folio_sector(folio);",
            "\tbio_add_folio_nofail(&bio, folio, folio_size(folio), 0);",
            "\t/*",
            "\t * Keep this task valid during swap readpage because the oom killer may",
            "\t * attempt to access it in the page fault retry time check.",
            "\t */",
            "\tget_task_struct(current);",
            "\tcount_mthp_stat(folio_order(folio), MTHP_STAT_SWPIN);",
            "\tcount_memcg_folio_events(folio, PSWPIN, folio_nr_pages(folio));",
            "\tcount_vm_events(PSWPIN, folio_nr_pages(folio));",
            "\tsubmit_bio_wait(&bio);",
            "\t__end_swap_bio_read(&bio);",
            "\tput_task_struct(current);",
            "}",
            "static void swap_read_folio_bdev_async(struct folio *folio,",
            "\t\tstruct swap_info_struct *sis)",
            "{",
            "\tstruct bio *bio;",
            "",
            "\tbio = bio_alloc(sis->bdev, 1, REQ_OP_READ, GFP_KERNEL);",
            "\tbio->bi_iter.bi_sector = swap_folio_sector(folio);",
            "\tbio->bi_end_io = end_swap_bio_read;",
            "\tbio_add_folio_nofail(bio, folio, folio_size(folio), 0);",
            "\tcount_mthp_stat(folio_order(folio), MTHP_STAT_SWPIN);",
            "\tcount_memcg_folio_events(folio, PSWPIN, folio_nr_pages(folio));",
            "\tcount_vm_events(PSWPIN, folio_nr_pages(folio));",
            "\tsubmit_bio(bio);",
            "}",
            "void swap_read_folio(struct folio *folio, struct swap_iocb **plug)",
            "{",
            "\tstruct swap_info_struct *sis = swp_swap_info(folio->swap);",
            "\tbool synchronous = sis->flags & SWP_SYNCHRONOUS_IO;",
            "\tbool workingset = folio_test_workingset(folio);",
            "\tunsigned long pflags;",
            "\tbool in_thrashing;",
            "",
            "\tVM_BUG_ON_FOLIO(!folio_test_swapcache(folio) && !synchronous, folio);",
            "\tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);",
            "\tVM_BUG_ON_FOLIO(folio_test_uptodate(folio), folio);",
            "",
            "\t/*",
            "\t * Count submission time as memory stall and delay. When the device",
            "\t * is congested, or the submitting cgroup IO-throttled, submission",
            "\t * can be a significant part of overall IO time.",
            "\t */",
            "\tif (workingset) {",
            "\t\tdelayacct_thrashing_start(&in_thrashing);",
            "\t\tpsi_memstall_enter(&pflags);",
            "\t}",
            "\tdelayacct_swapin_start();",
            "",
            "\tif (zswap_load(folio)) {",
            "\t\tfolio_unlock(folio);",
            "\t} else if (data_race(sis->flags & SWP_FS_OPS)) {",
            "\t\tswap_read_folio_fs(folio, plug);",
            "\t} else if (synchronous) {",
            "\t\tswap_read_folio_bdev_sync(folio, sis);",
            "\t} else {",
            "\t\tswap_read_folio_bdev_async(folio, sis);",
            "\t}",
            "",
            "\tif (workingset) {",
            "\t\tdelayacct_thrashing_end(&in_thrashing);",
            "\t\tpsi_memstall_leave(&pflags);",
            "\t}",
            "\tdelayacct_swapin_end();",
            "}"
          ],
          "function_name": "sio_read_complete, swap_read_folio_fs, swap_read_folio_bdev_sync, swap_read_folio_bdev_async, swap_read_folio",
          "description": "swap_read_folio启动页面换入流程，根据配置选择文件级或块设备读取路径，处理交换数据加载及状态更新。",
          "similarity": 0.5651587247848511
        },
        {
          "chunk_id": 2,
          "file_path": "mm/page_io.c",
          "start_line": 179,
          "end_line": 280,
          "content": [
            "int swap_writepage(struct page *page, struct writeback_control *wbc)",
            "{",
            "\tstruct folio *folio = page_folio(page);",
            "\tint ret;",
            "",
            "\tif (folio_free_swap(folio)) {",
            "\t\tfolio_unlock(folio);",
            "\t\treturn 0;",
            "\t}",
            "\t/*",
            "\t * Arch code may have to preserve more data than just the page",
            "\t * contents, e.g. memory tags.",
            "\t */",
            "\tret = arch_prepare_to_swap(folio);",
            "\tif (ret) {",
            "\t\tfolio_mark_dirty(folio);",
            "\t\tfolio_unlock(folio);",
            "\t\treturn ret;",
            "\t}",
            "\tif (zswap_store(folio)) {",
            "\t\tfolio_start_writeback(folio);",
            "\t\tfolio_unlock(folio);",
            "\t\tfolio_end_writeback(folio);",
            "\t\treturn 0;",
            "\t}",
            "\tif (!mem_cgroup_zswap_writeback_enabled(folio_memcg(folio))) {",
            "\t\tfolio_mark_dirty(folio);",
            "\t\treturn AOP_WRITEPAGE_ACTIVATE;",
            "\t}",
            "",
            "\t__swap_writepage(folio, wbc);",
            "\treturn 0;",
            "}",
            "static inline void count_swpout_vm_event(struct folio *folio)",
            "{",
            "#ifdef CONFIG_TRANSPARENT_HUGEPAGE",
            "\tif (unlikely(folio_test_pmd_mappable(folio))) {",
            "\t\tcount_memcg_folio_events(folio, THP_SWPOUT, 1);",
            "\t\tcount_vm_event(THP_SWPOUT);",
            "\t}",
            "\tcount_mthp_stat(folio_order(folio), MTHP_STAT_SWPOUT);",
            "#endif",
            "\tcount_memcg_folio_events(folio, PSWPOUT, folio_nr_pages(folio));",
            "\tcount_vm_events(PSWPOUT, folio_nr_pages(folio));",
            "}",
            "static void bio_associate_blkg_from_page(struct bio *bio, struct folio *folio)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct mem_cgroup *memcg;",
            "",
            "\tmemcg = folio_memcg(folio);",
            "\tif (!memcg)",
            "\t\treturn;",
            "",
            "\trcu_read_lock();",
            "\tcss = cgroup_e_css(memcg->css.cgroup, &io_cgrp_subsys);",
            "\tbio_associate_blkg_from_css(bio, css);",
            "\trcu_read_unlock();",
            "}",
            "int sio_pool_init(void)",
            "{",
            "\tif (!sio_pool) {",
            "\t\tmempool_t *pool = mempool_create_kmalloc_pool(",
            "\t\t\tSWAP_CLUSTER_MAX, sizeof(struct swap_iocb));",
            "\t\tif (cmpxchg(&sio_pool, NULL, pool))",
            "\t\t\tmempool_destroy(pool);",
            "\t}",
            "\tif (!sio_pool)",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "static void sio_write_complete(struct kiocb *iocb, long ret)",
            "{",
            "\tstruct swap_iocb *sio = container_of(iocb, struct swap_iocb, iocb);",
            "\tstruct page *page = sio->bvec[0].bv_page;",
            "\tint p;",
            "",
            "\tif (ret != sio->len) {",
            "\t\t/*",
            "\t\t * In the case of swap-over-nfs, this can be a",
            "\t\t * temporary failure if the system has limited",
            "\t\t * memory for allocating transmit buffers.",
            "\t\t * Mark the page dirty and avoid",
            "\t\t * folio_rotate_reclaimable but rate-limit the",
            "\t\t * messages but do not flag PageError like",
            "\t\t * the normal direct-to-bio case as it could",
            "\t\t * be temporary.",
            "\t\t */",
            "\t\tpr_err_ratelimited(\"Write error %ld on dio swapfile (%llu)\\n\",",
            "\t\t\t\t   ret, page_file_offset(page));",
            "\t\tfor (p = 0; p < sio->pages; p++) {",
            "\t\t\tpage = sio->bvec[p].bv_page;",
            "\t\t\tset_page_dirty(page);",
            "\t\t\tClearPageReclaim(page);",
            "\t\t}",
            "\t}",
            "",
            "\tfor (p = 0; p < sio->pages; p++)",
            "\t\tend_page_writeback(sio->bvec[p].bv_page);",
            "",
            "\tmempool_free(sio, sio_pool);",
            "}"
          ],
          "function_name": "swap_writepage, count_swpout_vm_event, bio_associate_blkg_from_page, sio_pool_init, sio_write_complete",
          "description": "swap_writepage发起页面换出流程，调用架构特定准备函数并处理ZSwap缓存；sio_write_complete处理异步写入完成，标记脏页并释放资源。",
          "similarity": 0.5627026557922363
        }
      ]
    }
  ]
}