{
  "query": "操作系统中进程通信的分类",
  "timestamp": "2025-12-25 23:47:25",
  "retrieved_files": [
    {
      "source_file": "kernel/seccomp.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:23:11\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `seccomp.c`\n\n---\n\n# seccomp.c 技术文档\n\n## 文件概述\n\n`seccomp.c` 是 Linux 内核中实现安全计算（Secure Computing，简称 seccomp）机制的核心文件。该机制用于限制进程可执行的系统调用，从而提升系统安全性。文件支持两种主要模式：\n\n- **Mode 1（严格模式）**：仅允许 `read`、`write`、`exit` 和 `sigreturn` 四个系统调用。\n- **Mode 2（过滤器模式）**：允许用户通过 Berkeley Packet Filter（BPF）形式定义自定义的系统调用过滤规则。\n\n此外，该文件还实现了 **用户空间通知（user-space notification）** 功能，允许内核在遇到特定系统调用时暂停执行并通知用户态监听器进行处理。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct seccomp_filter`**  \n  表示一个 seccomp BPF 过滤器实例，包含：\n  - 引用计数（`refs` 和 `users`）\n  - BPF 程序指针（`prog`）\n  - 通知相关结构（`notif`、`notify_lock`、`wqh`）\n  - 动作缓存（`cache`）\n  - 指向前一个过滤器的指针（`prev`），构成过滤器链\n\n- **`struct notification`**  \n  管理用户空间通知的容器，包含请求计数器、标志位、下一个通知 ID 和通知链表。\n\n- **`struct seccomp_knotif`**  \n  表示一个待处理的用户通知请求，记录触发通知的任务、系统调用数据、状态（INIT/SENT/REPLIED）、返回值及完成信号量。\n\n- **`struct seccomp_kaddfd`**  \n  用于 `SECCOMP_IOCTL_NOTIF_ADDFD` 操作，允许监听器向目标进程注入文件描述符。\n\n- **`struct action_cache`**（条件编译）  \n  针对原生和兼容架构的系统调用动作缓存，用于快速判断是否允许某系统调用，避免重复执行 BPF 程序。\n\n### 关键枚举与常量\n\n- **`enum notify_state`**：通知状态机（INIT → SENT → REPLIED）\n- **`SECCOMP_MODE_DEAD`**：内部使用的特殊模式，表示进程已进入不可恢复的 seccomp 状态\n- **`MAX_INSNS_PER_PATH`**：限制 BPF 指令路径总长度不超过 256KB，防止资源耗尽\n\n### 特殊兼容性处理\n\n- **`SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR`**：为兼容早期错误的 ioctl 命令方向而保留的旧定义\n\n## 关键实现\n\n### 过滤器生命周期管理\n\n- 使用双重引用计数机制：\n  - `refs`：控制对象内存释放（包括任务引用、依赖过滤器、通知监听器）\n  - `users`：跟踪直接或间接使用该过滤器的任务数量，用于判断是否还能被新任务继承\n- 过滤器一旦附加到任务，除引用计数外不可修改，确保并发安全\n\n### 用户空间通知机制\n\n- 当 BPF 程序返回 `SECCOMP_RET_USER_NOTIF` 时，内核创建 `seccomp_knotif` 并加入通知队列\n- 用户态通过文件描述符读取通知，内核将状态置为 `SENT`\n- 监听器通过 `ioctl` 回复结果，状态转为 `REPLIED`，触发 `completion` 使原任务继续执行\n- 支持通过 `SECCOMP_IOCTL_NOTIF_ADDFD` 向目标进程注入文件描述符\n\n### 动作缓存优化（`action_cache`）\n\n- 在支持 `SECCOMP_ARCH_NATIVE` 的架构上，为每个系统调用编号维护一个“始终允许”位图\n- 若缓存命中（即该系统调用在所有路径下均返回 `ALLOW`），可跳过 BPF 执行，提升性能\n- 分别处理原生（native）和兼容（compat）系统调用空间\n\n### 安全与资源限制\n\n- 限制 BPF 指令总路径长度，防止深度嵌套或循环导致 DoS\n- 通知机制使用互斥锁（`notify_lock`）和完成量（`completion`）保证状态一致性\n- 支持 `wait_killable_recv` 选项，使等待通知回复的进程可被信号中断\n\n## 依赖关系\n\n- **BPF 子系统**：依赖 `linux/filter.h` 提供的 socket filter/BPF 执行引擎\n- **进程管理**：与 `sched.h`、`task_struct` 紧密集成，管理 per-task seccomp 状态\n- **文件系统与 fd 管理**：通过 `file.h`、`uaccess.h` 实现跨进程 fd 注入\n- **审计与日志**：集成 `audit.h` 支持 seccomp 事件审计\n- **架构相关代码**：通过 `asm/syscall.h` 获取系统调用号和参数\n- **能力机制**：依赖 `capability.h` 检查特权操作权限\n- **内存管理**：使用 `slab.h` 分配过滤器和通知结构\n\n## 使用场景\n\n1. **容器安全**：Docker、LXC 等容器运行时使用 seccomp 过滤器限制容器内进程的系统调用，防止逃逸\n2. **沙箱应用**：Chromium、Firefox 等浏览器使用 seccomp 构建渲染进程沙箱\n3. **最小权限原则**：特权服务（如 systemd、sshd）在初始化后启用 seccomp 以减少攻击面\n4. **动态策略执行**：通过 `SECCOMP_RET_USER_NOTIF` 实现用户态代理系统调用（如 ptrace 替代方案）\n5. **安全审计**：结合 `SECCOMP_RET_LOG` 记录所有被拦截或允许的系统调用行为\n6. **系统加固**：在不可信环境中运行程序时，强制限制其系统调用能力",
      "similarity": 0.6043603420257568,
      "chunks": [
        {
          "chunk_id": 8,
          "file_path": "kernel/seccomp.c",
          "start_line": 1340,
          "end_line": 1443,
          "content": [
            "static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,",
            "\t\t\t    const bool recheck_after_trace)",
            "{",
            "\tBUG();",
            "",
            "\treturn -1;",
            "}",
            "int __secure_computing(const struct seccomp_data *sd)",
            "{",
            "\tint mode = current->seccomp.mode;",
            "\tint this_syscall;",
            "",
            "\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&",
            "\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))",
            "\t\treturn 0;",
            "",
            "\tthis_syscall = sd ? sd->nr :",
            "\t\tsyscall_get_nr(current, current_pt_regs());",
            "",
            "\tswitch (mode) {",
            "\tcase SECCOMP_MODE_STRICT:",
            "\t\t__secure_computing_strict(this_syscall);  /* may call do_exit */",
            "\t\treturn 0;",
            "\tcase SECCOMP_MODE_FILTER:",
            "\t\treturn __seccomp_filter(this_syscall, sd, false);",
            "\t/* Surviving SECCOMP_RET_KILL_* must be proactively impossible. */",
            "\tcase SECCOMP_MODE_DEAD:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tdo_exit(SIGKILL);",
            "\t\treturn -1;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "}",
            "long prctl_get_seccomp(void)",
            "{",
            "\treturn current->seccomp.mode;",
            "}",
            "static long seccomp_set_mode_strict(void)",
            "{",
            "\tconst unsigned long seccomp_mode = SECCOMP_MODE_STRICT;",
            "\tlong ret = -EINVAL;",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "",
            "\tif (!seccomp_may_assign_mode(seccomp_mode))",
            "\t\tgoto out;",
            "",
            "#ifdef TIF_NOTSC",
            "\tdisable_TSC();",
            "#endif",
            "\tseccomp_assign_mode(current, seccomp_mode, 0);",
            "\tret = 0;",
            "",
            "out:",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "",
            "\treturn ret;",
            "}",
            "static void seccomp_notify_free(struct seccomp_filter *filter)",
            "{",
            "\tkfree(filter->notif);",
            "\tfilter->notif = NULL;",
            "}",
            "static void seccomp_notify_detach(struct seccomp_filter *filter)",
            "{",
            "\tstruct seccomp_knotif *knotif;",
            "",
            "\tif (!filter)",
            "\t\treturn;",
            "",
            "\tmutex_lock(&filter->notify_lock);",
            "",
            "\t/*",
            "\t * If this file is being closed because e.g. the task who owned it",
            "\t * died, let's wake everyone up who was waiting on us.",
            "\t */",
            "\tlist_for_each_entry(knotif, &filter->notif->notifications, list) {",
            "\t\tif (knotif->state == SECCOMP_NOTIFY_REPLIED)",
            "\t\t\tcontinue;",
            "",
            "\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;",
            "\t\tknotif->error = -ENOSYS;",
            "\t\tknotif->val = 0;",
            "",
            "\t\t/*",
            "\t\t * We do not need to wake up any pending addfd messages, as",
            "\t\t * the notifier will do that for us, as this just looks",
            "\t\t * like a standard reply.",
            "\t\t */",
            "\t\tcomplete(&knotif->ready);",
            "\t}",
            "",
            "\tseccomp_notify_free(filter);",
            "\tmutex_unlock(&filter->notify_lock);",
            "}",
            "static int seccomp_notify_release(struct inode *inode, struct file *file)",
            "{",
            "\tstruct seccomp_filter *filter = file->private_data;",
            "",
            "\tseccomp_notify_detach(filter);",
            "\t__put_seccomp_filter(filter);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__seccomp_filter, __secure_computing, prctl_get_seccomp, seccomp_set_mode_strict, seccomp_notify_free, seccomp_notify_detach, seccomp_notify_release",
          "description": "提供seccomp模式切换接口(prctl_get_seccomp/seccomp_set_mode_strict)，实现通知资源释放(detach/release)机制",
          "similarity": 0.5769457817077637
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/seccomp.c",
          "start_line": 1477,
          "end_line": 1578,
          "content": [
            "static int recv_wake_function(wait_queue_entry_t *wait, unsigned int mode, int sync,",
            "\t\t\t\t  void *key)",
            "{",
            "\t/* Avoid a wakeup if event not interesting for us. */",
            "\tif (key && !(key_to_poll(key) & (EPOLLIN | EPOLLERR)))",
            "\t\treturn 0;",
            "\treturn autoremove_wake_function(wait, mode, sync, key);",
            "}",
            "static int recv_wait_event(struct seccomp_filter *filter)",
            "{",
            "\tDEFINE_WAIT_FUNC(wait, recv_wake_function);",
            "\tint ret;",
            "",
            "\tif (atomic_dec_if_positive(&filter->notif->requests) >= 0)",
            "\t\treturn 0;",
            "",
            "\tfor (;;) {",
            "\t\tret = prepare_to_wait_event(&filter->wqh, &wait, TASK_INTERRUPTIBLE);",
            "",
            "\t\tif (atomic_dec_if_positive(&filter->notif->requests) >= 0)",
            "\t\t\tbreak;",
            "",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "",
            "\t\tschedule();",
            "\t}",
            "\tfinish_wait(&filter->wqh, &wait);",
            "\treturn 0;",
            "}",
            "static long seccomp_notify_recv(struct seccomp_filter *filter,",
            "\t\t\t\tvoid __user *buf)",
            "{",
            "\tstruct seccomp_knotif *knotif = NULL, *cur;",
            "\tstruct seccomp_notif unotif;",
            "\tssize_t ret;",
            "",
            "\t/* Verify that we're not given garbage to keep struct extensible. */",
            "\tret = check_zeroed_user(buf, sizeof(unotif));",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "\tif (!ret)",
            "\t\treturn -EINVAL;",
            "",
            "\tmemset(&unotif, 0, sizeof(unotif));",
            "",
            "\tret = recv_wait_event(filter);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tmutex_lock(&filter->notify_lock);",
            "\tlist_for_each_entry(cur, &filter->notif->notifications, list) {",
            "\t\tif (cur->state == SECCOMP_NOTIFY_INIT) {",
            "\t\t\tknotif = cur;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * If we didn't find a notification, it could be that the task was",
            "\t * interrupted by a fatal signal between the time we were woken and",
            "\t * when we were able to acquire the rw lock.",
            "\t */",
            "\tif (!knotif) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tunotif.id = knotif->id;",
            "\tunotif.pid = task_pid_vnr(knotif->task);",
            "\tunotif.data = *(knotif->data);",
            "",
            "\tknotif->state = SECCOMP_NOTIFY_SENT;",
            "\twake_up_poll(&filter->wqh, EPOLLOUT | EPOLLWRNORM);",
            "\tret = 0;",
            "out:",
            "\tmutex_unlock(&filter->notify_lock);",
            "",
            "\tif (ret == 0 && copy_to_user(buf, &unotif, sizeof(unotif))) {",
            "\t\tret = -EFAULT;",
            "",
            "\t\t/*",
            "\t\t * Userspace screwed up. To make sure that we keep this",
            "\t\t * notification alive, let's reset it back to INIT. It",
            "\t\t * may have died when we released the lock, so we need to make",
            "\t\t * sure it's still around.",
            "\t\t */",
            "\t\tmutex_lock(&filter->notify_lock);",
            "\t\tknotif = find_notification(filter, unotif.id);",
            "\t\tif (knotif) {",
            "\t\t\t/* Reset the process to make sure it's not stuck */",
            "\t\t\tif (should_sleep_killable(filter, knotif))",
            "\t\t\t\tcomplete(&knotif->ready);",
            "\t\t\tknotif->state = SECCOMP_NOTIFY_INIT;",
            "\t\t\tatomic_inc(&filter->notif->requests);",
            "\t\t\twake_up_poll(&filter->wqh, EPOLLIN | EPOLLRDNORM);",
            "\t\t}",
            "\t\tmutex_unlock(&filter->notify_lock);",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "recv_wake_function, recv_wait_event, seccomp_notify_recv",
          "description": "实现通知接收等待队列管理(recv_wait_event)和用户态数据接收(seccomp_notify_recv)的同步控制",
          "similarity": 0.5732032656669617
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/seccomp.c",
          "start_line": 1111,
          "end_line": 1212,
          "content": [
            "static bool should_sleep_killable(struct seccomp_filter *match,",
            "\t\t\t\t  struct seccomp_knotif *n)",
            "{",
            "\treturn match->wait_killable_recv && n->state == SECCOMP_NOTIFY_SENT;",
            "}",
            "static int seccomp_do_user_notification(int this_syscall,",
            "\t\t\t\t\tstruct seccomp_filter *match,",
            "\t\t\t\t\tconst struct seccomp_data *sd)",
            "{",
            "\tint err;",
            "\tu32 flags = 0;",
            "\tlong ret = 0;",
            "\tstruct seccomp_knotif n = {};",
            "\tstruct seccomp_kaddfd *addfd, *tmp;",
            "",
            "\tmutex_lock(&match->notify_lock);",
            "\terr = -ENOSYS;",
            "\tif (!match->notif)",
            "\t\tgoto out;",
            "",
            "\tn.task = current;",
            "\tn.state = SECCOMP_NOTIFY_INIT;",
            "\tn.data = sd;",
            "\tn.id = seccomp_next_notify_id(match);",
            "\tinit_completion(&n.ready);",
            "\tlist_add_tail(&n.list, &match->notif->notifications);",
            "\tINIT_LIST_HEAD(&n.addfd);",
            "",
            "\tatomic_inc(&match->notif->requests);",
            "\tif (match->notif->flags & SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP)",
            "\t\twake_up_poll_on_current_cpu(&match->wqh, EPOLLIN | EPOLLRDNORM);",
            "\telse",
            "\t\twake_up_poll(&match->wqh, EPOLLIN | EPOLLRDNORM);",
            "",
            "\t/*",
            "\t * This is where we wait for a reply from userspace.",
            "\t */",
            "\tdo {",
            "\t\tbool wait_killable = should_sleep_killable(match, &n);",
            "",
            "\t\tmutex_unlock(&match->notify_lock);",
            "\t\tif (wait_killable)",
            "\t\t\terr = wait_for_completion_killable(&n.ready);",
            "\t\telse",
            "\t\t\terr = wait_for_completion_interruptible(&n.ready);",
            "\t\tmutex_lock(&match->notify_lock);",
            "",
            "\t\tif (err != 0) {",
            "\t\t\t/*",
            "\t\t\t * Check to see if the notifcation got picked up and",
            "\t\t\t * whether we should switch to wait killable.",
            "\t\t\t */",
            "\t\t\tif (!wait_killable && should_sleep_killable(match, &n))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tgoto interrupted;",
            "\t\t}",
            "",
            "\t\taddfd = list_first_entry_or_null(&n.addfd,",
            "\t\t\t\t\t\t struct seccomp_kaddfd, list);",
            "\t\t/* Check if we were woken up by a addfd message */",
            "\t\tif (addfd)",
            "\t\t\tseccomp_handle_addfd(addfd, &n);",
            "",
            "\t}  while (n.state != SECCOMP_NOTIFY_REPLIED);",
            "",
            "\tret = n.val;",
            "\terr = n.error;",
            "\tflags = n.flags;",
            "",
            "interrupted:",
            "\t/* If there were any pending addfd calls, clear them out */",
            "\tlist_for_each_entry_safe(addfd, tmp, &n.addfd, list) {",
            "\t\t/* The process went away before we got a chance to handle it */",
            "\t\taddfd->ret = -ESRCH;",
            "\t\tlist_del_init(&addfd->list);",
            "\t\tcomplete(&addfd->completion);",
            "\t}",
            "",
            "\t/*",
            "\t * Note that it's possible the listener died in between the time when",
            "\t * we were notified of a response (or a signal) and when we were able to",
            "\t * re-acquire the lock, so only delete from the list if the",
            "\t * notification actually exists.",
            "\t *",
            "\t * Also note that this test is only valid because there's no way to",
            "\t * *reattach* to a notifier right now. If one is added, we'll need to",
            "\t * keep track of the notif itself and make sure they match here.",
            "\t */",
            "\tif (match->notif)",
            "\t\tlist_del(&n.list);",
            "out:",
            "\tmutex_unlock(&match->notify_lock);",
            "",
            "\t/* Userspace requests to continue the syscall. */",
            "\tif (flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE)",
            "\t\treturn 0;",
            "",
            "\tsyscall_set_return_value(current, current_pt_regs(),",
            "\t\t\t\t err, ret);",
            "\treturn -1;",
            "}"
          ],
          "function_name": "should_sleep_killable, seccomp_do_user_notification",
          "description": "实现用户空间通知等待逻辑，seccomp_do_user_notification处理通知状态转换、文件描述符传递及超时控制",
          "similarity": 0.5667991638183594
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/seccomp.c",
          "start_line": 1,
          "end_line": 178,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * linux/kernel/seccomp.c",
            " *",
            " * Copyright 2004-2005  Andrea Arcangeli <andrea@cpushare.com>",
            " *",
            " * Copyright (C) 2012 Google, Inc.",
            " * Will Drewry <wad@chromium.org>",
            " *",
            " * This defines a simple but solid secure-computing facility.",
            " *",
            " * Mode 1 uses a fixed list of allowed system calls.",
            " * Mode 2 allows user-defined system call filters in the form",
            " *        of Berkeley Packet Filters/Linux Socket Filters.",
            " */",
            "#define pr_fmt(fmt) \"seccomp: \" fmt",
            "",
            "#include <linux/refcount.h>",
            "#include <linux/audit.h>",
            "#include <linux/compat.h>",
            "#include <linux/coredump.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/nospec.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sysctl.h>",
            "",
            "/* Not exposed in headers: strictly internal use only. */",
            "#define SECCOMP_MODE_DEAD\t(SECCOMP_MODE_FILTER + 1)",
            "",
            "#ifdef CONFIG_HAVE_ARCH_SECCOMP_FILTER",
            "#include <asm/syscall.h>",
            "#endif",
            "",
            "#ifdef CONFIG_SECCOMP_FILTER",
            "#include <linux/file.h>",
            "#include <linux/filter.h>",
            "#include <linux/pid.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/lockdep.h>",
            "",
            "/*",
            " * When SECCOMP_IOCTL_NOTIF_ID_VALID was first introduced, it had the",
            " * wrong direction flag in the ioctl number. This is the broken one,",
            " * which the kernel needs to keep supporting until all userspaces stop",
            " * using the wrong command number.",
            " */",
            "#define SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR\tSECCOMP_IOR(2, __u64)",
            "",
            "enum notify_state {",
            "\tSECCOMP_NOTIFY_INIT,",
            "\tSECCOMP_NOTIFY_SENT,",
            "\tSECCOMP_NOTIFY_REPLIED,",
            "};",
            "",
            "struct seccomp_knotif {",
            "\t/* The struct pid of the task whose filter triggered the notification */",
            "\tstruct task_struct *task;",
            "",
            "\t/* The \"cookie\" for this request; this is unique for this filter. */",
            "\tu64 id;",
            "",
            "\t/*",
            "\t * The seccomp data. This pointer is valid the entire time this",
            "\t * notification is active, since it comes from __seccomp_filter which",
            "\t * eclipses the entire lifecycle here.",
            "\t */",
            "\tconst struct seccomp_data *data;",
            "",
            "\t/*",
            "\t * Notification states. When SECCOMP_RET_USER_NOTIF is returned, a",
            "\t * struct seccomp_knotif is created and starts out in INIT. Once the",
            "\t * handler reads the notification off of an FD, it transitions to SENT.",
            "\t * If a signal is received the state transitions back to INIT and",
            "\t * another message is sent. When the userspace handler replies, state",
            "\t * transitions to REPLIED.",
            "\t */",
            "\tenum notify_state state;",
            "",
            "\t/* The return values, only valid when in SECCOMP_NOTIFY_REPLIED */",
            "\tint error;",
            "\tlong val;",
            "\tu32 flags;",
            "",
            "\t/*",
            "\t * Signals when this has changed states, such as the listener",
            "\t * dying, a new seccomp addfd message, or changing to REPLIED",
            "\t */",
            "\tstruct completion ready;",
            "",
            "\tstruct list_head list;",
            "",
            "\t/* outstanding addfd requests */",
            "\tstruct list_head addfd;",
            "};",
            "",
            "/**",
            " * struct seccomp_kaddfd - container for seccomp_addfd ioctl messages",
            " *",
            " * @file: A reference to the file to install in the other task",
            " * @fd: The fd number to install it at. If the fd number is -1, it means the",
            " *      installing process should allocate the fd as normal.",
            " * @flags: The flags for the new file descriptor. At the moment, only O_CLOEXEC",
            " *         is allowed.",
            " * @ioctl_flags: The flags used for the seccomp_addfd ioctl.",
            " * @setfd: whether or not SECCOMP_ADDFD_FLAG_SETFD was set during notify_addfd",
            " * @ret: The return value of the installing process. It is set to the fd num",
            " *       upon success (>= 0).",
            " * @completion: Indicates that the installing process has completed fd",
            " *              installation, or gone away (either due to successful",
            " *              reply, or signal)",
            " * @list: list_head for chaining seccomp_kaddfd together.",
            " *",
            " */",
            "struct seccomp_kaddfd {",
            "\tstruct file *file;",
            "\tint fd;",
            "\tunsigned int flags;",
            "\t__u32 ioctl_flags;",
            "",
            "\tunion {",
            "\t\tbool setfd;",
            "\t\t/* To only be set on reply */",
            "\t\tint ret;",
            "\t};",
            "\tstruct completion completion;",
            "\tstruct list_head list;",
            "};",
            "",
            "/**",
            " * struct notification - container for seccomp userspace notifications. Since",
            " * most seccomp filters will not have notification listeners attached and this",
            " * structure is fairly large, we store the notification-specific stuff in a",
            " * separate structure.",
            " *",
            " * @requests: A semaphore that users of this notification can wait on for",
            " *            changes. Actual reads and writes are still controlled with",
            " *            filter->notify_lock.",
            " * @flags: A set of SECCOMP_USER_NOTIF_FD_* flags.",
            " * @next_id: The id of the next request.",
            " * @notifications: A list of struct seccomp_knotif elements.",
            " */",
            "",
            "struct notification {",
            "\tatomic_t requests;",
            "\tu32 flags;",
            "\tu64 next_id;",
            "\tstruct list_head notifications;",
            "};",
            "",
            "#ifdef SECCOMP_ARCH_NATIVE",
            "/**",
            " * struct action_cache - per-filter cache of seccomp actions per",
            " * arch/syscall pair",
            " *",
            " * @allow_native: A bitmap where each bit represents whether the",
            " *\t\t  filter will always allow the syscall, for the",
            " *\t\t  native architecture.",
            " * @allow_compat: A bitmap where each bit represents whether the",
            " *\t\t  filter will always allow the syscall, for the",
            " *\t\t  compat architecture.",
            " */",
            "struct action_cache {",
            "\tDECLARE_BITMAP(allow_native, SECCOMP_ARCH_NATIVE_NR);",
            "#ifdef SECCOMP_ARCH_COMPAT",
            "\tDECLARE_BITMAP(allow_compat, SECCOMP_ARCH_COMPAT_NR);",
            "#endif",
            "};",
            "#else",
            "struct action_cache { };",
            ""
          ],
          "function_name": null,
          "description": "定义seccomp模块的内部结构体和枚举类型，包括用于管理用户空间通知的seccomp_knotif结构、文件描述符操作的seccomp_kaddfd结构，以及跨架构的action_cache缓存结构。声明了SECCOMP_MODE_DEAD等内省常量和架构相关的宏定义。",
          "similarity": 0.5426119565963745
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/seccomp.c",
          "start_line": 1783,
          "end_line": 1952,
          "content": [
            "static long seccomp_notify_ioctl(struct file *file, unsigned int cmd,",
            "\t\t\t\t unsigned long arg)",
            "{",
            "\tstruct seccomp_filter *filter = file->private_data;",
            "\tvoid __user *buf = (void __user *)arg;",
            "",
            "\t/* Fixed-size ioctls */",
            "\tswitch (cmd) {",
            "\tcase SECCOMP_IOCTL_NOTIF_RECV:",
            "\t\treturn seccomp_notify_recv(filter, buf);",
            "\tcase SECCOMP_IOCTL_NOTIF_SEND:",
            "\t\treturn seccomp_notify_send(filter, buf);",
            "\tcase SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR:",
            "\tcase SECCOMP_IOCTL_NOTIF_ID_VALID:",
            "\t\treturn seccomp_notify_id_valid(filter, buf);",
            "\tcase SECCOMP_IOCTL_NOTIF_SET_FLAGS:",
            "\t\treturn seccomp_notify_set_flags(filter, arg);",
            "\t}",
            "",
            "\t/* Extensible Argument ioctls */",
            "#define EA_IOCTL(cmd)\t((cmd) & ~(IOC_INOUT | IOCSIZE_MASK))",
            "\tswitch (EA_IOCTL(cmd)) {",
            "\tcase EA_IOCTL(SECCOMP_IOCTL_NOTIF_ADDFD):",
            "\t\treturn seccomp_notify_addfd(filter, buf, _IOC_SIZE(cmd));",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "}",
            "static __poll_t seccomp_notify_poll(struct file *file,",
            "\t\t\t\t    struct poll_table_struct *poll_tab)",
            "{",
            "\tstruct seccomp_filter *filter = file->private_data;",
            "\t__poll_t ret = 0;",
            "\tstruct seccomp_knotif *cur;",
            "",
            "\tpoll_wait(file, &filter->wqh, poll_tab);",
            "",
            "\tif (mutex_lock_interruptible(&filter->notify_lock) < 0)",
            "\t\treturn EPOLLERR;",
            "",
            "\tlist_for_each_entry(cur, &filter->notif->notifications, list) {",
            "\t\tif (cur->state == SECCOMP_NOTIFY_INIT)",
            "\t\t\tret |= EPOLLIN | EPOLLRDNORM;",
            "\t\tif (cur->state == SECCOMP_NOTIFY_SENT)",
            "\t\t\tret |= EPOLLOUT | EPOLLWRNORM;",
            "\t\tif ((ret & EPOLLIN) && (ret & EPOLLOUT))",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\tmutex_unlock(&filter->notify_lock);",
            "",
            "\tif (refcount_read(&filter->users) == 0)",
            "\t\tret |= EPOLLHUP;",
            "",
            "\treturn ret;",
            "}",
            "static bool has_duplicate_listener(struct seccomp_filter *new_child)",
            "{",
            "\tstruct seccomp_filter *cur;",
            "",
            "\t/* must be protected against concurrent TSYNC */",
            "\tlockdep_assert_held(&current->sighand->siglock);",
            "",
            "\tif (!new_child->notif)",
            "\t\treturn false;",
            "\tfor (cur = current->seccomp.filter; cur; cur = cur->prev) {",
            "\t\tif (cur->notif)",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static long seccomp_set_mode_filter(unsigned int flags,",
            "\t\t\t\t    const char __user *filter)",
            "{",
            "\tconst unsigned long seccomp_mode = SECCOMP_MODE_FILTER;",
            "\tstruct seccomp_filter *prepared = NULL;",
            "\tlong ret = -EINVAL;",
            "\tint listener = -1;",
            "\tstruct file *listener_f = NULL;",
            "",
            "\t/* Validate flags. */",
            "\tif (flags & ~SECCOMP_FILTER_FLAG_MASK)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * In the successful case, NEW_LISTENER returns the new listener fd.",
            "\t * But in the failure case, TSYNC returns the thread that died. If you",
            "\t * combine these two flags, there's no way to tell whether something",
            "\t * succeeded or failed. So, let's disallow this combination if the user",
            "\t * has not explicitly requested no errors from TSYNC.",
            "\t */",
            "\tif ((flags & SECCOMP_FILTER_FLAG_TSYNC) &&",
            "\t    (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) &&",
            "\t    ((flags & SECCOMP_FILTER_FLAG_TSYNC_ESRCH) == 0))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * The SECCOMP_FILTER_FLAG_WAIT_KILLABLE_SENT flag doesn't make sense",
            "\t * without the SECCOMP_FILTER_FLAG_NEW_LISTENER flag.",
            "\t */",
            "\tif ((flags & SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV) &&",
            "\t    ((flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) == 0))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Prepare the new filter before holding any locks. */",
            "\tprepared = seccomp_prepare_user_filter(filter);",
            "\tif (IS_ERR(prepared))",
            "\t\treturn PTR_ERR(prepared);",
            "",
            "\tif (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) {",
            "\t\tlistener = get_unused_fd_flags(O_CLOEXEC);",
            "\t\tif (listener < 0) {",
            "\t\t\tret = listener;",
            "\t\t\tgoto out_free;",
            "\t\t}",
            "",
            "\t\tlistener_f = init_listener(prepared);",
            "\t\tif (IS_ERR(listener_f)) {",
            "\t\t\tput_unused_fd(listener);",
            "\t\t\tret = PTR_ERR(listener_f);",
            "\t\t\tgoto out_free;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * Make sure we cannot change seccomp or nnp state via TSYNC",
            "\t * while another thread is in the middle of calling exec.",
            "\t */",
            "\tif (flags & SECCOMP_FILTER_FLAG_TSYNC &&",
            "\t    mutex_lock_killable(&current->signal->cred_guard_mutex))",
            "\t\tgoto out_put_fd;",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "",
            "\tif (!seccomp_may_assign_mode(seccomp_mode))",
            "\t\tgoto out;",
            "",
            "\tif (has_duplicate_listener(prepared)) {",
            "\t\tret = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = seccomp_attach_filter(flags, prepared);",
            "\tif (ret)",
            "\t\tgoto out;",
            "\t/* Do not free the successfully attached filter. */",
            "\tprepared = NULL;",
            "",
            "\tseccomp_assign_mode(current, seccomp_mode, flags);",
            "out:",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)",
            "\t\tmutex_unlock(&current->signal->cred_guard_mutex);",
            "out_put_fd:",
            "\tif (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) {",
            "\t\tif (ret) {",
            "\t\t\tlistener_f->private_data = NULL;",
            "\t\t\tfput(listener_f);",
            "\t\t\tput_unused_fd(listener);",
            "\t\t\tseccomp_notify_detach(prepared);",
            "\t\t} else {",
            "\t\t\tfd_install(listener, listener_f);",
            "\t\t\tret = listener;",
            "\t\t}",
            "\t}",
            "out_free:",
            "\tseccomp_filter_free(prepared);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "seccomp_notify_ioctl, seccomp_notify_poll, has_duplicate_listener, seccomp_set_mode_filter",
          "description": "该代码段实现seccomp过滤器的通知机制与模式配置功能。  \n`seccomp_notify_ioctl`处理通知相关的IOCTL命令，支持接收/发送通知及扩展参数操作；`seccomp_notify_poll`通过轮询检测过滤器状态变化并设置对应epoll掩码；`has_duplicate_listener`检查是否存在重复监听器以避免资源冲突，`seccomp_set_mode_filter`负责设置过滤模式并管理监听器创建与同步。  \n注：代码未展示全部上下文，如`seccomp_prepare_user_filter`等辅助函数的具体实现。",
          "similarity": 0.5361871719360352
        }
      ]
    },
    {
      "source_file": "kernel/task_work.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:33:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `task_work.c`\n\n---\n\n# task_work.c 技术文档\n\n## 文件概述\n\n`task_work.c` 实现了 Linux 内核中的 **任务工作（task work）机制**，允许内核在特定时机（如任务返回用户态、收到信号或处于 NMI 上下文）异步执行回调函数。该机制主要用于在不阻塞当前执行路径的前提下，将工作延迟到目标任务的合适上下文中执行，常用于安全模块（如 seccomp）、用户态通知、延迟清理等场景。\n\n任务工作队列是 **LIFO（后进先出）** 的，且不保证多个工作项之间的执行顺序。该机制支持多种通知模式，以适应不同的延迟和中断需求。\n\n## 核心功能\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `task_work_add()` | 向指定任务添加一个回调工作项，并根据通知模式触发相应通知 |\n| `task_work_run()` | 执行当前任务的所有挂起工作项，通常在返回用户态或任务退出前调用 |\n| `task_work_cancel_match()` | 根据自定义匹配函数取消队列中的某个工作项 |\n| `task_work_cancel_func()` | 取消队列中第一个函数指针匹配指定函数的工作项 |\n| `task_work_cancel()` | 取消队列中指定的回调结构体（精确匹配指针） |\n\n### 主要数据结构\n\n- `struct callback_head`：通用回调结构体，包含 `next` 指针和 `func` 回调函数指针。\n- `enum task_work_notify_mode`：通知模式枚举，包括：\n  - `TWA_NONE`：不通知\n  - `TWA_RESUME`：在任务返回用户态或进入 guest 模式前执行\n  - `TWA_SIGNAL`：类似信号，可中断内核态任务并立即调度执行\n  - `TWA_SIGNAL_NO_IPI`：类似 `TWA_SIGNAL`，但不发送 IPI 强制重调度\n  - `TWA_NMI_CURRENT`：仅用于当前任务且在 NMI 上下文中，通过 IRQ work 触发\n\n### 全局变量\n\n- `work_exited`：特殊标记，表示任务已退出，不能再接受新工作。\n- `irq_work_NMI_resume`（per-CPU）：用于 `TWA_NMI_CURRENT` 模式下触发 `TIF_NOTIFY_RESUME` 标志。\n\n## 关键实现\n\n### 1. 无锁队列插入（LIFO）\n\n`task_work_add()` 使用 `try_cmpxchg()` 原子操作将新工作项插入到 `task->task_works` 链表头部，实现无锁并发插入。若发现 `task_works == &work_exited`，说明任务正在退出，返回 `-ESRCH`。\n\n### 2. 多种通知机制\n\n- **`TWA_RESUME`**：调用 `set_notify_resume(task)`，设置 `TIF_NOTIFY_RESUME` 标志，确保任务在 `exit_to_user_mode()` 路径中调用 `task_work_run()`。\n- **`TWA_SIGNAL` / `TWA_SIGNAL_NO_IPI`**：分别调用 `set_notify_signal()` 和 `__set_notify_signal()`，设置 `TIF_NOTIFY_SIGNAL` 标志，并可能发送 IPI 强制目标 CPU 重调度。\n- **`TWA_NMI_CURRENT`**：在 NMI 上下文中，通过 per-CPU 的 `irq_work` 触发软中断，在 IRQ 上下文中设置 `TIF_NOTIFY_RESUME`。\n\n### 3. 安全退出处理\n\n`task_work_run()` 在循环中：\n- 原子地将 `task_works` 置为 `NULL`（或 `&work_exited`，若任务正在退出）。\n- 若任务正在退出（`PF_EXITING`），则标记为 `work_exited`，防止后续 `task_work_add()` 成功。\n- 执行所有取出的工作项，每个 `work->func(work)` 可能再次调用 `task_work_add()`，因此需循环处理。\n\n### 4. 并发取消机制\n\n`task_work_cancel_match()` 使用 `task->pi_lock` 保护遍历和删除操作：\n- 遍历链表查找匹配项。\n- 使用 `try_cmpxchg()` 原子地移除节点，避免与 `task_work_add()` 或 `task_work_run()` 冲突。\n- 特别地，`task_work_run()` 在执行前会短暂获取 `pi_lock`，确保取消操作不会在执行过程中移除正在运行的工作项。\n\n### 5. KASAN 辅助栈记录\n\n在 `task_work_add()` 中，根据 `TWAF_NO_ALLOC` 标志调用 `kasan_record_aux_stack()` 或 `kasan_record_aux_stack_noalloc()`，用于在 KASAN 报告中显示工作项的分配调用栈。\n\n## 依赖关系\n\n- **`<linux/irq_work.h>`**：提供 `irq_work` 机制，用于 `TWA_NMI_CURRENT` 模式。\n- **`<linux/resume_user_mode.h>`**：提供 `set_notify_resume()` 等接口，用于在返回用户态时触发回调。\n- **`<linux/spinlock.h>`**：使用 `raw_spinlock_t`（`pi_lock`）保护取消操作。\n- **`<linux/task_work.h>`**：定义 `task_work_notify_mode`、`callback_head` 等核心类型。\n- **调度子系统**：依赖 `TIF_NOTIFY_RESUME` / `TIF_NOTIFY_SIGNAL` 标志位，在调度路径中调用 `task_work_run()`。\n- **KASAN**：集成内存错误检测的调用栈记录功能。\n\n## 使用场景\n\n1. **Seccomp 通知**：当 seccomp 策略需要异步通知用户态代理时，通过 `task_work_add()` 添加回调。\n2. **用户态延迟操作**：内核模块需要在任务下次返回用户态时执行清理或通知，使用 `TWA_RESUME`。\n3. **NMI 上下文延迟处理**：在不可睡眠的 NMI 处理程序中，通过 `TWA_NMI_CURRENT` 安全地安排后续工作。\n4. **信号式中断执行**：需要立即中断目标任务（即使在内核态）以执行高优先级工作，使用 `TWA_SIGNAL`。\n5. **资源回收**：在任务退出路径中，确保所有挂起工作被执行或清理。\n6. **动态取消机制**：如 seccomp 可能需要在条件变化时取消之前安排的工作，使用 `task_work_cancel_func()`。",
      "similarity": 0.5833714008331299,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/task_work.c",
          "start_line": 10,
          "end_line": 125,
          "content": [
            "static void task_work_set_notify_irq(struct irq_work *entry)",
            "{",
            "\ttest_and_set_tsk_thread_flag(current, TIF_NOTIFY_RESUME);",
            "}",
            "int task_work_add(struct task_struct *task, struct callback_head *work,",
            "\t\t  enum task_work_notify_mode notify)",
            "{",
            "\tstruct callback_head *head;",
            "\tint flags = notify & TWA_FLAGS;",
            "",
            "\tnotify &= ~TWA_FLAGS;",
            "\tif (notify == TWA_NMI_CURRENT) {",
            "\t\tif (WARN_ON_ONCE(task != current))",
            "\t\t\treturn -EINVAL;",
            "\t\tif (!IS_ENABLED(CONFIG_IRQ_WORK))",
            "\t\t\treturn -EINVAL;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Record the work call stack in order to print it in KASAN",
            "\t\t * reports.",
            "\t\t *",
            "\t\t * Note that stack allocation can fail if TWAF_NO_ALLOC flag",
            "\t\t * is set and new page is needed to expand the stack buffer.",
            "\t\t */",
            "\t\tif (flags & TWAF_NO_ALLOC)",
            "\t\t\tkasan_record_aux_stack_noalloc(work);",
            "\t\telse",
            "\t\t\tkasan_record_aux_stack(work);",
            "\t}",
            "",
            "\thead = READ_ONCE(task->task_works);",
            "\tdo {",
            "\t\tif (unlikely(head == &work_exited))",
            "\t\t\treturn -ESRCH;",
            "\t\twork->next = head;",
            "\t} while (!try_cmpxchg(&task->task_works, &head, work));",
            "",
            "\tswitch (notify) {",
            "\tcase TWA_NONE:",
            "\t\tbreak;",
            "\tcase TWA_RESUME:",
            "\t\tset_notify_resume(task);",
            "\t\tbreak;",
            "\tcase TWA_SIGNAL:",
            "\t\tset_notify_signal(task);",
            "\t\tbreak;",
            "\tcase TWA_SIGNAL_NO_IPI:",
            "\t\t__set_notify_signal(task);",
            "\t\tbreak;",
            "#ifdef CONFIG_IRQ_WORK",
            "\tcase TWA_NMI_CURRENT:",
            "\t\tirq_work_queue(this_cpu_ptr(&irq_work_NMI_resume));",
            "\t\tbreak;",
            "#endif",
            "\tdefault:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static bool task_work_func_match(struct callback_head *cb, void *data)",
            "{",
            "\treturn cb->func == data;",
            "}",
            "static bool task_work_match(struct callback_head *cb, void *data)",
            "{",
            "\treturn cb == data;",
            "}",
            "bool task_work_cancel(struct task_struct *task, struct callback_head *cb)",
            "{",
            "\tstruct callback_head *ret;",
            "",
            "\tret = task_work_cancel_match(task, task_work_match, cb);",
            "",
            "\treturn ret == cb;",
            "}",
            "void task_work_run(void)",
            "{",
            "\tstruct task_struct *task = current;",
            "\tstruct callback_head *work, *head, *next;",
            "",
            "\tfor (;;) {",
            "\t\t/*",
            "\t\t * work->func() can do task_work_add(), do not set",
            "\t\t * work_exited unless the list is empty.",
            "\t\t */",
            "\t\twork = READ_ONCE(task->task_works);",
            "\t\tdo {",
            "\t\t\thead = NULL;",
            "\t\t\tif (!work) {",
            "\t\t\t\tif (task->flags & PF_EXITING)",
            "\t\t\t\t\thead = &work_exited;",
            "\t\t\t\telse",
            "\t\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t} while (!try_cmpxchg(&task->task_works, &work, head));",
            "",
            "\t\tif (!work)",
            "\t\t\tbreak;",
            "\t\t/*",
            "\t\t * Synchronize with task_work_cancel_match(). It can not remove",
            "\t\t * the first entry == work, cmpxchg(task_works) must fail.",
            "\t\t * But it can remove another entry from the ->next list.",
            "\t\t */",
            "\t\traw_spin_lock_irq(&task->pi_lock);",
            "\t\traw_spin_unlock_irq(&task->pi_lock);",
            "",
            "\t\tdo {",
            "\t\t\tnext = work->next;",
            "\t\t\twork->func(work);",
            "\t\t\twork = next;",
            "\t\t\tcond_resched();",
            "\t\t} while (work);",
            "\t}",
            "}"
          ],
          "function_name": "task_work_set_notify_irq, task_work_add, task_work_func_match, task_work_match, task_work_cancel, task_work_run",
          "description": "实现任务工作队列的添加、匹配、取消及执行逻辑，支持多种通知模式（如RESUME/SIGNAL/NMI），通过原子操作维护链表并同步执行回调函数",
          "similarity": 0.565169095993042
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/task_work.c",
          "start_line": 1,
          "end_line": 9,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/task_work.h>",
            "#include <linux/resume_user_mode.h>",
            "",
            "static struct callback_head work_exited; /* all we need is ->next == NULL */",
            "",
            "#ifdef CONFIG_IRQ_WORK"
          ],
          "function_name": null,
          "description": "声明用于任务工作通知的静态变量work_exited，该变量通过next指针判断任务工作链表是否为空，上下文不完整",
          "similarity": 0.4759821593761444
        }
      ]
    },
    {
      "source_file": "kernel/fork.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:30:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `fork.c`\n\n---\n\n# fork.c 技术文档\n\n## 1. 文件概述\n\n`fork.c` 是 Linux 内核中实现进程创建（fork）系统调用的核心源文件。该文件包含了创建新进程所需的所有辅助例程，负责复制父进程的资源（如内存、文件描述符、信号处理等）以生成子进程。虽然 fork 逻辑本身概念简单，但其涉及的内存管理（尤其是写时复制 COW 机制）极为复杂，实际内存页的复制由 `mm/memory.c` 中的 `copy_page_range()` 等函数处理。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `total_forks`: 累计系统自启动以来创建的进程总数\n- `nr_threads`: 当前系统中的线程总数（不包括 idle 线程）\n- `max_threads`: 可配置的线程数量上限（默认为 `FUTEX_TID_MASK`）\n- `process_counts`: 每 CPU 的进程计数器（per-CPU 变量）\n- `tasklist_lock`: 保护任务链表的读写锁（全局任务列表的同步原语）\n\n### 关键辅助函数\n- `nr_processes()`: 计算系统中所有进程的总数（聚合各 CPU 的 `process_counts`）\n- `arch_release_task_struct()`: 架构相关的 task_struct 释放钩子（弱符号，默认为空）\n- `alloc_task_struct_node()` / `free_task_struct()`: 分配/释放 `task_struct` 结构（基于 slab 分配器）\n- `alloc_thread_stack_node()` / `thread_stack_delayed_free()`: 分配/延迟释放线程内核栈（支持 `CONFIG_VMAP_STACK`）\n\n### 核心数据结构\n- `resident_page_types[]`: 用于内存统计的页面类型名称映射数组\n- `vm_stack`: 用于 RCU 延迟释放的虚拟内存栈封装结构\n- `cached_stacks[NR_CACHED_STACKS]`: 每 CPU 的内核栈缓存（减少频繁 vmalloc/vfree 开销）\n\n## 3. 关键实现\n\n### 进程/线程计数管理\n- 使用 per-CPU 变量 `process_counts` 避免全局锁竞争\n- 全局计数器 `nr_threads` 和 `total_forks` 由 `tasklist_lock` 保护\n- `nr_processes()` 通过遍历所有可能的 CPU 聚合计数\n\n### 内核栈分配策略（`CONFIG_VMAP_STACK`）\n- **缓存机制**：每个 CPU 缓存最多 2 个已释放的栈（`NR_CACHED_STACKS`），减少 TLB 刷新和 vmalloc 开销\n- **内存分配**：\n  - 优先从本地缓存获取栈\n  - 缓存未命中时使用 `__vmalloc_node_range()` 分配连续虚拟地址空间\n  - 显式禁用 `__GFP_ACCOUNT`（因后续手动进行 memcg 计费）\n- **安全清理**：\n  - 重用栈时清零内存（`memset(stack, 0, THREAD_SIZE)`）\n  - KASAN 消毒（`kasan_unpoison_range`）和标签重置\n- **延迟释放**：\n  - 通过 RCU 机制延迟释放栈（`call_rcu`）\n  - 释放时尝试回填缓存，失败则直接 `vfree`\n\n### 内存控制组（memcg）集成\n- 手动对栈的每个物理页进行 memcg 计费（`memcg_kmem_charge_page`）\n- 计费失败时回滚已计费页面（`memcg_kmem_uncharge_page`）\n- 确保内核栈内存纳入 cgroup 内存限制\n\n### 锁与同步\n- `tasklist_lock` 作为全局任务列表的保护锁（读写锁）\n- 提供 `lockdep_tasklist_lock_is_held()` 供 RCU 锁验证使用\n- RCU 用于安全延迟释放内核栈资源\n\n## 4. 依赖关系\n\n### 内核子系统依赖\n- **内存管理 (MM)**：`<linux/mm.h>`, `<linux/vmalloc.h>`, `<linux/memcontrol.h>`\n- **调度器 (Scheduler)**：`<linux/sched/*.h>`, 任务状态和 CPU 绑定\n- **安全模块**：`<linux/security.h>`, `<linux/capability.h>`, `<linux/seccomp.h>`\n- **命名空间**：`<linux/nsproxy.h>`（UTS, IPC, PID, 网络等）\n- **文件系统**：`<linux/fs.h>`, `<linux/fdtable.h>`（文件描述符复制）\n- **跟踪与调试**：`<trace/events/sched.h>`, `<linux/ftrace.h>`, KASAN/KMSAN\n\n### 架构相关依赖\n- `<asm/pgalloc.h>`：页表分配\n- `<asm/mmu_context.h>`：MMU 上下文切换\n- `<asm/tlbflush.h>`：TLB 刷新操作\n- 架构特定的 `THREAD_SIZE` 和栈对齐要求\n\n### 配置选项依赖\n- `CONFIG_VMAP_STACK`：启用虚拟内存分配内核栈\n- `CONFIG_PROVE_RCU`：RCU 锁验证支持\n- `CONFIG_ARCH_TASK_STRUCT_ALLOCATOR`：架构自定义 task_struct 分配器\n- `CONFIG_MEMCG_KMEM`：内核内存 cgroup 支持\n\n## 5. 使用场景\n\n### 进程创建路径\n- **系统调用入口**：`sys_fork()`, `sys_vfork()`, `sys_clone()` 最终调用 `_do_fork()`\n- **内核线程创建**：`kthread_create()` 通过 `kernel_thread()` 触发 fork 逻辑\n- **容器/命名空间初始化**：新 PID/UTS/IPC 命名空间创建时伴随进程 fork\n\n### 资源复制关键点\n- **内存描述符 (mm_struct)**：通过 `dup_mm()` 复制地址空间（COW 页表）\n- **文件描述符表**：`dup_fd()` 复制打开文件表\n- **信号处理**：复制信号掩码和处理函数\n- **POSIX 定时器/异步 I/O**：复制相关上下文（如 `aio`, `posix-timers`）\n\n### 特殊场景处理\n- **写时复制优化**：避免物理内存立即复制，提升 fork 性能\n- **OOM Killer 集成**：在内存不足时参与进程选择\n- **审计与监控**：通过 `audit_alloc()` 和 `proc` 文件系统暴露进程信息\n- **实时性保障**：RT 任务 fork 时保持调度策略和优先级",
      "similarity": 0.5822583436965942,
      "chunks": [
        {
          "chunk_id": 16,
          "file_path": "kernel/fork.c",
          "start_line": 3480,
          "end_line": 3518,
          "content": [
            "int unshare_files(void)",
            "{",
            "\tstruct task_struct *task = current;",
            "\tstruct files_struct *old, *copy = NULL;",
            "\tint error;",
            "",
            "\terror = unshare_fd(CLONE_FILES, &copy);",
            "\tif (error || !copy)",
            "\t\treturn error;",
            "",
            "\told = task->files;",
            "\ttask_lock(task);",
            "\ttask->files = copy;",
            "\ttask_unlock(task);",
            "\tput_files_struct(old);",
            "\treturn 0;",
            "}",
            "int sysctl_max_threads(struct ctl_table *table, int write,",
            "\t\t       void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct ctl_table t;",
            "\tint ret;",
            "\tint threads = max_threads;",
            "\tint min = 1;",
            "\tint max = MAX_THREADS;",
            "",
            "\tt = *table;",
            "\tt.data = &threads;",
            "\tt.extra1 = &min;",
            "\tt.extra2 = &max;",
            "",
            "\tret = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);",
            "\tif (ret || !write)",
            "\t\treturn ret;",
            "",
            "\tmax_threads = threads;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "unshare_files, sysctl_max_threads",
          "description": "unshare_files函数复制当前进程的文件表结构并将其绑定到当前任务，sysctl_max_threads函数通过proc_dointvec_minmax接口限制系统最大线程数，支持读取和写入操作，其中写入时会更新全局max_threads变量。",
          "similarity": 0.6041353940963745
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/fork.c",
          "start_line": 666,
          "end_line": 845,
          "content": [
            "static __latent_entropy int dup_mmap(struct mm_struct *mm,",
            "\t\t\t\t\tstruct mm_struct *oldmm)",
            "{",
            "\tstruct vm_area_struct *mpnt, *tmp;",
            "\tint retval;",
            "\tunsigned long charge = 0;",
            "\tLIST_HEAD(uf);",
            "\tVMA_ITERATOR(vmi, mm, 0);",
            "",
            "\tuprobe_start_dup_mmap();",
            "\tif (mmap_write_lock_killable(oldmm)) {",
            "\t\tretval = -EINTR;",
            "\t\tgoto fail_uprobe_end;",
            "\t}",
            "\tflush_cache_dup_mm(oldmm);",
            "\tuprobe_dup_mmap(oldmm, mm);",
            "\t/*",
            "\t * Not linked in yet - no deadlock potential:",
            "\t */",
            "\tmmap_write_lock_nested(mm, SINGLE_DEPTH_NESTING);",
            "",
            "\t/* No ordering required: file already has been exposed. */",
            "\tdup_mm_exe_file(mm, oldmm);",
            "",
            "\tmm->total_vm = oldmm->total_vm;",
            "\tmm->data_vm = oldmm->data_vm;",
            "\tmm->exec_vm = oldmm->exec_vm;",
            "\tmm->stack_vm = oldmm->stack_vm;",
            "",
            "\t/* Use __mt_dup() to efficiently build an identical maple tree. */",
            "\tretval = __mt_dup(&oldmm->mm_mt, &mm->mm_mt, GFP_KERNEL);",
            "\tif (unlikely(retval))",
            "\t\tgoto out;",
            "",
            "\tmt_clear_in_rcu(vmi.mas.tree);",
            "\tfor_each_vma(vmi, mpnt) {",
            "\t\tstruct file *file;",
            "",
            "\t\tvma_start_write(mpnt);",
            "\t\tif (mpnt->vm_flags & VM_DONTCOPY) {",
            "\t\t\tretval = vma_iter_clear_gfp(&vmi, mpnt->vm_start,",
            "\t\t\t\t\t\t    mpnt->vm_end, GFP_KERNEL);",
            "\t\t\tif (retval)",
            "\t\t\t\tgoto loop_out;",
            "",
            "\t\t\tvm_stat_account(mm, mpnt->vm_flags, -vma_pages(mpnt));",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tcharge = 0;",
            "\t\t/*",
            "\t\t * Don't duplicate many vmas if we've been oom-killed (for",
            "\t\t * example)",
            "\t\t */",
            "\t\tif (fatal_signal_pending(current)) {",
            "\t\t\tretval = -EINTR;",
            "\t\t\tgoto loop_out;",
            "\t\t}",
            "\t\tif (mpnt->vm_flags & VM_ACCOUNT) {",
            "\t\t\tunsigned long len = vma_pages(mpnt);",
            "",
            "\t\t\tif (security_vm_enough_memory_mm(oldmm, len)) /* sic */",
            "\t\t\t\tgoto fail_nomem;",
            "\t\t\tcharge = len;",
            "\t\t}",
            "\t\ttmp = vm_area_dup(mpnt);",
            "\t\tif (!tmp)",
            "\t\t\tgoto fail_nomem;",
            "",
            "\t\t/* track_pfn_copy() will later take care of copying internal state. */",
            "\t\tif (unlikely(tmp->vm_flags & VM_PFNMAP))",
            "\t\t\tuntrack_pfn_clear(tmp);",
            "",
            "\t\tretval = vma_dup_policy(mpnt, tmp);",
            "\t\tif (retval)",
            "\t\t\tgoto fail_nomem_policy;",
            "\t\ttmp->vm_mm = mm;",
            "\t\tretval = dup_userfaultfd(tmp, &uf);",
            "\t\tif (retval)",
            "\t\t\tgoto fail_nomem_anon_vma_fork;",
            "\t\tif (tmp->vm_flags & VM_WIPEONFORK) {",
            "\t\t\t/*",
            "\t\t\t * VM_WIPEONFORK gets a clean slate in the child.",
            "\t\t\t * Don't prepare anon_vma until fault since we don't",
            "\t\t\t * copy page for current vma.",
            "\t\t\t */",
            "\t\t\ttmp->anon_vma = NULL;",
            "\t\t} else if (anon_vma_fork(tmp, mpnt))",
            "\t\t\tgoto fail_nomem_anon_vma_fork;",
            "\t\tvm_flags_clear(tmp, VM_LOCKED_MASK);",
            "\t\tfile = tmp->vm_file;",
            "\t\tif (file) {",
            "\t\t\tstruct address_space *mapping = file->f_mapping;",
            "",
            "\t\t\tget_file(file);",
            "\t\t\ti_mmap_lock_write(mapping);",
            "\t\t\tif (vma_is_shared_maywrite(tmp))",
            "\t\t\t\tmapping_allow_writable(mapping);",
            "\t\t\tflush_dcache_mmap_lock(mapping);",
            "\t\t\t/* insert tmp into the share list, just after mpnt */",
            "\t\t\tvma_interval_tree_insert_after(tmp, mpnt,",
            "\t\t\t\t\t&mapping->i_mmap);",
            "\t\t\tflush_dcache_mmap_unlock(mapping);",
            "\t\t\ti_mmap_unlock_write(mapping);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Copy/update hugetlb private vma information.",
            "\t\t */",
            "\t\tif (is_vm_hugetlb_page(tmp))",
            "\t\t\thugetlb_dup_vma_private(tmp);",
            "",
            "\t\t/*",
            "\t\t * Link the vma into the MT. After using __mt_dup(), memory",
            "\t\t * allocation is not necessary here, so it cannot fail.",
            "\t\t */",
            "\t\tvma_iter_bulk_store(&vmi, tmp);",
            "",
            "\t\tmm->map_count++;",
            "\t\tif (!(tmp->vm_flags & VM_WIPEONFORK))",
            "\t\t\tretval = copy_page_range(tmp, mpnt);",
            "",
            "\t\tif (tmp->vm_ops && tmp->vm_ops->open)",
            "\t\t\ttmp->vm_ops->open(tmp);",
            "",
            "\t\tif (retval) {",
            "\t\t\tmpnt = vma_next(&vmi);",
            "\t\t\tgoto loop_out;",
            "\t\t}",
            "\t}",
            "\t/* a new mm has just been created */",
            "\tretval = arch_dup_mmap(oldmm, mm);",
            "loop_out:",
            "\tvma_iter_free(&vmi);",
            "\tif (!retval) {",
            "\t\tmt_set_in_rcu(vmi.mas.tree);",
            "\t\tksm_fork(mm, oldmm);",
            "\t\tkhugepaged_fork(mm, oldmm);",
            "\t} else {",
            "",
            "\t\t/*",
            "\t\t * The entire maple tree has already been duplicated. If the",
            "\t\t * mmap duplication fails, mark the failure point with",
            "\t\t * XA_ZERO_ENTRY. In exit_mmap(), if this marker is encountered,",
            "\t\t * stop releasing VMAs that have not been duplicated after this",
            "\t\t * point.",
            "\t\t */",
            "\t\tif (mpnt) {",
            "\t\t\tmas_set_range(&vmi.mas, mpnt->vm_start, mpnt->vm_end - 1);",
            "\t\t\tmas_store(&vmi.mas, XA_ZERO_ENTRY);",
            "\t\t\t/* Avoid OOM iterating a broken tree */",
            "\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);",
            "\t\t}",
            "\t\t/*",
            "\t\t * The mm_struct is going to exit, but the locks will be dropped",
            "\t\t * first.  Set the mm_struct as unstable is advisable as it is",
            "\t\t * not fully initialised.",
            "\t\t */",
            "\t\tset_bit(MMF_UNSTABLE, &mm->flags);",
            "\t}",
            "out:",
            "\tmmap_write_unlock(mm);",
            "\tflush_tlb_mm(oldmm);",
            "\tmmap_write_unlock(oldmm);",
            "\tif (!retval)",
            "\t\tdup_userfaultfd_complete(&uf);",
            "\telse",
            "\t\tdup_userfaultfd_fail(&uf);",
            "fail_uprobe_end:",
            "\tuprobe_end_dup_mmap();",
            "\treturn retval;",
            "",
            "fail_nomem_anon_vma_fork:",
            "\tmpol_put(vma_policy(tmp));",
            "fail_nomem_policy:",
            "\tvm_area_free(tmp);",
            "fail_nomem:",
            "\tretval = -ENOMEM;",
            "\tvm_unacct_memory(charge);",
            "\tgoto loop_out;",
            "}"
          ],
          "function_name": "dup_mmap",
          "description": "实现进程fork时的内存映射复制逻辑，深度遍历原进程的VMA结构创建副本，处理共享文件映射、hugetlb页等特殊内存类型，并管理OOM异常情况下的失败恢复。",
          "similarity": 0.5459461212158203
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/fork.c",
          "start_line": 1863,
          "end_line": 1988,
          "content": [
            "static int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)",
            "{",
            "\tstruct sighand_struct *sig;",
            "",
            "\tif (clone_flags & CLONE_SIGHAND) {",
            "\t\trefcount_inc(&current->sighand->count);",
            "\t\treturn 0;",
            "\t}",
            "\tsig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);",
            "\tRCU_INIT_POINTER(tsk->sighand, sig);",
            "\tif (!sig)",
            "\t\treturn -ENOMEM;",
            "",
            "\trefcount_set(&sig->count, 1);",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "\tmemcpy(sig->action, current->sighand->action, sizeof(sig->action));",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "",
            "\t/* Reset all signal handler not set to SIG_IGN to SIG_DFL. */",
            "\tif (clone_flags & CLONE_CLEAR_SIGHAND)",
            "\t\tflush_signal_handlers(tsk, 0);",
            "",
            "\treturn 0;",
            "}",
            "void __cleanup_sighand(struct sighand_struct *sighand)",
            "{",
            "\tif (refcount_dec_and_test(&sighand->count)) {",
            "\t\tsignalfd_cleanup(sighand);",
            "\t\t/*",
            "\t\t * sighand_cachep is SLAB_TYPESAFE_BY_RCU so we can free it",
            "\t\t * without an RCU grace period, see __lock_task_sighand().",
            "\t\t */",
            "\t\tkmem_cache_free(sighand_cachep, sighand);",
            "\t}",
            "}",
            "static void posix_cpu_timers_init_group(struct signal_struct *sig)",
            "{",
            "\tstruct posix_cputimers *pct = &sig->posix_cputimers;",
            "\tunsigned long cpu_limit;",
            "",
            "\tcpu_limit = READ_ONCE(sig->rlim[RLIMIT_CPU].rlim_cur);",
            "\tposix_cputimers_group_init(pct, cpu_limit);",
            "}",
            "static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)",
            "{",
            "\tstruct signal_struct *sig;",
            "",
            "\tif (clone_flags & CLONE_THREAD)",
            "\t\treturn 0;",
            "",
            "\tsig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);",
            "\ttsk->signal = sig;",
            "\tif (!sig)",
            "\t\treturn -ENOMEM;",
            "",
            "\tsig->nr_threads = 1;",
            "\tsig->quick_threads = 1;",
            "\tatomic_set(&sig->live, 1);",
            "\trefcount_set(&sig->sigcnt, 1);",
            "",
            "\t/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */",
            "\tsig->thread_head = (struct list_head)LIST_HEAD_INIT(tsk->thread_node);",
            "\ttsk->thread_node = (struct list_head)LIST_HEAD_INIT(sig->thread_head);",
            "",
            "\tinit_waitqueue_head(&sig->wait_chldexit);",
            "\tsig->curr_target = tsk;",
            "\tinit_sigpending(&sig->shared_pending);",
            "\tINIT_HLIST_HEAD(&sig->multiprocess);",
            "\tseqlock_init(&sig->stats_lock);",
            "\tprev_cputime_init(&sig->prev_cputime);",
            "",
            "#ifdef CONFIG_POSIX_TIMERS",
            "\tINIT_LIST_HEAD(&sig->posix_timers);",
            "\thrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);",
            "\tsig->real_timer.function = it_real_fn;",
            "#endif",
            "",
            "\ttask_lock(current->group_leader);",
            "\tmemcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);",
            "\ttask_unlock(current->group_leader);",
            "",
            "\tposix_cpu_timers_init_group(sig);",
            "",
            "\ttty_audit_fork(sig);",
            "\tsched_autogroup_fork(sig);",
            "",
            "\tsig->oom_score_adj = current->signal->oom_score_adj;",
            "\tsig->oom_score_adj_min = current->signal->oom_score_adj_min;",
            "",
            "\tmutex_init(&sig->cred_guard_mutex);",
            "\tinit_rwsem(&sig->exec_update_lock);",
            "",
            "\treturn 0;",
            "}",
            "static void copy_seccomp(struct task_struct *p)",
            "{",
            "#ifdef CONFIG_SECCOMP",
            "\t/*",
            "\t * Must be called with sighand->lock held, which is common to",
            "\t * all threads in the group. Holding cred_guard_mutex is not",
            "\t * needed because this new task is not yet running and cannot",
            "\t * be racing exec.",
            "\t */",
            "\tassert_spin_locked(&current->sighand->siglock);",
            "",
            "\t/* Ref-count the new filter user, and assign it. */",
            "\tget_seccomp_filter(current);",
            "\tp->seccomp = current->seccomp;",
            "",
            "\t/*",
            "\t * Explicitly enable no_new_privs here in case it got set",
            "\t * between the task_struct being duplicated and holding the",
            "\t * sighand lock. The seccomp state and nnp must be in sync.",
            "\t */",
            "\tif (task_no_new_privs(current))",
            "\t\ttask_set_no_new_privs(p);",
            "",
            "\t/*",
            "\t * If the parent gained a seccomp mode after copying thread",
            "\t * flags and between before we held the sighand lock, we have",
            "\t * to manually enable the seccomp thread flag here.",
            "\t */",
            "\tif (p->seccomp.mode != SECCOMP_MODE_DISABLED)",
            "\t\tset_task_syscall_work(p, SECCOMP);",
            "#endif",
            "}"
          ],
          "function_name": "copy_sighand, __cleanup_sighand, posix_cpu_timers_init_group, copy_signal, copy_seccomp",
          "description": "实现进程克隆时信号处理手柄的复制逻辑，根据克隆标志决定是否共享或新建sighand结构体，同步信号动作数组并处理信号处理器重置，包含seccomp过滤器和线程组资源的复制",
          "similarity": 0.5435971021652222
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/fork.c",
          "start_line": 1710,
          "end_line": 1810,
          "content": [
            "void exit_mm_release(struct task_struct *tsk, struct mm_struct *mm)",
            "{",
            "\tfutex_exit_release(tsk);",
            "\tmm_release(tsk, mm);",
            "}",
            "void exec_mm_release(struct task_struct *tsk, struct mm_struct *mm)",
            "{",
            "\tfutex_exec_release(tsk);",
            "\tmm_release(tsk, mm);",
            "}",
            "static int copy_mm(unsigned long clone_flags, struct task_struct *tsk)",
            "{",
            "\tstruct mm_struct *mm, *oldmm;",
            "",
            "\ttsk->min_flt = tsk->maj_flt = 0;",
            "\ttsk->nvcsw = tsk->nivcsw = 0;",
            "#ifdef CONFIG_DETECT_HUNG_TASK",
            "\ttsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;",
            "\ttsk->last_switch_time = 0;",
            "#endif",
            "",
            "\ttsk->mm = NULL;",
            "\t#ifdef CONFIG_IEE",
            "\tiee_set_token_pgd(tsk, NULL);",
            "\t#endif",
            "\ttsk->active_mm = NULL;",
            "",
            "\t/*",
            "\t * Are we cloning a kernel thread?",
            "\t *",
            "\t * We need to steal a active VM for that..",
            "\t */",
            "\toldmm = current->mm;",
            "\tif (!oldmm)",
            "\t\treturn 0;",
            "",
            "\tif (clone_flags & CLONE_VM) {",
            "\t\tmmget(oldmm);",
            "\t\tmm = oldmm;",
            "\t} else {",
            "\t\tmm = dup_mm(tsk, current->mm);",
            "\t\tif (!mm)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\ttsk->mm = mm;",
            "\t#ifdef CONFIG_IEE",
            "\tiee_set_token_pgd(tsk, mm->pgd);",
            "\t#endif",
            "\ttsk->active_mm = mm;",
            "\tsched_mm_cid_fork(tsk);",
            "\treturn 0;",
            "}",
            "static int copy_fs(unsigned long clone_flags, struct task_struct *tsk)",
            "{",
            "\tstruct fs_struct *fs = current->fs;",
            "\tif (clone_flags & CLONE_FS) {",
            "\t\t/* tsk->fs is already what we want */",
            "\t\tspin_lock(&fs->lock);",
            "\t\tif (fs->in_exec) {",
            "\t\t\tspin_unlock(&fs->lock);",
            "\t\t\treturn -EAGAIN;",
            "\t\t}",
            "\t\tfs->users++;",
            "\t\tspin_unlock(&fs->lock);",
            "\t\treturn 0;",
            "\t}",
            "\ttsk->fs = copy_fs_struct(fs);",
            "\tif (!tsk->fs)",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "static int copy_files(unsigned long clone_flags, struct task_struct *tsk,",
            "\t\t      int no_files)",
            "{",
            "\tstruct files_struct *oldf, *newf;",
            "",
            "\t/*",
            "\t * A background process may not have any files ...",
            "\t */",
            "\toldf = current->files;",
            "\tif (!oldf)",
            "\t\treturn 0;",
            "",
            "\tif (no_files) {",
            "\t\ttsk->files = NULL;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tif (clone_flags & CLONE_FILES) {",
            "\t\tatomic_inc(&oldf->count);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tnewf = dup_fd(oldf, NULL);",
            "\tif (IS_ERR(newf))",
            "\t\treturn PTR_ERR(newf);",
            "",
            "\ttsk->files = newf;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "exit_mm_release, exec_mm_release, copy_mm, copy_fs, copy_files",
          "description": "处理进程退出时的mm释放流程，复制mm结构体及其相关资源（文件系统、文件描述符），支持CLONE_VM等克隆标志的差异化处理。",
          "similarity": 0.5420094728469849
        },
        {
          "chunk_id": 15,
          "file_path": "kernel/fork.c",
          "start_line": 3273,
          "end_line": 3450,
          "content": [
            "static int check_unshare_flags(unsigned long unshare_flags)",
            "{",
            "\tif (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|",
            "\t\t\t\tCLONE_VM|CLONE_FILES|CLONE_SYSVSEM|",
            "\t\t\t\tCLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET|",
            "\t\t\t\tCLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWCGROUP|",
            "\t\t\t\tCLONE_NEWTIME))",
            "\t\treturn -EINVAL;",
            "\t/*",
            "\t * Not implemented, but pretend it works if there is nothing",
            "\t * to unshare.  Note that unsharing the address space or the",
            "\t * signal handlers also need to unshare the signal queues (aka",
            "\t * CLONE_THREAD).",
            "\t */",
            "\tif (unshare_flags & (CLONE_THREAD | CLONE_SIGHAND | CLONE_VM)) {",
            "\t\tif (!thread_group_empty(current))",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "\tif (unshare_flags & (CLONE_SIGHAND | CLONE_VM)) {",
            "\t\tif (refcount_read(&current->sighand->count) > 1)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "\tif (unshare_flags & CLONE_VM) {",
            "\t\tif (!current_is_single_threaded())",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)",
            "{",
            "\tstruct fs_struct *fs = current->fs;",
            "",
            "\tif (!(unshare_flags & CLONE_FS) || !fs)",
            "\t\treturn 0;",
            "",
            "\t/* don't need lock here; in the worst case we'll do useless copy */",
            "\tif (fs->users == 1)",
            "\t\treturn 0;",
            "",
            "\t*new_fsp = copy_fs_struct(fs);",
            "\tif (!*new_fsp)",
            "\t\treturn -ENOMEM;",
            "",
            "\treturn 0;",
            "}",
            "static int unshare_fd(unsigned long unshare_flags, struct files_struct **new_fdp)",
            "{",
            "\tstruct files_struct *fd = current->files;",
            "",
            "\tif ((unshare_flags & CLONE_FILES) &&",
            "\t    (fd && atomic_read(&fd->count) > 1)) {",
            "\t\tfd = dup_fd(fd, NULL);",
            "\t\tif (IS_ERR(fd))",
            "\t\t\treturn PTR_ERR(fd);",
            "\t\t*new_fdp = fd;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int ksys_unshare(unsigned long unshare_flags)",
            "{",
            "\tstruct fs_struct *fs, *new_fs = NULL;",
            "\tstruct files_struct *new_fd = NULL;",
            "\tstruct cred *new_cred = NULL;",
            "\tstruct nsproxy *new_nsproxy = NULL;",
            "\tint do_sysvsem = 0;",
            "\tint err;",
            "",
            "\t/*",
            "\t * If unsharing a user namespace must also unshare the thread group",
            "\t * and unshare the filesystem root and working directories.",
            "\t */",
            "\tif (unshare_flags & CLONE_NEWUSER)",
            "\t\tunshare_flags |= CLONE_THREAD | CLONE_FS;",
            "\t/*",
            "\t * If unsharing vm, must also unshare signal handlers.",
            "\t */",
            "\tif (unshare_flags & CLONE_VM)",
            "\t\tunshare_flags |= CLONE_SIGHAND;",
            "\t/*",
            "\t * If unsharing a signal handlers, must also unshare the signal queues.",
            "\t */",
            "\tif (unshare_flags & CLONE_SIGHAND)",
            "\t\tunshare_flags |= CLONE_THREAD;",
            "\t/*",
            "\t * If unsharing namespace, must also unshare filesystem information.",
            "\t */",
            "\tif (unshare_flags & CLONE_NEWNS)",
            "\t\tunshare_flags |= CLONE_FS;",
            "",
            "\terr = check_unshare_flags(unshare_flags);",
            "\tif (err)",
            "\t\tgoto bad_unshare_out;",
            "\t/*",
            "\t * CLONE_NEWIPC must also detach from the undolist: after switching",
            "\t * to a new ipc namespace, the semaphore arrays from the old",
            "\t * namespace are unreachable.",
            "\t */",
            "\tif (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))",
            "\t\tdo_sysvsem = 1;",
            "\terr = unshare_fs(unshare_flags, &new_fs);",
            "\tif (err)",
            "\t\tgoto bad_unshare_out;",
            "\terr = unshare_fd(unshare_flags, &new_fd);",
            "\tif (err)",
            "\t\tgoto bad_unshare_cleanup_fs;",
            "\terr = unshare_userns(unshare_flags, &new_cred);",
            "\tif (err)",
            "\t\tgoto bad_unshare_cleanup_fd;",
            "\terr = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,",
            "\t\t\t\t\t new_cred, new_fs);",
            "\tif (err)",
            "\t\tgoto bad_unshare_cleanup_cred;",
            "",
            "\tif (new_cred) {",
            "\t\terr = set_cred_ucounts(new_cred);",
            "\t\tif (err)",
            "\t\t\tgoto bad_unshare_cleanup_cred;",
            "\t}",
            "",
            "\tif (new_fs || new_fd || do_sysvsem || new_cred || new_nsproxy) {",
            "\t\tif (do_sysvsem) {",
            "\t\t\t/*",
            "\t\t\t * CLONE_SYSVSEM is equivalent to sys_exit().",
            "\t\t\t */",
            "\t\t\texit_sem(current);",
            "\t\t}",
            "\t\tif (unshare_flags & CLONE_NEWIPC) {",
            "\t\t\t/* Orphan segments in old ns (see sem above). */",
            "\t\t\texit_shm(current);",
            "\t\t\tshm_init_task(current);",
            "\t\t}",
            "",
            "\t\tif (new_nsproxy)",
            "\t\t\tswitch_task_namespaces(current, new_nsproxy);",
            "",
            "\t\ttask_lock(current);",
            "",
            "\t\tif (new_fs) {",
            "\t\t\tfs = current->fs;",
            "\t\t\tspin_lock(&fs->lock);",
            "\t\t\tcurrent->fs = new_fs;",
            "\t\t\tif (--fs->users)",
            "\t\t\t\tnew_fs = NULL;",
            "\t\t\telse",
            "\t\t\t\tnew_fs = fs;",
            "\t\t\tspin_unlock(&fs->lock);",
            "\t\t}",
            "",
            "\t\tif (new_fd)",
            "\t\t\tswap(current->files, new_fd);",
            "",
            "\t\ttask_unlock(current);",
            "",
            "\t\tif (new_cred) {",
            "\t\t\t/* Install the new user namespace */",
            "\t\t\tcommit_creds(new_cred);",
            "\t\t\tnew_cred = NULL;",
            "\t\t}",
            "\t}",
            "",
            "\tperf_event_namespaces(current);",
            "",
            "bad_unshare_cleanup_cred:",
            "\tif (new_cred)",
            "\t\tput_cred(new_cred);",
            "bad_unshare_cleanup_fd:",
            "\tif (new_fd)",
            "\t\tput_files_struct(new_fd);",
            "",
            "bad_unshare_cleanup_fs:",
            "\tif (new_fs)",
            "\t\tfree_fs_struct(new_fs);",
            "",
            "bad_unshare_out:",
            "\treturn err;",
            "}"
          ],
          "function_name": "check_unshare_flags, unshare_fs, unshare_fd, ksys_unshare",
          "description": "检查unshare标志的有效性，验证CLONE_THREAD/CLONE_SIGHAND/CLONE_VM等标志组合是否合法，确保线程组为空且信号处理共享计数正确。随后依次处理文件系统、文件描述符、用户命名空间等资源的分离操作，最终通过switch_task_namespaces切换命名空间并更新任务结构体。",
          "similarity": 0.5400018692016602
        }
      ]
    }
  ]
}