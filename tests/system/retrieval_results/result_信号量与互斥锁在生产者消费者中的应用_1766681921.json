{
  "query": "信号量与互斥锁在生产者消费者中的应用",
  "timestamp": "2025-12-26 00:58:41",
  "retrieved_files": [
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.5427776575088501,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.5162850618362427
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.5051007270812988
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.48083141446113586
        }
      ]
    },
    {
      "source_file": "kernel/locking/mutex.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:42:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\mutex.c`\n\n---\n\n# Linux 内核互斥锁（mutex）实现文档\n\n## 1. 文件概述\n\n`locking/mutex.c` 是 Linux 内核中互斥锁（mutex）的核心实现文件，提供了基于阻塞的互斥同步原语。该文件实现了高效、可睡眠的互斥锁机制，支持自旋优化、锁移交（handoff）、调试功能以及与调度器、死锁检测等子系统的深度集成。互斥锁用于保护临界区，确保同一时间只有一个任务可以持有锁，适用于需要长时间持有锁或可能睡眠的场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `__mutex_init()`：初始化互斥锁对象\n- `mutex_is_locked()`：检查互斥锁是否已被持有\n- `mutex_get_owner()`：获取当前锁持有者的任务指针（仅用于调试）\n- `__mutex_trylock()`：尝试获取互斥锁（非阻塞）\n- `__mutex_trylock_fast()`：快速路径尝试获取未竞争的锁\n- `__mutex_unlock_fast()`：快速路径释放锁\n- `__mutex_lock_slowpath()`：慢速路径获取锁（包含睡眠和等待逻辑）\n- `__mutex_handoff()`：将锁所有权移交给指定任务\n- `__mutex_add_waiter()` / `__mutex_remove_waiter()`：管理等待队列\n\n### 关键数据结构\n\n- `struct mutex`：互斥锁核心结构体\n  - `atomic_long_t owner`：原子存储锁持有者指针和状态标志\n  - `raw_spinlock_t wait_lock`：保护等待队列的自旋锁\n  - `struct list_head wait_list`：等待获取锁的任务队列\n  - `struct optimistic_spin_queue osq`：用于自旋优化的队列（CONFIG_MUTEX_SPIN_ON_OWNER）\n\n### 状态标志位\n\n- `MUTEX_FLAG_WAITERS (0x01)`：表示存在等待者，解锁时需唤醒\n- `MUTEX_FLAG_HANDOFF (0x02)`：表示需要将锁移交给队首等待者\n- `MUTEX_FLAG_PICKUP (0x04)`：表示锁已被移交给特定任务，等待其获取\n\n## 3. 关键实现\n\n### 锁状态编码\n互斥锁的 `owner` 字段采用指针-标志位混合编码：利用 `task_struct` 指针的低 3 位（因内存对齐保证为 0）存储状态标志。这种设计避免了额外的内存访问，提高了原子操作效率。\n\n### 快慢路径分离\n- **快速路径**：针对无竞争场景，直接通过原子比较交换（cmpxchg）获取/释放锁，避免函数调用开销\n- **慢速路径**：处理竞争情况，包含自旋等待、任务阻塞、唤醒等复杂逻辑\n\n### 自适应自旋（Adaptive Spinning）\n在 `CONFIG_MUTEX_SPIN_ON_OWNER` 配置下，当检测到锁持有者正在运行时，当前任务会先自旋等待而非立即睡眠，减少上下文切换开销。使用 OSQ（Optimistic Spin Queue）机制协调多个自旋任务。\n\n### 锁移交机制（Handoff）\n通过 `MUTEX_FLAG_HANDOFF` 和 `MUTEX_FLAG_PICKUP` 标志实现高效的锁移交：\n1. 解锁者设置 `HANDOFF` 标志并唤醒队首等待者\n2. 被唤醒任务在获取锁时检测到 `HANDOFF`，设置 `PICKUP` 标志\n3. 解锁者通过 `__mutex_handoff()` 直接将所有权转移给指定任务\n避免了唤醒后再次竞争的问题，提高实时性。\n\n### 调试支持\n- `CONFIG_DEBUG_MUTEXES`：提供锁状态验证、死锁检测\n- `CONFIG_DETECT_HUNG_TASK_BLOCKER`：集成 hung task 检测，记录阻塞源\n- `lockdep`：通过 `debug_mutex_*` 函数集成锁依赖验证\n\n## 4. 依赖关系\n\n### 头文件依赖\n- `<linux/mutex.h>` / `<linux/ww_mutex.h>`：互斥锁接口定义\n- `<linux/sched/*.h>`：调度器相关功能（睡眠、唤醒、实时任务）\n- `<linux/spinlock.h>`：底层自旋锁实现\n- `<linux/osq_lock.h>`：乐观自旋队列支持\n- `<linux/hung_task.h>`：hung task 检测集成\n- `<trace/events/lock.h>`：锁事件跟踪点\n\n### 子系统交互\n- **调度器**：通过 `schedule()` 实现任务阻塞，`wake_q` 机制批量唤醒\n- **内存管理**：依赖 `task_struct` 的内存对齐特性\n- **实时补丁（PREEMPT_RT）**：非 RT 配置下编译此文件（`#ifndef CONFIG_PREEMPT_RT`）\n- **调试子系统**：与 lockdep、hung task detector 深度集成\n\n## 5. 使用场景\n\n### 典型应用场景\n- **长临界区保护**：当临界区执行时间较长或包含可能睡眠的操作（如内存分配、I/O）\n- **驱动程序同步**：设备驱动中保护硬件寄存器访问或共享数据结构\n- **文件系统操作**：保护 inode、dentry 等元数据结构\n- **内核子系统互斥**：如网络协议栈、块设备层等需要互斥访问的场景\n\n### 使用约束\n- **不可递归**：同一任务重复获取会导致死锁\n- **必须配对使用**：获取锁的任务必须负责释放\n- **禁止中断上下文使用**：因可能睡眠，只能在进程上下文使用\n- **内存生命周期**：锁对象内存不能在持有锁时释放\n\n### 性能考量\n- 无竞争场景：纳秒级延迟（快速路径原子操作）\n- 有竞争场景：微秒级延迟（自旋优化）或毫秒级（任务切换）\n- 适用于中低频竞争场景，高频竞争建议使用读写锁或 RCU",
      "similarity": 0.5332646369934082,
      "chunks": [
        {
          "chunk_id": 6,
          "file_path": "kernel/locking/mutex.c",
          "start_line": 1059,
          "end_line": 1129,
          "content": [
            "static noinline int __sched",
            "__mutex_lock_interruptible_slowpath(struct mutex *lock)",
            "{",
            "\treturn __mutex_lock(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);",
            "}",
            "static noinline int __sched",
            "__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)",
            "{",
            "\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0,",
            "\t\t\t       _RET_IP_, ctx);",
            "}",
            "static noinline int __sched",
            "__ww_mutex_lock_interruptible_slowpath(struct ww_mutex *lock,",
            "\t\t\t\t\t    struct ww_acquire_ctx *ctx)",
            "{",
            "\treturn __ww_mutex_lock(&lock->base, TASK_INTERRUPTIBLE, 0,",
            "\t\t\t       _RET_IP_, ctx);",
            "}",
            "int __sched mutex_trylock(struct mutex *lock)",
            "{",
            "\tbool locked;",
            "",
            "\tMUTEX_WARN_ON(lock->magic != lock);",
            "",
            "\tlocked = __mutex_trylock(lock);",
            "\tif (locked)",
            "\t\tmutex_acquire(&lock->dep_map, 0, 1, _RET_IP_);",
            "",
            "\treturn locked;",
            "}",
            "int __sched",
            "ww_mutex_lock(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)",
            "{",
            "\tmight_sleep();",
            "",
            "\tif (__mutex_trylock_fast(&lock->base)) {",
            "\t\tif (ctx)",
            "\t\t\tww_mutex_set_context_fastpath(lock, ctx);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\treturn __ww_mutex_lock_slowpath(lock, ctx);",
            "}",
            "int __sched",
            "ww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)",
            "{",
            "\tmight_sleep();",
            "",
            "\tif (__mutex_trylock_fast(&lock->base)) {",
            "\t\tif (ctx)",
            "\t\t\tww_mutex_set_context_fastpath(lock, ctx);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);",
            "}",
            "int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock)",
            "{",
            "\t/* dec if we can't possibly hit 0 */",
            "\tif (atomic_add_unless(cnt, -1, 1))",
            "\t\treturn 0;",
            "\t/* we might hit 0, so take the lock */",
            "\tmutex_lock(lock);",
            "\tif (!atomic_dec_and_test(cnt)) {",
            "\t\t/* when we actually did the dec, we didn't hit 0 */",
            "\t\tmutex_unlock(lock);",
            "\t\treturn 0;",
            "\t}",
            "\t/* we hit 0, and we hold the lock */",
            "\treturn 1;",
            "}"
          ],
          "function_name": "__mutex_lock_interruptible_slowpath, __ww_mutex_lock_slowpath, __ww_mutex_lock_interruptible_slowpath, mutex_trylock, ww_mutex_lock, ww_mutex_lock_interruptible, atomic_dec_and_mutex_lock",
          "description": "提供互斥锁快速路径与慢速路径切换支持，包含原子计数器递减与锁获取协同机制",
          "similarity": 0.6470293402671814
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/mutex.c",
          "start_line": 46,
          "end_line": 151,
          "content": [
            "void",
            "__mutex_init(struct mutex *lock, const char *name, struct lock_class_key *key)",
            "{",
            "\tatomic_long_set(&lock->owner, 0);",
            "\traw_spin_lock_init(&lock->wait_lock);",
            "\tINIT_LIST_HEAD(&lock->wait_list);",
            "#ifdef CONFIG_MUTEX_SPIN_ON_OWNER",
            "\tosq_lock_init(&lock->osq);",
            "#endif",
            "",
            "\tdebug_mutex_init(lock, name, key);",
            "}",
            "bool mutex_is_locked(struct mutex *lock)",
            "{",
            "\treturn __mutex_owner(lock) != NULL;",
            "}",
            "static inline unsigned long __owner_flags(unsigned long owner)",
            "{",
            "\treturn owner & MUTEX_FLAGS;",
            "}",
            "unsigned long mutex_get_owner(struct mutex *lock)",
            "{",
            "\tunsigned long owner = atomic_long_read(&lock->owner);",
            "",
            "\treturn (unsigned long)__owner_task(owner);",
            "}",
            "static inline bool __mutex_trylock_or_handoff(struct mutex *lock, bool handoff)",
            "{",
            "\treturn !__mutex_trylock_common(lock, handoff);",
            "}",
            "static inline bool __mutex_trylock(struct mutex *lock)",
            "{",
            "\treturn !__mutex_trylock_common(lock, false);",
            "}",
            "static __always_inline bool __mutex_trylock_fast(struct mutex *lock)",
            "{",
            "\tunsigned long curr = (unsigned long)current;",
            "\tunsigned long zero = 0UL;",
            "",
            "\tif (atomic_long_try_cmpxchg_acquire(&lock->owner, &zero, curr))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "static __always_inline bool __mutex_unlock_fast(struct mutex *lock)",
            "{",
            "\tunsigned long curr = (unsigned long)current;",
            "",
            "\treturn atomic_long_try_cmpxchg_release(&lock->owner, &curr, 0UL);",
            "}",
            "static inline void __mutex_set_flag(struct mutex *lock, unsigned long flag)",
            "{",
            "\tatomic_long_or(flag, &lock->owner);",
            "}",
            "static inline void __mutex_clear_flag(struct mutex *lock, unsigned long flag)",
            "{",
            "\tatomic_long_andnot(flag, &lock->owner);",
            "}",
            "static inline bool __mutex_waiter_is_first(struct mutex *lock, struct mutex_waiter *waiter)",
            "{",
            "\treturn list_first_entry(&lock->wait_list, struct mutex_waiter, list) == waiter;",
            "}",
            "static void",
            "__mutex_add_waiter(struct mutex *lock, struct mutex_waiter *waiter,",
            "\t\t   struct list_head *list)",
            "{",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER",
            "\thung_task_set_blocker(lock, BLOCKER_TYPE_MUTEX);",
            "#endif",
            "\tdebug_mutex_add_waiter(lock, waiter, current);",
            "",
            "\tlist_add_tail(&waiter->list, list);",
            "\tif (__mutex_waiter_is_first(lock, waiter))",
            "\t\t__mutex_set_flag(lock, MUTEX_FLAG_WAITERS);",
            "}",
            "static void",
            "__mutex_remove_waiter(struct mutex *lock, struct mutex_waiter *waiter)",
            "{",
            "\tlist_del(&waiter->list);",
            "\tif (likely(list_empty(&lock->wait_list)))",
            "\t\t__mutex_clear_flag(lock, MUTEX_FLAGS);",
            "",
            "\tdebug_mutex_remove_waiter(lock, waiter, current);",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER",
            "\thung_task_clear_blocker();",
            "#endif",
            "}",
            "static void __mutex_handoff(struct mutex *lock, struct task_struct *task)",
            "{",
            "\tunsigned long owner = atomic_long_read(&lock->owner);",
            "",
            "\tfor (;;) {",
            "\t\tunsigned long new;",
            "",
            "\t\tMUTEX_WARN_ON(__owner_task(owner) != current);",
            "\t\tMUTEX_WARN_ON(owner & MUTEX_FLAG_PICKUP);",
            "",
            "\t\tnew = (owner & MUTEX_FLAG_WAITERS);",
            "\t\tnew |= (unsigned long)task;",
            "\t\tif (task)",
            "\t\t\tnew |= MUTEX_FLAG_PICKUP;",
            "",
            "\t\tif (atomic_long_try_cmpxchg_release(&lock->owner, &owner, new))",
            "\t\t\tbreak;",
            "\t}",
            "}"
          ],
          "function_name": "__mutex_init, mutex_is_locked, __owner_flags, mutex_get_owner, __mutex_trylock_or_handoff, __mutex_trylock, __mutex_trylock_fast, __mutex_unlock_fast, __mutex_set_flag, __mutex_clear_flag, __mutex_waiter_is_first, __mutex_add_waiter, __mutex_remove_waiter, __mutex_handoff",
          "description": "实现互斥锁核心操作，包括初始化、状态检查、快速尝试加锁、标志位操作及等待者链表管理。",
          "similarity": 0.6137877702713013
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/locking/mutex.c",
          "start_line": 895,
          "end_line": 996,
          "content": [
            "int __sched",
            "ww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)",
            "{",
            "\tint ret;",
            "",
            "\tmight_sleep();",
            "\tret = __ww_mutex_lock(&lock->base, TASK_INTERRUPTIBLE,",
            "\t\t\t      0, _RET_IP_, ctx);",
            "",
            "\tif (!ret && ctx && ctx->acquired > 1)",
            "\t\treturn ww_mutex_deadlock_injection(lock, ctx);",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __mutex_unlock_slowpath(struct mutex *lock, unsigned long ip)",
            "{",
            "\tstruct task_struct *next = NULL;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "\tunsigned long owner;",
            "",
            "\tmutex_release(&lock->dep_map, ip);",
            "",
            "\t/*",
            "\t * Release the lock before (potentially) taking the spinlock such that",
            "\t * other contenders can get on with things ASAP.",
            "\t *",
            "\t * Except when HANDOFF, in that case we must not clear the owner field,",
            "\t * but instead set it to the top waiter.",
            "\t */",
            "\towner = atomic_long_read(&lock->owner);",
            "\tfor (;;) {",
            "\t\tMUTEX_WARN_ON(__owner_task(owner) != current);",
            "\t\tMUTEX_WARN_ON(owner & MUTEX_FLAG_PICKUP);",
            "",
            "\t\tif (owner & MUTEX_FLAG_HANDOFF)",
            "\t\t\tbreak;",
            "",
            "\t\tif (atomic_long_try_cmpxchg_release(&lock->owner, &owner, __owner_flags(owner))) {",
            "\t\t\tif (owner & MUTEX_FLAG_WAITERS)",
            "\t\t\t\tbreak;",
            "",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "",
            "\traw_spin_lock(&lock->wait_lock);",
            "\tdebug_mutex_unlock(lock);",
            "\tif (!list_empty(&lock->wait_list)) {",
            "\t\t/* get the first entry from the wait-list: */",
            "\t\tstruct mutex_waiter *waiter =",
            "\t\t\tlist_first_entry(&lock->wait_list,",
            "\t\t\t\t\t struct mutex_waiter, list);",
            "",
            "\t\tnext = waiter->task;",
            "",
            "\t\tdebug_mutex_wake_waiter(lock, waiter);",
            "\t\twake_q_add(&wake_q, next);",
            "\t}",
            "",
            "\tif (owner & MUTEX_FLAG_HANDOFF)",
            "\t\t__mutex_handoff(lock, next);",
            "",
            "\traw_spin_unlock(&lock->wait_lock);",
            "",
            "\twake_up_q(&wake_q);",
            "}",
            "int __sched mutex_lock_interruptible(struct mutex *lock)",
            "{",
            "\tmight_sleep();",
            "",
            "\tif (__mutex_trylock_fast(lock))",
            "\t\treturn 0;",
            "",
            "\treturn __mutex_lock_interruptible_slowpath(lock);",
            "}",
            "int __sched mutex_lock_killable(struct mutex *lock)",
            "{",
            "\tmight_sleep();",
            "",
            "\tif (__mutex_trylock_fast(lock))",
            "\t\treturn 0;",
            "",
            "\treturn __mutex_lock_killable_slowpath(lock);",
            "}",
            "void __sched mutex_lock_io(struct mutex *lock)",
            "{",
            "\tint token;",
            "",
            "\ttoken = io_schedule_prepare();",
            "\tmutex_lock(lock);",
            "\tio_schedule_finish(token);",
            "}",
            "static noinline void __sched",
            "__mutex_lock_slowpath(struct mutex *lock)",
            "{",
            "\t__mutex_lock(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);",
            "}",
            "static noinline int __sched",
            "__mutex_lock_killable_slowpath(struct mutex *lock)",
            "{",
            "\treturn __mutex_lock(lock, TASK_KILLABLE, 0, NULL, _RET_IP_);",
            "}"
          ],
          "function_name": "ww_mutex_lock_interruptible, __mutex_unlock_slowpath, mutex_lock_interruptible, mutex_lock_killable, mutex_lock_io, __mutex_lock_slowpath, __mutex_lock_killable_slowpath",
          "description": "实现带死锁检测的递归互斥锁中断获取逻辑，处理锁状态转换、唤醒等待线程及异常注入场景",
          "similarity": 0.5743250846862793
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/mutex.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * kernel/locking/mutex.c",
            " *",
            " * Mutexes: blocking mutual exclusion locks",
            " *",
            " * Started by Ingo Molnar:",
            " *",
            " *  Copyright (C) 2004, 2005, 2006 Red Hat, Inc., Ingo Molnar <mingo@redhat.com>",
            " *",
            " * Many thanks to Arjan van de Ven, Thomas Gleixner, Steven Rostedt and",
            " * David Howells for suggestions and improvements.",
            " *",
            " *  - Adaptive spinning for mutexes by Peter Zijlstra. (Ported to mainline",
            " *    from the -rt tree, where it was originally implemented for rtmutexes",
            " *    by Steven Rostedt, based on work by Gregory Haskins, Peter Morreale",
            " *    and Sven Dietrich.",
            " *",
            " * Also see Documentation/locking/mutex-design.rst.",
            " */",
            "#include <linux/mutex.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/osq_lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/lock.h>",
            "",
            "#ifndef CONFIG_PREEMPT_RT",
            "#include \"mutex.h\"",
            "",
            "#ifdef CONFIG_DEBUG_MUTEXES",
            "# define MUTEX_WARN_ON(cond) DEBUG_LOCKS_WARN_ON(cond)",
            "#else",
            "# define MUTEX_WARN_ON(cond)",
            "#endif",
            ""
          ],
          "function_name": null,
          "description": "声明互斥锁模块的头文件和基本配置，初始化互斥锁结构体并设置等待队列及调试信息。",
          "similarity": 0.5695297718048096
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/locking/mutex.c",
          "start_line": 758,
          "end_line": 862,
          "content": [
            "static int __sched",
            "__mutex_lock(struct mutex *lock, unsigned int state, unsigned int subclass,",
            "\t     struct lockdep_map *nest_lock, unsigned long ip)",
            "{",
            "\treturn __mutex_lock_common(lock, state, subclass, nest_lock, ip, NULL, false);",
            "}",
            "static int __sched",
            "__ww_mutex_lock(struct mutex *lock, unsigned int state, unsigned int subclass,",
            "\t\tunsigned long ip, struct ww_acquire_ctx *ww_ctx)",
            "{",
            "\treturn __mutex_lock_common(lock, state, subclass, NULL, ip, ww_ctx, true);",
            "}",
            "int ww_mutex_trylock(struct ww_mutex *ww, struct ww_acquire_ctx *ww_ctx)",
            "{",
            "\tif (!ww_ctx)",
            "\t\treturn mutex_trylock(&ww->base);",
            "",
            "\tMUTEX_WARN_ON(ww->base.magic != &ww->base);",
            "",
            "\t/*",
            "\t * Reset the wounded flag after a kill. No other process can",
            "\t * race and wound us here, since they can't have a valid owner",
            "\t * pointer if we don't have any locks held.",
            "\t */",
            "\tif (ww_ctx->acquired == 0)",
            "\t\tww_ctx->wounded = 0;",
            "",
            "\tif (__mutex_trylock(&ww->base)) {",
            "\t\tww_mutex_set_context_fastpath(ww, ww_ctx);",
            "\t\tmutex_acquire_nest(&ww->base.dep_map, 0, 1, &ww_ctx->dep_map, _RET_IP_);",
            "\t\treturn 1;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void __sched",
            "mutex_lock_nested(struct mutex *lock, unsigned int subclass)",
            "{",
            "\t__mutex_lock(lock, TASK_UNINTERRUPTIBLE, subclass, NULL, _RET_IP_);",
            "}",
            "void __sched",
            "_mutex_lock_nest_lock(struct mutex *lock, struct lockdep_map *nest)",
            "{",
            "\t__mutex_lock(lock, TASK_UNINTERRUPTIBLE, 0, nest, _RET_IP_);",
            "}",
            "int __sched",
            "mutex_lock_killable_nested(struct mutex *lock, unsigned int subclass)",
            "{",
            "\treturn __mutex_lock(lock, TASK_KILLABLE, subclass, NULL, _RET_IP_);",
            "}",
            "int __sched",
            "mutex_lock_interruptible_nested(struct mutex *lock, unsigned int subclass)",
            "{",
            "\treturn __mutex_lock(lock, TASK_INTERRUPTIBLE, subclass, NULL, _RET_IP_);",
            "}",
            "void __sched",
            "mutex_lock_io_nested(struct mutex *lock, unsigned int subclass)",
            "{",
            "\tint token;",
            "",
            "\tmight_sleep();",
            "",
            "\ttoken = io_schedule_prepare();",
            "\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE,",
            "\t\t\t    subclass, NULL, _RET_IP_, NULL, 0);",
            "\tio_schedule_finish(token);",
            "}",
            "static inline int",
            "ww_mutex_deadlock_injection(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)",
            "{",
            "#ifdef CONFIG_DEBUG_WW_MUTEX_SLOWPATH",
            "\tunsigned tmp;",
            "",
            "\tif (ctx->deadlock_inject_countdown-- == 0) {",
            "\t\ttmp = ctx->deadlock_inject_interval;",
            "\t\tif (tmp > UINT_MAX/4)",
            "\t\t\ttmp = UINT_MAX;",
            "\t\telse",
            "\t\t\ttmp = tmp*2 + tmp + tmp/2;",
            "",
            "\t\tctx->deadlock_inject_interval = tmp;",
            "\t\tctx->deadlock_inject_countdown = tmp;",
            "\t\tctx->contending_lock = lock;",
            "",
            "\t\tww_mutex_unlock(lock);",
            "",
            "\t\treturn -EDEADLK;",
            "\t}",
            "#endif",
            "",
            "\treturn 0;",
            "}",
            "int __sched",
            "ww_mutex_lock(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)",
            "{",
            "\tint ret;",
            "",
            "\tmight_sleep();",
            "\tret =  __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE,",
            "\t\t\t       0, _RET_IP_, ctx);",
            "\tif (!ret && ctx && ctx->acquired > 1)",
            "\t\treturn ww_mutex_deadlock_injection(lock, ctx);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__mutex_lock, __ww_mutex_lock, ww_mutex_trylock, mutex_lock_nested, _mutex_lock_nest_lock, mutex_lock_killable_nested, mutex_lock_interruptible_nested, mutex_lock_io_nested, ww_mutex_deadlock_injection, ww_mutex_lock",
          "description": "封装多种锁获取接口，处理嵌套锁、可中断锁及死锁注入逻辑，协调锁持有者与等待者的交互关系。",
          "similarity": 0.5560412406921387
        }
      ]
    },
    {
      "source_file": "kernel/locking/rwsem.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:51:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\rwsem.c`\n\n---\n\n# `locking/rwsem.c` 技术文档\n\n## 1. 文件概述\n\n`locking/rwsem.c` 是 Linux 内核中读写信号量（Read-Write Semaphore, rwsem）的核心实现文件，提供了对共享资源进行并发访问控制的机制。该机制允许多个读者并发访问资源，但写者必须独占访问。文件实现了 rwsem 的底层原子操作、锁获取/释放逻辑、乐观自旋（optimistic spinning）、写者锁抢占（lock-stealing）以及调试支持等功能，适用于高并发场景下的同步需求。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct rw_semaphore`：读写信号量的核心结构体，包含：\n  - `count`：原子长整型，编码了写者锁状态、等待者标志、移交标志、读者计数等信息。\n  - `owner`：记录当前锁持有者（写者任务指针或带标志的读者信息）。\n  - `wait_list`：等待队列，用于管理阻塞的读者和写者。\n  - `wait_lock`：保护等待队列的自旋锁。\n\n### 关键宏定义\n- **Owner 字段标志位**：\n  - `RWSEM_READER_OWNED`（bit 0）：表示当前由读者持有。\n  - `RWSEM_NONSPINNABLE`（bit 1）：禁止乐观自旋。\n- **Count 字段位布局**（64 位架构）：\n  - bit 0：`RWSEM_WRITER_LOCKED`（写者已加锁）\n  - bit 1：`RWSEM_FLAG_WAITERS`（存在等待者）\n  - bit 2：`RWSEM_FLAG_HANDOFF`（锁移交标志）\n  - bits 8–62：55 位读者计数\n  - bit 63：`RWSEM_FLAG_READFAIL`（读取失败标志，用于未来扩展）\n\n### 核心内联函数\n- `rwsem_set_owner()` / `rwsem_clear_owner()`：设置/清除写者所有者。\n- `rwsem_set_reader_owned()` / `rwsem_clear_reader_owned()`：标记/清除读者所有者（带调试支持）。\n- `is_rwsem_reader_owned()`：判断是否由读者持有。\n- `rwsem_set_nonspinnable()`：在读者持有时设置不可自旋标志。\n- `rwsem_test_oflags()`：测试 owner 字段中的标志位。\n\n## 3. 关键实现\n\n### 位域编码设计\n`count` 字段采用紧凑的位域编码，将写者锁状态、等待者存在标志、锁移交标志和读者计数集成在一个 `atomic_long_t` 中。这种设计使得 fast-path（快速路径）操作（如读者加锁）可通过单一原子加法完成，极大提升性能。\n\n### 乐观自旋（Optimistic Spinning）\n当写者尝试获取锁失败时，若满足条件（如锁由写者刚释放、无移交请求），会进入乐观自旋状态，避免立即进入睡眠。若自旋超时且锁仍为读者持有，则设置 `RWSEM_NONSPINNABLE` 标志，禁止后续写者自旋，防止 CPU 资源浪费。\n\n### 写者锁抢占（Writer Lock-Stealing）\n在特定条件下（如锁刚由写者释放、无等待者、无移交标志），新来的写者可直接抢占锁，无需排队，减少延迟。\n\n### 所有者追踪机制\n- **写者**：`owner` 字段直接存储 `task_struct*` 指针。\n- **读者**：`owner` 字段存储当前读者任务指针并置 `RWSEM_READER_OWNED` 位。由于性能考虑，仅记录**最后一个获取锁的读者**，而非所有读者。\n- 调试模式（`CONFIG_DEBUG_RWSEMS`）下，`rwsem_clear_reader_owned()` 确保只有真正的持有者才能清除其所有者记录。\n\n### 原子操作策略\n- **读者加锁**：使用 `atomic_long_fetch_add()` 原子增加读者计数。\n- **写者加锁**：使用 `atomic_long_cmpxchg()` 进行条件交换，确保互斥。\n\n### 锁移交（Handoff）机制\n当写者被唤醒时，若其位于等待队列头部，可设置 `RWSEM_FLAG_HANDOFF` 标志，确保该写者优先获得锁，避免“写者饥饿”。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/rwsem.h>`：定义 `rw_semaphore` 结构和公共 API。\n  - `<linux/atomic.h>`：提供原子操作原语。\n  - `<linux/sched/*.h>`：任务调度、唤醒队列、实时调度支持。\n  - `<trace/events/lock.h>`：锁事件追踪。\n- **配置依赖**：\n  - `CONFIG_PREEMPT_RT`：若启用，部分实现（如乐观自旋）被禁用。\n  - `CONFIG_DEBUG_RWSEMS`：启用所有者一致性检查和警告。\n- **内部依赖**：\n  - `lock_events.h`：统计锁事件（仅在非 `PREEMPT_RT` 下）。\n  - 内核调度器：用于任务阻塞/唤醒。\n\n## 5. 使用场景\n\n- **文件系统**：如 ext4、XFS 使用 rwsem 保护 inode 或目录结构，允许多读者并发访问元数据。\n- **内存管理**：`mm_struct` 的 `mmap_lock` 采用 rwsem，支持并发读（如页表遍历）与独占写（如内存映射修改）。\n- **模块加载**：内核模块的引用计数和符号表访问通过 rwsem 同步。\n- **RCU 替代场景**：在需要严格写者优先或不能使用 RCU 的上下文中，rwsem 提供强一致性保证。\n- **调试与死锁检测**：结合 `lockdep` 和 `DEBUG_RWSEMS`，用于检测读者/写者死锁或非法嵌套。",
      "similarity": 0.5275115370750427,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/rwsem.c",
          "start_line": 140,
          "end_line": 249,
          "content": [
            "static inline void rwsem_set_owner(struct rw_semaphore *sem)",
            "{",
            "\tlockdep_assert_preemption_disabled();",
            "\tatomic_long_set(&sem->owner, (long)current);",
            "}",
            "static inline void rwsem_clear_owner(struct rw_semaphore *sem)",
            "{",
            "\tlockdep_assert_preemption_disabled();",
            "\tatomic_long_set(&sem->owner, 0);",
            "}",
            "static inline bool rwsem_test_oflags(struct rw_semaphore *sem, long flags)",
            "{",
            "\treturn atomic_long_read(&sem->owner) & flags;",
            "}",
            "static inline void __rwsem_set_reader_owned(struct rw_semaphore *sem,",
            "\t\t\t\t\t    struct task_struct *owner)",
            "{",
            "\tunsigned long val = (unsigned long)owner | RWSEM_READER_OWNED |",
            "\t\t(atomic_long_read(&sem->owner) & RWSEM_NONSPINNABLE);",
            "",
            "\tatomic_long_set(&sem->owner, val);",
            "}",
            "static inline void rwsem_set_reader_owned(struct rw_semaphore *sem)",
            "{",
            "\t__rwsem_set_reader_owned(sem, current);",
            "}",
            "static inline bool is_rwsem_reader_owned(struct rw_semaphore *sem)",
            "{",
            "#ifdef CONFIG_DEBUG_RWSEMS",
            "\t/*",
            "\t * Check the count to see if it is write-locked.",
            "\t */",
            "\tlong count = atomic_long_read(&sem->count);",
            "",
            "\tif (count & RWSEM_WRITER_MASK)",
            "\t\treturn false;",
            "#endif",
            "\treturn rwsem_test_oflags(sem, RWSEM_READER_OWNED);",
            "}",
            "static inline void rwsem_clear_reader_owned(struct rw_semaphore *sem)",
            "{",
            "\tunsigned long val = atomic_long_read(&sem->owner);",
            "",
            "\twhile ((val & ~RWSEM_OWNER_FLAGS_MASK) == (unsigned long)current) {",
            "\t\tif (atomic_long_try_cmpxchg(&sem->owner, &val,",
            "\t\t\t\t\t    val & RWSEM_OWNER_FLAGS_MASK))",
            "\t\t\treturn;",
            "\t}",
            "}",
            "static inline void rwsem_clear_reader_owned(struct rw_semaphore *sem)",
            "{",
            "}",
            "static inline void rwsem_set_nonspinnable(struct rw_semaphore *sem)",
            "{",
            "\tunsigned long owner = atomic_long_read(&sem->owner);",
            "",
            "\tdo {",
            "\t\tif (!(owner & RWSEM_READER_OWNED))",
            "\t\t\tbreak;",
            "\t\tif (owner & RWSEM_NONSPINNABLE)",
            "\t\t\tbreak;",
            "\t} while (!atomic_long_try_cmpxchg(&sem->owner, &owner,",
            "\t\t\t\t\t  owner | RWSEM_NONSPINNABLE));",
            "}",
            "static inline bool rwsem_read_trylock(struct rw_semaphore *sem, long *cntp)",
            "{",
            "\t*cntp = atomic_long_add_return_acquire(RWSEM_READER_BIAS, &sem->count);",
            "",
            "\tif (WARN_ON_ONCE(*cntp < 0))",
            "\t\trwsem_set_nonspinnable(sem);",
            "",
            "\tif (!(*cntp & RWSEM_READ_FAILED_MASK)) {",
            "\t\trwsem_set_reader_owned(sem);",
            "\t\treturn true;",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static inline bool rwsem_write_trylock(struct rw_semaphore *sem)",
            "{",
            "\tlong tmp = RWSEM_UNLOCKED_VALUE;",
            "",
            "\tif (atomic_long_try_cmpxchg_acquire(&sem->count, &tmp, RWSEM_WRITER_LOCKED)) {",
            "\t\trwsem_set_owner(sem);",
            "\t\treturn true;",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "void __init_rwsem(struct rw_semaphore *sem, const char *name,",
            "\t\t  struct lock_class_key *key)",
            "{",
            "#ifdef CONFIG_DEBUG_LOCK_ALLOC",
            "\t/*",
            "\t * Make sure we are not reinitializing a held semaphore:",
            "\t */",
            "\tdebug_check_no_locks_freed((void *)sem, sizeof(*sem));",
            "\tlockdep_init_map_wait(&sem->dep_map, name, key, 0, LD_WAIT_SLEEP);",
            "#endif",
            "#ifdef CONFIG_DEBUG_RWSEMS",
            "\tsem->magic = sem;",
            "#endif",
            "\tatomic_long_set(&sem->count, RWSEM_UNLOCKED_VALUE);",
            "\traw_spin_lock_init(&sem->wait_lock);",
            "\tINIT_LIST_HEAD(&sem->wait_list);",
            "\tatomic_long_set(&sem->owner, 0L);",
            "#ifdef CONFIG_RWSEM_SPIN_ON_OWNER",
            "\tosq_lock_init(&sem->osq);",
            "#endif",
            "}"
          ],
          "function_name": "rwsem_set_owner, rwsem_clear_owner, rwsem_test_oflags, __rwsem_set_reader_owned, rwsem_set_reader_owned, is_rwsem_reader_owned, rwsem_clear_reader_owned, rwsem_clear_reader_owned, rwsem_set_nonspinnable, rwsem_read_trylock, rwsem_write_trylock, __init_rwsem",
          "description": "提供读写信号量的核心操作函数，包括设置/清除所有者、尝试加锁、初始化信号量结构体及其状态管理",
          "similarity": 0.5849721431732178
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/locking/rwsem.c",
          "start_line": 734,
          "end_line": 920,
          "content": [
            "static inline enum owner_state",
            "rwsem_owner_state(struct task_struct *owner, unsigned long flags)",
            "{",
            "\tif (flags & RWSEM_NONSPINNABLE)",
            "\t\treturn OWNER_NONSPINNABLE;",
            "",
            "\tif (flags & RWSEM_READER_OWNED)",
            "\t\treturn OWNER_READER;",
            "",
            "\treturn owner ? OWNER_WRITER : OWNER_NULL;",
            "}",
            "static noinline enum owner_state",
            "rwsem_spin_on_owner(struct rw_semaphore *sem)",
            "{",
            "\tstruct task_struct *new, *owner;",
            "\tunsigned long flags, new_flags;",
            "\tenum owner_state state;",
            "",
            "\tlockdep_assert_preemption_disabled();",
            "",
            "\towner = rwsem_owner_flags(sem, &flags);",
            "\tstate = rwsem_owner_state(owner, flags);",
            "\tif (state != OWNER_WRITER)",
            "\t\treturn state;",
            "",
            "\tfor (;;) {",
            "\t\t/*",
            "\t\t * When a waiting writer set the handoff flag, it may spin",
            "\t\t * on the owner as well. Once that writer acquires the lock,",
            "\t\t * we can spin on it. So we don't need to quit even when the",
            "\t\t * handoff bit is set.",
            "\t\t */",
            "\t\tnew = rwsem_owner_flags(sem, &new_flags);",
            "\t\tif ((new != owner) || (new_flags != flags)) {",
            "\t\t\tstate = rwsem_owner_state(new, new_flags);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Ensure we emit the owner->on_cpu, dereference _after_",
            "\t\t * checking sem->owner still matches owner, if that fails,",
            "\t\t * owner might point to free()d memory, if it still matches,",
            "\t\t * our spinning context already disabled preemption which is",
            "\t\t * equal to RCU read-side crital section ensures the memory",
            "\t\t * stays valid.",
            "\t\t */",
            "\t\tbarrier();",
            "",
            "\t\tif (need_resched() || !owner_on_cpu(owner)) {",
            "\t\t\tstate = OWNER_NONSPINNABLE;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tcpu_relax();",
            "\t}",
            "",
            "\treturn state;",
            "}",
            "static inline u64 rwsem_rspin_threshold(struct rw_semaphore *sem)",
            "{",
            "\tlong count = atomic_long_read(&sem->count);",
            "\tint readers = count >> RWSEM_READER_SHIFT;",
            "\tu64 delta;",
            "",
            "\tif (readers > 30)",
            "\t\treaders = 30;",
            "\tdelta = (20 + readers) * NSEC_PER_USEC / 2;",
            "",
            "\treturn sched_clock() + delta;",
            "}",
            "static bool rwsem_optimistic_spin(struct rw_semaphore *sem)",
            "{",
            "\tbool taken = false;",
            "\tint prev_owner_state = OWNER_NULL;",
            "\tint loop = 0;",
            "\tu64 rspin_threshold = 0;",
            "",
            "\t/* sem->wait_lock should not be held when doing optimistic spinning */",
            "\tif (!osq_lock(&sem->osq))",
            "\t\tgoto done;",
            "",
            "\t/*",
            "\t * Optimistically spin on the owner field and attempt to acquire the",
            "\t * lock whenever the owner changes. Spinning will be stopped when:",
            "\t *  1) the owning writer isn't running; or",
            "\t *  2) readers own the lock and spinning time has exceeded limit.",
            "\t */",
            "\tfor (;;) {",
            "\t\tenum owner_state owner_state;",
            "",
            "\t\towner_state = rwsem_spin_on_owner(sem);",
            "\t\tif (!(owner_state & OWNER_SPINNABLE))",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * Try to acquire the lock",
            "\t\t */",
            "\t\ttaken = rwsem_try_write_lock_unqueued(sem);",
            "",
            "\t\tif (taken)",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * Time-based reader-owned rwsem optimistic spinning",
            "\t\t */",
            "\t\tif (owner_state == OWNER_READER) {",
            "\t\t\t/*",
            "\t\t\t * Re-initialize rspin_threshold every time when",
            "\t\t\t * the owner state changes from non-reader to reader.",
            "\t\t\t * This allows a writer to steal the lock in between",
            "\t\t\t * 2 reader phases and have the threshold reset at",
            "\t\t\t * the beginning of the 2nd reader phase.",
            "\t\t\t */",
            "\t\t\tif (prev_owner_state != OWNER_READER) {",
            "\t\t\t\tif (rwsem_test_oflags(sem, RWSEM_NONSPINNABLE))",
            "\t\t\t\t\tbreak;",
            "\t\t\t\trspin_threshold = rwsem_rspin_threshold(sem);",
            "\t\t\t\tloop = 0;",
            "\t\t\t}",
            "",
            "\t\t\t/*",
            "\t\t\t * Check time threshold once every 16 iterations to",
            "\t\t\t * avoid calling sched_clock() too frequently so",
            "\t\t\t * as to reduce the average latency between the times",
            "\t\t\t * when the lock becomes free and when the spinner",
            "\t\t\t * is ready to do a trylock.",
            "\t\t\t */",
            "\t\t\telse if (!(++loop & 0xf) && (sched_clock() > rspin_threshold)) {",
            "\t\t\t\trwsem_set_nonspinnable(sem);",
            "\t\t\t\tlockevent_inc(rwsem_opt_nospin);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * An RT task cannot do optimistic spinning if it cannot",
            "\t\t * be sure the lock holder is running or live-lock may",
            "\t\t * happen if the current task and the lock holder happen",
            "\t\t * to run in the same CPU. However, aborting optimistic",
            "\t\t * spinning while a NULL owner is detected may miss some",
            "\t\t * opportunity where spinning can continue without causing",
            "\t\t * problem.",
            "\t\t *",
            "\t\t * There are 2 possible cases where an RT task may be able",
            "\t\t * to continue spinning.",
            "\t\t *",
            "\t\t * 1) The lock owner is in the process of releasing the",
            "\t\t *    lock, sem->owner is cleared but the lock has not",
            "\t\t *    been released yet.",
            "\t\t * 2) The lock was free and owner cleared, but another",
            "\t\t *    task just comes in and acquire the lock before",
            "\t\t *    we try to get it. The new owner may be a spinnable",
            "\t\t *    writer.",
            "\t\t *",
            "\t\t * To take advantage of two scenarios listed above, the RT",
            "\t\t * task is made to retry one more time to see if it can",
            "\t\t * acquire the lock or continue spinning on the new owning",
            "\t\t * writer. Of course, if the time lag is long enough or the",
            "\t\t * new owner is not a writer or spinnable, the RT task will",
            "\t\t * quit spinning.",
            "\t\t *",
            "\t\t * If the owner is a writer, the need_resched() check is",
            "\t\t * done inside rwsem_spin_on_owner(). If the owner is not",
            "\t\t * a writer, need_resched() check needs to be done here.",
            "\t\t */",
            "\t\tif (owner_state != OWNER_WRITER) {",
            "\t\t\tif (need_resched())",
            "\t\t\t\tbreak;",
            "\t\t\tif (rt_or_dl_task(current) &&",
            "\t\t\t   (prev_owner_state != OWNER_WRITER))",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tprev_owner_state = owner_state;",
            "",
            "\t\t/*",
            "\t\t * The cpu_relax() call is a compiler barrier which forces",
            "\t\t * everything in this loop to be re-loaded. We don't need",
            "\t\t * memory barriers as we'll eventually observe the right",
            "\t\t * values at the cost of a few extra spins.",
            "\t\t */",
            "\t\tcpu_relax();",
            "\t}",
            "\tosq_unlock(&sem->osq);",
            "done:",
            "\tlockevent_cond_inc(rwsem_opt_fail, !taken);",
            "\treturn taken;",
            "}"
          ],
          "function_name": "rwsem_owner_state, rwsem_spin_on_owner, rwsem_rspin_threshold, rwsem_optimistic_spin",
          "description": "实现乐观自旋机制，通过检测所有者状态变化和时间阈值限制，优化锁竞争场景下的吞吐量",
          "similarity": 0.5708025097846985
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/locking/rwsem.c",
          "start_line": 1483,
          "end_line": 1585,
          "content": [
            "static inline int __sched __down_write_killable(struct rw_semaphore *sem)",
            "{",
            "\treturn rwbase_write_lock(&sem->rwbase, TASK_KILLABLE);",
            "}",
            "static inline int __down_write_trylock(struct rw_semaphore *sem)",
            "{",
            "\treturn rwbase_write_trylock(&sem->rwbase);",
            "}",
            "static inline void __up_write(struct rw_semaphore *sem)",
            "{",
            "\trwbase_write_unlock(&sem->rwbase);",
            "}",
            "static inline void __downgrade_write(struct rw_semaphore *sem)",
            "{",
            "\trwbase_write_downgrade(&sem->rwbase);",
            "}",
            "static inline void __rwsem_set_reader_owned(struct rw_semaphore *sem,",
            "\t\t\t\t\t    struct task_struct *owner)",
            "{",
            "}",
            "static inline bool is_rwsem_reader_owned(struct rw_semaphore *sem)",
            "{",
            "\tint count = atomic_read(&sem->rwbase.readers);",
            "",
            "\treturn count < 0 && count != READER_BIAS;",
            "}",
            "void __sched down_read(struct rw_semaphore *sem)",
            "{",
            "\tmight_sleep();",
            "\trwsem_acquire_read(&sem->dep_map, 0, 0, _RET_IP_);",
            "",
            "\tLOCK_CONTENDED(sem, __down_read_trylock, __down_read);",
            "}",
            "int __sched down_read_interruptible(struct rw_semaphore *sem)",
            "{",
            "\tmight_sleep();",
            "\trwsem_acquire_read(&sem->dep_map, 0, 0, _RET_IP_);",
            "",
            "\tif (LOCK_CONTENDED_RETURN(sem, __down_read_trylock, __down_read_interruptible)) {",
            "\t\trwsem_release(&sem->dep_map, _RET_IP_);",
            "\t\treturn -EINTR;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int __sched down_read_killable(struct rw_semaphore *sem)",
            "{",
            "\tmight_sleep();",
            "\trwsem_acquire_read(&sem->dep_map, 0, 0, _RET_IP_);",
            "",
            "\tif (LOCK_CONTENDED_RETURN(sem, __down_read_trylock, __down_read_killable)) {",
            "\t\trwsem_release(&sem->dep_map, _RET_IP_);",
            "\t\treturn -EINTR;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int down_read_trylock(struct rw_semaphore *sem)",
            "{",
            "\tint ret = __down_read_trylock(sem);",
            "",
            "\tif (ret == 1)",
            "\t\trwsem_acquire_read(&sem->dep_map, 0, 1, _RET_IP_);",
            "\treturn ret;",
            "}",
            "void __sched down_write(struct rw_semaphore *sem)",
            "{",
            "\tmight_sleep();",
            "\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);",
            "\tLOCK_CONTENDED(sem, __down_write_trylock, __down_write);",
            "}",
            "int __sched down_write_killable(struct rw_semaphore *sem)",
            "{",
            "\tmight_sleep();",
            "\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);",
            "",
            "\tif (LOCK_CONTENDED_RETURN(sem, __down_write_trylock,",
            "\t\t\t\t  __down_write_killable)) {",
            "\t\trwsem_release(&sem->dep_map, _RET_IP_);",
            "\t\treturn -EINTR;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int down_write_trylock(struct rw_semaphore *sem)",
            "{",
            "\tint ret = __down_write_trylock(sem);",
            "",
            "\tif (ret == 1)",
            "\t\trwsem_acquire(&sem->dep_map, 0, 1, _RET_IP_);",
            "",
            "\treturn ret;",
            "}",
            "void up_read(struct rw_semaphore *sem)",
            "{",
            "\trwsem_release(&sem->dep_map, _RET_IP_);",
            "\t__up_read(sem);",
            "}",
            "void up_write(struct rw_semaphore *sem)",
            "{",
            "\trwsem_release(&sem->dep_map, _RET_IP_);",
            "\t__up_write(sem);",
            "}"
          ],
          "function_name": "__down_write_killable, __down_write_trylock, __up_write, __downgrade_write, __rwsem_set_reader_owned, is_rwsem_reader_owned, down_read, down_read_interruptible, down_read_killable, down_read_trylock, down_write, down_write_killable, down_write_trylock, up_read, up_write",
          "description": "提供标准的读写信号量API接口，包含down_read/down_write等公共函数，通过LOCK_CONTENDED宏协调自旋尝试与阻塞等待，整合锁的获取/释放追踪机制（如rwsem_acquire/read_unlock），并处理中断可睡眠的锁获取场景。",
          "similarity": 0.5271705985069275
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/rwsem.c",
          "start_line": 1,
          "end_line": 139,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* kernel/rwsem.c: R/W semaphores, public implementation",
            " *",
            " * Written by David Howells (dhowells@redhat.com).",
            " * Derived from asm-i386/semaphore.h",
            " *",
            " * Writer lock-stealing by Alex Shi <alex.shi@intel.com>",
            " * and Michel Lespinasse <walken@google.com>",
            " *",
            " * Optimistic spinning by Tim Chen <tim.c.chen@intel.com>",
            " * and Davidlohr Bueso <davidlohr@hp.com>. Based on mutexes.",
            " *",
            " * Rwsem count bit fields re-definition and rwsem rearchitecture by",
            " * Waiman Long <longman@redhat.com> and",
            " * Peter Zijlstra <peterz@infradead.org>.",
            " */",
            "",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/export.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>",
            "#include <trace/events/lock.h>",
            "",
            "#ifndef CONFIG_PREEMPT_RT",
            "#include \"lock_events.h\"",
            "",
            "/*",
            " * The least significant 2 bits of the owner value has the following",
            " * meanings when set.",
            " *  - Bit 0: RWSEM_READER_OWNED - The rwsem is owned by readers",
            " *  - Bit 1: RWSEM_NONSPINNABLE - Cannot spin on a reader-owned lock",
            " *",
            " * When the rwsem is reader-owned and a spinning writer has timed out,",
            " * the nonspinnable bit will be set to disable optimistic spinning.",
            "",
            " * When a writer acquires a rwsem, it puts its task_struct pointer",
            " * into the owner field. It is cleared after an unlock.",
            " *",
            " * When a reader acquires a rwsem, it will also puts its task_struct",
            " * pointer into the owner field with the RWSEM_READER_OWNED bit set.",
            " * On unlock, the owner field will largely be left untouched. So",
            " * for a free or reader-owned rwsem, the owner value may contain",
            " * information about the last reader that acquires the rwsem.",
            " *",
            " * That information may be helpful in debugging cases where the system",
            " * seems to hang on a reader owned rwsem especially if only one reader",
            " * is involved. Ideally we would like to track all the readers that own",
            " * a rwsem, but the overhead is simply too big.",
            " *",
            " * A fast path reader optimistic lock stealing is supported when the rwsem",
            " * is previously owned by a writer and the following conditions are met:",
            " *  - rwsem is not currently writer owned",
            " *  - the handoff isn't set.",
            " */",
            "#define RWSEM_READER_OWNED\t(1UL << 0)",
            "#define RWSEM_NONSPINNABLE\t(1UL << 1)",
            "#define RWSEM_OWNER_FLAGS_MASK\t(RWSEM_READER_OWNED | RWSEM_NONSPINNABLE)",
            "",
            "#ifdef CONFIG_DEBUG_RWSEMS",
            "# define DEBUG_RWSEMS_WARN_ON(c, sem)\tdo {\t\t\t\\",
            "\tif (!debug_locks_silent &&\t\t\t\t\\",
            "\t    WARN_ONCE(c, \"DEBUG_RWSEMS_WARN_ON(%s): count = 0x%lx, magic = 0x%lx, owner = 0x%lx, curr 0x%lx, list %sempty\\n\",\\",
            "\t\t#c, atomic_long_read(&(sem)->count),\t\t\\",
            "\t\t(unsigned long) sem->magic,\t\t\t\\",
            "\t\tatomic_long_read(&(sem)->owner), (long)current,\t\\",
            "\t\tlist_empty(&(sem)->wait_list) ? \"\" : \"not \"))\t\\",
            "\t\t\tdebug_locks_off();\t\t\t\\",
            "\t} while (0)",
            "#else",
            "# define DEBUG_RWSEMS_WARN_ON(c, sem)",
            "#endif",
            "",
            "/*",
            " * On 64-bit architectures, the bit definitions of the count are:",
            " *",
            " * Bit  0    - writer locked bit",
            " * Bit  1    - waiters present bit",
            " * Bit  2    - lock handoff bit",
            " * Bits 3-7  - reserved",
            " * Bits 8-62 - 55-bit reader count",
            " * Bit  63   - read fail bit",
            " *",
            " * On 32-bit architectures, the bit definitions of the count are:",
            " *",
            " * Bit  0    - writer locked bit",
            " * Bit  1    - waiters present bit",
            " * Bit  2    - lock handoff bit",
            " * Bits 3-7  - reserved",
            " * Bits 8-30 - 23-bit reader count",
            " * Bit  31   - read fail bit",
            " *",
            " * It is not likely that the most significant bit (read fail bit) will ever",
            " * be set. This guard bit is still checked anyway in the down_read() fastpath",
            " * just in case we need to use up more of the reader bits for other purpose",
            " * in the future.",
            " *",
            " * atomic_long_fetch_add() is used to obtain reader lock, whereas",
            " * atomic_long_cmpxchg() will be used to obtain writer lock.",
            " *",
            " * There are three places where the lock handoff bit may be set or cleared.",
            " * 1) rwsem_mark_wake() for readers\t\t-- set, clear",
            " * 2) rwsem_try_write_lock() for writers\t-- set, clear",
            " * 3) rwsem_del_waiter()\t\t\t-- clear",
            " *",
            " * For all the above cases, wait_lock will be held. A writer must also",
            " * be the first one in the wait_list to be eligible for setting the handoff",
            " * bit. So concurrent setting/clearing of handoff bit is not possible.",
            " */",
            "#define RWSEM_WRITER_LOCKED\t(1UL << 0)",
            "#define RWSEM_FLAG_WAITERS\t(1UL << 1)",
            "#define RWSEM_FLAG_HANDOFF\t(1UL << 2)",
            "#define RWSEM_FLAG_READFAIL\t(1UL << (BITS_PER_LONG - 1))",
            "",
            "#define RWSEM_READER_SHIFT\t8",
            "#define RWSEM_READER_BIAS\t(1UL << RWSEM_READER_SHIFT)",
            "#define RWSEM_READER_MASK\t(~(RWSEM_READER_BIAS - 1))",
            "#define RWSEM_WRITER_MASK\tRWSEM_WRITER_LOCKED",
            "#define RWSEM_LOCK_MASK\t\t(RWSEM_WRITER_MASK|RWSEM_READER_MASK)",
            "#define RWSEM_READ_FAILED_MASK\t(RWSEM_WRITER_MASK|RWSEM_FLAG_WAITERS|\\",
            "\t\t\t\t RWSEM_FLAG_HANDOFF|RWSEM_FLAG_READFAIL)",
            "",
            "/*",
            " * All writes to owner are protected by WRITE_ONCE() to make sure that",
            " * store tearing can't happen as optimistic spinners may read and use",
            " * the owner value concurrently without lock. Read from owner, however,",
            " * may not need READ_ONCE() as long as the pointer value is only used",
            " * for comparison and isn't being dereferenced.",
            " *",
            " * Both rwsem_{set,clear}_owner() functions should be in the same",
            " * preempt disable section as the atomic op that changes sem->count.",
            " */"
          ],
          "function_name": null,
          "description": "定义读写信号量相关常量与宏，描述count字段的位布局及所有权标志位，用于管理锁状态和调试信息",
          "similarity": 0.510456919670105
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/locking/rwsem.c",
          "start_line": 1323,
          "end_line": 1424,
          "content": [
            "static inline int __down_write_trylock(struct rw_semaphore *sem)",
            "{",
            "\tint ret;",
            "",
            "\tpreempt_disable();",
            "\tDEBUG_RWSEMS_WARN_ON(sem->magic != sem, sem);",
            "\tret = rwsem_write_trylock(sem);",
            "\tpreempt_enable();",
            "",
            "\treturn ret;",
            "}",
            "static inline void __up_read(struct rw_semaphore *sem)",
            "{",
            "\tlong tmp;",
            "",
            "\tDEBUG_RWSEMS_WARN_ON(sem->magic != sem, sem);",
            "\tDEBUG_RWSEMS_WARN_ON(!is_rwsem_reader_owned(sem), sem);",
            "",
            "\tpreempt_disable();",
            "\trwsem_clear_reader_owned(sem);",
            "\ttmp = atomic_long_add_return_release(-RWSEM_READER_BIAS, &sem->count);",
            "\tDEBUG_RWSEMS_WARN_ON(tmp < 0, sem);",
            "\tif (unlikely((tmp & (RWSEM_LOCK_MASK|RWSEM_FLAG_WAITERS)) ==",
            "\t\t      RWSEM_FLAG_WAITERS)) {",
            "\t\tclear_nonspinnable(sem);",
            "\t\trwsem_wake(sem);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static inline void __up_write(struct rw_semaphore *sem)",
            "{",
            "\tlong tmp;",
            "",
            "\tDEBUG_RWSEMS_WARN_ON(sem->magic != sem, sem);",
            "\t/*",
            "\t * sem->owner may differ from current if the ownership is transferred",
            "\t * to an anonymous writer by setting the RWSEM_NONSPINNABLE bits.",
            "\t */",
            "\tDEBUG_RWSEMS_WARN_ON((rwsem_owner(sem) != current) &&",
            "\t\t\t    !rwsem_test_oflags(sem, RWSEM_NONSPINNABLE), sem);",
            "",
            "\tpreempt_disable();",
            "\trwsem_clear_owner(sem);",
            "\ttmp = atomic_long_fetch_add_release(-RWSEM_WRITER_LOCKED, &sem->count);",
            "\tif (unlikely(tmp & RWSEM_FLAG_WAITERS))",
            "\t\trwsem_wake(sem);",
            "\tpreempt_enable();",
            "}",
            "static inline void __downgrade_write(struct rw_semaphore *sem)",
            "{",
            "\tlong tmp;",
            "",
            "\t/*",
            "\t * When downgrading from exclusive to shared ownership,",
            "\t * anything inside the write-locked region cannot leak",
            "\t * into the read side. In contrast, anything in the",
            "\t * read-locked region is ok to be re-ordered into the",
            "\t * write side. As such, rely on RELEASE semantics.",
            "\t */",
            "\tDEBUG_RWSEMS_WARN_ON(rwsem_owner(sem) != current, sem);",
            "\tpreempt_disable();",
            "\ttmp = atomic_long_fetch_add_release(",
            "\t\t-RWSEM_WRITER_LOCKED+RWSEM_READER_BIAS, &sem->count);",
            "\trwsem_set_reader_owned(sem);",
            "\tif (tmp & RWSEM_FLAG_WAITERS)",
            "\t\trwsem_downgrade_wake(sem);",
            "\tpreempt_enable();",
            "}",
            "void __init_rwsem(struct rw_semaphore *sem, const char *name,",
            "\t\t  struct lock_class_key *key)",
            "{",
            "\tinit_rwbase_rt(&(sem)->rwbase);",
            "",
            "#ifdef CONFIG_DEBUG_LOCK_ALLOC",
            "\tdebug_check_no_locks_freed((void *)sem, sizeof(*sem));",
            "\tlockdep_init_map_wait(&sem->dep_map, name, key, 0, LD_WAIT_SLEEP);",
            "#endif",
            "}",
            "static inline void __down_read(struct rw_semaphore *sem)",
            "{",
            "\trwbase_read_lock(&sem->rwbase, TASK_UNINTERRUPTIBLE);",
            "}",
            "static inline int __down_read_interruptible(struct rw_semaphore *sem)",
            "{",
            "\treturn rwbase_read_lock(&sem->rwbase, TASK_INTERRUPTIBLE);",
            "}",
            "static inline int __down_read_killable(struct rw_semaphore *sem)",
            "{",
            "\treturn rwbase_read_lock(&sem->rwbase, TASK_KILLABLE);",
            "}",
            "static inline int __down_read_trylock(struct rw_semaphore *sem)",
            "{",
            "\treturn rwbase_read_trylock(&sem->rwbase);",
            "}",
            "static inline void __up_read(struct rw_semaphore *sem)",
            "{",
            "\trwbase_read_unlock(&sem->rwbase, TASK_NORMAL);",
            "}",
            "static inline void __sched __down_write(struct rw_semaphore *sem)",
            "{",
            "\trwbase_write_lock(&sem->rwbase, TASK_UNINTERRUPTIBLE);",
            "}"
          ],
          "function_name": "__down_write_trylock, __up_read, __up_write, __downgrade_write, __init_rwsem, __down_read, __down_read_interruptible, __down_read_killable, __down_read_trylock, __up_read, __down_write",
          "description": "实现读写信号量的释放逻辑及初始化功能，包含__up_read/__up_write处理计数器更新与唤醒等待线程，__downgrade_write实现写锁向读锁的降级转换，__init_rwsem初始化信号量结构体，部分函数通过rwbase系列接口实现底层锁操作。",
          "similarity": 0.5070079565048218
        }
      ]
    }
  ]
}