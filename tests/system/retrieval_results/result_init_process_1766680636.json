{
  "query": "init_process",
  "timestamp": "2025-12-26 00:37:16",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/chip.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:48:28\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\chip.c`\n\n---\n\n# `irq/chip.c` 技术文档\n\n## 1. 文件概述\n\n`irq/chip.c` 是 Linux 内核通用中断子系统（Generic IRQ）的核心实现文件之一，主要负责基于 `irq_chip` 抽象的中断控制器底层操作。该文件提供了中断芯片（IRQ chip）的注册、配置、启停、数据管理等基础接口，是架构无关的中断处理基础设施，为各种硬件中断控制器（如 GIC、APIC、MSI 等）提供统一的管理框架。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能说明 |\n|--------|--------|\n| `irq_set_chip()` | 为指定 IRQ 号绑定 `irq_chip` 操作结构体 |\n| `irq_set_irq_type()` | 设置中断触发类型（电平/边沿触发等） |\n| `irq_set_handler_data()` | 设置中断处理程序私有数据（`handler_data`） |\n| `irq_set_chip_data()` | 设置中断芯片私有数据（`chip_data`） |\n| `irq_set_msi_desc()` / `irq_set_msi_desc_off()` | 为 MSI/MSI-X 中断设置描述符 |\n| `irq_get_irq_data()` | 获取指定 IRQ 的 `irq_data` 结构指针 |\n| `irq_startup()` | 启动一个中断（调用 chip 的 `irq_startup` 或 `irq_enable`） |\n| `irq_shutdown()` | 关闭一个中断（调用 chip 的 `irq_shutdown` 或 `irq_disable`） |\n| `irq_activate()` | 激活中断（通常用于 IRQ domain 资源分配） |\n| `irq_activate_and_startup()` | 组合激活并启动中断 |\n| `irq_shutdown_and_deactivate()` | 组合关闭并去激活中断 |\n\n### 关键数据结构\n\n- **`chained_action`**：专用于级联中断（chained IRQ）的默认 `irqaction`，其处理函数 `bad_chained_irq` 会在错误调用时发出警告。\n- **`struct irq_chip`**：中断控制器操作抽象，包含 `irq_startup`、`irq_shutdown`、`irq_enable`、`irq_disable` 等回调函数。\n- **`struct irq_desc`**：中断描述符，包含中断状态、操作函数、私有数据等。\n- **`struct irq_data`**：中断数据结构，嵌入在 `irq_desc` 中，包含 `chip`、`chip_data`、状态标志（如 `IRQD_IRQ_DISABLED`）等。\n\n## 3. 关键实现\n\n### 中断状态管理\n- 使用 `irqd_set()` / `irqd_clear()` 操作 `irq_data` 中的状态位（如 `IRQD_IRQ_DISABLED`、`IRQD_IRQ_MASKED`、`IRQD_IRQ_STARTED`）。\n- `irq_startup()` 和 `irq_shutdown()` 通过检查 `irqd_is_started()` 决定是否执行完整启停流程。\n\n### 级联中断保护\n- `chained_action` 的 `bad_chained_irq` 处理函数用于防止级联中断被误当作普通中断处理，确保级联中断仅由父中断控制器驱动调用。\n\n### 管理型中断（Managed IRQ）支持\n- 在 `CONFIG_SMP` 下，`__irq_startup_managed()` 检查中断是否为“管理型”（由内核自动管理 CPU 亲和性）。\n- 若亲和性掩码中无在线 CPU，则进入 `IRQ_STARTUP_ABORT` 状态并设置 `IRQD_MANAGED_SHUTDOWN`，等待 CPU 热插拔事件重新启动。\n\n### 启动流程\n- `irq_startup()` 根据 `irq_chip` 是否提供 `irq_startup` 回调选择不同路径：\n  - 有 `irq_startup`：调用该函数，并清除 `DISABLED` 和 `MASKED` 状态。\n  - 无 `irq_startup`：调用通用 `irq_enable()`。\n- 支持亲和性设置时机控制：通过 `IRQCHIP_AFFINITY_PRE_STARTUP` 标志决定在启动前还是启动后设置 CPU 亲和性。\n\n### MSI 描述符管理\n- `irq_set_msi_desc_off()` 支持为 MSI 中断组（base + offset）设置描述符，并在 offset 为 0 时更新 `msi_desc->irq` 字段。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`：定义 `irq_chip`、`irq_desc` 等核心结构。\n  - `<linux/msi.h>`：MSI 相关定义。\n  - `<linux/irqdomain.h>`：IRQ domain 支持。\n  - `\"internals.h\"`：中断子系统内部接口。\n- **模块依赖**：\n  - 依赖通用中断子系统（Generic IRQ）的其他组件，如 `irqdesc.c`（描述符管理）、`irqdomain.c`（IRQ domain 映射）。\n  - 与 CPU 热插拔子系统交互（管理型中断场景）。\n  - 被各类中断控制器驱动（如 GIC、IOAPIC、MSI 驱动）调用以注册和配置中断。\n\n## 5. 使用场景\n\n- **中断控制器驱动初始化**：在平台或设备驱动中调用 `irq_set_chip()`、`irq_set_chip_data()` 等函数注册中断控制器操作。\n- **中断类型配置**：设备驱动通过 `irq_set_irq_type()` 设置中断触发方式（如 `IRQ_TYPE_EDGE_RISING`）。\n- **MSI/MSI-X 中断设置**：PCIe 驱动使用 `irq_set_msi_desc()` 关联 MSI 描述符与 IRQ 号。\n- **中断启停控制**：内核在 `request_irq()` / `free_irq()` 或 `enable_irq()` / `disable_irq()` 路径中调用 `irq_startup()` / `irq_shutdown()`。\n- **CPU 热插拔处理**：管理型中断在 CPU 上线/下线时自动启停，依赖本文件的 `__irq_startup_managed()` 逻辑。\n- **级联中断实现**：父中断控制器使用 `chained_action` 作为占位符，防止子中断被错误处理。",
      "similarity": 0.5580851435661316,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/chip.c",
          "start_line": 227,
          "end_line": 337,
          "content": [
            "static __always_inline int",
            "__irq_startup_managed(struct irq_desc *desc, const struct cpumask *aff,",
            "\t\t      bool force)",
            "{",
            "\treturn IRQ_STARTUP_NORMAL;",
            "}",
            "static int __irq_startup(struct irq_desc *desc)",
            "{",
            "\tstruct irq_data *d = irq_desc_get_irq_data(desc);",
            "\tint ret = 0;",
            "",
            "\t/* Warn if this interrupt is not activated but try nevertheless */",
            "\tWARN_ON_ONCE(!irqd_is_activated(d));",
            "",
            "\tif (d->chip->irq_startup) {",
            "\t\tret = d->chip->irq_startup(d);",
            "\t\tirq_state_clr_disabled(desc);",
            "\t\tirq_state_clr_masked(desc);",
            "\t} else {",
            "\t\tirq_enable(desc);",
            "\t}",
            "\tirq_state_set_started(desc);",
            "\treturn ret;",
            "}",
            "int irq_startup(struct irq_desc *desc, bool resend, bool force)",
            "{",
            "\tstruct irq_data *d = irq_desc_get_irq_data(desc);",
            "\tconst struct cpumask *aff = irq_data_get_affinity_mask(d);",
            "\tint ret = 0;",
            "",
            "\tdesc->depth = 0;",
            "",
            "\tif (irqd_is_started(d)) {",
            "\t\tirq_enable(desc);",
            "\t} else {",
            "\t\tswitch (__irq_startup_managed(desc, aff, force)) {",
            "\t\tcase IRQ_STARTUP_NORMAL:",
            "\t\t\tif (d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP)",
            "\t\t\t\tirq_setup_affinity(desc);",
            "\t\t\tret = __irq_startup(desc);",
            "\t\t\tif (!(d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP))",
            "\t\t\t\tirq_setup_affinity(desc);",
            "\t\t\tbreak;",
            "\t\tcase IRQ_STARTUP_MANAGED:",
            "\t\t\tirq_do_set_affinity(d, aff, false);",
            "\t\t\tret = __irq_startup(desc);",
            "\t\t\tbreak;",
            "\t\tcase IRQ_STARTUP_ABORT:",
            "\t\t\tirqd_set_managed_shutdown(d);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "\tif (resend)",
            "\t\tcheck_irq_resend(desc, false);",
            "",
            "\treturn ret;",
            "}",
            "int irq_activate(struct irq_desc *desc)",
            "{",
            "\tstruct irq_data *d = irq_desc_get_irq_data(desc);",
            "",
            "\tif (!irqd_affinity_is_managed(d))",
            "\t\treturn irq_domain_activate_irq(d, false);",
            "\treturn 0;",
            "}",
            "int irq_activate_and_startup(struct irq_desc *desc, bool resend)",
            "{",
            "\tif (WARN_ON(irq_activate(desc)))",
            "\t\treturn 0;",
            "\treturn irq_startup(desc, resend, IRQ_START_FORCE);",
            "}",
            "void irq_shutdown(struct irq_desc *desc)",
            "{",
            "\tif (irqd_is_started(&desc->irq_data)) {",
            "\t\tclear_irq_resend(desc);",
            "\t\tdesc->depth = 1;",
            "\t\tif (desc->irq_data.chip->irq_shutdown) {",
            "\t\t\tdesc->irq_data.chip->irq_shutdown(&desc->irq_data);",
            "\t\t\tirq_state_set_disabled(desc);",
            "\t\t\tirq_state_set_masked(desc);",
            "\t\t} else {",
            "\t\t\t__irq_disable(desc, true);",
            "\t\t}",
            "\t\tirq_state_clr_started(desc);",
            "\t}",
            "}",
            "void irq_shutdown_and_deactivate(struct irq_desc *desc)",
            "{",
            "\tirq_shutdown(desc);",
            "\t/*",
            "\t * This must be called even if the interrupt was never started up,",
            "\t * because the activation can happen before the interrupt is",
            "\t * available for request/startup. It has it's own state tracking so",
            "\t * it's safe to call it unconditionally.",
            "\t */",
            "\tirq_domain_deactivate_irq(&desc->irq_data);",
            "}",
            "void irq_enable(struct irq_desc *desc)",
            "{",
            "\tif (!irqd_irq_disabled(&desc->irq_data)) {",
            "\t\tunmask_irq(desc);",
            "\t} else {",
            "\t\tirq_state_clr_disabled(desc);",
            "\t\tif (desc->irq_data.chip->irq_enable) {",
            "\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);",
            "\t\t\tirq_state_clr_masked(desc);",
            "\t\t} else {",
            "\t\t\tunmask_irq(desc);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "__irq_startup_managed, __irq_startup, irq_startup, irq_activate, irq_activate_and_startup, irq_shutdown, irq_shutdown_and_deactivate, irq_enable",
          "description": "实现中断启动逻辑，包含管理型中断特殊处理流程，负责中断激活、启动及状态管理",
          "similarity": 0.6096178293228149
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/chip.c",
          "start_line": 495,
          "end_line": 610,
          "content": [
            "static bool irq_check_poll(struct irq_desc *desc)",
            "{",
            "\tif (!(desc->istate & IRQS_POLL_INPROGRESS))",
            "\t\treturn false;",
            "\treturn irq_wait_for_poll(desc);",
            "}",
            "static bool irq_may_run(struct irq_desc *desc)",
            "{",
            "\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;",
            "",
            "\t/*",
            "\t * If the interrupt is not in progress and is not an armed",
            "\t * wakeup interrupt, proceed.",
            "\t */",
            "\tif (!irqd_has_set(&desc->irq_data, mask))",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * If the interrupt is an armed wakeup source, mark it pending",
            "\t * and suspended, disable it and notify the pm core about the",
            "\t * event.",
            "\t */",
            "\tif (irq_pm_check_wakeup(desc))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Handle a potential concurrent poll on a different core.",
            "\t */",
            "\treturn irq_check_poll(desc);",
            "}",
            "void handle_simple_irq(struct irq_desc *desc)",
            "{",
            "\traw_spin_lock(&desc->lock);",
            "",
            "\tif (!irq_may_run(desc))",
            "\t\tgoto out_unlock;",
            "",
            "\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);",
            "",
            "\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {",
            "\t\tdesc->istate |= IRQS_PENDING;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tkstat_incr_irqs_this_cpu(desc);",
            "\thandle_irq_event(desc);",
            "",
            "out_unlock:",
            "\traw_spin_unlock(&desc->lock);",
            "}",
            "void handle_untracked_irq(struct irq_desc *desc)",
            "{",
            "\traw_spin_lock(&desc->lock);",
            "",
            "\tif (!irq_may_run(desc))",
            "\t\tgoto out_unlock;",
            "",
            "\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);",
            "",
            "\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {",
            "\t\tdesc->istate |= IRQS_PENDING;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tdesc->istate &= ~IRQS_PENDING;",
            "\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);",
            "\traw_spin_unlock(&desc->lock);",
            "",
            "\t__handle_irq_event_percpu(desc);",
            "",
            "\traw_spin_lock(&desc->lock);",
            "\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);",
            "",
            "out_unlock:",
            "\traw_spin_unlock(&desc->lock);",
            "}",
            "static void cond_unmask_irq(struct irq_desc *desc)",
            "{",
            "\t/*",
            "\t * We need to unmask in the following cases:",
            "\t * - Standard level irq (IRQF_ONESHOT is not set)",
            "\t * - Oneshot irq which did not wake the thread (caused by a",
            "\t *   spurious interrupt or a primary handler handling it",
            "\t *   completely).",
            "\t */",
            "\tif (!irqd_irq_disabled(&desc->irq_data) &&",
            "\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)",
            "\t\tunmask_irq(desc);",
            "}",
            "void handle_level_irq(struct irq_desc *desc)",
            "{",
            "\traw_spin_lock(&desc->lock);",
            "\tmask_ack_irq(desc);",
            "",
            "\tif (!irq_may_run(desc))",
            "\t\tgoto out_unlock;",
            "",
            "\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);",
            "",
            "\t/*",
            "\t * If its disabled or no action available",
            "\t * keep it masked and get out of here",
            "\t */",
            "\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {",
            "\t\tdesc->istate |= IRQS_PENDING;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tkstat_incr_irqs_this_cpu(desc);",
            "\thandle_irq_event(desc);",
            "",
            "\tcond_unmask_irq(desc);",
            "",
            "out_unlock:",
            "\traw_spin_unlock(&desc->lock);",
            "}"
          ],
          "function_name": "irq_check_poll, irq_may_run, handle_simple_irq, handle_untracked_irq, cond_unmask_irq, handle_level_irq",
          "description": "实现中断处理流程控制，包含轮询检查、中断可执行性判断及不同类型中断（简单/层级）的处理逻辑",
          "similarity": 0.5368835926055908
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/chip.c",
          "start_line": 22,
          "end_line": 148,
          "content": [
            "static irqreturn_t bad_chained_irq(int irq, void *dev_id)",
            "{",
            "\tWARN_ONCE(1, \"Chained irq %d should not call an action\\n\", irq);",
            "\treturn IRQ_NONE;",
            "}",
            "int irq_set_chip(unsigned int irq, const struct irq_chip *chip)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "",
            "\tdesc->irq_data.chip = (struct irq_chip *)(chip ?: &no_irq_chip);",
            "\tirq_put_desc_unlock(desc, flags);",
            "\t/*",
            "\t * For !CONFIG_SPARSE_IRQ make the irq show up in",
            "\t * allocated_irqs.",
            "\t */",
            "\tirq_mark_irq(irq);",
            "\treturn 0;",
            "}",
            "int irq_set_irq_type(unsigned int irq, unsigned int type)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);",
            "\tint ret = 0;",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "",
            "\tret = __irq_set_trigger(desc, type);",
            "\tirq_put_desc_busunlock(desc, flags);",
            "\treturn ret;",
            "}",
            "int irq_set_handler_data(unsigned int irq, void *data)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "\tdesc->irq_common_data.handler_data = data;",
            "\tirq_put_desc_unlock(desc, flags);",
            "\treturn 0;",
            "}",
            "int irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,",
            "\t\t\t struct msi_desc *entry)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_lock(irq_base + irq_offset, &flags, IRQ_GET_DESC_CHECK_GLOBAL);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "\tdesc->irq_common_data.msi_desc = entry;",
            "\tif (entry && !irq_offset)",
            "\t\tentry->irq = irq_base;",
            "\tirq_put_desc_unlock(desc, flags);",
            "\treturn 0;",
            "}",
            "int irq_set_msi_desc(unsigned int irq, struct msi_desc *entry)",
            "{",
            "\treturn irq_set_msi_desc_off(irq, 0, entry);",
            "}",
            "int irq_set_chip_data(unsigned int irq, void *data)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "\tdesc->irq_data.chip_data = data;",
            "\tirq_put_desc_unlock(desc, flags);",
            "\treturn 0;",
            "}",
            "static void irq_state_clr_disabled(struct irq_desc *desc)",
            "{",
            "\tirqd_clear(&desc->irq_data, IRQD_IRQ_DISABLED);",
            "}",
            "static void irq_state_clr_masked(struct irq_desc *desc)",
            "{",
            "\tirqd_clear(&desc->irq_data, IRQD_IRQ_MASKED);",
            "}",
            "static void irq_state_clr_started(struct irq_desc *desc)",
            "{",
            "\tirqd_clear(&desc->irq_data, IRQD_IRQ_STARTED);",
            "}",
            "static void irq_state_set_started(struct irq_desc *desc)",
            "{",
            "\tirqd_set(&desc->irq_data, IRQD_IRQ_STARTED);",
            "}",
            "static int",
            "__irq_startup_managed(struct irq_desc *desc, const struct cpumask *aff,",
            "\t\t      bool force)",
            "{",
            "\tstruct irq_data *d = irq_desc_get_irq_data(desc);",
            "",
            "\tif (!irqd_affinity_is_managed(d))",
            "\t\treturn IRQ_STARTUP_NORMAL;",
            "",
            "\tirqd_clr_managed_shutdown(d);",
            "",
            "\tif (cpumask_any_and(aff, cpu_online_mask) >= nr_cpu_ids) {",
            "\t\t/*",
            "\t\t * Catch code which fiddles with enable_irq() on a managed",
            "\t\t * and potentially shutdown IRQ. Chained interrupt",
            "\t\t * installment or irq auto probing should not happen on",
            "\t\t * managed irqs either.",
            "\t\t */",
            "\t\tif (WARN_ON_ONCE(force))",
            "\t\t\treturn IRQ_STARTUP_ABORT;",
            "\t\t/*",
            "\t\t * The interrupt was requested, but there is no online CPU",
            "\t\t * in it's affinity mask. Put it into managed shutdown",
            "\t\t * state and let the cpu hotplug mechanism start it up once",
            "\t\t * a CPU in the mask becomes available.",
            "\t\t */",
            "\t\treturn IRQ_STARTUP_ABORT;",
            "\t}",
            "\t/*",
            "\t * Managed interrupts have reserved resources, so this should not",
            "\t * happen.",
            "\t */",
            "\tif (WARN_ON(irq_domain_activate_irq(d, false)))",
            "\t\treturn IRQ_STARTUP_ABORT;",
            "\treturn IRQ_STARTUP_MANAGED;",
            "}"
          ],
          "function_name": "bad_chained_irq, irq_set_chip, irq_set_irq_type, irq_set_handler_data, irq_set_msi_desc_off, irq_set_msi_desc, irq_set_chip_data, irq_state_clr_disabled, irq_state_clr_masked, irq_state_clr_started, irq_state_set_started, __irq_startup_managed",
          "description": "实现中断芯片配置接口，包括设置中断芯片、触发类型、MSI描述符等，包含链式中断错误处理函数",
          "similarity": 0.5259074568748474
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/irq/chip.c",
          "start_line": 984,
          "end_line": 1090,
          "content": [
            "static void",
            "__irq_do_set_handler(struct irq_desc *desc, irq_flow_handler_t handle,",
            "\t\t     int is_chained, const char *name)",
            "{",
            "\tif (!handle) {",
            "\t\thandle = handle_bad_irq;",
            "\t} else {",
            "\t\tstruct irq_data *irq_data = &desc->irq_data;",
            "#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY",
            "\t\t/*",
            "\t\t * With hierarchical domains we might run into a",
            "\t\t * situation where the outermost chip is not yet set",
            "\t\t * up, but the inner chips are there.  Instead of",
            "\t\t * bailing we install the handler, but obviously we",
            "\t\t * cannot enable/startup the interrupt at this point.",
            "\t\t */",
            "\t\twhile (irq_data) {",
            "\t\t\tif (irq_data->chip != &no_irq_chip)",
            "\t\t\t\tbreak;",
            "\t\t\t/*",
            "\t\t\t * Bail out if the outer chip is not set up",
            "\t\t\t * and the interrupt supposed to be started",
            "\t\t\t * right away.",
            "\t\t\t */",
            "\t\t\tif (WARN_ON(is_chained))",
            "\t\t\t\treturn;",
            "\t\t\t/* Try the parent */",
            "\t\t\tirq_data = irq_data->parent_data;",
            "\t\t}",
            "#endif",
            "\t\tif (WARN_ON(!irq_data || irq_data->chip == &no_irq_chip))",
            "\t\t\treturn;",
            "\t}",
            "",
            "\t/* Uninstall? */",
            "\tif (handle == handle_bad_irq) {",
            "\t\tif (desc->irq_data.chip != &no_irq_chip)",
            "\t\t\tmask_ack_irq(desc);",
            "\t\tirq_state_set_disabled(desc);",
            "\t\tif (is_chained) {",
            "\t\t\tdesc->action = NULL;",
            "\t\t\tWARN_ON(irq_chip_pm_put(irq_desc_get_irq_data(desc)));",
            "\t\t}",
            "\t\tdesc->depth = 1;",
            "\t}",
            "\tdesc->handle_irq = handle;",
            "\tdesc->name = name;",
            "",
            "\tif (handle != handle_bad_irq && is_chained) {",
            "\t\tunsigned int type = irqd_get_trigger_type(&desc->irq_data);",
            "",
            "\t\t/*",
            "\t\t * We're about to start this interrupt immediately,",
            "\t\t * hence the need to set the trigger configuration.",
            "\t\t * But the .set_type callback may have overridden the",
            "\t\t * flow handler, ignoring that we're dealing with a",
            "\t\t * chained interrupt. Reset it immediately because we",
            "\t\t * do know better.",
            "\t\t */",
            "\t\tif (type != IRQ_TYPE_NONE) {",
            "\t\t\t__irq_set_trigger(desc, type);",
            "\t\t\tdesc->handle_irq = handle;",
            "\t\t}",
            "",
            "\t\tirq_settings_set_noprobe(desc);",
            "\t\tirq_settings_set_norequest(desc);",
            "\t\tirq_settings_set_nothread(desc);",
            "\t\tdesc->action = &chained_action;",
            "\t\tWARN_ON(irq_chip_pm_get(irq_desc_get_irq_data(desc)));",
            "\t\tirq_activate_and_startup(desc, IRQ_RESEND);",
            "\t}",
            "}",
            "void",
            "__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,",
            "\t\t  const char *name)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);",
            "",
            "\tif (!desc)",
            "\t\treturn;",
            "",
            "\t__irq_do_set_handler(desc, handle, is_chained, name);",
            "\tirq_put_desc_busunlock(desc, flags);",
            "}",
            "void",
            "irq_set_chained_handler_and_data(unsigned int irq, irq_flow_handler_t handle,",
            "\t\t\t\t void *data)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);",
            "",
            "\tif (!desc)",
            "\t\treturn;",
            "",
            "\tdesc->irq_common_data.handler_data = data;",
            "\t__irq_do_set_handler(desc, handle, 1, NULL);",
            "",
            "\tirq_put_desc_busunlock(desc, flags);",
            "}",
            "void",
            "irq_set_chip_and_handler_name(unsigned int irq, const struct irq_chip *chip,",
            "\t\t\t      irq_flow_handler_t handle, const char *name)",
            "{",
            "\tirq_set_chip(irq, chip);",
            "\t__irq_set_handler(irq, handle, 0, name);",
            "}"
          ],
          "function_name": "__irq_do_set_handler, __irq_set_handler, irq_set_chained_handler_and_data, irq_set_chip_and_handler_name",
          "description": "该代码段实现了中断处理程序的动态配置，核心功能是通过多个辅助函数统一管理中断处理逻辑的安装与更新。  \n`__irq_do_set_handler` 核心处理中断处理函数的绑定逻辑，包含对链式中断的特殊处理及触发类型配置，同时协调芯片层级的依赖关系。  \n其他函数（如 `__irq_set_handler` 和 `irq_set_chained_handler_and_data`）作为封装接口，分别用于普通中断和链式中断的处理器设置，通过共享底层逻辑实现功能差异化。",
          "similarity": 0.5130707025527954
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/chip.c",
          "start_line": 1,
          "end_line": 21,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992, 1998-2006 Linus Torvalds, Ingo Molnar",
            " * Copyright (C) 2005-2006, Thomas Gleixner, Russell King",
            " *",
            " * This file contains the core interrupt handling code, for irq-chip based",
            " * architectures. Detailed information is available in",
            " * Documentation/core-api/genericirq.rst",
            " */",
            "",
            "#include <linux/irq.h>",
            "#include <linux/msi.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdomain.h>",
            "",
            "#include <trace/events/irq.h>",
            "",
            "#include \"internals.h\"",
            ""
          ],
          "function_name": null,
          "description": "声明通用中断处理核心代码，包含irq-chip相关头文件及内部实现依赖，提供中断处理框架基础支持",
          "similarity": 0.5112046003341675
        }
      ]
    },
    {
      "source_file": "kernel/irq/migration.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:03:53\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\migration.c`\n\n---\n\n# `irq/migration.c` 技术文档\n\n## 1. 文件概述\n\n`irq/migration.c` 是 Linux 内核中断子系统中用于处理中断亲和性（IRQ affinity）迁移的核心实现文件。该文件主要负责在 CPU 热插拔（如 CPU offline）或显式调用 `irq_set_affinity()` 时，安全、正确地将中断从一个或多个 CPU 迁移到新的目标 CPU 集合。其关键职责包括：\n\n- 清理因 CPU 下线而无法完成的中断迁移状态；\n- 执行实际的中断亲和性重定向操作；\n- 确保在迁移过程中中断行为的正确性，尤其对边沿触发（edge-triggered）中断避免硬件异常。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能简述 |\n|--------|---------|\n| `irq_fixup_move_pending()` | 在 CPU 即将离线时，清理中断描述符中未完成的迁移状态（`move pending`），根据参数决定是否强制清除。 |\n| `irq_move_masked_irq()` | 执行已标记为“待迁移”的中断的实际亲和性设置操作，调用底层 `irq_chip` 的 `irq_set_affinity` 回调。 |\n| `__irq_move_irq()` | 对未被禁用的中断执行完整的迁移流程：临时屏蔽 → 执行迁移 → 恢复屏蔽状态。 |\n\n### 关键数据结构（间接使用）\n\n- `struct irq_desc`：中断描述符，包含中断状态、锁、pending_mask 等。\n- `struct irq_data`：中断数据结构，包含芯片操作回调、亲和性掩码、状态标志（如 `IRQD_SETAFFINITY_PENDING`）。\n- `cpumask_t pending_mask`：记录待迁移的目标 CPU 掩码。\n\n## 3. 关键实现\n\n### 中断迁移状态管理\n\n- **`IRQD_SETAFFINITY_PENDING` 标志**：当调用 `irq_set_affinity()` 但无法立即执行（如中断正在处理中），内核会设置此标志，并将目标 CPU 掩码存入 `desc->pending_mask`。\n- **迁移触发时机**：通常在中断处理结束（EOI）或显式调用迁移函数时，检查该标志并执行实际迁移。\n\n### `irq_fixup_move_pending()` 的逻辑\n\n- 若未设置 `move pending`，直接返回 `false`。\n- 检查 `pending_mask` 中是否还有**在线 CPU**：\n  - 若无（即所有目标 CPU 都已离线），则清除 `move pending` 标志，返回 `false`。\n  - 若有，且 `force_clear == true`，则强制清除标志，但仍返回 `true`（表示存在有效目标）。\n- 返回值用于判断是否仍需将中断迁移到其他在线 CPU。\n\n### `irq_move_masked_irq()` 的安全迁移机制\n\n- **前提条件**：调用者必须已持有 `desc->lock`，且中断已被屏蔽（由 `__irq_move_irq` 保证）。\n- **关键步骤**：\n  1. 清除 `move pending` 标志；\n  2. 跳过 per-CPU 中断（不应迁移）；\n  3. 若 `pending_mask` 为空或芯片不支持 `irq_set_affinity`，直接退出；\n  4. 调用 `irq_do_set_affinity()` 执行底层亲和性设置；\n  5. 若返回 `-EBUSY`（如向量资源繁忙），重新设置 `move pending`，保留 `pending_mask`，推迟迁移；\n  6. 成功则清空 `pending_mask`。\n\n### `__irq_move_irq()` 的屏蔽保护\n\n- 对非屏蔽中断，**临时屏蔽** → 执行迁移 → **恢复原状态**。\n- 防止在迁移过程中（尤其是边沿触发中断）因硬件寄存器重编程导致中断丢失或重复触发。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`、`<linux/interrupt.h>`：提供中断核心 API 和数据结构定义。\n  - `\"internals.h\"`：包含中断子系统内部函数和宏（如 `irq_do_set_affinity`、状态操作宏）。\n- **功能依赖**：\n  - **中断域（IRQ Domain）层次结构**：通过 `irq_desc_get_irq_data()` 自动处理层次化中断控制器（如级联 GIC）。\n  - **CPU 热插拔子系统**：`cpu_online_mask` 用于判断目标 CPU 是否在线。\n  - **底层中断控制器驱动**：依赖 `struct irq_chip` 的 `irq_mask`/`irq_unmask`/`irq_set_affinity` 回调实现。\n\n## 5. 使用场景\n\n1. **CPU 热插拔（Offline）**：\n   - 当 CPU 被关闭时，内核调用 `irq_fixup_move_pending()` 清理分配给该 CPU 但尚未迁移的中断。\n   - 若存在其他在线目标 CPU，则后续通过 `__irq_move_irq()` 完成实际迁移。\n\n2. **用户空间或内核动态设置亲和性**：\n   - 通过 `/proc/irq/<N>/smp_affinity` 或 `irq_set_affinity()` API 修改中断目标 CPU。\n   - 若中断处于活跃状态，设置 `move pending` 标志，待安全时机（如中断处理结束）由 `__irq_move_irq()` 执行迁移。\n\n3. **中断负载均衡**：\n   - 内核调度器或中断均衡器（如 `irqbalance`）调整中断分布时，触发亲和性迁移流程。\n\n4. **虚拟化与容器环境**：\n   - 在 vCPU 热插拔或 NUMA 拓扑变化时，确保设备中断正确绑定到新拓扑中的在线 CPU。",
      "similarity": 0.5525280237197876,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/migration.c",
          "start_line": 18,
          "end_line": 117,
          "content": [
            "bool irq_fixup_move_pending(struct irq_desc *desc, bool force_clear)",
            "{",
            "\tstruct irq_data *data = irq_desc_get_irq_data(desc);",
            "",
            "\tif (!irqd_is_setaffinity_pending(data))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * The outgoing CPU might be the last online target in a pending",
            "\t * interrupt move. If that's the case clear the pending move bit.",
            "\t */",
            "\tif (cpumask_any_and(desc->pending_mask, cpu_online_mask) >= nr_cpu_ids) {",
            "\t\tirqd_clr_move_pending(data);",
            "\t\treturn false;",
            "\t}",
            "\tif (force_clear)",
            "\t\tirqd_clr_move_pending(data);",
            "\treturn true;",
            "}",
            "void irq_move_masked_irq(struct irq_data *idata)",
            "{",
            "\tstruct irq_desc *desc = irq_data_to_desc(idata);",
            "\tstruct irq_data *data = &desc->irq_data;",
            "\tstruct irq_chip *chip = data->chip;",
            "",
            "\tif (likely(!irqd_is_setaffinity_pending(data)))",
            "\t\treturn;",
            "",
            "\tirqd_clr_move_pending(data);",
            "",
            "\t/*",
            "\t * Paranoia: cpu-local interrupts shouldn't be calling in here anyway.",
            "\t */",
            "\tif (irqd_is_per_cpu(data)) {",
            "\t\tWARN_ON(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (unlikely(cpumask_empty(desc->pending_mask)))",
            "\t\treturn;",
            "",
            "\tif (!chip->irq_set_affinity)",
            "\t\treturn;",
            "",
            "\tassert_raw_spin_locked(&desc->lock);",
            "",
            "\t/*",
            "\t * If there was a valid mask to work with, please",
            "\t * do the disable, re-program, enable sequence.",
            "\t * This is *not* particularly important for level triggered",
            "\t * but in a edge trigger case, we might be setting rte",
            "\t * when an active trigger is coming in. This could",
            "\t * cause some ioapics to mal-function.",
            "\t * Being paranoid i guess!",
            "\t *",
            "\t * For correct operation this depends on the caller",
            "\t * masking the irqs.",
            "\t */",
            "\tif (cpumask_any_and(desc->pending_mask, cpu_online_mask) < nr_cpu_ids) {",
            "\t\tint ret;",
            "",
            "\t\tret = irq_do_set_affinity(data, desc->pending_mask, false);",
            "\t\t/*",
            "\t\t * If the there is a cleanup pending in the underlying",
            "\t\t * vector management, reschedule the move for the next",
            "\t\t * interrupt. Leave desc->pending_mask intact.",
            "\t\t */",
            "\t\tif (ret == -EBUSY) {",
            "\t\t\tirqd_set_move_pending(data);",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "\tcpumask_clear(desc->pending_mask);",
            "}",
            "void __irq_move_irq(struct irq_data *idata)",
            "{",
            "\tbool masked;",
            "",
            "\t/*",
            "\t * Get top level irq_data when CONFIG_IRQ_DOMAIN_HIERARCHY is enabled,",
            "\t * and it should be optimized away when CONFIG_IRQ_DOMAIN_HIERARCHY is",
            "\t * disabled. So we avoid an \"#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\" here.",
            "\t */",
            "\tidata = irq_desc_get_irq_data(irq_data_to_desc(idata));",
            "",
            "\tif (unlikely(irqd_irq_disabled(idata)))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Be careful vs. already masked interrupts. If this is a",
            "\t * threaded interrupt with ONESHOT set, we can end up with an",
            "\t * interrupt storm.",
            "\t */",
            "\tmasked = irqd_irq_masked(idata);",
            "\tif (!masked)",
            "\t\tidata->chip->irq_mask(idata);",
            "\tirq_move_masked_irq(idata);",
            "\tif (!masked)",
            "\t\tidata->chip->irq_unmask(idata);",
            "}"
          ],
          "function_name": "irq_fixup_move_pending, irq_move_masked_irq, __irq_move_irq",
          "description": "实现中断迁移相关操作。irq_fixup_move_pending清理迁移挂起位；irq_move_masked_irq调整中断亲和性并处理迁移失败场景；__irq_move_irq协调中断屏蔽与迁移流程，确保迁移操作原子性。三者协同管理中断在CPU间动态迁移时的状态同步与资源回收。",
          "similarity": 0.5542268753051758
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/migration.c",
          "start_line": 1,
          "end_line": 17,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "",
            "#include \"internals.h\"",
            "",
            "/**",
            " * irq_fixup_move_pending - Cleanup irq move pending from a dying CPU",
            " * @desc:\t\tInterrupt descriptor to clean up",
            " * @force_clear:\tIf set clear the move pending bit unconditionally.",
            " *\t\t\tIf not set, clear it only when the dying CPU is the",
            " *\t\t\tlast one in the pending mask.",
            " *",
            " * Returns true if the pending bit was set and the pending mask contains an",
            " * online CPU other than the dying CPU.",
            " */"
          ],
          "function_name": null,
          "description": "声明irq_fixup_move_pending函数原型，用于清理中断迁移挂起状态。该函数根据参数判断是否清除中断迁移挂起位，核心逻辑是检查目标CPU是否仍在线以决定是否保留挂起标记。",
          "similarity": 0.5242477059364319
        }
      ]
    },
    {
      "source_file": "kernel/sched/swait.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:18:23\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\swait.c`\n\n---\n\n# `sched/swait.c` 技术文档\n\n## 1. 文件概述\n\n`sched/swait.c` 是 Linux 内核中 **简单等待队列（simple wait queues）** 的核心实现文件，对应头文件为 `<linux/swait.h>`。该机制提供了一种轻量级、低开销的进程等待与唤醒基础设施，相比传统的 `wait_queue`，`swait` 去除了复杂的回调函数、唤醒过滤器等特性，仅保留最基本的 FIFO 等待队列功能，适用于对性能和代码简洁性要求较高的场景（如 completion 机制）。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct swait_queue_head`：简单等待队列头，包含一个自旋锁 `lock` 和一个任务链表 `task_list`。\n- `struct swait_queue`：代表一个等待项，包含指向当前任务 `task` 的指针和链表节点 `task_list`。\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|---------|\n| `__init_swait_queue_head()` | 初始化 `swait_queue_head` 结构，设置锁类信息和初始化链表。 |\n| `swake_up_locked()` | 在已持有队列锁的前提下，唤醒队列中的**第一个**等待任务并将其从队列中移除。 |\n| `swake_up_all_locked()` | 在已持有队列锁的前提下，**循环唤醒所有**等待任务（专用于 completion）。 |\n| `swake_up_one()` | 安全地唤醒队列中的**第一个**等待任务（自动加锁/关中断）。 |\n| `swake_up_all()` | 安全地唤醒**所有**等待任务，支持从中断上下文调用，但内部会临时释放锁以避免长时间持锁。 |\n| `__prepare_to_swait()` | 将当前任务加入等待队列（需外部加锁）。 |\n| `prepare_to_swait_exclusive()` | 将当前任务以指定状态加入等待队列，并设置任务状态（自动加锁/关中断）。 |\n| `prepare_to_swait_event()` | 类似 `prepare_to_swait_exclusive()`，但会检查是否有挂起信号，若有则返回 `-ERESTARTSYS`。 |\n| `__finish_swait()` / `finish_swait()` | 清理等待状态，将任务从队列中移除并恢复为 `TASK_RUNNING` 状态。 |\n\n## 3. 关键实现\n\n### 等待队列管理\n- 所有等待任务通过 `list_add_tail()` 按 FIFO 顺序加入 `q->task_list`。\n- 每个 `swait_queue` 实例通常作为局部变量在栈上分配，生命周期由调用者控制。\n\n### 唤醒机制\n- **`swake_up_locked()`**：仅唤醒队首任务，适用于“一次唤醒一个”的场景（如互斥资源）。\n- **`swake_up_all()`**：\n  - 先将整个等待链表 `splice` 到临时链表 `tmp`，避免在唤醒过程中队列被并发修改。\n  - 采用 **“唤醒一个 → 释放锁 → 重新加锁”** 的循环策略，防止在唤醒大量任务时长时间持有自旋锁，从而避免影响系统实时性。\n  - **不适用于中断上下文**（因其内部会启用中断）。\n- **`swake_up_all_locked()`**：\n  - 专为 **completion** 设计，可在硬中断上下文或关中断区域调用。\n  - 直接循环调用 `swake_up_locked()`，不释放锁，因此要求调用者确保上下文安全。\n\n### 信号处理\n- `prepare_to_swait_event()` 在加入队列前检查 `signal_pending_state()`，若存在挂起信号，则**不加入队列**并返回 `-ERESTARTSYS`，确保后续 `swake_up_one()` 不会错误唤醒一个本应被信号中断的任务。\n\n### 锁与中断控制\n- 所有对外接口（如 `swake_up_one`, `prepare_to_swait_exclusive`）均使用 `raw_spin_lock_irqsave()` / `raw_spin_unlock_irqrestore()`，保证在中断上下文和 SMP 环境下的安全性。\n- `finish_swait()` 使用 `list_empty_careful()` 避免在无锁情况下误判链表状态，仅在必要时加锁删除节点。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/swait.h>`：定义 `swait_queue_head` 和 `swait_queue` 结构及函数原型。\n  - `<linux/sched.h>`：提供 `try_to_wake_up()`, `wake_up_state()`, `set_current_state()` 等调度器接口。\n  - `<linux/list.h>`：提供链表操作宏。\n  - `<linux/spinlock.h>`：提供原始自旋锁实现。\n  - `<linux/lockdep.h>`：用于锁类调试（`lockdep_set_class_and_name`）。\n- **模块依赖**：\n  - **Completion 机制**（`kernel/completion.c`）：是 `swait` 的主要用户，依赖 `swake_up_all_locked()` 实现中断安全的批量唤醒。\n  - 其他需要轻量级等待机制的子系统（如某些驱动或底层同步原语）。\n\n## 5. 使用场景\n\n- **Completion 同步原语**：`swait` 是 completion 的底层实现基础，用于线程间“完成通知”场景。\n- **轻量级条件等待**：当不需要传统 `wait_queue` 的复杂功能（如唤醒回调、非互斥等待等）时，可使用 `swait` 减少开销。\n- **中断上下文唤醒**：通过 `swake_up_all_locked()`，允许在硬中断或关中断区域安全地唤醒等待任务（仅限 completion 使用）。\n- **性能敏感路径**：由于 `swait` 代码路径短、无动态内存分配、无复杂逻辑，适用于对延迟要求极高的内核路径。",
      "similarity": 0.5522152185440063,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/swait.c",
          "start_line": 6,
          "end_line": 111,
          "content": [
            "void __init_swait_queue_head(struct swait_queue_head *q, const char *name,",
            "\t\t\t     struct lock_class_key *key)",
            "{",
            "\traw_spin_lock_init(&q->lock);",
            "\tlockdep_set_class_and_name(&q->lock, key, name);",
            "\tINIT_LIST_HEAD(&q->task_list);",
            "}",
            "void swake_up_locked(struct swait_queue_head *q, int wake_flags)",
            "{",
            "\tstruct swait_queue *curr;",
            "",
            "\tif (list_empty(&q->task_list))",
            "\t\treturn;",
            "",
            "\tcurr = list_first_entry(&q->task_list, typeof(*curr), task_list);",
            "\ttry_to_wake_up(curr->task, TASK_NORMAL, wake_flags);",
            "\tlist_del_init(&curr->task_list);",
            "}",
            "void swake_up_all_locked(struct swait_queue_head *q)",
            "{",
            "\twhile (!list_empty(&q->task_list))",
            "\t\tswake_up_locked(q, 0);",
            "}",
            "void swake_up_one(struct swait_queue_head *q)",
            "{",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&q->lock, flags);",
            "\tswake_up_locked(q, 0);",
            "\traw_spin_unlock_irqrestore(&q->lock, flags);",
            "}",
            "void swake_up_all(struct swait_queue_head *q)",
            "{",
            "\tstruct swait_queue *curr;",
            "\tLIST_HEAD(tmp);",
            "",
            "\traw_spin_lock_irq(&q->lock);",
            "\tlist_splice_init(&q->task_list, &tmp);",
            "\twhile (!list_empty(&tmp)) {",
            "\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);",
            "",
            "\t\twake_up_state(curr->task, TASK_NORMAL);",
            "\t\tlist_del_init(&curr->task_list);",
            "",
            "\t\tif (list_empty(&tmp))",
            "\t\t\tbreak;",
            "",
            "\t\traw_spin_unlock_irq(&q->lock);",
            "\t\traw_spin_lock_irq(&q->lock);",
            "\t}",
            "\traw_spin_unlock_irq(&q->lock);",
            "}",
            "void __prepare_to_swait(struct swait_queue_head *q, struct swait_queue *wait)",
            "{",
            "\twait->task = current;",
            "\tif (list_empty(&wait->task_list))",
            "\t\tlist_add_tail(&wait->task_list, &q->task_list);",
            "}",
            "void prepare_to_swait_exclusive(struct swait_queue_head *q, struct swait_queue *wait, int state)",
            "{",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&q->lock, flags);",
            "\t__prepare_to_swait(q, wait);",
            "\tset_current_state(state);",
            "\traw_spin_unlock_irqrestore(&q->lock, flags);",
            "}",
            "long prepare_to_swait_event(struct swait_queue_head *q, struct swait_queue *wait, int state)",
            "{",
            "\tunsigned long flags;",
            "\tlong ret = 0;",
            "",
            "\traw_spin_lock_irqsave(&q->lock, flags);",
            "\tif (signal_pending_state(state, current)) {",
            "\t\t/*",
            "\t\t * See prepare_to_wait_event(). TL;DR, subsequent swake_up_one()",
            "\t\t * must not see us.",
            "\t\t */",
            "\t\tlist_del_init(&wait->task_list);",
            "\t\tret = -ERESTARTSYS;",
            "\t} else {",
            "\t\t__prepare_to_swait(q, wait);",
            "\t\tset_current_state(state);",
            "\t}",
            "\traw_spin_unlock_irqrestore(&q->lock, flags);",
            "",
            "\treturn ret;",
            "}",
            "void __finish_swait(struct swait_queue_head *q, struct swait_queue *wait)",
            "{",
            "\t__set_current_state(TASK_RUNNING);",
            "\tif (!list_empty(&wait->task_list))",
            "\t\tlist_del_init(&wait->task_list);",
            "}",
            "void finish_swait(struct swait_queue_head *q, struct swait_queue *wait)",
            "{",
            "\tunsigned long flags;",
            "",
            "\t__set_current_state(TASK_RUNNING);",
            "",
            "\tif (!list_empty_careful(&wait->task_list)) {",
            "\t\traw_spin_lock_irqsave(&q->lock, flags);",
            "\t\tlist_del_init(&wait->task_list);",
            "\t\traw_spin_unlock_irqrestore(&q->lock, flags);",
            "\t}",
            "}"
          ],
          "function_name": "__init_swait_queue_head, swake_up_locked, swake_up_all_locked, swake_up_one, swake_up_all, __prepare_to_swait, prepare_to_swait_exclusive, prepare_to_swait_event, __finish_swait, finish_swait",
          "description": "实现简单等待队列相关函数，包括初始化头结构、唤醒单个/全部等待任务、准备等待状态及完成等待操作，支持锁保护与中断安全唤醒逻辑",
          "similarity": 0.5361654758453369
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/swait.c",
          "start_line": 1,
          "end_line": 5,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * <linux/swait.h> (simple wait queues ) implementation:",
            " */",
            ""
          ],
          "function_name": null,
          "description": "此代码块为swait.h头文件的实现片段，仅包含许可证声明与注释，未提供实际功能代码，上下文不完整",
          "similarity": 0.4879385828971863
        }
      ]
    }
  ]
}