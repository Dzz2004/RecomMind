{
  "query": "引导程序如何处理多操作系统启动",
  "timestamp": "2025-12-26 00:36:01",
  "retrieved_files": [
    {
      "source_file": "kernel/usermode_driver.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:47:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `usermode_driver.c`\n\n---\n\n# usermode_driver.c 技术文档\n\n## 文件概述\n\n`usermode_driver.c` 实现了 Linux 内核中用户态驱动（User Mode Driver, UMD）的支持机制。该文件提供了一套 API，允许内核模块将一段可执行的二进制数据（blob）加载为临时文件系统中的可执行文件，并以此为基础 fork 出一个用户态进程作为驱动程序运行。该机制常用于需要在用户空间执行复杂逻辑但又需与内核紧密协作的驱动场景（如某些固件加载器、安全模块或虚拟设备驱动）。\n\n## 核心功能\n\n### 主要函数\n\n- `blob_to_mnt(const void *data, size_t len, const char *name)`  \n  将二进制数据写入 tmpfs 文件系统中，返回挂载点（vfsmount）。\n\n- `umd_load_blob(struct umd_info *info, const void *data, size_t len)`  \n  将给定的二进制 blob 加载为可执行文件，并关联到 `umd_info` 结构中。\n\n- `umd_unload_blob(struct umd_info *info)`  \n  卸载之前加载的 blob，释放相关文件系统资源。\n\n- `fork_usermode_driver(struct umd_info *info)`  \n  基于已加载的 blob fork 并执行一个用户态驱动进程。\n\n- `umd_setup(struct subprocess_info *info, struct cred *new)`  \n  在子进程中设置执行环境，包括创建通信管道、设置工作目录等。\n\n- `umd_cleanup(struct subprocess_info *info)`  \n  子进程执行失败时的清理回调。\n\n- `umd_cleanup_helper(struct umd_info *info)`  \n  释放 `umd_setup` 中分配的资源（管道、PID 等）。\n\n### 关键数据结构\n\n- `struct umd_info`  \n  描述用户态驱动的上下文信息，包含：\n  - `wd`：工作目录（`struct path`），指向 tmpfs 中的可执行文件所在目录\n  - `driver_name`：驱动程序在 tmpfs 中的文件名\n  - `pipe_to_umh` / `pipe_from_umh`：与用户态进程通信的双向管道\n  - `tgid`：用户态驱动进程的线程组 ID（用于后续管理）\n\n## 关键实现\n\n### Blob 到可执行文件的转换\n\n`blob_to_mnt()` 函数通过以下步骤将内存中的二进制数据转换为可执行文件：\n\n1. 挂载 `tmpfs` 文件系统（使用 `kern_mount()`）\n2. 在挂载点根目录下以指定名称创建文件（权限 `0700`）\n3. 使用 `kernel_write()` 将数据写入文件\n4. 调用 `flush_delayed_fput()` 和 `task_work_run()` 确保文件描述符延迟释放完成，以便后续 `exec` 能以只读方式打开该文件\n\n此机制避免了将驱动二进制写入磁盘，提高了安全性和灵活性。\n\n### 用户态驱动进程的启动\n\n`fork_usermode_driver()` 利用内核的 `call_usermodehelper` 机制：\n\n- 使用 `call_usermodehelper_setup()` 注册 `umd_setup` 作为子进程初始化回调\n- 在 `umd_setup` 中：\n  - 创建两个匿名管道：一个用于内核向用户态发送数据（stdin 重定向），一个用于用户态向内核返回数据（stdout 重定向）\n  - 使用 `replace_fd()` 将标准输入/输出重定向到管道端点\n  - 设置当前进程的 pwd（工作目录）为 tmpfs 挂载点，使 `exec` 能直接以相对路径执行驱动文件\n  - 保存管道文件指针和子进程 TGID 到 `umd_info`\n- 执行 `call_usermodehelper_exec()` 启动进程\n\n### 资源管理与错误处理\n\n- `umd_load_blob()` 和 `umd_unload_blob()` 通过 `WARN_ON_ONCE` 确保状态一致性（避免重复加载/卸载）\n- 若 `exec` 失败，`umd_cleanup` 回调会调用 `umd_cleanup_helper` 释放管道和 PID\n- 所有资源（vfsmount、file、pipe、pid）均通过内核标准接口分配和释放，确保无泄漏\n\n## 依赖关系\n\n- **文件系统**：依赖 `tmpfs`（通过 `get_fs_type(\"tmpfs\")`），用于临时存储可执行 blob\n- **进程管理**：依赖 `call_usermodehelper` 子系统（`linux/kmod.h` 隐式包含），用于 fork/exec 用户态进程\n- **VFS 层**：使用 `kern_mount`/`kern_unmount`、`file_open_root_mnt`、`kernel_write` 等 VFS 接口\n- **IPC 机制**：依赖管道（`create_pipe_files`）实现内核与用户态驱动的双向通信\n- **内存管理**：依赖 `shmem_fs.h`（tmpfs 底层基于共享内存）\n- **任务工作队列**：调用 `task_work_run()` 确保文件描述符及时释放\n\n## 使用场景\n\n1. **动态用户态驱动加载**  \n   内核模块可将嵌入的 ELF 二进制或脚本作为 blob 加载，无需预先安装到文件系统。\n\n2. **安全隔离驱动**  \n   将可能含漏洞的驱动逻辑移至用户空间运行，通过管道与内核通信，降低内核攻击面。\n\n3. **固件或微码加载器**  \n   某些设备需要复杂的固件初始化逻辑，可通过 UMD 在用户态执行，避免内核复杂性。\n\n4. **虚拟设备后端**  \n   如 virtio-user、vhost-user 等场景，内核前端通过 UMD 与用户态后端进程协作。\n\n5. **测试与原型开发**  \n   快速验证驱动逻辑，无需频繁编译内核模块，提高开发效率。\n\n> **注意**：调用者需负责用户态进程的生命周期管理（健康检查、信号终止、管道关闭等）。",
      "similarity": 0.5597041249275208,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 60,
          "end_line": 161,
          "content": [
            "int umd_load_blob(struct umd_info *info, const void *data, size_t len)",
            "{",
            "\tstruct vfsmount *mnt;",
            "",
            "\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))",
            "\t\treturn -EBUSY;",
            "",
            "\tmnt = blob_to_mnt(data, len, info->driver_name);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn PTR_ERR(mnt);",
            "",
            "\tinfo->wd.mnt = mnt;",
            "\tinfo->wd.dentry = mnt->mnt_root;",
            "\treturn 0;",
            "}",
            "int umd_unload_blob(struct umd_info *info)",
            "{",
            "\tif (WARN_ON_ONCE(!info->wd.mnt ||",
            "\t\t\t !info->wd.dentry ||",
            "\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))",
            "\t\treturn -EINVAL;",
            "",
            "\tkern_unmount(info->wd.mnt);",
            "\tinfo->wd.mnt = NULL;",
            "\tinfo->wd.dentry = NULL;",
            "\treturn 0;",
            "}",
            "static int umd_setup(struct subprocess_info *info, struct cred *new)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "\tstruct file *from_umh[2];",
            "\tstruct file *to_umh[2];",
            "\tint err;",
            "",
            "\t/* create pipe to send data to umh */",
            "\terr = create_pipe_files(to_umh, 0);",
            "\tif (err)",
            "\t\treturn err;",
            "\terr = replace_fd(0, to_umh[0], 0);",
            "\tfput(to_umh[0]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\t/* create pipe to receive data from umh */",
            "\terr = create_pipe_files(from_umh, 0);",
            "\tif (err) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\treturn err;",
            "\t}",
            "\terr = replace_fd(1, from_umh[1], 0);",
            "\tfput(from_umh[1]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\tfput(from_umh[0]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tset_fs_pwd(current->fs, &umd_info->wd);",
            "\tumd_info->pipe_to_umh = to_umh[1];",
            "\tumd_info->pipe_from_umh = from_umh[0];",
            "\tumd_info->tgid = get_pid(task_tgid(current));",
            "\treturn 0;",
            "}",
            "static void umd_cleanup(struct subprocess_info *info)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "",
            "\t/* cleanup if umh_setup() was successful but exec failed */",
            "\tif (info->retval)",
            "\t\tumd_cleanup_helper(umd_info);",
            "}",
            "void umd_cleanup_helper(struct umd_info *info)",
            "{",
            "\tfput(info->pipe_to_umh);",
            "\tfput(info->pipe_from_umh);",
            "\tput_pid(info->tgid);",
            "\tinfo->tgid = NULL;",
            "}",
            "int fork_usermode_driver(struct umd_info *info)",
            "{",
            "\tstruct subprocess_info *sub_info;",
            "\tconst char *argv[] = { info->driver_name, NULL };",
            "\tint err;",
            "",
            "\tif (WARN_ON_ONCE(info->tgid))",
            "\t\treturn -EBUSY;",
            "",
            "\terr = -ENOMEM;",
            "\tsub_info = call_usermodehelper_setup(info->driver_name,",
            "\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,",
            "\t\t\t\t\t     umd_setup, umd_cleanup, info);",
            "\tif (!sub_info)",
            "\t\tgoto out;",
            "",
            "\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);",
            "out:",
            "\treturn err;",
            "}"
          ],
          "function_name": "umd_load_blob, umd_unload_blob, umd_setup, umd_cleanup, umd_cleanup_helper, fork_usermode_driver",
          "description": "提供用户模式驱动程序的数据加载/卸载及子进程管理功能，包括挂载tmpfs、建立进程间管道通信、设置工作目录及清理资源，最终通过call_usermodehelper启动用户态驱动程序",
          "similarity": 0.5831366181373596
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * umd - User mode driver support",
            " */",
            "#include <linux/shmem_fs.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/usermode_driver.h>",
            "",
            "static struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)",
            "{",
            "\tstruct file_system_type *type;",
            "\tstruct vfsmount *mnt;",
            "\tstruct file *file;",
            "\tssize_t written;",
            "\tloff_t pos = 0;",
            "",
            "\ttype = get_fs_type(\"tmpfs\");",
            "\tif (!type)",
            "\t\treturn ERR_PTR(-ENODEV);",
            "",
            "\tmnt = kern_mount(type);",
            "\tput_filesystem(type);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn mnt;",
            "",
            "\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);",
            "\tif (IS_ERR(file)) {",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_CAST(file);",
            "\t}",
            "",
            "\twritten = kernel_write(file, data, len, &pos);",
            "\tif (written != len) {",
            "\t\tint err = written;",
            "\t\tif (err >= 0)",
            "\t\t\terr = -ENOMEM;",
            "\t\tfilp_close(file, NULL);",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_PTR(err);",
            "\t}",
            "",
            "\tfput(file);",
            "",
            "\t/* Flush delayed fput so exec can open the file read-only */",
            "\tflush_delayed_fput();",
            "\ttask_work_run();",
            "\treturn mnt;",
            "}",
            "",
            "/**",
            " * umd_load_blob - Remember a blob of bytes for fork_usermode_driver",
            " * @info: information about usermode driver",
            " * @data: a blob of bytes that can be executed as a file",
            " * @len:  The lentgh of the blob",
            " *",
            " */"
          ],
          "function_name": null,
          "description": "创建并挂载tmpfs文件系统以存储二进制数据，通过文件操作将输入数据写入新挂载点的指定名称文件，返回对应的vfsmount结构指针",
          "similarity": 0.4568621516227722
        }
      ]
    },
    {
      "source_file": "kernel/entry/syscall_user_dispatch.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:20:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `entry\\syscall_user_dispatch.c`\n\n---\n\n# entry/syscall_user_dispatch.c 技术文档\n\n## 1. 文件概述\n\n`entry/syscall_user_dispatch.c` 实现了 **系统调用用户分发（Syscall User Dispatch, SUD）** 机制，该机制允许用户空间程序通过 `prctl()` 系统调用配置一个“选择器”（selector），用于在特定条件下拦截或允许系统调用的执行。当系统调用指令指针位于指定区域之外且选择器状态为“阻塞”时，内核会回滚该系统调用并向进程发送 `SIGSYS` 信号，从而实现对系统调用的细粒度控制。此功能常用于沙箱、安全监控或调试场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `trigger_sigsys(struct pt_regs *regs)`  \n  构造并强制发送 `SIGSYS` 信号，携带被拦截系统调用的详细信息（如地址、系统调用号、架构等）。\n\n- `syscall_user_dispatch(struct pt_regs *regs)`  \n  系统调用入口处的分发判断逻辑。根据当前指令指针位置和用户选择器状态决定是否拦截系统调用。\n\n- `task_set_syscall_user_dispatch(struct task_struct *task, ...)`  \n  为指定任务设置系统调用用户分发配置（开启/关闭、偏移、长度、选择器地址）。\n\n- `set_syscall_user_dispatch(...)`  \n  为当前任务设置系统调用用户分发配置的封装接口，供 `prctl()` 调用。\n\n- `syscall_user_dispatch_get_config(...)`  \n  通过 `ptrace` 获取指定任务的 SUD 配置。\n\n- `syscall_user_dispatch_set_config(...)`  \n  通过 `ptrace` 设置指定任务的 SUD 配置。\n\n### 关键数据结构\n\n- `struct syscall_user_dispatch`（定义在 `<linux/syscall_user_dispatch.h>`）  \n  存储每个任务的 SUD 配置：\n  - `selector`：指向用户空间选择器字节的指针\n  - `offset` / `len`：允许直接执行系统调用的代码区域（[offset, offset+len)）\n  - `on_dispatch`：标志位，表示当前是否处于分发拦截状态\n\n- `struct ptrace_sud_config`  \n  用于 `ptrace` 接口传递 SUD 配置的结构体，包含 `mode`、`offset`、`len` 和 `selector`。\n\n## 3. 关键实现\n\n### 系统调用拦截逻辑\n\n1. **区域检查**：若当前指令指针（`instruction_pointer(regs)`）落在 `[offset, offset + len)` 范围内，则**允许**系统调用直接执行，不进行拦截。\n2. **vdso 例外**：若系统调用来自 vDSO 中的 `sigreturn`（如 `arch_syscall_is_vdso_sigreturn()` 返回 true），则跳过拦截，避免干扰信号返回路径。\n3. **选择器读取**：若配置了 `selector`，则从用户空间读取一个字节的状态值：\n   - `SYSCALL_DISPATCH_FILTER_ALLOW`（0）：允许系统调用\n   - `SYSCALL_DISPATCH_FILTER_BLOCK`（1）：触发拦截\n   - 其他值：视为非法，发送 `SIGSYS`\n4. **拦截处理**：\n   - 设置 `on_dispatch = true`\n   - 调用 `syscall_rollback()` 回滚系统调用（恢复寄存器状态）\n   - 调用 `trigger_sigsys()` 发送 `SIGSYS` 信号\n\n### 安全与健壮性设计\n\n- **地址合法性校验**：在设置 `selector` 时使用 `access_ok(untagged_addr(selector), ...)`，确保地址可访问，并处理内存标记（如 ARM MTE）场景下调试器（tracer）与被调试进程（tracee）地址标记不一致的问题。\n- **溢出防护**：检查 `offset + len <= offset` 防止整数溢出导致无效区域。\n- **权限隔离**：`ptrace` 接口允许调试器配置其他进程的 SUD，但需具备相应权限。\n\n### 信号信息构造\n\n`trigger_sigsys()` 构造的 `siginfo_t` 包含：\n- `si_signo = SIGSYS`\n- `si_code = SYS_USER_DISPATCH`\n- `si_call_addr`：触发系统调用的用户空间地址\n- `si_syscall`：系统调用号\n- `si_arch`：系统调用架构（如 x86_64、AArch64）\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/prctl.h>`：定义 `PR_SYS_DISPATCH_*` 常量\n  - `<linux/syscall_user_dispatch.h>`：定义 `struct syscall_user_dispatch` 和相关常量\n  - `<asm/syscall.h>`：提供 `syscall_get_arch()`、`syscall_get_nr()` 等架构相关接口\n  - `\"common.h\"`：可能包含内核入口通用辅助函数\n- **内核子系统**：\n  - **调度器（sched）**：访问 `current` 任务结构\n  - **信号子系统（signal）**：发送 `SIGSYS` 信号\n  - **内存管理（uaccess）**：用户空间内存访问（`__get_user`, `access_ok`）\n  - **ptrace**：支持调试器配置 SUD\n  - **ELF**：可能用于架构识别（间接依赖）\n\n## 5. 使用场景\n\n- **沙箱环境**：限制应用只能在特定代码段发起系统调用，防止恶意代码绕过安全策略。\n- **动态二进制插桩（DBI）**：工具（如 Valgrind、Intel Pin）可拦截系统调用进行分析或重定向。\n- **安全监控**：监控程序可配置选择器为“阻塞”，在 `SIGSYS` 信号处理程序中记录或审查系统调用。\n- **调试与测试**：通过 `ptrace` 动态启用/禁用 SUD，用于测试系统调用拦截逻辑。\n- **W^X 策略增强**：结合代码段只读与 SUD，确保只有可信代码路径可发起系统调用。",
      "similarity": 0.5436683893203735,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 20,
          "end_line": 122,
          "content": [
            "static void trigger_sigsys(struct pt_regs *regs)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGSYS;",
            "\tinfo.si_code = SYS_USER_DISPATCH;",
            "\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_arch = syscall_get_arch(current);",
            "\tinfo.si_syscall = syscall_get_nr(current, regs);",
            "",
            "\tforce_sig_info(&info);",
            "}",
            "bool syscall_user_dispatch(struct pt_regs *regs)",
            "{",
            "\tstruct syscall_user_dispatch *sd = &current->syscall_dispatch;",
            "\tchar state;",
            "",
            "\tif (likely(instruction_pointer(regs) - sd->offset < sd->len))",
            "\t\treturn false;",
            "",
            "\tif (unlikely(arch_syscall_is_vdso_sigreturn(regs)))",
            "\t\treturn false;",
            "",
            "\tif (likely(sd->selector)) {",
            "\t\t/*",
            "\t\t * access_ok() is performed once, at prctl time, when",
            "\t\t * the selector is loaded by userspace.",
            "\t\t */",
            "\t\tif (unlikely(__get_user(state, sd->selector))) {",
            "\t\t\tforce_exit_sig(SIGSEGV);",
            "\t\t\treturn true;",
            "\t\t}",
            "",
            "\t\tif (likely(state == SYSCALL_DISPATCH_FILTER_ALLOW))",
            "\t\t\treturn false;",
            "",
            "\t\tif (state != SYSCALL_DISPATCH_FILTER_BLOCK) {",
            "\t\t\tforce_exit_sig(SIGSYS);",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\tsd->on_dispatch = true;",
            "\tsyscall_rollback(current, regs);",
            "\ttrigger_sigsys(regs);",
            "",
            "\treturn true;",
            "}",
            "static int task_set_syscall_user_dispatch(struct task_struct *task, unsigned long mode,",
            "\t\t\t\t\t  unsigned long offset, unsigned long len,",
            "\t\t\t\t\t  char __user *selector)",
            "{",
            "\tswitch (mode) {",
            "\tcase PR_SYS_DISPATCH_OFF:",
            "\t\tif (offset || len || selector)",
            "\t\t\treturn -EINVAL;",
            "\t\tbreak;",
            "\tcase PR_SYS_DISPATCH_ON:",
            "\t\t/*",
            "\t\t * Validate the direct dispatcher region just for basic",
            "\t\t * sanity against overflow and a 0-sized dispatcher",
            "\t\t * region.  If the user is able to submit a syscall from",
            "\t\t * an address, that address is obviously valid.",
            "\t\t */",
            "\t\tif (offset && offset + len <= offset)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\t/*",
            "\t\t * access_ok() will clear memory tags for tagged addresses",
            "\t\t * if current has memory tagging enabled.",
            "",
            "\t\t * To enable a tracer to set a tracees selector the",
            "\t\t * selector address must be untagged for access_ok(),",
            "\t\t * otherwise an untagged tracer will always fail to set a",
            "\t\t * tagged tracees selector.",
            "\t\t */",
            "\t\tif (selector && !access_ok(untagged_addr(selector), sizeof(*selector)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttask->syscall_dispatch.selector = selector;",
            "\ttask->syscall_dispatch.offset = offset;",
            "\ttask->syscall_dispatch.len = len;",
            "\ttask->syscall_dispatch.on_dispatch = false;",
            "",
            "\tif (mode == PR_SYS_DISPATCH_ON)",
            "\t\tset_task_syscall_work(task, SYSCALL_USER_DISPATCH);",
            "\telse",
            "\t\tclear_task_syscall_work(task, SYSCALL_USER_DISPATCH);",
            "",
            "\treturn 0;",
            "}",
            "int set_syscall_user_dispatch(unsigned long mode, unsigned long offset,",
            "\t\t\t      unsigned long len, char __user *selector)",
            "{",
            "\treturn task_set_syscall_user_dispatch(current, mode, offset, len, selector);",
            "}"
          ],
          "function_name": "trigger_sigsys, syscall_user_dispatch, task_set_syscall_user_dispatch, set_syscall_user_dispatch",
          "description": "实现系统调用用户分发核心逻辑，包含触发SIGSYS信号处理、配置验证、拦截判断及模式切换功能",
          "similarity": 0.5585282444953918
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 127,
          "end_line": 163,
          "content": [
            "int syscall_user_dispatch_get_config(struct task_struct *task, unsigned long size,",
            "\t\t\t\t     void __user *data)",
            "{",
            "\tstruct syscall_user_dispatch *sd = &task->syscall_dispatch;",
            "\tstruct ptrace_sud_config cfg;",
            "",
            "\tif (size != sizeof(cfg))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (test_task_syscall_work(task, SYSCALL_USER_DISPATCH))",
            "\t\tcfg.mode = PR_SYS_DISPATCH_ON;",
            "\telse",
            "\t\tcfg.mode = PR_SYS_DISPATCH_OFF;",
            "",
            "\tcfg.offset = sd->offset;",
            "\tcfg.len = sd->len;",
            "\tcfg.selector = (__u64)(uintptr_t)sd->selector;",
            "",
            "\tif (copy_to_user(data, &cfg, sizeof(cfg)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn 0;",
            "}",
            "int syscall_user_dispatch_set_config(struct task_struct *task, unsigned long size,",
            "\t\t\t\t     void __user *data)",
            "{",
            "\tstruct ptrace_sud_config cfg;",
            "",
            "\tif (size != sizeof(cfg))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (copy_from_user(&cfg, data, sizeof(cfg)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn task_set_syscall_user_dispatch(task, cfg.mode, cfg.offset, cfg.len,",
            "\t\t\t\t\t      (char __user *)(uintptr_t)cfg.selector);",
            "}"
          ],
          "function_name": "syscall_user_dispatch_get_config, syscall_user_dispatch_set_config",
          "description": "提供系统调用分发配置的获取与设置接口，通过用户态指针操作实现配置参数的双向传递",
          "similarity": 0.552155613899231
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2020 Collabora Ltd.",
            " */",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscall_user_dispatch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/signal.h>",
            "#include <linux/elf.h>",
            "",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task_stack.h>",
            "",
            "#include <asm/syscall.h>",
            "",
            "#include \"common.h\"",
            ""
          ],
          "function_name": null,
          "description": "包含系统调用用户分发功能所需头文件及通用定义，提供架构相关接口和内核调度必要声明",
          "similarity": 0.47991782426834106
        }
      ]
    },
    {
      "source_file": "kernel/cpu.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:55:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cpu.c`\n\n---\n\n# cpu.c 技术文档\n\n## 1. 文件概述\n\n`cpu.c` 是 Linux 内核中 CPU 热插拔（CPU Hotplug）子系统的核心实现文件，负责管理 CPU 的在线（online）与离线（offline）状态转换。该文件实现了 CPU 热插拔状态机、回调函数调用机制、多实例支持、原子状态处理以及与 SMP（对称多处理）架构的协同工作。通过定义一系列有序的状态步骤（steps），内核可以在 CPU 上下电过程中安全地执行初始化和清理操作，确保系统稳定性。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct cpuhp_cpu_state`**  \n  每个 CPU 的热插拔状态存储结构，包含当前状态、目标状态、失败状态、热插拔线程指针、同步信号量、多实例回滚信息等，用于驱动状态机执行。\n\n- **`struct cpuhp_step`**  \n  热插拔状态机的单个步骤定义，包含启动（startup）和拆除（teardown）回调函数（支持单实例或多实例模式）、步骤名称、是否可中断、是否支持多实例等属性。\n\n### 关键函数\n\n- **`cpuhp_invoke_callback()`**  \n  核心回调调用函数，根据指定 CPU、状态、方向（bringup/teardown）及节点信息，执行对应的单实例或多实例回调，并支持失败时的自动回滚。\n\n- **`cpuhp_get_step()`**  \n  根据 `cpuhp_state` 枚举值获取对应的 `cpuhp_step` 结构。\n\n- **`cpuhp_step_empty()`**  \n  判断指定方向（bringup/teardown）下某状态步骤是否为空（即无回调函数）。\n\n- **`wait_for_ap_thread()` / `complete_ap_thread()`**  \n  用于主线程与 AP（Application Processor）热插拔线程之间的同步，通过 completion 机制等待操作完成。\n\n- **`cpuhp_is_ap_state()` / `cpuhp_is_atomic_state()`**  \n  判断某状态是否属于 AP 状态或原子状态（需在 IRQ 禁用下执行且不可失败）。\n\n### 全局变量\n\n- **`cpuhp_state`**  \n  每 CPU 变量，存储各 CPU 的热插拔运行时状态。\n\n- **`cpus_booted_once_mask`**  \n  记录曾经成功启动过的 CPU 位图（仅在 CONFIG_SMP 下定义）。\n\n- **`cpuhp_hp_states[]`**  \n  全局状态步骤数组，由其他子系统注册回调填充。\n\n- **`cpuhp_state_mutex`**  \n  保护状态注册和修改的互斥锁。\n\n## 3. 关键实现\n\n### 热插拔状态机\n\nCPU 热插拔通过预定义的 `enum cpuhp_state` 枚举实现线性状态机。每个状态对应一个 `cpuhp_step`，包含 bringup 和 teardown 两个方向的回调。状态转换按序执行，确保依赖关系正确。\n\n### 多实例支持\n\n对于需要动态添加/删除多个实例的子系统（如中断域、设备驱动），`cpuhp_step` 支持 `multi_instance` 模式。实例通过 `hlist_head list` 管理，`cpuhp_invoke_callback()` 可遍历所有实例执行回调，并在失败时按逆序回滚已成功执行的实例。\n\n### 原子状态处理\n\n部分状态（如 `CPUHP_AP_IDLE_DEAD` 到 `CPUHP_AP_ONLINE`）被标记为“原子状态”，要求在 IRQ 禁用上下文中执行且**不可失败**。这些状态通常用于 CPU 核心底层初始化/销毁，失败将导致系统不稳定。\n\n### AP 线程同步\n\n在 SMP 系统中，CPU 上下电操作由专用内核线程（`cpuhp_thread`）在目标 CPU 上执行。主线程通过 `completion`（`done_up`/`done_down`）等待操作完成，确保状态转换的串行性和可见性。\n\n### 锁依赖检测（Lockdep）\n\n在 `CONFIG_LOCKDEP` 启用时，通过 `cpuhp_state_up_map` 和 `cpuhp_state_down_map` 为热插拔路径提供锁依赖分析，帮助检测潜在的死锁问题。\n\n### 回调执行与回滚\n\n`cpuhp_invoke_callback()` 在执行多实例回调时，若某实例失败：\n1. 记录失败节点（通过 `lastp`）\n2. 切换回调方向（bringup 失败则执行 teardown 回滚）\n3. 逆序执行已成功实例的回滚操作\n4. 触发 `WARN_ON_ONCE` 若回滚本身失败（因回滚必须成功）\n\n### 跟踪点（Tracepoints）\n\n集成 `trace/events/cpuhp.h`，在回调进入/退出时记录 trace 事件（如 `trace_cpuhp_enter`、`trace_cpuhp_multi_enter`），便于调试和性能分析。\n\n## 4. 依赖关系\n\n- **SMP 子系统**：依赖 `smp.h`、`smpboot.h` 实现 CPU 间通信和启动流程。\n- **调度器**：使用 `sched/mm.h`、`sched/hotplug.h`、`sched/isolation.h` 等接口管理 CPU 亲和性和隔离。\n- **内存管理**：通过 `slab.h`、`gfp.h` 分配多实例节点内存。\n- **中断子系统**：在原子状态中操作 IRQ（`irq.h`、`nmi.h`）。\n- **电源管理**：与 `suspend.h` 协同处理系统挂起时的 CPU 状态。\n- **RCU**：使用 `rcupdate.h` 确保回调注册/注销的安全性。\n- **Lockdep**：在调试配置下集成锁依赖检测。\n- **Per-CPU 机制**：依赖 `percpu-rwsem.h` 和 per-CPU 变量管理状态。\n\n## 5. 使用场景\n\n- **CPU 热插拔**：用户通过 `/sys/devices/system/cpu/cpuX/online` 接口动态启用/禁用 CPU 时，触发状态机执行 bringup/teardown 流程。\n- **系统启动/关机**：内核初始化时 bringup 所有 CPU；关机时 teardown 非引导 CPU。\n- **Suspend/Resume**：系统挂起时 offline 非引导 CPU，恢复时重新 online。\n- **内核模块注册**：驱动或子系统通过 `cpuhp_setup_state()` 等 API 注册自己的 CPU 热插拔回调，在 CPU 状态变化时执行特定操作（如重绑中断、迁移任务）。\n- **CPU 隔离**：配合 `isolcpus` 内核参数，在启动时将某些 CPU 从调度器中隔离，但仍需执行底层 bringup。\n- **错误恢复**：当某热插拔步骤失败时，自动回滚已执行的操作，维持系统一致性。",
      "similarity": 0.5427049398422241,
      "chunks": [
        {
          "chunk_id": 20,
          "file_path": "kernel/cpu.c",
          "start_line": 3127,
          "end_line": 3176,
          "content": [
            "void __init boot_cpu_init(void)",
            "{",
            "\tint cpu = smp_processor_id();",
            "",
            "\t/* Mark the boot cpu \"present\", \"online\" etc for SMP and UP case */",
            "\tset_cpu_online(cpu, true);",
            "\tset_cpu_active(cpu, true);",
            "\tset_cpu_present(cpu, true);",
            "\tset_cpu_possible(cpu, true);",
            "",
            "#ifdef CONFIG_SMP",
            "\t__boot_cpu_id = cpu;",
            "#endif",
            "}",
            "void __init boot_cpu_hotplug_init(void)",
            "{",
            "#ifdef CONFIG_SMP",
            "\tcpumask_set_cpu(smp_processor_id(), &cpus_booted_once_mask);",
            "\tatomic_set(this_cpu_ptr(&cpuhp_state.ap_sync_state), SYNC_STATE_ONLINE);",
            "#endif",
            "\tthis_cpu_write(cpuhp_state.state, CPUHP_ONLINE);",
            "\tthis_cpu_write(cpuhp_state.target, CPUHP_ONLINE);",
            "}",
            "static int __init mitigations_parse_cmdline(char *arg)",
            "{",
            "\tif (!strcmp(arg, \"off\"))",
            "\t\tcpu_mitigations = CPU_MITIGATIONS_OFF;",
            "\telse if (!strcmp(arg, \"auto\"))",
            "\t\tcpu_mitigations = CPU_MITIGATIONS_AUTO;",
            "\telse if (!strcmp(arg, \"auto,nosmt\"))",
            "\t\tcpu_mitigations = CPU_MITIGATIONS_AUTO_NOSMT;",
            "\telse",
            "\t\tpr_crit(\"Unsupported mitigations=%s, system may still be vulnerable\\n\",",
            "\t\t\targ);",
            "",
            "\treturn 0;",
            "}",
            "bool cpu_mitigations_off(void)",
            "{",
            "\treturn cpu_mitigations == CPU_MITIGATIONS_OFF;",
            "}",
            "bool cpu_mitigations_auto_nosmt(void)",
            "{",
            "\treturn cpu_mitigations == CPU_MITIGATIONS_AUTO_NOSMT;",
            "}",
            "static int __init mitigations_parse_cmdline(char *arg)",
            "{",
            "\tpr_crit(\"Kernel compiled without mitigations, ignoring 'mitigations'; system may still be vulnerable\\n\");",
            "\treturn 0;",
            "}"
          ],
          "function_name": "boot_cpu_init, boot_cpu_hotplug_init, mitigations_parse_cmdline, cpu_mitigations_off, cpu_mitigations_auto_nosmt, mitigations_parse_cmdline",
          "description": "该代码段主要负责初始化引导CPU状态及解析CPU缓解措施命令行参数。  \n`boot_cpu_init`和`boot_cpu_hotplug_init`用于标记引导CPU的在线状态及热插拔同步状态；`mitigations_parse_cmdline`解析命令行参数以配置CPU安全缓解策略（存在重复定义问题）。  \n代码中包含两个同名的`mitigations_parse_cmdline`函数，可能导致上下文不完整，需进一步验证其意图。",
          "similarity": 0.5887842178344727
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/cpu.c",
          "start_line": 1720,
          "end_line": 1824,
          "content": [
            "int cpu_device_up(struct device *dev)",
            "{",
            "\treturn cpu_up(dev->id, CPUHP_ONLINE);",
            "}",
            "int add_cpu(unsigned int cpu)",
            "{",
            "\tint ret;",
            "",
            "\tlock_device_hotplug();",
            "\tret = device_online(get_cpu_device(cpu));",
            "\tunlock_device_hotplug();",
            "",
            "\treturn ret;",
            "}",
            "int bringup_hibernate_cpu(unsigned int sleep_cpu)",
            "{",
            "\tint ret;",
            "",
            "\tif (!cpu_online(sleep_cpu)) {",
            "\t\tpr_info(\"Hibernated on a CPU that is offline! Bringing CPU up.\\n\");",
            "\t\tret = cpu_up(sleep_cpu, CPUHP_ONLINE);",
            "\t\tif (ret) {",
            "\t\t\tpr_err(\"Failed to bring hibernate-CPU up!\\n\");",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}",
            "static void __init cpuhp_bringup_mask(const struct cpumask *mask, unsigned int ncpus,",
            "\t\t\t\t      enum cpuhp_state target)",
            "{",
            "\tunsigned int cpu;",
            "",
            "\tfor_each_cpu(cpu, mask) {",
            "\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);",
            "",
            "\t\tif (cpu_up(cpu, target) && can_rollback_cpu(st)) {",
            "\t\t\t/*",
            "\t\t\t * If this failed then cpu_up() might have only",
            "\t\t\t * rolled back to CPUHP_BP_KICK_AP for the final",
            "\t\t\t * online. Clean it up. NOOP if already rolled back.",
            "\t\t\t */",
            "\t\t\tWARN_ON(cpuhp_invoke_callback_range(false, cpu, st, CPUHP_OFFLINE));",
            "\t\t}",
            "",
            "\t\tif (!--ncpus)",
            "\t\t\tbreak;",
            "\t}",
            "}",
            "static int __init parallel_bringup_parse_param(char *arg)",
            "{",
            "\treturn kstrtobool(arg, &__cpuhp_parallel_bringup);",
            "}",
            "static inline bool cpuhp_smt_aware(void)",
            "{",
            "\treturn cpu_smt_max_threads > 1;",
            "}",
            "static bool __init cpuhp_bringup_cpus_parallel(unsigned int ncpus)",
            "{",
            "\tconst struct cpumask *mask = cpu_present_mask;",
            "",
            "\tif (__cpuhp_parallel_bringup)",
            "\t\t__cpuhp_parallel_bringup = arch_cpuhp_init_parallel_bringup();",
            "\tif (!__cpuhp_parallel_bringup)",
            "\t\treturn false;",
            "",
            "\tif (cpuhp_smt_aware()) {",
            "\t\tconst struct cpumask *pmask = cpuhp_get_primary_thread_mask();",
            "\t\tstatic struct cpumask tmp_mask __initdata;",
            "",
            "\t\t/*",
            "\t\t * X86 requires to prevent that SMT siblings stopped while",
            "\t\t * the primary thread does a microcode update for various",
            "\t\t * reasons. Bring the primary threads up first.",
            "\t\t */",
            "\t\tcpumask_and(&tmp_mask, mask, pmask);",
            "\t\tcpuhp_bringup_mask(&tmp_mask, ncpus, CPUHP_BP_KICK_AP);",
            "\t\tcpuhp_bringup_mask(&tmp_mask, ncpus, CPUHP_ONLINE);",
            "\t\t/* Account for the online CPUs */",
            "\t\tncpus -= num_online_cpus();",
            "\t\tif (!ncpus)",
            "\t\t\treturn true;",
            "\t\t/* Create the mask for secondary CPUs */",
            "\t\tcpumask_andnot(&tmp_mask, mask, pmask);",
            "\t\tmask = &tmp_mask;",
            "\t}",
            "",
            "\t/* Bring the not-yet started CPUs up */",
            "\tcpuhp_bringup_mask(mask, ncpus, CPUHP_BP_KICK_AP);",
            "\tcpuhp_bringup_mask(mask, ncpus, CPUHP_ONLINE);",
            "\treturn true;",
            "}",
            "static inline bool cpuhp_bringup_cpus_parallel(unsigned int ncpus) { return false; }",
            "void __init bringup_nonboot_cpus(unsigned int setup_max_cpus)",
            "{",
            "\tif (!setup_max_cpus)",
            "\t\treturn;",
            "",
            "\t/* Try parallel bringup optimization if enabled */",
            "\tif (cpuhp_bringup_cpus_parallel(setup_max_cpus))",
            "\t\treturn;",
            "",
            "\t/* Full per CPU serialized bringup */",
            "\tcpuhp_bringup_mask(cpu_present_mask, setup_max_cpus, CPUHP_ONLINE);",
            "}"
          ],
          "function_name": "cpu_device_up, add_cpu, bringup_hibernate_cpu, cpuhp_bringup_mask, parallel_bringup_parse_param, cpuhp_smt_aware, cpuhp_bringup_cpus_parallel, cpuhp_bringup_cpus_parallel, bringup_nonboot_cpus",
          "description": "提供并行启动CPU的机制，优先启动主核心线程以避免SMT相关问题，支持动态状态预留和批量CPU上线操作",
          "similarity": 0.5827723741531372
        },
        {
          "chunk_id": 15,
          "file_path": "kernel/cpu.c",
          "start_line": 2350,
          "end_line": 2478,
          "content": [
            "static void cpuhp_rollback_install(int failedcpu, enum cpuhp_state state,",
            "\t\t\t\t   struct hlist_node *node)",
            "{",
            "\tint cpu;",
            "",
            "\t/* Roll back the already executed steps on the other cpus */",
            "\tfor_each_present_cpu(cpu) {",
            "\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);",
            "\t\tint cpustate = st->state;",
            "",
            "\t\tif (cpu >= failedcpu)",
            "\t\t\tbreak;",
            "",
            "\t\t/* Did we invoke the startup call on that cpu ? */",
            "\t\tif (cpustate >= state)",
            "\t\t\tcpuhp_issue_call(cpu, state, false, node);",
            "\t}",
            "}",
            "int __cpuhp_state_add_instance_cpuslocked(enum cpuhp_state state,",
            "\t\t\t\t\t  struct hlist_node *node,",
            "\t\t\t\t\t  bool invoke)",
            "{",
            "\tstruct cpuhp_step *sp;",
            "\tint cpu;",
            "\tint ret;",
            "",
            "\tlockdep_assert_cpus_held();",
            "",
            "\tsp = cpuhp_get_step(state);",
            "\tif (sp->multi_instance == false)",
            "\t\treturn -EINVAL;",
            "",
            "\tmutex_lock(&cpuhp_state_mutex);",
            "",
            "\tif (!invoke || !sp->startup.multi)",
            "\t\tgoto add_node;",
            "",
            "\t/*",
            "\t * Try to call the startup callback for each present cpu",
            "\t * depending on the hotplug state of the cpu.",
            "\t */",
            "\tfor_each_present_cpu(cpu) {",
            "\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);",
            "\t\tint cpustate = st->state;",
            "",
            "\t\tif (cpustate < state)",
            "\t\t\tcontinue;",
            "",
            "\t\tret = cpuhp_issue_call(cpu, state, true, node);",
            "\t\tif (ret) {",
            "\t\t\tif (sp->teardown.multi)",
            "\t\t\t\tcpuhp_rollback_install(cpu, state, node);",
            "\t\t\tgoto unlock;",
            "\t\t}",
            "\t}",
            "add_node:",
            "\tret = 0;",
            "\thlist_add_head(node, &sp->list);",
            "unlock:",
            "\tmutex_unlock(&cpuhp_state_mutex);",
            "\treturn ret;",
            "}",
            "int __cpuhp_state_add_instance(enum cpuhp_state state, struct hlist_node *node,",
            "\t\t\t       bool invoke)",
            "{",
            "\tint ret;",
            "",
            "\tcpus_read_lock();",
            "\tret = __cpuhp_state_add_instance_cpuslocked(state, node, invoke);",
            "\tcpus_read_unlock();",
            "\treturn ret;",
            "}",
            "int __cpuhp_setup_state_cpuslocked(enum cpuhp_state state,",
            "\t\t\t\t   const char *name, bool invoke,",
            "\t\t\t\t   int (*startup)(unsigned int cpu),",
            "\t\t\t\t   int (*teardown)(unsigned int cpu),",
            "\t\t\t\t   bool multi_instance)",
            "{",
            "\tint cpu, ret = 0;",
            "\tbool dynstate;",
            "",
            "\tlockdep_assert_cpus_held();",
            "",
            "\tif (cpuhp_cb_check(state) || !name)",
            "\t\treturn -EINVAL;",
            "",
            "\tmutex_lock(&cpuhp_state_mutex);",
            "",
            "\tret = cpuhp_store_callbacks(state, name, startup, teardown,",
            "\t\t\t\t    multi_instance);",
            "",
            "\tdynstate = state == CPUHP_AP_ONLINE_DYN || state == CPUHP_BP_PREPARE_DYN;",
            "\tif (ret > 0 && dynstate) {",
            "\t\tstate = ret;",
            "\t\tret = 0;",
            "\t}",
            "",
            "\tif (ret || !invoke || !startup)",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Try to call the startup callback for each present cpu",
            "\t * depending on the hotplug state of the cpu.",
            "\t */",
            "\tfor_each_present_cpu(cpu) {",
            "\t\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);",
            "\t\tint cpustate = st->state;",
            "",
            "\t\tif (cpustate < state)",
            "\t\t\tcontinue;",
            "",
            "\t\tret = cpuhp_issue_call(cpu, state, true, NULL);",
            "\t\tif (ret) {",
            "\t\t\tif (teardown)",
            "\t\t\t\tcpuhp_rollback_install(cpu, state, NULL);",
            "\t\t\tcpuhp_store_callbacks(state, NULL, NULL, NULL, false);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "out:",
            "\tmutex_unlock(&cpuhp_state_mutex);",
            "\t/*",
            "\t * If the requested state is CPUHP_AP_ONLINE_DYN or CPUHP_BP_PREPARE_DYN,",
            "\t * return the dynamically allocated state in case of success.",
            "\t */",
            "\tif (!ret && dynstate)",
            "\t\treturn state;",
            "\treturn ret;",
            "}"
          ],
          "function_name": "cpuhp_rollback_install, __cpuhp_state_add_instance_cpuslocked, __cpuhp_state_add_instance, __cpuhp_setup_state_cpuslocked",
          "description": "实现CPU热插拔状态回滚逻辑，在添加实例失败时撤销已执行步骤；__cpuhp_state_add_instance_cpuslocked用于多CPU状态下安全地添加实例并触发启动回调；__cpuhp_setup_state_cpuslocked负责注册状态回调并尝试调用启动函数",
          "similarity": 0.5714995861053467
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/cpu.c",
          "start_line": 1166,
          "end_line": 1308,
          "content": [
            "static int cpuhp_kick_ap_work(unsigned int cpu)",
            "{",
            "\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);",
            "\tenum cpuhp_state prev_state = st->state;",
            "\tint ret;",
            "",
            "\tcpuhp_lock_acquire(false);",
            "\tcpuhp_lock_release(false);",
            "",
            "\tcpuhp_lock_acquire(true);",
            "\tcpuhp_lock_release(true);",
            "",
            "\ttrace_cpuhp_enter(cpu, st->target, prev_state, cpuhp_kick_ap_work);",
            "\tret = cpuhp_kick_ap(cpu, st, st->target);",
            "\ttrace_cpuhp_exit(cpu, st->state, prev_state, ret);",
            "",
            "\treturn ret;",
            "}",
            "static __init void cpuhp_init_state(void)",
            "{",
            "\tstruct cpuhp_cpu_state *st;",
            "\tint cpu;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tst = per_cpu_ptr(&cpuhp_state, cpu);",
            "\t\tinit_completion(&st->done_up);",
            "\t\tinit_completion(&st->done_down);",
            "\t}",
            "}",
            "void __init cpuhp_threads_init(void)",
            "{",
            "\tcpuhp_init_state();",
            "\tBUG_ON(smpboot_register_percpu_thread(&cpuhp_threads));",
            "\tkthread_unpark(this_cpu_read(cpuhp_state.thread));",
            "}",
            "void clear_tasks_mm_cpumask(int cpu)",
            "{",
            "\tstruct task_struct *p;",
            "",
            "\t/*",
            "\t * This function is called after the cpu is taken down and marked",
            "\t * offline, so its not like new tasks will ever get this cpu set in",
            "\t * their mm mask. -- Peter Zijlstra",
            "\t * Thus, we may use rcu_read_lock() here, instead of grabbing",
            "\t * full-fledged tasklist_lock.",
            "\t */",
            "\tWARN_ON(cpu_online(cpu));",
            "\trcu_read_lock();",
            "\tfor_each_process(p) {",
            "\t\tstruct task_struct *t;",
            "",
            "\t\t/*",
            "\t\t * Main thread might exit, but other threads may still have",
            "\t\t * a valid mm. Find one.",
            "\t\t */",
            "\t\tt = find_lock_task_mm(p);",
            "\t\tif (!t)",
            "\t\t\tcontinue;",
            "\t\tarch_clear_mm_cpumask_cpu(cpu, t->mm);",
            "\t\ttask_unlock(t);",
            "\t}",
            "\trcu_read_unlock();",
            "}",
            "static int take_cpu_down(void *_param)",
            "{",
            "\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);",
            "\tenum cpuhp_state target = max((int)st->target, CPUHP_AP_OFFLINE);",
            "\tint err, cpu = smp_processor_id();",
            "",
            "\t/* Ensure this CPU doesn't handle any more interrupts. */",
            "\terr = __cpu_disable();",
            "\tif (err < 0)",
            "\t\treturn err;",
            "",
            "\t/*",
            "\t * Must be called from CPUHP_TEARDOWN_CPU, which means, as we are going",
            "\t * down, that the current state is CPUHP_TEARDOWN_CPU - 1.",
            "\t */",
            "\tWARN_ON(st->state != (CPUHP_TEARDOWN_CPU - 1));",
            "",
            "\t/*",
            "\t * Invoke the former CPU_DYING callbacks. DYING must not fail!",
            "\t */",
            "\tcpuhp_invoke_callback_range_nofail(false, cpu, st, target);",
            "",
            "\t/* Give up timekeeping duties */",
            "\ttick_handover_do_timer();",
            "\t/* Remove CPU from timer broadcasting */",
            "\ttick_offline_cpu(cpu);",
            "\t/* Park the stopper thread */",
            "\tstop_machine_park(cpu);",
            "\treturn 0;",
            "}",
            "static int takedown_cpu(unsigned int cpu)",
            "{",
            "\tstruct cpuhp_cpu_state *st = per_cpu_ptr(&cpuhp_state, cpu);",
            "\tint err;",
            "",
            "\t/* Park the smpboot threads */",
            "\tkthread_park(st->thread);",
            "",
            "\t/*",
            "\t * Prevent irq alloc/free while the dying cpu reorganizes the",
            "\t * interrupt affinities.",
            "\t */",
            "\tirq_lock_sparse();",
            "",
            "\t/*",
            "\t * So now all preempt/rcu users must observe !cpu_active().",
            "\t */",
            "\terr = stop_machine_cpuslocked(take_cpu_down, NULL, cpumask_of(cpu));",
            "\tif (err) {",
            "\t\t/* CPU refused to die */",
            "\t\tirq_unlock_sparse();",
            "\t\t/* Unpark the hotplug thread so we can rollback there */",
            "\t\tkthread_unpark(st->thread);",
            "\t\treturn err;",
            "\t}",
            "\tBUG_ON(cpu_online(cpu));",
            "",
            "\t/*",
            "\t * The teardown callback for CPUHP_AP_SCHED_STARTING will have removed",
            "\t * all runnable tasks from the CPU, there's only the idle task left now",
            "\t * that the migration thread is done doing the stop_machine thing.",
            "\t *",
            "\t * Wait for the stop thread to go away.",
            "\t */",
            "\twait_for_ap_thread(st, false);",
            "\tBUG_ON(st->state != CPUHP_AP_IDLE_DEAD);",
            "",
            "\t/* Interrupts are moved away from the dying cpu, reenable alloc/free */",
            "\tirq_unlock_sparse();",
            "",
            "\thotplug_cpu__broadcast_tick_pull(cpu);",
            "\t/* This actually kills the CPU. */",
            "\t__cpu_die(cpu);",
            "",
            "\tcpuhp_bp_sync_dead(cpu);",
            "",
            "\ttick_cleanup_dead_cpu(cpu);",
            "\trcutree_migrate_callbacks(cpu);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "cpuhp_kick_ap_work, cpuhp_init_state, cpuhp_threads_init, clear_tasks_mm_cpumask, take_cpu_down, takedown_cpu",
          "description": "初始化CPU热插拔状态并处理CPU下线流程，包含中断禁用、回调调用及资源清理。",
          "similarity": 0.5635439157485962
        },
        {
          "chunk_id": 14,
          "file_path": "kernel/cpu.c",
          "start_line": 2009,
          "end_line": 2112,
          "content": [
            "static int __init cpu_hotplug_pm_sync_init(void)",
            "{",
            "\t/*",
            "\t * cpu_hotplug_pm_callback has higher priority than x86",
            "\t * bsp_pm_callback which depends on cpu_hotplug_pm_callback",
            "\t * to disable cpu hotplug to avoid cpu hotplug race.",
            "\t */",
            "\tpm_notifier(cpu_hotplug_pm_callback, 0);",
            "\treturn 0;",
            "}",
            "static int cpuhp_cb_check(enum cpuhp_state state)",
            "{",
            "\tif (state <= CPUHP_OFFLINE || state >= CPUHP_ONLINE)",
            "\t\treturn -EINVAL;",
            "\treturn 0;",
            "}",
            "static int cpuhp_reserve_state(enum cpuhp_state state)",
            "{",
            "\tenum cpuhp_state i, end;",
            "\tstruct cpuhp_step *step;",
            "",
            "\tswitch (state) {",
            "\tcase CPUHP_AP_ONLINE_DYN:",
            "\t\tstep = cpuhp_hp_states + CPUHP_AP_ONLINE_DYN;",
            "\t\tend = CPUHP_AP_ONLINE_DYN_END;",
            "\t\tbreak;",
            "\tcase CPUHP_BP_PREPARE_DYN:",
            "\t\tstep = cpuhp_hp_states + CPUHP_BP_PREPARE_DYN;",
            "\t\tend = CPUHP_BP_PREPARE_DYN_END;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tfor (i = state; i <= end; i++, step++) {",
            "\t\tif (!step->name)",
            "\t\t\treturn i;",
            "\t}",
            "\tWARN(1, \"No more dynamic states available for CPU hotplug\\n\");",
            "\treturn -ENOSPC;",
            "}",
            "static int cpuhp_store_callbacks(enum cpuhp_state state, const char *name,",
            "\t\t\t\t int (*startup)(unsigned int cpu),",
            "\t\t\t\t int (*teardown)(unsigned int cpu),",
            "\t\t\t\t bool multi_instance)",
            "{",
            "\t/* (Un)Install the callbacks for further cpu hotplug operations */",
            "\tstruct cpuhp_step *sp;",
            "\tint ret = 0;",
            "",
            "\t/*",
            "\t * If name is NULL, then the state gets removed.",
            "\t *",
            "\t * CPUHP_AP_ONLINE_DYN and CPUHP_BP_PREPARE_DYN are handed out on",
            "\t * the first allocation from these dynamic ranges, so the removal",
            "\t * would trigger a new allocation and clear the wrong (already",
            "\t * empty) state, leaving the callbacks of the to be cleared state",
            "\t * dangling, which causes wreckage on the next hotplug operation.",
            "\t */",
            "\tif (name && (state == CPUHP_AP_ONLINE_DYN ||",
            "\t\t     state == CPUHP_BP_PREPARE_DYN)) {",
            "\t\tret = cpuhp_reserve_state(state);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t\tstate = ret;",
            "\t}",
            "\tsp = cpuhp_get_step(state);",
            "\tif (name && sp->name)",
            "\t\treturn -EBUSY;",
            "",
            "\tsp->startup.single = startup;",
            "\tsp->teardown.single = teardown;",
            "\tsp->name = name;",
            "\tsp->multi_instance = multi_instance;",
            "\tINIT_HLIST_HEAD(&sp->list);",
            "\treturn ret;",
            "}",
            "static int cpuhp_issue_call(int cpu, enum cpuhp_state state, bool bringup,",
            "\t\t\t    struct hlist_node *node)",
            "{",
            "\tstruct cpuhp_step *sp = cpuhp_get_step(state);",
            "\tint ret;",
            "",
            "\t/*",
            "\t * If there's nothing to do, we done.",
            "\t * Relies on the union for multi_instance.",
            "\t */",
            "\tif (cpuhp_step_empty(bringup, sp))",
            "\t\treturn 0;",
            "\t/*",
            "\t * The non AP bound callbacks can fail on bringup. On teardown",
            "\t * e.g. module removal we crash for now.",
            "\t */",
            "#ifdef CONFIG_SMP",
            "\tif (cpuhp_is_ap_state(state))",
            "\t\tret = cpuhp_invoke_ap_callback(cpu, state, bringup, node);",
            "\telse",
            "\t\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);",
            "#else",
            "\tret = cpuhp_invoke_callback(cpu, state, bringup, node, NULL);",
            "#endif",
            "\tBUG_ON(ret && !bringup);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "cpu_hotplug_pm_sync_init, cpuhp_cb_check, cpuhp_reserve_state, cpuhp_store_callbacks, cpuhp_issue_call",
          "description": "实现动态CPU热点状态的回调管理，包含状态预留检查、回调函数注册及触发机制，确保多线程环境下CPU状态变更的安全性",
          "similarity": 0.5576351881027222
        }
      ]
    }
  ]
}