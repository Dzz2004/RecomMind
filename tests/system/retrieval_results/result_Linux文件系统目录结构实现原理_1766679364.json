{
  "query": "Linux文件系统目录结构实现原理",
  "timestamp": "2025-12-26 00:16:04",
  "retrieved_files": [
    {
      "source_file": "kernel/regset.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:51:57\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `regset.c`\n\n---\n\n# regset.c 技术文档\n\n## 1. 文件概述\n\n`regset.c` 是 Linux 内核中用于管理用户态寄存器集合（user register sets）的核心辅助实现文件。该文件提供了一组通用接口，用于从目标任务（通常是进程或线程）中安全地获取寄存器状态数据，并支持将这些数据复制到用户空间。它为架构无关的 ptrace、core dump 等调试和状态导出机制提供了统一的数据访问抽象。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `__regset_get()`：内部辅助函数，执行寄存器集的实际获取逻辑，支持传入预分配缓冲区或自动分配内存。\n- `regset_get()`：公开接口，使用调用者提供的缓冲区获取寄存器数据。\n- `regset_get_alloc()`：公开接口，自动分配内存用于存储寄存器数据，并通过指针返回分配的缓冲区。\n- `copy_regset_to_user()`：将指定寄存器集的部分或全部内容安全地复制到用户空间缓冲区。\n\n### 关键数据结构（引用自 `<linux/regset.h>`）\n\n- `struct user_regset`：描述一个寄存器集合的元数据，包括寄存器数量（`n`）、每个寄存器大小（`size`）以及获取/设置回调函数（如 `regset_get`）。\n- `struct user_regset_view`：描述特定架构下所有寄存器集合的视图，包含多个 `user_regset` 实例。\n- `struct membuf`：轻量级内存缓冲区描述符，包含当前写入指针 `p` 和剩余空间 `left`，用于传递给 `regset_get` 回调。\n\n## 3. 关键实现\n\n- **内存管理策略**：  \n  `__regset_get()` 支持两种内存使用模式：\n  - 若调用者传入非空 `data` 指针，则直接使用该缓冲区；\n  - 若传入空指针，则内部调用 `kzalloc()` 分配所需内存，并在出错时自动释放。\n\n- **边界检查与截断**：  \n  函数会校验请求的 `size` 是否超过寄存器集总大小（`n * size`），若超出则自动截断，防止越界访问。\n\n- **回调机制**：  \n  实际寄存器数据的填充由 `regset->regset_get` 回调完成，该回调接收 `struct membuf` 结构，按需向缓冲区写入数据，并返回未使用的字节数（即成功写入 `size - ret` 字节）。\n\n- **用户空间安全复制**：  \n  `copy_regset_to_user()` 先通过 `regset_get_alloc()` 获取内核缓冲区，再使用 `copy_to_user()` 安全地将数据传送到用户空间，确保地址有效性并处理可能的缺页异常。\n\n- **错误处理**：  \n  所有路径均进行错误检查，包括回调不支持（`-EOPNOTSUPP`）、内存分配失败（`-ENOMEM`）、用户空间访问失败（`-EFAULT`）等，并在失败时释放已分配资源。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/export.h>`：用于导出符号供其他内核模块使用（`EXPORT_SYMBOL`）。\n  - `<linux/slab.h>`：提供 `kzalloc()` 和 `\tkfree()` 内存分配/释放接口。\n  - `<linux/regset.h>`：定义 `user_regset`、`user_regset_view`、`membuf` 等核心数据结构和函数原型。\n\n- **架构依赖**：  \n  本文件为架构无关实现，实际的寄存器读取逻辑由各架构（如 x86、ARM64）在 `user_regset` 的 `regset_get` 回调中提供。\n\n- **模块交互**：  \n  被 `ptrace` 子系统、`/proc/<pid>/mem` 接口、core dump 生成器等依赖，用于读取进程寄存器状态。\n\n## 5. 使用场景\n\n- **调试器支持**：  \n  GDB 等调试器通过 `ptrace(PTRACE_GETREGSET, ...)` 系统调用间接调用 `copy_regset_to_user()` 获取目标进程的寄存器值。\n\n- **Core Dump 生成**：  \n  进程崩溃时，内核需将寄存器上下文写入 core 文件，通过 `regset_get_alloc()` 获取寄存器数据。\n\n- **性能分析工具**：  \n  如 `perf` 或 `ftrace` 在采样时可能需要读取特定线程的寄存器状态以进行上下文分析。\n\n- **容器/虚拟化监控**：  \n  宿主机或监控程序可通过此接口安全读取客户机或容器内进程的 CPU 状态，用于状态检查或迁移。",
      "similarity": 0.6151610612869263,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/regset.c",
          "start_line": 1,
          "end_line": 5,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/regset.h>",
            ""
          ],
          "function_name": null,
          "description": "提供内核模块导出、内存分配及寄存器集合操作所需的基础头文件支持",
          "similarity": 0.554360032081604
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/regset.c",
          "start_line": 6,
          "end_line": 62,
          "content": [
            "static int __regset_get(struct task_struct *target,",
            "\t\t\tconst struct user_regset *regset,",
            "\t\t\tunsigned int size,",
            "\t\t\tvoid **data)",
            "{",
            "\tvoid *p = *data, *to_free = NULL;",
            "\tint res;",
            "",
            "\tif (!regset->regset_get)",
            "\t\treturn -EOPNOTSUPP;",
            "\tif (size > regset->n * regset->size)",
            "\t\tsize = regset->n * regset->size;",
            "\tif (!p) {",
            "\t\tto_free = p = kzalloc(size, GFP_KERNEL);",
            "\t\tif (!p)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "\tres = regset->regset_get(target, regset,",
            "\t\t\t   (struct membuf){.p = p, .left = size});",
            "\tif (res < 0) {",
            "\t\tkfree(to_free);",
            "\t\treturn res;",
            "\t}",
            "\t*data = p;",
            "\treturn size - res;",
            "}",
            "int regset_get(struct task_struct *target,",
            "\t       const struct user_regset *regset,",
            "\t       unsigned int size,",
            "\t       void *data)",
            "{",
            "\treturn __regset_get(target, regset, size, &data);",
            "}",
            "int regset_get_alloc(struct task_struct *target,",
            "\t\t     const struct user_regset *regset,",
            "\t\t     unsigned int size,",
            "\t\t     void **data)",
            "{",
            "\t*data = NULL;",
            "\treturn __regset_get(target, regset, size, data);",
            "}",
            "int copy_regset_to_user(struct task_struct *target,",
            "\t\t\tconst struct user_regset_view *view,",
            "\t\t\tunsigned int setno,",
            "\t\t\tunsigned int offset, unsigned int size,",
            "\t\t\tvoid __user *data)",
            "{",
            "\tconst struct user_regset *regset = &view->regsets[setno];",
            "\tvoid *buf;",
            "\tint ret;",
            "",
            "\tret = regset_get_alloc(target, regset, size, &buf);",
            "\tif (ret > 0)",
            "\t\tret = copy_to_user(data, buf, ret) ? -EFAULT : 0;",
            "\tkfree(buf);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__regset_get, regset_get, regset_get_alloc, copy_regset_to_user",
          "description": "实现寄存器集合数据获取与拷贝机制，包含通用获取函数、内存分配接口及用户态数据复制函数，用于架构特定寄存器集合的统一访问",
          "similarity": 0.5465215444564819
        }
      ]
    },
    {
      "source_file": "kernel/range.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:37:53\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `range.c`\n\n---\n\n# range.c 技术文档\n\n## 1. 文件概述\n\n`range.c` 是 Linux 内核中用于管理地址范围（range）集合的核心工具文件。它提供了一组操作函数，用于动态地添加、合并、删除和排序不连续的地址区间（通常表示物理内存或 I/O 地址范围）。这些操作在内存管理、资源分配、NUMA 拓扑构建等场景中被广泛使用，尤其适用于需要维护非重叠、有序地址区间的子系统。\n\n## 2. 核心功能\n\n### 数据结构\n- `struct range`：表示一个地址区间，包含 `start`（起始地址）和 `end`（结束地址，不包含）两个 `u64` 字段。\n\n### 主要函数\n- `int add_range(struct range *range, int az, int nr_range, u64 start, u64 end)`  \n  向范围数组中添加一个新的区间，不进行合并。\n- `int add_range_with_merge(struct range *range, int az, int nr_range, u64 start, u64 end)`  \n  添加新区间，并自动与已有区间合并重叠或相邻的部分。\n- `void subtract_range(struct range *range, int az, u64 start, u64 end)`  \n  从现有范围中减去指定区间，可能将一个区间拆分为两个。\n- `int clean_sort_range(struct range *range, int az)`  \n  清理数组中无效（`end == 0`）的条目，压缩有效区间到数组前端，并按起始地址排序，返回有效区间数量。\n- `void sort_range(struct range *range, int nr_range)`  \n  对指定数量的区间按起始地址进行排序。\n\n## 3. 关键实现\n\n### 区间合并逻辑（`add_range_with_merge`）\n1. 首先检查输入区间是否有效（`start < end`）。\n2. 遍历现有所有有效区间，查找与新区间有交集的部分：\n   - 若存在交集，则扩展新区间的 `start` 和 `end` 以覆盖合并后的范围。\n   - 将被合并的旧区间从数组中移除（通过 `memmove` 前移后续元素，并将末尾置零）。\n   - 由于移除了元素，需将索引 `i` 减 1 以重新检查当前位置。\n3. 最终将合并后的新区间通过 `add_range` 添加到数组末尾。\n\n### 区间相减逻辑（`subtract_range`）\n处理四种相交情况：\n1. **完全覆盖**：待减区间完全包含目标区间 → 将目标区间置为无效（`start = end = 0`）。\n2. **左覆盖**：待减区间覆盖目标区间的左部 → 将目标区间起始地址更新为 `end`。\n3. **右覆盖**：待减区间覆盖目标区间的右部 → 将目标区间结束地址更新为 `start`。\n4. **中间挖洞**：待减区间位于目标区间内部 → 将原区间拆分为两段：\n   - 原区间保留左段（`[start, subtract_start)`）。\n   - 在数组中寻找空闲槽位（`end == 0`），插入右段（`[subtract_end, original_end)`）。\n   - 若无空闲槽位，打印错误日志。\n\n### 数组清理与排序（`clean_sort_range`）\n- 采用双指针法：从前往后找无效项，从后往前找有效项，进行交换，将所有有效区间压缩到数组前端。\n- 遍历压缩后的数组，统计有效区间数量（首个 `end == 0` 的位置）。\n- 使用内核 `sort()` 函数按 `start` 升序排列有效区间。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/range.h>`：定义 `struct range`。\n  - `<linux/sort.h>`：提供 `sort()` 排序函数。\n  - `<linux/minmax.h>`：提供 `min()`/`max()` 宏。\n  - `<linux/printk.h>`：用于错误日志输出。\n  - `<linux/string.h>`：提供 `memmove()`。\n  - `<linux/init.h>`：可能用于初始化上下文（尽管本文件未直接使用初始化宏）。\n- **无外部模块依赖**：该文件为通用工具库，被多个内核子系统（如 `e820`、`memblock`、`ACPI`、`NUMA` 初始化等）直接调用。\n\n## 5. 使用场景\n\n- **物理内存布局管理**：在启动早期，通过 `e820` 或 `EFI` 获取物理内存范围后，使用 `add_range_with_merge` 合并连续内存块。\n- **内存热插拔/热移除**：动态调整可用内存范围时，使用 `subtract_range` 移除故障或离线内存区域。\n- **I/O 资源分配**：管理 PCI 或平台设备的 I/O 地址空间，避免冲突。\n- **NUMA 节点拓扑构建**：在解析 SRAT 表时，合并属于同一节点的内存范围。\n- **内核参数处理**：如 `mem=` 或 `memmap=` 参数指定的内存保留/排除区域，需与系统内存范围进行加减运算。\n- **资源冲突检测**：在设备枚举过程中，通过区间运算判断资源是否重叠。",
      "similarity": 0.6124362945556641,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/range.c",
          "start_line": 12,
          "end_line": 121,
          "content": [
            "int add_range(struct range *range, int az, int nr_range, u64 start, u64 end)",
            "{",
            "\tif (start >= end)",
            "\t\treturn nr_range;",
            "",
            "\t/* Out of slots: */",
            "\tif (nr_range >= az)",
            "\t\treturn nr_range;",
            "",
            "\trange[nr_range].start = start;",
            "\trange[nr_range].end = end;",
            "",
            "\tnr_range++;",
            "",
            "\treturn nr_range;",
            "}",
            "int add_range_with_merge(struct range *range, int az, int nr_range,",
            "\t\t     u64 start, u64 end)",
            "{",
            "\tint i;",
            "",
            "\tif (start >= end)",
            "\t\treturn nr_range;",
            "",
            "\t/* get new start/end: */",
            "\tfor (i = 0; i < nr_range; i++) {",
            "\t\tu64 common_start, common_end;",
            "",
            "\t\tif (!range[i].end)",
            "\t\t\tcontinue;",
            "",
            "\t\tcommon_start = max(range[i].start, start);",
            "\t\tcommon_end = min(range[i].end, end);",
            "\t\tif (common_start > common_end)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* new start/end, will add it back at last */",
            "\t\tstart = min(range[i].start, start);",
            "\t\tend = max(range[i].end, end);",
            "",
            "\t\tmemmove(&range[i], &range[i + 1],",
            "\t\t\t(nr_range - (i + 1)) * sizeof(range[i]));",
            "\t\trange[nr_range - 1].start = 0;",
            "\t\trange[nr_range - 1].end   = 0;",
            "\t\tnr_range--;",
            "\t\ti--;",
            "\t}",
            "",
            "\t/* Need to add it: */",
            "\treturn add_range(range, az, nr_range, start, end);",
            "}",
            "void subtract_range(struct range *range, int az, u64 start, u64 end)",
            "{",
            "\tint i, j;",
            "",
            "\tif (start >= end)",
            "\t\treturn;",
            "",
            "\tfor (j = 0; j < az; j++) {",
            "\t\tif (!range[j].end)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (start <= range[j].start && end >= range[j].end) {",
            "\t\t\trange[j].start = 0;",
            "\t\t\trange[j].end = 0;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (start <= range[j].start && end < range[j].end &&",
            "\t\t    range[j].start < end) {",
            "\t\t\trange[j].start = end;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "",
            "\t\tif (start > range[j].start && end >= range[j].end &&",
            "\t\t    range[j].end > start) {",
            "\t\t\trange[j].end = start;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (start > range[j].start && end < range[j].end) {",
            "\t\t\t/* Find the new spare: */",
            "\t\t\tfor (i = 0; i < az; i++) {",
            "\t\t\t\tif (range[i].end == 0)",
            "\t\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tif (i < az) {",
            "\t\t\t\trange[i].end = range[j].end;",
            "\t\t\t\trange[i].start = end;",
            "\t\t\t} else {",
            "\t\t\t\tpr_err(\"%s: run out of slot in ranges\\n\",",
            "\t\t\t\t\t__func__);",
            "\t\t\t}",
            "\t\t\trange[j].end = start;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t}",
            "}",
            "static int cmp_range(const void *x1, const void *x2)",
            "{",
            "\tconst struct range *r1 = x1;",
            "\tconst struct range *r2 = x2;",
            "",
            "\tif (r1->start < r2->start)",
            "\t\treturn -1;",
            "\tif (r1->start > r2->start)",
            "\t\treturn 1;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "add_range, add_range_with_merge, subtract_range, cmp_range",
          "description": "实现范围添加与合并操作，add_range将新区间追加至数组，add_range_with_merge合并重叠区间并通过memmove优化存储，subtract_range执行区间差集计算，cmp_range用于范围排序比较。",
          "similarity": 0.4543241262435913
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/range.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Range add and subtract",
            " */",
            "#include <linux/init.h>",
            "#include <linux/minmax.h>",
            "#include <linux/printk.h>",
            "#include <linux/sort.h>",
            "#include <linux/string.h>",
            "#include <linux/range.h>",
            ""
          ],
          "function_name": null,
          "description": "定义范围操作模块的头文件，包含GPL-2.0许可证声明及基础依赖项，为后续范围运算提供类型和宏定义支持。",
          "similarity": 0.4540865421295166
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/range.c",
          "start_line": 126,
          "end_line": 164,
          "content": [
            "int clean_sort_range(struct range *range, int az)",
            "{",
            "\tint i, j, k = az - 1, nr_range = az;",
            "",
            "\tfor (i = 0; i < k; i++) {",
            "\t\tif (range[i].end)",
            "\t\t\tcontinue;",
            "\t\tfor (j = k; j > i; j--) {",
            "\t\t\tif (range[j].end) {",
            "\t\t\t\tk = j;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (j == i)",
            "\t\t\tbreak;",
            "\t\trange[i].start = range[k].start;",
            "\t\trange[i].end   = range[k].end;",
            "\t\trange[k].start = 0;",
            "\t\trange[k].end   = 0;",
            "\t\tk--;",
            "\t}",
            "\t/* count it */",
            "\tfor (i = 0; i < az; i++) {",
            "\t\tif (!range[i].end) {",
            "\t\t\tnr_range = i;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\t/* sort them */",
            "\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);",
            "",
            "\treturn nr_range;",
            "}",
            "void sort_range(struct range *range, int nr_range)",
            "{",
            "\t/* sort them */",
            "\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);",
            "}"
          ],
          "function_name": "clean_sort_range, sort_range",
          "description": "clean_sort_range清理空闲范围槽位并排序有效区间，sort_range直接对有效范围数组进行排序，通过cmp_range保证区间按起始地址升序排列。",
          "similarity": 0.4265703856945038
        }
      ]
    },
    {
      "source_file": "mm/list_lru.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:35:23\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `list_lru.c`\n\n---\n\n# list_lru.c 技术文档\n\n## 1. 文件概述\n\n`list_lru.c` 实现了 Linux 内核中通用的 **List-based LRU（Least Recently Used）基础设施**，用于管理可回收对象的双向链表。该机制支持按 NUMA 节点（node）和内存控制组（memcg）进行细粒度组织，便于内存压力下的高效回收。主要服务于 slab 分配器等子系统，作为 shrinker 框架的一部分，在内存紧张时协助释放非活跃对象。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct list_lru`：顶层 LRU 管理结构，包含 per-node 的 `list_lru_node`\n- `struct list_lru_node`：每个 NUMA 节点对应的 LRU 节点，含自旋锁和总项数\n- `struct list_lru_one`：实际存储对象链表和计数的单元（per-memcg per-node）\n- `struct list_lru_memcg`：当启用 `CONFIG_MEMCG` 时，为每个 memcg 存储 per-node 的 `list_lru_one`\n\n### 主要导出函数\n- `list_lru_add()` / `list_lru_add_obj()`：向 LRU 添加对象\n- `list_lru_del()` / `list_lru_del_obj()`：从 LRU 删除对象\n- `list_lru_isolate()` / `list_lru_isolate_move()`：在回收过程中隔离对象\n- `list_lru_count_one()` / `list_lru_count_node()`：查询 LRU 中对象数量\n- `list_lru_walk_one()` / `list_lru_walk_node()`：遍历并处理 LRU 中的对象（用于 shrinker 回调）\n\n### 内部辅助函数\n- `list_lru_from_memcg_idx()`：根据 memcg ID 获取对应的 `list_lru_one`\n- `__list_lru_walk_one()`：带锁的 LRU 遍历核心逻辑\n- `list_lru_register()` / `list_lru_unregister()`：注册/注销 memcg-aware 的 LRU（用于全局追踪）\n\n## 3. 关键实现\n\n### 内存控制组（memcg）支持\n- 通过 `CONFIG_MEMCG` 条件编译控制 memcg 相关逻辑\n- 使用 XArray (`lru->xa`) 动态存储每个 memcg 对应的 `list_lru_memcg` 结构\n- 每个 memcg 在每个 NUMA 节点上拥有独立的 `list_lru_one`，实现资源隔离\n- 全局 `memcg_list_lrus` 链表和 `list_lrus_mutex` 用于跟踪所有 memcg-aware 的 LRU 实例\n\n### 并发控制\n- 每个 NUMA 节点 (`list_lru_node`) 拥有独立的自旋锁 (`nlru->lock`)\n- 所有对 LRU 链表的操作（增、删、遍历）均在对应节点锁保护下进行\n- 提供 `_irq` 版本的遍历函数（`list_lru_walk_one_irq`）用于中断上下文\n\n### 回收遍历机制\n- `list_lru_walk_*` 函数接受回调函数 `isolate`，由调用者定义回收策略\n- 回调返回值控制遍历行为：\n  - `LRU_REMOVED`：成功移除\n  - `LRU_REMOVED_RETRY`：移除后需重新开始遍历（锁曾被释放）\n  - `LRU_RETRY`：未移除但需重新开始遍历\n  - `LRU_ROTATE`：将对象移到链表尾部（标记为最近使用）\n  - `LRU_SKIP`：跳过当前对象\n  - `LRU_STOP`：立即停止遍历\n- 通过 `nr_to_walk` 限制单次遍历的最大对象数，防止长时间持锁\n\n### Shrinker 集成\n- 当向空的 `list_lru_one` 添加首个对象时，调用 `set_shrinker_bit()` 标记该 memcg/node 需要被 shrinker 处理\n- `lru_shrinker_id()` 返回关联的 shrinker ID，用于通知内存回收子系统\n\n### 对象归属识别\n- `list_lru_add_obj()` / `list_lru_del_obj()` 通过 `mem_cgroup_from_slab_obj()` 自动获取对象所属的 memcg\n- 使用 `page_to_nid(virt_to_page(item))` 确定对象所在的 NUMA 节点\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/list_lru.h>`：定义核心数据结构和 API\n  - `<linux/memcontrol.h>`：memcg 相关接口（如 `memcg_kmem_id`）\n  - `\"slab.h\"` 和 `\"internal.h\"`：slab 分配器内部接口（如 `mem_cgroup_from_slab_obj`）\n- **配置依赖**：\n  - `CONFIG_MEMCG`：决定是否编译 memcg 相关代码\n  - `CONFIG_NUMA`：影响 per-node 数据结构的大小（通过 `nr_node_ids`）\n- **子系统依赖**：\n  - Slab 分配器：作为主要使用者，管理可回收 slab 对象\n  - Memory Control Group (memcg)：提供内存隔离和记账\n  - Shrinker 框架：通过 shrinker 回调触发 LRU 遍历回收\n\n## 5. 使用场景\n\n- **Slab 对象回收**：当系统内存压力大时，shrinker 通过 `list_lru_walk_*` 遍历 inactive slab 对象链表，释放可回收对象\n- **Per-memcg 内存限制**：在 cgroup 内存超限时，仅遍历该 memcg 对应的 LRU 部分，实现精确回收\n- **NUMA 感知管理**：按 NUMA 节点分离 LRU 链表，减少远程内存访问，提升性能\n- **通用 LRU 容器**：任何需要按 LRU 策略管理可回收对象的内核子系统均可使用此基础设施（如 dentry、inode 缓存等）",
      "similarity": 0.6112316250801086,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "mm/list_lru.c",
          "start_line": 425,
          "end_line": 551,
          "content": [
            "static void memcg_reparent_list_lru(struct list_lru *lru,",
            "\t\t\t\t    int src_idx, struct mem_cgroup *dst_memcg)",
            "{",
            "\tint i;",
            "",
            "\tfor_each_node(i)",
            "\t\tmemcg_reparent_list_lru_node(lru, i, src_idx, dst_memcg);",
            "",
            "\tmemcg_list_lru_free(lru, src_idx);",
            "}",
            "void memcg_reparent_list_lrus(struct mem_cgroup *memcg, struct mem_cgroup *parent)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct list_lru *lru;",
            "\tint src_idx = memcg->kmemcg_id;",
            "",
            "\t/*",
            "\t * Change kmemcg_id of this cgroup and all its descendants to the",
            "\t * parent's id, and then move all entries from this cgroup's list_lrus",
            "\t * to ones of the parent.",
            "\t *",
            "\t * After we have finished, all list_lrus corresponding to this cgroup",
            "\t * are guaranteed to remain empty. So we can safely free this cgroup's",
            "\t * list lrus in memcg_list_lru_free().",
            "\t *",
            "\t * Changing ->kmemcg_id to the parent can prevent memcg_list_lru_alloc()",
            "\t * from allocating list lrus for this cgroup after memcg_list_lru_free()",
            "\t * call.",
            "\t */",
            "\trcu_read_lock();",
            "\tcss_for_each_descendant_pre(css, &memcg->css) {",
            "\t\tstruct mem_cgroup *child;",
            "",
            "\t\tchild = mem_cgroup_from_css(css);",
            "\t\tWRITE_ONCE(child->kmemcg_id, parent->kmemcg_id);",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\tmutex_lock(&list_lrus_mutex);",
            "\tlist_for_each_entry(lru, &memcg_list_lrus, list)",
            "\t\tmemcg_reparent_list_lru(lru, src_idx, parent);",
            "\tmutex_unlock(&list_lrus_mutex);",
            "}",
            "static inline bool memcg_list_lru_allocated(struct mem_cgroup *memcg,",
            "\t\t\t\t\t    struct list_lru *lru)",
            "{",
            "\tint idx = memcg->kmemcg_id;",
            "",
            "\treturn idx < 0 || xa_load(&lru->xa, idx);",
            "}",
            "int memcg_list_lru_alloc(struct mem_cgroup *memcg, struct list_lru *lru,",
            "\t\t\t gfp_t gfp)",
            "{",
            "\tint i;",
            "\tunsigned long flags;",
            "\tstruct list_lru_memcg_table {",
            "\t\tstruct list_lru_memcg *mlru;",
            "\t\tstruct mem_cgroup *memcg;",
            "\t} *table;",
            "\tXA_STATE(xas, &lru->xa, 0);",
            "",
            "\tif (!list_lru_memcg_aware(lru) || memcg_list_lru_allocated(memcg, lru))",
            "\t\treturn 0;",
            "",
            "\tgfp &= GFP_RECLAIM_MASK;",
            "\ttable = kmalloc_array(memcg->css.cgroup->level, sizeof(*table), gfp);",
            "\tif (!table)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/*",
            "\t * Because the list_lru can be reparented to the parent cgroup's",
            "\t * list_lru, we should make sure that this cgroup and all its",
            "\t * ancestors have allocated list_lru_memcg.",
            "\t */",
            "\tfor (i = 0; memcg; memcg = parent_mem_cgroup(memcg), i++) {",
            "\t\tif (memcg_list_lru_allocated(memcg, lru))",
            "\t\t\tbreak;",
            "",
            "\t\ttable[i].memcg = memcg;",
            "\t\ttable[i].mlru = memcg_init_list_lru_one(gfp);",
            "\t\tif (!table[i].mlru) {",
            "\t\t\twhile (i--)",
            "\t\t\t\tkfree(table[i].mlru);",
            "\t\t\tkfree(table);",
            "\t\t\treturn -ENOMEM;",
            "\t\t}",
            "\t}",
            "",
            "\txas_lock_irqsave(&xas, flags);",
            "\twhile (i--) {",
            "\t\tint index = READ_ONCE(table[i].memcg->kmemcg_id);",
            "\t\tstruct list_lru_memcg *mlru = table[i].mlru;",
            "",
            "\t\txas_set(&xas, index);",
            "retry:",
            "\t\tif (unlikely(index < 0 || xas_error(&xas) || xas_load(&xas))) {",
            "\t\t\tkfree(mlru);",
            "\t\t} else {",
            "\t\t\txas_store(&xas, mlru);",
            "\t\t\tif (xas_error(&xas) == -ENOMEM) {",
            "\t\t\t\txas_unlock_irqrestore(&xas, flags);",
            "\t\t\t\tif (xas_nomem(&xas, gfp))",
            "\t\t\t\t\txas_set_err(&xas, 0);",
            "\t\t\t\txas_lock_irqsave(&xas, flags);",
            "\t\t\t\t/*",
            "\t\t\t\t * The xas lock has been released, this memcg",
            "\t\t\t\t * can be reparented before us. So reload",
            "\t\t\t\t * memcg id. More details see the comments",
            "\t\t\t\t * in memcg_reparent_list_lrus().",
            "\t\t\t\t */",
            "\t\t\t\tindex = READ_ONCE(table[i].memcg->kmemcg_id);",
            "\t\t\t\tif (index < 0)",
            "\t\t\t\t\txas_set_err(&xas, 0);",
            "\t\t\t\telse if (!xas_error(&xas) && index != xas.xa_index)",
            "\t\t\t\t\txas_set(&xas, index);",
            "\t\t\t\tgoto retry;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t/* xas_nomem() is used to free memory instead of memory allocation. */",
            "\tif (xas.xa_alloc)",
            "\t\txas_nomem(&xas, gfp);",
            "\txas_unlock_irqrestore(&xas, flags);",
            "\tkfree(table);",
            "",
            "\treturn xas_error(&xas);",
            "}"
          ],
          "function_name": "memcg_reparent_list_lru, memcg_reparent_list_lrus, memcg_list_lru_allocated, memcg_list_lru_alloc",
          "description": "实现内存组层级间的LRU列表迁移与分配机制，包含递归子组处理、动态分配/释放LRU结构体及冲突解决逻辑。",
          "similarity": 0.5653484463691711
        },
        {
          "chunk_id": 5,
          "file_path": "mm/list_lru.c",
          "start_line": 556,
          "end_line": 605,
          "content": [
            "static inline void memcg_init_list_lru(struct list_lru *lru, bool memcg_aware)",
            "{",
            "}",
            "static void memcg_destroy_list_lru(struct list_lru *lru)",
            "{",
            "}",
            "int __list_lru_init(struct list_lru *lru, bool memcg_aware,",
            "\t\t    struct lock_class_key *key, struct shrinker *shrinker)",
            "{",
            "\tint i;",
            "",
            "#ifdef CONFIG_MEMCG",
            "\tif (shrinker)",
            "\t\tlru->shrinker_id = shrinker->id;",
            "\telse",
            "\t\tlru->shrinker_id = -1;",
            "#endif",
            "",
            "\tlru->node = kcalloc(nr_node_ids, sizeof(*lru->node), GFP_KERNEL);",
            "\tif (!lru->node)",
            "\t\treturn -ENOMEM;",
            "",
            "\tfor_each_node(i) {",
            "\t\tspin_lock_init(&lru->node[i].lock);",
            "\t\tif (key)",
            "\t\t\tlockdep_set_class(&lru->node[i].lock, key);",
            "\t\tinit_one_lru(&lru->node[i].lru);",
            "\t}",
            "",
            "\tmemcg_init_list_lru(lru, memcg_aware);",
            "\tlist_lru_register(lru);",
            "",
            "\treturn 0;",
            "}",
            "void list_lru_destroy(struct list_lru *lru)",
            "{",
            "\t/* Already destroyed or not yet initialized? */",
            "\tif (!lru->node)",
            "\t\treturn;",
            "",
            "\tlist_lru_unregister(lru);",
            "",
            "\tmemcg_destroy_list_lru(lru);",
            "\tkfree(lru->node);",
            "\tlru->node = NULL;",
            "",
            "#ifdef CONFIG_MEMCG",
            "\tlru->shrinker_id = -1;",
            "#endif",
            "}"
          ],
          "function_name": "memcg_init_list_lru, memcg_destroy_list_lru, __list_lru_init, list_lru_destroy",
          "description": "该代码段实现了基于内存控制组（MEMCG）的LRU列表管理功能。  \n`__list_lru_init` 初始化 `list_lru` 结构体并注册到系统，其中包含 MEMCG 相关的 shrinker ID 设置及节点锁初始化；`list_lru_destroy` 反向清理资源，但 `memcg_init_list_lru` 和 `memcg_destroy_list_lru` 的具体实现缺失，上下文不完整。",
          "similarity": 0.5095484256744385
        },
        {
          "chunk_id": 0,
          "file_path": "mm/list_lru.c",
          "start_line": 1,
          "end_line": 21,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2013 Red Hat, Inc. and Parallels Inc. All rights reserved.",
            " * Authors: David Chinner and Glauber Costa",
            " *",
            " * Generic LRU infrastructure",
            " */",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/memcontrol.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "",
            "#ifdef CONFIG_MEMCG",
            "static LIST_HEAD(memcg_list_lrus);",
            "static DEFINE_MUTEX(list_lrus_mutex);",
            ""
          ],
          "function_name": null,
          "description": "定义了支持内存控制组（MemCG）的LRU基础设施，声明了全局链表头memcg_list_lrus和互斥锁list_lrus_mutex，用于管理MemCG环境下的LRU列表注册与注销操作。",
          "similarity": 0.4946524202823639
        },
        {
          "chunk_id": 1,
          "file_path": "mm/list_lru.c",
          "start_line": 22,
          "end_line": 129,
          "content": [
            "static inline bool list_lru_memcg_aware(struct list_lru *lru)",
            "{",
            "\treturn lru->memcg_aware;",
            "}",
            "static void list_lru_register(struct list_lru *lru)",
            "{",
            "\tif (!list_lru_memcg_aware(lru))",
            "\t\treturn;",
            "",
            "\tmutex_lock(&list_lrus_mutex);",
            "\tlist_add(&lru->list, &memcg_list_lrus);",
            "\tmutex_unlock(&list_lrus_mutex);",
            "}",
            "static void list_lru_unregister(struct list_lru *lru)",
            "{",
            "\tif (!list_lru_memcg_aware(lru))",
            "\t\treturn;",
            "",
            "\tmutex_lock(&list_lrus_mutex);",
            "\tlist_del(&lru->list);",
            "\tmutex_unlock(&list_lrus_mutex);",
            "}",
            "static int lru_shrinker_id(struct list_lru *lru)",
            "{",
            "\treturn lru->shrinker_id;",
            "}",
            "static void list_lru_register(struct list_lru *lru)",
            "{",
            "}",
            "static void list_lru_unregister(struct list_lru *lru)",
            "{",
            "}",
            "static int lru_shrinker_id(struct list_lru *lru)",
            "{",
            "\treturn -1;",
            "}",
            "static inline bool list_lru_memcg_aware(struct list_lru *lru)",
            "{",
            "\treturn false;",
            "}",
            "bool list_lru_add(struct list_lru *lru, struct list_head *item, int nid,",
            "\t\t    struct mem_cgroup *memcg)",
            "{",
            "\tstruct list_lru_node *nlru = &lru->node[nid];",
            "\tstruct list_lru_one *l;",
            "",
            "\tspin_lock(&nlru->lock);",
            "\tif (list_empty(item)) {",
            "\t\tl = list_lru_from_memcg_idx(lru, nid, memcg_kmem_id(memcg));",
            "\t\tlist_add_tail(item, &l->list);",
            "\t\t/* Set shrinker bit if the first element was added */",
            "\t\tif (!l->nr_items++)",
            "\t\t\tset_shrinker_bit(memcg, nid, lru_shrinker_id(lru));",
            "\t\tnlru->nr_items++;",
            "\t\tspin_unlock(&nlru->lock);",
            "\t\treturn true;",
            "\t}",
            "\tspin_unlock(&nlru->lock);",
            "\treturn false;",
            "}",
            "bool list_lru_add_obj(struct list_lru *lru, struct list_head *item)",
            "{",
            "\tbool ret;",
            "\tint nid = page_to_nid(virt_to_page(item));",
            "",
            "\tif (list_lru_memcg_aware(lru)) {",
            "\t\trcu_read_lock();",
            "\t\tret = list_lru_add(lru, item, nid, mem_cgroup_from_slab_obj(item));",
            "\t\trcu_read_unlock();",
            "\t} else {",
            "\t\tret = list_lru_add(lru, item, nid, NULL);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "bool list_lru_del(struct list_lru *lru, struct list_head *item, int nid,",
            "\t\t    struct mem_cgroup *memcg)",
            "{",
            "\tstruct list_lru_node *nlru = &lru->node[nid];",
            "\tstruct list_lru_one *l;",
            "",
            "\tspin_lock(&nlru->lock);",
            "\tif (!list_empty(item)) {",
            "\t\tl = list_lru_from_memcg_idx(lru, nid, memcg_kmem_id(memcg));",
            "\t\tlist_del_init(item);",
            "\t\tl->nr_items--;",
            "\t\tnlru->nr_items--;",
            "\t\tspin_unlock(&nlru->lock);",
            "\t\treturn true;",
            "\t}",
            "\tspin_unlock(&nlru->lock);",
            "\treturn false;",
            "}",
            "bool list_lru_del_obj(struct list_lru *lru, struct list_head *item)",
            "{",
            "\tbool ret;",
            "\tint nid = page_to_nid(virt_to_page(item));",
            "",
            "\tif (list_lru_memcg_aware(lru)) {",
            "\t\trcu_read_lock();",
            "\t\tret = list_lru_del(lru, item, nid, mem_cgroup_from_slab_obj(item));",
            "\t\trcu_read_unlock();",
            "\t} else {",
            "\t\tret = list_lru_del(lru, item, nid, NULL);",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "list_lru_memcg_aware, list_lru_register, list_lru_unregister, lru_shrinker_id, list_lru_register, list_lru_unregister, lru_shrinker_id, list_lru_memcg_aware, list_lru_add, list_lru_add_obj, list_lru_del, list_lru_del_obj",
          "description": "实现了LRU列表的添加/删除操作，支持MemCG感知的节点和内存组粒度管理，包含处理多核、内存组切换及RCU安全访问的逻辑。",
          "similarity": 0.4899511933326721
        },
        {
          "chunk_id": 3,
          "file_path": "mm/list_lru.c",
          "start_line": 289,
          "end_line": 400,
          "content": [
            "unsigned long",
            "list_lru_walk_one_irq(struct list_lru *lru, int nid, struct mem_cgroup *memcg,",
            "\t\t      list_lru_walk_cb isolate, void *cb_arg,",
            "\t\t      unsigned long *nr_to_walk)",
            "{",
            "\tstruct list_lru_node *nlru = &lru->node[nid];",
            "\tunsigned long ret;",
            "",
            "\tspin_lock_irq(&nlru->lock);",
            "\tret = __list_lru_walk_one(lru, nid, memcg_kmem_id(memcg), isolate,",
            "\t\t\t\t  cb_arg, nr_to_walk);",
            "\tspin_unlock_irq(&nlru->lock);",
            "\treturn ret;",
            "}",
            "unsigned long list_lru_walk_node(struct list_lru *lru, int nid,",
            "\t\t\t\t list_lru_walk_cb isolate, void *cb_arg,",
            "\t\t\t\t unsigned long *nr_to_walk)",
            "{",
            "\tlong isolated = 0;",
            "",
            "\tisolated += list_lru_walk_one(lru, nid, NULL, isolate, cb_arg,",
            "\t\t\t\t      nr_to_walk);",
            "",
            "#ifdef CONFIG_MEMCG",
            "\tif (*nr_to_walk > 0 && list_lru_memcg_aware(lru)) {",
            "\t\tstruct list_lru_memcg *mlru;",
            "\t\tunsigned long index;",
            "",
            "\t\txa_for_each(&lru->xa, index, mlru) {",
            "\t\t\tstruct list_lru_node *nlru = &lru->node[nid];",
            "",
            "\t\t\tspin_lock(&nlru->lock);",
            "\t\t\tisolated += __list_lru_walk_one(lru, nid, index,",
            "\t\t\t\t\t\t\tisolate, cb_arg,",
            "\t\t\t\t\t\t\tnr_to_walk);",
            "\t\t\tspin_unlock(&nlru->lock);",
            "",
            "\t\t\tif (*nr_to_walk <= 0)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "#endif",
            "",
            "\treturn isolated;",
            "}",
            "static void init_one_lru(struct list_lru_one *l)",
            "{",
            "\tINIT_LIST_HEAD(&l->list);",
            "\tl->nr_items = 0;",
            "}",
            "static void memcg_list_lru_free(struct list_lru *lru, int src_idx)",
            "{",
            "\tstruct list_lru_memcg *mlru = xa_erase_irq(&lru->xa, src_idx);",
            "",
            "\t/*",
            "\t * The __list_lru_walk_one() can walk the list of this node.",
            "\t * We need kvfree_rcu() here. And the walking of the list",
            "\t * is under lru->node[nid]->lock, which can serve as a RCU",
            "\t * read-side critical section.",
            "\t */",
            "\tif (mlru)",
            "\t\tkvfree_rcu(mlru, rcu);",
            "}",
            "static inline void memcg_init_list_lru(struct list_lru *lru, bool memcg_aware)",
            "{",
            "\tif (memcg_aware)",
            "\t\txa_init_flags(&lru->xa, XA_FLAGS_LOCK_IRQ);",
            "\tlru->memcg_aware = memcg_aware;",
            "}",
            "static void memcg_destroy_list_lru(struct list_lru *lru)",
            "{",
            "\tXA_STATE(xas, &lru->xa, 0);",
            "\tstruct list_lru_memcg *mlru;",
            "",
            "\tif (!list_lru_memcg_aware(lru))",
            "\t\treturn;",
            "",
            "\txas_lock_irq(&xas);",
            "\txas_for_each(&xas, mlru, ULONG_MAX) {",
            "\t\tkfree(mlru);",
            "\t\txas_store(&xas, NULL);",
            "\t}",
            "\txas_unlock_irq(&xas);",
            "}",
            "static void memcg_reparent_list_lru_node(struct list_lru *lru, int nid,",
            "\t\t\t\t\t int src_idx, struct mem_cgroup *dst_memcg)",
            "{",
            "\tstruct list_lru_node *nlru = &lru->node[nid];",
            "\tint dst_idx = dst_memcg->kmemcg_id;",
            "\tstruct list_lru_one *src, *dst;",
            "",
            "\t/*",
            "\t * Since list_lru_{add,del} may be called under an IRQ-safe lock,",
            "\t * we have to use IRQ-safe primitives here to avoid deadlock.",
            "\t */",
            "\tspin_lock_irq(&nlru->lock);",
            "",
            "\tsrc = list_lru_from_memcg_idx(lru, nid, src_idx);",
            "\tif (!src)",
            "\t\tgoto out;",
            "\tdst = list_lru_from_memcg_idx(lru, nid, dst_idx);",
            "",
            "\tlist_splice_init(&src->list, &dst->list);",
            "",
            "\tif (src->nr_items) {",
            "\t\tdst->nr_items += src->nr_items;",
            "\t\tset_shrinker_bit(dst_memcg, nid, lru_shrinker_id(lru));",
            "\t\tsrc->nr_items = 0;",
            "\t}",
            "out:",
            "\tspin_unlock_irq(&nlru->lock);",
            "}"
          ],
          "function_name": "list_lru_walk_one_irq, list_lru_walk_node, init_one_lru, memcg_list_lru_free, memcg_init_list_lru, memcg_destroy_list_lru, memcg_reparent_list_lru_node",
          "description": "包含LRU节点初始化、内存组间列表迁移、资源释放等高级操作，涉及XA表管理、中断安全锁操作及内存组重新归属处理。",
          "similarity": 0.4677954316139221
        }
      ]
    }
  ]
}