{
  "query": "中断嵌套导致的栈溢出问题",
  "timestamp": "2025-12-26 02:12:04",
  "retrieved_files": [
    {
      "source_file": "kernel/stackleak.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:27:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `stackleak.c`\n\n---\n\n# stackleak.c 技术文档\n\n## 1. 文件概述\n\n`stackleak.c` 是 Linux 内核中实现 **STACKLEAK** 安全特性的核心源文件。该特性源自 grsecurity/PaX 项目，主要功能是在内核返回用户空间前，将当前任务已使用的内核栈区域用特定“毒值”（poison value）填充。此举可显著降低内核栈信息泄露漏洞的危害，并有效防御部分基于未初始化栈变量的攻击。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`stackleak_erase(void)`**  \n  通用接口，自动判断当前是否运行在任务栈上，并调用 `__stackleak_erase()` 执行栈擦除。\n\n- **`stackleak_erase_on_task_stack(void)`**  \n  显式指定当前运行在任务栈上，调用 `__stackleak_erase(true)`。\n\n- **`stackleak_erase_off_task_stack(void)`**  \n  显式指定当前运行在非任务栈（如入口跳板栈）上，调用 `__stackleak_erase(false)`。\n\n- **`stackleak_track_stack(void)`**  \n  跟踪当前栈指针位置，动态更新 `current->lowest_stack`，记录本次系统调用期间栈使用的最低地址（即最深位置）。\n\n- **`__stackleak_erase(bool on_task_stack)`**  \n  核心擦除逻辑：根据 `on_task_stack` 参数确定擦除范围，并调用 `__stackleak_poison()` 填充毒值。\n\n- **`__stackleak_poison(unsigned long erase_low, unsigned long erase_high, unsigned long poison)`**  \n  内联函数，从 `erase_low` 到 `erase_high` 的内存区域以 `unsigned long` 为单位写入 `STACKLEAK_POISON`。\n\n### 数据结构与变量\n\n- **`stack_erasing_bypass`**  \n  静态跳转键（`static_key`），用于在运行时动态启用/禁用栈擦除功能（仅当 `CONFIG_STACKLEAK_RUNTIME_DISABLE=y` 时存在）。\n\n- **`current->lowest_stack`**  \n  每个任务的 `task_struct` 中维护的字段，记录自上次擦除以来栈使用的最低地址。\n\n- **`current->prev_lowest_stack`**（仅当 `CONFIG_STACKLEAK_METRICS=y`）  \n  用于性能度量，保存上一次擦除的起始地址。\n\n## 3. 关键实现\n\n### 栈擦除范围确定\n- **擦除起点 (`erase_low`)**：通过 `stackleak_find_top_of_poison()` 从 `task_stack_low` 向上搜索，找到第一个非毒值地址，即上次擦除后首次使用的栈位置。\n- **擦除终点 (`erase_high`)**：\n  - 若在任务栈上执行（`on_task_stack == true`），终点为当前栈指针 `current_stack_pointer`，避免覆盖当前函数栈帧。\n  - 若在其他栈上执行（如中断/系统调用入口栈），终点为任务栈顶 `task_stack_high`，可安全擦除整个任务栈未使用区域。\n\n### 运行时动态开关\n- 当配置 `CONFIG_STACKLEAK_RUNTIME_DISABLE` 时，提供 `/proc/sys/kernel/stack_erasing` sysctl 接口。\n- 通过 `static_branch_unlikely(&stack_erasing_bypass)` 实现零开销判断：默认编译为直接跳过擦除，仅在运行时启用时才执行。\n\n### 栈使用跟踪机制\n- `stackleak_track_stack()` 在编译器插桩（由 GCC plugin 实现）调用下，定期更新 `current->lowest_stack`。\n- 要求 `CONFIG_STACKLEAK_TRACK_MIN_SIZE <= STACKLEAK_SEARCH_DEPTH`，确保毒值搜索不会越界。\n\n### 安全与性能优化\n- 所有擦除函数标记为 `noinstr`，禁止被 ftrace 等调试机制插桩，防止干扰关键路径。\n- `stackleak_track_stack()` 使用 `__no_caller_saved_registers`，避免编译器生成额外寄存器保存/恢复代码，减少开销。\n\n## 4. 依赖关系\n\n- **编译依赖**：\n  - 必须启用 `CONFIG_STACKLEAK`。\n  - 依赖 GCC plugin（`stackleak_plugin.c`）在编译时插入 `stackleak_track_stack()` 调用。\n- **头文件依赖**：\n  - `<linux/stackleak.h>`：定义 `STACKLEAK_POISON`、栈边界宏及任务结构体扩展字段。\n  - `<linux/kprobes.h>`：提供 `noinstr` 等属性定义。\n- **可选依赖**：\n  - `CONFIG_STACKLEAK_RUNTIME_DISABLE`：启用运行时开关功能。\n  - `CONFIG_SYSCTL`：提供 sysctl 控制接口。\n  - `CONFIG_STACKLEAK_METRICS`：启用栈使用深度度量。\n\n## 5. 使用场景\n\n- **系统调用返回路径**：在 `syscall_exit_to_user_mode()` 等路径中调用 `stackleak_erase()`，清理本次系统调用使用的内核栈。\n- **中断/异常返回用户空间前**：当从中断上下文返回用户态时，若使用独立栈（如 entry trampoline stack），调用 `stackleak_erase_off_task_stack()`。\n- **内核线程退出**：在切换回用户任务前擦除内核栈残留数据。\n- **安全加固场景**：部署在高安全要求环境中，防止栈信息泄露（如通过侧信道或内存泄露漏洞）暴露内核地址、敏感数据或控制流信息。",
      "similarity": 0.5992209911346436,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/stackleak.c",
          "start_line": 24,
          "end_line": 135,
          "content": [
            "static int stack_erasing_sysctl(struct ctl_table *table, int write,",
            "\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint ret = 0;",
            "\tint state = !static_branch_unlikely(&stack_erasing_bypass);",
            "\tint prev_state = state;",
            "",
            "\ttable->data = &state;",
            "\ttable->maxlen = sizeof(int);",
            "\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\tstate = !!state;",
            "\tif (ret || !write || state == prev_state)",
            "\t\treturn ret;",
            "",
            "\tif (state)",
            "\t\tstatic_branch_disable(&stack_erasing_bypass);",
            "\telse",
            "\t\tstatic_branch_enable(&stack_erasing_bypass);",
            "",
            "\tpr_warn(\"stackleak: kernel stack erasing is %s\\n\",",
            "\t\t\t\t\tstate ? \"enabled\" : \"disabled\");",
            "\treturn ret;",
            "}",
            "static int __init stackleak_sysctls_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", stackleak_sysctls);",
            "\treturn 0;",
            "}",
            "static __always_inline void __stackleak_poison(unsigned long erase_low,",
            "\t\t\t\t\t       unsigned long erase_high,",
            "\t\t\t\t\t       unsigned long poison)",
            "{",
            "\twhile (erase_low < erase_high) {",
            "\t\t*(unsigned long *)erase_low = poison;",
            "\t\terase_low += sizeof(unsigned long);",
            "\t}",
            "}",
            "static __always_inline void __stackleak_erase(bool on_task_stack)",
            "{",
            "\tconst unsigned long task_stack_low = stackleak_task_low_bound(current);",
            "\tconst unsigned long task_stack_high = stackleak_task_high_bound(current);",
            "\tunsigned long erase_low, erase_high;",
            "",
            "\terase_low = stackleak_find_top_of_poison(task_stack_low,",
            "\t\t\t\t\t\t current->lowest_stack);",
            "",
            "#ifdef CONFIG_STACKLEAK_METRICS",
            "\tcurrent->prev_lowest_stack = erase_low;",
            "#endif",
            "",
            "\t/*",
            "\t * Write poison to the task's stack between 'erase_low' and",
            "\t * 'erase_high'.",
            "\t *",
            "\t * If we're running on a different stack (e.g. an entry trampoline",
            "\t * stack) we can erase everything below the pt_regs at the top of the",
            "\t * task stack.",
            "\t *",
            "\t * If we're running on the task stack itself, we must not clobber any",
            "\t * stack used by this function and its caller. We assume that this",
            "\t * function has a fixed-size stack frame, and the current stack pointer",
            "\t * doesn't change while we write poison.",
            "\t */",
            "\tif (on_task_stack)",
            "\t\terase_high = current_stack_pointer;",
            "\telse",
            "\t\terase_high = task_stack_high;",
            "",
            "\t__stackleak_poison(erase_low, erase_high, STACKLEAK_POISON);",
            "",
            "\t/* Reset the 'lowest_stack' value for the next syscall */",
            "\tcurrent->lowest_stack = task_stack_high;",
            "}",
            "asmlinkage void noinstr stackleak_erase(void)",
            "{",
            "\tif (skip_erasing())",
            "\t\treturn;",
            "",
            "\t__stackleak_erase(on_thread_stack());",
            "}",
            "asmlinkage void noinstr stackleak_erase_on_task_stack(void)",
            "{",
            "\tif (skip_erasing())",
            "\t\treturn;",
            "",
            "\t__stackleak_erase(true);",
            "}",
            "asmlinkage void noinstr stackleak_erase_off_task_stack(void)",
            "{",
            "\tif (skip_erasing())",
            "\t\treturn;",
            "",
            "\t__stackleak_erase(false);",
            "}",
            "void __used __no_caller_saved_registers noinstr stackleak_track_stack(void)",
            "{",
            "\tunsigned long sp = current_stack_pointer;",
            "",
            "\t/*",
            "\t * Having CONFIG_STACKLEAK_TRACK_MIN_SIZE larger than",
            "\t * STACKLEAK_SEARCH_DEPTH makes the poison search in",
            "\t * stackleak_erase() unreliable. Let's prevent that.",
            "\t */",
            "\tBUILD_BUG_ON(CONFIG_STACKLEAK_TRACK_MIN_SIZE > STACKLEAK_SEARCH_DEPTH);",
            "",
            "\t/* 'lowest_stack' should be aligned on the register width boundary */",
            "\tsp = ALIGN(sp, sizeof(unsigned long));",
            "\tif (sp < current->lowest_stack &&",
            "\t    sp >= stackleak_task_low_bound(current)) {",
            "\t\tcurrent->lowest_stack = sp;",
            "\t}",
            "}"
          ],
          "function_name": "stack_erasing_sysctl, stackleak_sysctls_init, __stackleak_poison, __stackleak_erase, stackleak_erase, stackleak_erase_on_task_stack, stackleak_erase_off_task_stack, stackleak_track_stack",
          "description": "实现了栈擦除核心逻辑，包含sysctl控制接口、毒值填充函数、任务栈区域检测及擦除操作，以及栈跟踪机制的实现",
          "similarity": 0.6174389719963074
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/stackleak.c",
          "start_line": 1,
          "end_line": 23,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * This code fills the used part of the kernel stack with a poison value",
            " * before returning to userspace. It's part of the STACKLEAK feature",
            " * ported from grsecurity/PaX.",
            " *",
            " * Author: Alexander Popov <alex.popov@linux.com>",
            " *",
            " * STACKLEAK reduces the information which kernel stack leak bugs can",
            " * reveal and blocks some uninitialized stack variable attacks.",
            " */",
            "",
            "#include <linux/stackleak.h>",
            "#include <linux/kprobes.h>",
            "",
            "#ifdef CONFIG_STACKLEAK_RUNTIME_DISABLE",
            "#include <linux/jump_label.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "",
            "static DEFINE_STATIC_KEY_FALSE(stack_erasing_bypass);",
            "",
            "#ifdef CONFIG_SYSCTL"
          ],
          "function_name": null,
          "description": "定义了STACKLEAK功能的运行时禁用控制接口，通过sysctl注册动态开关栈擦除功能的控制参数",
          "similarity": 0.5751489400863647
        }
      ]
    },
    {
      "source_file": "kernel/irq/handle.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:55:29\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\handle.c`\n\n---\n\n# `irq/handle.c` 技术文档\n\n## 1. 文件概述\n\n`irq/handle.c` 是 Linux 内核通用中断子系统（Generic IRQ）的核心实现文件之一，负责中断事件的高层处理逻辑。该文件实现了中断处理流程中的关键函数，包括中断动作（`irqaction`）的调用、线程化中断的唤醒机制、未处理或异常中断的处理，以及架构无关的中断入口封装。其目标是为不同硬件架构提供统一、可扩展的中断处理框架。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`handle_bad_irq(struct irq_desc *desc)`**  \n  处理伪中断（spurious IRQ）或未注册处理函数的中断，记录统计信息并调用架构相关的 `ack_bad_irq()`。\n\n- **`no_action(int cpl, void *dev_id)`**  \n  空中断处理函数，返回 `IRQ_NONE`，常用于占位或测试。\n\n- **`__irq_wake_thread(struct irq_desc *desc, struct irqaction *action)`**  \n  唤醒与中断动作关联的内核线程（用于线程化中断），管理 `threads_oneshot` 和 `threads_active` 状态。\n\n- **`__handle_irq_event_percpu(struct irq_desc *desc)`**  \n  在当前 CPU 上遍历并执行该中断描述符关联的所有 `irqaction` 处理函数，支持 `IRQ_WAKE_THREAD` 返回值以触发线程化处理。\n\n- **`handle_irq_event_percpu(struct irq_desc *desc)`**  \n  对 `__handle_irq_event_percpu` 的封装，附加中断随机数注入（`add_interrupt_randomness`）和调试记录（`note_interrupt`）。\n\n- **`handle_irq_event(struct irq_desc *desc)`**  \n  中断事件处理的顶层入口，负责清除 `IRQS_PENDING` 状态、设置 `IRQD_IRQ_INPROGRESS` 标志，并在释放 `desc->lock` 后调用 per-CPU 处理函数，最后恢复锁和状态。\n\n- **`generic_handle_arch_irq(struct pt_regs *regs)`**（仅当 `CONFIG_GENERIC_IRQ_MULTI_HANDLER` 启用）  \n  架构无关的通用中断入口点，封装 `irq_enter()`/`irq_exit()` 和寄存器上下文切换。\n\n- **`set_handle_irq(void (*handle_irq)(struct pt_regs *))`**（仅当 `CONFIG_GENERIC_IRQ_MULTI_HANDLER` 启用）  \n  初始化架构特定的底层中断处理函数指针 `handle_arch_irq`。\n\n### 关键数据结构（引用）\n\n- `struct irq_desc`：中断描述符，包含中断状态、动作链表、锁等。\n- `struct irqaction`：中断动作，包含处理函数 `handler`、线程函数 `thread_fn`、设备 ID、标志等。\n- `handle_arch_irq`：函数指针，指向架构特定的底层中断分发函数（仅在 `CONFIG_GENERIC_IRQ_MULTI_HANDLER` 下定义）。\n\n## 3. 关键实现\n\n### 线程化中断唤醒机制\n\n当硬中断处理函数返回 `IRQ_WAKE_THREAD` 时，内核需唤醒对应的线程处理下半部。`__irq_wake_thread` 实现了以下关键逻辑：\n\n- 检查线程是否已退出（`PF_EXITING`），若是则忽略。\n- 使用原子位操作 `test_and_set_bit(IRQTF_RUNTHREAD, ...)` 避免重复唤醒。\n- 通过 `desc->threads_oneshot |= action->thread_mask` 标记需运行的线程。\n- 原子递增 `desc->threads_active`，供 `synchronize_irq()` 等同步原语使用。\n- 调用 `wake_up_process()` 唤醒内核线程。\n\n该机制通过 `IRQS_INPROGRESS` 状态和 `desc->lock` 实现硬中断上下文与中断线程之间的同步，确保 `threads_oneshot` 的读写安全。\n\n### 中断处理流程控制\n\n`handle_irq_event` 是中断流控的关键：\n\n1. 清除 `IRQS_PENDING`（表示中断已开始处理）。\n2. 设置 `IRQD_IRQ_INPROGRESS`（防止嵌套处理）。\n3. 释放 `desc->lock`，允许中断线程或其他 CPU 并发访问。\n4. 调用 `handle_irq_event_percpu` 执行实际处理。\n5. 重新获取锁，清除 `IRQD_IRQ_INPROGRESS`。\n\n此设计解耦了中断流控（如电平触发中断的 EOI）与具体处理逻辑，提高并发性。\n\n### 架构无关中断入口（`CONFIG_GENERIC_IRQ_MULTI_HANDLER`）\n\n该配置允许架构代码注册一个统一的中断入口函数 `handle_arch_irq`。`generic_handle_arch_irq` 作为通用包装器：\n\n- 调用 `irq_enter()` 进入中断上下文。\n- 使用 `set_irq_regs()` 切换当前 CPU 的中断寄存器上下文。\n- 调用注册的 `handle_arch_irq` 进行实际分发。\n- 恢复寄存器上下文并调用 `irq_exit()`。\n\n适用于不自行管理中断入口计数和上下文的架构（如 ARM64）。\n\n### 安全与调试\n\n- **中断使能检查**：在调用 `action->handler` 后，检查中断是否被意外使能（`WARN_ONCE(!irqs_disabled(), ...)`），若发现则强制禁用。\n- **伪中断处理**：`handle_bad_irq` 提供统一的异常中断处理路径，便于调试和统计。\n- **随机数注入**：通过 `add_interrupt_randomness()` 利用中断时间戳增强内核熵池。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`、`<linux/interrupt.h>`：中断核心 API 和数据结构。\n  - `<linux/kernel_stat.h>`：中断统计（`kstat_incr_irqs_this_cpu`）。\n  - `<linux/random.h>`：中断随机数注入。\n  - `<asm/irq_regs.h>`：架构相关的中断寄存器上下文管理。\n  - `\"internals.h\"`：中断子系统内部实现细节。\n  - `<trace/events/irq.h>`：中断事件跟踪点。\n\n- **模块依赖**：\n  - **Generic IRQ 子系统**：依赖 `irqdesc.c`、`irqchip.c` 等提供的 `irq_desc` 管理。\n  - **调度器**：`wake_up_process()` 依赖进程调度。\n  - **RCU 与同步原语**：`synchronize_irq()` 依赖 `threads_active` 计数。\n  - **架构代码**：`ack_bad_irq()`、`handle_arch_irq` 由具体架构实现。\n\n## 5. 使用场景\n\n- **设备驱动注册中断处理函数**：驱动通过 `request_irq()` 注册 `irqaction`，中断触发时由 `handle_irq_event_percpu` 调用其 `handler`。\n- **线程化中断处理**：驱动设置 `IRQF_ONESHOT` 并提供 `thread_fn`，硬中断返回 `IRQ_WAKE_THREAD` 后由 `__irq_wake_thread` 唤醒线程。\n- **伪中断或未处理中断**：硬件误触发或未注册处理函数的中断由 `handle_bad_irq` 统一处理。\n- **架构中断入口**：在 `CONFIG_GENERIC_IRQ_MULTI_HANDLER` 架构（如 ARM64）中，异常向量表直接跳转至 `generic_handle_arch_irq`。\n- **中断同步**：`synchronize_irq()` 等函数依赖 `threads_active` 计数等待线程化中断完成。\n- **内核调试与监控**：通过 `note_interrupt()` 记录异常中断，通过 ftrace 的 `irq_handler_entry/exit` 跟踪点监控中断处理性能。",
      "similarity": 0.5876051783561707,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/handle.c",
          "start_line": 189,
          "end_line": 232,
          "content": [
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc)",
            "{",
            "\tirqreturn_t retval;",
            "",
            "\tretval = __handle_irq_event_percpu(desc);",
            "",
            "\tadd_interrupt_randomness(desc->irq_data.irq);",
            "",
            "\tif (!irq_settings_no_debug(desc))",
            "\t\tnote_interrupt(desc, retval);",
            "\treturn retval;",
            "}",
            "irqreturn_t handle_irq_event(struct irq_desc *desc)",
            "{",
            "\tirqreturn_t ret;",
            "",
            "\tdesc->istate &= ~IRQS_PENDING;",
            "\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);",
            "\traw_spin_unlock(&desc->lock);",
            "",
            "\tret = handle_irq_event_percpu(desc);",
            "",
            "\traw_spin_lock(&desc->lock);",
            "\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);",
            "\treturn ret;",
            "}",
            "int __init set_handle_irq(void (*handle_irq)(struct pt_regs *))",
            "{",
            "\tif (handle_arch_irq)",
            "\t\treturn -EBUSY;",
            "",
            "\thandle_arch_irq = handle_irq;",
            "\treturn 0;",
            "}",
            "asmlinkage void noinstr generic_handle_arch_irq(struct pt_regs *regs)",
            "{",
            "\tstruct pt_regs *old_regs;",
            "",
            "\tirq_enter();",
            "\told_regs = set_irq_regs(regs);",
            "\thandle_arch_irq(regs);",
            "\tset_irq_regs(old_regs);",
            "\tirq_exit();",
            "}"
          ],
          "function_name": "handle_irq_event_percpu, handle_irq_event, set_handle_irq, generic_handle_arch_irq",
          "description": "提供中断事件处理接口，包含通用架构中断入口点generic_handle_arch_irq，管理中断处理流程并集成随机化干扰注入功能",
          "similarity": 0.6143079400062561
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/handle.c",
          "start_line": 33,
          "end_line": 178,
          "content": [
            "void handle_bad_irq(struct irq_desc *desc)",
            "{",
            "\tunsigned int irq = irq_desc_get_irq(desc);",
            "",
            "\tprint_irq_desc(irq, desc);",
            "\tkstat_incr_irqs_this_cpu(desc);",
            "\tack_bad_irq(irq);",
            "}",
            "irqreturn_t no_action(int cpl, void *dev_id)",
            "{",
            "\treturn IRQ_NONE;",
            "}",
            "static void warn_no_thread(unsigned int irq, struct irqaction *action)",
            "{",
            "\tif (test_and_set_bit(IRQTF_WARNED, &action->thread_flags))",
            "\t\treturn;",
            "",
            "\tprintk(KERN_WARNING \"IRQ %d device %s returned IRQ_WAKE_THREAD \"",
            "\t       \"but no thread function available.\", irq, action->name);",
            "}",
            "void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action)",
            "{",
            "\t/*",
            "\t * In case the thread crashed and was killed we just pretend that",
            "\t * we handled the interrupt. The hardirq handler has disabled the",
            "\t * device interrupt, so no irq storm is lurking.",
            "\t */",
            "\tif (action->thread->flags & PF_EXITING)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Wake up the handler thread for this action. If the",
            "\t * RUNTHREAD bit is already set, nothing to do.",
            "\t */",
            "\tif (test_and_set_bit(IRQTF_RUNTHREAD, &action->thread_flags))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * It's safe to OR the mask lockless here. We have only two",
            "\t * places which write to threads_oneshot: This code and the",
            "\t * irq thread.",
            "\t *",
            "\t * This code is the hard irq context and can never run on two",
            "\t * cpus in parallel. If it ever does we have more serious",
            "\t * problems than this bitmask.",
            "\t *",
            "\t * The irq threads of this irq which clear their \"running\" bit",
            "\t * in threads_oneshot are serialized via desc->lock against",
            "\t * each other and they are serialized against this code by",
            "\t * IRQS_INPROGRESS.",
            "\t *",
            "\t * Hard irq handler:",
            "\t *",
            "\t *\tspin_lock(desc->lock);",
            "\t *\tdesc->state |= IRQS_INPROGRESS;",
            "\t *\tspin_unlock(desc->lock);",
            "\t *\tset_bit(IRQTF_RUNTHREAD, &action->thread_flags);",
            "\t *\tdesc->threads_oneshot |= mask;",
            "\t *\tspin_lock(desc->lock);",
            "\t *\tdesc->state &= ~IRQS_INPROGRESS;",
            "\t *\tspin_unlock(desc->lock);",
            "\t *",
            "\t * irq thread:",
            "\t *",
            "\t * again:",
            "\t *\tspin_lock(desc->lock);",
            "\t *\tif (desc->state & IRQS_INPROGRESS) {",
            "\t *\t\tspin_unlock(desc->lock);",
            "\t *\t\twhile(desc->state & IRQS_INPROGRESS)",
            "\t *\t\t\tcpu_relax();",
            "\t *\t\tgoto again;",
            "\t *\t}",
            "\t *\tif (!test_bit(IRQTF_RUNTHREAD, &action->thread_flags))",
            "\t *\t\tdesc->threads_oneshot &= ~mask;",
            "\t *\tspin_unlock(desc->lock);",
            "\t *",
            "\t * So either the thread waits for us to clear IRQS_INPROGRESS",
            "\t * or we are waiting in the flow handler for desc->lock to be",
            "\t * released before we reach this point. The thread also checks",
            "\t * IRQTF_RUNTHREAD under desc->lock. If set it leaves",
            "\t * threads_oneshot untouched and runs the thread another time.",
            "\t */",
            "\tdesc->threads_oneshot |= action->thread_mask;",
            "",
            "\t/*",
            "\t * We increment the threads_active counter in case we wake up",
            "\t * the irq thread. The irq thread decrements the counter when",
            "\t * it returns from the handler or in the exit path and wakes",
            "\t * up waiters which are stuck in synchronize_irq() when the",
            "\t * active count becomes zero. synchronize_irq() is serialized",
            "\t * against this code (hard irq handler) via IRQS_INPROGRESS",
            "\t * like the finalize_oneshot() code. See comment above.",
            "\t */",
            "\tatomic_inc(&desc->threads_active);",
            "",
            "\twake_up_process(action->thread);",
            "}",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc)",
            "{",
            "\tirqreturn_t retval = IRQ_NONE;",
            "\tunsigned int irq = desc->irq_data.irq;",
            "\tstruct irqaction *action;",
            "",
            "\trecord_irq_time(desc);",
            "",
            "\tfor_each_action_of_desc(desc, action) {",
            "\t\tirqreturn_t res;",
            "",
            "\t\t/*",
            "\t\t * If this IRQ would be threaded under force_irqthreads, mark it so.",
            "\t\t */",
            "\t\tif (irq_settings_can_thread(desc) &&",
            "\t\t    !(action->flags & (IRQF_NO_THREAD | IRQF_PERCPU | IRQF_ONESHOT)))",
            "\t\t\tlockdep_hardirq_threaded();",
            "",
            "\t\ttrace_irq_handler_entry(irq, action);",
            "\t\tres = action->handler(irq, action->dev_id);",
            "\t\ttrace_irq_handler_exit(irq, action, res);",
            "",
            "\t\tif (WARN_ONCE(!irqs_disabled(),\"irq %u handler %pS enabled interrupts\\n\",",
            "\t\t\t      irq, action->handler))",
            "\t\t\tlocal_irq_disable();",
            "",
            "\t\tswitch (res) {",
            "\t\tcase IRQ_WAKE_THREAD:",
            "\t\t\t/*",
            "\t\t\t * Catch drivers which return WAKE_THREAD but",
            "\t\t\t * did not set up a thread function",
            "\t\t\t */",
            "\t\t\tif (unlikely(!action->thread_fn)) {",
            "\t\t\t\twarn_no_thread(irq, action);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t\t__irq_wake_thread(desc, action);",
            "\t\t\tbreak;",
            "",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tretval |= res;",
            "\t}",
            "",
            "\treturn retval;",
            "}"
          ],
          "function_name": "handle_bad_irq, no_action, warn_no_thread, __irq_wake_thread, __handle_irq_event_percpu",
          "description": "实现中断处理核心逻辑，包括错误中断处理、唤醒线程函数、事件分发及中断处理结果收集，包含中断线程唤醒与状态同步机制",
          "similarity": 0.5773694515228271
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/handle.c",
          "start_line": 1,
          "end_line": 32,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992, 1998-2006 Linus Torvalds, Ingo Molnar",
            " * Copyright (C) 2005-2006, Thomas Gleixner, Russell King",
            " *",
            " * This file contains the core interrupt handling code. Detailed",
            " * information is available in Documentation/core-api/genericirq.rst",
            " *",
            " */",
            "",
            "#include <linux/irq.h>",
            "#include <linux/random.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "",
            "#include <asm/irq_regs.h>",
            "",
            "#include <trace/events/irq.h>",
            "",
            "#include \"internals.h\"",
            "",
            "#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER",
            "void (*handle_arch_irq)(struct pt_regs *) __ro_after_init;",
            "#endif",
            "",
            "/**",
            " * handle_bad_irq - handle spurious and unhandled irqs",
            " * @desc:      description of the interrupt",
            " *",
            " * Handles spurious and unhandled IRQ's. It also prints a debugmessage.",
            " */"
          ],
          "function_name": null,
          "description": "定义了处理异常中断的函数handle_bad_irq，用于处理未处理或误触发的中断，打印调试信息并更新中断统计",
          "similarity": 0.5457262992858887
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_stack.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:37:38\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_stack.c`\n\n---\n\n# `trace/trace_stack.c` 技术文档\n\n## 1. 文件概述\n\n`trace/trace_stack.c` 实现了 Linux 内核中的**栈追踪器**（stack tracer）功能，用于动态监控并记录内核执行路径中**最大栈使用深度**。该功能基于 ftrace 框架，在每次函数调用时检查当前栈使用量，若超过历史最大值，则保存完整的调用栈信息，包括每个函数帧的大小和位置。主要用于调试栈溢出风险、分析内核栈使用模式，对系统稳定性与安全性具有重要意义。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `stack_dump_trace[]`：存储最大栈深度时的返回地址（函数指针），最多 `STACK_TRACE_ENTRIES`（500）项。\n- `stack_trace_index[]`：对应每个返回地址在栈中的偏移量（从栈顶开始计算的字节数）。\n- `stack_trace_nr_entries`：当前记录的有效栈帧数量。\n- `stack_trace_max_size`：历史记录的最大栈使用字节数。\n- `stack_trace_max_lock`：保护最大栈数据的自旋锁（`arch_spinlock_t`）。\n- `disable_stack_tracer`（per-CPU）：用于临时禁用当前 CPU 上的栈追踪。\n- `stack_tracer_enabled`：全局开关，控制栈追踪器是否启用。\n- `stack_sysctl_mutex`：保护 sysctl 接口的互斥锁。\n\n### 主要函数\n- `print_max_stack()`：以人类可读格式打印当前记录的最大栈使用情况，包括深度、各帧大小及函数符号。\n- `check_stack(unsigned long ip, unsigned long *stack)`：核心回调函数，由 ftrace 触发，用于检测并更新最大栈使用记录。\n\n## 3. 关键实现\n\n### 栈大小计算\n- 通过传入的局部变量地址 `stack` 计算当前栈使用量：  \n  `this_size = THREAD_SIZE - ((unsigned long)stack & (THREAD_SIZE - 1))`\n- 减去追踪器自身帧开销（`tracer_frame`），避免污染测量结果。\n\n### 最大栈更新逻辑\n1. 若当前栈使用量 ≤ 已记录最大值，直接返回。\n2. 若栈不在当前任务栈空间（如中断栈），则跳过（暂不支持）。\n3. 禁用本地中断并获取自旋锁，确保更新原子性。\n4. 调用 `stack_trace_save()` 获取当前调用栈的返回地址列表。\n5. **跳过追踪器自身帧**：在栈回溯结果中查找触发回调的指令指针 `ip`，忽略其之上的帧。\n6. **地址到栈偏移映射**：\n   - 从栈底向栈顶扫描，匹配返回地址。\n   - 记录每个匹配地址距离栈顶的偏移（字节数）到 `stack_trace_index[]`。\n   - 使用 `READ_ONCE_NOCHECK` 避免 KASAN 误报栈越界。\n\n### 架构适配说明\n- 文档注释详细解释了不同 CPU 架构（如 x86 与 ARM）在栈帧布局上的差异：\n  - **x86 风格**：返回地址位于局部变量**之前**，偏移直接对应函数帧起始。\n  - **ARM 风格**（`ARCH_RET_ADDR_AFTER_LOCAL_VARS`）：返回地址（LR）保存在局部变量**之后**，需调整偏移计算逻辑（代码中通过条件编译处理，但当前片段未展示完整实现）。\n\n## 4. 依赖关系\n\n- **ftrace 框架**：通过 `ftrace` 注册回调函数 `check_stack`，在每次函数入口触发。\n- **栈回溯接口**：依赖 `stack_trace_save()`（来自 `<linux/stacktrace.h>`）获取调用栈。\n- **内核符号解析**：使用 `kallsyms`（`%pS` 格式化）将地址转换为函数名。\n- **内存与任务管理**：依赖 `task_stack.h` 判断栈边界（`object_is_on_stack`）。\n- **同步原语**：使用 `arch_spinlock_t` 和 `mutex` 保证多核/多线程安全。\n- **安全模块**：包含 `<linux/security.h>`，可能用于权限检查（如 sysctl 访问控制）。\n\n## 5. 使用场景\n\n- **内核调试**：通过 `/sys/kernel/debug/tracing/stack_max_size` 和 `/sys/kernel/debug/tracing/stack_trace` 接口查看最大栈使用情况，定位潜在栈溢出风险。\n- **性能分析**：评估内核路径的栈消耗，优化深层调用链。\n- **安全审计**：监控异常栈增长，辅助检测栈溢出类漏洞。\n- **系统稳定性保障**：在开发和测试阶段启用，确保关键路径不会超出 `THREAD_SIZE`（通常 8KB 或 16KB）限制。\n- **架构验证**：验证不同 CPU 架构下栈布局假设的正确性。",
      "similarity": 0.5856834650039673,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_stack.c",
          "start_line": 291,
          "end_line": 416,
          "content": [
            "static void",
            "stack_trace_call(unsigned long ip, unsigned long parent_ip,",
            "\t\t struct ftrace_ops *op, struct ftrace_regs *fregs)",
            "{",
            "\tunsigned long stack;",
            "",
            "\tpreempt_disable_notrace();",
            "",
            "\t/* no atomic needed, we only modify this variable by this cpu */",
            "\t__this_cpu_inc(disable_stack_tracer);",
            "\tif (__this_cpu_read(disable_stack_tracer) != 1)",
            "\t\tgoto out;",
            "",
            "\t/* If rcu is not watching, then save stack trace can fail */",
            "\tif (!rcu_is_watching())",
            "\t\tgoto out;",
            "",
            "\tip += MCOUNT_INSN_SIZE;",
            "",
            "\tcheck_stack(ip, &stack);",
            "",
            " out:",
            "\t__this_cpu_dec(disable_stack_tracer);",
            "\t/* prevent recursion in schedule */",
            "\tpreempt_enable_notrace();",
            "}",
            "static ssize_t",
            "stack_max_size_read(struct file *filp, char __user *ubuf,",
            "\t\t    size_t count, loff_t *ppos)",
            "{",
            "\tunsigned long *ptr = filp->private_data;",
            "\tchar buf[64];",
            "\tint r;",
            "",
            "\tr = snprintf(buf, sizeof(buf), \"%ld\\n\", *ptr);",
            "\tif (r > sizeof(buf))",
            "\t\tr = sizeof(buf);",
            "\treturn simple_read_from_buffer(ubuf, count, ppos, buf, r);",
            "}",
            "static ssize_t",
            "stack_max_size_write(struct file *filp, const char __user *ubuf,",
            "\t\t     size_t count, loff_t *ppos)",
            "{",
            "\tlong *ptr = filp->private_data;",
            "\tunsigned long val, flags;",
            "\tint ret;",
            "",
            "\tret = kstrtoul_from_user(ubuf, count, 10, &val);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tlocal_irq_save(flags);",
            "",
            "\t/*",
            "\t * In case we trace inside arch_spin_lock() or after (NMI),",
            "\t * we will cause circular lock, so we also need to increase",
            "\t * the percpu disable_stack_tracer here.",
            "\t */",
            "\t__this_cpu_inc(disable_stack_tracer);",
            "",
            "\tarch_spin_lock(&stack_trace_max_lock);",
            "\t*ptr = val;",
            "\tarch_spin_unlock(&stack_trace_max_lock);",
            "",
            "\t__this_cpu_dec(disable_stack_tracer);",
            "\tlocal_irq_restore(flags);",
            "",
            "\treturn count;",
            "}",
            "static void t_stop(struct seq_file *m, void *p)",
            "{",
            "\tarch_spin_unlock(&stack_trace_max_lock);",
            "",
            "\t__this_cpu_dec(disable_stack_tracer);",
            "",
            "\tlocal_irq_enable();",
            "}",
            "static void trace_lookup_stack(struct seq_file *m, long i)",
            "{",
            "\tunsigned long addr = stack_dump_trace[i];",
            "",
            "\tseq_printf(m, \"%pS\\n\", (void *)addr);",
            "}",
            "static void print_disabled(struct seq_file *m)",
            "{",
            "\tseq_puts(m, \"#\\n\"",
            "\t\t \"#  Stack tracer disabled\\n\"",
            "\t\t \"#\\n\"",
            "\t\t \"# To enable the stack tracer, either add 'stacktrace' to the\\n\"",
            "\t\t \"# kernel command line\\n\"",
            "\t\t \"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\\n\"",
            "\t\t \"#\\n\");",
            "}",
            "static int t_show(struct seq_file *m, void *v)",
            "{",
            "\tlong i;",
            "\tint size;",
            "",
            "\tif (v == SEQ_START_TOKEN) {",
            "\t\tseq_printf(m, \"        Depth    Size   Location\"",
            "\t\t\t   \"    (%d entries)\\n\"",
            "\t\t\t   \"        -----    ----   --------\\n\",",
            "\t\t\t   stack_trace_nr_entries);",
            "",
            "\t\tif (!stack_tracer_enabled && !stack_trace_max_size)",
            "\t\t\tprint_disabled(m);",
            "",
            "\t\treturn 0;",
            "\t}",
            "",
            "\ti = *(long *)v;",
            "",
            "\tif (i >= stack_trace_nr_entries)",
            "\t\treturn 0;",
            "",
            "\tif (i + 1 == stack_trace_nr_entries)",
            "\t\tsize = stack_trace_index[i];",
            "\telse",
            "\t\tsize = stack_trace_index[i] - stack_trace_index[i+1];",
            "",
            "\tseq_printf(m, \"%3ld) %8d   %5d   \", i, stack_trace_index[i], size);",
            "",
            "\ttrace_lookup_stack(m, i);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "stack_trace_call, stack_max_size_read, stack_max_size_write, t_stop, trace_lookup_stack, print_disabled, t_show",
          "description": "提供堆栈跟踪的调试接口，包括读写最大堆栈大小的系统调用、序列化输出堆栈信息的函数以及禁用状态提示逻辑，支持动态调整跟踪行为。",
          "similarity": 0.5869610905647278
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_stack.c",
          "start_line": 37,
          "end_line": 185,
          "content": [
            "static void print_max_stack(void)",
            "{",
            "\tlong i;",
            "\tint size;",
            "",
            "\tpr_emerg(\"        Depth    Size   Location    (%d entries)\\n\"",
            "\t\t\t   \"        -----    ----   --------\\n\",",
            "\t\t\t   stack_trace_nr_entries);",
            "",
            "\tfor (i = 0; i < stack_trace_nr_entries; i++) {",
            "\t\tif (i + 1 == stack_trace_nr_entries)",
            "\t\t\tsize = stack_trace_index[i];",
            "\t\telse",
            "\t\t\tsize = stack_trace_index[i] - stack_trace_index[i+1];",
            "",
            "\t\tpr_emerg(\"%3ld) %8d   %5d   %pS\\n\", i, stack_trace_index[i],",
            "\t\t\t\tsize, (void *)stack_dump_trace[i]);",
            "\t}",
            "}",
            "static void check_stack(unsigned long ip, unsigned long *stack)",
            "{",
            "\tunsigned long this_size, flags; unsigned long *p, *top, *start;",
            "\tstatic int tracer_frame;",
            "\tint frame_size = READ_ONCE(tracer_frame);",
            "\tint i, x;",
            "",
            "\tthis_size = ((unsigned long)stack) & (THREAD_SIZE-1);",
            "\tthis_size = THREAD_SIZE - this_size;",
            "\t/* Remove the frame of the tracer */",
            "\tthis_size -= frame_size;",
            "",
            "\tif (this_size <= stack_trace_max_size)",
            "\t\treturn;",
            "",
            "\t/* we do not handle interrupt stacks yet */",
            "\tif (!object_is_on_stack(stack))",
            "\t\treturn;",
            "",
            "\t/* Can't do this from NMI context (can cause deadlocks) */",
            "\tif (in_nmi())",
            "\t\treturn;",
            "",
            "\tlocal_irq_save(flags);",
            "\tarch_spin_lock(&stack_trace_max_lock);",
            "",
            "\t/* In case another CPU set the tracer_frame on us */",
            "\tif (unlikely(!frame_size))",
            "\t\tthis_size -= tracer_frame;",
            "",
            "\t/* a race could have already updated it */",
            "\tif (this_size <= stack_trace_max_size)",
            "\t\tgoto out;",
            "",
            "\tstack_trace_max_size = this_size;",
            "",
            "\tstack_trace_nr_entries = stack_trace_save(stack_dump_trace,",
            "\t\t\t\t\t       ARRAY_SIZE(stack_dump_trace) - 1,",
            "\t\t\t\t\t       0);",
            "",
            "\t/* Skip over the overhead of the stack tracer itself */",
            "\tfor (i = 0; i < stack_trace_nr_entries; i++) {",
            "\t\tif (stack_dump_trace[i] == ip)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\t/*",
            "\t * Some archs may not have the passed in ip in the dump.",
            "\t * If that happens, we need to show everything.",
            "\t */",
            "\tif (i == stack_trace_nr_entries)",
            "\t\ti = 0;",
            "",
            "\t/*",
            "\t * Now find where in the stack these are.",
            "\t */",
            "\tx = 0;",
            "\tstart = stack;",
            "\ttop = (unsigned long *)",
            "\t\t(((unsigned long)start & ~(THREAD_SIZE-1)) + THREAD_SIZE);",
            "",
            "\t/*",
            "\t * Loop through all the entries. One of the entries may",
            "\t * for some reason be missed on the stack, so we may",
            "\t * have to account for them. If they are all there, this",
            "\t * loop will only happen once. This code only takes place",
            "\t * on a new max, so it is far from a fast path.",
            "\t */",
            "\twhile (i < stack_trace_nr_entries) {",
            "\t\tint found = 0;",
            "",
            "\t\tstack_trace_index[x] = this_size;",
            "\t\tp = start;",
            "",
            "\t\tfor (; p < top && i < stack_trace_nr_entries; p++) {",
            "\t\t\t/*",
            "\t\t\t * The READ_ONCE_NOCHECK is used to let KASAN know that",
            "\t\t\t * this is not a stack-out-of-bounds error.",
            "\t\t\t */",
            "\t\t\tif ((READ_ONCE_NOCHECK(*p)) == stack_dump_trace[i]) {",
            "\t\t\t\tstack_dump_trace[x] = stack_dump_trace[i++];",
            "\t\t\t\tthis_size = stack_trace_index[x++] =",
            "\t\t\t\t\t(top - p) * sizeof(unsigned long);",
            "\t\t\t\tfound = 1;",
            "\t\t\t\t/* Start the search from here */",
            "\t\t\t\tstart = p + 1;",
            "\t\t\t\t/*",
            "\t\t\t\t * We do not want to show the overhead",
            "\t\t\t\t * of the stack tracer stack in the",
            "\t\t\t\t * max stack. If we haven't figured",
            "\t\t\t\t * out what that is, then figure it out",
            "\t\t\t\t * now.",
            "\t\t\t\t */",
            "\t\t\t\tif (unlikely(!tracer_frame)) {",
            "\t\t\t\t\ttracer_frame = (p - stack) *",
            "\t\t\t\t\t\tsizeof(unsigned long);",
            "\t\t\t\t\tstack_trace_max_size -= tracer_frame;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tif (!found)",
            "\t\t\ti++;",
            "\t}",
            "",
            "#ifdef ARCH_FTRACE_SHIFT_STACK_TRACER",
            "\t/*",
            "\t * Some archs will store the link register before calling",
            "\t * nested functions. This means the saved return address",
            "\t * comes after the local storage, and we need to shift",
            "\t * for that.",
            "\t */",
            "\tif (x > 1) {",
            "\t\tmemmove(&stack_trace_index[0], &stack_trace_index[1],",
            "\t\t\tsizeof(stack_trace_index[0]) * (x - 1));",
            "\t\tx--;",
            "\t}",
            "#endif",
            "",
            "\tstack_trace_nr_entries = x;",
            "",
            "\tif (task_stack_end_corrupted(current)) {",
            "\t\tprint_max_stack();",
            "\t\tBUG();",
            "\t}",
            "",
            " out:",
            "\tarch_spin_unlock(&stack_trace_max_lock);",
            "\tlocal_irq_restore(flags);",
            "}"
          ],
          "function_name": "print_max_stack, check_stack",
          "description": "check_stack函数用于检测当前堆栈深度是否超出限制，若超出则更新最大堆栈大小并保存堆栈信息；print_max_stack函数用于将堆栈跟踪结果格式化输出至日志。",
          "similarity": 0.5188602209091187
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_stack.c",
          "start_line": 1,
          "end_line": 36,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2008 Steven Rostedt <srostedt@redhat.com>",
            " *",
            " */",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "",
            "#include <asm/setup.h>",
            "",
            "#include \"trace.h\"",
            "",
            "#define STACK_TRACE_ENTRIES 500",
            "",
            "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES];",
            "static unsigned stack_trace_index[STACK_TRACE_ENTRIES];",
            "",
            "static unsigned int stack_trace_nr_entries;",
            "static unsigned long stack_trace_max_size;",
            "static arch_spinlock_t stack_trace_max_lock =",
            "\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "",
            "DEFINE_PER_CPU(int, disable_stack_tracer);",
            "static DEFINE_MUTEX(stack_sysctl_mutex);",
            "",
            "int stack_tracer_enabled;",
            ""
          ],
          "function_name": null,
          "description": "定义堆栈跟踪所需的全局变量和辅助结构，包括存储堆栈信息的数组、锁、互斥量及控制启用状态的标志位，用于后续堆栈跟踪逻辑的初始化和管理。",
          "similarity": 0.4939652383327484
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/trace_stack.c",
          "start_line": 476,
          "end_line": 554,
          "content": [
            "static int stack_trace_open(struct inode *inode, struct file *file)",
            "{",
            "\tint ret;",
            "",
            "\tret = security_locked_down(LOCKDOWN_TRACEFS);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn seq_open(file, &stack_trace_seq_ops);",
            "}",
            "static int",
            "stack_trace_filter_open(struct inode *inode, struct file *file)",
            "{",
            "\tstruct ftrace_ops *ops = inode->i_private;",
            "",
            "\t/* Checks for tracefs lockdown */",
            "\treturn ftrace_regex_open(ops, FTRACE_ITER_FILTER,",
            "\t\t\t\t inode, file);",
            "}",
            "int",
            "stack_trace_sysctl(struct ctl_table *table, int write, void *buffer,",
            "\t\t   size_t *lenp, loff_t *ppos)",
            "{",
            "\tint was_enabled;",
            "\tint ret;",
            "",
            "\tmutex_lock(&stack_sysctl_mutex);",
            "\twas_enabled = !!stack_tracer_enabled;",
            "",
            "\tret = proc_dointvec(table, write, buffer, lenp, ppos);",
            "",
            "\tif (ret || !write || (was_enabled == !!stack_tracer_enabled))",
            "\t\tgoto out;",
            "",
            "\tif (stack_tracer_enabled)",
            "\t\tregister_ftrace_function(&trace_ops);",
            "\telse",
            "\t\tunregister_ftrace_function(&trace_ops);",
            " out:",
            "\tmutex_unlock(&stack_sysctl_mutex);",
            "\treturn ret;",
            "}",
            "static __init int enable_stacktrace(char *str)",
            "{",
            "\tint len;",
            "",
            "\tif ((len = str_has_prefix(str, \"_filter=\")))",
            "\t\tstrncpy(stack_trace_filter_buf, str + len, COMMAND_LINE_SIZE);",
            "",
            "\tstack_tracer_enabled = 1;",
            "\treturn 1;",
            "}",
            "static __init int stack_trace_init(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = tracing_init_dentry();",
            "\tif (ret)",
            "\t\treturn 0;",
            "",
            "\ttrace_create_file(\"stack_max_size\", TRACE_MODE_WRITE, NULL,",
            "\t\t\t&stack_trace_max_size, &stack_max_size_fops);",
            "",
            "\ttrace_create_file(\"stack_trace\", TRACE_MODE_READ, NULL,",
            "\t\t\tNULL, &stack_trace_fops);",
            "",
            "#ifdef CONFIG_DYNAMIC_FTRACE",
            "\ttrace_create_file(\"stack_trace_filter\", TRACE_MODE_WRITE, NULL,",
            "\t\t\t  &trace_ops, &stack_trace_filter_fops);",
            "#endif",
            "",
            "\tif (stack_trace_filter_buf[0])",
            "\t\tftrace_set_early_filter(&trace_ops, stack_trace_filter_buf, 1);",
            "",
            "\tif (stack_tracer_enabled)",
            "\t\tregister_ftrace_function(&trace_ops);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "stack_trace_open, stack_trace_filter_open, stack_trace_sysctl, enable_stacktrace, stack_trace_init",
          "description": "实现堆栈跟踪的初始化流程，包括创建跟踪文件节点、注册FTrace操作、处理sysctl参数以及通过命令行启用堆栈跟踪功能，完成子系统的注册与配置。",
          "similarity": 0.47244906425476074
        }
      ]
    }
  ]
}