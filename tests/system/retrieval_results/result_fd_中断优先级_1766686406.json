{
  "query": "fd 中断优先级",
  "timestamp": "2025-12-26 02:13:26",
  "retrieved_files": [
    {
      "source_file": "kernel/sched/deadline.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:06:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\deadline.c`\n\n---\n\n# `sched/deadline.c` 技术文档\n\n## 1. 文件概述\n\n`sched/deadline.c` 是 Linux 内核调度器中 **SCHED_DEADLINE** 调度类的核心实现文件。该调度类基于 **最早截止时间优先（Earliest Deadline First, EDF）** 算法，并结合 **恒定带宽服务器（Constant Bandwidth Server, CBS）** 机制，为具有严格实时性要求的任务提供可预测的调度保障。\n\n其核心目标是：  \n- 对于周期性任务，若其实际运行时间不超过所申请的运行时间（runtime），则保证不会错过任何截止时间（deadline）；  \n- 对于非周期性任务、突发任务或试图超出其预留带宽的任务，系统会对其进行节流（throttling），防止其影响其他任务的实时性保障。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct sched_dl_entity`：表示一个 deadline 调度实体，包含任务的运行时间（runtime）、截止期限（deadline）、周期（period）、带宽（dl_bw）等关键参数。\n- `struct dl_rq`：每个 CPU 的 deadline 运行队列，维护该 CPU 上所有 deadline 任务的红黑树、当前带宽使用情况（`this_bw`、`running_bw`）等。\n- `struct dl_bw`：deadline 带宽管理结构，用于跟踪系统或调度域中已分配的总带宽（`total_bw`）。\n\n### 主要函数与辅助宏\n\n#### 调度实体与运行队列关联\n- `dl_task_of(dl_se)`：从 `sched_dl_entity` 获取对应的 `task_struct`（仅适用于普通任务，不适用于服务器实体）。\n- `rq_of_dl_rq(dl_rq)` / `rq_of_dl_se(dl_se)`：获取与 deadline 运行队列或调度实体关联的 `rq`（runqueue）。\n- `dl_rq_of_se(dl_se)`：获取调度实体所属的 `dl_rq`。\n- `on_dl_rq(dl_se)`：判断调度实体是否已在 deadline 运行队列中（通过红黑树节点是否为空判断）。\n\n#### 优先级继承（PI）支持（`CONFIG_RT_MUTEXES`）\n- `pi_of(dl_se)`：获取当前调度实体因优先级继承而提升后的“代理”实体。\n- `is_dl_boosted(dl_se)`：判断该 deadline 实体是否因优先级继承被提升。\n\n#### 带宽管理（SMP 与 UP 差异处理）\n- `dl_bw_of(cpu)`：获取指定 CPU 所属调度域（或本地）的 `dl_bw` 结构。\n- `dl_bw_cpus(cpu)`：返回该 CPU 所在调度域中活跃 CPU 的数量。\n- `dl_bw_capacity(cpu)`：计算调度域的总 CPU 容量（考虑异构 CPU 的 `arch_scale_cpu_capacity`）。\n- `__dl_add()` / `__dl_sub()`：向带宽池中添加或移除任务带宽，并更新 `extra_bw`（用于负载均衡）。\n- `__dl_overflow()`：检查新增带宽是否超出系统/调度域的可用带宽上限。\n\n#### 运行时带宽跟踪\n- `__add_running_bw()` / `__sub_running_bw()`：更新 `dl_rq->running_bw`（当前正在运行的 deadline 任务所消耗的带宽）。\n- `__add_rq_bw()` / `__sub_rq_bw()`：更新 `dl_rq->this_bw`（该运行队列上所有 deadline 任务的总预留带宽）。\n- `add_running_bw()` / `sub_running_bw()` / `add_rq_bw()` / `sub_rq_bw()`：带宽操作的封装，跳过“特殊”调度实体（如服务器）。\n\n#### 其他\n- `dl_server(dl_se)`：判断调度实体是否为 CBS 服务器（而非普通任务）。\n- `dl_bw_visited(cpu, gen)`：用于带宽遍历去重（SMP 场景）。\n\n### 系统控制接口（`CONFIG_SYSCTL`）\n- `sched_deadline_period_max_us`：deadline 任务周期上限（默认 ~4 秒）。\n- `sched_deadline_period_min_us`：deadline 任务周期下限（默认 100 微秒），防止定时器 DoS。\n\n## 3. 关键实现\n\n### EDF + CBS 调度模型\n- 每个 deadline 任务通过 `runtime`、`deadline`、`period` 三个参数定义其资源需求。\n- 调度器按 **绝对截止时间（absolute deadline）** 对任务排序，使用红黑树实现 O(log n) 的调度决策。\n- CBS 机制确保任务即使突发执行，也不会长期占用超过其 `runtime/period` 的 CPU 带宽，超限任务会被 throttled。\n\n### 带宽隔离与全局限制\n- 在 SMP 系统中，deadline 带宽按 **调度域（root domain）** 进行管理，防止跨 CPU 的带宽滥用。\n- 总带宽限制默认为 CPU 总容量的 95%（由 `sysctl_sched_util_clamp_min` 等机制间接控制，具体限制逻辑在带宽分配函数中体现）。\n- `dl_bw->total_bw` 跟踪已分配带宽，`__dl_overflow()` 用于在任务加入时检查是否超限。\n\n### 异构 CPU 支持\n- 通过 `arch_scale_cpu_capacity()` 获取每个 CPU 的相对性能权重。\n- `dl_bw_capacity()` 在异构系统中返回调度域内所有活跃 CPU 的容量总和，用于带宽比例计算（`cap_scale()`）。\n\n### 与 cpufreq 集成\n- 每次 `running_bw` 变化时调用 `cpufreq_update_util()`，通知 CPU 频率调节器当前 deadline 负载，确保满足实时性能需求。\n\n### 优先级继承（PI）\n- 当 deadline 任务因持有 mutex 而阻塞高优先级任务时，通过 `pi_se` 字段临时提升其调度参数，避免优先级反转。\n\n## 4. 依赖关系\n\n- **核心调度框架**：依赖 `kernel/sched/sched.h` 中定义的通用调度结构（如 `rq`、`task_struct`）和宏（如 `SCHED_CAPACITY_SCALE`）。\n- **CPU 拓扑与容量**：依赖 `arch_scale_cpu_capacity()`（由各架构实现）获取 CPU 性能信息。\n- **RCU 机制**：在 SMP 路径中大量使用 `rcu_read_lock_sched_held()` 进行锁依赖检查。\n- **cpufreq 子系统**：通过 `cpufreq_update_util()` 与 CPU 频率调节器交互。\n- **实时互斥锁**：`CONFIG_RT_MUTEXES` 启用时，支持 deadline 任务的优先级继承。\n- **Sysctl 接口**：`CONFIG_SYSCTL` 启用时，提供用户空间可调的 deadline 参数。\n\n## 5. 使用场景\n\n- **工业实时控制**：如机器人控制、数控机床等需要严格周期性和低延迟响应的场景。\n- **音视频处理**：专业音视频采集、编码、播放等对 jitter 敏感的应用。\n- **电信基础设施**：5G 基站、核心网网元中的高优先级信令处理。\n- **汽车电子**：ADAS、自动驾驶系统中的关键任务调度。\n- **科研与高性能计算**：需要确定性执行时间的实验或仿真任务。\n\n用户通过 `sched_setattr(2)` 系统调用设置任务的 `SCHED_DEADLINE` 策略及对应的 `runtime`、`deadline`、`period` 参数，内核则通过本文件实现的调度逻辑确保其满足实时性约束。",
      "similarity": 0.5587283372879028,
      "chunks": [
        {
          "chunk_id": 13,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 2104,
          "end_line": 2251,
          "content": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tif (is_dl_boosted(&p->dl)) {",
            "\t\t/*",
            "\t\t * Because of delays in the detection of the overrun of a",
            "\t\t * thread's runtime, it might be the case that a thread",
            "\t\t * goes to sleep in a rt mutex with negative runtime. As",
            "\t\t * a consequence, the thread will be throttled.",
            "\t\t *",
            "\t\t * While waiting for the mutex, this thread can also be",
            "\t\t * boosted via PI, resulting in a thread that is throttled",
            "\t\t * and boosted at the same time.",
            "\t\t *",
            "\t\t * In this case, the boost overrides the throttle.",
            "\t\t */",
            "\t\tif (p->dl.dl_throttled) {",
            "\t\t\t/*",
            "\t\t\t * The replenish timer needs to be canceled. No",
            "\t\t\t * problem if it fires concurrently: boosted threads",
            "\t\t\t * are ignored in dl_task_timer().",
            "\t\t\t *",
            "\t\t\t * If the timer callback was running (hrtimer_try_to_cancel == -1),",
            "\t\t\t * it will eventually call put_task_struct().",
            "\t\t\t */",
            "\t\t\tif (hrtimer_try_to_cancel(&p->dl.dl_timer) == 1 &&",
            "\t\t\t    !dl_server(&p->dl))",
            "\t\t\t\tput_task_struct(p);",
            "\t\t\tp->dl.dl_throttled = 0;",
            "\t\t}",
            "\t} else if (!dl_prio(p->normal_prio)) {",
            "\t\t/*",
            "\t\t * Special case in which we have a !SCHED_DEADLINE task that is going",
            "\t\t * to be deboosted, but exceeds its runtime while doing so. No point in",
            "\t\t * replenishing it, as it's going to return back to its original",
            "\t\t * scheduling class after this. If it has been throttled, we need to",
            "\t\t * clear the flag, otherwise the task may wake up as throttled after",
            "\t\t * being boosted again with no means to replenish the runtime and clear",
            "\t\t * the throttle.",
            "\t\t */",
            "\t\tp->dl.dl_throttled = 0;",
            "\t\tif (!(flags & ENQUEUE_REPLENISH))",
            "\t\t\tprintk_deferred_once(\"sched: DL de-boosted task PID %d: REPLENISH flag missing\\n\",",
            "\t\t\t\t\t     task_pid_nr(p));",
            "",
            "\t\treturn;",
            "\t}",
            "",
            "\tcheck_schedstat_required();",
            "\tupdate_stats_wait_start_dl(dl_rq_of_se(&p->dl), &p->dl);",
            "",
            "\tif (p->on_rq == TASK_ON_RQ_MIGRATING)",
            "\t\tflags |= ENQUEUE_MIGRATING;",
            "",
            "\tenqueue_dl_entity(&p->dl, flags);",
            "",
            "\tif (dl_server(&p->dl))",
            "\t\treturn;",
            "",
            "\tif (!task_current(rq, p) && !p->dl.dl_throttled && p->nr_cpus_allowed > 1)",
            "\t\tenqueue_pushable_dl_task(rq, p);",
            "}",
            "static bool dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tupdate_curr_dl(rq);",
            "",
            "\tif (p->on_rq == TASK_ON_RQ_MIGRATING)",
            "\t\tflags |= DEQUEUE_MIGRATING;",
            "",
            "\tdequeue_dl_entity(&p->dl, flags);",
            "\tif (!p->dl.dl_throttled && !dl_server(&p->dl))",
            "\t\tdequeue_pushable_dl_task(rq, p);",
            "",
            "\treturn true;",
            "}",
            "static void yield_task_dl(struct rq *rq)",
            "{",
            "\t/*",
            "\t * We make the task go to sleep until its current deadline by",
            "\t * forcing its runtime to zero. This way, update_curr_dl() stops",
            "\t * it and the bandwidth timer will wake it up and will give it",
            "\t * new scheduling parameters (thanks to dl_yielded=1).",
            "\t */",
            "\trq->curr->dl.dl_yielded = 1;",
            "",
            "\tupdate_rq_clock(rq);",
            "\tupdate_curr_dl(rq);",
            "\t/*",
            "\t * Tell update_rq_clock() that we've just updated,",
            "\t * so we don't do microscopic update in schedule()",
            "\t * and double the fastpath cost.",
            "\t */",
            "\trq_clock_skip_update(rq);",
            "}",
            "static inline bool dl_task_is_earliest_deadline(struct task_struct *p,",
            "\t\t\t\t\t\t struct rq *rq)",
            "{",
            "\treturn (!rq->dl.dl_nr_running ||",
            "\t\tdl_time_before(p->dl.deadline,",
            "\t\t\t       rq->dl.earliest_dl.curr));",
            "}",
            "static int",
            "select_task_rq_dl(struct task_struct *p, int cpu, int flags)",
            "{",
            "\tstruct task_struct *curr;",
            "\tbool select_rq;",
            "\tstruct rq *rq;",
            "",
            "\tif (!(flags & WF_TTWU))",
            "\t\tgoto out;",
            "",
            "\trq = cpu_rq(cpu);",
            "",
            "\trcu_read_lock();",
            "\tcurr = READ_ONCE(rq->curr); /* unlocked access */",
            "",
            "\t/*",
            "\t * If we are dealing with a -deadline task, we must",
            "\t * decide where to wake it up.",
            "\t * If it has a later deadline and the current task",
            "\t * on this rq can't move (provided the waking task",
            "\t * can!) we prefer to send it somewhere else. On the",
            "\t * other hand, if it has a shorter deadline, we",
            "\t * try to make it stay here, it might be important.",
            "\t */",
            "\tselect_rq = unlikely(dl_task(curr)) &&",
            "\t\t    (curr->nr_cpus_allowed < 2 ||",
            "\t\t     !dl_entity_preempt(&p->dl, &curr->dl)) &&",
            "\t\t    p->nr_cpus_allowed > 1;",
            "",
            "\t/*",
            "\t * Take the capacity of the CPU into account to",
            "\t * ensure it fits the requirement of the task.",
            "\t */",
            "\tif (sched_asym_cpucap_active())",
            "\t\tselect_rq |= !dl_task_fits_capacity(p, cpu);",
            "",
            "\tif (select_rq) {",
            "\t\tint target = find_later_rq(p);",
            "",
            "\t\tif (target != -1 &&",
            "\t\t    dl_task_is_earliest_deadline(p, cpu_rq(target)))",
            "\t\t\tcpu = target;",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "out:",
            "\treturn cpu;",
            "}"
          ],
          "function_name": "enqueue_task_dl, dequeue_task_dl, yield_task_dl, dl_task_is_earliest_deadline, select_task_rq_dl",
          "description": "处理截止时间任务的调度决策，包含任务入队出队、抢占检查、CPU选择及负载均衡逻辑，通过dl_task_is_earliest_deadline判断任务截止时间优先级并选择合适CPU",
          "similarity": 0.5818145871162415
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 514,
          "end_line": 616,
          "content": [
            "static inline int is_leftmost(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)",
            "{",
            "\treturn rb_first_cached(&dl_rq->root) == &dl_se->rb_node;",
            "}",
            "void init_dl_bw(struct dl_bw *dl_b)",
            "{",
            "\traw_spin_lock_init(&dl_b->lock);",
            "\tif (global_rt_runtime() == RUNTIME_INF)",
            "\t\tdl_b->bw = -1;",
            "\telse",
            "\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());",
            "\tdl_b->total_bw = 0;",
            "}",
            "void init_dl_rq(struct dl_rq *dl_rq)",
            "{",
            "\tdl_rq->root = RB_ROOT_CACHED;",
            "",
            "#ifdef CONFIG_SMP",
            "\t/* zero means no -deadline tasks */",
            "\tdl_rq->earliest_dl.curr = dl_rq->earliest_dl.next = 0;",
            "",
            "\tdl_rq->overloaded = 0;",
            "\tdl_rq->pushable_dl_tasks_root = RB_ROOT_CACHED;",
            "#else",
            "\tinit_dl_bw(&dl_rq->dl_bw);",
            "#endif",
            "",
            "\tdl_rq->running_bw = 0;",
            "\tdl_rq->this_bw = 0;",
            "\tinit_dl_rq_bw_ratio(dl_rq);",
            "}",
            "static inline int dl_overloaded(struct rq *rq)",
            "{",
            "\treturn atomic_read(&rq->rd->dlo_count);",
            "}",
            "static inline void dl_set_overload(struct rq *rq)",
            "{",
            "\tif (!rq->online)",
            "\t\treturn;",
            "",
            "\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);",
            "\t/*",
            "\t * Must be visible before the overload count is",
            "\t * set (as in sched_rt.c).",
            "\t *",
            "\t * Matched by the barrier in pull_dl_task().",
            "\t */",
            "\tsmp_wmb();",
            "\tatomic_inc(&rq->rd->dlo_count);",
            "}",
            "static inline void dl_clear_overload(struct rq *rq)",
            "{",
            "\tif (!rq->online)",
            "\t\treturn;",
            "",
            "\tatomic_dec(&rq->rd->dlo_count);",
            "\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);",
            "}",
            "static inline bool __pushable_less(struct rb_node *a, const struct rb_node *b)",
            "{",
            "\treturn dl_entity_preempt(&__node_2_pdl(a)->dl, &__node_2_pdl(b)->dl);",
            "}",
            "static inline int has_pushable_dl_tasks(struct rq *rq)",
            "{",
            "\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);",
            "}",
            "static void enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)",
            "{",
            "\tstruct rb_node *leftmost;",
            "",
            "\tWARN_ON_ONCE(!RB_EMPTY_NODE(&p->pushable_dl_tasks));",
            "",
            "\tleftmost = rb_add_cached(&p->pushable_dl_tasks,",
            "\t\t\t\t &rq->dl.pushable_dl_tasks_root,",
            "\t\t\t\t __pushable_less);",
            "\tif (leftmost)",
            "\t\trq->dl.earliest_dl.next = p->dl.deadline;",
            "",
            "\tif (!rq->dl.overloaded) {",
            "\t\tdl_set_overload(rq);",
            "\t\trq->dl.overloaded = 1;",
            "\t}",
            "}",
            "static void dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)",
            "{",
            "\tstruct dl_rq *dl_rq = &rq->dl;",
            "\tstruct rb_root_cached *root = &dl_rq->pushable_dl_tasks_root;",
            "\tstruct rb_node *leftmost;",
            "",
            "\tif (RB_EMPTY_NODE(&p->pushable_dl_tasks))",
            "\t\treturn;",
            "",
            "\tleftmost = rb_erase_cached(&p->pushable_dl_tasks, root);",
            "\tif (leftmost)",
            "\t\tdl_rq->earliest_dl.next = __node_2_pdl(leftmost)->dl.deadline;",
            "",
            "\tRB_CLEAR_NODE(&p->pushable_dl_tasks);",
            "",
            "\tif (!has_pushable_dl_tasks(rq) && rq->dl.overloaded) {",
            "\t\tdl_clear_overload(rq);",
            "\t\trq->dl.overloaded = 0;",
            "\t}",
            "}"
          ],
          "function_name": "is_leftmost, init_dl_bw, init_dl_rq, dl_overloaded, dl_set_overload, dl_clear_overload, __pushable_less, has_pushable_dl_tasks, enqueue_pushable_dl_task, dequeue_pushable_dl_task",
          "description": "实现截止时间调度的抢占判定和过载管理机制，包含任务优先级比较、过载标记维护及可推送任务的数据结构操作。",
          "similarity": 0.5722576379776001
        },
        {
          "chunk_id": 18,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 3051,
          "end_line": 3166,
          "content": [
            "static void switched_to_dl(struct rq *rq, struct task_struct *p)",
            "{",
            "\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)",
            "\t\tput_task_struct(p);",
            "",
            "\t/*",
            "\t * In case a task is setscheduled to SCHED_DEADLINE we need to keep",
            "\t * track of that on its cpuset (for correct bandwidth tracking).",
            "\t */",
            "\tinc_dl_tasks_cs(p);",
            "",
            "\t/* If p is not queued we will update its parameters at next wakeup. */",
            "\tif (!task_on_rq_queued(p)) {",
            "\t\tadd_rq_bw(&p->dl, &rq->dl);",
            "",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (rq->curr != p) {",
            "#ifdef CONFIG_SMP",
            "\t\tif (p->nr_cpus_allowed > 1 && rq->dl.overloaded)",
            "\t\t\tdeadline_queue_push_tasks(rq);",
            "#endif",
            "\t\tif (dl_task(rq->curr))",
            "\t\t\twakeup_preempt_dl(rq, p, 0);",
            "\t\telse",
            "\t\t\tresched_curr(rq);",
            "\t} else {",
            "\t\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 0);",
            "\t}",
            "}",
            "static void prio_changed_dl(struct rq *rq, struct task_struct *p,",
            "\t\t\t    int oldprio)",
            "{",
            "\tif (!task_on_rq_queued(p))",
            "\t\treturn;",
            "",
            "#ifdef CONFIG_SMP",
            "\t/*",
            "\t * This might be too much, but unfortunately",
            "\t * we don't have the old deadline value, and",
            "\t * we can't argue if the task is increasing",
            "\t * or lowering its prio, so...",
            "\t */",
            "\tif (!rq->dl.overloaded)",
            "\t\tdeadline_queue_pull_task(rq);",
            "",
            "\tif (task_current(rq, p)) {",
            "\t\t/*",
            "\t\t * If we now have a earlier deadline task than p,",
            "\t\t * then reschedule, provided p is still on this",
            "\t\t * runqueue.",
            "\t\t */",
            "\t\tif (dl_time_before(rq->dl.earliest_dl.curr, p->dl.deadline))",
            "\t\t\tresched_curr(rq);",
            "\t} else {",
            "\t\t/*",
            "\t\t * Current may not be deadline in case p was throttled but we",
            "\t\t * have just replenished it (e.g. rt_mutex_setprio()).",
            "\t\t *",
            "\t\t * Otherwise, if p was given an earlier deadline, reschedule.",
            "\t\t */",
            "\t\tif (!dl_task(rq->curr) ||",
            "\t\t    dl_time_before(p->dl.deadline, rq->curr->dl.deadline))",
            "\t\t\tresched_curr(rq);",
            "\t}",
            "#else",
            "\t/*",
            "\t * We don't know if p has a earlier or later deadline, so let's blindly",
            "\t * set a (maybe not needed) rescheduling point.",
            "\t */",
            "\tresched_curr(rq);",
            "#endif",
            "}",
            "static int task_is_throttled_dl(struct task_struct *p, int cpu)",
            "{",
            "\treturn p->dl.dl_throttled;",
            "}",
            "int sched_dl_global_validate(void)",
            "{",
            "\tu64 runtime = global_rt_runtime();",
            "\tu64 period = global_rt_period();",
            "\tu64 new_bw = to_ratio(period, runtime);",
            "\tu64 gen = ++dl_generation;",
            "\tstruct dl_bw *dl_b;",
            "\tint cpu, cpus, ret = 0;",
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * Here we want to check the bandwidth not being set to some",
            "\t * value smaller than the currently allocated bandwidth in",
            "\t * any of the root_domains.",
            "\t */",
            "\tfor_each_online_cpu(cpu) {",
            "\t\trcu_read_lock_sched();",
            "",
            "\t\tif (dl_bw_visited(cpu, gen))",
            "\t\t\tgoto next;",
            "",
            "\t\tdl_b = dl_bw_of(cpu);",
            "\t\tcpus = dl_bw_cpus(cpu);",
            "",
            "\t\traw_spin_lock_irqsave(&dl_b->lock, flags);",
            "\t\tif (new_bw * cpus < dl_b->total_bw)",
            "\t\t\tret = -EBUSY;",
            "\t\traw_spin_unlock_irqrestore(&dl_b->lock, flags);",
            "",
            "next:",
            "\t\trcu_read_unlock_sched();",
            "",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "switched_to_dl, prio_changed_dl, task_is_throttled_dl, sched_dl_global_validate",
          "description": "处理SCHED_DEADLINE任务策略切换、优先级变更、节流状态检测及全局带宽验证，确保系统范围内的带宽约束有效性",
          "similarity": 0.5511614680290222
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 1741,
          "end_line": 1857,
          "content": [
            "static void update_curr_dl(struct rq *rq)",
            "{",
            "\tstruct task_struct *curr = rq->curr;",
            "\tstruct sched_dl_entity *dl_se = &curr->dl;",
            "\ts64 delta_exec;",
            "",
            "\tif (!dl_task(curr) || !on_dl_rq(dl_se))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Consumed budget is computed considering the time as",
            "\t * observed by schedulable tasks (excluding time spent",
            "\t * in hardirq context, etc.). Deadlines are instead",
            "\t * computed using hard walltime. This seems to be the more",
            "\t * natural solution, but the full ramifications of this",
            "\t * approach need further study.",
            "\t */",
            "\tdelta_exec = update_curr_common(rq);",
            "\tupdate_curr_dl_se(rq, dl_se, delta_exec);",
            "}",
            "static enum hrtimer_restart inactive_task_timer(struct hrtimer *timer)",
            "{",
            "\tstruct sched_dl_entity *dl_se = container_of(timer,",
            "\t\t\t\t\t\t     struct sched_dl_entity,",
            "\t\t\t\t\t\t     inactive_timer);",
            "\tstruct task_struct *p = NULL;",
            "\tstruct rq_flags rf;",
            "\tstruct rq *rq;",
            "",
            "\tif (!dl_server(dl_se)) {",
            "\t\tp = dl_task_of(dl_se);",
            "\t\trq = task_rq_lock(p, &rf);",
            "\t} else {",
            "\t\trq = dl_se->rq;",
            "\t\trq_lock(rq, &rf);",
            "\t}",
            "",
            "\tsched_clock_tick();",
            "\tupdate_rq_clock(rq);",
            "",
            "\tif (dl_server(dl_se))",
            "\t\tgoto no_task;",
            "",
            "\tif (!dl_task(p) || READ_ONCE(p->__state) == TASK_DEAD) {",
            "\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));",
            "",
            "\t\tif (READ_ONCE(p->__state) == TASK_DEAD && dl_se->dl_non_contending) {",
            "\t\t\tsub_running_bw(&p->dl, dl_rq_of_se(&p->dl));",
            "\t\t\tsub_rq_bw(&p->dl, dl_rq_of_se(&p->dl));",
            "\t\t\tdl_se->dl_non_contending = 0;",
            "\t\t}",
            "",
            "\t\traw_spin_lock(&dl_b->lock);",
            "\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));",
            "\t\traw_spin_unlock(&dl_b->lock);",
            "\t\t__dl_clear_params(dl_se);",
            "",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "no_task:",
            "\tif (dl_se->dl_non_contending == 0)",
            "\t\tgoto unlock;",
            "",
            "\tsub_running_bw(dl_se, &rq->dl);",
            "\tdl_se->dl_non_contending = 0;",
            "unlock:",
            "",
            "\tif (!dl_server(dl_se)) {",
            "\t\ttask_rq_unlock(rq, p, &rf);",
            "\t\tput_task_struct(p);",
            "\t} else {",
            "\t\trq_unlock(rq, &rf);",
            "\t}",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}",
            "static void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se)",
            "{",
            "\tstruct hrtimer *timer = &dl_se->inactive_timer;",
            "",
            "\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);",
            "\ttimer->function = inactive_task_timer;",
            "}",
            "static void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline)",
            "{",
            "\tstruct rq *rq = rq_of_dl_rq(dl_rq);",
            "",
            "\tif (dl_rq->earliest_dl.curr == 0 ||",
            "\t    dl_time_before(deadline, dl_rq->earliest_dl.curr)) {",
            "\t\tif (dl_rq->earliest_dl.curr == 0)",
            "\t\t\tcpupri_set(&rq->rd->cpupri, rq->cpu, CPUPRI_HIGHER);",
            "\t\tdl_rq->earliest_dl.curr = deadline;",
            "\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, deadline);",
            "\t}",
            "}",
            "static void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline)",
            "{",
            "\tstruct rq *rq = rq_of_dl_rq(dl_rq);",
            "",
            "\t/*",
            "\t * Since we may have removed our earliest (and/or next earliest)",
            "\t * task we must recompute them.",
            "\t */",
            "\tif (!dl_rq->dl_nr_running) {",
            "\t\tdl_rq->earliest_dl.curr = 0;",
            "\t\tdl_rq->earliest_dl.next = 0;",
            "\t\tcpudl_clear(&rq->rd->cpudl, rq->cpu);",
            "\t\tcpupri_set(&rq->rd->cpupri, rq->cpu, rq->rt.highest_prio.curr);",
            "\t} else {",
            "\t\tstruct rb_node *leftmost = rb_first_cached(&dl_rq->root);",
            "\t\tstruct sched_dl_entity *entry = __node_2_dle(leftmost);",
            "",
            "\t\tdl_rq->earliest_dl.curr = entry->deadline;",
            "\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, entry->deadline);",
            "\t}",
            "}"
          ],
          "function_name": "update_curr_dl, inactive_task_timer, init_dl_inactive_task_timer, inc_dl_deadline, dec_dl_deadline",
          "description": "实现截止时间调度器的核心逻辑，包含update_curr_dl更新当前任务执行时间，inactive_task_timer处理非竞争任务的定时器逻辑，init_dl_inactive_task_timer初始化定时器，inc_dl_deadline和dec_dl_deadline维护截止时间队列的最早截止时间",
          "similarity": 0.5350987315177917
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/deadline.c",
          "start_line": 48,
          "end_line": 151,
          "content": [
            "static int __init sched_dl_sysctl_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", sched_dl_sysctls);",
            "\treturn 0;",
            "}",
            "static bool dl_server(struct sched_dl_entity *dl_se)",
            "{",
            "\treturn dl_se->dl_server;",
            "}",
            "static inline int on_dl_rq(struct sched_dl_entity *dl_se)",
            "{",
            "\treturn !RB_EMPTY_NODE(&dl_se->rb_node);",
            "}",
            "static inline bool is_dl_boosted(struct sched_dl_entity *dl_se)",
            "{",
            "\treturn pi_of(dl_se) != dl_se;",
            "}",
            "static inline bool is_dl_boosted(struct sched_dl_entity *dl_se)",
            "{",
            "\treturn false;",
            "}",
            "static inline int dl_bw_cpus(int i)",
            "{",
            "\tstruct root_domain *rd = cpu_rq(i)->rd;",
            "\tint cpus;",
            "",
            "\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),",
            "\t\t\t \"sched RCU must be held\");",
            "",
            "\tif (cpumask_subset(rd->span, cpu_active_mask))",
            "\t\treturn cpumask_weight(rd->span);",
            "",
            "\tcpus = 0;",
            "",
            "\tfor_each_cpu_and(i, rd->span, cpu_active_mask)",
            "\t\tcpus++;",
            "",
            "\treturn cpus;",
            "}",
            "static inline unsigned long __dl_bw_capacity(const struct cpumask *mask)",
            "{",
            "\tunsigned long cap = 0;",
            "\tint i;",
            "",
            "\tfor_each_cpu_and(i, mask, cpu_active_mask)",
            "\t\tcap += arch_scale_cpu_capacity(i);",
            "",
            "\treturn cap;",
            "}",
            "static inline unsigned long dl_bw_capacity(int i)",
            "{",
            "\tif (!sched_asym_cpucap_active() &&",
            "\t    arch_scale_cpu_capacity(i) == SCHED_CAPACITY_SCALE) {",
            "\t\treturn dl_bw_cpus(i) << SCHED_CAPACITY_SHIFT;",
            "\t} else {",
            "\t\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),",
            "\t\t\t\t \"sched RCU must be held\");",
            "",
            "\t\treturn __dl_bw_capacity(cpu_rq(i)->rd->span);",
            "\t}",
            "}",
            "static inline bool dl_bw_visited(int cpu, u64 gen)",
            "{",
            "\tstruct root_domain *rd = cpu_rq(cpu)->rd;",
            "",
            "\tif (rd->visit_gen == gen)",
            "\t\treturn true;",
            "",
            "\trd->visit_gen = gen;",
            "\treturn false;",
            "}",
            "static inline",
            "void __dl_update(struct dl_bw *dl_b, s64 bw)",
            "{",
            "\tstruct root_domain *rd = container_of(dl_b, struct root_domain, dl_bw);",
            "\tint i;",
            "",
            "\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),",
            "\t\t\t \"sched RCU must be held\");",
            "\tfor_each_cpu_and(i, rd->span, cpu_active_mask) {",
            "\t\tstruct rq *rq = cpu_rq(i);",
            "",
            "\t\trq->dl.extra_bw += bw;",
            "\t}",
            "}",
            "static inline int dl_bw_cpus(int i)",
            "{",
            "\treturn 1;",
            "}",
            "static inline unsigned long dl_bw_capacity(int i)",
            "{",
            "\treturn SCHED_CAPACITY_SCALE;",
            "}",
            "static inline bool dl_bw_visited(int cpu, u64 gen)",
            "{",
            "\treturn false;",
            "}",
            "static inline",
            "void __dl_update(struct dl_bw *dl_b, s64 bw)",
            "{",
            "\tstruct dl_rq *dl = container_of(dl_b, struct dl_rq, dl_bw);",
            "",
            "\tdl->extra_bw += bw;",
            "}"
          ],
          "function_name": "sched_dl_sysctl_init, dl_server, on_dl_rq, is_dl_boosted, is_dl_boosted, dl_bw_cpus, __dl_bw_capacity, dl_bw_capacity, dl_bw_visited, __dl_update, dl_bw_cpus, dl_bw_capacity, dl_bw_visited, __dl_update",
          "description": "提供与截止时间调度相关的辅助函数，包括判断任务属性、计算带宽、管理资源容量及更新带宽分配的操作。",
          "similarity": 0.5165891051292419
        }
      ]
    },
    {
      "source_file": "kernel/irq/settings.h",
      "md_summary": "> 自动生成时间: 2025-10-25 14:08:46\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\settings.h`\n\n---\n\n# `irq/settings.h` 技术文档\n\n## 1. 文件概述\n\n`irq/settings.h` 是 Linux 内核中断子系统中的一个内部头文件，用于封装对 `irq_desc` 结构体中中断状态（原 `status` 字段，现为 `status_use_accessors`）的访问逻辑。该文件通过定义一组带下划线前缀的枚举常量（如 `_IRQ_PER_CPU`）映射原始中断标志（如 `IRQ_PER_CPU`），并提供一系列内联函数以安全、统一的方式读取和修改中断描述符的配置属性。同时，文件通过将原始标志宏（如 `IRQ_PER_CPU`）重定义为无效值（`GOT_YOU_MORON`），强制开发者使用封装后的访问器函数，避免直接操作底层状态位，从而提升代码的可维护性和安全性。\n\n## 2. 核心功能\n\n### 枚举常量\n- `_IRQ_DEFAULT_INIT_FLAGS`：中断描述符的默认初始化标志。\n- `_IRQ_PER_CPU`：表示该中断仅绑定到特定 CPU。\n- `_IRQ_LEVEL`：表示该中断为电平触发。\n- `_IRQ_NOPROBE`：禁止对该中断进行探测。\n- `_IRQ_NOREQUEST`：禁止通过 `request_irq()` 请求该中断。\n- `_IRQ_NOTHREAD`：禁止为该中断创建线程化处理程序。\n- `_IRQ_NOAUTOEN`：中断不会在注册后自动启用。\n- `_IRQ_MOVE_PCNTXT`：允许在进程上下文中迁移该中断。\n- `_IRQ_NO_BALANCING`：禁用中断负载均衡。\n- `_IRQ_NESTED_THREAD`：表示该中断是嵌套线程化中断。\n- `_IRQ_PER_CPU_DEVID`：表示该中断为 per-CPU 类型，且使用设备 ID。\n- `_IRQ_IS_POLLED`：表示该中断由轮询机制处理。\n- `_IRQ_DISABLE_UNLAZY`：禁用 lazy disable 优化。\n- `_IRQ_HIDDEN`：该中断对用户空间隐藏。\n- `_IRQ_NO_DEBUG`：禁用对该中断的调试跟踪。\n- `_IRQF_MODIFY_MASK`：定义哪些标志位允许被修改。\n\n### 内联函数\n- **通用操作**：\n  - `irq_settings_clr_and_set()`：原子地清除和设置指定的中断标志位。\n- **Per-CPU 相关**：\n  - `irq_settings_is_per_cpu()` / `irq_settings_set_per_cpu()`\n  - `irq_settings_is_per_cpu_devid()`\n- **负载均衡**：\n  - `irq_settings_set_no_balancing()` / `irq_settings_has_no_balance_set()`\n- **触发类型**：\n  - `irq_settings_get_trigger_mask()` / `irq_settings_set_trigger_mask()`\n  - `irq_settings_is_level()` / `irq_settings_set_level()` / `irq_settings_clr_level()`\n- **请求与探测控制**：\n  - `irq_settings_can_request()` / `irq_settings_set_norequest()` / `irq_settings_clr_norequest()`\n  - `irq_settings_can_probe()` / `irq_settings_set_noprobe()` / `irq_settings_clr_noprobe()`\n- **线程化处理**：\n  - `irq_settings_can_thread()` / `irq_settings_set_nothread()` / `irq_settings_clr_nothread()`\n  - `irq_settings_is_nested_thread()`\n- **其他属性**：\n  - `irq_settings_can_move_pcntxt()`\n  - `irq_settings_can_autoenable()`\n  - `irq_settings_is_polled()`\n  - `irq_settings_disable_unlazy()` / `irq_settings_clr_disable_unlazy()`\n  - `irq_settings_is_hidden()`\n  - `irq_settings_no_debug()` / `irq_settings_set_no_debug()`\n\n## 3. 关键实现\n\n- **标志位封装**：所有原始中断标志（如 `IRQ_PER_CPU`）被重定义为无效标识符（`GOT_YOU_MORON`），强制开发者使用带下划线前缀的枚举值（如 `_IRQ_PER_CPU`）配合封装函数进行操作，防止直接访问 `irq_desc->status_use_accessors`。\n- **安全位操作**：`irq_settings_clr_and_set()` 函数在修改标志位时，会与 `_IRQF_MODIFY_MASK` 进行掩码操作，确保只有允许修改的位被更新，防止意外覆盖关键状态。\n- **触发类型管理**：通过 `IRQ_TYPE_SENSE_MASK` 掩码单独管理中断触发类型（如边沿/电平），与其他标志位解耦。\n- **布尔语义封装**：对于“禁止”类标志（如 `_IRQ_NOREQUEST`），封装函数（如 `irq_settings_can_request()`）返回其逻辑否定值，使接口语义更直观（“能否请求”而非“是否禁止请求”）。\n\n## 4. 依赖关系\n\n- **依赖头文件**：隐式依赖 `linux/irq.h` 或 `linux/interrupt.h`，其中定义了原始中断标志（如 `IRQ_PER_CPU`、`IRQ_TYPE_SENSE_MASK`）和 `struct irq_desc`。\n- **被依赖模块**：\n  - 中断核心子系统（`kernel/irq/` 下的 `.c` 文件）：如 `irqdesc.c`、`manage.c` 等，在初始化、配置和管理中断描述符时调用本文件提供的访问器函数。\n  - 中断控制器驱动（如 GIC、APIC 驱动）：在设置特定中断属性时使用这些封装接口。\n  - 线程化中断和中断亲和性管理模块：依赖 per-CPU、线程化、负载均衡等相关接口。\n\n## 5. 使用场景\n\n- **中断描述符初始化**：在 `alloc_desc()` 或 `irq_setup_virq()` 等函数中，使用 `irq_settings_set_*` 系列函数设置中断的初始属性（如 per-CPU、触发类型等）。\n- **中断注册与配置**：在 `request_irq()`、`devm_request_irq()` 或驱动的中断设置路径中，通过 `irq_settings_can_request()` 等函数检查中断是否可被请求，并通过 `irq_settings_set_norequest()` 等函数动态调整属性。\n- **中断迁移与负载均衡**：在 `irq_set_affinity()` 或中断均衡逻辑中，使用 `irq_settings_has_no_balance_set()` 判断是否跳过均衡处理。\n- **调试与监控**：调试子系统通过 `irq_settings_no_debug()` 判断是否应跳过特定中断的跟踪。\n- **电源管理与轮询**：在中断休眠或轮询模式下，通过 `irq_settings_is_polled()` 和 `irq_settings_disable_unlazy()` 控制中断行为。",
      "similarity": 0.5503067970275879,
      "chunks": []
    },
    {
      "source_file": "kernel/irq/timings.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:10:35\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\timings.c`\n\n---\n\n# irq/timings.c 技术文档\n\n## 1. 文件概述\n\n`irq/timings.c` 是 Linux 内核中用于中断时间预测的核心模块。该文件实现了基于历史中断时间戳的预测算法，旨在通过分析中断发生的周期性模式，预测下一次中断可能发生的时间。此功能主要用于低功耗场景（如 CPU 空闲状态管理），帮助调度器或电源管理子系统更精确地设置唤醒时间，从而在保证响应性的同时减少不必要的唤醒开销。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct irq_timings`：每个 CPU 私有的中断时间记录结构，包含一个循环缓冲区，用于存储 `<中断号, 时间戳>` 元组。\n- `irqt_stats`：全局 IDR（整数到指针映射）结构，用于按中断号索引中断统计信息。\n- `irq_timing_enabled`：静态分支键（`static_key`），用于在运行时动态启用/禁用中断时间跟踪功能，避免性能开销。\n\n### 主要函数\n\n- `irq_timings_enable(void)`：启用中断时间跟踪功能，激活静态分支。\n- `irq_timings_disable(void)`：禁用中断时间跟踪功能，关闭静态分支。\n- （注：实际的预测算法逻辑虽未在代码片段中完整展示，但文档详细描述了其实现原理）\n\n## 3. 关键实现\n\n### 中断时间预测算法\n\n该模块采用三阶段算法预测中断周期：\n\n#### 1) 后缀数组（Suffix Array）模式识别\n- 将中断间隔（经 `ilog2` 映射后的索引值）序列视为字符串。\n- 构建长度为 2 到 5 的后缀（受限于实际设备周期经验）。\n- 在最近 `3 × max_period`（即 15）个索引中搜索后缀的重复出现。\n- 若某后缀连续出现 3 次，则认为发现有效周期模式，其长度即为预测周期。\n\n#### 2) 对数间隔桶（Log Interval Bucketing）\n- 使用 `ilog2(interval)` 将原始时间间隔映射到 0~63 的桶索引（因 `u64` 最大为 2^64）。\n- 该方法将大范围的时间值压缩到小数组中，例如值 1123 映射到索引 10（因 2^10 = 1024 ≤ 1123 < 2048 = 2^11）。\n\n#### 3) 指数移动平均（Exponential Moving Average, EMA）\n- 每个桶维护一个 EMA 值，用于平滑同一数量级间隔的波动。\n- EMA 公式使平均值对新数据具有可调的响应速度（通过 alpha 参数隐式控制）。\n- 预测时，根据识别出的周期模式中的桶索引，返回对应桶的 EMA 值作为预测间隔。\n\n### 工作流程\n1. 中断发生时，若 `irq_timing_enabled` 为真，则将 `<irq, timestamp>` 记录到 per-CPU 的循环缓冲区。\n2. 当需要预测某中断的下次发生时间时：\n   - 清空并处理循环缓冲区，将间隔数据分发到各中断的统计结构中。\n   - 对每个中断的间隔序列执行上述三阶段算法。\n   - 若找到重复模式，则用 EMA 值计算预测时间；否则返回未预测。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/percpu.h>`：实现 per-CPU 变量 `irq_timings`。\n  - `<linux/static_key.h>`：提供静态分支优化，避免未启用时的条件判断开销。\n  - `<linux/math64.h>` 和 `<linux/log2.h>`：用于 `ilog2` 等数学运算。\n  - `<trace/events/irq.h>`：可能用于跟踪事件（虽未在片段中调用）。\n  - `\"internals.h\"`：内核中断子系统内部头文件。\n- **子系统依赖**：\n  - 通用中断子系统（`<linux/irq.h>`, `<linux/interrupt.h>`）。\n  - 内存管理（`<linux/slab.h>`）用于动态分配统计结构。\n  - IDR 机制（`<linux/idr.h>`）用于中断号到统计结构的映射。\n\n## 5. 使用场景\n\n- **CPU 空闲状态管理（cpuidle）**：在进入深度 C-state 前，预测下一次中断时间以设置精确的唤醒定时器，避免过早或过晚唤醒。\n- **实时系统调度**：辅助调度器预判周期性中断（如 tickless 系统中的高精度定时器），优化任务调度时机。\n- **电源管理**：结合设备驱动的中断模式，动态调整设备或 CPU 的电源状态。\n- **性能分析**：通过跟踪中断时间模式，诊断中断风暴或异常周期行为。\n\n该功能默认关闭，仅在需要时通过 `irq_timings_enable()` 动态启用，确保对常规系统性能无影响。",
      "similarity": 0.5485501289367676,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/timings.c",
          "start_line": 26,
          "end_line": 165,
          "content": [
            "void irq_timings_enable(void)",
            "{",
            "\tstatic_branch_enable(&irq_timing_enabled);",
            "}",
            "void irq_timings_disable(void)",
            "{",
            "\tstatic_branch_disable(&irq_timing_enabled);",
            "}",
            "static u64 irq_timings_ema_new(u64 value, u64 ema_old)",
            "{",
            "\ts64 diff;",
            "",
            "\tif (unlikely(!ema_old))",
            "\t\treturn value;",
            "",
            "\tdiff = (value - ema_old) * EMA_ALPHA_VAL;",
            "\t/*",
            "\t * We can use a s64 type variable to be added with the u64",
            "\t * ema_old variable as this one will never have its topmost",
            "\t * bit set, it will be always smaller than 2^63 nanosec",
            "\t * interrupt interval (292 years).",
            "\t */",
            "\treturn ema_old + (diff >> EMA_ALPHA_SHIFT);",
            "}",
            "static int irq_timings_next_event_index(int *buffer, size_t len, int period_max)",
            "{",
            "\tint period;",
            "",
            "\t/*",
            "\t * Move the beginning pointer to the end minus the max period x 3.",
            "\t * We are at the point we can begin searching the pattern",
            "\t */",
            "\tbuffer = &buffer[len - (period_max * 3)];",
            "",
            "\t/* Adjust the length to the maximum allowed period x 3 */",
            "\tlen = period_max * 3;",
            "",
            "\t/*",
            "\t * The buffer contains the suite of intervals, in a ilog2",
            "\t * basis, we are looking for a repetition. We point the",
            "\t * beginning of the search three times the length of the",
            "\t * period beginning at the end of the buffer. We do that for",
            "\t * each suffix.",
            "\t */",
            "\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {",
            "",
            "\t\t/*",
            "\t\t * The first comparison always succeed because the",
            "\t\t * suffix is deduced from the first n-period bytes of",
            "\t\t * the buffer and we compare the initial suffix with",
            "\t\t * itself, so we can skip the first iteration.",
            "\t\t */",
            "\t\tint idx = period;",
            "\t\tsize_t size = period;",
            "",
            "\t\t/*",
            "\t\t * We look if the suite with period 'i' repeat",
            "\t\t * itself. If it is truncated at the end, as it",
            "\t\t * repeats we can use the period to find out the next",
            "\t\t * element with the modulo.",
            "\t\t */",
            "\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {",
            "",
            "\t\t\t/*",
            "\t\t\t * Move the index in a period basis",
            "\t\t\t */",
            "\t\t\tidx += size;",
            "",
            "\t\t\t/*",
            "\t\t\t * If this condition is reached, all previous",
            "\t\t\t * memcmp were successful, so the period is",
            "\t\t\t * found.",
            "\t\t\t */",
            "\t\t\tif (idx == len)",
            "\t\t\t\treturn buffer[len % period];",
            "",
            "\t\t\t/*",
            "\t\t\t * If the remaining elements to compare are",
            "\t\t\t * smaller than the period, readjust the size",
            "\t\t\t * of the comparison for the last iteration.",
            "\t\t\t */",
            "\t\t\tif (len - idx < period)",
            "\t\t\t\tsize = len - idx;",
            "\t\t}",
            "\t}",
            "",
            "\treturn -1;",
            "}",
            "static u64 __irq_timings_next_event(struct irqt_stat *irqs, int irq, u64 now)",
            "{",
            "\tint index, i, period_max, count, start, min = INT_MAX;",
            "",
            "\tif ((now - irqs->last_ts) >= NSEC_PER_SEC) {",
            "\t\tirqs->count = irqs->last_ts = 0;",
            "\t\treturn U64_MAX;",
            "\t}",
            "",
            "\t/*",
            "\t * As we want to find three times the repetition, we need a",
            "\t * number of intervals greater or equal to three times the",
            "\t * maximum period, otherwise we truncate the max period.",
            "\t */",
            "\tperiod_max = irqs->count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : irqs->count / 3;",
            "",
            "\t/*",
            "\t * If we don't have enough irq timings for this prediction,",
            "\t * just bail out.",
            "\t */",
            "\tif (period_max <= PREDICTION_PERIOD_MIN)",
            "\t\treturn U64_MAX;",
            "",
            "\t/*",
            "\t * 'count' will depends if the circular buffer wrapped or not",
            "\t */",
            "\tcount = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\tirqs->count : IRQ_TIMINGS_SIZE;",
            "",
            "\tstart = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\t0 : (irqs->count & IRQ_TIMINGS_MASK);",
            "",
            "\t/*",
            "\t * Copy the content of the circular buffer into another buffer",
            "\t * in order to linearize the buffer instead of dealing with",
            "\t * wrapping indexes and shifted array which will be prone to",
            "\t * error and extremely difficult to debug.",
            "\t */",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "",
            "\t\tirqs->timings[i] = irqs->circ_timings[index];",
            "\t\tmin = min_t(int, irqs->timings[i], min);",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(irqs->timings, count, period_max);",
            "\tif (index < 0)",
            "\t\treturn irqs->last_ts + irqs->ema_time[min];",
            "",
            "\treturn irqs->last_ts + irqs->ema_time[index];",
            "}"
          ],
          "function_name": "irq_timings_enable, irq_timings_disable, irq_timings_ema_new, irq_timings_next_event_index, __irq_timings_next_event",
          "description": "实现中断计时功能的启用/禁用控制，EMA计算算法及基于模式匹配的周期预测核心逻辑",
          "similarity": 0.5252302885055542
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/timings.c",
          "start_line": 1,
          "end_line": 25,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright (C) 2016, Linaro Ltd - Daniel Lezcano <daniel.lezcano@linaro.org>",
            "#define pr_fmt(fmt) \"irq_timings: \" fmt",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/static_key.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/idr.h>",
            "#include <linux/irq.h>",
            "#include <linux/math64.h>",
            "#include <linux/log2.h>",
            "",
            "#include <trace/events/irq.h>",
            "",
            "#include \"internals.h\"",
            "",
            "DEFINE_STATIC_KEY_FALSE(irq_timing_enabled);",
            "",
            "DEFINE_PER_CPU(struct irq_timings, irq_timings);",
            "",
            "static DEFINE_IDR(irqt_stats);",
            ""
          ],
          "function_name": null,
          "description": "定义中断计时模块的静态键开关和PER-CPU结构体，声明IDR管理器用于动态分配中断统计实例",
          "similarity": 0.5165272951126099
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/timings.c",
          "start_line": 435,
          "end_line": 563,
          "content": [
            "static __always_inline int irq_timings_interval_index(u64 interval)",
            "{",
            "\t/*",
            "\t * The PREDICTION_FACTOR increase the interval size for the",
            "\t * array of exponential average.",
            "\t */",
            "\tu64 interval_us = (interval >> 10) / PREDICTION_FACTOR;",
            "",
            "\treturn likely(interval_us) ? ilog2(interval_us) : 0;",
            "}",
            "static __always_inline void __irq_timings_store(int irq, struct irqt_stat *irqs,",
            "\t\t\t\t\t\tu64 interval)",
            "{",
            "\tint index;",
            "",
            "\t/*",
            "\t * Get the index in the ema table for this interrupt.",
            "\t */",
            "\tindex = irq_timings_interval_index(interval);",
            "",
            "\tif (index > PREDICTION_BUFFER_SIZE - 1) {",
            "\t\tirqs->count = 0;",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * Store the index as an element of the pattern in another",
            "\t * circular array.",
            "\t */",
            "\tirqs->circ_timings[irqs->count & IRQ_TIMINGS_MASK] = index;",
            "",
            "\tirqs->ema_time[index] = irq_timings_ema_new(interval,",
            "\t\t\t\t\t\t    irqs->ema_time[index]);",
            "",
            "\tirqs->count++;",
            "}",
            "static inline void irq_timings_store(int irq, struct irqt_stat *irqs, u64 ts)",
            "{",
            "\tu64 old_ts = irqs->last_ts;",
            "\tu64 interval;",
            "",
            "\t/*",
            "\t * The timestamps are absolute time values, we need to compute",
            "\t * the timing interval between two interrupts.",
            "\t */",
            "\tirqs->last_ts = ts;",
            "",
            "\t/*",
            "\t * The interval type is u64 in order to deal with the same",
            "\t * type in our computation, that prevent mindfuck issues with",
            "\t * overflow, sign and division.",
            "\t */",
            "\tinterval = ts - old_ts;",
            "",
            "\t/*",
            "\t * The interrupt triggered more than one second apart, that",
            "\t * ends the sequence as predictable for our purpose. In this",
            "\t * case, assume we have the beginning of a sequence and the",
            "\t * timestamp is the first value. As it is impossible to",
            "\t * predict anything at this point, return.",
            "\t *",
            "\t * Note the first timestamp of the sequence will always fall",
            "\t * in this test because the old_ts is zero. That is what we",
            "\t * want as we need another timestamp to compute an interval.",
            "\t */",
            "\tif (interval >= NSEC_PER_SEC) {",
            "\t\tirqs->count = 0;",
            "\t\treturn;",
            "\t}",
            "",
            "\t__irq_timings_store(irq, irqs, interval);",
            "}",
            "u64 irq_timings_next_event(u64 now)",
            "{",
            "\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);",
            "\tstruct irqt_stat *irqs;",
            "\tstruct irqt_stat __percpu *s;",
            "\tu64 ts, next_evt = U64_MAX;",
            "\tint i, irq = 0;",
            "",
            "\t/*",
            "\t * This function must be called with the local irq disabled in",
            "\t * order to prevent the timings circular buffer to be updated",
            "\t * while we are reading it.",
            "\t */",
            "\tlockdep_assert_irqs_disabled();",
            "",
            "\tif (!irqts->count)",
            "\t\treturn next_evt;",
            "",
            "\t/*",
            "\t * Number of elements in the circular buffer: If it happens it",
            "\t * was flushed before, then the number of elements could be",
            "\t * smaller than IRQ_TIMINGS_SIZE, so the count is used,",
            "\t * otherwise the array size is used as we wrapped. The index",
            "\t * begins from zero when we did not wrap. That could be done",
            "\t * in a nicer way with the proper circular array structure",
            "\t * type but with the cost of extra computation in the",
            "\t * interrupt handler hot path. We choose efficiency.",
            "\t *",
            "\t * Inject measured irq/timestamp to the pattern prediction",
            "\t * model while decrementing the counter because we consume the",
            "\t * data from our circular buffer.",
            "\t */",
            "\tfor_each_irqts(i, irqts) {",
            "\t\tirq = irq_timing_decode(irqts->values[i], &ts);",
            "\t\ts = idr_find(&irqt_stats, irq);",
            "\t\tif (s)",
            "\t\t\tirq_timings_store(irq, this_cpu_ptr(s), ts);",
            "\t}",
            "",
            "\t/*",
            "\t * Look in the list of interrupts' statistics, the earliest",
            "\t * next event.",
            "\t */",
            "\tidr_for_each_entry(&irqt_stats, s, i) {",
            "",
            "\t\tirqs = this_cpu_ptr(s);",
            "",
            "\t\tts = __irq_timings_next_event(irqs, i, now);",
            "\t\tif (ts <= now)",
            "\t\t\treturn now;",
            "",
            "\t\tif (ts < next_evt)",
            "\t\t\tnext_evt = ts;",
            "\t}",
            "",
            "\treturn next_evt;",
            "}"
          ],
          "function_name": "irq_timings_interval_index, __irq_timings_store, irq_timings_store, irq_timings_next_event",
          "description": "提供时间间隔转索引的映射函数，实现环形缓冲区数据存储及主事件预测函数",
          "similarity": 0.501071035861969
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/irq/timings.c",
          "start_line": 927,
          "end_line": 956,
          "content": [
            "static int __init irq_timings_selftest(void)",
            "{",
            "\tint ret;",
            "",
            "\tpr_info(\"------------------- selftest start -----------------\\n\");",
            "",
            "\t/*",
            "\t * At this point, we don't except any subsystem to use the irq",
            "\t * timings but us, so it should not be enabled.",
            "\t */",
            "\tif (static_branch_unlikely(&irq_timing_enabled)) {",
            "\t\tpr_warn(\"irq timings already initialized, skipping selftest\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = irq_timings_irqts_selftest();",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tret = irq_timings_irqs_selftest();",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tret = irq_timings_next_index_selftest();",
            "out:",
            "\tpr_info(\"---------- selftest end with %s -----------\\n\",",
            "\t\tret ? \"failure\" : \"success\");",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_selftest",
          "description": "该代码段实现了中断定时功能的自我检测逻辑，用于验证中断时间戳、中断序列及索引管理等子系统的正确性。作为初始化函数，它通过调用三个子测试函数依次检查相关功能模块的行为是否符合预期。由于代码中引用了未展示的测试函数（如irq_timings_irqts_selftest），需结合上下文才能完整理解其工作机制。",
          "similarity": 0.49656444787979126
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/timings.c",
          "start_line": 594,
          "end_line": 739,
          "content": [
            "void irq_timings_free(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s) {",
            "\t\tfree_percpu(s);",
            "\t\tidr_remove(&irqt_stats, irq);",
            "\t}",
            "}",
            "int irq_timings_alloc(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tint id;",
            "",
            "\t/*",
            "\t * Some platforms can have the same private interrupt per cpu,",
            "\t * so this function may be called several times with the",
            "\t * same interrupt number. Just bail out in case the per cpu",
            "\t * stat structure is already allocated.",
            "\t */",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s)",
            "\t\treturn 0;",
            "",
            "\ts = alloc_percpu(*s);",
            "\tif (!s)",
            "\t\treturn -ENOMEM;",
            "",
            "\tidr_preload(GFP_KERNEL);",
            "\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);",
            "\tidr_preload_end();",
            "",
            "\tif (id < 0) {",
            "\t\tfree_percpu(s);",
            "\t\treturn id;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_test_next_index(struct timings_intervals *ti)",
            "{",
            "\tint _buffer[IRQ_TIMINGS_SIZE];",
            "\tint buffer[IRQ_TIMINGS_SIZE];",
            "\tint index, start, i, count, period_max;",
            "",
            "\tcount = ti->count - 1;",
            "",
            "\tperiod_max = count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : count / 3;",
            "",
            "\t/*",
            "\t * Inject all values except the last one which will be used",
            "\t * to compare with the next index result.",
            "\t */",
            "\tpr_debug(\"index suite: \");",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\t_buffer[i & IRQ_TIMINGS_MASK] = index;",
            "\t\tpr_cont(\"%d \", index);",
            "\t}",
            "",
            "\tstart = count < IRQ_TIMINGS_SIZE ? 0 :",
            "\t\tcount & IRQ_TIMINGS_MASK;",
            "",
            "\tcount = min_t(int, count, IRQ_TIMINGS_SIZE);",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "\t\tbuffer[i] = _buffer[index];",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(buffer, count, period_max);",
            "\ti = irq_timings_interval_index(ti->intervals[ti->count - 1]);",
            "",
            "\tif (index != i) {",
            "\t\tpr_err(\"Expected (%d) and computed (%d) next indexes differ\\n\",",
            "\t\t       i, index);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_next_index_selftest(void)",
            "{",
            "\tint i, ret;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {",
            "",
            "\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",",
            "\t\t\ti, tis[i].count);",
            "",
            "\t\tret = irq_timings_test_next_index(&tis[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __init irq_timings_test_irqs(struct timings_intervals *ti)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tstruct irqt_stat *irqs;",
            "\tint i, index, ret, irq = 0xACE5;",
            "",
            "\tret = irq_timings_alloc(irq);",
            "\tif (ret) {",
            "\t\tpr_err(\"Failed to allocate irq timings\\n\");",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (!s) {",
            "\t\tret = -EIDRM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tirqs = this_cpu_ptr(s);",
            "",
            "\tfor (i = 0; i < ti->count; i++) {",
            "",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\tpr_debug(\"%d: interval=%llu ema_index=%d\\n\",",
            "\t\t\t i, ti->intervals[i], index);",
            "",
            "\t\t__irq_timings_store(irq, irqs, ti->intervals[i]);",
            "\t\tif (irqs->circ_timings[i & IRQ_TIMINGS_MASK] != index) {",
            "\t\t\tret = -EBADSLT;",
            "\t\t\tpr_err(\"Failed to store in the circular buffer\\n\");",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tif (irqs->count != ti->count) {",
            "\t\tret = -ERANGE;",
            "\t\tpr_err(\"Count differs\\n\");",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = 0;",
            "out:",
            "\tirq_timings_free(irq);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_free, irq_timings_alloc, irq_timings_test_next_index, irq_timings_next_index_selftest, irq_timings_test_irqs",
          "description": "实现中断统计结构的动态分配/释放机制，包含预测算法的自检测试函数",
          "similarity": 0.4946719706058502
        }
      ]
    }
  ]
}