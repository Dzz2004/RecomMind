{
  "query": "脏页回收与I/O调度器的协同机制",
  "timestamp": "2025-12-26 00:28:44",
  "retrieved_files": [
    {
      "source_file": "mm/page_io.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:03:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page_io.c`\n\n---\n\n# page_io.c 技术文档\n\n## 1. 文件概述\n\n`page_io.c` 是 Linux 内核内存管理子系统中负责页面交换 I/O 操作的核心文件。该文件实现了将匿名页写入交换设备（swap-out）和从交换设备读回内存（swap-in）的底层机制，包括基于 `bio` 的块设备交换路径和基于文件系统的直接 I/O 交换路径。此外，还提供了通用的交换文件激活逻辑，用于在启用交换文件时构建物理块到交换页的映射。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `__end_swap_bio_write()` / `end_swap_bio_write()`：处理交换写操作完成的回调，处理写错误并结束写回。\n- `__end_swap_bio_read()` / `end_swap_bio_read()`：处理交换读操作完成的回调，设置页面 uptodate 状态或报告读错误。\n- `generic_swapfile_activate()`：为基于文件的交换设备（如 swapfile）构建连续的物理块映射，填充 `swap_info_struct`。\n- `swap_writepage()`：页面写回交换区的主入口函数，支持 zswap 压缩缓存、内存控制组限制等特性。\n- `swap_writepage_fs()`：通过文件系统直接 I/O 路径（如 swap-over-NFS）执行交换写操作。\n- `sio_pool_init()`：初始化用于异步交换 I/O 的内存池。\n- `sio_write_complete()`：处理基于 kiocb 的异步交换写完成回调。\n\n### 关键数据结构\n\n- `struct swap_iocb`：封装用于文件系统交换 I/O 的 `kiocb` 和 `bio_vec` 数组，支持批量交换页写入。\n- `sio_pool`：`mempool_t` 类型的内存池，用于分配 `swap_iocb` 结构，避免高内存压力下分配失败。\n\n## 3. 关键实现\n\n### 交换 I/O 完成处理\n- 写操作失败时，页面被重新标记为 dirty 并清除 `PG_reclaim` 标志，防止被错误回收，同时输出限频警告日志。\n- 读操作失败仅输出警告；成功则设置 `PG_uptodate` 并解锁页面。\n\n### 交换文件激活 (`generic_swapfile_activate`)\n- 遍历交换文件的逻辑块，使用 `bmap()` 获取物理块号。\n- 验证每个 PAGE_SIZE 对齐区域的物理块是否连续且对齐。\n- 通过 `add_swap_extent()` 将有效的交换页范围注册到交换子系统。\n- 计算交换空间的物理跨度（`span`），用于优化交换分配策略。\n\n### 交换写入路径选择\n- 默认使用 `__swap_writepage()`（基于 `bio` 的块设备路径）。\n- 若启用了 zswap 且压缩存储成功，则跳过磁盘 I/O。\n- 若内存控制组禁用 zswap 回写，则返回 `AOP_WRITEPAGE_ACTIVATE` 以保留页面在内存中。\n- 对于 NFS 等不支持 `bmap` 的文件系统，使用 `swap_writepage_fs()` 路径，通过 `kiocb` 异步 DIO 写入。\n\n### 异步交换 I/O 批处理\n- `swap_writepage_fs()` 支持通过 `wbc->swap_plug` 合并多个相邻页面的写请求到同一个 `swap_iocb`。\n- 利用 `mempool` 保证在内存紧张时仍能分配 I/O 控制块。\n- 完成回调中处理部分写入错误，标记所有相关页面为 dirty 并结束写回。\n\n### 资源统计与控制\n- 通过 `count_swpout_vm_event()` 更新透明大页（THP）和普通页的交换出计数。\n- 在配置了 MEMCG 和 BLK_CGROUP 时，通过 `bio_associate_blkg_from_page()` 将 I/O 请求关联到页面所属的 blkcg，实现 I/O 资源隔离。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/swap.h>`、`<linux/pagemap.h>` 等，与页面回收、反向映射、内存控制组紧密集成。\n- **块设备层**：通过 `<linux/bio.h>`、`<linux/blkdev.h>` 与块 I/O 子系统交互。\n- **文件系统接口**：使用 `bmap()` 和 `kiocb` 与具体文件系统（如 ext4、xfs）或网络文件系统（如 NFS）协作。\n- **压缩子系统**：集成 `<linux/zswap.h>`，支持透明压缩交换缓存。\n- **资源控制器**：依赖 MEMCG 和 BLK_CGROUP 实现内存与 I/O 的多租户隔离。\n- **内部头文件**：包含本地 `\"swap.h\"` 获取交换子系统私有接口。\n\n## 5. 使用场景\n\n- **系统内存不足时**：页面回收机制调用 `swap_writepage()` 将匿名页换出到交换设备。\n- **启用交换文件时**：`swapon` 系统调用执行 `generic_swapfile_activate()` 初始化交换文件的物理布局。\n- **从交换区缺页中断**：当访问已换出页面时，内核通过 `end_swap_bio_read` 路径将数据读回内存。\n- **容器环境**：在启用内存和 I/O 控制组的系统中，确保交换 I/O 正确归属到对应 cgroup。\n- **使用压缩交换缓存**：当 zswap 启用时，优先尝试压缩页面而非立即写入慢速交换设备。\n- **网络交换场景**：在无本地块设备的环境中（如云实例使用 NFS 作为交换后端），通过 `swap_writepage_fs()` 路径完成交换。",
      "similarity": 0.6430960893630981,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/page_io.c",
          "start_line": 30,
          "end_line": 169,
          "content": [
            "static void __end_swap_bio_write(struct bio *bio)",
            "{",
            "\tstruct folio *folio = bio_first_folio_all(bio);",
            "",
            "\tif (bio->bi_status) {",
            "\t\t/*",
            "\t\t * We failed to write the page out to swap-space.",
            "\t\t * Re-dirty the page in order to avoid it being reclaimed.",
            "\t\t * Also print a dire warning that things will go BAD (tm)",
            "\t\t * very quickly.",
            "\t\t *",
            "\t\t * Also clear PG_reclaim to avoid folio_rotate_reclaimable()",
            "\t\t */",
            "\t\tfolio_mark_dirty(folio);",
            "\t\tpr_alert_ratelimited(\"Write-error on swap-device (%u:%u:%llu)\\n\",",
            "\t\t\t\t     MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),",
            "\t\t\t\t     (unsigned long long)bio->bi_iter.bi_sector);",
            "\t\tfolio_clear_reclaim(folio);",
            "\t}",
            "\tfolio_end_writeback(folio);",
            "}",
            "static void end_swap_bio_write(struct bio *bio)",
            "{",
            "\t__end_swap_bio_write(bio);",
            "\tbio_put(bio);",
            "}",
            "static void __end_swap_bio_read(struct bio *bio)",
            "{",
            "\tstruct folio *folio = bio_first_folio_all(bio);",
            "",
            "\tif (bio->bi_status) {",
            "\t\tpr_alert_ratelimited(\"Read-error on swap-device (%u:%u:%llu)\\n\",",
            "\t\t\t\t     MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),",
            "\t\t\t\t     (unsigned long long)bio->bi_iter.bi_sector);",
            "\t} else {",
            "\t\tfolio_mark_uptodate(folio);",
            "\t}",
            "\tfolio_unlock(folio);",
            "}",
            "static void end_swap_bio_read(struct bio *bio)",
            "{",
            "\t__end_swap_bio_read(bio);",
            "\tbio_put(bio);",
            "}",
            "int generic_swapfile_activate(struct swap_info_struct *sis,",
            "\t\t\t\tstruct file *swap_file,",
            "\t\t\t\tsector_t *span)",
            "{",
            "\tstruct address_space *mapping = swap_file->f_mapping;",
            "\tstruct inode *inode = mapping->host;",
            "\tunsigned blocks_per_page;",
            "\tunsigned long page_no;",
            "\tunsigned blkbits;",
            "\tsector_t probe_block;",
            "\tsector_t last_block;",
            "\tsector_t lowest_block = -1;",
            "\tsector_t highest_block = 0;",
            "\tint nr_extents = 0;",
            "\tint ret;",
            "",
            "\tblkbits = inode->i_blkbits;",
            "\tblocks_per_page = PAGE_SIZE >> blkbits;",
            "",
            "\t/*",
            "\t * Map all the blocks into the extent tree.  This code doesn't try",
            "\t * to be very smart.",
            "\t */",
            "\tprobe_block = 0;",
            "\tpage_no = 0;",
            "\tlast_block = i_size_read(inode) >> blkbits;",
            "\twhile ((probe_block + blocks_per_page) <= last_block &&",
            "\t\t\tpage_no < sis->max) {",
            "\t\tunsigned block_in_page;",
            "\t\tsector_t first_block;",
            "",
            "\t\tcond_resched();",
            "",
            "\t\tfirst_block = probe_block;",
            "\t\tret = bmap(inode, &first_block);",
            "\t\tif (ret || !first_block)",
            "\t\t\tgoto bad_bmap;",
            "",
            "\t\t/*",
            "\t\t * It must be PAGE_SIZE aligned on-disk",
            "\t\t */",
            "\t\tif (first_block & (blocks_per_page - 1)) {",
            "\t\t\tprobe_block++;",
            "\t\t\tgoto reprobe;",
            "\t\t}",
            "",
            "\t\tfor (block_in_page = 1; block_in_page < blocks_per_page;",
            "\t\t\t\t\tblock_in_page++) {",
            "\t\t\tsector_t block;",
            "",
            "\t\t\tblock = probe_block + block_in_page;",
            "\t\t\tret = bmap(inode, &block);",
            "\t\t\tif (ret || !block)",
            "\t\t\t\tgoto bad_bmap;",
            "",
            "\t\t\tif (block != first_block + block_in_page) {",
            "\t\t\t\t/* Discontiguity */",
            "\t\t\t\tprobe_block++;",
            "\t\t\t\tgoto reprobe;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tfirst_block >>= (PAGE_SHIFT - blkbits);",
            "\t\tif (page_no) {\t/* exclude the header page */",
            "\t\t\tif (first_block < lowest_block)",
            "\t\t\t\tlowest_block = first_block;",
            "\t\t\tif (first_block > highest_block)",
            "\t\t\t\thighest_block = first_block;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * We found a PAGE_SIZE-length, PAGE_SIZE-aligned run of blocks",
            "\t\t */",
            "\t\tret = add_swap_extent(sis, page_no, 1, first_block);",
            "\t\tif (ret < 0)",
            "\t\t\tgoto out;",
            "\t\tnr_extents += ret;",
            "\t\tpage_no++;",
            "\t\tprobe_block += blocks_per_page;",
            "reprobe:",
            "\t\tcontinue;",
            "\t}",
            "\tret = nr_extents;",
            "\t*span = 1 + highest_block - lowest_block;",
            "\tif (page_no == 0)",
            "\t\tpage_no = 1;\t/* force Empty message */",
            "\tsis->max = page_no;",
            "\tsis->pages = page_no - 1;",
            "\tsis->highest_bit = page_no - 1;",
            "out:",
            "\treturn ret;",
            "bad_bmap:",
            "\tpr_err(\"swapon: swapfile has holes\\n\");",
            "\tret = -EINVAL;",
            "\tgoto out;",
            "}"
          ],
          "function_name": "__end_swap_bio_write, end_swap_bio_write, __end_swap_bio_read, end_swap_bio_read, generic_swapfile_activate",
          "description": "实现交换I/O完成回调函数，处理写入错误重标记脏页及读取错误日志；generic_swapfile_activate扫描交换文件块并构建交换区范围。",
          "similarity": 0.6391441822052002
        },
        {
          "chunk_id": 2,
          "file_path": "mm/page_io.c",
          "start_line": 179,
          "end_line": 280,
          "content": [
            "int swap_writepage(struct page *page, struct writeback_control *wbc)",
            "{",
            "\tstruct folio *folio = page_folio(page);",
            "\tint ret;",
            "",
            "\tif (folio_free_swap(folio)) {",
            "\t\tfolio_unlock(folio);",
            "\t\treturn 0;",
            "\t}",
            "\t/*",
            "\t * Arch code may have to preserve more data than just the page",
            "\t * contents, e.g. memory tags.",
            "\t */",
            "\tret = arch_prepare_to_swap(folio);",
            "\tif (ret) {",
            "\t\tfolio_mark_dirty(folio);",
            "\t\tfolio_unlock(folio);",
            "\t\treturn ret;",
            "\t}",
            "\tif (zswap_store(folio)) {",
            "\t\tfolio_start_writeback(folio);",
            "\t\tfolio_unlock(folio);",
            "\t\tfolio_end_writeback(folio);",
            "\t\treturn 0;",
            "\t}",
            "\tif (!mem_cgroup_zswap_writeback_enabled(folio_memcg(folio))) {",
            "\t\tfolio_mark_dirty(folio);",
            "\t\treturn AOP_WRITEPAGE_ACTIVATE;",
            "\t}",
            "",
            "\t__swap_writepage(folio, wbc);",
            "\treturn 0;",
            "}",
            "static inline void count_swpout_vm_event(struct folio *folio)",
            "{",
            "#ifdef CONFIG_TRANSPARENT_HUGEPAGE",
            "\tif (unlikely(folio_test_pmd_mappable(folio))) {",
            "\t\tcount_memcg_folio_events(folio, THP_SWPOUT, 1);",
            "\t\tcount_vm_event(THP_SWPOUT);",
            "\t}",
            "\tcount_mthp_stat(folio_order(folio), MTHP_STAT_SWPOUT);",
            "#endif",
            "\tcount_memcg_folio_events(folio, PSWPOUT, folio_nr_pages(folio));",
            "\tcount_vm_events(PSWPOUT, folio_nr_pages(folio));",
            "}",
            "static void bio_associate_blkg_from_page(struct bio *bio, struct folio *folio)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct mem_cgroup *memcg;",
            "",
            "\tmemcg = folio_memcg(folio);",
            "\tif (!memcg)",
            "\t\treturn;",
            "",
            "\trcu_read_lock();",
            "\tcss = cgroup_e_css(memcg->css.cgroup, &io_cgrp_subsys);",
            "\tbio_associate_blkg_from_css(bio, css);",
            "\trcu_read_unlock();",
            "}",
            "int sio_pool_init(void)",
            "{",
            "\tif (!sio_pool) {",
            "\t\tmempool_t *pool = mempool_create_kmalloc_pool(",
            "\t\t\tSWAP_CLUSTER_MAX, sizeof(struct swap_iocb));",
            "\t\tif (cmpxchg(&sio_pool, NULL, pool))",
            "\t\t\tmempool_destroy(pool);",
            "\t}",
            "\tif (!sio_pool)",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "static void sio_write_complete(struct kiocb *iocb, long ret)",
            "{",
            "\tstruct swap_iocb *sio = container_of(iocb, struct swap_iocb, iocb);",
            "\tstruct page *page = sio->bvec[0].bv_page;",
            "\tint p;",
            "",
            "\tif (ret != sio->len) {",
            "\t\t/*",
            "\t\t * In the case of swap-over-nfs, this can be a",
            "\t\t * temporary failure if the system has limited",
            "\t\t * memory for allocating transmit buffers.",
            "\t\t * Mark the page dirty and avoid",
            "\t\t * folio_rotate_reclaimable but rate-limit the",
            "\t\t * messages but do not flag PageError like",
            "\t\t * the normal direct-to-bio case as it could",
            "\t\t * be temporary.",
            "\t\t */",
            "\t\tpr_err_ratelimited(\"Write error %ld on dio swapfile (%llu)\\n\",",
            "\t\t\t\t   ret, page_file_offset(page));",
            "\t\tfor (p = 0; p < sio->pages; p++) {",
            "\t\t\tpage = sio->bvec[p].bv_page;",
            "\t\t\tset_page_dirty(page);",
            "\t\t\tClearPageReclaim(page);",
            "\t\t}",
            "\t}",
            "",
            "\tfor (p = 0; p < sio->pages; p++)",
            "\t\tend_page_writeback(sio->bvec[p].bv_page);",
            "",
            "\tmempool_free(sio, sio_pool);",
            "}"
          ],
          "function_name": "swap_writepage, count_swpout_vm_event, bio_associate_blkg_from_page, sio_pool_init, sio_write_complete",
          "description": "swap_writepage发起页面换出流程，调用架构特定准备函数并处理ZSwap缓存；sio_write_complete处理异步写入完成，标记脏页并释放资源。",
          "similarity": 0.5766577124595642
        },
        {
          "chunk_id": 5,
          "file_path": "mm/page_io.c",
          "start_line": 543,
          "end_line": 553,
          "content": [
            "void __swap_read_unplug(struct swap_iocb *sio)",
            "{",
            "\tstruct iov_iter from;",
            "\tstruct address_space *mapping = sio->iocb.ki_filp->f_mapping;",
            "\tint ret;",
            "",
            "\tiov_iter_bvec(&from, ITER_DEST, sio->bvec, sio->pages, sio->len);",
            "\tret = mapping->a_ops->swap_rw(&sio->iocb, &from);",
            "\tif (ret != -EIOCBQUEUED)",
            "\t\tsio_read_complete(&sio->iocb, ret);",
            "}"
          ],
          "function_name": "__swap_read_unplug",
          "description": "该函数是处理交换读取操作的关键函数，在页置换过程中将从交换设备读取的数据通过I/O向量传递至文件地址空间。  \n它通过构建iov_iter并调用address_space的a_ops->swap_rw接口进行实际的数据读取，并根据返回状态触发相应的完成回调。  \n注：swap_rw的具体实现依赖于对应文件系统的a_ops，此处上下文不完整。",
          "similarity": 0.5668811202049255
        },
        {
          "chunk_id": 3,
          "file_path": "mm/page_io.c",
          "start_line": 298,
          "end_line": 400,
          "content": [
            "static void swap_writepage_fs(struct folio *folio, struct writeback_control *wbc)",
            "{",
            "\tstruct swap_iocb *sio = NULL;",
            "\tstruct swap_info_struct *sis = swp_swap_info(folio->swap);",
            "\tstruct file *swap_file = sis->swap_file;",
            "\tloff_t pos = folio_file_pos(folio);",
            "",
            "\tcount_swpout_vm_event(folio);",
            "\tfolio_start_writeback(folio);",
            "\tfolio_unlock(folio);",
            "\tif (wbc->swap_plug)",
            "\t\tsio = *wbc->swap_plug;",
            "\tif (sio) {",
            "\t\tif (sio->iocb.ki_filp != swap_file ||",
            "\t\t    sio->iocb.ki_pos + sio->len != pos) {",
            "\t\t\tswap_write_unplug(sio);",
            "\t\t\tsio = NULL;",
            "\t\t}",
            "\t}",
            "\tif (!sio) {",
            "\t\tsio = mempool_alloc(sio_pool, GFP_NOIO);",
            "\t\tinit_sync_kiocb(&sio->iocb, swap_file);",
            "\t\tsio->iocb.ki_complete = sio_write_complete;",
            "\t\tsio->iocb.ki_pos = pos;",
            "\t\tsio->pages = 0;",
            "\t\tsio->len = 0;",
            "\t}",
            "\tbvec_set_folio(&sio->bvec[sio->pages], folio, folio_size(folio), 0);",
            "\tsio->len += folio_size(folio);",
            "\tsio->pages += 1;",
            "\tif (sio->pages == ARRAY_SIZE(sio->bvec) || !wbc->swap_plug) {",
            "\t\tswap_write_unplug(sio);",
            "\t\tsio = NULL;",
            "\t}",
            "\tif (wbc->swap_plug)",
            "\t\t*wbc->swap_plug = sio;",
            "}",
            "static void swap_writepage_bdev_sync(struct folio *folio,",
            "\t\tstruct writeback_control *wbc, struct swap_info_struct *sis)",
            "{",
            "\tstruct bio_vec bv;",
            "\tstruct bio bio;",
            "",
            "\tbio_init(&bio, sis->bdev, &bv, 1,",
            "\t\t REQ_OP_WRITE | REQ_SWAP | wbc_to_write_flags(wbc));",
            "\tbio.bi_iter.bi_sector = swap_folio_sector(folio);",
            "\tbio_add_folio_nofail(&bio, folio, folio_size(folio), 0);",
            "",
            "\tbio_associate_blkg_from_page(&bio, folio);",
            "\tcount_swpout_vm_event(folio);",
            "",
            "\tfolio_start_writeback(folio);",
            "\tfolio_unlock(folio);",
            "",
            "\tsubmit_bio_wait(&bio);",
            "\t__end_swap_bio_write(&bio);",
            "}",
            "static void swap_writepage_bdev_async(struct folio *folio,",
            "\t\tstruct writeback_control *wbc, struct swap_info_struct *sis)",
            "{",
            "\tstruct bio *bio;",
            "",
            "\tbio = bio_alloc(sis->bdev, 1,",
            "\t\t\tREQ_OP_WRITE | REQ_SWAP | wbc_to_write_flags(wbc),",
            "\t\t\tGFP_NOIO);",
            "\tbio->bi_iter.bi_sector = swap_folio_sector(folio);",
            "\tbio->bi_end_io = end_swap_bio_write;",
            "\tbio_add_folio_nofail(bio, folio, folio_size(folio), 0);",
            "",
            "\tbio_associate_blkg_from_page(bio, folio);",
            "\tcount_swpout_vm_event(folio);",
            "\tfolio_start_writeback(folio);",
            "\tfolio_unlock(folio);",
            "\tsubmit_bio(bio);",
            "}",
            "void __swap_writepage(struct folio *folio, struct writeback_control *wbc)",
            "{",
            "\tstruct swap_info_struct *sis = swp_swap_info(folio->swap);",
            "",
            "\tVM_BUG_ON_FOLIO(!folio_test_swapcache(folio), folio);",
            "\t/*",
            "\t * ->flags can be updated non-atomicially (scan_swap_map_slots),",
            "\t * but that will never affect SWP_FS_OPS, so the data_race",
            "\t * is safe.",
            "\t */",
            "\tif (data_race(sis->flags & SWP_FS_OPS))",
            "\t\tswap_writepage_fs(folio, wbc);",
            "\telse if (sis->flags & SWP_SYNCHRONOUS_IO)",
            "\t\tswap_writepage_bdev_sync(folio, wbc, sis);",
            "\telse",
            "\t\tswap_writepage_bdev_async(folio, wbc, sis);",
            "}",
            "void swap_write_unplug(struct swap_iocb *sio)",
            "{",
            "\tstruct iov_iter from;",
            "\tstruct address_space *mapping = sio->iocb.ki_filp->f_mapping;",
            "\tint ret;",
            "",
            "\tiov_iter_bvec(&from, ITER_SOURCE, sio->bvec, sio->pages, sio->len);",
            "\tret = mapping->a_ops->swap_rw(&sio->iocb, &from);",
            "\tif (ret != -EIOCBQUEUED)",
            "\t\tsio_write_complete(&sio->iocb, ret);",
            "}"
          ],
          "function_name": "swap_writepage_fs, swap_writepage_bdev_sync, swap_writepage_bdev_async, __swap_writepage, swap_write_unplug",
          "description": "__swap_writepage根据配置选择同步/异步块设备写入路径，通过bio结构执行交换页面写入操作，支持批量提交优化。",
          "similarity": 0.5652223229408264
        },
        {
          "chunk_id": 0,
          "file_path": "mm/page_io.c",
          "start_line": 1,
          "end_line": 29,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  linux/mm/page_io.c",
            " *",
            " *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds",
            " *",
            " *  Swap reorganised 29.12.95, ",
            " *  Asynchronous swapping added 30.12.95. Stephen Tweedie",
            " *  Removed race in async swapping. 14.4.1996. Bruno Haible",
            " *  Add swap of shared pages through the page cache. 20.2.1998. Stephen Tweedie",
            " *  Always use brw_page, life becomes simpler. 12 May 1998 Eric Biederman",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swapops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/psi.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/zswap.h>",
            "#include \"swap.h\"",
            ""
          ],
          "function_name": null,
          "description": "声明头文件并引入交换页面管理模块的基本依赖，为后续交换操作提供基础框架。",
          "similarity": 0.53783118724823
        }
      ]
    },
    {
      "source_file": "mm/page-writeback.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:59:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page-writeback.c`\n\n---\n\n# page-writeback.c 技术文档\n\n## 1. 文件概述\n\n`page-writeback.c` 是 Linux 内核内存管理子系统（MM）中的核心文件，负责实现**脏页回写（dirty page writeback）机制**。该机制用于控制和协调将修改过的页面（即“脏页”）从内存写回到持久化存储（如磁盘）的过程，以确保数据一致性、防止内存耗尽，并在系统负载与 I/O 带宽之间取得平衡。\n\n该文件主要提供以下功能：\n- 脏页数量的全局与每 BDI（Backing Device Info）级别的阈值管理\n- 脏页生成速率的动态限流（throttling）\n- 后台回写线程（如 `writeback` 线程）的触发逻辑\n- 支持基于 cgroup 的内存回写控制（当启用 `CONFIG_CGROUP_WRITEBACK` 时）\n- 与 `/proc/sys/vm` 中可调参数的交互接口\n\n## 2. 核心功能\n\n### 主要全局变量（可通过 sysctl 调整）\n| 变量名 | 默认值 | 说明 |\n|--------|--------|------|\n| `dirty_background_ratio` | 10 | 当脏页占可用内存比例达到此值时，启动后台回写 |\n| `vm_dirty_ratio` | 20 | 脏页比例硬上限，超过则阻塞写进程进行同步回写 |\n| `dirty_background_bytes` | 0 | 以字节为单位指定后台回写阈值（优先级高于 ratio） |\n| `vm_dirty_bytes` | 0 | 以字节为单位指定脏页硬上限（优先级高于 ratio） |\n| `dirty_writeback_interval` | 500 (5秒) | 后台回写线程的唤醒间隔（单位：厘秒） |\n| `dirty_expire_interval` | 3000 (30秒) | 脏页最大存活时间，超时强制回写 |\n| `laptop_mode` | 0 | 笔记本模式开关，减少磁盘活动以省电 |\n| `ratelimit_pages` | 32 | 每 CPU 脏页速率限制阈值 |\n\n### 关键数据结构\n- **`struct wb_domain`**  \n  回写域（writeback domain），用于聚合多个 BDI 的回写状态，支持全局或 per-memcg 的回写控制。\n  \n- **`struct dirty_throttle_control` (dtc)**  \n  脏页限流控制上下文，包含：\n  - `avail`：当前可脏化的内存总量\n  - `dirty`：当前脏页数量\n  - `thresh` / `bg_thresh`：硬/软回写阈值\n  - `wb_dirty` / `wb_thresh` / `wb_bg_thresh`：per-BDI 级别的对应值\n  - `pos_ratio`：用于计算回写速率的比例因子\n\n- **条件编译支持**  \n  通过 `CONFIG_CGROUP_WRITEBACK` 区分是否支持 memcg 级别的回写控制，提供 `GDTC_INIT`、`MDTC_INIT` 等宏及辅助函数（如 `mdtc_valid()`、`wb_min_max_ratio()`）。\n\n### 核心辅助函数（部分在截断代码中未完整显示）\n- `node_dirtyable_memory()`：计算指定 NUMA 节点中可用于脏页缓存的内存总量（包括空闲页 + 文件缓存页 - 保留页）。\n- `balance_dirty_pages()`：主限流函数，在进程写入时被调用，根据当前脏页水位决定是否休眠或触发回写。\n- `balance_dirty_pages_ratelimited()`：带速率限制的脏页平衡入口，避免频繁调用开销。\n\n## 3. 关键实现\n\n### 脏页阈值计算逻辑\n- 脏页上限基于 **“dirtyable memory”** 计算，即 `(free pages + file cache pages - kernel reserves)`。\n- 支持两种配置方式：**百分比（ratio）** 或 **绝对字节数（bytes）**，后者优先。\n- 当启用 `vm_highmem_is_dirtyable` 时，highmem 区域的空闲页也计入 dirtyable memory。\n\n### 动态限流机制\n- 使用 **`MAX_PAUSE`（最大 200ms）** 限制单次 `balance_dirty_pages()` 的休眠时间。\n- 引入 **`DIRTY_POLL_THRESH`（128KB）** 作为调用间隔优化阈值：若脏页增长过快，则提升休眠时间至最大值。\n- 通过 **`BANDWIDTH_INTERVAL`（200ms）** 动态估算存储设备的写入带宽，用于调整回写速率。\n\n### cgroup writeback 支持\n- 在 `CONFIG_CGROUP_WRITEBACK` 启用时：\n  - 每个 memcg 有独立的 `wb_domain`\n  - `dirty_throttle_control` 可关联全局（gdtc）或 memcg（mdtc）上下文\n  - BDI 的 min/max_ratio 根据其实际带宽动态缩放，实现公平分配\n\n### 老化与完成计数\n- 使用 `fprop_local_percpu` 结构跟踪每个 BDI 的回写完成情况。\n- `VM_COMPLETIONS_PERIOD_LEN`（3 秒）定义了回写完成率的老化周期，影响带宽估算的响应速度。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/swap.h>`、`<linux/pagevec.h>` 等，与页分配、回收机制紧密集成。\n- **VFS 层**：通过 `<linux/fs.h>`、`<linux/pagemap.h>` 与 address_space 和 inode 交互。\n- **块设备层**：通过 `<linux/blkdev.h>`、`<linux/backing-dev.h>` 获取 BDI 信息和 I/O 能力。\n- **调度与同步**：使用 `<linux/sched.h>`、`<linux/spinlock.h>`、`<linux/timer.h>` 实现休眠、锁和定时器。\n- **追踪系统**：集成 `<trace/events/writeback.h>` 提供回写事件追踪点。\n- **内部头文件**：包含 `\"internal.h\"` 获取 MM 子系统内部接口。\n\n## 5. 使用场景\n\n1. **用户空间写入文件**  \n   当进程通过 `write()` 修改文件页时，页被标记为脏，随后调用 `balance_dirty_pages_ratelimited()` 触发脏页控制。\n\n2. **内存压力下的页面回收**  \n   kswapd 或直接回收路径在需要释放内存时，可能调用回写逻辑清理脏页。\n\n3. **定期后台回写**  \n   `writeback` 内核线程按 `dirty_writeback_interval` 周期唤醒，检查并回写超过 `dirty_expire_interval` 的脏页。\n\n4. **系统关闭或 sync 调用**  \n   虽然主要同步逻辑在其他文件，但本文件提供的阈值和状态是决策基础。\n\n5. **容器环境中的资源隔离**  \n   启用 cgroup writeback 后，不同 memcg 的脏页回写相互隔离，避免一个容器的大量写入影响其他容器性能。\n\n6. **笔记本省电模式**  \n   当 `laptop_mode` 启用时，延迟回写以减少磁盘旋转时间，延长电池寿命。",
      "similarity": 0.6271684169769287,
      "chunks": [
        {
          "chunk_id": 9,
          "file_path": "mm/page-writeback.c",
          "start_line": 1662,
          "end_line": 1988,
          "content": [
            "static inline void wb_dirty_limits(struct dirty_throttle_control *dtc)",
            "{",
            "\tstruct bdi_writeback *wb = dtc->wb;",
            "\tunsigned long wb_reclaimable;",
            "",
            "\t/*",
            "\t * wb_thresh is not treated as some limiting factor as",
            "\t * dirty_thresh, due to reasons",
            "\t * - in JBOD setup, wb_thresh can fluctuate a lot",
            "\t * - in a system with HDD and USB key, the USB key may somehow",
            "\t *   go into state (wb_dirty >> wb_thresh) either because",
            "\t *   wb_dirty starts high, or because wb_thresh drops low.",
            "\t *   In this case we don't want to hard throttle the USB key",
            "\t *   dirtiers for 100 seconds until wb_dirty drops under",
            "\t *   wb_thresh. Instead the auxiliary wb control line in",
            "\t *   wb_position_ratio() will let the dirtier task progress",
            "\t *   at some rate <= (write_bw / 2) for bringing down wb_dirty.",
            "\t */",
            "\tdtc->wb_thresh = __wb_calc_thresh(dtc);",
            "\tdtc->wb_bg_thresh = dtc->thresh ?",
            "\t\tdiv_u64((u64)dtc->wb_thresh * dtc->bg_thresh, dtc->thresh) : 0;",
            "",
            "\t/*",
            "\t * In order to avoid the stacked BDI deadlock we need",
            "\t * to ensure we accurately count the 'dirty' pages when",
            "\t * the threshold is low.",
            "\t *",
            "\t * Otherwise it would be possible to get thresh+n pages",
            "\t * reported dirty, even though there are thresh-m pages",
            "\t * actually dirty; with m+n sitting in the percpu",
            "\t * deltas.",
            "\t */",
            "\tif (dtc->wb_thresh < 2 * wb_stat_error()) {",
            "\t\twb_reclaimable = wb_stat_sum(wb, WB_RECLAIMABLE);",
            "\t\tdtc->wb_dirty = wb_reclaimable + wb_stat_sum(wb, WB_WRITEBACK);",
            "\t} else {",
            "\t\twb_reclaimable = wb_stat(wb, WB_RECLAIMABLE);",
            "\t\tdtc->wb_dirty = wb_reclaimable + wb_stat(wb, WB_WRITEBACK);",
            "\t}",
            "}",
            "static int balance_dirty_pages(struct bdi_writeback *wb,",
            "\t\t\t       unsigned long pages_dirtied, unsigned int flags)",
            "{",
            "\tstruct dirty_throttle_control gdtc_stor = { GDTC_INIT(wb) };",
            "\tstruct dirty_throttle_control mdtc_stor = { MDTC_INIT(wb, &gdtc_stor) };",
            "\tstruct dirty_throttle_control * const gdtc = &gdtc_stor;",
            "\tstruct dirty_throttle_control * const mdtc = mdtc_valid(&mdtc_stor) ?",
            "\t\t\t\t\t\t     &mdtc_stor : NULL;",
            "\tstruct dirty_throttle_control *sdtc;",
            "\tunsigned long nr_dirty;",
            "\tlong period;",
            "\tlong pause;",
            "\tlong max_pause;",
            "\tlong min_pause;",
            "\tint nr_dirtied_pause;",
            "\tbool dirty_exceeded = false;",
            "\tunsigned long task_ratelimit;",
            "\tunsigned long dirty_ratelimit;",
            "\tstruct backing_dev_info *bdi = wb->bdi;",
            "\tbool strictlimit = bdi->capabilities & BDI_CAP_STRICTLIMIT;",
            "\tunsigned long start_time = jiffies;",
            "\tint ret = 0;",
            "",
            "\tfor (;;) {",
            "\t\tunsigned long now = jiffies;",
            "\t\tunsigned long dirty, thresh, bg_thresh;",
            "\t\tunsigned long m_dirty = 0;\t/* stop bogus uninit warnings */",
            "\t\tunsigned long m_thresh = 0;",
            "\t\tunsigned long m_bg_thresh = 0;",
            "",
            "\t\tnr_dirty = global_node_page_state(NR_FILE_DIRTY);",
            "\t\tgdtc->avail = global_dirtyable_memory();",
            "\t\tgdtc->dirty = nr_dirty + global_node_page_state(NR_WRITEBACK);",
            "",
            "\t\tdomain_dirty_limits(gdtc);",
            "",
            "\t\tif (unlikely(strictlimit)) {",
            "\t\t\twb_dirty_limits(gdtc);",
            "",
            "\t\t\tdirty = gdtc->wb_dirty;",
            "\t\t\tthresh = gdtc->wb_thresh;",
            "\t\t\tbg_thresh = gdtc->wb_bg_thresh;",
            "\t\t} else {",
            "\t\t\tdirty = gdtc->dirty;",
            "\t\t\tthresh = gdtc->thresh;",
            "\t\t\tbg_thresh = gdtc->bg_thresh;",
            "\t\t}",
            "",
            "\t\tif (mdtc) {",
            "\t\t\tunsigned long filepages, headroom, writeback;",
            "",
            "\t\t\t/*",
            "\t\t\t * If @wb belongs to !root memcg, repeat the same",
            "\t\t\t * basic calculations for the memcg domain.",
            "\t\t\t */",
            "\t\t\tmem_cgroup_wb_stats(wb, &filepages, &headroom,",
            "\t\t\t\t\t    &mdtc->dirty, &writeback);",
            "\t\t\tmdtc->dirty += writeback;",
            "\t\t\tmdtc_calc_avail(mdtc, filepages, headroom);",
            "",
            "\t\t\tdomain_dirty_limits(mdtc);",
            "",
            "\t\t\tif (unlikely(strictlimit)) {",
            "\t\t\t\twb_dirty_limits(mdtc);",
            "\t\t\t\tm_dirty = mdtc->wb_dirty;",
            "\t\t\t\tm_thresh = mdtc->wb_thresh;",
            "\t\t\t\tm_bg_thresh = mdtc->wb_bg_thresh;",
            "\t\t\t} else {",
            "\t\t\t\tm_dirty = mdtc->dirty;",
            "\t\t\t\tm_thresh = mdtc->thresh;",
            "\t\t\t\tm_bg_thresh = mdtc->bg_thresh;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * In laptop mode, we wait until hitting the higher threshold",
            "\t\t * before starting background writeout, and then write out all",
            "\t\t * the way down to the lower threshold.  So slow writers cause",
            "\t\t * minimal disk activity.",
            "\t\t *",
            "\t\t * In normal mode, we start background writeout at the lower",
            "\t\t * background_thresh, to keep the amount of dirty memory low.",
            "\t\t */",
            "\t\tif (!laptop_mode && nr_dirty > gdtc->bg_thresh &&",
            "\t\t    !writeback_in_progress(wb))",
            "\t\t\twb_start_background_writeback(wb);",
            "",
            "\t\t/*",
            "\t\t * Throttle it only when the background writeback cannot",
            "\t\t * catch-up. This avoids (excessively) small writeouts",
            "\t\t * when the wb limits are ramping up in case of !strictlimit.",
            "\t\t *",
            "\t\t * In strictlimit case make decision based on the wb counters",
            "\t\t * and limits. Small writeouts when the wb limits are ramping",
            "\t\t * up are the price we consciously pay for strictlimit-ing.",
            "\t\t *",
            "\t\t * If memcg domain is in effect, @dirty should be under",
            "\t\t * both global and memcg freerun ceilings.",
            "\t\t */",
            "\t\tif (dirty <= dirty_freerun_ceiling(thresh, bg_thresh) &&",
            "\t\t    (!mdtc ||",
            "\t\t     m_dirty <= dirty_freerun_ceiling(m_thresh, m_bg_thresh))) {",
            "\t\t\tunsigned long intv;",
            "\t\t\tunsigned long m_intv;",
            "",
            "free_running:",
            "\t\t\tintv = dirty_poll_interval(dirty, thresh);",
            "\t\t\tm_intv = ULONG_MAX;",
            "",
            "\t\t\tcurrent->dirty_paused_when = now;",
            "\t\t\tcurrent->nr_dirtied = 0;",
            "\t\t\tif (mdtc)",
            "\t\t\t\tm_intv = dirty_poll_interval(m_dirty, m_thresh);",
            "\t\t\tcurrent->nr_dirtied_pause = min(intv, m_intv);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* Start writeback even when in laptop mode */",
            "\t\tif (unlikely(!writeback_in_progress(wb)))",
            "\t\t\twb_start_background_writeback(wb);",
            "",
            "\t\tmem_cgroup_flush_foreign(wb);",
            "",
            "\t\t/*",
            "\t\t * Calculate global domain's pos_ratio and select the",
            "\t\t * global dtc by default.",
            "\t\t */",
            "\t\tif (!strictlimit) {",
            "\t\t\twb_dirty_limits(gdtc);",
            "",
            "\t\t\tif ((current->flags & PF_LOCAL_THROTTLE) &&",
            "\t\t\t    gdtc->wb_dirty <",
            "\t\t\t    dirty_freerun_ceiling(gdtc->wb_thresh,",
            "\t\t\t\t\t\t  gdtc->wb_bg_thresh))",
            "\t\t\t\t/*",
            "\t\t\t\t * LOCAL_THROTTLE tasks must not be throttled",
            "\t\t\t\t * when below the per-wb freerun ceiling.",
            "\t\t\t\t */",
            "\t\t\t\tgoto free_running;",
            "\t\t}",
            "",
            "\t\tdirty_exceeded = (gdtc->wb_dirty > gdtc->wb_thresh) &&",
            "\t\t\t((gdtc->dirty > gdtc->thresh) || strictlimit);",
            "",
            "\t\twb_position_ratio(gdtc);",
            "\t\tsdtc = gdtc;",
            "",
            "\t\tif (mdtc) {",
            "\t\t\t/*",
            "\t\t\t * If memcg domain is in effect, calculate its",
            "\t\t\t * pos_ratio.  @wb should satisfy constraints from",
            "\t\t\t * both global and memcg domains.  Choose the one",
            "\t\t\t * w/ lower pos_ratio.",
            "\t\t\t */",
            "\t\t\tif (!strictlimit) {",
            "\t\t\t\twb_dirty_limits(mdtc);",
            "",
            "\t\t\t\tif ((current->flags & PF_LOCAL_THROTTLE) &&",
            "\t\t\t\t    mdtc->wb_dirty <",
            "\t\t\t\t    dirty_freerun_ceiling(mdtc->wb_thresh,",
            "\t\t\t\t\t\t\t  mdtc->wb_bg_thresh))",
            "\t\t\t\t\t/*",
            "\t\t\t\t\t * LOCAL_THROTTLE tasks must not be",
            "\t\t\t\t\t * throttled when below the per-wb",
            "\t\t\t\t\t * freerun ceiling.",
            "\t\t\t\t\t */",
            "\t\t\t\t\tgoto free_running;",
            "\t\t\t}",
            "\t\t\tdirty_exceeded |= (mdtc->wb_dirty > mdtc->wb_thresh) &&",
            "\t\t\t\t((mdtc->dirty > mdtc->thresh) || strictlimit);",
            "",
            "\t\t\twb_position_ratio(mdtc);",
            "\t\t\tif (mdtc->pos_ratio < gdtc->pos_ratio)",
            "\t\t\t\tsdtc = mdtc;",
            "\t\t}",
            "",
            "\t\tif (dirty_exceeded != wb->dirty_exceeded)",
            "\t\t\twb->dirty_exceeded = dirty_exceeded;",
            "",
            "\t\tif (time_is_before_jiffies(READ_ONCE(wb->bw_time_stamp) +",
            "\t\t\t\t\t   BANDWIDTH_INTERVAL))",
            "\t\t\t__wb_update_bandwidth(gdtc, mdtc, true);",
            "",
            "\t\t/* throttle according to the chosen dtc */",
            "\t\tdirty_ratelimit = READ_ONCE(wb->dirty_ratelimit);",
            "\t\ttask_ratelimit = ((u64)dirty_ratelimit * sdtc->pos_ratio) >>",
            "\t\t\t\t\t\t\tRATELIMIT_CALC_SHIFT;",
            "\t\tmax_pause = wb_max_pause(wb, sdtc->wb_dirty);",
            "\t\tmin_pause = wb_min_pause(wb, max_pause,",
            "\t\t\t\t\t task_ratelimit, dirty_ratelimit,",
            "\t\t\t\t\t &nr_dirtied_pause);",
            "",
            "\t\tif (unlikely(task_ratelimit == 0)) {",
            "\t\t\tperiod = max_pause;",
            "\t\t\tpause = max_pause;",
            "\t\t\tgoto pause;",
            "\t\t}",
            "\t\tperiod = HZ * pages_dirtied / task_ratelimit;",
            "\t\tpause = period;",
            "\t\tif (current->dirty_paused_when)",
            "\t\t\tpause -= now - current->dirty_paused_when;",
            "\t\t/*",
            "\t\t * For less than 1s think time (ext3/4 may block the dirtier",
            "\t\t * for up to 800ms from time to time on 1-HDD; so does xfs,",
            "\t\t * however at much less frequency), try to compensate it in",
            "\t\t * future periods by updating the virtual time; otherwise just",
            "\t\t * do a reset, as it may be a light dirtier.",
            "\t\t */",
            "\t\tif (pause < min_pause) {",
            "\t\t\ttrace_balance_dirty_pages(wb,",
            "\t\t\t\t\t\t  sdtc->thresh,",
            "\t\t\t\t\t\t  sdtc->bg_thresh,",
            "\t\t\t\t\t\t  sdtc->dirty,",
            "\t\t\t\t\t\t  sdtc->wb_thresh,",
            "\t\t\t\t\t\t  sdtc->wb_dirty,",
            "\t\t\t\t\t\t  dirty_ratelimit,",
            "\t\t\t\t\t\t  task_ratelimit,",
            "\t\t\t\t\t\t  pages_dirtied,",
            "\t\t\t\t\t\t  period,",
            "\t\t\t\t\t\t  min(pause, 0L),",
            "\t\t\t\t\t\t  start_time);",
            "\t\t\tif (pause < -HZ) {",
            "\t\t\t\tcurrent->dirty_paused_when = now;",
            "\t\t\t\tcurrent->nr_dirtied = 0;",
            "\t\t\t} else if (period) {",
            "\t\t\t\tcurrent->dirty_paused_when += period;",
            "\t\t\t\tcurrent->nr_dirtied = 0;",
            "\t\t\t} else if (current->nr_dirtied_pause <= pages_dirtied)",
            "\t\t\t\tcurrent->nr_dirtied_pause += pages_dirtied;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (unlikely(pause > max_pause)) {",
            "\t\t\t/* for occasional dropped task_ratelimit */",
            "\t\t\tnow += min(pause - max_pause, max_pause);",
            "\t\t\tpause = max_pause;",
            "\t\t}",
            "",
            "pause:",
            "\t\ttrace_balance_dirty_pages(wb,",
            "\t\t\t\t\t  sdtc->thresh,",
            "\t\t\t\t\t  sdtc->bg_thresh,",
            "\t\t\t\t\t  sdtc->dirty,",
            "\t\t\t\t\t  sdtc->wb_thresh,",
            "\t\t\t\t\t  sdtc->wb_dirty,",
            "\t\t\t\t\t  dirty_ratelimit,",
            "\t\t\t\t\t  task_ratelimit,",
            "\t\t\t\t\t  pages_dirtied,",
            "\t\t\t\t\t  period,",
            "\t\t\t\t\t  pause,",
            "\t\t\t\t\t  start_time);",
            "\t\tif (flags & BDP_ASYNC) {",
            "\t\t\tret = -EAGAIN;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t__set_current_state(TASK_KILLABLE);",
            "\t\tbdi->last_bdp_sleep = jiffies;",
            "\t\tio_schedule_timeout(pause);",
            "",
            "\t\tcurrent->dirty_paused_when = now + pause;",
            "\t\tcurrent->nr_dirtied = 0;",
            "\t\tcurrent->nr_dirtied_pause = nr_dirtied_pause;",
            "",
            "\t\t/*",
            "\t\t * This is typically equal to (dirty < thresh) and can also",
            "\t\t * keep \"1000+ dd on a slow USB stick\" under control.",
            "\t\t */",
            "\t\tif (task_ratelimit)",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * In the case of an unresponsive NFS server and the NFS dirty",
            "\t\t * pages exceeds dirty_thresh, give the other good wb's a pipe",
            "\t\t * to go through, so that tasks on them still remain responsive.",
            "\t\t *",
            "\t\t * In theory 1 page is enough to keep the consumer-producer",
            "\t\t * pipe going: the flusher cleans 1 page => the task dirties 1",
            "\t\t * more page. However wb_dirty has accounting errors.  So use",
            "\t\t * the larger and more IO friendly wb_stat_error.",
            "\t\t */",
            "\t\tif (sdtc->wb_dirty <= wb_stat_error())",
            "\t\t\tbreak;",
            "",
            "\t\tif (fatal_signal_pending(current))",
            "\t\t\tbreak;",
            "\t}",
            "\treturn ret;",
            "}"
          ],
          "function_name": "wb_dirty_limits, balance_dirty_pages",
          "description": "实现脏页管理核心逻辑，包含确定当前脏页限制的计算函数和脏页平衡主函数，通过多级阈值检测、动态速率限制、暂停时间控制等机制，在保证系统响应性的同时防止内存过载，支持严格限制模式下的特殊处理。",
          "similarity": 0.6422407627105713
        },
        {
          "chunk_id": 4,
          "file_path": "mm/page-writeback.c",
          "start_line": 615,
          "end_line": 719,
          "content": [
            "void wb_writeout_inc(struct bdi_writeback *wb)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "\t__wb_writeout_add(wb, 1);",
            "\tlocal_irq_restore(flags);",
            "}",
            "static void writeout_period(struct timer_list *t)",
            "{",
            "\tstruct wb_domain *dom = from_timer(dom, t, period_timer);",
            "\tint miss_periods = (jiffies - dom->period_time) /",
            "\t\t\t\t\t\t VM_COMPLETIONS_PERIOD_LEN;",
            "",
            "\tif (fprop_new_period(&dom->completions, miss_periods + 1)) {",
            "\t\tdom->period_time = wp_next_time(dom->period_time +",
            "\t\t\t\tmiss_periods * VM_COMPLETIONS_PERIOD_LEN);",
            "\t\tmod_timer(&dom->period_timer, dom->period_time);",
            "\t} else {",
            "\t\t/*",
            "\t\t * Aging has zeroed all fractions. Stop wasting CPU on period",
            "\t\t * updates.",
            "\t\t */",
            "\t\tdom->period_time = 0;",
            "\t}",
            "}",
            "int wb_domain_init(struct wb_domain *dom, gfp_t gfp)",
            "{",
            "\tmemset(dom, 0, sizeof(*dom));",
            "",
            "\tspin_lock_init(&dom->lock);",
            "",
            "\ttimer_setup(&dom->period_timer, writeout_period, TIMER_DEFERRABLE);",
            "",
            "\tdom->dirty_limit_tstamp = jiffies;",
            "",
            "\treturn fprop_global_init(&dom->completions, gfp);",
            "}",
            "void wb_domain_exit(struct wb_domain *dom)",
            "{",
            "\tdel_timer_sync(&dom->period_timer);",
            "\tfprop_global_destroy(&dom->completions);",
            "}",
            "static int bdi_check_pages_limit(unsigned long pages)",
            "{",
            "\tunsigned long max_dirty_pages = global_dirtyable_memory();",
            "",
            "\tif (pages > max_dirty_pages)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static unsigned long bdi_ratio_from_pages(unsigned long pages)",
            "{",
            "\tunsigned long background_thresh;",
            "\tunsigned long dirty_thresh;",
            "\tunsigned long ratio;",
            "",
            "\tglobal_dirty_limits(&background_thresh, &dirty_thresh);",
            "\tratio = div64_u64(pages * 100ULL * BDI_RATIO_SCALE, dirty_thresh);",
            "",
            "\treturn ratio;",
            "}",
            "static u64 bdi_get_bytes(unsigned int ratio)",
            "{",
            "\tunsigned long background_thresh;",
            "\tunsigned long dirty_thresh;",
            "\tu64 bytes;",
            "",
            "\tglobal_dirty_limits(&background_thresh, &dirty_thresh);",
            "\tbytes = (dirty_thresh * PAGE_SIZE * ratio) / BDI_RATIO_SCALE / 100;",
            "",
            "\treturn bytes;",
            "}",
            "static int __bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)",
            "{",
            "\tunsigned int delta;",
            "\tint ret = 0;",
            "",
            "\tif (min_ratio > 100 * BDI_RATIO_SCALE)",
            "\t\treturn -EINVAL;",
            "\tmin_ratio *= BDI_RATIO_SCALE;",
            "",
            "\tspin_lock_bh(&bdi_lock);",
            "\tif (min_ratio > bdi->max_ratio) {",
            "\t\tret = -EINVAL;",
            "\t} else {",
            "\t\tif (min_ratio < bdi->min_ratio) {",
            "\t\t\tdelta = bdi->min_ratio - min_ratio;",
            "\t\t\tbdi_min_ratio -= delta;",
            "\t\t\tbdi->min_ratio = min_ratio;",
            "\t\t} else {",
            "\t\t\tdelta = min_ratio - bdi->min_ratio;",
            "\t\t\tif (bdi_min_ratio + delta < 100 * BDI_RATIO_SCALE) {",
            "\t\t\t\tbdi_min_ratio += delta;",
            "\t\t\t\tbdi->min_ratio = min_ratio;",
            "\t\t\t} else {",
            "\t\t\t\tret = -EINVAL;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tspin_unlock_bh(&bdi_lock);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "wb_writeout_inc, writeout_period, wb_domain_init, wb_domain_exit, bdi_check_pages_limit, bdi_ratio_from_pages, bdi_get_bytes, __bdi_set_min_ratio",
          "description": "实现写回统计增量记录、定时器驱动的写回周期校准及内存设备（bdi）的脏页限制验证与参数转换逻辑，支撑动态写回策略调整。",
          "similarity": 0.6254790425300598
        },
        {
          "chunk_id": 3,
          "file_path": "mm/page-writeback.c",
          "start_line": 495,
          "end_line": 600,
          "content": [
            "bool node_dirty_ok(struct pglist_data *pgdat)",
            "{",
            "\tunsigned long limit = node_dirty_limit(pgdat);",
            "\tunsigned long nr_pages = 0;",
            "",
            "\tnr_pages += node_page_state(pgdat, NR_FILE_DIRTY);",
            "\tnr_pages += node_page_state(pgdat, NR_WRITEBACK);",
            "",
            "\treturn nr_pages <= limit;",
            "}",
            "static int dirty_background_ratio_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint ret;",
            "",
            "\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\tif (ret == 0 && write)",
            "\t\tdirty_background_bytes = 0;",
            "\treturn ret;",
            "}",
            "static int dirty_background_bytes_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint ret;",
            "\tunsigned long old_bytes = dirty_background_bytes;",
            "",
            "\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);",
            "\tif (ret == 0 && write) {",
            "\t\tif (DIV_ROUND_UP(dirty_background_bytes, PAGE_SIZE) >",
            "\t\t\t\t\t\t\t\tUINT_MAX) {",
            "\t\t\tdirty_background_bytes = old_bytes;",
            "\t\t\treturn -ERANGE;",
            "\t\t}",
            "\t\tdirty_background_ratio = 0;",
            "\t}",
            "\treturn ret;",
            "}",
            "static int dirty_ratio_handler(struct ctl_table *table, int write, void *buffer,",
            "\t\tsize_t *lenp, loff_t *ppos)",
            "{",
            "\tint old_ratio = vm_dirty_ratio;",
            "\tint ret;",
            "",
            "\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);",
            "\tif (ret == 0 && write && vm_dirty_ratio != old_ratio) {",
            "\t\tvm_dirty_bytes = 0;",
            "\t\twriteback_set_ratelimit();",
            "\t}",
            "\treturn ret;",
            "}",
            "static int dirty_bytes_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tunsigned long old_bytes = vm_dirty_bytes;",
            "\tint ret;",
            "",
            "\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);",
            "\tif (ret == 0 && write && vm_dirty_bytes != old_bytes) {",
            "\t\tif (DIV_ROUND_UP(vm_dirty_bytes, PAGE_SIZE) > UINT_MAX) {",
            "\t\t\tvm_dirty_bytes = old_bytes;",
            "\t\t\treturn -ERANGE;",
            "\t\t}",
            "\t\twriteback_set_ratelimit();",
            "\t\tvm_dirty_ratio = 0;",
            "\t}",
            "\treturn ret;",
            "}",
            "static unsigned long wp_next_time(unsigned long cur_time)",
            "{",
            "\tcur_time += VM_COMPLETIONS_PERIOD_LEN;",
            "\t/* 0 has a special meaning... */",
            "\tif (!cur_time)",
            "\t\treturn 1;",
            "\treturn cur_time;",
            "}",
            "static void wb_domain_writeout_add(struct wb_domain *dom,",
            "\t\t\t\t   struct fprop_local_percpu *completions,",
            "\t\t\t\t   unsigned int max_prop_frac, long nr)",
            "{",
            "\t__fprop_add_percpu_max(&dom->completions, completions,",
            "\t\t\t       max_prop_frac, nr);",
            "\t/* First event after period switching was turned off? */",
            "\tif (unlikely(!dom->period_time)) {",
            "\t\t/*",
            "\t\t * We can race with other __bdi_writeout_inc calls here but",
            "\t\t * it does not cause any harm since the resulting time when",
            "\t\t * timer will fire and what is in writeout_period_time will be",
            "\t\t * roughly the same.",
            "\t\t */",
            "\t\tdom->period_time = wp_next_time(jiffies);",
            "\t\tmod_timer(&dom->period_timer, dom->period_time);",
            "\t}",
            "}",
            "static inline void __wb_writeout_add(struct bdi_writeback *wb, long nr)",
            "{",
            "\tstruct wb_domain *cgdom;",
            "",
            "\twb_stat_mod(wb, WB_WRITTEN, nr);",
            "\twb_domain_writeout_add(&global_wb_domain, &wb->completions,",
            "\t\t\t       wb->bdi->max_prop_frac, nr);",
            "",
            "\tcgdom = mem_cgroup_wb_domain(wb);",
            "\tif (cgdom)",
            "\t\twb_domain_writeout_add(cgdom, wb_memcg_completions(wb),",
            "\t\t\t\t       wb->bdi->max_prop_frac, nr);",
            "}"
          ],
          "function_name": "node_dirty_ok, dirty_background_ratio_handler, dirty_background_bytes_handler, dirty_ratio_handler, dirty_bytes_handler, wp_next_time, wb_domain_writeout_add, __wb_writeout_add",
          "description": "通过sysctl接口动态调整脏页写回参数，维护写回统计信息并周期性触发写回检查，确保系统内存使用符合预设策略。",
          "similarity": 0.6208401322364807
        },
        {
          "chunk_id": 6,
          "file_path": "mm/page-writeback.c",
          "start_line": 883,
          "end_line": 1126,
          "content": [
            "static unsigned long __wb_calc_thresh(struct dirty_throttle_control *dtc)",
            "{",
            "\tstruct wb_domain *dom = dtc_dom(dtc);",
            "\tunsigned long thresh = dtc->thresh;",
            "\tu64 wb_thresh;",
            "\tunsigned long numerator, denominator;",
            "\tunsigned long wb_min_ratio, wb_max_ratio;",
            "",
            "\t/*",
            "\t * Calculate this BDI's share of the thresh ratio.",
            "\t */",
            "\tfprop_fraction_percpu(&dom->completions, dtc->wb_completions,",
            "\t\t\t      &numerator, &denominator);",
            "",
            "\twb_thresh = (thresh * (100 * BDI_RATIO_SCALE - bdi_min_ratio)) / (100 * BDI_RATIO_SCALE);",
            "\twb_thresh *= numerator;",
            "\twb_thresh = div64_ul(wb_thresh, denominator);",
            "",
            "\twb_min_max_ratio(dtc->wb, &wb_min_ratio, &wb_max_ratio);",
            "",
            "\twb_thresh += (thresh * wb_min_ratio) / (100 * BDI_RATIO_SCALE);",
            "\tif (wb_thresh > (thresh * wb_max_ratio) / (100 * BDI_RATIO_SCALE))",
            "\t\twb_thresh = thresh * wb_max_ratio / (100 * BDI_RATIO_SCALE);",
            "",
            "\treturn wb_thresh;",
            "}",
            "unsigned long wb_calc_thresh(struct bdi_writeback *wb, unsigned long thresh)",
            "{",
            "\tstruct dirty_throttle_control gdtc = { GDTC_INIT(wb),",
            "\t\t\t\t\t       .thresh = thresh };",
            "\treturn __wb_calc_thresh(&gdtc);",
            "}",
            "unsigned long cgwb_calc_thresh(struct bdi_writeback *wb)",
            "{",
            "\tstruct dirty_throttle_control gdtc = { GDTC_INIT_NO_WB };",
            "\tstruct dirty_throttle_control mdtc = { MDTC_INIT(wb, &gdtc) };",
            "\tunsigned long filepages = 0, headroom = 0, writeback = 0;",
            "",
            "\tgdtc.avail = global_dirtyable_memory();",
            "\tgdtc.dirty = global_node_page_state(NR_FILE_DIRTY) +",
            "\t\t     global_node_page_state(NR_WRITEBACK);",
            "",
            "\tmem_cgroup_wb_stats(wb, &filepages, &headroom,",
            "\t\t\t    &mdtc.dirty, &writeback);",
            "\tmdtc.dirty += writeback;",
            "\tmdtc_calc_avail(&mdtc, filepages, headroom);",
            "\tdomain_dirty_limits(&mdtc);",
            "",
            "\treturn __wb_calc_thresh(&mdtc);",
            "}",
            "static long long pos_ratio_polynom(unsigned long setpoint,",
            "\t\t\t\t\t  unsigned long dirty,",
            "\t\t\t\t\t  unsigned long limit)",
            "{",
            "\tlong long pos_ratio;",
            "\tlong x;",
            "",
            "\tx = div64_s64(((s64)setpoint - (s64)dirty) << RATELIMIT_CALC_SHIFT,",
            "\t\t      (limit - setpoint) | 1);",
            "\tpos_ratio = x;",
            "\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;",
            "\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;",
            "\tpos_ratio += 1 << RATELIMIT_CALC_SHIFT;",
            "",
            "\treturn clamp(pos_ratio, 0LL, 2LL << RATELIMIT_CALC_SHIFT);",
            "}",
            "static void wb_position_ratio(struct dirty_throttle_control *dtc)",
            "{",
            "\tstruct bdi_writeback *wb = dtc->wb;",
            "\tunsigned long write_bw = READ_ONCE(wb->avg_write_bandwidth);",
            "\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);",
            "\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);",
            "\tunsigned long wb_thresh = dtc->wb_thresh;",
            "\tunsigned long x_intercept;",
            "\tunsigned long setpoint;\t\t/* dirty pages' target balance point */",
            "\tunsigned long wb_setpoint;",
            "\tunsigned long span;",
            "\tlong long pos_ratio;\t\t/* for scaling up/down the rate limit */",
            "\tlong x;",
            "",
            "\tdtc->pos_ratio = 0;",
            "",
            "\tif (unlikely(dtc->dirty >= limit))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * global setpoint",
            "\t *",
            "\t * See comment for pos_ratio_polynom().",
            "\t */",
            "\tsetpoint = (freerun + limit) / 2;",
            "\tpos_ratio = pos_ratio_polynom(setpoint, dtc->dirty, limit);",
            "",
            "\t/*",
            "\t * The strictlimit feature is a tool preventing mistrusted filesystems",
            "\t * from growing a large number of dirty pages before throttling. For",
            "\t * such filesystems balance_dirty_pages always checks wb counters",
            "\t * against wb limits. Even if global \"nr_dirty\" is under \"freerun\".",
            "\t * This is especially important for fuse which sets bdi->max_ratio to",
            "\t * 1% by default. Without strictlimit feature, fuse writeback may",
            "\t * consume arbitrary amount of RAM because it is accounted in",
            "\t * NR_WRITEBACK_TEMP which is not involved in calculating \"nr_dirty\".",
            "\t *",
            "\t * Here, in wb_position_ratio(), we calculate pos_ratio based on",
            "\t * two values: wb_dirty and wb_thresh. Let's consider an example:",
            "\t * total amount of RAM is 16GB, bdi->max_ratio is equal to 1%, global",
            "\t * limits are set by default to 10% and 20% (background and throttle).",
            "\t * Then wb_thresh is 1% of 20% of 16GB. This amounts to ~8K pages.",
            "\t * wb_calc_thresh(wb, bg_thresh) is about ~4K pages. wb_setpoint is",
            "\t * about ~6K pages (as the average of background and throttle wb",
            "\t * limits). The 3rd order polynomial will provide positive feedback if",
            "\t * wb_dirty is under wb_setpoint and vice versa.",
            "\t *",
            "\t * Note, that we cannot use global counters in these calculations",
            "\t * because we want to throttle process writing to a strictlimit wb",
            "\t * much earlier than global \"freerun\" is reached (~23MB vs. ~2.3GB",
            "\t * in the example above).",
            "\t */",
            "\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {",
            "\t\tlong long wb_pos_ratio;",
            "",
            "\t\tif (dtc->wb_dirty < 8) {",
            "\t\t\tdtc->pos_ratio = min_t(long long, pos_ratio * 2,",
            "\t\t\t\t\t   2 << RATELIMIT_CALC_SHIFT);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tif (dtc->wb_dirty >= wb_thresh)",
            "\t\t\treturn;",
            "",
            "\t\twb_setpoint = dirty_freerun_ceiling(wb_thresh,",
            "\t\t\t\t\t\t    dtc->wb_bg_thresh);",
            "",
            "\t\tif (wb_setpoint == 0 || wb_setpoint == wb_thresh)",
            "\t\t\treturn;",
            "",
            "\t\twb_pos_ratio = pos_ratio_polynom(wb_setpoint, dtc->wb_dirty,",
            "\t\t\t\t\t\t wb_thresh);",
            "",
            "\t\t/*",
            "\t\t * Typically, for strictlimit case, wb_setpoint << setpoint",
            "\t\t * and pos_ratio >> wb_pos_ratio. In the other words global",
            "\t\t * state (\"dirty\") is not limiting factor and we have to",
            "\t\t * make decision based on wb counters. But there is an",
            "\t\t * important case when global pos_ratio should get precedence:",
            "\t\t * global limits are exceeded (e.g. due to activities on other",
            "\t\t * wb's) while given strictlimit wb is below limit.",
            "\t\t *",
            "\t\t * \"pos_ratio * wb_pos_ratio\" would work for the case above,",
            "\t\t * but it would look too non-natural for the case of all",
            "\t\t * activity in the system coming from a single strictlimit wb",
            "\t\t * with bdi->max_ratio == 100%.",
            "\t\t *",
            "\t\t * Note that min() below somewhat changes the dynamics of the",
            "\t\t * control system. Normally, pos_ratio value can be well over 3",
            "\t\t * (when globally we are at freerun and wb is well below wb",
            "\t\t * setpoint). Now the maximum pos_ratio in the same situation",
            "\t\t * is 2. We might want to tweak this if we observe the control",
            "\t\t * system is too slow to adapt.",
            "\t\t */",
            "\t\tdtc->pos_ratio = min(pos_ratio, wb_pos_ratio);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * We have computed basic pos_ratio above based on global situation. If",
            "\t * the wb is over/under its share of dirty pages, we want to scale",
            "\t * pos_ratio further down/up. That is done by the following mechanism.",
            "\t */",
            "",
            "\t/*",
            "\t * wb setpoint",
            "\t *",
            "\t *        f(wb_dirty) := 1.0 + k * (wb_dirty - wb_setpoint)",
            "\t *",
            "\t *                        x_intercept - wb_dirty",
            "\t *                     := --------------------------",
            "\t *                        x_intercept - wb_setpoint",
            "\t *",
            "\t * The main wb control line is a linear function that subjects to",
            "\t *",
            "\t * (1) f(wb_setpoint) = 1.0",
            "\t * (2) k = - 1 / (8 * write_bw)  (in single wb case)",
            "\t *     or equally: x_intercept = wb_setpoint + 8 * write_bw",
            "\t *",
            "\t * For single wb case, the dirty pages are observed to fluctuate",
            "\t * regularly within range",
            "\t *        [wb_setpoint - write_bw/2, wb_setpoint + write_bw/2]",
            "\t * for various filesystems, where (2) can yield in a reasonable 12.5%",
            "\t * fluctuation range for pos_ratio.",
            "\t *",
            "\t * For JBOD case, wb_thresh (not wb_dirty!) could fluctuate up to its",
            "\t * own size, so move the slope over accordingly and choose a slope that",
            "\t * yields 100% pos_ratio fluctuation on suddenly doubled wb_thresh.",
            "\t */",
            "\tif (unlikely(wb_thresh > dtc->thresh))",
            "\t\twb_thresh = dtc->thresh;",
            "\t/*",
            "\t * It's very possible that wb_thresh is close to 0 not because the",
            "\t * device is slow, but that it has remained inactive for long time.",
            "\t * Honour such devices a reasonable good (hopefully IO efficient)",
            "\t * threshold, so that the occasional writes won't be blocked and active",
            "\t * writes can rampup the threshold quickly.",
            "\t */",
            "\twb_thresh = max(wb_thresh, (limit - dtc->dirty) / 8);",
            "\t/*",
            "\t * scale global setpoint to wb's:",
            "\t *\twb_setpoint = setpoint * wb_thresh / thresh",
            "\t */",
            "\tx = div_u64((u64)wb_thresh << 16, dtc->thresh | 1);",
            "\twb_setpoint = setpoint * (u64)x >> 16;",
            "\t/*",
            "\t * Use span=(8*write_bw) in single wb case as indicated by",
            "\t * (thresh - wb_thresh ~= 0) and transit to wb_thresh in JBOD case.",
            "\t *",
            "\t *        wb_thresh                    thresh - wb_thresh",
            "\t * span = --------- * (8 * write_bw) + ------------------ * wb_thresh",
            "\t *         thresh                           thresh",
            "\t */",
            "\tspan = (dtc->thresh - wb_thresh + 8 * write_bw) * (u64)x >> 16;",
            "\tx_intercept = wb_setpoint + span;",
            "",
            "\tif (dtc->wb_dirty < x_intercept - span / 4) {",
            "\t\tpos_ratio = div64_u64(pos_ratio * (x_intercept - dtc->wb_dirty),",
            "\t\t\t\t      (x_intercept - wb_setpoint) | 1);",
            "\t} else",
            "\t\tpos_ratio /= 4;",
            "",
            "\t/*",
            "\t * wb reserve area, safeguard against dirty pool underrun and disk idle",
            "\t * It may push the desired control point of global dirty pages higher",
            "\t * than setpoint.",
            "\t */",
            "\tx_intercept = wb_thresh / 2;",
            "\tif (dtc->wb_dirty < x_intercept) {",
            "\t\tif (dtc->wb_dirty > x_intercept / 8)",
            "\t\t\tpos_ratio = div_u64(pos_ratio * x_intercept,",
            "\t\t\t\t\t    dtc->wb_dirty);",
            "\t\telse",
            "\t\t\tpos_ratio *= 8;",
            "\t}",
            "",
            "\tdtc->pos_ratio = pos_ratio;",
            "}"
          ],
          "function_name": "__wb_calc_thresh, wb_calc_thresh, cgwb_calc_thresh, pos_ratio_polynom, wb_position_ratio",
          "description": "实现基于脏页阈值的动态调节算法，包含计算全局和内存控制组的脏页阈值、基于多项式的位置比值计算、根据写入带宽和当前脏页状态调整控制参数等功能，通过多级阈值和反馈机制平衡系统负载。",
          "similarity": 0.6128475666046143
        },
        {
          "chunk_id": 12,
          "file_path": "mm/page-writeback.c",
          "start_line": 2574,
          "end_line": 2681,
          "content": [
            "static int writepage_cb(struct folio *folio, struct writeback_control *wbc,",
            "\t\tvoid *data)",
            "{",
            "\tstruct address_space *mapping = data;",
            "\tint ret = mapping->a_ops->writepage(&folio->page, wbc);",
            "\tmapping_set_error(mapping, ret);",
            "\treturn ret;",
            "}",
            "int do_writepages(struct address_space *mapping, struct writeback_control *wbc)",
            "{",
            "\tint ret;",
            "\tstruct bdi_writeback *wb;",
            "",
            "\tif (wbc->nr_to_write <= 0)",
            "\t\treturn 0;",
            "\twb = inode_to_wb_wbc(mapping->host, wbc);",
            "\twb_bandwidth_estimate_start(wb);",
            "\twhile (1) {",
            "\t\tif (mapping->a_ops->writepages) {",
            "\t\t\tret = mapping->a_ops->writepages(mapping, wbc);",
            "\t\t} else if (mapping->a_ops->writepage) {",
            "\t\t\tstruct blk_plug plug;",
            "",
            "\t\t\tblk_start_plug(&plug);",
            "\t\t\tret = write_cache_pages(mapping, wbc, writepage_cb,",
            "\t\t\t\t\t\tmapping);",
            "\t\t\tblk_finish_plug(&plug);",
            "\t\t} else {",
            "\t\t\t/* deal with chardevs and other special files */",
            "\t\t\tret = 0;",
            "\t\t}",
            "\t\tif (ret != -ENOMEM || wbc->sync_mode != WB_SYNC_ALL)",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * Lacking an allocation context or the locality or writeback",
            "\t\t * state of any of the inode's pages, throttle based on",
            "\t\t * writeback activity on the local node. It's as good a",
            "\t\t * guess as any.",
            "\t\t */",
            "\t\treclaim_throttle(NODE_DATA(numa_node_id()),",
            "\t\t\tVMSCAN_THROTTLE_WRITEBACK);",
            "\t}",
            "\t/*",
            "\t * Usually few pages are written by now from those we've just submitted",
            "\t * but if there's constant writeback being submitted, this makes sure",
            "\t * writeback bandwidth is updated once in a while.",
            "\t */",
            "\tif (time_is_before_jiffies(READ_ONCE(wb->bw_time_stamp) +",
            "\t\t\t\t   BANDWIDTH_INTERVAL))",
            "\t\twb_update_bandwidth(wb);",
            "\treturn ret;",
            "}",
            "bool noop_dirty_folio(struct address_space *mapping, struct folio *folio)",
            "{",
            "\tif (!folio_test_dirty(folio))",
            "\t\treturn !folio_test_set_dirty(folio);",
            "\treturn false;",
            "}",
            "static void folio_account_dirtied(struct folio *folio,",
            "\t\tstruct address_space *mapping)",
            "{",
            "\tstruct inode *inode = mapping->host;",
            "",
            "\ttrace_writeback_dirty_folio(folio, mapping);",
            "",
            "\tif (mapping_can_writeback(mapping)) {",
            "\t\tstruct bdi_writeback *wb;",
            "\t\tlong nr = folio_nr_pages(folio);",
            "",
            "\t\tinode_attach_wb(inode, folio);",
            "\t\twb = inode_to_wb(inode);",
            "",
            "\t\t__lruvec_stat_mod_folio(folio, NR_FILE_DIRTY, nr);",
            "\t\t__zone_stat_mod_folio(folio, NR_ZONE_WRITE_PENDING, nr);",
            "\t\t__node_stat_mod_folio(folio, NR_DIRTIED, nr);",
            "\t\twb_stat_mod(wb, WB_RECLAIMABLE, nr);",
            "\t\twb_stat_mod(wb, WB_DIRTIED, nr);",
            "\t\ttask_io_account_write(nr * PAGE_SIZE);",
            "\t\tcurrent->nr_dirtied += nr;",
            "\t\t__this_cpu_add(bdp_ratelimits, nr);",
            "",
            "\t\tmem_cgroup_track_foreign_dirty(folio, wb);",
            "\t}",
            "}",
            "void folio_account_cleaned(struct folio *folio, struct bdi_writeback *wb)",
            "{",
            "\tlong nr = folio_nr_pages(folio);",
            "",
            "\tlruvec_stat_mod_folio(folio, NR_FILE_DIRTY, -nr);",
            "\tzone_stat_mod_folio(folio, NR_ZONE_WRITE_PENDING, -nr);",
            "\twb_stat_mod(wb, WB_RECLAIMABLE, -nr);",
            "\ttask_io_account_cancelled_write(nr * PAGE_SIZE);",
            "}",
            "void __folio_mark_dirty(struct folio *folio, struct address_space *mapping,",
            "\t\t\t     int warn)",
            "{",
            "\tunsigned long flags;",
            "",
            "\txa_lock_irqsave(&mapping->i_pages, flags);",
            "\tif (folio->mapping) {\t/* Race with truncate? */",
            "\t\tWARN_ON_ONCE(warn && !folio_test_uptodate(folio));",
            "\t\tfolio_account_dirtied(folio, mapping);",
            "\t\t__xa_set_mark(&mapping->i_pages, folio_index(folio),",
            "\t\t\t\tPAGECACHE_TAG_DIRTY);",
            "\t}",
            "\txa_unlock_irqrestore(&mapping->i_pages, flags);",
            "}"
          ],
          "function_name": "writepage_cb, do_writepages, noop_dirty_folio, folio_account_dirtied, folio_account_cleaned, __folio_mark_dirty",
          "description": "writepage_cb 调用文件系统的writepage接口。do_writepages 执行批量写回操作，处理不同写回场景。noop_dirty_folio 默认处理脏页标记。folio_account_dirtied 和 folio_account_cleaned 维护脏页统计信息。__folio_mark_dirty 标记页面为脏状态。",
          "similarity": 0.6105800867080688
        }
      ]
    },
    {
      "source_file": "mm/swap.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:25:49\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `swap.c`\n\n---\n\n# swap.c 技术文档\n\n## 1. 文件概述\n\n`swap.c` 是 Linux 内核内存管理子系统（MM）中的核心文件之一，主要负责页面回收（page reclaim）、LRU（Least Recently Used）链表管理、页面释放以及与交换（swap）机制相关的底层支持逻辑。尽管文件名为 `swap.c`，但其功能不仅限于交换，而是涵盖了通用的页面生命周期管理、LRU 链表操作、页面引用计数释放、可回收性判断等关键内存管理任务。该文件为页面缓存（page cache）、匿名页（anonymous pages）和大页（huge pages）提供统一的释放与 LRU 管理接口。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `page_cluster`：控制一次 I/O 操作中尝试换入/换出的页面数量（以 2 的幂表示），默认值由系统配置决定。\n- `page_cluster_max`：`page_cluster` 的最大允许值（31，即最多 2^31 页，实际受架构限制）。\n\n### 主要数据结构\n- `struct lru_rotate`：每个 CPU 私有的结构，用于在中断禁用上下文中批量处理需移至 LRU 链表尾部的页面（如 `folio_rotate_reclaimable` 场景）。\n- `struct cpu_fbatches`：每个 CPU 私有的 folio 批处理结构，包含多个 folio_batch，用于高效地向 LRU 链表添加、停用或激活页面，避免频繁获取 LRU 锁。\n\n### 主要函数\n- `__folio_put()`：释放一个 folio 的核心函数，根据 folio 类型（设备内存、大页、普通页）调用相应的释放路径。\n- `put_pages_list()`：批量释放通过 `lru` 字段链接的页面列表，常用于网络子系统或 compound page 释放。\n- `lru_add_fn()`：将 folio 添加到对应 LRU 链表的回调函数，处理可回收性（evictable/unevictable）状态转换和统计计数。\n- `folio_batch_move_lru()`：批量执行 LRU 操作（如添加、移动），在持有 LRU 锁期间完成所有 folio 的处理。\n- `folio_rotate_reclaimable()`：在写回完成后，若页面仍可回收，则将其移至 inactive LRU 链表尾部，以延迟其被回收的时间。\n- `lru_note_cost()`：记录 LRU 扫描过程中的 I/O 和旋转（rotation）成本，用于后续调整 anon/file LRU 的扫描比例。\n\n## 3. 关键实现\n\n### LRU 批处理机制\n为减少 LRU 锁竞争，内核采用 per-CPU 批处理（`folio_batch`）方式暂存待处理的 folio。当批处理满或遇到大页（`folio_test_large`）时，才批量获取 LRU 锁并执行操作（如 `lru_add_fn`）。这显著提升了高并发场景下的性能。\n\n### 可回收性管理\n页面是否可回收由 `folio_evictable()` 判断，主要依据是否被 mlock 锁定。在添加到 LRU 时：\n- 若页面变为可回收（原为 unevictable），则增加 `UNEVICTABLE_PGRESCUED` 统计；\n- 若页面不可回收，则清除 active 标志，设置 unevictable 标志，并重置 `mlock_count`，同时增加 `UNEVICTABLE_PGCULLED` 统计。\n\n### 页面释放路径\n`__folio_put()` 是 folio 引用计数归零后的释放入口：\n1. 设备内存 folio 调用 `free_zone_device_folio()`\n2. 大页 folio 调用 `free_huge_folio()`\n3. 普通 folio 先从 LRU 移除（若在 LRU 上），然后解绑内存控制组（memcg），最后调用 `free_unref_page()` 释放到伙伴系统。\n\n### LRU 旋转优化\n`folio_rotate_reclaimable()` 在写回结束时，若页面干净且未锁定，则将其移至 inactive LRU 尾部。此操作通过 per-CPU 的 `lru_rotate` 批处理完成，仅在必要时获取 LRU 锁，避免影响写回关键路径性能。\n\n### 成本跟踪\n`lru_note_cost()` 通过累加 `nr_io * SWAP_CLUSTER_MAX + nr_rotated` 来量化扫描成本，用于动态调整匿名页与文件页 LRU 的扫描比例，优化内存回收效率。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/pagevec.h>`、`\"internal.h\"` 等，使用伙伴系统、LRU 框架、内存控制组（memcg）等基础组件。\n- **交换子系统**：虽不直接实现 swap read/write，但为 `vmscan.c` 中的页面回收提供 LRU 操作接口，是 swap 机制的支撑模块。\n- **大页支持**：通过 `hugetlb.h` 与大页子系统交互，特殊处理大页释放。\n- **设备内存**：通过 `memremap.h` 支持持久内存（pmem）等 zone device 页面的释放。\n- **跟踪与统计**：使用 tracepoint（`trace/events/pagemap.h`）和 VM 统计（`kernel_stat.h`）进行性能分析。\n- **SMP 支持**：大量使用 per-CPU 变量（`DEFINE_PER_CPU`）和本地锁（`local_lock_t`）优化多核性能。\n\n## 5. 使用场景\n\n- **页面回收（Reclaim）**：当内存压力触发 kswapd 或 direct reclaim 时，`vmscan.c` 调用本文件的 LRU 操作函数来隔离、释放页面。\n- **页面缓存释放**：文件系统或网络子系统在释放 page cache 页面时，通过 `__folio_put()` 或 `put_pages_list()` 触发 LRU 移除和内存释放。\n- **写回完成处理**：块设备或文件系统在完成脏页写回后，调用 `folio_rotate_reclaimable()` 更新页面在 LRU 中的位置。\n- **内存控制组（cgroup）**：memcg 回收内存时，复用本文件的 LRU 批处理和 folio 释放逻辑。\n- **大页与设备内存管理**：透明大页（THP）或持久内存应用释放页面时，通过统一的 `__folio_put()` 接口分发到专用释放函数。\n- **系统调优**：管理员通过 `/proc/sys/vm/page-cluster` 调整 `page_cluster` 值，影响 swap 和 page cache 的 I/O 批量大小。",
      "similarity": 0.6139744520187378,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/swap.c",
          "start_line": 77,
          "end_line": 190,
          "content": [
            "static void __page_cache_release(struct folio *folio, struct lruvec **lruvecp,",
            "\t\tunsigned long *flagsp)",
            "{",
            "\tif (folio_test_lru(folio)) {",
            "\t\tfolio_lruvec_relock_irqsave(folio, lruvecp, flagsp);",
            "\t\tlruvec_del_folio(*lruvecp, folio);",
            "\t\t__folio_clear_lru_flags(folio);",
            "\t}",
            "}",
            "static void page_cache_release(struct folio *folio)",
            "{",
            "\tstruct lruvec *lruvec = NULL;",
            "\tunsigned long flags;",
            "",
            "\t__page_cache_release(folio, &lruvec, &flags);",
            "\tif (lruvec)",
            "\t\tunlock_page_lruvec_irqrestore(lruvec, flags);",
            "}",
            "void __folio_put(struct folio *folio)",
            "{",
            "\tif (unlikely(folio_is_zone_device(folio))) {",
            "\t\tfree_zone_device_folio(folio);",
            "\t\treturn;",
            "\t} else if (folio_test_hugetlb(folio)) {",
            "\t\tfree_huge_folio(folio);",
            "\t\treturn;",
            "\t}",
            "",
            "\tpage_cache_release(folio);",
            "\tfolio_unqueue_deferred_split(folio);",
            "\tmem_cgroup_uncharge(folio);",
            "\tfree_unref_page(&folio->page, folio_order(folio));",
            "}",
            "void put_pages_list(struct list_head *pages)",
            "{",
            "\tstruct folio_batch fbatch;",
            "\tstruct folio *folio, *next;",
            "",
            "\tfolio_batch_init(&fbatch);",
            "\tlist_for_each_entry_safe(folio, next, pages, lru) {",
            "\t\tif (!folio_put_testzero(folio))",
            "\t\t\tcontinue;",
            "\t\tif (folio_test_hugetlb(folio)) {",
            "\t\t\tfree_huge_folio(folio);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t/* LRU flag must be clear because it's passed using the lru */",
            "\t\tif (folio_batch_add(&fbatch, folio) > 0)",
            "\t\t\tcontinue;",
            "\t\tfree_unref_folios(&fbatch);",
            "\t}",
            "",
            "\tif (fbatch.nr)",
            "\t\tfree_unref_folios(&fbatch);",
            "\tINIT_LIST_HEAD(pages);",
            "}",
            "static void lru_add_fn(struct lruvec *lruvec, struct folio *folio)",
            "{",
            "\tint was_unevictable = folio_test_clear_unevictable(folio);",
            "\tlong nr_pages = folio_nr_pages(folio);",
            "",
            "\tVM_BUG_ON_FOLIO(folio_test_lru(folio), folio);",
            "",
            "\t/*",
            "\t * Is an smp_mb__after_atomic() still required here, before",
            "\t * folio_evictable() tests the mlocked flag, to rule out the possibility",
            "\t * of stranding an evictable folio on an unevictable LRU?  I think",
            "\t * not, because __munlock_folio() only clears the mlocked flag",
            "\t * while the LRU lock is held.",
            "\t *",
            "\t * (That is not true of __page_cache_release(), and not necessarily",
            "\t * true of folios_put(): but those only clear the mlocked flag after",
            "\t * folio_put_testzero() has excluded any other users of the folio.)",
            "\t */",
            "\tif (folio_evictable(folio)) {",
            "\t\tif (was_unevictable)",
            "\t\t\t__count_vm_events(UNEVICTABLE_PGRESCUED, nr_pages);",
            "\t} else {",
            "\t\tfolio_clear_active(folio);",
            "\t\tfolio_set_unevictable(folio);",
            "\t\t/*",
            "\t\t * folio->mlock_count = !!folio_test_mlocked(folio)?",
            "\t\t * But that leaves __mlock_folio() in doubt whether another",
            "\t\t * actor has already counted the mlock or not.  Err on the",
            "\t\t * safe side, underestimate, let page reclaim fix it, rather",
            "\t\t * than leaving a page on the unevictable LRU indefinitely.",
            "\t\t */",
            "\t\tfolio->mlock_count = 0;",
            "\t\tif (!was_unevictable)",
            "\t\t\t__count_vm_events(UNEVICTABLE_PGCULLED, nr_pages);",
            "\t}",
            "",
            "\tlruvec_add_folio(lruvec, folio);",
            "\ttrace_mm_lru_insertion(folio);",
            "}",
            "static void folio_batch_move_lru(struct folio_batch *fbatch, move_fn_t move_fn)",
            "{",
            "\tint i;",
            "\tstruct lruvec *lruvec = NULL;",
            "\tunsigned long flags = 0;",
            "",
            "\tfor (i = 0; i < folio_batch_count(fbatch); i++) {",
            "\t\tstruct folio *folio = fbatch->folios[i];",
            "",
            "\t\tfolio_lruvec_relock_irqsave(folio, &lruvec, &flags);",
            "\t\tmove_fn(lruvec, folio);",
            "",
            "\t\tfolio_set_lru(folio);",
            "\t}",
            "",
            "\tif (lruvec)",
            "\t\tunlock_page_lruvec_irqrestore(lruvec, flags);",
            "\tfolios_put(fbatch);",
            "}"
          ],
          "function_name": "__page_cache_release, page_cache_release, __folio_put, put_pages_list, lru_add_fn, folio_batch_move_lru",
          "description": "实现了页面缓存释放和LRU列表维护逻辑，包含__page_cache_release用于从LRU列表移除页面，page_cache_release处理普通页面释放流程，__folio_put负责释放非设备映射和大页，put_pages_list批量处理页面释放，lru_add_fn将页面添加到LRU列表并根据是否可交换设置相应标志。",
          "similarity": 0.544126033782959
        },
        {
          "chunk_id": 8,
          "file_path": "mm/swap.c",
          "start_line": 1079,
          "end_line": 1111,
          "content": [
            "void __folio_batch_release(struct folio_batch *fbatch)",
            "{",
            "\tif (!fbatch->percpu_pvec_drained) {",
            "\t\tlru_add_drain();",
            "\t\tfbatch->percpu_pvec_drained = true;",
            "\t}",
            "\tfolios_put(fbatch);",
            "}",
            "void folio_batch_remove_exceptionals(struct folio_batch *fbatch)",
            "{",
            "\tunsigned int i, j;",
            "",
            "\tfor (i = 0, j = 0; i < folio_batch_count(fbatch); i++) {",
            "\t\tstruct folio *folio = fbatch->folios[i];",
            "\t\tif (!xa_is_value(folio))",
            "\t\t\tfbatch->folios[j++] = folio;",
            "\t}",
            "\tfbatch->nr = j;",
            "}",
            "void __init swap_setup(void)",
            "{",
            "\tunsigned long megs = totalram_pages() >> (20 - PAGE_SHIFT);",
            "",
            "\t/* Use a smaller cluster for small-memory machines */",
            "\tif (megs < 16)",
            "\t\tpage_cluster = 2;",
            "\telse",
            "\t\tpage_cluster = 3;",
            "\t/*",
            "\t * Right now other parts of the system means that we",
            "\t * _really_ don't want to cluster much more",
            "\t */",
            "}"
          ],
          "function_name": "__folio_batch_release, folio_batch_remove_exceptionals, swap_setup",
          "description": "__folio_batch_release 标记并释放页面批次引用，folio_batch_remove_exceptionals 清理异常条目；swap_setup 初始化页面聚类参数，根据内存大小调整page_cluster值。",
          "similarity": 0.5107564330101013
        },
        {
          "chunk_id": 5,
          "file_path": "mm/swap.c",
          "start_line": 641,
          "end_line": 743,
          "content": [
            "void lru_add_drain_cpu(int cpu)",
            "{",
            "\tstruct cpu_fbatches *fbatches = &per_cpu(cpu_fbatches, cpu);",
            "\tstruct folio_batch *fbatch = &fbatches->lru_add;",
            "",
            "\tif (folio_batch_count(fbatch))",
            "\t\tfolio_batch_move_lru(fbatch, lru_add_fn);",
            "",
            "\tfbatch = &per_cpu(lru_rotate.fbatch, cpu);",
            "\t/* Disabling interrupts below acts as a compiler barrier. */",
            "\tif (data_race(folio_batch_count(fbatch))) {",
            "\t\tunsigned long flags;",
            "",
            "\t\t/* No harm done if a racing interrupt already did this */",
            "\t\tlocal_lock_irqsave(&lru_rotate.lock, flags);",
            "\t\tfolio_batch_move_lru(fbatch, lru_move_tail_fn);",
            "\t\tlocal_unlock_irqrestore(&lru_rotate.lock, flags);",
            "\t}",
            "",
            "\tfbatch = &fbatches->lru_deactivate_file;",
            "\tif (folio_batch_count(fbatch))",
            "\t\tfolio_batch_move_lru(fbatch, lru_deactivate_file_fn);",
            "",
            "\tfbatch = &fbatches->lru_deactivate;",
            "\tif (folio_batch_count(fbatch))",
            "\t\tfolio_batch_move_lru(fbatch, lru_deactivate_fn);",
            "",
            "\tfbatch = &fbatches->lru_lazyfree;",
            "\tif (folio_batch_count(fbatch))",
            "\t\tfolio_batch_move_lru(fbatch, lru_lazyfree_fn);",
            "",
            "\tfolio_activate_drain(cpu);",
            "}",
            "void deactivate_file_folio(struct folio *folio)",
            "{",
            "\tstruct folio_batch *fbatch;",
            "",
            "\t/* Deactivating an unevictable folio will not accelerate reclaim */",
            "\tif (folio_test_unevictable(folio))",
            "\t\treturn;",
            "",
            "\tfolio_get(folio);",
            "\tif (!folio_test_clear_lru(folio)) {",
            "\t\tfolio_put(folio);",
            "\t\treturn;",
            "\t}",
            "",
            "\tlocal_lock(&cpu_fbatches.lock);",
            "\tfbatch = this_cpu_ptr(&cpu_fbatches.lru_deactivate_file);",
            "\tfolio_batch_add_and_move(fbatch, folio, lru_deactivate_file_fn);",
            "\tlocal_unlock(&cpu_fbatches.lock);",
            "}",
            "void folio_deactivate(struct folio *folio)",
            "{",
            "\tif (!folio_test_unevictable(folio) && (folio_test_active(folio) ||",
            "\t    lru_gen_enabled())) {",
            "\t\tstruct folio_batch *fbatch;",
            "",
            "\t\tfolio_get(folio);",
            "\t\tif (!folio_test_clear_lru(folio)) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tlocal_lock(&cpu_fbatches.lock);",
            "\t\tfbatch = this_cpu_ptr(&cpu_fbatches.lru_deactivate);",
            "\t\tfolio_batch_add_and_move(fbatch, folio, lru_deactivate_fn);",
            "\t\tlocal_unlock(&cpu_fbatches.lock);",
            "\t}",
            "}",
            "void folio_mark_lazyfree(struct folio *folio)",
            "{",
            "\tif (folio_test_anon(folio) && folio_test_swapbacked(folio) &&",
            "\t    !folio_test_swapcache(folio) && !folio_test_unevictable(folio)) {",
            "\t\tstruct folio_batch *fbatch;",
            "",
            "\t\tfolio_get(folio);",
            "\t\tif (!folio_test_clear_lru(folio)) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tlocal_lock(&cpu_fbatches.lock);",
            "\t\tfbatch = this_cpu_ptr(&cpu_fbatches.lru_lazyfree);",
            "\t\tfolio_batch_add_and_move(fbatch, folio, lru_lazyfree_fn);",
            "\t\tlocal_unlock(&cpu_fbatches.lock);",
            "\t}",
            "}",
            "void lru_add_drain(void)",
            "{",
            "\tlocal_lock(&cpu_fbatches.lock);",
            "\tlru_add_drain_cpu(smp_processor_id());",
            "\tlocal_unlock(&cpu_fbatches.lock);",
            "\tmlock_drain_local();",
            "}",
            "static void lru_add_and_bh_lrus_drain(void)",
            "{",
            "\tlocal_lock(&cpu_fbatches.lock);",
            "\tlru_add_drain_cpu(smp_processor_id());",
            "\tlocal_unlock(&cpu_fbatches.lock);",
            "\tinvalidate_bh_lrus_cpu();",
            "\tmlock_drain_local();",
            "}"
          ],
          "function_name": "lru_add_drain_cpu, deactivate_file_folio, folio_deactivate, folio_mark_lazyfree, lru_add_drain, lru_add_and_bh_lrus_drain",
          "description": "lru_add_drain_cpu 处理CPU本地LRU批次的移动，将不同类型的页面（如lru_add、deactivate、lazyfree等）通过folio_batch_move_lru分发至相应LRU队列，同时协调中断禁用和锁保护以确保原子性。",
          "similarity": 0.5030062198638916
        },
        {
          "chunk_id": 6,
          "file_path": "mm/swap.c",
          "start_line": 781,
          "end_line": 896,
          "content": [
            "void lru_add_drain_cpu_zone(struct zone *zone)",
            "{",
            "\tlocal_lock(&cpu_fbatches.lock);",
            "\tlru_add_drain_cpu(smp_processor_id());",
            "\tdrain_local_pages(zone);",
            "\tlocal_unlock(&cpu_fbatches.lock);",
            "\tmlock_drain_local();",
            "}",
            "static void lru_add_drain_per_cpu(struct work_struct *dummy)",
            "{",
            "\tlru_add_and_bh_lrus_drain();",
            "}",
            "static bool cpu_needs_drain(unsigned int cpu)",
            "{",
            "\tstruct cpu_fbatches *fbatches = &per_cpu(cpu_fbatches, cpu);",
            "",
            "\t/* Check these in order of likelihood that they're not zero */",
            "\treturn folio_batch_count(&fbatches->lru_add) ||",
            "\t\tdata_race(folio_batch_count(&per_cpu(lru_rotate.fbatch, cpu))) ||",
            "\t\tfolio_batch_count(&fbatches->lru_deactivate_file) ||",
            "\t\tfolio_batch_count(&fbatches->lru_deactivate) ||",
            "\t\tfolio_batch_count(&fbatches->lru_lazyfree) ||",
            "\t\tfolio_batch_count(&fbatches->activate) ||",
            "\t\tneed_mlock_drain(cpu) ||",
            "\t\thas_bh_in_lru(cpu, NULL);",
            "}",
            "static inline void __lru_add_drain_all(bool force_all_cpus)",
            "{",
            "\t/*",
            "\t * lru_drain_gen - Global pages generation number",
            "\t *",
            "\t * (A) Definition: global lru_drain_gen = x implies that all generations",
            "\t *     0 < n <= x are already *scheduled* for draining.",
            "\t *",
            "\t * This is an optimization for the highly-contended use case where a",
            "\t * user space workload keeps constantly generating a flow of pages for",
            "\t * each CPU.",
            "\t */",
            "\tstatic unsigned int lru_drain_gen;",
            "\tstatic struct cpumask has_work;",
            "\tstatic DEFINE_MUTEX(lock);",
            "\tunsigned cpu, this_gen;",
            "",
            "\t/*",
            "\t * Make sure nobody triggers this path before mm_percpu_wq is fully",
            "\t * initialized.",
            "\t */",
            "\tif (WARN_ON(!mm_percpu_wq))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Guarantee folio_batch counter stores visible by this CPU",
            "\t * are visible to other CPUs before loading the current drain",
            "\t * generation.",
            "\t */",
            "\tsmp_mb();",
            "",
            "\t/*",
            "\t * (B) Locally cache global LRU draining generation number",
            "\t *",
            "\t * The read barrier ensures that the counter is loaded before the mutex",
            "\t * is taken. It pairs with smp_mb() inside the mutex critical section",
            "\t * at (D).",
            "\t */",
            "\tthis_gen = smp_load_acquire(&lru_drain_gen);",
            "",
            "\tmutex_lock(&lock);",
            "",
            "\t/*",
            "\t * (C) Exit the draining operation if a newer generation, from another",
            "\t * lru_add_drain_all(), was already scheduled for draining. Check (A).",
            "\t */",
            "\tif (unlikely(this_gen != lru_drain_gen && !force_all_cpus))",
            "\t\tgoto done;",
            "",
            "\t/*",
            "\t * (D) Increment global generation number",
            "\t *",
            "\t * Pairs with smp_load_acquire() at (B), outside of the critical",
            "\t * section. Use a full memory barrier to guarantee that the",
            "\t * new global drain generation number is stored before loading",
            "\t * folio_batch counters.",
            "\t *",
            "\t * This pairing must be done here, before the for_each_online_cpu loop",
            "\t * below which drains the page vectors.",
            "\t *",
            "\t * Let x, y, and z represent some system CPU numbers, where x < y < z.",
            "\t * Assume CPU #z is in the middle of the for_each_online_cpu loop",
            "\t * below and has already reached CPU #y's per-cpu data. CPU #x comes",
            "\t * along, adds some pages to its per-cpu vectors, then calls",
            "\t * lru_add_drain_all().",
            "\t *",
            "\t * If the paired barrier is done at any later step, e.g. after the",
            "\t * loop, CPU #x will just exit at (C) and miss flushing out all of its",
            "\t * added pages.",
            "\t */",
            "\tWRITE_ONCE(lru_drain_gen, lru_drain_gen + 1);",
            "\tsmp_mb();",
            "",
            "\tcpumask_clear(&has_work);",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);",
            "",
            "\t\tif (cpu_needs_drain(cpu)) {",
            "\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);",
            "\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);",
            "\t\t\t__cpumask_set_cpu(cpu, &has_work);",
            "\t\t}",
            "\t}",
            "",
            "\tfor_each_cpu(cpu, &has_work)",
            "\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));",
            "",
            "done:",
            "\tmutex_unlock(&lock);",
            "}"
          ],
          "function_name": "lru_add_drain_cpu_zone, lru_add_drain_per_cpu, cpu_needs_drain, __lru_add_drain_all",
          "description": "__lru_add_drain_all 管理全局LRU排水过程，通过generation-based机制避免重复处理，利用互斥锁和smp_mb屏障确保跨CPU数据可见性，并调度工作队列处理各CPU的待处理页面批次。",
          "similarity": 0.500766932964325
        },
        {
          "chunk_id": 3,
          "file_path": "mm/swap.c",
          "start_line": 332,
          "end_line": 460,
          "content": [
            "static void folio_activate_drain(int cpu)",
            "{",
            "\tstruct folio_batch *fbatch = &per_cpu(cpu_fbatches.activate, cpu);",
            "",
            "\tif (folio_batch_count(fbatch))",
            "\t\tfolio_batch_move_lru(fbatch, folio_activate_fn);",
            "}",
            "void folio_activate(struct folio *folio)",
            "{",
            "\tif (!folio_test_active(folio) && !folio_test_unevictable(folio)) {",
            "\t\tstruct folio_batch *fbatch;",
            "",
            "\t\tfolio_get(folio);",
            "\t\tif (!folio_test_clear_lru(folio)) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tlocal_lock(&cpu_fbatches.lock);",
            "\t\tfbatch = this_cpu_ptr(&cpu_fbatches.activate);",
            "\t\tfolio_batch_add_and_move(fbatch, folio, folio_activate_fn);",
            "\t\tlocal_unlock(&cpu_fbatches.lock);",
            "\t}",
            "}",
            "static inline void folio_activate_drain(int cpu)",
            "{",
            "}",
            "void folio_activate(struct folio *folio)",
            "{",
            "\tstruct lruvec *lruvec;",
            "",
            "\tif (folio_test_clear_lru(folio)) {",
            "\t\tlruvec = folio_lruvec_lock_irq(folio);",
            "\t\tfolio_activate_fn(lruvec, folio);",
            "\t\tunlock_page_lruvec_irq(lruvec);",
            "\t\tfolio_set_lru(folio);",
            "\t}",
            "}",
            "static void __lru_cache_activate_folio(struct folio *folio)",
            "{",
            "\tstruct folio_batch *fbatch;",
            "\tint i;",
            "",
            "\tlocal_lock(&cpu_fbatches.lock);",
            "\tfbatch = this_cpu_ptr(&cpu_fbatches.lru_add);",
            "",
            "\t/*",
            "\t * Search backwards on the optimistic assumption that the folio being",
            "\t * activated has just been added to this batch. Note that only",
            "\t * the local batch is examined as a !LRU folio could be in the",
            "\t * process of being released, reclaimed, migrated or on a remote",
            "\t * batch that is currently being drained. Furthermore, marking",
            "\t * a remote batch's folio active potentially hits a race where",
            "\t * a folio is marked active just after it is added to the inactive",
            "\t * list causing accounting errors and BUG_ON checks to trigger.",
            "\t */",
            "\tfor (i = folio_batch_count(fbatch) - 1; i >= 0; i--) {",
            "\t\tstruct folio *batch_folio = fbatch->folios[i];",
            "",
            "\t\tif (batch_folio == folio) {",
            "\t\t\tfolio_set_active(folio);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tlocal_unlock(&cpu_fbatches.lock);",
            "}",
            "static void folio_inc_refs(struct folio *folio)",
            "{",
            "\tunsigned long new_flags, old_flags = READ_ONCE(folio->flags);",
            "",
            "\tif (folio_test_unevictable(folio))",
            "\t\treturn;",
            "",
            "\tif (!folio_test_referenced(folio)) {",
            "\t\tfolio_set_referenced(folio);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (!folio_test_workingset(folio)) {",
            "\t\tfolio_set_workingset(folio);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* see the comment on MAX_NR_TIERS */",
            "\tdo {",
            "\t\tnew_flags = old_flags & LRU_REFS_MASK;",
            "\t\tif (new_flags == LRU_REFS_MASK)",
            "\t\t\tbreak;",
            "",
            "\t\tnew_flags += BIT(LRU_REFS_PGOFF);",
            "\t\tnew_flags |= old_flags & ~LRU_REFS_MASK;",
            "\t} while (!try_cmpxchg(&folio->flags, &old_flags, new_flags));",
            "}",
            "static void folio_inc_refs(struct folio *folio)",
            "{",
            "}",
            "void folio_mark_accessed(struct folio *folio)",
            "{",
            "\tif (lru_gen_enabled()) {",
            "\t\tfolio_inc_refs(folio);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (!folio_test_referenced(folio)) {",
            "\t\tfolio_set_referenced(folio);",
            "\t} else if (folio_test_unevictable(folio)) {",
            "\t\t/*",
            "\t\t * Unevictable pages are on the \"LRU_UNEVICTABLE\" list. But,",
            "\t\t * this list is never rotated or maintained, so marking an",
            "\t\t * unevictable page accessed has no effect.",
            "\t\t */",
            "\t} else if (!folio_test_active(folio)) {",
            "\t\t/*",
            "\t\t * If the folio is on the LRU, queue it for activation via",
            "\t\t * cpu_fbatches.activate. Otherwise, assume the folio is in a",
            "\t\t * folio_batch, mark it active and it'll be moved to the active",
            "\t\t * LRU on the next drain.",
            "\t\t */",
            "\t\tif (folio_test_lru(folio))",
            "\t\t\tfolio_activate(folio);",
            "\t\telse",
            "\t\t\t__lru_cache_activate_folio(folio);",
            "\t\tfolio_clear_referenced(folio);",
            "\t\tworkingset_activation(folio);",
            "\t}",
            "\tif (folio_test_idle(folio))",
            "\t\tfolio_clear_idle(folio);",
            "}"
          ],
          "function_name": "folio_activate_drain, folio_activate, folio_activate_drain, folio_activate, __lru_cache_activate_folio, folio_inc_refs, folio_inc_refs, folio_mark_accessed",
          "description": "实现页面激活和引用计数管理，folio_activate_drain和folio_activate将页面从非活动列表转至活动列表，__lru_cache_activate_folio处理本地批次中的页面激活，folio_inc_refs更新页面引用标志，folio_mark_accessed标记页面访问状态并触发激活流程。",
          "similarity": 0.49003130197525024
        }
      ]
    }
  ]
}