{
  "query": "inode结构与目录项关联方式",
  "timestamp": "2025-12-26 00:16:04",
  "retrieved_files": [
    {
      "source_file": "kernel/audit_tree.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:51:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `audit_tree.c`\n\n---\n\n# audit_tree.c 技术文档\n\n## 1. 文件概述\n\n`audit_tree.c` 是 Linux 内核审计子系统中用于实现**目录树监控**（audit tree watching）的核心模块。该文件提供了对整个目录树（而不仅仅是单个 inode）进行审计监控的能力，通过将审计规则与目录路径关联，并在文件系统事件（如创建、删除、重命名等）发生时高效匹配规则。其核心机制基于 `fsnotify` 框架，在 inode 级别挂载通知标记（mark），并通过引用计数、RCU（Read-Copy-Update）和哈希表等技术保证高并发下的安全性和性能。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct audit_tree`**  \n  表示一个被监控的目录树。包含路径名、引用计数、关联的规则列表、关联的 chunk 列表等。\n  \n- **`struct audit_chunk`**  \n  表示与一个或多个 inode 关联的监控单元。每个 chunk 通过 `fsnotify_mark` 附加到 inode 上，并维护多个 `audit_tree` 的所有者关系（`owners[]` 数组）。\n\n- **`struct audit_tree_mark`**  \n  封装 `fsnotify_mark`，作为 chunk 与 inode 之间的桥梁，属于 `fsnotify` 框架的扩展标记类型。\n\n- **`struct audit_node`**  \n  嵌入在 `audit_chunk` 中，表示 chunk 与某个 `audit_tree` 的关联关系，包含 owner 指针和索引。\n\n### 主要函数\n\n- **`alloc_tree(const char *s)`**  \n  分配并初始化一个新的 `audit_tree` 实例。\n\n- **`get_tree()` / `put_tree()`**  \n  对 `audit_tree` 进行引用计数管理，`put_tree` 在引用归零时使用 RCU 安全释放。\n\n- **`audit_tree_lookup(const struct inode *inode)`**  \n  在 RCU 读临界区内，根据 inode 查找对应的 `audit_chunk`，并增加其引用计数。\n\n- **`audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)`**  \n  检查给定 chunk 是否属于指定的 audit tree。\n\n- **`alloc_chunk(int count)`**  \n  分配包含指定数量 `audit_node` 的 chunk。\n\n- **`insert_hash(struct audit_chunk *chunk)`**  \n  将 chunk 插入全局哈希表，用于快速查找。\n\n- **`audit_mark_put_chunk()` / `audit_put_chunk()`**  \n  安全释放 chunk 的引用，结合 RCU 机制确保并发安全。\n\n- **`replace_mark_chunk()` / `replace_chunk()`**  \n  在标记或 chunk 更新时进行原子替换（代码片段中 `replace_chunk` 未完整）。\n\n## 3. 关键实现\n\n### 哈希与查找机制\n- 使用 `inode->i_fsnotify_marks` 的地址作为哈希键（`inode_to_key`），确保每个 inode 对应唯一键。\n- 全局哈希表 `chunk_hash_heads[HASH_SIZE]`（大小为 128）配合 `hash_lock` 自旋锁保护写操作。\n- 查找操作（`audit_tree_lookup`）在 RCU 读锁下进行，通过 `READ_ONCE()` 和 `smp_wmb()` 保证内存可见性。\n\n### 引用计数与生命周期管理\n- `audit_tree` 使用 `refcount_t` 管理引用，来源包括：关联的审计规则、chunk 中的 owner 引用。\n- `audit_chunk` 使用 `atomic_long_t refs`，其中一份引用由 `fsnotify_mark` 持有。\n- 所有释放操作均通过 RCU（`call_rcu` / `kfree_rcu`）延迟执行，确保并发读取安全。\n\n### 与 fsnotify 集成\n- 每个被监控的 inode 通过 `audit_tree_mark`（继承 `fsnotify_mark`）关联一个 `audit_chunk`。\n- 当 inode 被删除或 untag 时，`fsnotify` 框架回调 `audit_tree_destroy_watch` 释放 mark。\n- `mark->mask = FS_IN_IGNORED` 表示仅用于内部结构关联，不主动监听事件（实际事件由审计规则触发匹配）。\n\n### 循环链表组织\n- `tree->chunks`：链接所有包含该 tree 的 chunk 中的 `audit_node.list`。\n- `chunk->trees`：链接所有以该 chunk 为根的 tree 的 `same_root` 链表。\n- `tree->rules`：链接所有引用该 tree 的审计规则。\n- 这些链表分别由 `hash_lock` 或 `audit_filter_mutex` 保护。\n\n### 索引位标记\n- `audit_node.index` 的最高位（MSB）用于标记“可能需要回滚”的临时状态，辅助复杂操作（如树重构）的清理逻辑。\n\n## 4. 依赖关系\n\n- **`<linux/fsnotify_backend.h>`**：依赖 fsnotify 框架实现 inode 级别事件通知和标记管理。\n- **`<linux/namei.h>` / `<linux/mount.h>`**：用于路径解析和挂载点处理（虽未在片段中直接调用，但 audit 树需处理跨挂载点语义）。\n- **`audit.h`**：与审计核心模块交互，提供 `audit_tree_path()` 等接口供规则匹配使用。\n- **`<linux/rcupdate.h>`**：使用 RCU 机制保证并发安全。\n- **`<linux/slab.h>`**：使用 `kmem_cache` 高效分配 `audit_tree_mark` 对象。\n\n## 5. 使用场景\n\n- **审计规则匹配**：当用户通过 `auditctl` 添加 `-w /path/to/dir -p wa -k key` 类型规则时，内核将 `/path/to/dir` 注册为 `audit_tree`。\n- **路径遍历监控**：在 `audit_inode()` 和 `audit_inode_child()` 中，内核收集路径上所有 inode 对应的 `audit_chunk`，用于后续与 `AUDIT_TREE` 类型规则匹配。\n- **动态目录结构变更**：当目录树内发生文件创建、删除、重命名或 inode 删除时，通过 fsnotify 机制触发 chunk 更新或 prune（修剪）操作，由专用内核线程 `prune_thread` 处理延迟清理。\n- **资源回收**：当审计规则被删除或监控目录被移除时，相关 `audit_tree` 和 `audit_chunk` 通过引用计数和 RCU 安全释放，避免内存泄漏。",
      "similarity": 0.6233854293823242,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/audit_tree.c",
          "start_line": 458,
          "end_line": 560,
          "content": [
            "static int tag_chunk(struct inode *inode, struct audit_tree *tree)",
            "{",
            "\tstruct fsnotify_mark *mark;",
            "\tstruct audit_chunk *chunk, *old;",
            "\tstruct audit_node *p;",
            "\tint n;",
            "",
            "\tfsnotify_group_lock(audit_tree_group);",
            "\tmark = fsnotify_find_inode_mark(inode, audit_tree_group);",
            "\tif (!mark)",
            "\t\treturn create_chunk(inode, tree);",
            "",
            "\t/*",
            "\t * Found mark is guaranteed to be attached and mark_mutex protects mark",
            "\t * from getting detached and thus it makes sure there is chunk attached",
            "\t * to the mark.",
            "\t */",
            "\t/* are we already there? */",
            "\tspin_lock(&hash_lock);",
            "\told = mark_chunk(mark);",
            "\tfor (n = 0; n < old->count; n++) {",
            "\t\tif (old->owners[n].owner == tree) {",
            "\t\t\tspin_unlock(&hash_lock);",
            "\t\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\t\tfsnotify_put_mark(mark);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "\tspin_unlock(&hash_lock);",
            "",
            "\tchunk = alloc_chunk(old->count + 1);",
            "\tif (!chunk) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tspin_lock(&hash_lock);",
            "\tif (tree->goner) {",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn 0;",
            "\t}",
            "\tp = &chunk->owners[chunk->count - 1];",
            "\tp->index = (chunk->count - 1) | (1U<<31);",
            "\tp->owner = tree;",
            "\tget_tree(tree);",
            "\tlist_add(&p->list, &tree->chunks);",
            "\tif (!tree->root) {",
            "\t\ttree->root = chunk;",
            "\t\tlist_add(&tree->same_root, &chunk->trees);",
            "\t}",
            "\t/*",
            "\t * This has to go last when updating chunk as once replace_chunk() is",
            "\t * called, new RCU readers can see the new chunk.",
            "\t */",
            "\treplace_chunk(chunk, old);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\tfsnotify_put_mark(mark); /* pair to fsnotify_find_mark */",
            "\taudit_mark_put_chunk(old);",
            "",
            "\treturn 0;",
            "}",
            "static void audit_tree_log_remove_rule(struct audit_context *context,",
            "\t\t\t\t       struct audit_krule *rule)",
            "{",
            "\tstruct audit_buffer *ab;",
            "",
            "\tif (!audit_enabled)",
            "\t\treturn;",
            "\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CONFIG_CHANGE);",
            "\tif (unlikely(!ab))",
            "\t\treturn;",
            "\taudit_log_format(ab, \"op=remove_rule dir=\");",
            "\taudit_log_untrustedstring(ab, rule->tree->pathname);",
            "\taudit_log_key(ab, rule->filterkey);",
            "\taudit_log_format(ab, \" list=%d res=1\", rule->listnr);",
            "\taudit_log_end(ab);",
            "}",
            "static void kill_rules(struct audit_context *context, struct audit_tree *tree)",
            "{",
            "\tstruct audit_krule *rule, *next;",
            "\tstruct audit_entry *entry;",
            "",
            "\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {",
            "\t\tentry = container_of(rule, struct audit_entry, rule);",
            "",
            "\t\tlist_del_init(&rule->rlist);",
            "\t\tif (rule->tree) {",
            "\t\t\t/* not a half-baked one */",
            "\t\t\taudit_tree_log_remove_rule(context, rule);",
            "\t\t\tif (entry->rule.exe)",
            "\t\t\t\taudit_remove_mark(entry->rule.exe);",
            "\t\t\trule->tree = NULL;",
            "\t\t\tlist_del_rcu(&entry->list);",
            "\t\t\tlist_del(&entry->rule.list);",
            "\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "tag_chunk, audit_tree_log_remove_rule, kill_rules",
          "description": "负责规则绑定和解绑操作，包含标记chunk的关联建立与断开。通过日志记录规则变更，触发清理流程，确保审计规则与文件系统事件的动态同步。",
          "similarity": 0.4968474209308624
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/audit_tree.c",
          "start_line": 874,
          "end_line": 993,
          "content": [
            "int audit_tag_tree(char *old, char *new)",
            "{",
            "\tstruct list_head cursor, barrier;",
            "\tint failed = 0;",
            "\tstruct path path1, path2;",
            "\tstruct path array[16];",
            "\tstruct path *paths;",
            "\tint err;",
            "",
            "\terr = kern_path(new, 0, &path2);",
            "\tif (err)",
            "\t\treturn err;",
            "\tpaths = collect_paths(&path2, array, 16);",
            "\tpath_put(&path2);",
            "\tif (IS_ERR(paths))",
            "\t\treturn PTR_ERR(paths);",
            "",
            "\terr = kern_path(old, 0, &path1);",
            "\tif (err) {",
            "\t\tdrop_collected_paths(paths, array);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tlist_add(&barrier, &tree_list);",
            "\tlist_add(&cursor, &barrier);",
            "",
            "\twhile (cursor.next != &tree_list) {",
            "\t\tstruct audit_tree *tree;",
            "\t\tint good_one = 0;",
            "",
            "\t\ttree = container_of(cursor.next, struct audit_tree, list);",
            "\t\tget_tree(tree);",
            "\t\tlist_move(&cursor, &tree->list);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\terr = kern_path(tree->pathname, 0, &path2);",
            "\t\tif (!err) {",
            "\t\t\tgood_one = path_is_under(&path1, &path2);",
            "\t\t\tpath_put(&path2);",
            "\t\t}",
            "",
            "\t\tif (!good_one) {",
            "\t\t\tput_tree(tree);",
            "\t\t\tmutex_lock(&audit_filter_mutex);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tfailed = tag_mounts(paths, tree);",
            "\t\tif (failed) {",
            "\t\t\tput_tree(tree);",
            "\t\t\tmutex_lock(&audit_filter_mutex);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t\tspin_lock(&hash_lock);",
            "\t\tif (!tree->goner) {",
            "\t\t\tlist_move(&tree->list, &tree_list);",
            "\t\t}",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tput_tree(tree);",
            "\t}",
            "",
            "\twhile (barrier.prev != &tree_list) {",
            "\t\tstruct audit_tree *tree;",
            "",
            "\t\ttree = container_of(barrier.prev, struct audit_tree, list);",
            "\t\tget_tree(tree);",
            "\t\tlist_move(&tree->list, &barrier);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\tif (!failed) {",
            "\t\t\tstruct audit_node *node;",
            "\t\t\tspin_lock(&hash_lock);",
            "\t\t\tlist_for_each_entry(node, &tree->chunks, list)",
            "\t\t\t\tnode->index &= ~(1U<<31);",
            "\t\t\tspin_unlock(&hash_lock);",
            "\t\t} else {",
            "\t\t\ttrim_marked(tree);",
            "\t\t}",
            "",
            "\t\tput_tree(tree);",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t}",
            "\tlist_del(&barrier);",
            "\tlist_del(&cursor);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\tpath_put(&path1);",
            "\tdrop_collected_paths(paths, array);",
            "\treturn failed;",
            "}",
            "static void audit_schedule_prune(void)",
            "{",
            "\twake_up_process(prune_thread);",
            "}",
            "void audit_kill_trees(struct audit_context *context)",
            "{",
            "\tstruct list_head *list = &context->killed_trees;",
            "",
            "\taudit_ctl_lock();",
            "\tmutex_lock(&audit_filter_mutex);",
            "",
            "\twhile (!list_empty(list)) {",
            "\t\tstruct audit_tree *victim;",
            "",
            "\t\tvictim = list_entry(list->next, struct audit_tree, list);",
            "\t\tkill_rules(context, victim);",
            "\t\tlist_del_init(&victim->list);",
            "",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\tprune_one(victim);",
            "",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t}",
            "",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\taudit_ctl_unlock();",
            "}"
          ],
          "function_name": "audit_tag_tree, audit_schedule_prune, audit_kill_trees",
          "description": "提供审计树状态同步与清理机制，audit_tag_tree用于路径变更时同步树结构，audit_schedule_prune唤醒修剪线程，audit_kill_trees处理上下文中被终止的审计树，通过互斥锁保护并发访问并执行规则清理。",
          "similarity": 0.4882791340351105
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/audit_tree.c",
          "start_line": 1,
          "end_line": 110,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include \"audit.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/refcount.h>",
            "#include <linux/slab.h>",
            "",
            "struct audit_tree;",
            "struct audit_chunk;",
            "",
            "struct audit_tree {",
            "\trefcount_t count;",
            "\tint goner;",
            "\tstruct audit_chunk *root;",
            "\tstruct list_head chunks;",
            "\tstruct list_head rules;",
            "\tstruct list_head list;",
            "\tstruct list_head same_root;",
            "\tstruct rcu_head head;",
            "\tchar pathname[];",
            "};",
            "",
            "struct audit_chunk {",
            "\tstruct list_head hash;",
            "\tunsigned long key;",
            "\tstruct fsnotify_mark *mark;",
            "\tstruct list_head trees;\t\t/* with root here */",
            "\tint count;",
            "\tatomic_long_t refs;",
            "\tstruct rcu_head head;",
            "\tstruct audit_node {",
            "\t\tstruct list_head list;",
            "\t\tstruct audit_tree *owner;",
            "\t\tunsigned index;\t\t/* index; upper bit indicates 'will prune' */",
            "\t} owners[];",
            "};",
            "",
            "struct audit_tree_mark {",
            "\tstruct fsnotify_mark mark;",
            "\tstruct audit_chunk *chunk;",
            "};",
            "",
            "static LIST_HEAD(tree_list);",
            "static LIST_HEAD(prune_list);",
            "static struct task_struct *prune_thread;",
            "",
            "/*",
            " * One struct chunk is attached to each inode of interest through",
            " * audit_tree_mark (fsnotify mark). We replace struct chunk on tagging /",
            " * untagging, the mark is stable as long as there is chunk attached. The",
            " * association between mark and chunk is protected by hash_lock and",
            " * audit_tree_group->mark_mutex. Thus as long as we hold",
            " * audit_tree_group->mark_mutex and check that the mark is alive by",
            " * FSNOTIFY_MARK_FLAG_ATTACHED flag check, we are sure the mark points to",
            " * the current chunk.",
            " *",
            " * Rules have pointer to struct audit_tree.",
            " * Rules have struct list_head rlist forming a list of rules over",
            " * the same tree.",
            " * References to struct chunk are collected at audit_inode{,_child}()",
            " * time and used in AUDIT_TREE rule matching.",
            " * These references are dropped at the same time we are calling",
            " * audit_free_names(), etc.",
            " *",
            " * Cyclic lists galore:",
            " * tree.chunks anchors chunk.owners[].list\t\t\thash_lock",
            " * tree.rules anchors rule.rlist\t\t\t\taudit_filter_mutex",
            " * chunk.trees anchors tree.same_root\t\t\t\thash_lock",
            " * chunk.hash is a hash with middle bits of watch.inode as",
            " * a hash function.\t\t\t\t\t\tRCU, hash_lock",
            " *",
            " * tree is refcounted; one reference for \"some rules on rules_list refer to",
            " * it\", one for each chunk with pointer to it.",
            " *",
            " * chunk is refcounted by embedded .refs. Mark associated with the chunk holds",
            " * one chunk reference. This reference is dropped either when a mark is going",
            " * to be freed (corresponding inode goes away) or when chunk attached to the",
            " * mark gets replaced. This reference must be dropped using",
            " * audit_mark_put_chunk() to make sure the reference is dropped only after RCU",
            " * grace period as it protects RCU readers of the hash table.",
            " *",
            " * node.index allows to get from node.list to containing chunk.",
            " * MSB of that sucker is stolen to mark taggings that we might have to",
            " * revert - several operations have very unpleasant cleanup logics and",
            " * that makes a difference.  Some.",
            " */",
            "",
            "static struct fsnotify_group *audit_tree_group __ro_after_init;",
            "static struct kmem_cache *audit_tree_mark_cachep __ro_after_init;",
            "",
            "static struct audit_tree *alloc_tree(const char *s)",
            "{",
            "\tstruct audit_tree *tree;",
            "",
            "\ttree = kmalloc(struct_size(tree, pathname, strlen(s) + 1), GFP_KERNEL);",
            "\tif (tree) {",
            "\t\trefcount_set(&tree->count, 1);",
            "\t\ttree->goner = 0;",
            "\t\tINIT_LIST_HEAD(&tree->chunks);",
            "\t\tINIT_LIST_HEAD(&tree->rules);",
            "\t\tINIT_LIST_HEAD(&tree->list);",
            "\t\tINIT_LIST_HEAD(&tree->same_root);",
            "\t\ttree->root = NULL;",
            "\t\tstrcpy(tree->pathname, s);",
            "\t}",
            "\treturn tree;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了审计树和chunk的数据结构，用于跟踪文件系统事件。audit_tree包含规则列表和路径名，audit_chunk管理与文件节点的关联。全局变量和辅助函数用于初始化、引用计数及哈希表操作，支持审计规则匹配和事件追踪。",
          "similarity": 0.4821309447288513
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/audit_tree.c",
          "start_line": 723,
          "end_line": 862,
          "content": [
            "int audit_make_tree(struct audit_krule *rule, char *pathname, u32 op)",
            "{",
            "",
            "\tif (pathname[0] != '/' ||",
            "\t    (rule->listnr != AUDIT_FILTER_EXIT &&",
            "\t     rule->listnr != AUDIT_FILTER_URING_EXIT) ||",
            "\t    op != Audit_equal ||",
            "\t    rule->inode_f || rule->watch || rule->tree)",
            "\t\treturn -EINVAL;",
            "\trule->tree = alloc_tree(pathname);",
            "\tif (!rule->tree)",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "void audit_put_tree(struct audit_tree *tree)",
            "{",
            "\tput_tree(tree);",
            "}",
            "static int tag_mounts(struct path *paths, struct audit_tree *tree)",
            "{",
            "\tfor (struct path *p = paths; p->dentry; p++) {",
            "\t\tint err = tag_chunk(p->dentry->d_inode, tree);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int prune_tree_thread(void *unused)",
            "{",
            "\tfor (;;) {",
            "\t\tif (list_empty(&prune_list)) {",
            "\t\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\t\tschedule();",
            "\t\t}",
            "",
            "\t\taudit_ctl_lock();",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "",
            "\t\twhile (!list_empty(&prune_list)) {",
            "\t\t\tstruct audit_tree *victim;",
            "",
            "\t\t\tvictim = list_entry(prune_list.next,",
            "\t\t\t\t\tstruct audit_tree, list);",
            "\t\t\tlist_del_init(&victim->list);",
            "",
            "\t\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\t\tprune_one(victim);",
            "",
            "\t\t\tmutex_lock(&audit_filter_mutex);",
            "\t\t}",
            "",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\taudit_ctl_unlock();",
            "\t}",
            "\treturn 0;",
            "}",
            "static int audit_launch_prune(void)",
            "{",
            "\tif (prune_thread)",
            "\t\treturn 0;",
            "\tprune_thread = kthread_run(prune_tree_thread, NULL,",
            "\t\t\t\t\"audit_prune_tree\");",
            "\tif (IS_ERR(prune_thread)) {",
            "\t\tpr_err(\"cannot start thread audit_prune_tree\");",
            "\t\tprune_thread = NULL;",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\treturn 0;",
            "}",
            "int audit_add_tree_rule(struct audit_krule *rule)",
            "{",
            "\tstruct audit_tree *seed = rule->tree, *tree;",
            "\tstruct path path;",
            "\tstruct path array[16];",
            "\tstruct path *paths;",
            "\tint err;",
            "",
            "\trule->tree = NULL;",
            "\tlist_for_each_entry(tree, &tree_list, list) {",
            "\t\tif (!strcmp(seed->pathname, tree->pathname)) {",
            "\t\t\tput_tree(seed);",
            "\t\t\trule->tree = tree;",
            "\t\t\tlist_add(&rule->rlist, &tree->rules);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "\ttree = seed;",
            "\tlist_add(&tree->list, &tree_list);",
            "\tlist_add(&rule->rlist, &tree->rules);",
            "\t/* do not set rule->tree yet */",
            "\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\tif (unlikely(!prune_thread)) {",
            "\t\terr = audit_launch_prune();",
            "\t\tif (err)",
            "\t\t\tgoto Err;",
            "\t}",
            "",
            "\terr = kern_path(tree->pathname, 0, &path);",
            "\tif (err)",
            "\t\tgoto Err;",
            "\tpaths = collect_paths(&path, array, 16);",
            "\tpath_put(&path);",
            "\tif (IS_ERR(paths)) {",
            "\t\terr = PTR_ERR(paths);",
            "\t\tgoto Err;",
            "\t}",
            "",
            "\tget_tree(tree);",
            "\terr = tag_mounts(paths, tree);",
            "\tdrop_collected_paths(paths, array);",
            "",
            "\tif (!err) {",
            "\t\tstruct audit_node *node;",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_for_each_entry(node, &tree->chunks, list)",
            "\t\t\tnode->index &= ~(1U<<31);",
            "\t\tspin_unlock(&hash_lock);",
            "\t} else {",
            "\t\ttrim_marked(tree);",
            "\t\tgoto Err;",
            "\t}",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tif (list_empty(&rule->rlist)) {",
            "\t\tput_tree(tree);",
            "\t\treturn -ENOENT;",
            "\t}",
            "\trule->tree = tree;",
            "\tput_tree(tree);",
            "",
            "\treturn 0;",
            "Err:",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tlist_del_init(&tree->list);",
            "\tlist_del_init(&tree->rules);",
            "\tput_tree(tree);",
            "\treturn err;",
            "}"
          ],
          "function_name": "audit_make_tree, audit_put_tree, tag_mounts, prune_tree_thread, audit_launch_prune, audit_add_tree_rule",
          "description": "实现审计树的创建与销毁逻辑，包括路径有效性校验、树结构分配、挂载点标记、修剪线程启动及规则绑定。通过alloc_tree分配新树结构，put_tree释放资源，tag_mounts遍历路径标记挂载点，prune_tree_thread作为后台线程定期清理过期树节点。",
          "similarity": 0.4716477394104004
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/audit_tree.c",
          "start_line": 325,
          "end_line": 451,
          "content": [
            "static void remove_chunk_node(struct audit_chunk *chunk, struct audit_node *p)",
            "{",
            "\tstruct audit_tree *owner = p->owner;",
            "",
            "\tif (owner->root == chunk) {",
            "\t\tlist_del_init(&owner->same_root);",
            "\t\towner->root = NULL;",
            "\t}",
            "\tlist_del_init(&p->list);",
            "\tp->owner = NULL;",
            "\tput_tree(owner);",
            "}",
            "static int chunk_count_trees(struct audit_chunk *chunk)",
            "{",
            "\tint i;",
            "\tint ret = 0;",
            "",
            "\tfor (i = 0; i < chunk->count; i++)",
            "\t\tif (chunk->owners[i].owner)",
            "\t\t\tret++;",
            "\treturn ret;",
            "}",
            "static void untag_chunk(struct audit_chunk *chunk, struct fsnotify_mark *mark)",
            "{",
            "\tstruct audit_chunk *new;",
            "\tint size;",
            "",
            "\tfsnotify_group_lock(audit_tree_group);",
            "\t/*",
            "\t * mark_mutex stabilizes chunk attached to the mark so we can check",
            "\t * whether it didn't change while we've dropped hash_lock.",
            "\t */",
            "\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED) ||",
            "\t    mark_chunk(mark) != chunk)",
            "\t\tgoto out_mutex;",
            "",
            "\tsize = chunk_count_trees(chunk);",
            "\tif (!size) {",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_del_init(&chunk->trees);",
            "\t\tlist_del_rcu(&chunk->hash);",
            "\t\treplace_mark_chunk(mark, NULL);",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_detach_mark(mark);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\taudit_mark_put_chunk(chunk);",
            "\t\tfsnotify_free_mark(mark);",
            "\t\treturn;",
            "\t}",
            "",
            "\tnew = alloc_chunk(size);",
            "\tif (!new)",
            "\t\tgoto out_mutex;",
            "",
            "\tspin_lock(&hash_lock);",
            "\t/*",
            "\t * This has to go last when updating chunk as once replace_chunk() is",
            "\t * called, new RCU readers can see the new chunk.",
            "\t */",
            "\treplace_chunk(new, chunk);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\taudit_mark_put_chunk(chunk);",
            "\treturn;",
            "",
            "out_mutex:",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "}",
            "static int create_chunk(struct inode *inode, struct audit_tree *tree)",
            "{",
            "\tstruct fsnotify_mark *mark;",
            "\tstruct audit_chunk *chunk = alloc_chunk(1);",
            "",
            "\tif (!chunk) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tmark = alloc_mark();",
            "\tif (!mark) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tkfree(chunk);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tif (fsnotify_add_inode_mark_locked(mark, inode, 0)) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn -ENOSPC;",
            "\t}",
            "",
            "\tspin_lock(&hash_lock);",
            "\tif (tree->goner) {",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_detach_mark(mark);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_free_mark(mark);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn 0;",
            "\t}",
            "\treplace_mark_chunk(mark, chunk);",
            "\tchunk->owners[0].index = (1U << 31);",
            "\tchunk->owners[0].owner = tree;",
            "\tget_tree(tree);",
            "\tlist_add(&chunk->owners[0].list, &tree->chunks);",
            "\tif (!tree->root) {",
            "\t\ttree->root = chunk;",
            "\t\tlist_add(&tree->same_root, &chunk->trees);",
            "\t}",
            "\tchunk->key = inode_to_key(inode);",
            "\t/*",
            "\t * Inserting into the hash table has to go last as once we do that RCU",
            "\t * readers can see the chunk.",
            "\t */",
            "\tinsert_hash(chunk);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\t/*",
            "\t * Drop our initial reference. When mark we point to is getting freed,",
            "\t * we get notification through ->freeing_mark callback and cleanup",
            "\t * chunk pointing to this mark.",
            "\t */",
            "\tfsnotify_put_mark(mark);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "remove_chunk_node, chunk_count_trees, untag_chunk, create_chunk",
          "description": "实现文件节点标记的增删改查逻辑，包含chunk创建、旧chunk清理及哈希表更新。通过锁保护确保操作原子性，处理标记失效场景并释放无效资源，维持审计系统状态有效性。",
          "similarity": 0.46058952808380127
        }
      ]
    },
    {
      "source_file": "kernel/audit_watch.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:52:01\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `audit_watch.c`\n\n---\n\n# audit_watch.c 技术文档\n\n## 1. 文件概述\n\n`audit_watch.c` 是 Linux 内核审计子系统（Audit Subsystem）中用于实现文件路径监控的核心模块。该文件通过与 `fsnotify` 机制集成，实现对指定路径的动态 inode 监控。当被监控的文件或目录发生创建、删除、移动或卸载等事件时，审计系统能够自动更新规则中关联的 inode 信息，确保审计规则持续有效。该机制解决了传统基于路径的监控在文件系统结构变化时失效的问题。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct audit_watch`**  \n  表示一个审计监控项，包含：\n  - `count`：引用计数\n  - `dev` / `ino`：关联的设备号和 inode 号（初始为未设置状态）\n  - `path`：原始监控路径字符串\n  - `parent`：指向所属父目录的 `audit_parent` 结构\n  - `wlist`：挂载到父目录监控列表的链表节点\n  - `rules`：关联的审计规则链表头\n\n- **`struct audit_parent`**  \n  表示被监控路径的父目录，包含：\n  - `watches`：该父目录下所有 `audit_watch` 的链表头\n  - `mark`：嵌入的 `fsnotify_mark`，用于注册到 VFS 通知系统\n\n### 主要函数\n\n- **`audit_to_watch()`**  \n  将用户空间传入的路径字符串转换为内核 `audit_watch` 对象，并绑定到审计规则\n\n- **`audit_init_watch()` / `audit_init_parent()`**  \n  初始化 `audit_watch` 和 `audit_parent` 结构\n\n- **`audit_dupe_watch()`**  \n  复制监控项（用于 inode 变更时的规则更新）\n\n- **`audit_update_watch()`**  \n  核心回调函数，处理文件系统事件（如重命名、删除）并更新所有关联规则的 inode 信息\n\n- **`audit_watch_compare()`**  \n  比较监控项与给定 inode/dev 是否匹配\n\n- **`audit_get_watch()` / `audit_put_watch()`**  \n  引用计数管理接口\n\n- **`audit_remove_watch()`**  \n  从父目录监控列表中移除监控项\n\n## 3. 关键实现\n\n### 引用计数机制\n- **`audit_watch`**：使用 `refcount_t` 管理生命周期，每个关联的审计规则持有引用\n- **`audit_parent`**：通过 `fsnotify_mark` 的引用计数管理，每个子监控项持有父目录引用\n\n### fsnotify 集成\n- 创建专用 `fsnotify_group` (`audit_watch_group`)\n- 监控事件类型：`FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF | FS_MOVE_SELF | FS_UNMOUNT`\n- 通过 `fsnotify_add_inode_mark()` 在父目录 inode 上注册监控标记\n\n### 动态 inode 更新流程\n1. 文件系统事件触发 `audit_update_watch()` 回调\n2. 根据事件中的 dentry 名称匹配对应 `audit_watch`\n3. 创建新 `audit_watch` 副本并更新 inode/dev 信息\n4. 遍历原监控项关联的所有规则：\n   - 从旧 inode 哈希表移除规则\n   - 创建规则副本并绑定到新监控项\n   - 插入新 inode 对应的哈希表\n5. 记录配置变更日志（`AUDIT_CONFIG_CHANGE`）\n\n### 路径解析策略\n- 仅支持绝对路径（以 `/` 开头）\n- 不支持目录路径（路径末尾不能为 `/`）\n- 仅允许用于 `AUDIT_FILTER_EXIT` 和 `AUDIT_FILTER_URING_EXIT` 规则类型\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `fsnotify` 子系统（`<linux/fsnotify_backend.h>`）：提供文件系统事件通知\n  - 审计核心模块（`audit.h`）：规则管理、日志记录、哈希表操作\n  - VFS 层（`<linux/fs.h>`, `<linux/namei.h>`）：inode/dentry 操作\n\n- **关键交互**：\n  - 通过 `audit_filter_mutex` 与审计规则管理模块同步\n  - 调用 `audit_filter_inodes()` 确保事件发生时的审计记录完整性\n  - 使用 `audit_inode_hash` 哈希表管理基于 inode 的规则索引\n\n## 5. 使用场景\n\n1. **审计规则动态维护**  \n   当用户通过 `auditctl -w /path/to/file` 添加路径监控时，内核将路径解析为 inode 并注册 fsnotify 监控。后续文件移动/重命名时自动更新规则绑定的 inode。\n\n2. **文件系统事件响应**  \n   处理以下场景：\n   - 文件被移动到监控目录（触发 `FS_CREATE`）\n   - 监控文件被重命名（触发 `FS_MOVE`）\n   - 监控目录被卸载（触发 `FS_UNMOUNT`）\n   - 监控文件被删除（触发 `FS_DELETE`）\n\n3. **审计日志完整性保障**  \n   在 inode 变更过程中，通过 `audit_filter_inodes()` 确保变更期间的系统调用仍能被正确审计，避免监控间隙。\n\n4. **资源生命周期管理**  \n   通过引用计数确保：\n   - 规则存在时监控项不被释放\n   - 父目录无监控项时自动清理 fsnotify 标记\n   - 路径字符串内存的安全回收",
      "similarity": 0.6187688112258911,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/audit_watch.c",
          "start_line": 1,
          "end_line": 57,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/* audit_watch.c -- watching inodes",
            " *",
            " * Copyright 2003-2009 Red Hat, Inc.",
            " * Copyright 2005 Hewlett-Packard Development Company, L.P.",
            " * Copyright 2005 IBM Corporation",
            " */",
            "",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/audit.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/namei.h>",
            "#include <linux/netlink.h>",
            "#include <linux/refcount.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include \"audit.h\"",
            "",
            "/*",
            " * Reference counting:",
            " *",
            " * audit_parent: lifetime is from audit_init_parent() to receipt of an FS_IGNORED",
            " * \tevent.  Each audit_watch holds a reference to its associated parent.",
            " *",
            " * audit_watch: if added to lists, lifetime is from audit_init_watch() to",
            " * \taudit_remove_watch().  Additionally, an audit_watch may exist",
            " * \ttemporarily to assist in searching existing filter data.  Each",
            " * \taudit_krule holds a reference to its associated watch.",
            " */",
            "",
            "struct audit_watch {",
            "\trefcount_t\t\tcount;\t/* reference count */",
            "\tdev_t\t\t\tdev;\t/* associated superblock device */",
            "\tchar\t\t\t*path;\t/* insertion path */",
            "\tunsigned long\t\tino;\t/* associated inode number */",
            "\tstruct audit_parent\t*parent; /* associated parent */",
            "\tstruct list_head\twlist;\t/* entry in parent->watches list */",
            "\tstruct list_head\trules;\t/* anchor for krule->rlist */",
            "};",
            "",
            "struct audit_parent {",
            "\tstruct list_head\twatches; /* anchor for audit_watch->wlist */",
            "\tstruct fsnotify_mark mark; /* fsnotify mark on the inode */",
            "};",
            "",
            "/* fsnotify handle. */",
            "static struct fsnotify_group *audit_watch_group;",
            "",
            "/* fsnotify events we care about. */",
            "#define AUDIT_FS_WATCH (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\",
            "\t\t\tFS_MOVE_SELF | FS_UNMOUNT)",
            ""
          ],
          "function_name": null,
          "description": "定义了audit_watch和audit_parent结构体，用于跟踪被审计的文件系统对象及其关联的监视器。声明了全局的fsnotify组用于文件系统事件通知，并定义了用于匹配文件系统事件的位掩码AUDIT_FS_WATCH。",
          "similarity": 0.5106300115585327
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/audit_watch.c",
          "start_line": 58,
          "end_line": 218,
          "content": [
            "static void audit_free_parent(struct audit_parent *parent)",
            "{",
            "\tWARN_ON(!list_empty(&parent->watches));",
            "\tkfree(parent);",
            "}",
            "static void audit_watch_free_mark(struct fsnotify_mark *entry)",
            "{",
            "\tstruct audit_parent *parent;",
            "",
            "\tparent = container_of(entry, struct audit_parent, mark);",
            "\taudit_free_parent(parent);",
            "}",
            "static void audit_get_parent(struct audit_parent *parent)",
            "{",
            "\tif (likely(parent))",
            "\t\tfsnotify_get_mark(&parent->mark);",
            "}",
            "static void audit_put_parent(struct audit_parent *parent)",
            "{",
            "\tif (likely(parent))",
            "\t\tfsnotify_put_mark(&parent->mark);",
            "}",
            "void audit_get_watch(struct audit_watch *watch)",
            "{",
            "\trefcount_inc(&watch->count);",
            "}",
            "void audit_put_watch(struct audit_watch *watch)",
            "{",
            "\tif (refcount_dec_and_test(&watch->count)) {",
            "\t\tWARN_ON(watch->parent);",
            "\t\tWARN_ON(!list_empty(&watch->rules));",
            "\t\tkfree(watch->path);",
            "\t\tkfree(watch);",
            "\t}",
            "}",
            "static void audit_remove_watch(struct audit_watch *watch)",
            "{",
            "\tlist_del(&watch->wlist);",
            "\taudit_put_parent(watch->parent);",
            "\twatch->parent = NULL;",
            "\taudit_put_watch(watch); /* match initial get */",
            "}",
            "int audit_watch_compare(struct audit_watch *watch, unsigned long ino, dev_t dev)",
            "{",
            "\treturn (watch->ino != AUDIT_INO_UNSET) &&",
            "\t\t(watch->ino == ino) &&",
            "\t\t(watch->dev == dev);",
            "}",
            "int audit_to_watch(struct audit_krule *krule, char *path, int len, u32 op)",
            "{",
            "\tstruct audit_watch *watch;",
            "",
            "\tif (!audit_watch_group)",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\tif (path[0] != '/' || path[len-1] == '/' ||",
            "\t    (krule->listnr != AUDIT_FILTER_EXIT &&",
            "\t     krule->listnr != AUDIT_FILTER_URING_EXIT) ||",
            "\t    op != Audit_equal ||",
            "\t    krule->inode_f || krule->watch || krule->tree)",
            "\t\treturn -EINVAL;",
            "",
            "\twatch = audit_init_watch(path);",
            "\tif (IS_ERR(watch))",
            "\t\treturn PTR_ERR(watch);",
            "",
            "\tkrule->watch = watch;",
            "",
            "\treturn 0;",
            "}",
            "static void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)",
            "{",
            "\tstruct audit_buffer *ab;",
            "",
            "\tif (!audit_enabled)",
            "\t\treturn;",
            "\tab = audit_log_start(audit_context(), GFP_NOFS, AUDIT_CONFIG_CHANGE);",
            "\tif (!ab)",
            "\t\treturn;",
            "\taudit_log_session_info(ab);",
            "\taudit_log_format(ab, \"op=%s path=\", op);",
            "\taudit_log_untrustedstring(ab, w->path);",
            "\taudit_log_key(ab, r->filterkey);",
            "\taudit_log_format(ab, \" list=%d res=1\", r->listnr);",
            "\taudit_log_end(ab);",
            "}",
            "static void audit_update_watch(struct audit_parent *parent,",
            "\t\t\t       const struct qstr *dname, dev_t dev,",
            "\t\t\t       unsigned long ino, unsigned invalidating)",
            "{",
            "\tstruct audit_watch *owatch, *nwatch, *nextw;",
            "\tstruct audit_krule *r, *nextr;",
            "\tstruct audit_entry *oentry, *nentry;",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\t/* Run all of the watches on this parent looking for the one that",
            "\t * matches the given dname */",
            "\tlist_for_each_entry_safe(owatch, nextw, &parent->watches, wlist) {",
            "\t\tif (audit_compare_dname_path(dname, owatch->path,",
            "\t\t\t\t\t     AUDIT_NAME_FULL))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* If the update involves invalidating rules, do the inode-based",
            "\t\t * filtering now, so we don't omit records. */",
            "\t\tif (invalidating && !audit_dummy_context())",
            "\t\t\taudit_filter_inodes(current, audit_context());",
            "",
            "\t\t/* updating ino will likely change which audit_hash_list we",
            "\t\t * are on so we need a new watch for the new list */",
            "\t\tnwatch = audit_dupe_watch(owatch);",
            "\t\tif (IS_ERR(nwatch)) {",
            "\t\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\t\taudit_panic(\"error updating watch, skipping\");",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tnwatch->dev = dev;",
            "\t\tnwatch->ino = ino;",
            "",
            "\t\tlist_for_each_entry_safe(r, nextr, &owatch->rules, rlist) {",
            "",
            "\t\t\toentry = container_of(r, struct audit_entry, rule);",
            "\t\t\tlist_del(&oentry->rule.rlist);",
            "\t\t\tlist_del_rcu(&oentry->list);",
            "",
            "\t\t\tnentry = audit_dupe_rule(&oentry->rule);",
            "\t\t\tif (IS_ERR(nentry)) {",
            "\t\t\t\tlist_del(&oentry->rule.list);",
            "\t\t\t\taudit_panic(\"error updating watch, removing\");",
            "\t\t\t} else {",
            "\t\t\t\tint h = audit_hash_ino((u32)ino);",
            "",
            "\t\t\t\t/*",
            "\t\t\t\t * nentry->rule.watch == oentry->rule.watch so",
            "\t\t\t\t * we must drop that reference and set it to our",
            "\t\t\t\t * new watch.",
            "\t\t\t\t */",
            "\t\t\t\taudit_put_watch(nentry->rule.watch);",
            "\t\t\t\taudit_get_watch(nwatch);",
            "\t\t\t\tnentry->rule.watch = nwatch;",
            "\t\t\t\tlist_add(&nentry->rule.rlist, &nwatch->rules);",
            "\t\t\t\tlist_add_rcu(&nentry->list, &audit_inode_hash[h]);",
            "\t\t\t\tlist_replace(&oentry->rule.list,",
            "\t\t\t\t\t     &nentry->rule.list);",
            "\t\t\t}",
            "\t\t\tif (oentry->rule.exe)",
            "\t\t\t\taudit_remove_mark(oentry->rule.exe);",
            "",
            "\t\t\tcall_rcu(&oentry->rcu, audit_free_rule_rcu);",
            "\t\t}",
            "",
            "\t\taudit_remove_watch(owatch);",
            "\t\tgoto add_watch_to_parent; /* event applies to a single watch */",
            "\t}",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\treturn;",
            "",
            "add_watch_to_parent:",
            "\tlist_add(&nwatch->wlist, &parent->watches);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\treturn;",
            "}"
          ],
          "function_name": "audit_free_parent, audit_watch_free_mark, audit_get_parent, audit_put_parent, audit_get_watch, audit_put_watch, audit_remove_watch, audit_watch_compare, audit_to_watch, audit_watch_log_rule_change, audit_update_watch",
          "description": "实现了审计监视器的引用计数管理、资源释放逻辑及动态更新机制。包含对监视器与规则的绑定解除、路径匹配判断、以及基于文件系统事件的监视器状态同步等功能。",
          "similarity": 0.49003422260284424
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/audit_watch.c",
          "start_line": 322,
          "end_line": 437,
          "content": [
            "static void audit_remove_parent_watches(struct audit_parent *parent)",
            "{",
            "\tstruct audit_watch *w, *nextw;",
            "\tstruct audit_krule *r, *nextr;",
            "\tstruct audit_entry *e;",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tlist_for_each_entry_safe(w, nextw, &parent->watches, wlist) {",
            "\t\tlist_for_each_entry_safe(r, nextr, &w->rules, rlist) {",
            "\t\t\te = container_of(r, struct audit_entry, rule);",
            "\t\t\taudit_watch_log_rule_change(r, w, \"remove_rule\");",
            "\t\t\tif (e->rule.exe)",
            "\t\t\t\taudit_remove_mark(e->rule.exe);",
            "\t\t\tlist_del(&r->rlist);",
            "\t\t\tlist_del(&r->list);",
            "\t\t\tlist_del_rcu(&e->list);",
            "\t\t\tcall_rcu(&e->rcu, audit_free_rule_rcu);",
            "\t\t}",
            "\t\taudit_remove_watch(w);",
            "\t}",
            "\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);",
            "}",
            "static int audit_get_nd(struct audit_watch *watch, struct path *parent)",
            "{",
            "\tstruct dentry *d = kern_path_locked(watch->path, parent);",
            "\tif (IS_ERR(d))",
            "\t\treturn PTR_ERR(d);",
            "\tif (d_is_positive(d)) {",
            "\t\t/* update watch filter fields */",
            "\t\twatch->dev = d->d_sb->s_dev;",
            "\t\twatch->ino = d_backing_inode(d)->i_ino;",
            "\t}",
            "\tinode_unlock(d_backing_inode(parent->dentry));",
            "\tdput(d);",
            "\treturn 0;",
            "}",
            "static void audit_add_to_parent(struct audit_krule *krule,",
            "\t\t\t\tstruct audit_parent *parent)",
            "{",
            "\tstruct audit_watch *w, *watch = krule->watch;",
            "\tint watch_found = 0;",
            "",
            "\tBUG_ON(!mutex_is_locked(&audit_filter_mutex));",
            "",
            "\tlist_for_each_entry(w, &parent->watches, wlist) {",
            "\t\tif (strcmp(watch->path, w->path))",
            "\t\t\tcontinue;",
            "",
            "\t\twatch_found = 1;",
            "",
            "\t\t/* put krule's ref to temporary watch */",
            "\t\taudit_put_watch(watch);",
            "",
            "\t\taudit_get_watch(w);",
            "\t\tkrule->watch = watch = w;",
            "",
            "\t\taudit_put_parent(parent);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tif (!watch_found) {",
            "\t\twatch->parent = parent;",
            "",
            "\t\taudit_get_watch(watch);",
            "\t\tlist_add(&watch->wlist, &parent->watches);",
            "\t}",
            "\tlist_add(&krule->rlist, &watch->rules);",
            "}",
            "int audit_add_watch(struct audit_krule *krule, struct list_head **list)",
            "{",
            "\tstruct audit_watch *watch = krule->watch;",
            "\tstruct audit_parent *parent;",
            "\tstruct path parent_path;",
            "\tint h, ret = 0;",
            "",
            "\t/*",
            "\t * When we will be calling audit_add_to_parent, krule->watch might have",
            "\t * been updated and watch might have been freed.",
            "\t * So we need to keep a reference of watch.",
            "\t */",
            "\taudit_get_watch(watch);",
            "",
            "\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t/* Avoid calling path_lookup under audit_filter_mutex. */",
            "\tret = audit_get_nd(watch, &parent_path);",
            "",
            "\t/* caller expects mutex locked */",
            "\tmutex_lock(&audit_filter_mutex);",
            "",
            "\tif (ret) {",
            "\t\taudit_put_watch(watch);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/* either find an old parent or attach a new one */",
            "\tparent = audit_find_parent(d_backing_inode(parent_path.dentry));",
            "\tif (!parent) {",
            "\t\tparent = audit_init_parent(&parent_path);",
            "\t\tif (IS_ERR(parent)) {",
            "\t\t\tret = PTR_ERR(parent);",
            "\t\t\tgoto error;",
            "\t\t}",
            "\t}",
            "",
            "\taudit_add_to_parent(krule, parent);",
            "",
            "\th = audit_hash_ino((u32)watch->ino);",
            "\t*list = &audit_inode_hash[h];",
            "error:",
            "\tpath_put(&parent_path);",
            "\taudit_put_watch(watch);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "audit_remove_parent_watches, audit_get_nd, audit_add_to_parent, audit_add_watch",
          "description": "提供了将审计规则附加到文件系统路径的实现，包含路径解析、现有监视器查找替换逻辑，以及根据文件系统变更事件更新审计规则的机制。",
          "similarity": 0.4874166250228882
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/audit_watch.c",
          "start_line": 447,
          "end_line": 533,
          "content": [
            "void audit_remove_watch_rule(struct audit_krule *krule)",
            "{",
            "\tstruct audit_watch *watch = krule->watch;",
            "\tstruct audit_parent *parent = watch->parent;",
            "",
            "\tlist_del(&krule->rlist);",
            "",
            "\tif (list_empty(&watch->rules)) {",
            "\t\t/*",
            "\t\t * audit_remove_watch() drops our reference to 'parent' which",
            "\t\t * can get freed. Grab our own reference to be safe.",
            "\t\t */",
            "\t\taudit_get_parent(parent);",
            "\t\taudit_remove_watch(watch);",
            "\t\tif (list_empty(&parent->watches))",
            "\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);",
            "\t\taudit_put_parent(parent);",
            "\t}",
            "}",
            "static int audit_watch_handle_event(struct fsnotify_mark *inode_mark, u32 mask,",
            "\t\t\t\t    struct inode *inode, struct inode *dir,",
            "\t\t\t\t    const struct qstr *dname, u32 cookie)",
            "{",
            "\tstruct audit_parent *parent;",
            "",
            "\tparent = container_of(inode_mark, struct audit_parent, mark);",
            "",
            "\tif (WARN_ON_ONCE(inode_mark->group != audit_watch_group))",
            "\t\treturn 0;",
            "",
            "\tif (mask & (FS_CREATE|FS_MOVED_TO) && inode)",
            "\t\taudit_update_watch(parent, dname, inode->i_sb->s_dev, inode->i_ino, 0);",
            "\telse if (mask & (FS_DELETE|FS_MOVED_FROM))",
            "\t\taudit_update_watch(parent, dname, AUDIT_DEV_UNSET, AUDIT_INO_UNSET, 1);",
            "\telse if (mask & (FS_DELETE_SELF|FS_UNMOUNT|FS_MOVE_SELF))",
            "\t\taudit_remove_parent_watches(parent);",
            "",
            "\treturn 0;",
            "}",
            "static int __init audit_watch_init(void)",
            "{",
            "\taudit_watch_group = fsnotify_alloc_group(&audit_watch_fsnotify_ops, 0);",
            "\tif (IS_ERR(audit_watch_group)) {",
            "\t\taudit_watch_group = NULL;",
            "\t\taudit_panic(\"cannot create audit fsnotify group\");",
            "\t}",
            "\treturn 0;",
            "}",
            "int audit_dupe_exe(struct audit_krule *new, struct audit_krule *old)",
            "{",
            "\tstruct audit_fsnotify_mark *audit_mark;",
            "\tchar *pathname;",
            "",
            "\tpathname = kstrdup(audit_mark_path(old->exe), GFP_KERNEL);",
            "\tif (!pathname)",
            "\t\treturn -ENOMEM;",
            "",
            "\taudit_mark = audit_alloc_mark(new, pathname, strlen(pathname));",
            "\tif (IS_ERR(audit_mark)) {",
            "\t\tkfree(pathname);",
            "\t\treturn PTR_ERR(audit_mark);",
            "\t}",
            "\tnew->exe = audit_mark;",
            "",
            "\treturn 0;",
            "}",
            "int audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)",
            "{",
            "\tstruct file *exe_file;",
            "\tunsigned long ino;",
            "\tdev_t dev;",
            "",
            "\t/* only do exe filtering if we are recording @current events/records */",
            "\tif (tsk != current)",
            "\t\treturn 0;",
            "",
            "\tif (!current->mm)",
            "\t\treturn 0;",
            "\texe_file = get_mm_exe_file(current->mm);",
            "\tif (!exe_file)",
            "\t\treturn 0;",
            "\tino = file_inode(exe_file)->i_ino;",
            "\tdev = file_inode(exe_file)->i_sb->s_dev;",
            "\tfput(exe_file);",
            "",
            "\treturn audit_mark_compare(mark, ino, dev);",
            "}"
          ],
          "function_name": "audit_remove_watch_rule, audit_watch_handle_event, audit_watch_init, audit_dupe_exe, audit_exe_compare",
          "description": "实现了文件系统事件监听初始化、事件回调处理及执行文件路径比对功能。包含监视器事件处理入口、审计模块初始化代码，以及用于进程执行文件审计匹配的专用比较函数。",
          "similarity": 0.45543187856674194
        }
      ]
    },
    {
      "source_file": "kernel/bpf/bpf_inode_storage.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:57:41\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bpf_inode_storage.c`\n\n---\n\n# `bpf/bpf_inode_storage.c` 技术文档\n\n## 1. 文件概述\n\n`bpf_inode_storage.c` 实现了 BPF（Berkeley Packet Filter）程序对 **inode 级别本地存储（local storage）** 的支持。该机制允许 BPF 程序将任意用户定义的数据与内核中的 `struct inode` 实例关联，从而在不修改 VFS 层或文件系统代码的前提下，为 inode 附加自定义元数据。此功能主要用于 LSM（Linux Security Module）钩子、审计、追踪等场景。\n\n该文件基于通用的 `bpf_local_storage` 框架，为 inode 对象定制了存储管理逻辑，并提供了 BPF 辅助函数（helpers）和 map 操作接口。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `DEFINE_BPF_STORAGE_CACHE(inode_cache)`：为 inode 存储分配的专用内存缓存。\n- `inode_storage_map_ops`：`bpf_map_ops` 操作集，定义了 inode 存储 map 的行为。\n- `bpf_inode_storage_btf_ids`：BTF（BPF Type Format）类型 ID 列表，用于类型安全检查。\n\n### 关键函数\n- **存储访问与管理**\n  - `inode_storage_ptr()`：获取 inode 对应的 BPF 存储指针。\n  - `inode_storage_lookup()`：在指定 inode 和 map 中查找存储数据。\n  - `bpf_inode_storage_free()`：在 inode 销毁时释放其关联的 BPF 存储。\n  - `inode_storage_delete()`：从 inode 中删除指定 map 的存储项。\n\n- **BPF Map 操作接口**\n  - `bpf_fd_inode_storage_lookup_elem()`：通过文件描述符（fd）查找 inode 存储数据。\n  - `bpf_fd_inode_storage_update_elem()`：通过 fd 更新 inode 存储。\n  - `bpf_fd_inode_storage_delete_elem()`：通过 fd 删除 inode 存储。\n\n- **BPF 辅助函数（Helpers）**\n  - `bpf_inode_storage_get()`：BPF 程序调用的辅助函数，用于获取或创建 inode 存储。\n  - `bpf_inode_storage_delete()`：BPF 程序调用的辅助函数，用于删除 inode 存储。\n\n- **Map 生命周期管理**\n  - `inode_storage_map_alloc()`：分配 inode 存储类型的 BPF map。\n  - `inode_storage_map_free()`：释放该类型 map。\n\n## 3. 关键实现\n\n### 存储绑定机制\n- 每个 `struct inode` 通过 `bpf_inode()` 宏访问其内嵌的 `struct bpf_storage_blob`（通常位于 inode 的安全字段或扩展字段中）。\n- `bpf_storage_blob` 包含一个 RCU 保护的 `struct bpf_local_storage *storage` 指针，指向实际的存储容器。\n- 所有存储操作均通过 `bpf_local_storage` 通用框架完成，确保线程安全和内存管理一致性。\n\n### RCU 与锁策略\n- 查找操作使用 `rcu_read_lock()` 保护，避免持有写锁。\n- 更新/删除操作在必要时使用自旋锁（由 `bpf_local_storage_update` 内部处理）。\n- `bpf_inode_storage_get` 要求调用者已持有 RCU 锁（通过 `bpf_rcu_lock_held()` 验证），确保 inode 不会在操作期间被释放。\n\n### 内存分配策略\n- 存储项分配使用 `GFP_ATOMIC`（在 fd-based 接口）或由 verifier 传入的 `gfp_flags`（在 helper 中），以适应不同上下文（如中断、软中断）。\n- 使用专用 SLAB 缓存 `inode_cache` 优化内存分配性能。\n\n### BPF Map 与 Helper 集成\n- 提供两种访问路径：\n  1. **BPF 程序直接调用 helper**（如 `bpf_inode_storage_get`），传入 `struct inode *`。\n  2. **用户空间通过 fd 操作 map**（如 `bpf_map_lookup_elem`），内核自动解析 fd 到 inode。\n- `map_get_next_key` 返回 `-ENOTSUPP`，表明该 map 不支持迭代。\n\n### 类型安全\n- 通过 BTF 类型 ID (`bpf_inode_storage_btf_ids`) 确保 BPF 程序传入的 `inode` 指针类型正确。\n- `arg2_type = ARG_PTR_TO_BTF_ID_OR_NULL` 允许传入空指针（安全处理）。\n\n## 4. 依赖关系\n\n- **核心依赖**\n  - `<linux/bpf_local_storage.h>`：提供通用本地存储框架。\n  - `<linux/bpf.h>`：BPF 核心基础设施。\n  - `<linux/rculist.h>` / `<linux/spinlock.h>`：并发控制原语。\n  - `<linux/fdtable.h>`：fd 解析支持。\n\n- **关联子系统**\n  - **VFS（Virtual File System）**：依赖 `struct inode` 结构及生命周期管理。\n  - **BPF 子系统**：集成到 BPF map 和 helper 机制中。\n  - **LSM（Linux Security Modules）**：常用于在 LSM 钩子中附加安全上下文。\n  - **BTF（BPF Type Format）**：用于运行时类型验证。\n\n- **内存管理**\n  - 依赖 SLAB 分配器创建专用缓存 `inode_cache`。\n  - 与 RCU 机制深度集成，确保存储项安全回收。\n\n## 5. 使用场景\n\n1. **LSM 安全策略扩展**\n   - 在 LSM 钩子（如 `file_open`、`inode_permission`）中，BPF 程序可为 inode 附加自定义安全标签或策略数据。\n\n2. **文件系统审计与监控**\n   - 追踪特定 inode 的访问模式，记录额外审计信息（如首次访问时间、访问者 UID）。\n\n3. **资源配额与限制**\n   - 为 inode 关联配额计数器，实现细粒度资源控制（如单个文件的 I/O 限速）。\n\n4. **调试与性能分析**\n   - 在 BPF 程序中为热点 inode 附加调试信息，辅助性能调优。\n\n5. **用户空间工具集成**\n   - 通过 fd 操作 map，用户空间程序可查询/修改 inode 的 BPF 存储（如 `bpftool` 调试）。\n\n> **注意**：由于 inode 可能被频繁创建/销毁，BPF 程序必须确保在安全上下文中调用 helper（如持有 inode 引用或处于 RCU 临界区），避免访问已释放内存。",
      "similarity": 0.5818725228309631,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bpf_inode_storage.c",
          "start_line": 1,
          "end_line": 56,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (c) 2019 Facebook",
            " * Copyright 2020 Google LLC.",
            " */",
            "",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <net/sock.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/rcupdate_trace.h>",
            "",
            "DEFINE_BPF_STORAGE_CACHE(inode_cache);",
            "",
            "static struct bpf_local_storage __rcu **",
            "inode_storage_ptr(void *owner)",
            "{",
            "\tstruct inode *inode = owner;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn NULL;",
            "\treturn &bsb->storage;",
            "}",
            "",
            "static struct bpf_local_storage_data *inode_storage_lookup(struct inode *inode,",
            "\t\t\t\t\t\t\t   struct bpf_map *map,",
            "\t\t\t\t\t\t\t   bool cacheit_lockit)",
            "{",
            "\tstruct bpf_local_storage *inode_storage;",
            "\tstruct bpf_local_storage_map *smap;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn NULL;",
            "",
            "\tinode_storage =",
            "\t\trcu_dereference_check(bsb->storage, bpf_rcu_lock_held());",
            "\tif (!inode_storage)",
            "\t\treturn NULL;",
            "",
            "\tsmap = (struct bpf_local_storage_map *)map;",
            "\treturn bpf_local_storage_lookup(inode_storage, smap, cacheit_lockit);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义inode级别的BPF本地存储缓存inode_cache，并提供用于获取inode存储指针及查询特定map中存储数据的辅助函数。其中inode_storage_lookup通过RCU读锁安全地检索存储实例并调用底层BPF本地存储查找逻辑。",
          "similarity": 0.5588191747665405
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bpf_inode_storage.c",
          "start_line": 57,
          "end_line": 121,
          "content": [
            "void bpf_inode_storage_free(struct inode *inode)",
            "{",
            "\tstruct bpf_local_storage *local_storage;",
            "\tstruct bpf_storage_blob *bsb;",
            "",
            "\tbsb = bpf_inode(inode);",
            "\tif (!bsb)",
            "\t\treturn;",
            "",
            "\trcu_read_lock();",
            "",
            "\tlocal_storage = rcu_dereference(bsb->storage);",
            "\tif (!local_storage) {",
            "\t\trcu_read_unlock();",
            "\t\treturn;",
            "\t}",
            "",
            "\tbpf_local_storage_destroy(local_storage);",
            "\trcu_read_unlock();",
            "}",
            "static long bpf_fd_inode_storage_update_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t\t     void *value, u64 map_flags)",
            "{",
            "\tstruct bpf_local_storage_data *sdata;",
            "\tCLASS(fd_raw, f)(*(int *)key);",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "\tif (!inode_storage_ptr(file_inode(fd_file(f))))",
            "\t\treturn -EBADF;",
            "",
            "\tsdata = bpf_local_storage_update(file_inode(fd_file(f)),",
            "\t\t\t\t\t (struct bpf_local_storage_map *)map,",
            "\t\t\t\t\t value, map_flags, false, GFP_ATOMIC);",
            "\treturn PTR_ERR_OR_ZERO(sdata);",
            "}",
            "static int inode_storage_delete(struct inode *inode, struct bpf_map *map)",
            "{",
            "\tstruct bpf_local_storage_data *sdata;",
            "",
            "\tsdata = inode_storage_lookup(inode, map, false);",
            "\tif (!sdata)",
            "\t\treturn -ENOENT;",
            "",
            "\tbpf_selem_unlink(SELEM(sdata), false);",
            "",
            "\treturn 0;",
            "}",
            "static long bpf_fd_inode_storage_delete_elem(struct bpf_map *map, void *key)",
            "{",
            "\tCLASS(fd_raw, f)(*(int *)key);",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "\treturn inode_storage_delete(file_inode(fd_file(f)), map);",
            "}",
            "static int notsupp_get_next_key(struct bpf_map *map, void *key,",
            "\t\t\t\tvoid *next_key)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "static void inode_storage_map_free(struct bpf_map *map)",
            "{",
            "\tbpf_local_storage_map_free(map, &inode_cache, NULL);",
            "}"
          ],
          "function_name": "bpf_inode_storage_free, bpf_fd_inode_storage_update_elem, inode_storage_delete, bpf_fd_inode_storage_delete_elem, notsupp_get_next_key, inode_storage_map_free",
          "description": "实现inode相关BPF存储资源的释放、更新、删除操作。包含释放存储空间、通过文件描述符更新存储项、删除存储条目等功能，同时注册了不支持的get_next_key操作并实现map销毁时的缓存回收逻辑。",
          "similarity": 0.536904513835907
        }
      ]
    }
  ]
}