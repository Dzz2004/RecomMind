{
  "query": "特权模式下的资源访问权限",
  "timestamp": "2025-12-25 23:59:12",
  "retrieved_files": [
    {
      "source_file": "kernel/capability.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:39:00\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `capability.c`\n\n---\n\n# capability.c 技术文档\n\n## 1. 文件概述\n\n`capability.c` 是 Linux 内核中实现 POSIX 能力（Capabilities）机制的核心文件，位于 `kernel/` 目录下。该文件主要负责提供用户空间与内核之间进行能力获取（`capget`）和设置（`capset`）的系统调用接口，并维护能力模型的版本兼容性、安全策略检查以及与 LSM（Linux Security Module）框架的集成。能力机制允许将传统超级用户权限细分为多个独立的特权单元，从而实现最小权限原则。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `file_caps_enabled`：控制是否启用文件能力（File Capabilities）功能的全局开关，默认启用。可通过内核启动参数 `no_file_caps` 禁用。\n\n### 主要函数\n- **`cap_validate_magic()`**：验证用户传入的能力结构体版本号，支持 v1、v2、v3 版本，并对旧版本发出警告。\n- **`cap_get_target_pid()`**：安全地获取指定进程（通过 PID）的有效（Effective）、可继承（Inheritable）和允许（Permitted）能力集。\n- **`sys_capget()`**：`capget(2)` 系统调用的实现，用于查询指定进程的能力集。\n- **`sys_capset()`**：`capset(2)` 系统调用的实现，用于设置当前进程的能力集（仅限自身）。\n- **`mk_kernel_cap()`**：将用户空间传入的高低 32 位能力值组合成内核内部的 `kernel_cap_t` 类型。\n- **`has_ns_capability()`**（截断）：检查指定任务在给定用户命名空间中是否拥有某项能力（函数体在提供的代码中被截断）。\n\n### 辅助函数\n- `warn_legacy_capability_use()`：对使用 v1（32 位）能力接口的应用程序发出一次性警告。\n- `warn_deprecated_v2()`：对使用已弃用的 v2 能力接口的应用程序发出一次性警告。\n\n## 3. 关键实现\n\n### 能力版本兼容性处理\n- 支持三种能力结构版本：\n  - **v1 (`_LINUX_CAPABILITY_VERSION_1`)**：仅支持 32 位能力（旧版），调用时触发 `warn_legacy_capability_use()`。\n  - **v2 (`_LINUX_CAPABILITY_VERSION_2`)**：支持 64 位能力但存在安全风险，调用时触发 `warn_deprecated_v2()`。\n  - **v3 (`_LINUX_CAPABILITY_VERSION_3`)**：当前推荐版本，功能等同于 v2 但通过头文件变更避免误用。\n- 对于无效版本，内核会尝试将当前支持的版本号写回用户空间并返回 `-EINVAL`。\n\n### 能力数据传输格式\n- 用户空间使用两个 `__user_cap_data_struct` 结构体（`kdata[2]`）来表示 64 位能力值：\n  - `kdata[0]` 存储低 32 位\n  - `kdata[1]` 存储高 32 位\n- 在 `capget` 中，内核能力值被拆分为高低 32 位写入用户缓冲区；在 `capset` 中则反向组合。\n- **向后兼容策略**：当用户空间请求的版本只支持 32 位（`tocopy = 1`）时，内核会静默丢弃高 32 位能力，避免旧版 `libcap` 应用崩溃。\n\n### 安全限制\n- **`capset` 限制**：仅允许进程修改自身能力（`pid` 必须为 0 或当前进程 PID），修改其他进程能力的功能已被移除。\n- **能力设置规则**（由 LSM 实现，如 `security_capset`）：\n  - 新的 **可继承集（I）** 和 **允许集（P）** 只能是旧允许集的子集。\n  - 新的 **有效集（E）** 必须是新允许集的子集。\n- 使用 `prepare_creds()` / `commit_creds()` 机制安全地更新进程凭证（credentials），并在失败时通过 `abort_creds()` 回滚。\n\n### 并发与锁机制\n- 获取**其他进程**能力时，使用 `rcu_read_lock()` 保护对进程链表的访问（通过 `find_task_by_vpid()`）。\n- 获取**当前进程**能力时无需加锁，因为能力修改是原子的（通过凭证替换）。\n\n### 审计与日志\n- `capset` 成功时调用 `audit_log_capset()` 记录能力变更事件，用于安全审计。\n- 对旧版能力接口的使用通过 `pr_info_once()` 发出一次性内核日志警告。\n\n## 4. 依赖关系\n\n- **LSM 框架**：通过 `security_capget()` 和 `security_capset()` 钩子与安全模块（如 SELinux、AppArmor）交互，实际的能力检查和设置策略由 LSM 实现。\n- **凭证子系统**：依赖 `cred` 结构体管理进程权限，使用 `prepare_creds()`、`commit_creds()` 等函数安全更新。\n- **命名空间**：支持用户命名空间（`user_namespace.h`），能力检查与命名空间隔离相关（体现在 `has_ns_capability` 等函数中）。\n- **审计子系统**：通过 `audit.h` 提供能力变更的审计日志。\n- **系统调用接口**：通过 `SYSCALL_DEFINE2` 定义 `capget` 和 `capset` 系统调用。\n- **用户空间访问**：使用 `uaccess.h` 中的 `copy_to_user()` 和 `copy_from_user()` 安全传输数据。\n\n## 5. 使用场景\n\n- **容器与沙箱**：容器运行时（如 Docker、runc）通过 `capset` 限制容器内进程的能力集，实现权限隔离。\n- **特权程序降权**：需要临时提升权限的程序（如 `ping` 使用 `CAP_NET_RAW`）可在执行关键操作后通过 `capset` 丢弃多余能力。\n- **安全策略实施**：系统管理员或安全模块通过限制进程能力，遵循最小权限原则，减少攻击面。\n- **调试与监控**：安全工具（如 `getpcaps`）通过 `capget` 查询进程当前能力状态，用于诊断或合规检查。\n- **文件能力加载**：虽然本文件不直接处理文件能力，但 `file_caps_enabled` 开关控制是否启用基于文件扩展属性（xattr）的能力加载机制（由 `fs/` 子系统实现）。",
      "similarity": 0.5729506611824036,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/capability.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * linux/kernel/capability.c",
            " *",
            " * Copyright (C) 1997  Andrew Main <zefram@fysh.org>",
            " *",
            " * Integrated into 2.1.97+,  Andrew G. Morgan <morgan@kernel.org>",
            " * 30 May 2002:\tCleanup, Robert M. Love <rml@tech9.net>",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/uaccess.h>",
            "",
            "int file_caps_enabled = 1;",
            ""
          ],
          "function_name": null,
          "description": "声明模块许可证并包含必要的头文件，定义控制文件能力启用状态的全局变量file_caps_enabled",
          "similarity": 0.5515889525413513
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/capability.c",
          "start_line": 25,
          "end_line": 125,
          "content": [
            "static int __init file_caps_disable(char *str)",
            "{",
            "\tfile_caps_enabled = 0;",
            "\treturn 1;",
            "}",
            "static void warn_legacy_capability_use(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static void warn_deprecated_v2(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static int cap_validate_magic(cap_user_header_t header, unsigned *tocopy)",
            "{",
            "\t__u32 version;",
            "",
            "\tif (get_user(version, &header->version))",
            "\t\treturn -EFAULT;",
            "",
            "\tswitch (version) {",
            "\tcase _LINUX_CAPABILITY_VERSION_1:",
            "\t\twarn_legacy_capability_use();",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_1;",
            "\t\tbreak;",
            "\tcase _LINUX_CAPABILITY_VERSION_2:",
            "\t\twarn_deprecated_v2();",
            "\t\tfallthrough;\t/* v3 is otherwise equivalent to v2 */",
            "\tcase _LINUX_CAPABILITY_VERSION_3:",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_3;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tif (put_user((u32)_KERNEL_CAPABILITY_VERSION, &header->version))",
            "\t\t\treturn -EFAULT;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,",
            "\t\t\t\t     kernel_cap_t *pIp, kernel_cap_t *pPp)",
            "{",
            "\tint ret;",
            "",
            "\tif (pid && (pid != task_pid_vnr(current))) {",
            "\t\tconst struct task_struct *target;",
            "",
            "\t\trcu_read_lock();",
            "",
            "\t\ttarget = find_task_by_vpid(pid);",
            "\t\tif (!target)",
            "\t\t\tret = -ESRCH;",
            "\t\telse",
            "\t\t\tret = security_capget(target, pEp, pIp, pPp);",
            "",
            "\t\trcu_read_unlock();",
            "\t} else",
            "\t\tret = security_capget(current, pEp, pIp, pPp);",
            "",
            "\treturn ret;",
            "}",
            "static kernel_cap_t mk_kernel_cap(u32 low, u32 high)",
            "{",
            "\treturn (kernel_cap_t) { (low | ((u64)high << 32)) & CAP_VALID_MASK };",
            "}",
            "bool has_ns_capability(struct task_struct *t,",
            "\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability(t, &init_user_ns, cap);",
            "}",
            "bool has_ns_capability_noaudit(struct task_struct *t,",
            "\t\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability_noaudit(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);",
            "}"
          ],
          "function_name": "file_caps_disable, warn_legacy_capability_use, warn_deprecated_v2, cap_validate_magic, cap_get_target_pid, mk_kernel_cap, has_ns_capability, has_capability, has_ns_capability_noaudit, has_capability_noaudit",
          "description": "提供能力相关辅助函数，包括禁用文件能力标志、版本验证警告、目标进程能力获取及能力结构构建，实现命名空间能力检查和权限验证逻辑",
          "similarity": 0.5470213294029236
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/capability.c",
          "start_line": 351,
          "end_line": 424,
          "content": [
            "static bool ns_capable_common(struct user_namespace *ns,",
            "\t\t\t      int cap,",
            "\t\t\t      unsigned int opts)",
            "{",
            "\tint capable;",
            "",
            "\tif (unlikely(!cap_valid(cap))) {",
            "\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);",
            "\t\tBUG();",
            "\t}",
            "",
            "\tcapable = security_capable(current_cred(), ns, cap, opts);",
            "\tif (capable == 0) {",
            "\t\tcurrent->flags |= PF_SUPERPRIV;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "bool ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NONE);",
            "}",
            "bool ns_capable_noaudit(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);",
            "}",
            "bool ns_capable_setid(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);",
            "}",
            "bool capable(int cap)",
            "{",
            "\treturn ns_capable(&init_user_ns, cap);",
            "}",
            "bool file_ns_capable(const struct file *file, struct user_namespace *ns,",
            "\t\t     int cap)",
            "{",
            "",
            "\tif (WARN_ON_ONCE(!cap_valid(cap)))",
            "\t\treturn false;",
            "",
            "\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "bool privileged_wrt_inode_uidgid(struct user_namespace *ns,",
            "\t\t\t\t struct mnt_idmap *idmap,",
            "\t\t\t\t const struct inode *inode)",
            "{",
            "\treturn vfsuid_has_mapping(ns, i_uid_into_vfsuid(idmap, inode)) &&",
            "\t       vfsgid_has_mapping(ns, i_gid_into_vfsgid(idmap, inode));",
            "}",
            "bool capable_wrt_inode_uidgid(struct mnt_idmap *idmap,",
            "\t\t\t      const struct inode *inode, int cap)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "",
            "\treturn ns_capable(ns, cap) &&",
            "\t       privileged_wrt_inode_uidgid(ns, idmap, inode);",
            "}",
            "bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)",
            "{",
            "\tint ret = 0;  /* An absent tracer adds no restrictions */",
            "\tconst struct cred *cred;",
            "",
            "\trcu_read_lock();",
            "\tcred = rcu_dereference(tsk->ptracer_cred);",
            "\tif (cred)",
            "\t\tret = security_capable(cred, ns, CAP_SYS_PTRACE,",
            "\t\t\t\t       CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "\treturn (ret == 0);",
            "}"
          ],
          "function_name": "ns_capable_common, ns_capable, ns_capable_noaudit, ns_capable_setid, capable, file_ns_capable, privileged_wrt_inode_uidgid, capable_wrt_inode_uidgid, ptracer_capable",
          "description": "实现核心能力检查函数，包含通用命名空间能力检测、当前命名空间能力检查、文件能力验证、基于inode UID/GID的特权判断及跟踪者能力检查等功能",
          "similarity": 0.5395975112915039
        }
      ]
    },
    {
      "source_file": "kernel/resource.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:53:12\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `resource.c`\n\n---\n\n# resource.c 技术文档\n\n## 1. 文件概述\n\n`resource.c` 是 Linux 内核中用于管理和分配系统资源（如 I/O 端口和内存区域）的核心实现文件。它提供了一套通用的资源树管理机制，支持资源的申请、释放、查找和冲突检测。该文件维护了两个全局根资源节点：`ioport_resource`（用于 I/O 端口空间）和 `iomem_resource`（用于内存映射 I/O 空间），并通过树形结构组织所有已分配的子资源，确保资源分配的唯一性和安全性。\n\n## 2. 核心功能\n\n### 主要全局数据结构\n- `struct resource ioport_resource`：I/O 端口资源的根节点，范围为 `[0, IO_SPACE_LIMIT]`，标志为 `IORESOURCE_IO`。\n- `struct resource iomem_resource`：内存映射 I/O 资源的根节点，范围为 `[0, -1]`（即全地址空间），标志为 `IORESOURCE_MEM`。\n- `struct resource_constraint`：用于描述资源分配时的约束条件（最小/最大地址、对齐要求及自定义对齐函数）。\n\n### 关键函数\n- `request_resource(struct resource *root, struct resource *new)`：尝试在指定根资源下申请一段新资源，成功返回 0，冲突返回 `-EBUSY`。\n- `request_resource_conflict(...)`：与 `request_resource` 类似，但冲突时直接返回冲突的资源指针。\n- `release_resource(struct resource *old)`：释放已分配的资源。\n- `release_child_resources(struct resource *r)`：递归释放指定资源的所有子资源。\n- `find_next_iomem_res(...)`：在 `iomem_resource` 树中查找与指定区间 `[start, end]` 重叠且满足标志和描述符条件的下一个内存资源。\n- `for_each_resource` 宏：遍历资源树的通用宏，支持是否跳过子树的选项。\n\n### /proc 接口（条件编译）\n- 通过 `CONFIG_PROC_FS` 启用时，注册 `/proc/ioports` 和 `/proc/iomem` 文件，以树形格式展示当前系统中已分配的 I/O 端口和内存资源（仅对 `CAP_SYS_ADMIN` 权限用户显示实际地址）。\n\n## 3. 关键实现\n\n### 资源树结构\n- 资源以多叉树形式组织，每个 `struct resource` 包含 `child`（第一个子节点）、`sibling`（下一个兄弟节点）和 `parent` 指针。\n- 树内节点按起始地址升序排列，便于快速查找和插入。\n\n### 资源申请（`__request_resource`）\n- 在持有写锁 `resource_lock` 的前提下，遍历根节点的子链表。\n- 若新资源与现有节点无重叠，则按地址顺序插入；若存在重叠，则返回冲突节点。\n- 插入操作维护树的有序性：新节点插入到第一个起始地址大于其结束地址的节点之前。\n\n### 资源释放（`__release_resource`）\n- 支持两种模式：完全释放（含子资源）或仅提升子资源（当 `release_child=false` 时，将子节点直接挂到父节点下）。\n- 释放时调整兄弟链表指针，确保树结构完整性。\n\n### 资源遍历\n- `next_resource()`：深度优先遍历（先子节点，再兄弟节点）。\n- `next_resource_skip_children()`：仅遍历同级兄弟节点，跳过子树。\n- `/proc` 显示使用深度优先遍历，并限制最大显示层级（`MAX_IORES_LEVEL=5`）以避免过深嵌套。\n\n### 内存管理\n- 资源结构体通过 `alloc_resource()`（即 `kzalloc`）分配，通过 `free_resource()` 释放。\n- 注释指出：若资源由早期 `memblock` 分配，则无法安全释放（因非页对齐），会轻微泄漏，这是有意为之的简化设计。\n\n### 并发控制\n- 使用读写锁 `resource_lock` 保护全局资源树：\n  - 读操作（如 `/proc` 显示、`find_next_iomem_res`）使用 `read_lock`。\n  - 写操作（申请/释放资源）使用 `write_lock`。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/ioport.h>`：定义 `struct resource` 及相关宏（如 `IORESOURCE_IO`）。\n  - `<linux/proc_fs.h>`、`<linux/seq_file.h>`：实现 `/proc` 接口。\n  - `<linux/slab.h>`：资源结构体的动态分配。\n  - `<linux/spinlock.h>`：读写锁 `resource_lock` 的实现。\n  - `<asm/io.h>`：架构相关的 I/O 定义（如 `IO_SPACE_LIMIT`）。\n- **导出符号**：\n  - `ioport_resource`、`iomem_resource`、`request_resource`、`release_resource` 通过 `EXPORT_SYMBOL` 导出，供其他内核模块（如 PCI、platform_device 驱动）使用。\n- **配置依赖**：\n  - `/proc` 接口依赖 `CONFIG_PROC_FS`。\n\n## 5. 使用场景\n\n- **设备驱动资源管理**：PCI、platform 等总线驱动在探测设备时，调用 `request_resource()` 申请 I/O 端口或内存区域，防止资源冲突。\n- **固件/ACPI 资源解析**：内核解析 ACPI 表或 EFI 内存映射时，将保留区域注册到 `iomem_resource` 树中。\n- **系统调试与监控**：用户空间通过 `/proc/ioports` 和 `/proc/iomem` 查看硬件资源分配情况（需 root 权限）。\n- **内核子系统协作**：内存管理子系统（如 `devm_request_mem_region`）、DMA 引擎等依赖此机制确保物理地址资源的独占使用。\n- **热插拔支持**：设备移除时调用 `release_resource()` 释放资源，供后续设备重用。",
      "similarity": 0.5723555088043213,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/resource.c",
          "start_line": 802,
          "end_line": 912,
          "content": [
            "int allocate_resource(struct resource *root, struct resource *new,",
            "\t\t      resource_size_t size, resource_size_t min,",
            "\t\t      resource_size_t max, resource_size_t align,",
            "\t\t      resource_size_t (*alignf)(void *,",
            "\t\t\t\t\t\tconst struct resource *,",
            "\t\t\t\t\t\tresource_size_t,",
            "\t\t\t\t\t\tresource_size_t),",
            "\t\t      void *alignf_data)",
            "{",
            "\tint err;",
            "\tstruct resource_constraint constraint;",
            "",
            "\tif (!alignf)",
            "\t\talignf = simple_align_resource;",
            "",
            "\tconstraint.min = min;",
            "\tconstraint.max = max;",
            "\tconstraint.align = align;",
            "\tconstraint.alignf = alignf;",
            "\tconstraint.alignf_data = alignf_data;",
            "",
            "\tif ( new->parent ) {",
            "\t\t/* resource is already allocated, try reallocating with",
            "\t\t   the new constraints */",
            "\t\treturn reallocate_resource(root, new, size, &constraint);",
            "\t}",
            "",
            "\twrite_lock(&resource_lock);",
            "\terr = find_resource(root, new, size, &constraint);",
            "\tif (err >= 0 && __request_resource(root, new))",
            "\t\terr = -EBUSY;",
            "\twrite_unlock(&resource_lock);",
            "\treturn err;",
            "}",
            "int insert_resource(struct resource *parent, struct resource *new)",
            "{",
            "\tstruct resource *conflict;",
            "",
            "\tconflict = insert_resource_conflict(parent, new);",
            "\treturn conflict ? -EBUSY : 0;",
            "}",
            "void insert_resource_expand_to_fit(struct resource *root, struct resource *new)",
            "{",
            "\tif (new->parent)",
            "\t\treturn;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tfor (;;) {",
            "\t\tstruct resource *conflict;",
            "",
            "\t\tconflict = __insert_resource(root, new);",
            "\t\tif (!conflict)",
            "\t\t\tbreak;",
            "\t\tif (conflict == root)",
            "\t\t\tbreak;",
            "",
            "\t\t/* Ok, expand resource to cover the conflict, then try again .. */",
            "\t\tif (conflict->start < new->start)",
            "\t\t\tnew->start = conflict->start;",
            "\t\tif (conflict->end > new->end)",
            "\t\t\tnew->end = conflict->end;",
            "",
            "\t\tpr_info(\"Expanded resource %s due to conflict with %s\\n\", new->name, conflict->name);",
            "\t}",
            "\twrite_unlock(&resource_lock);",
            "}",
            "int remove_resource(struct resource *old)",
            "{",
            "\tint retval;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tretval = __release_resource(old, false);",
            "\twrite_unlock(&resource_lock);",
            "\treturn retval;",
            "}",
            "static int __adjust_resource(struct resource *res, resource_size_t start,",
            "\t\t\t\tresource_size_t size)",
            "{",
            "\tstruct resource *tmp, *parent = res->parent;",
            "\tresource_size_t end = start + size - 1;",
            "\tint result = -EBUSY;",
            "",
            "\tif (!parent)",
            "\t\tgoto skip;",
            "",
            "\tif ((start < parent->start) || (end > parent->end))",
            "\t\tgoto out;",
            "",
            "\tif (res->sibling && (res->sibling->start <= end))",
            "\t\tgoto out;",
            "",
            "\ttmp = parent->child;",
            "\tif (tmp != res) {",
            "\t\twhile (tmp->sibling != res)",
            "\t\t\ttmp = tmp->sibling;",
            "\t\tif (start <= tmp->end)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "skip:",
            "\tfor (tmp = res->child; tmp; tmp = tmp->sibling)",
            "\t\tif ((tmp->start < start) || (tmp->end > end))",
            "\t\t\tgoto out;",
            "",
            "\tres->start = start;",
            "\tres->end = end;",
            "\tresult = 0;",
            "",
            " out:",
            "\treturn result;",
            "}"
          ],
          "function_name": "allocate_resource, insert_resource, insert_resource_expand_to_fit, remove_resource, __adjust_resource",
          "description": "实现资源分配逻辑，支持带约束条件的资源查找与申请，处理资源冲突及扩展调整，提供基础资源管理框架。",
          "similarity": 0.5952479839324951
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/resource.c",
          "start_line": 1739,
          "end_line": 1846,
          "content": [
            "int iomem_map_sanity_check(resource_size_t addr, unsigned long size)",
            "{",
            "\tstruct resource *p = &iomem_resource;",
            "\tresource_size_t end = addr + size - 1;",
            "\tint err = 0;",
            "\tloff_t l;",
            "",
            "\tread_lock(&resource_lock);",
            "\tfor (p = p->child; p ; p = r_next(NULL, p, &l)) {",
            "\t\t/*",
            "\t\t * We can probably skip the resources without",
            "\t\t * IORESOURCE_IO attribute?",
            "\t\t */",
            "\t\tif (p->start > end)",
            "\t\t\tcontinue;",
            "\t\tif (p->end < addr)",
            "\t\t\tcontinue;",
            "\t\tif (PFN_DOWN(p->start) <= PFN_DOWN(addr) &&",
            "\t\t    PFN_DOWN(p->end) >= PFN_DOWN(end))",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * if a resource is \"BUSY\", it's not a hardware resource",
            "\t\t * but a driver mapping of such a resource; we don't want",
            "\t\t * to warn for those; some drivers legitimately map only",
            "\t\t * partial hardware resources. (example: vesafb)",
            "\t\t */",
            "\t\tif (p->flags & IORESOURCE_BUSY)",
            "\t\t\tcontinue;",
            "",
            "\t\tpr_warn(\"resource sanity check: requesting [mem %pa-%pa], which spans more than %s %pR\\n\",",
            "\t\t\t&addr, &end, p->name, p);",
            "\t\terr = -1;",
            "\t\tbreak;",
            "\t}",
            "\tread_unlock(&resource_lock);",
            "",
            "\treturn err;",
            "}",
            "bool resource_is_exclusive(struct resource *root, u64 addr, resource_size_t size)",
            "{",
            "\tconst unsigned int exclusive_system_ram = IORESOURCE_SYSTEM_RAM |",
            "\t\t\t\t\t\t  IORESOURCE_EXCLUSIVE;",
            "\tbool skip_children = false, err = false;",
            "\tstruct resource *p;",
            "",
            "\tread_lock(&resource_lock);",
            "\tfor_each_resource(root, p, skip_children) {",
            "\t\tif (p->start >= addr + size)",
            "\t\t\tbreak;",
            "\t\tif (p->end < addr) {",
            "\t\t\tskip_children = true;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tskip_children = false;",
            "",
            "\t\t/*",
            "\t\t * IORESOURCE_SYSTEM_RAM resources are exclusive if",
            "\t\t * IORESOURCE_EXCLUSIVE is set, even if they",
            "\t\t * are not busy and even if \"iomem=relaxed\" is set. The",
            "\t\t * responsible driver dynamically adds/removes system RAM within",
            "\t\t * such an area and uncontrolled access is dangerous.",
            "\t\t */",
            "\t\tif ((p->flags & exclusive_system_ram) == exclusive_system_ram) {",
            "\t\t\terr = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * A resource is exclusive if IORESOURCE_EXCLUSIVE is set",
            "\t\t * or CONFIG_IO_STRICT_DEVMEM is enabled and the",
            "\t\t * resource is busy.",
            "\t\t */",
            "\t\tif (!strict_iomem_checks || !(p->flags & IORESOURCE_BUSY))",
            "\t\t\tcontinue;",
            "\t\tif (IS_ENABLED(CONFIG_IO_STRICT_DEVMEM)",
            "\t\t\t\t|| p->flags & IORESOURCE_EXCLUSIVE) {",
            "\t\t\terr = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tread_unlock(&resource_lock);",
            "",
            "\treturn err;",
            "}",
            "bool iomem_is_exclusive(u64 addr)",
            "{",
            "\treturn resource_is_exclusive(&iomem_resource, addr & PAGE_MASK,",
            "\t\t\t\t     PAGE_SIZE);",
            "}",
            "void resource_list_free(struct list_head *head)",
            "{",
            "\tstruct resource_entry *entry, *tmp;",
            "",
            "\tlist_for_each_entry_safe(entry, tmp, head, node)",
            "\t\tresource_list_destroy_entry(entry);",
            "}",
            "static resource_size_t gfr_start(struct resource *base, resource_size_t size,",
            "\t\t\t\t resource_size_t align, unsigned long flags)",
            "{",
            "\tif (flags & GFR_DESCENDING) {",
            "\t\tresource_size_t end;",
            "",
            "\t\tend = min_t(resource_size_t, base->end, PHYSMEM_END);",
            "\t\treturn end - size + 1;",
            "\t}",
            "",
            "\treturn ALIGN(base->start, align);",
            "}"
          ],
          "function_name": "iomem_map_sanity_check, resource_is_exclusive, iomem_is_exclusive, resource_list_free, gfr_start",
          "description": "iomem_map_sanity_check 检查新请求的I/O内存区域是否与现有资源冲突，若存在覆盖则返回-1；resource_is_exclusive 判断目标地址是否属于独占资源，依据IORESOURCE_EXCLUSIVE标志及CONFIG_IO_STRICT_DEVMEM配置；iomem_is_exclusive 简化调用resource_is_exclusive检查单个地址；resource_list_free 遍历并销毁指定链表中的所有resource_entry；gfr_start 根据对齐方向计算起始地址，支持降序分配模式。",
          "similarity": 0.5863648653030396
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/resource.c",
          "start_line": 104,
          "end_line": 208,
          "content": [
            "static void r_stop(struct seq_file *m, void *v)",
            "\t__releases(resource_lock)",
            "{",
            "\tread_unlock(&resource_lock);",
            "}",
            "static int r_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct resource *root = pde_data(file_inode(m->file));",
            "\tstruct resource *r = v, *p;",
            "\tunsigned long long start, end;",
            "\tint width = root->end < 0x10000 ? 4 : 8;",
            "\tint depth;",
            "",
            "\tfor (depth = 0, p = r; depth < MAX_IORES_LEVEL; depth++, p = p->parent)",
            "\t\tif (p->parent == root)",
            "\t\t\tbreak;",
            "",
            "\tif (file_ns_capable(m->file, &init_user_ns, CAP_SYS_ADMIN)) {",
            "\t\tstart = r->start;",
            "\t\tend = r->end;",
            "\t} else {",
            "\t\tstart = end = 0;",
            "\t}",
            "",
            "\tseq_printf(m, \"%*s%0*llx-%0*llx : %s\\n\",",
            "\t\t\tdepth * 2, \"\",",
            "\t\t\twidth, start,",
            "\t\t\twidth, end,",
            "\t\t\tr->name ? r->name : \"<BAD>\");",
            "\treturn 0;",
            "}",
            "static int __init ioresources_init(void)",
            "{",
            "\tproc_create_seq_data(\"ioports\", 0, NULL, &resource_op,",
            "\t\t\t&ioport_resource);",
            "\tproc_create_seq_data(\"iomem\", 0, NULL, &resource_op, &iomem_resource);",
            "\treturn 0;",
            "}",
            "static void free_resource(struct resource *res)",
            "{",
            "\t/**",
            "\t * If the resource was allocated using memblock early during boot",
            "\t * we'll leak it here: we can only return full pages back to the",
            "\t * buddy and trying to be smart and reusing them eventually in",
            "\t * alloc_resource() overcomplicates resource handling.",
            "\t */",
            "\tif (res && PageSlab(virt_to_head_page(res)))",
            "\t\tkfree(res);",
            "}",
            "static int __release_resource(struct resource *old, bool release_child)",
            "{",
            "\tstruct resource *tmp, **p, *chd;",
            "",
            "\tp = &old->parent->child;",
            "\tfor (;;) {",
            "\t\ttmp = *p;",
            "\t\tif (!tmp)",
            "\t\t\tbreak;",
            "\t\tif (tmp == old) {",
            "\t\t\tif (release_child || !(tmp->child)) {",
            "\t\t\t\t*p = tmp->sibling;",
            "\t\t\t} else {",
            "\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {",
            "\t\t\t\t\tchd->parent = tmp->parent;",
            "\t\t\t\t\tif (!(chd->sibling))",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\t*p = tmp->child;",
            "\t\t\t\tchd->sibling = tmp->sibling;",
            "\t\t\t}",
            "\t\t\told->parent = NULL;",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tp = &tmp->sibling;",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "static void __release_child_resources(struct resource *r)",
            "{",
            "\tstruct resource *tmp, *p;",
            "\tresource_size_t size;",
            "",
            "\tp = r->child;",
            "\tr->child = NULL;",
            "\twhile (p) {",
            "\t\ttmp = p;",
            "\t\tp = p->sibling;",
            "",
            "\t\ttmp->parent = NULL;",
            "\t\ttmp->sibling = NULL;",
            "\t\t__release_child_resources(tmp);",
            "",
            "\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);",
            "\t\t/* need to restore size, and keep flags */",
            "\t\tsize = resource_size(tmp);",
            "\t\ttmp->start = 0;",
            "\t\ttmp->end = size - 1;",
            "\t}",
            "}",
            "void release_child_resources(struct resource *r)",
            "{",
            "\twrite_lock(&resource_lock);",
            "\t__release_child_resources(r);",
            "\twrite_unlock(&resource_lock);",
            "}"
          ],
          "function_name": "r_stop, r_show, ioresources_init, free_resource, __release_resource, __release_child_resources, release_child_resources",
          "description": "实现资源遍历显示接口、资源释放逻辑及初始化函数，提供资源冲突检测、子资源释放、内存区域遍历等功能，支持进程命名空间下的资源访问控制。",
          "similarity": 0.5685932636260986
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/resource.c",
          "start_line": 637,
          "end_line": 763,
          "content": [
            "int region_intersects(resource_size_t start, size_t size, unsigned long flags,",
            "\t\t      unsigned long desc)",
            "{",
            "\tint ret;",
            "",
            "\tread_lock(&resource_lock);",
            "\tret = __region_intersects(&iomem_resource, start, size, flags, desc);",
            "\tread_unlock(&resource_lock);",
            "",
            "\treturn ret;",
            "}",
            "void __weak arch_remove_reservations(struct resource *avail)",
            "{",
            "}",
            "static resource_size_t simple_align_resource(void *data,",
            "\t\t\t\t\t     const struct resource *avail,",
            "\t\t\t\t\t     resource_size_t size,",
            "\t\t\t\t\t     resource_size_t align)",
            "{",
            "\treturn avail->start;",
            "}",
            "static void resource_clip(struct resource *res, resource_size_t min,",
            "\t\t\t  resource_size_t max)",
            "{",
            "\tif (res->start < min)",
            "\t\tres->start = min;",
            "\tif (res->end > max)",
            "\t\tres->end = max;",
            "}",
            "static int __find_resource(struct resource *root, struct resource *old,",
            "\t\t\t struct resource *new,",
            "\t\t\t resource_size_t  size,",
            "\t\t\t struct resource_constraint *constraint)",
            "{",
            "\tstruct resource *this = root->child;",
            "\tstruct resource tmp = *new, avail, alloc;",
            "",
            "\ttmp.start = root->start;",
            "\t/*",
            "\t * Skip past an allocated resource that starts at 0, since the assignment",
            "\t * of this->start - 1 to tmp->end below would cause an underflow.",
            "\t */",
            "\tif (this && this->start == root->start) {",
            "\t\ttmp.start = (this == old) ? old->start : this->end + 1;",
            "\t\tthis = this->sibling;",
            "\t}",
            "\tfor(;;) {",
            "\t\tif (this)",
            "\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;",
            "\t\telse",
            "\t\t\ttmp.end = root->end;",
            "",
            "\t\tif (tmp.end < tmp.start)",
            "\t\t\tgoto next;",
            "",
            "\t\tresource_clip(&tmp, constraint->min, constraint->max);",
            "\t\tarch_remove_reservations(&tmp);",
            "",
            "\t\t/* Check for overflow after ALIGN() */",
            "\t\tavail.start = ALIGN(tmp.start, constraint->align);",
            "\t\tavail.end = tmp.end;",
            "\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;",
            "\t\tif (avail.start >= tmp.start) {",
            "\t\t\talloc.flags = avail.flags;",
            "\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,",
            "\t\t\t\t\tsize, constraint->align);",
            "\t\t\talloc.end = alloc.start + size - 1;",
            "\t\t\tif (alloc.start <= alloc.end &&",
            "\t\t\t    resource_contains(&avail, &alloc)) {",
            "\t\t\t\tnew->start = alloc.start;",
            "\t\t\t\tnew->end = alloc.end;",
            "\t\t\t\treturn 0;",
            "\t\t\t}",
            "\t\t}",
            "",
            "next:\t\tif (!this || this->end == root->end)",
            "\t\t\tbreak;",
            "",
            "\t\tif (this != old)",
            "\t\t\ttmp.start = this->end + 1;",
            "\t\tthis = this->sibling;",
            "\t}",
            "\treturn -EBUSY;",
            "}",
            "static int find_resource(struct resource *root, struct resource *new,",
            "\t\t\tresource_size_t size,",
            "\t\t\tstruct resource_constraint  *constraint)",
            "{",
            "\treturn  __find_resource(root, NULL, new, size, constraint);",
            "}",
            "static int reallocate_resource(struct resource *root, struct resource *old,",
            "\t\t\t       resource_size_t newsize,",
            "\t\t\t       struct resource_constraint *constraint)",
            "{",
            "\tint err=0;",
            "\tstruct resource new = *old;",
            "\tstruct resource *conflict;",
            "",
            "\twrite_lock(&resource_lock);",
            "",
            "\tif ((err = __find_resource(root, old, &new, newsize, constraint)))",
            "\t\tgoto out;",
            "",
            "\tif (resource_contains(&new, old)) {",
            "\t\told->start = new.start;",
            "\t\told->end = new.end;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (old->child) {",
            "\t\terr = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (resource_contains(old, &new)) {",
            "\t\told->start = new.start;",
            "\t\told->end = new.end;",
            "\t} else {",
            "\t\t__release_resource(old, true);",
            "\t\t*old = new;",
            "\t\tconflict = __request_resource(root, old);",
            "\t\tBUG_ON(conflict);",
            "\t}",
            "out:",
            "\twrite_unlock(&resource_lock);",
            "\treturn err;",
            "}"
          ],
          "function_name": "region_intersects, arch_remove_reservations, simple_align_resource, resource_clip, __find_resource, find_resource, reallocate_resource",
          "description": "实现资源分配策略核心逻辑，包含资源位置查找、尺寸调整、冲突检测等关键功能，支持带约束条件的资源重新分配与位置确定。",
          "similarity": 0.5610312819480896
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/resource.c",
          "start_line": 1561,
          "end_line": 1661,
          "content": [
            "static void devm_resource_release(struct device *dev, void *ptr)",
            "{",
            "\tstruct resource **r = ptr;",
            "",
            "\trelease_resource(*r);",
            "}",
            "int devm_request_resource(struct device *dev, struct resource *root,",
            "\t\t\t  struct resource *new)",
            "{",
            "\tstruct resource *conflict, **ptr;",
            "",
            "\tptr = devres_alloc(devm_resource_release, sizeof(*ptr), GFP_KERNEL);",
            "\tif (!ptr)",
            "\t\treturn -ENOMEM;",
            "",
            "\t*ptr = new;",
            "",
            "\tconflict = request_resource_conflict(root, new);",
            "\tif (conflict) {",
            "\t\tdev_err(dev, \"resource collision: %pR conflicts with %s %pR\\n\",",
            "\t\t\tnew, conflict->name, conflict);",
            "\t\tdevres_free(ptr);",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\tdevres_add(dev, ptr);",
            "\treturn 0;",
            "}",
            "static int devm_resource_match(struct device *dev, void *res, void *data)",
            "{",
            "\tstruct resource **ptr = res;",
            "",
            "\treturn *ptr == data;",
            "}",
            "void devm_release_resource(struct device *dev, struct resource *new)",
            "{",
            "\tWARN_ON(devres_release(dev, devm_resource_release, devm_resource_match,",
            "\t\t\t       new));",
            "}",
            "static void devm_region_release(struct device *dev, void *res)",
            "{",
            "\tstruct region_devres *this = res;",
            "",
            "\t__release_region(this->parent, this->start, this->n);",
            "}",
            "static int devm_region_match(struct device *dev, void *res, void *match_data)",
            "{",
            "\tstruct region_devres *this = res, *match = match_data;",
            "",
            "\treturn this->parent == match->parent &&",
            "\t\tthis->start == match->start && this->n == match->n;",
            "}",
            "void __devm_release_region(struct device *dev, struct resource *parent,",
            "\t\t\t   resource_size_t start, resource_size_t n)",
            "{",
            "\tstruct region_devres match_data = { parent, start, n };",
            "",
            "\t__release_region(parent, start, n);",
            "\tWARN_ON(devres_destroy(dev, devm_region_release, devm_region_match,",
            "\t\t\t       &match_data));",
            "}",
            "static int __init reserve_setup(char *str)",
            "{",
            "\tstatic int reserved;",
            "\tstatic struct resource reserve[MAXRESERVE];",
            "",
            "\tfor (;;) {",
            "\t\tunsigned int io_start, io_num;",
            "\t\tint x = reserved;",
            "\t\tstruct resource *parent;",
            "",
            "\t\tif (get_option(&str, &io_start) != 2)",
            "\t\t\tbreak;",
            "\t\tif (get_option(&str, &io_num) == 0)",
            "\t\t\tbreak;",
            "\t\tif (x < MAXRESERVE) {",
            "\t\t\tstruct resource *res = reserve + x;",
            "",
            "\t\t\t/*",
            "\t\t\t * If the region starts below 0x10000, we assume it's",
            "\t\t\t * I/O port space; otherwise assume it's memory.",
            "\t\t\t */",
            "\t\t\tif (io_start < 0x10000) {",
            "\t\t\t\tres->flags = IORESOURCE_IO;",
            "\t\t\t\tparent = &ioport_resource;",
            "\t\t\t} else {",
            "\t\t\t\tres->flags = IORESOURCE_MEM;",
            "\t\t\t\tparent = &iomem_resource;",
            "\t\t\t}",
            "\t\t\tres->name = \"reserved\";",
            "\t\t\tres->start = io_start;",
            "\t\t\tres->end = io_start + io_num - 1;",
            "\t\t\tres->flags |= IORESOURCE_BUSY;",
            "\t\t\tres->desc = IORES_DESC_NONE;",
            "\t\t\tres->child = NULL;",
            "\t\t\tif (request_resource(parent, res) == 0)",
            "\t\t\t\treserved = x+1;",
            "\t\t}",
            "\t}",
            "\treturn 1;",
            "}"
          ],
          "function_name": "devm_resource_release, devm_request_resource, devm_resource_match, devm_release_resource, devm_region_release, devm_region_match, __devm_release_region, reserve_setup",
          "description": "实现设备资源管理器（devm）的资源申请/释放机制，包含预留资源初始化及设备资源生命周期绑定功能。",
          "similarity": 0.5584192276000977
        }
      ]
    },
    {
      "source_file": "kernel/sched/features.h",
      "md_summary": "> 自动生成时间: 2025-10-25 16:09:45\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\features.h`\n\n---\n\n# `sched/features.h` 技术文档\n\n## 1. 文件概述\n\n`sched/features.h` 是 Linux 内核调度器（CFS 和 EEVDF 调度类）中用于定义和管理**调度特性（Scheduling Features）** 的头文件。该文件通过宏 `SCHED_FEAT(name, enabled)` 声明一系列可配置的调度行为开关，用于控制调度器在运行时的各种策略，如任务放置、抢占、迁移、缓存局部性优化、延迟处理、利用率估计等。这些特性通常在编译时默认启用或禁用，但部分可通过 `/sys/kernel/debug/sched_features` 在运行时动态调整。\n\n## 2. 核心功能\n\n本文件不包含函数或数据结构定义，而是通过一系列 `SCHED_FEAT(feature_name, default_value)` 宏声明调度器的**可配置特性标志**。每个特性对应一个布尔开关，控制调度器某一方面的行为逻辑。主要特性包括：\n\n- **任务放置策略**：`PLACE_LAG`、`PLACE_DEADLINE_INITIAL`、`PLACE_REL_DEADLINE`\n- **抢占控制**：`RUN_TO_PARITY`、`PREEMPT_SHORT`、`WAKEUP_PREEMPTION`\n- **缓存局部性优化**：`NEXT_BUDDY`、`CACHE_HOT_BUDDY`\n- **延迟出队机制**：`DELAY_DEQUEUE`、`DELAY_ZERO`\n- **高精度定时器支持**：`HRTICK`、`HRTICK_DL`\n- **CPU 容量与负载管理**：`NONTASK_CAPACITY`、`ATTACH_AGE_LOAD`\n- **唤醒优化**：`TTWU_QUEUE`、`SIS_UTIL`\n- **实时任务调度优化**：`RT_PUSH_IPI`、`RT_RUNTIME_SHARE`\n- **利用率估计**：`UTIL_EST`、`UTIL_EST_FASTUP`\n- **调试与告警**：`WARN_DOUBLE_CLOCK`、`LATENCY_WARN`\n\n## 3. 关键实现\n\n- **`SCHED_FEAT` 宏机制**：  \n  该宏在 `kernel/sched/features.h` 中定义（通常通过 `#define SCHED_FEAT(x, enabled) SCHED_FEAT_##x`），最终在 `kernel/sched/core.c` 中展开为位图（`sysctl_sched_features`）中的位标志。调度器代码通过 `sched_feat(FEAT_NAME)` 宏查询某特性是否启用。\n\n- **EEVDF 相关特性**：\n  - `PLACE_LAG`：启用后，任务在睡眠/唤醒周期中保留其虚拟运行时间（avg_vruntime）的“滞后”（lag），确保公平性。这是 EEVDF（Earliest Eligible Virtual Deadline First）调度器的核心策略之一。\n  - `PLACE_DEADLINE_INITIAL`：新任务初始虚拟截止时间设为当前时间加半个时间片，避免新任务因虚拟截止时间过早而过度抢占。\n  - `PLACE_REL_DEADLINE`：任务迁移时保持其相对于当前虚拟时间的截止时间偏移，维持调度公平性。\n\n- **抢占抑制与唤醒抢占**：\n  - `RUN_TO_PARITY`：禁止唤醒抢占，直到当前任务达到“零滞后点”（即其虚拟运行时间追平队列平均值）或耗尽时间片。\n  - `PREEMPT_SHORT`：允许具有更短时间片的唤醒任务抢占当前任务，即使 `RESPECT_SLICE` 被设置。\n  - `WAKEUP_PREEMPTION`：启用唤醒时的抢占检查，是 CFS/EEVDF 实现低延迟响应的关键。\n\n- **缓存局部性优化**：\n  - `NEXT_BUDDY`（默认关闭）：优先调度最近被唤醒但未成功抢占的任务，因其可能复用刚访问的数据。\n  - `CACHE_HOT_BUDDY`：将 buddy 任务视为缓存热任务，降低其被迁移的概率。\n\n- **延迟出队（`DELAY_DEQUEUE`）**：  \n  非就绪任务（如睡眠中）不会立即从运行队列移除，使其保留在调度竞争中以“消耗”负滞后（negative lag），当选中时自然具有正滞后，提升调度平滑性。`DELAY_ZERO` 则在出队或唤醒时将滞后裁剪为 0。\n\n- **TTWU_QUEUE 优化**：  \n  在非 `PREEMPT_RT` 配置下，默认启用远程唤醒排队机制，通过调度 IPI 异步处理跨 CPU 唤醒，减少运行队列锁竞争。\n\n- **利用率估计（Utilization Estimation）**：  \n  `UTIL_EST` 启用基于 PELT（Per-Entity Load Tracking）信号的 CPU 利用率估计，`UTIL_EST_FASTUP` 允许利用率快速上升以响应突发负载，用于 EAS（Energy Aware Scheduling）等场景。\n\n- **RT 调度优化**：  \n  `RT_PUSH_IPI` 在支持 `HAVE_RT_PUSH_IPI` 的平台上启用，通过 IPI 推送高优先级 RT 任务，避免多 CPU 同时争抢单个运行队列锁导致的“惊群”问题。\n\n## 4. 依赖关系\n\n- **依赖头文件**：通常由 `kernel/sched/sched.h` 或 `kernel/sched/core.c` 包含。\n- **依赖配置选项**：\n  - `CONFIG_PREEMPT_RT`：影响 `TTWU_QUEUE` 默认值。\n  - `HAVE_RT_PUSH_IPI`：决定 `RT_PUSH_IPI` 特性是否定义。\n- **依赖调度核心模块**：特性标志在 `kernel/sched/core.c`、`kernel/sched/fair.c`（CFS/EEVDF）、`kernel/sched/rt.c`（实时调度）中被实际使用。\n- **依赖调试接口**：部分特性（如 `WARN_DOUBLE_CLOCK`、`LATENCY_WARN`）依赖内核调试基础设施。\n\n## 5. 使用场景\n\n- **调度策略调优**：系统管理员或开发者可通过 `/sys/kernel/debug/sched_features` 动态开启/关闭特性，以优化特定工作负载（如低延迟、高吞吐、能效）下的调度行为。\n- **EEVDF 调度器支持**：`PLACE_LAG`、`PLACE_DEADLINE_INITIAL` 等特性是 Linux 6.6+ 引入的 EEVDF 调度器实现公平性和响应性的关键。\n- **实时系统优化**：`RT_PUSH_IPI`、`RT_RUNTIME_SHARE` 等用于改善实时任务的调度延迟和 CPU 资源分配。\n- **能效调度（EAS）**：`UTIL_EST` 和 `UTIL_EST_FASTUP` 为 EAS 提供准确的 CPU 利用率预测，用于任务放置决策。\n- **性能调试**：`LATENCY_WARN`、`WARN_DOUBLE_CLOCK` 等特性用于检测调度器内部异常或性能瓶颈。\n- **多核扩展性优化**：`TTWU_QUEUE`、`SIS_UTIL` 减少跨 CPU 唤醒和 LLC 域扫描开销，提升大规模系统可扩展性。",
      "similarity": 0.5581665635108948,
      "chunks": []
    }
  ]
}