{
  "query": "系统时间管理实现原理与中断协作机制",
  "timestamp": "2025-12-26 02:18:22",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/timings.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:10:35\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\timings.c`\n\n---\n\n# irq/timings.c 技术文档\n\n## 1. 文件概述\n\n`irq/timings.c` 是 Linux 内核中用于中断时间预测的核心模块。该文件实现了基于历史中断时间戳的预测算法，旨在通过分析中断发生的周期性模式，预测下一次中断可能发生的时间。此功能主要用于低功耗场景（如 CPU 空闲状态管理），帮助调度器或电源管理子系统更精确地设置唤醒时间，从而在保证响应性的同时减少不必要的唤醒开销。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct irq_timings`：每个 CPU 私有的中断时间记录结构，包含一个循环缓冲区，用于存储 `<中断号, 时间戳>` 元组。\n- `irqt_stats`：全局 IDR（整数到指针映射）结构，用于按中断号索引中断统计信息。\n- `irq_timing_enabled`：静态分支键（`static_key`），用于在运行时动态启用/禁用中断时间跟踪功能，避免性能开销。\n\n### 主要函数\n\n- `irq_timings_enable(void)`：启用中断时间跟踪功能，激活静态分支。\n- `irq_timings_disable(void)`：禁用中断时间跟踪功能，关闭静态分支。\n- （注：实际的预测算法逻辑虽未在代码片段中完整展示，但文档详细描述了其实现原理）\n\n## 3. 关键实现\n\n### 中断时间预测算法\n\n该模块采用三阶段算法预测中断周期：\n\n#### 1) 后缀数组（Suffix Array）模式识别\n- 将中断间隔（经 `ilog2` 映射后的索引值）序列视为字符串。\n- 构建长度为 2 到 5 的后缀（受限于实际设备周期经验）。\n- 在最近 `3 × max_period`（即 15）个索引中搜索后缀的重复出现。\n- 若某后缀连续出现 3 次，则认为发现有效周期模式，其长度即为预测周期。\n\n#### 2) 对数间隔桶（Log Interval Bucketing）\n- 使用 `ilog2(interval)` 将原始时间间隔映射到 0~63 的桶索引（因 `u64` 最大为 2^64）。\n- 该方法将大范围的时间值压缩到小数组中，例如值 1123 映射到索引 10（因 2^10 = 1024 ≤ 1123 < 2048 = 2^11）。\n\n#### 3) 指数移动平均（Exponential Moving Average, EMA）\n- 每个桶维护一个 EMA 值，用于平滑同一数量级间隔的波动。\n- EMA 公式使平均值对新数据具有可调的响应速度（通过 alpha 参数隐式控制）。\n- 预测时，根据识别出的周期模式中的桶索引，返回对应桶的 EMA 值作为预测间隔。\n\n### 工作流程\n1. 中断发生时，若 `irq_timing_enabled` 为真，则将 `<irq, timestamp>` 记录到 per-CPU 的循环缓冲区。\n2. 当需要预测某中断的下次发生时间时：\n   - 清空并处理循环缓冲区，将间隔数据分发到各中断的统计结构中。\n   - 对每个中断的间隔序列执行上述三阶段算法。\n   - 若找到重复模式，则用 EMA 值计算预测时间；否则返回未预测。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/percpu.h>`：实现 per-CPU 变量 `irq_timings`。\n  - `<linux/static_key.h>`：提供静态分支优化，避免未启用时的条件判断开销。\n  - `<linux/math64.h>` 和 `<linux/log2.h>`：用于 `ilog2` 等数学运算。\n  - `<trace/events/irq.h>`：可能用于跟踪事件（虽未在片段中调用）。\n  - `\"internals.h\"`：内核中断子系统内部头文件。\n- **子系统依赖**：\n  - 通用中断子系统（`<linux/irq.h>`, `<linux/interrupt.h>`）。\n  - 内存管理（`<linux/slab.h>`）用于动态分配统计结构。\n  - IDR 机制（`<linux/idr.h>`）用于中断号到统计结构的映射。\n\n## 5. 使用场景\n\n- **CPU 空闲状态管理（cpuidle）**：在进入深度 C-state 前，预测下一次中断时间以设置精确的唤醒定时器，避免过早或过晚唤醒。\n- **实时系统调度**：辅助调度器预判周期性中断（如 tickless 系统中的高精度定时器），优化任务调度时机。\n- **电源管理**：结合设备驱动的中断模式，动态调整设备或 CPU 的电源状态。\n- **性能分析**：通过跟踪中断时间模式，诊断中断风暴或异常周期行为。\n\n该功能默认关闭，仅在需要时通过 `irq_timings_enable()` 动态启用，确保对常规系统性能无影响。",
      "similarity": 0.6446599364280701,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/timings.c",
          "start_line": 26,
          "end_line": 165,
          "content": [
            "void irq_timings_enable(void)",
            "{",
            "\tstatic_branch_enable(&irq_timing_enabled);",
            "}",
            "void irq_timings_disable(void)",
            "{",
            "\tstatic_branch_disable(&irq_timing_enabled);",
            "}",
            "static u64 irq_timings_ema_new(u64 value, u64 ema_old)",
            "{",
            "\ts64 diff;",
            "",
            "\tif (unlikely(!ema_old))",
            "\t\treturn value;",
            "",
            "\tdiff = (value - ema_old) * EMA_ALPHA_VAL;",
            "\t/*",
            "\t * We can use a s64 type variable to be added with the u64",
            "\t * ema_old variable as this one will never have its topmost",
            "\t * bit set, it will be always smaller than 2^63 nanosec",
            "\t * interrupt interval (292 years).",
            "\t */",
            "\treturn ema_old + (diff >> EMA_ALPHA_SHIFT);",
            "}",
            "static int irq_timings_next_event_index(int *buffer, size_t len, int period_max)",
            "{",
            "\tint period;",
            "",
            "\t/*",
            "\t * Move the beginning pointer to the end minus the max period x 3.",
            "\t * We are at the point we can begin searching the pattern",
            "\t */",
            "\tbuffer = &buffer[len - (period_max * 3)];",
            "",
            "\t/* Adjust the length to the maximum allowed period x 3 */",
            "\tlen = period_max * 3;",
            "",
            "\t/*",
            "\t * The buffer contains the suite of intervals, in a ilog2",
            "\t * basis, we are looking for a repetition. We point the",
            "\t * beginning of the search three times the length of the",
            "\t * period beginning at the end of the buffer. We do that for",
            "\t * each suffix.",
            "\t */",
            "\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {",
            "",
            "\t\t/*",
            "\t\t * The first comparison always succeed because the",
            "\t\t * suffix is deduced from the first n-period bytes of",
            "\t\t * the buffer and we compare the initial suffix with",
            "\t\t * itself, so we can skip the first iteration.",
            "\t\t */",
            "\t\tint idx = period;",
            "\t\tsize_t size = period;",
            "",
            "\t\t/*",
            "\t\t * We look if the suite with period 'i' repeat",
            "\t\t * itself. If it is truncated at the end, as it",
            "\t\t * repeats we can use the period to find out the next",
            "\t\t * element with the modulo.",
            "\t\t */",
            "\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {",
            "",
            "\t\t\t/*",
            "\t\t\t * Move the index in a period basis",
            "\t\t\t */",
            "\t\t\tidx += size;",
            "",
            "\t\t\t/*",
            "\t\t\t * If this condition is reached, all previous",
            "\t\t\t * memcmp were successful, so the period is",
            "\t\t\t * found.",
            "\t\t\t */",
            "\t\t\tif (idx == len)",
            "\t\t\t\treturn buffer[len % period];",
            "",
            "\t\t\t/*",
            "\t\t\t * If the remaining elements to compare are",
            "\t\t\t * smaller than the period, readjust the size",
            "\t\t\t * of the comparison for the last iteration.",
            "\t\t\t */",
            "\t\t\tif (len - idx < period)",
            "\t\t\t\tsize = len - idx;",
            "\t\t}",
            "\t}",
            "",
            "\treturn -1;",
            "}",
            "static u64 __irq_timings_next_event(struct irqt_stat *irqs, int irq, u64 now)",
            "{",
            "\tint index, i, period_max, count, start, min = INT_MAX;",
            "",
            "\tif ((now - irqs->last_ts) >= NSEC_PER_SEC) {",
            "\t\tirqs->count = irqs->last_ts = 0;",
            "\t\treturn U64_MAX;",
            "\t}",
            "",
            "\t/*",
            "\t * As we want to find three times the repetition, we need a",
            "\t * number of intervals greater or equal to three times the",
            "\t * maximum period, otherwise we truncate the max period.",
            "\t */",
            "\tperiod_max = irqs->count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : irqs->count / 3;",
            "",
            "\t/*",
            "\t * If we don't have enough irq timings for this prediction,",
            "\t * just bail out.",
            "\t */",
            "\tif (period_max <= PREDICTION_PERIOD_MIN)",
            "\t\treturn U64_MAX;",
            "",
            "\t/*",
            "\t * 'count' will depends if the circular buffer wrapped or not",
            "\t */",
            "\tcount = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\tirqs->count : IRQ_TIMINGS_SIZE;",
            "",
            "\tstart = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\t0 : (irqs->count & IRQ_TIMINGS_MASK);",
            "",
            "\t/*",
            "\t * Copy the content of the circular buffer into another buffer",
            "\t * in order to linearize the buffer instead of dealing with",
            "\t * wrapping indexes and shifted array which will be prone to",
            "\t * error and extremely difficult to debug.",
            "\t */",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "",
            "\t\tirqs->timings[i] = irqs->circ_timings[index];",
            "\t\tmin = min_t(int, irqs->timings[i], min);",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(irqs->timings, count, period_max);",
            "\tif (index < 0)",
            "\t\treturn irqs->last_ts + irqs->ema_time[min];",
            "",
            "\treturn irqs->last_ts + irqs->ema_time[index];",
            "}"
          ],
          "function_name": "irq_timings_enable, irq_timings_disable, irq_timings_ema_new, irq_timings_next_event_index, __irq_timings_next_event",
          "description": "实现中断计时功能的启用/禁用控制，EMA计算算法及基于模式匹配的周期预测核心逻辑",
          "similarity": 0.6800466775894165
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/timings.c",
          "start_line": 1,
          "end_line": 25,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright (C) 2016, Linaro Ltd - Daniel Lezcano <daniel.lezcano@linaro.org>",
            "#define pr_fmt(fmt) \"irq_timings: \" fmt",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/static_key.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/idr.h>",
            "#include <linux/irq.h>",
            "#include <linux/math64.h>",
            "#include <linux/log2.h>",
            "",
            "#include <trace/events/irq.h>",
            "",
            "#include \"internals.h\"",
            "",
            "DEFINE_STATIC_KEY_FALSE(irq_timing_enabled);",
            "",
            "DEFINE_PER_CPU(struct irq_timings, irq_timings);",
            "",
            "static DEFINE_IDR(irqt_stats);",
            ""
          ],
          "function_name": null,
          "description": "定义中断计时模块的静态键开关和PER-CPU结构体，声明IDR管理器用于动态分配中断统计实例",
          "similarity": 0.6298339366912842
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/timings.c",
          "start_line": 594,
          "end_line": 739,
          "content": [
            "void irq_timings_free(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s) {",
            "\t\tfree_percpu(s);",
            "\t\tidr_remove(&irqt_stats, irq);",
            "\t}",
            "}",
            "int irq_timings_alloc(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tint id;",
            "",
            "\t/*",
            "\t * Some platforms can have the same private interrupt per cpu,",
            "\t * so this function may be called several times with the",
            "\t * same interrupt number. Just bail out in case the per cpu",
            "\t * stat structure is already allocated.",
            "\t */",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s)",
            "\t\treturn 0;",
            "",
            "\ts = alloc_percpu(*s);",
            "\tif (!s)",
            "\t\treturn -ENOMEM;",
            "",
            "\tidr_preload(GFP_KERNEL);",
            "\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);",
            "\tidr_preload_end();",
            "",
            "\tif (id < 0) {",
            "\t\tfree_percpu(s);",
            "\t\treturn id;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_test_next_index(struct timings_intervals *ti)",
            "{",
            "\tint _buffer[IRQ_TIMINGS_SIZE];",
            "\tint buffer[IRQ_TIMINGS_SIZE];",
            "\tint index, start, i, count, period_max;",
            "",
            "\tcount = ti->count - 1;",
            "",
            "\tperiod_max = count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : count / 3;",
            "",
            "\t/*",
            "\t * Inject all values except the last one which will be used",
            "\t * to compare with the next index result.",
            "\t */",
            "\tpr_debug(\"index suite: \");",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\t_buffer[i & IRQ_TIMINGS_MASK] = index;",
            "\t\tpr_cont(\"%d \", index);",
            "\t}",
            "",
            "\tstart = count < IRQ_TIMINGS_SIZE ? 0 :",
            "\t\tcount & IRQ_TIMINGS_MASK;",
            "",
            "\tcount = min_t(int, count, IRQ_TIMINGS_SIZE);",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "\t\tbuffer[i] = _buffer[index];",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(buffer, count, period_max);",
            "\ti = irq_timings_interval_index(ti->intervals[ti->count - 1]);",
            "",
            "\tif (index != i) {",
            "\t\tpr_err(\"Expected (%d) and computed (%d) next indexes differ\\n\",",
            "\t\t       i, index);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_next_index_selftest(void)",
            "{",
            "\tint i, ret;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {",
            "",
            "\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",",
            "\t\t\ti, tis[i].count);",
            "",
            "\t\tret = irq_timings_test_next_index(&tis[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __init irq_timings_test_irqs(struct timings_intervals *ti)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tstruct irqt_stat *irqs;",
            "\tint i, index, ret, irq = 0xACE5;",
            "",
            "\tret = irq_timings_alloc(irq);",
            "\tif (ret) {",
            "\t\tpr_err(\"Failed to allocate irq timings\\n\");",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (!s) {",
            "\t\tret = -EIDRM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tirqs = this_cpu_ptr(s);",
            "",
            "\tfor (i = 0; i < ti->count; i++) {",
            "",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\tpr_debug(\"%d: interval=%llu ema_index=%d\\n\",",
            "\t\t\t i, ti->intervals[i], index);",
            "",
            "\t\t__irq_timings_store(irq, irqs, ti->intervals[i]);",
            "\t\tif (irqs->circ_timings[i & IRQ_TIMINGS_MASK] != index) {",
            "\t\t\tret = -EBADSLT;",
            "\t\t\tpr_err(\"Failed to store in the circular buffer\\n\");",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tif (irqs->count != ti->count) {",
            "\t\tret = -ERANGE;",
            "\t\tpr_err(\"Count differs\\n\");",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = 0;",
            "out:",
            "\tirq_timings_free(irq);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_free, irq_timings_alloc, irq_timings_test_next_index, irq_timings_next_index_selftest, irq_timings_test_irqs",
          "description": "实现中断统计结构的动态分配/释放机制，包含预测算法的自检测试函数",
          "similarity": 0.5885661840438843
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/irq/timings.c",
          "start_line": 927,
          "end_line": 956,
          "content": [
            "static int __init irq_timings_selftest(void)",
            "{",
            "\tint ret;",
            "",
            "\tpr_info(\"------------------- selftest start -----------------\\n\");",
            "",
            "\t/*",
            "\t * At this point, we don't except any subsystem to use the irq",
            "\t * timings but us, so it should not be enabled.",
            "\t */",
            "\tif (static_branch_unlikely(&irq_timing_enabled)) {",
            "\t\tpr_warn(\"irq timings already initialized, skipping selftest\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = irq_timings_irqts_selftest();",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tret = irq_timings_irqs_selftest();",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tret = irq_timings_next_index_selftest();",
            "out:",
            "\tpr_info(\"---------- selftest end with %s -----------\\n\",",
            "\t\tret ? \"failure\" : \"success\");",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_selftest",
          "description": "该代码段实现了中断定时功能的自我检测逻辑，用于验证中断时间戳、中断序列及索引管理等子系统的正确性。作为初始化函数，它通过调用三个子测试函数依次检查相关功能模块的行为是否符合预期。由于代码中引用了未展示的测试函数（如irq_timings_irqts_selftest），需结合上下文才能完整理解其工作机制。",
          "similarity": 0.5644958019256592
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/timings.c",
          "start_line": 821,
          "end_line": 923,
          "content": [
            "static int __init irq_timings_irqs_selftest(void)",
            "{",
            "\tint i, ret;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {",
            "\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",",
            "\t\t\ti, tis[i].count);",
            "\t\tret = irq_timings_test_irqs(&tis[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __init irq_timings_test_irqts(struct irq_timings *irqts,",
            "\t\t\t\t\t unsigned count)",
            "{",
            "\tint start = count >= IRQ_TIMINGS_SIZE ? count - IRQ_TIMINGS_SIZE : 0;",
            "\tint i, irq, oirq = 0xBEEF;",
            "\tu64 ots = 0xDEAD, ts;",
            "",
            "\t/*",
            "\t * Fill the circular buffer by using the dedicated function.",
            "\t */",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tpr_debug(\"%d: index=%d, ts=%llX irq=%X\\n\",",
            "\t\t\t i, i & IRQ_TIMINGS_MASK, ots + i, oirq + i);",
            "",
            "\t\tirq_timings_push(ots + i, oirq + i);",
            "\t}",
            "",
            "\t/*",
            "\t * Compute the first elements values after the index wrapped",
            "\t * up or not.",
            "\t */",
            "\tots += start;",
            "\toirq += start;",
            "",
            "\t/*",
            "\t * Test the circular buffer count is correct.",
            "\t */",
            "\tpr_debug(\"---> Checking timings array count (%d) is right\\n\", count);",
            "\tif (WARN_ON(irqts->count != count))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Test the macro allowing to browse all the irqts.",
            "\t */",
            "\tpr_debug(\"---> Checking the for_each_irqts() macro\\n\");",
            "\tfor_each_irqts(i, irqts) {",
            "",
            "\t\tirq = irq_timing_decode(irqts->values[i], &ts);",
            "",
            "\t\tpr_debug(\"index=%d, ts=%llX / %llX, irq=%X / %X\\n\",",
            "\t\t\t i, ts, ots, irq, oirq);",
            "",
            "\t\tif (WARN_ON(ts != ots || irq != oirq))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tots++; oirq++;",
            "\t}",
            "",
            "\t/*",
            "\t * The circular buffer should have be flushed when browsed",
            "\t * with for_each_irqts",
            "\t */",
            "\tpr_debug(\"---> Checking timings array is empty after browsing it\\n\");",
            "\tif (WARN_ON(irqts->count))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_irqts_selftest(void)",
            "{",
            "\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);",
            "\tint i, ret;",
            "",
            "\t/*",
            "\t * Test the circular buffer with different number of",
            "\t * elements. The purpose is to test at the limits (empty, half",
            "\t * full, full, wrapped with the cursor at the boundaries,",
            "\t * wrapped several times, etc ...",
            "\t */",
            "\tint count[] = { 0,",
            "\t\t\tIRQ_TIMINGS_SIZE >> 1,",
            "\t\t\tIRQ_TIMINGS_SIZE,",
            "\t\t\tIRQ_TIMINGS_SIZE + (IRQ_TIMINGS_SIZE >> 1),",
            "\t\t\t2 * IRQ_TIMINGS_SIZE,",
            "\t\t\t(2 * IRQ_TIMINGS_SIZE) + 3,",
            "\t};",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(count); i++) {",
            "",
            "\t\tpr_info(\"---> Checking the timings with %d/%d values\\n\",",
            "\t\t\tcount[i], IRQ_TIMINGS_SIZE);",
            "",
            "\t\tret = irq_timings_test_irqts(irqts, count[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_irqs_selftest, irq_timings_test_irqts, irq_timings_irqts_selftest",
          "description": "包含完整的中断计时模块自检框架，验证环形缓冲区操作和for_each_irqts宏的正确性",
          "similarity": 0.5453647971153259
        }
      ]
    },
    {
      "source_file": "kernel/time/timekeeping.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:55:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\timekeeping.c`\n\n---\n\n# timekeeping.c 技术文档\n\n## 1. 文件概述\n\n`timekeeping.c` 是 Linux 内核中负责时间保持（timekeeping）的核心实现文件。它维护系统时间的连续性和准确性，提供高精度的时间读取接口，并处理与 NTP（网络时间协议）、时钟源（clocksource）、系统挂起/恢复等相关的时间同步逻辑。该文件实现了单调时钟（monotonic）、原始时钟（raw）、实时时钟（wall-clock）等多种时间视图，并确保在中断上下文、NMI（不可屏蔽中断）等特殊场景下也能安全读取时间。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct timekeeper`**  \n  核心时间保持结构体，包含当前时间、时钟偏移、TAI 偏移、启动时间偏移等关键字段。\n\n- **`struct tk_read_base`**  \n  用于快速时间读取的基础结构，包含时钟源指针、乘数（mult）、移位（shift）、掩码（mask）和上次周期值（cycle_last）等。\n\n- **`struct tk_fast`**  \n  专为 NMI 和中断上下文设计的快速时间读取结构，使用双缓冲（latch-based seqcount）机制实现无锁安全读取。\n\n- **`tk_core`**  \n  全局核心时间保持对象，包含一个 `seqcount_raw_spinlock_t` 序列锁和 `timekeeper` 实例，对齐到 64 字节缓存行以优化性能。\n\n- **`shadow_timekeeper`**  \n  时间保持器的影子副本，用于在更新过程中暂存新值，避免直接修改主结构导致不一致。\n\n- **`dummy_clock`**  \n  早期启动阶段使用的虚拟时钟源，基于 `local_clock()`，在真实时钟源注册前提供基本时间服务。\n\n### 主要函数与宏\n\n- **`tk_normalize_xtime()`**  \n  将纳秒部分规范化，确保 `xtime_nsec` 不超过每秒纳秒数的表示范围。\n\n- **`tk_xtime()` / `tk_set_xtime()` / `tk_xtime_add()`**  \n  用于获取、设置和累加系统实时时钟（wall time）。\n\n- **`tk_set_wall_to_mono()`**  \n  设置 wall-to-monotonic 偏移，并同步更新 `offs_real` 和 `offs_tai`。\n\n- **`tk_update_sleep_time()`**  \n  在系统从挂起状态恢复时，更新启动时间偏移（`offs_boot`）。\n\n- **`tk_clock_read()`**  \n  安全读取当前时钟源的周期值，防止在时钟源切换过程中发生崩溃。\n\n- **`timekeeping_check_update()`（仅调试模式）**  \n  检查时钟周期偏移是否超出安全范围，防止溢出或下溢。\n\n- **`update_fast_timekeeper()`（未完整显示但被引用）**  \n  更新 `tk_fast_mono` 和 `tk_fast_raw`，用于 NMI 安全的时间读取。\n\n### 全局变量\n\n- `timekeeper_lock`：保护 `tk_core` 的原始自旋锁。\n- `timekeeping_suspended`：标志系统时间保持是否处于挂起状态。\n- `cycles_at_suspend`：系统挂起时记录的时钟周期值。\n- `tk_fast_mono` / `tk_fast_raw`：分别用于单调时间和原始时间的快速读取路径。\n\n## 3. 关键实现\n\n### 时间读取的无锁安全机制\n\n为支持在 NMI、中断等不可睡眠上下文中安全读取时间，内核引入了 `tk_fast` 结构。它使用 `seqcount_latch_t`（一种双缓冲序列计数器），通过切换两个 `tk_read_base` 实例（索引由序列计数器最低位决定）来实现更新与读取的分离。读取时只需读取当前有效的副本，无需加锁。\n\n### 时间规范化与溢出处理\n\n`tk_normalize_xtime()` 确保纳秒字段不会超过 `NSEC_PER_SEC << shift`，避免在时间计算中出现逻辑错误。同时，`CONFIG_DEBUG_TIMEKEEPING` 启用时会检查周期偏移是否超过时钟源的 `max_cycles`，防止因时钟源回绕或频率异常导致时间跳变。\n\n### 早期启动支持\n\n在系统早期启动阶段，真实时钟源尚未注册，此时使用 `dummy_clock` 作为占位时钟源。其 `read` 函数返回 `local_clock()`（通常基于 TSC 或 jiffies），并设置 `mult=1, shift=0`，因为 `local_clock()` 直接返回纳秒值，无需转换。\n\n### 挂起/恢复处理\n\n当系统挂起时，`timekeeping_suspend()` 会记录当前时钟周期值到 `cycles_at_suspend`，并将 `dummy_clock` 的 `read` 函数改为返回该固定值，防止挂起期间时间继续推进。恢复时再切换回真实时钟源并补偿睡眠时间。\n\n### 序列锁保护\n\n主时间保持结构 `tk_core` 使用 `seqcount_raw_spinlock_t` 保护。写操作需持有 `timekeeper_lock`，读操作通过 `read_seqcount_begin()` / `read_seqcount_retry()` 实现无锁但一致的读取，适用于大多数用户空间时间查询路径（如 VDSO）。\n\n## 4. 依赖关系\n\n- **`<linux/clocksource.h>`**：依赖时钟源抽象，用于获取高精度硬件计时器。\n- **`<linux/tick.h>` / `tick-internal.h`**：与 tick 管理子系统交互，处理周期性时间更新。\n- **`ntp_internal.h`**：集成 NTP 频率调整和闰秒处理逻辑。\n- **`timekeeping_internal.h`**：包含内部辅助函数和结构定义。\n- **`<linux/vdso.h>` / `pvclock_gtod.h`**：为 VDSO 和虚拟化环境（如 Xen、KVM）提供高效时间读取支持。\n- **`<linux/sched/clock.h>`**：使用 `local_clock()` 作为早期启动和虚拟时钟源。\n- **`<linux/stop_machine.h>`**：在某些关键更新路径中可能使用 stop-machine 机制确保全局一致性。\n\n## 5. 使用场景\n\n- **系统调用时间查询**：如 `clock_gettime(CLOCK_REALTIME)`、`CLOCK_MONOTONIC` 等通过此模块获取高精度时间。\n- **VDSO 加速**：用户空间通过 VDSO 直接读取 `tk_fast` 结构，避免陷入内核。\n- **NMI 和中断处理**：在不可睡眠上下文中安全获取时间戳（如 perf、ftrace、oops 打印）。\n- **系统挂起/恢复**：在 suspend/resume 流程中冻结和恢复时间推进。\n- **NTP 时间同步**：接收用户空间 `adjtimex` 调用，调整时钟频率和偏移。\n- **内核日志时间戳**：`printk` 等日志系统依赖此模块提供单调或实时时钟。\n- **调度器和负载计算**：`update_wall_time()` 被 tick 中断定期调用，驱动时间推进，影响调度、负载均衡等子系统。",
      "similarity": 0.6319857835769653,
      "chunks": [
        {
          "chunk_id": 11,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 1840,
          "end_line": 1985,
          "content": [
            "int timekeeping_suspend(void)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tunsigned long flags;",
            "\tstruct timespec64\t\tdelta, delta_delta;",
            "\tstatic struct timespec64\told_delta;",
            "\tstruct clocksource *curr_clock;",
            "\tu64 cycle_now;",
            "",
            "\tread_persistent_clock64(&timekeeping_suspend_time);",
            "",
            "\t/*",
            "\t * On some systems the persistent_clock can not be detected at",
            "\t * timekeeping_init by its return value, so if we see a valid",
            "\t * value returned, update the persistent_clock_exists flag.",
            "\t */",
            "\tif (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)",
            "\t\tpersistent_clock_exists = true;",
            "",
            "\tsuspend_timing_needed = true;",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "\ttimekeeping_forward_now(tk);",
            "\ttimekeeping_suspended = 1;",
            "",
            "\t/*",
            "\t * Since we've called forward_now, cycle_last stores the value",
            "\t * just read from the current clocksource. Save this to potentially",
            "\t * use in suspend timing.",
            "\t */",
            "\tcurr_clock = tk->tkr_mono.clock;",
            "\tcycle_now = tk->tkr_mono.cycle_last;",
            "\tclocksource_start_suspend_timing(curr_clock, cycle_now);",
            "",
            "\tif (persistent_clock_exists) {",
            "\t\t/*",
            "\t\t * To avoid drift caused by repeated suspend/resumes,",
            "\t\t * which each can add ~1 second drift error,",
            "\t\t * try to compensate so the difference in system time",
            "\t\t * and persistent_clock time stays close to constant.",
            "\t\t */",
            "\t\tdelta = timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);",
            "\t\tdelta_delta = timespec64_sub(delta, old_delta);",
            "\t\tif (abs(delta_delta.tv_sec) >= 2) {",
            "\t\t\t/*",
            "\t\t\t * if delta_delta is too large, assume time correction",
            "\t\t\t * has occurred and set old_delta to the current delta.",
            "\t\t\t */",
            "\t\t\told_delta = delta;",
            "\t\t} else {",
            "\t\t\t/* Otherwise try to adjust old_system to compensate */",
            "\t\t\ttimekeeping_suspend_time =",
            "\t\t\t\ttimespec64_add(timekeeping_suspend_time, delta_delta);",
            "\t\t}",
            "\t}",
            "",
            "\ttimekeeping_update(tk, TK_MIRROR);",
            "\thalt_fast_timekeeper(tk);",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\ttick_suspend();",
            "\tclocksource_suspend();",
            "\tclockevents_suspend();",
            "",
            "\treturn 0;",
            "}",
            "static int __init timekeeping_init_ops(void)",
            "{",
            "\tregister_syscore_ops(&timekeeping_syscore_ops);",
            "\treturn 0;",
            "}",
            "static __always_inline void timekeeping_apply_adjustment(struct timekeeper *tk,",
            "\t\t\t\t\t\t\t s64 offset,",
            "\t\t\t\t\t\t\t s32 mult_adj)",
            "{",
            "\ts64 interval = tk->cycle_interval;",
            "",
            "\tif (mult_adj == 0) {",
            "\t\treturn;",
            "\t} else if (mult_adj == -1) {",
            "\t\tinterval = -interval;",
            "\t\toffset = -offset;",
            "\t} else if (mult_adj != 1) {",
            "\t\tinterval *= mult_adj;",
            "\t\toffset *= mult_adj;",
            "\t}",
            "",
            "\t/*",
            "\t * So the following can be confusing.",
            "\t *",
            "\t * To keep things simple, lets assume mult_adj == 1 for now.",
            "\t *",
            "\t * When mult_adj != 1, remember that the interval and offset values",
            "\t * have been appropriately scaled so the math is the same.",
            "\t *",
            "\t * The basic idea here is that we're increasing the multiplier",
            "\t * by one, this causes the xtime_interval to be incremented by",
            "\t * one cycle_interval. This is because:",
            "\t *\txtime_interval = cycle_interval * mult",
            "\t * So if mult is being incremented by one:",
            "\t *\txtime_interval = cycle_interval * (mult + 1)",
            "\t * Its the same as:",
            "\t *\txtime_interval = (cycle_interval * mult) + cycle_interval",
            "\t * Which can be shortened to:",
            "\t *\txtime_interval += cycle_interval",
            "\t *",
            "\t * So offset stores the non-accumulated cycles. Thus the current",
            "\t * time (in shifted nanoseconds) is:",
            "\t *\tnow = (offset * adj) + xtime_nsec",
            "\t * Now, even though we're adjusting the clock frequency, we have",
            "\t * to keep time consistent. In other words, we can't jump back",
            "\t * in time, and we also want to avoid jumping forward in time.",
            "\t *",
            "\t * So given the same offset value, we need the time to be the same",
            "\t * both before and after the freq adjustment.",
            "\t *\tnow = (offset * adj_1) + xtime_nsec_1",
            "\t *\tnow = (offset * adj_2) + xtime_nsec_2",
            "\t * So:",
            "\t *\t(offset * adj_1) + xtime_nsec_1 =",
            "\t *\t\t(offset * adj_2) + xtime_nsec_2",
            "\t * And we know:",
            "\t *\tadj_2 = adj_1 + 1",
            "\t * So:",
            "\t *\t(offset * adj_1) + xtime_nsec_1 =",
            "\t *\t\t(offset * (adj_1+1)) + xtime_nsec_2",
            "\t *\t(offset * adj_1) + xtime_nsec_1 =",
            "\t *\t\t(offset * adj_1) + offset + xtime_nsec_2",
            "\t * Canceling the sides:",
            "\t *\txtime_nsec_1 = offset + xtime_nsec_2",
            "\t * Which gives us:",
            "\t *\txtime_nsec_2 = xtime_nsec_1 - offset",
            "\t * Which simplifies to:",
            "\t *\txtime_nsec -= offset",
            "\t */",
            "\tif ((mult_adj > 0) && (tk->tkr_mono.mult + mult_adj < mult_adj)) {",
            "\t\t/* NTP adjustment caused clocksource mult overflow */",
            "\t\tWARN_ON_ONCE(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\ttk->tkr_mono.mult += mult_adj;",
            "\ttk->xtime_interval += interval;",
            "\ttk->tkr_mono.xtime_nsec -= offset;",
            "}"
          ],
          "function_name": "timekeeping_suspend, timekeeping_init_ops, timekeeping_apply_adjustment",
          "description": "实现系统挂起时的持久化时间记录与调整逻辑，初始化时间管理核心操作，应用频率调整参数以保持时间一致性",
          "similarity": 0.6370912790298462
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 1689,
          "end_line": 1793,
          "content": [
            "static void __timekeeping_inject_sleeptime(struct timekeeper *tk,",
            "\t\t\t\t\t   const struct timespec64 *delta)",
            "{",
            "\tif (!timespec64_valid_strict(delta)) {",
            "\t\tprintk_deferred(KERN_WARNING",
            "\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"",
            "\t\t\t\t\"sleep delta value!\\n\");",
            "\t\treturn;",
            "\t}",
            "\ttk_xtime_add(tk, delta);",
            "\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));",
            "\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));",
            "\ttk_debug_account_sleep_time(delta);",
            "}",
            "bool timekeeping_rtc_skipresume(void)",
            "{",
            "\treturn !suspend_timing_needed;",
            "}",
            "bool timekeeping_rtc_skipsuspend(void)",
            "{",
            "\treturn persistent_clock_exists;",
            "}",
            "void timekeeping_inject_sleeptime64(const struct timespec64 *delta)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "",
            "\tsuspend_timing_needed = false;",
            "",
            "\ttimekeeping_forward_now(tk);",
            "",
            "\t__timekeeping_inject_sleeptime(tk, delta);",
            "",
            "\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);",
            "",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\t/* Signal hrtimers about time change */",
            "\tclock_was_set(CLOCK_SET_WALL | CLOCK_SET_BOOT);",
            "}",
            "void timekeeping_resume(void)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tstruct clocksource *clock = tk->tkr_mono.clock;",
            "\tunsigned long flags;",
            "\tstruct timespec64 ts_new, ts_delta;",
            "\tu64 cycle_now, nsec;",
            "\tbool inject_sleeptime = false;",
            "",
            "\tread_persistent_clock64(&ts_new);",
            "",
            "\tclockevents_resume();",
            "\tclocksource_resume();",
            "",
            "\traw_spin_lock_irqsave(&timekeeper_lock, flags);",
            "\twrite_seqcount_begin(&tk_core.seq);",
            "",
            "\t/*",
            "\t * After system resumes, we need to calculate the suspended time and",
            "\t * compensate it for the OS time. There are 3 sources that could be",
            "\t * used: Nonstop clocksource during suspend, persistent clock and rtc",
            "\t * device.",
            "\t *",
            "\t * One specific platform may have 1 or 2 or all of them, and the",
            "\t * preference will be:",
            "\t *\tsuspend-nonstop clocksource -> persistent clock -> rtc",
            "\t * The less preferred source will only be tried if there is no better",
            "\t * usable source. The rtc part is handled separately in rtc core code.",
            "\t */",
            "\tcycle_now = tk_clock_read(&tk->tkr_mono);",
            "\tnsec = clocksource_stop_suspend_timing(clock, cycle_now);",
            "\tif (nsec > 0) {",
            "\t\tts_delta = ns_to_timespec64(nsec);",
            "\t\tinject_sleeptime = true;",
            "\t} else if (timespec64_compare(&ts_new, &timekeeping_suspend_time) > 0) {",
            "\t\tts_delta = timespec64_sub(ts_new, timekeeping_suspend_time);",
            "\t\tinject_sleeptime = true;",
            "\t}",
            "",
            "\tif (inject_sleeptime) {",
            "\t\tsuspend_timing_needed = false;",
            "\t\t__timekeeping_inject_sleeptime(tk, &ts_delta);",
            "\t}",
            "",
            "\t/* Re-base the last cycle value */",
            "\ttk->tkr_mono.cycle_last = cycle_now;",
            "\ttk->tkr_raw.cycle_last  = cycle_now;",
            "",
            "\ttk->ntp_error = 0;",
            "\ttimekeeping_suspended = 0;",
            "\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);",
            "\twrite_seqcount_end(&tk_core.seq);",
            "\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);",
            "",
            "\ttouch_softlockup_watchdog();",
            "",
            "\t/* Resume the clockevent device(s) and hrtimers */",
            "\ttick_resume();",
            "\t/* Notify timerfd as resume is equivalent to clock_was_set() */",
            "\ttimerfd_resume();",
            "}"
          ],
          "function_name": "__timekeeping_inject_sleeptime, timekeeping_rtc_skipresume, timekeeping_rtc_skipsuspend, timekeeping_inject_sleeptime64, timekeeping_resume",
          "description": "处理系统挂起/恢复时的时间调整，注入睡眠时间到时间保持器，控制RTC跳过逻辑，并通过clocksource计算周期差补偿系统时间",
          "similarity": 0.6038333773612976
        },
        {
          "chunk_id": 14,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 2290,
          "end_line": 2394,
          "content": [
            "void do_timer(unsigned long ticks)",
            "{",
            "\tjiffies_64 += ticks;",
            "\tcalc_global_load();",
            "}",
            "ktime_t ktime_get_update_offsets_now(unsigned int *cwsseq, ktime_t *offs_real,",
            "\t\t\t\t     ktime_t *offs_boot, ktime_t *offs_tai)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tunsigned int seq;",
            "\tktime_t base;",
            "\tu64 nsecs;",
            "",
            "\tdo {",
            "\t\tseq = read_seqcount_begin(&tk_core.seq);",
            "",
            "\t\tbase = tk->tkr_mono.base;",
            "\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);",
            "\t\tbase = ktime_add_ns(base, nsecs);",
            "",
            "\t\tif (*cwsseq != tk->clock_was_set_seq) {",
            "\t\t\t*cwsseq = tk->clock_was_set_seq;",
            "\t\t\t*offs_real = tk->offs_real;",
            "\t\t\t*offs_boot = tk->offs_boot;",
            "\t\t\t*offs_tai = tk->offs_tai;",
            "\t\t}",
            "",
            "\t\t/* Handle leapsecond insertion adjustments */",
            "\t\tif (unlikely(base >= tk->next_leap_ktime))",
            "\t\t\t*offs_real = ktime_sub(tk->offs_real, ktime_set(1, 0));",
            "",
            "\t} while (read_seqcount_retry(&tk_core.seq, seq));",
            "",
            "\treturn base;",
            "}",
            "static int timekeeping_validate_timex(const struct __kernel_timex *txc)",
            "{",
            "\tif (txc->modes & ADJ_ADJTIME) {",
            "\t\t/* singleshot must not be used with any other mode bits */",
            "\t\tif (!(txc->modes & ADJ_OFFSET_SINGLESHOT))",
            "\t\t\treturn -EINVAL;",
            "\t\tif (!(txc->modes & ADJ_OFFSET_READONLY) &&",
            "\t\t    !capable(CAP_SYS_TIME))",
            "\t\t\treturn -EPERM;",
            "\t} else {",
            "\t\t/* In order to modify anything, you gotta be super-user! */",
            "\t\tif (txc->modes && !capable(CAP_SYS_TIME))",
            "\t\t\treturn -EPERM;",
            "\t\t/*",
            "\t\t * if the quartz is off by more than 10% then",
            "\t\t * something is VERY wrong!",
            "\t\t */",
            "\t\tif (txc->modes & ADJ_TICK &&",
            "\t\t    (txc->tick <  900000/USER_HZ ||",
            "\t\t     txc->tick > 1100000/USER_HZ))",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (txc->modes & ADJ_SETOFFSET) {",
            "\t\t/* In order to inject time, you gotta be super-user! */",
            "\t\tif (!capable(CAP_SYS_TIME))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\t/*",
            "\t\t * Validate if a timespec/timeval used to inject a time",
            "\t\t * offset is valid.  Offsets can be positive or negative, so",
            "\t\t * we don't check tv_sec. The value of the timeval/timespec",
            "\t\t * is the sum of its fields,but *NOTE*:",
            "\t\t * The field tv_usec/tv_nsec must always be non-negative and",
            "\t\t * we can't have more nanoseconds/microseconds than a second.",
            "\t\t */",
            "\t\tif (txc->time.tv_usec < 0)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (txc->modes & ADJ_NANO) {",
            "\t\t\tif (txc->time.tv_usec >= NSEC_PER_SEC)",
            "\t\t\t\treturn -EINVAL;",
            "\t\t} else {",
            "\t\t\tif (txc->time.tv_usec >= USEC_PER_SEC)",
            "\t\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * Check for potential multiplication overflows that can",
            "\t * only happen on 64-bit systems:",
            "\t */",
            "\tif ((txc->modes & ADJ_FREQUENCY) && (BITS_PER_LONG == 64)) {",
            "\t\tif (LLONG_MIN / PPM_SCALE > txc->freq)",
            "\t\t\treturn -EINVAL;",
            "\t\tif (LLONG_MAX / PPM_SCALE < txc->freq)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "unsigned long random_get_entropy_fallback(void)",
            "{",
            "\tstruct tk_read_base *tkr = &tk_core.timekeeper.tkr_mono;",
            "\tstruct clocksource *clock = READ_ONCE(tkr->clock);",
            "",
            "\tif (unlikely(timekeeping_suspended || !clock))",
            "\t\treturn 0;",
            "\treturn clock->read(clock);",
            "}"
          ],
          "function_name": "do_timer, ktime_get_update_offsets_now, timekeeping_validate_timex, random_get_entropy_fallback",
          "description": "处理定时器中断更新jiffies，获取并验证时间校准参数有效性，提供熵收集回退函数读取钟源读数",
          "similarity": 0.5957053899765015
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 79,
          "end_line": 183,
          "content": [
            "static u64 dummy_clock_read(struct clocksource *cs)",
            "{",
            "\tif (timekeeping_suspended)",
            "\t\treturn cycles_at_suspend;",
            "\treturn local_clock();",
            "}",
            "static inline void tk_normalize_xtime(struct timekeeper *tk)",
            "{",
            "\twhile (tk->tkr_mono.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_mono.shift)) {",
            "\t\ttk->tkr_mono.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_mono.shift;",
            "\t\ttk->xtime_sec++;",
            "\t}",
            "\twhile (tk->tkr_raw.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_raw.shift)) {",
            "\t\ttk->tkr_raw.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_raw.shift;",
            "\t\ttk->raw_sec++;",
            "\t}",
            "}",
            "static inline struct timespec64 tk_xtime(const struct timekeeper *tk)",
            "{",
            "\tstruct timespec64 ts;",
            "",
            "\tts.tv_sec = tk->xtime_sec;",
            "\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);",
            "\treturn ts;",
            "}",
            "static void tk_set_xtime(struct timekeeper *tk, const struct timespec64 *ts)",
            "{",
            "\ttk->xtime_sec = ts->tv_sec;",
            "\ttk->tkr_mono.xtime_nsec = (u64)ts->tv_nsec << tk->tkr_mono.shift;",
            "}",
            "static void tk_xtime_add(struct timekeeper *tk, const struct timespec64 *ts)",
            "{",
            "\ttk->xtime_sec += ts->tv_sec;",
            "\ttk->tkr_mono.xtime_nsec += (u64)ts->tv_nsec << tk->tkr_mono.shift;",
            "\ttk_normalize_xtime(tk);",
            "}",
            "static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)",
            "{",
            "\tstruct timespec64 tmp;",
            "",
            "\t/*",
            "\t * Verify consistency of: offset_real = -wall_to_monotonic",
            "\t * before modifying anything",
            "\t */",
            "\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,",
            "\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);",
            "\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));",
            "\ttk->wall_to_monotonic = wtm;",
            "\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);",
            "\ttk->offs_real = timespec64_to_ktime(tmp);",
            "\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));",
            "}",
            "static inline void tk_update_sleep_time(struct timekeeper *tk, ktime_t delta)",
            "{",
            "\ttk->offs_boot = ktime_add(tk->offs_boot, delta);",
            "\t/*",
            "\t * Timespec representation for VDSO update to avoid 64bit division",
            "\t * on every update.",
            "\t */",
            "\ttk->monotonic_to_boot = ktime_to_timespec64(tk->offs_boot);",
            "}",
            "static inline u64 tk_clock_read(const struct tk_read_base *tkr)",
            "{",
            "\tstruct clocksource *clock = READ_ONCE(tkr->clock);",
            "",
            "\treturn clock->read(clock);",
            "}",
            "static void timekeeping_check_update(struct timekeeper *tk, u64 offset)",
            "{",
            "",
            "\tu64 max_cycles = tk->tkr_mono.clock->max_cycles;",
            "\tconst char *name = tk->tkr_mono.clock->name;",
            "",
            "\tif (offset > max_cycles) {",
            "\t\tprintk_deferred(\"WARNING: timekeeping: Cycle offset (%lld) is larger than allowed by the '%s' clock's max_cycles value (%lld): time overflow danger\\n\",",
            "\t\t\t\toffset, name, max_cycles);",
            "\t\tprintk_deferred(\"         timekeeping: Your kernel is sick, but tries to cope by capping time updates\\n\");",
            "\t} else {",
            "\t\tif (offset > (max_cycles >> 1)) {",
            "\t\t\tprintk_deferred(\"INFO: timekeeping: Cycle offset (%lld) is larger than the '%s' clock's 50%% safety margin (%lld)\\n\",",
            "\t\t\t\t\toffset, name, max_cycles >> 1);",
            "\t\t\tprintk_deferred(\"      timekeeping: Your kernel is still fine, but is feeling a bit nervous\\n\");",
            "\t\t}",
            "\t}",
            "",
            "\tif (tk->underflow_seen) {",
            "\t\tif (jiffies - tk->last_warning > WARNING_FREQ) {",
            "\t\t\tprintk_deferred(\"WARNING: Underflow in clocksource '%s' observed, time update ignored.\\n\", name);",
            "\t\t\tprintk_deferred(\"         Please report this, consider using a different clocksource, if possible.\\n\");",
            "\t\t\tprintk_deferred(\"         Your kernel is probably still fine.\\n\");",
            "\t\t\ttk->last_warning = jiffies;",
            "\t\t}",
            "\t\ttk->underflow_seen = 0;",
            "\t}",
            "",
            "\tif (tk->overflow_seen) {",
            "\t\tif (jiffies - tk->last_warning > WARNING_FREQ) {",
            "\t\t\tprintk_deferred(\"WARNING: Overflow in clocksource '%s' observed, time update capped.\\n\", name);",
            "\t\t\tprintk_deferred(\"         Please report this, consider using a different clocksource, if possible.\\n\");",
            "\t\t\tprintk_deferred(\"         Your kernel is probably still fine.\\n\");",
            "\t\t\ttk->last_warning = jiffies;",
            "\t\t}",
            "\t\ttk->overflow_seen = 0;",
            "\t}",
            "}"
          ],
          "function_name": "dummy_clock_read, tk_normalize_xtime, tk_xtime, tk_set_xtime, tk_xtime_add, tk_set_wall_to_mono, tk_update_sleep_time, tk_clock_read, timekeeping_check_update",
          "description": "实现时间归一化处理、时间戳转换、时间偏移设置及更新逻辑，检测时钟源偏移量是否超出允许范围，输出警告信息以防止时间溢出或下溢问题",
          "similarity": 0.5821789503097534
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/timekeeping.c",
          "start_line": 240,
          "end_line": 356,
          "content": [
            "static inline u64 timekeeping_get_delta(const struct tk_read_base *tkr)",
            "{",
            "\tstruct timekeeper *tk = &tk_core.timekeeper;",
            "\tu64 now, last, mask, max, delta;",
            "\tunsigned int seq;",
            "",
            "\t/*",
            "\t * Since we're called holding a seqcount, the data may shift",
            "\t * under us while we're doing the calculation. This can cause",
            "\t * false positives, since we'd note a problem but throw the",
            "\t * results away. So nest another seqcount here to atomically",
            "\t * grab the points we are checking with.",
            "\t */",
            "\tdo {",
            "\t\tseq = read_seqcount_begin(&tk_core.seq);",
            "\t\tnow = tk_clock_read(tkr);",
            "\t\tlast = tkr->cycle_last;",
            "\t\tmask = tkr->mask;",
            "\t\tmax = tkr->clock->max_cycles;",
            "\t} while (read_seqcount_retry(&tk_core.seq, seq));",
            "",
            "\tdelta = clocksource_delta(now, last, mask);",
            "",
            "\t/*",
            "\t * Try to catch underflows by checking if we are seeing small",
            "\t * mask-relative negative values.",
            "\t */",
            "\tif (unlikely((~delta & mask) < (mask >> 3))) {",
            "\t\ttk->underflow_seen = 1;",
            "\t\tdelta = 0;",
            "\t}",
            "",
            "\t/* Cap delta value to the max_cycles values to avoid mult overflows */",
            "\tif (unlikely(delta > max)) {",
            "\t\ttk->overflow_seen = 1;",
            "\t\tdelta = tkr->clock->max_cycles;",
            "\t}",
            "",
            "\treturn delta;",
            "}",
            "static inline void timekeeping_check_update(struct timekeeper *tk, u64 offset)",
            "{",
            "}",
            "static inline u64 timekeeping_get_delta(const struct tk_read_base *tkr)",
            "{",
            "\tu64 cycle_now, delta;",
            "",
            "\t/* read clocksource */",
            "\tcycle_now = tk_clock_read(tkr);",
            "",
            "\t/* calculate the delta since the last update_wall_time */",
            "\tdelta = clocksource_delta(cycle_now, tkr->cycle_last, tkr->mask);",
            "",
            "\treturn delta;",
            "}",
            "static void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)",
            "{",
            "\tu64 interval;",
            "\tu64 tmp, ntpinterval;",
            "\tstruct clocksource *old_clock;",
            "",
            "\t++tk->cs_was_changed_seq;",
            "\told_clock = tk->tkr_mono.clock;",
            "\ttk->tkr_mono.clock = clock;",
            "\ttk->tkr_mono.mask = clock->mask;",
            "\ttk->tkr_mono.cycle_last = tk_clock_read(&tk->tkr_mono);",
            "",
            "\ttk->tkr_raw.clock = clock;",
            "\ttk->tkr_raw.mask = clock->mask;",
            "\ttk->tkr_raw.cycle_last = tk->tkr_mono.cycle_last;",
            "",
            "\t/* Do the ns -> cycle conversion first, using original mult */",
            "\ttmp = NTP_INTERVAL_LENGTH;",
            "\ttmp <<= clock->shift;",
            "\tntpinterval = tmp;",
            "\ttmp += clock->mult/2;",
            "\tdo_div(tmp, clock->mult);",
            "\tif (tmp == 0)",
            "\t\ttmp = 1;",
            "",
            "\tinterval = (u64) tmp;",
            "\ttk->cycle_interval = interval;",
            "",
            "\t/* Go back from cycles -> shifted ns */",
            "\ttk->xtime_interval = interval * clock->mult;",
            "\ttk->xtime_remainder = ntpinterval - tk->xtime_interval;",
            "\ttk->raw_interval = interval * clock->mult;",
            "",
            "\t /* if changing clocks, convert xtime_nsec shift units */",
            "\tif (old_clock) {",
            "\t\tint shift_change = clock->shift - old_clock->shift;",
            "\t\tif (shift_change < 0) {",
            "\t\t\ttk->tkr_mono.xtime_nsec >>= -shift_change;",
            "\t\t\ttk->tkr_raw.xtime_nsec >>= -shift_change;",
            "\t\t} else {",
            "\t\t\ttk->tkr_mono.xtime_nsec <<= shift_change;",
            "\t\t\ttk->tkr_raw.xtime_nsec <<= shift_change;",
            "\t\t}",
            "\t}",
            "",
            "\ttk->tkr_mono.shift = clock->shift;",
            "\ttk->tkr_raw.shift = clock->shift;",
            "",
            "\ttk->ntp_error = 0;",
            "\ttk->ntp_error_shift = NTP_SCALE_SHIFT - clock->shift;",
            "\ttk->ntp_tick = ntpinterval << tk->ntp_error_shift;",
            "",
            "\t/*",
            "\t * The timekeeper keeps its own mult values for the currently",
            "\t * active clocksource. These value will be adjusted via NTP",
            "\t * to counteract clock drifting.",
            "\t */",
            "\ttk->tkr_mono.mult = clock->mult;",
            "\ttk->tkr_raw.mult = clock->mult;",
            "\ttk->ntp_err_mult = 0;",
            "\ttk->skip_second_overflow = 0;",
            "}"
          ],
          "function_name": "timekeeping_get_delta, timekeeping_check_update, timekeeping_get_delta, tk_setup_internals",
          "description": "计算当前时间间隔并进行数值裁剪，设置时间保持器内部参数包括时钟源信息、周期间隔及转换因子，处理时钟切换时的单位换算和数据迁移",
          "similarity": 0.5733658671379089
        }
      ]
    },
    {
      "source_file": "kernel/stop_machine.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:30:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `stop_machine.c`\n\n---\n\n# `stop_machine.c` 技术文档\n\n## 1. 文件概述\n\n`stop_machine.c` 实现了 Linux 内核中用于在所有（或指定）CPU 上同步执行特定函数的机制，即 **stop_machine** 机制。该机制通过为每个 CPU 创建一个高优先级的内核线程（称为 stopper），在需要时唤醒这些线程以执行指定任务，并确保在执行期间其他任务无法抢占，从而实现对整个系统或部分 CPU 的“冻结”式同步操作。此机制常用于需要全局一致状态的关键内核操作，如 CPU 热插拔、模块加载、内核热补丁（livepatch）等。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct cpu_stop_done`**  \n  用于协调多个 CPU 上 stop 任务的完成状态，包含待完成任务计数（`nr_todo`）、返回值（`ret`）和完成信号量（`completion`）。\n\n- **`struct cpu_stopper`**  \n  每个 CPU 对应一个 stopper 实例，包含：\n  - `thread`：stopper 内核线程\n  - `lock`：保护 pending works 链表的自旋锁\n  - `enabled`：该 stopper 是否启用（对应 CPU 是否在线）\n  - `works`：待执行的 `cpu_stop_work` 链表\n  - `stop_work`、`caller`、`fn`：用于 `stop_cpus` 的临时字段\n\n- **`struct multi_stop_data`**  \n  用于多 CPU 同步执行的共享控制结构，包含：\n  - `fn` 和 `data`：要执行的函数及其参数\n  - `num_threads`：参与同步的线程数\n  - `active_cpus`：指定哪些 CPU 需要实际执行函数\n  - `state`：全局状态机（`MULTI_STOP_*` 枚举）\n  - `thread_ack`：用于状态同步的原子计数器\n\n- **`enum multi_stop_state`**  \n  多 CPU 同步执行的状态机，包括：\n  - `MULTI_STOP_NONE`\n  - `MULTI_STOP_PREPARE`\n  - `MULTI_STOP_DISABLE_IRQ`\n  - `MULTI_STOP_RUN`\n  - `MULTI_STOP_EXIT`\n\n### 主要函数\n\n- **`stop_one_cpu(cpu, fn, arg)`**  \n  在指定 CPU 上执行函数 `fn(arg)`，阻塞等待执行完成。若 CPU 离线则返回 `-ENOENT`。\n\n- **`cpu_stop_queue_work(cpu, work)`**  \n  将 stop 任务加入指定 CPU 的 stopper 队列，若 CPU 在线则唤醒其 stopper 线程。\n\n- **`multi_cpu_stop(data)`**  \n  stopper 线程的主函数，实现多 CPU 同步状态机，负责禁用中断、执行函数、状态同步等。\n\n- **`print_stop_info(log_lvl, task)`**  \n  调试辅助函数，若 `task` 是 stopper 线程，则打印其当前执行函数及调用者信息。\n\n- **`set_state()` / `ack_state()`**  \n  控制多 CPU 同步状态机的推进：`set_state` 设置新状态并重置 ack 计数器，`ack_state` 用于线程确认状态，最后一个确认者推进到下一状态。\n\n## 3. 关键实现\n\n### Stopper 线程模型\n- 每个可能的 CPU 都有一个 `cpu_stopper` 实例，其中包含一个专用内核线程。\n- 该线程运行 `multi_cpu_stop` 函数，处于高优先级实时调度策略（由 `smpboot` 框架设置），可抢占普通任务。\n- 当有 stop 任务时，通过 `wake_up_process` 唤醒对应 stopper 线程。\n\n### 多 CPU 同步状态机\n- 使用共享的 `multi_stop_data` 结构协调所有参与 CPU。\n- 状态转换通过 `set_state` 触发，所有线程通过轮询 `msdata->state` 检测状态变化。\n- 每个状态变更需所有线程调用 `ack_state` 确认，最后一个确认者推进到下一状态，确保严格同步。\n- 在 `MULTI_STOP_DISABLE_IRQ` 状态下，所有参与 CPU 禁用本地中断（包括硬中断），ARM64 还会屏蔽 SDEI 事件。\n- 仅 `active_cpus` 中的 CPU 在 `MULTI_STOP_RUN` 状态执行实际函数。\n\n### 中断与 NMI 安全\n- 执行期间禁用本地中断，防止中断处理程序干扰关键操作。\n- 在等待状态循环中调用 `touch_nmi_watchdog()` 防止 NMI watchdog 误报硬锁死。\n- 使用 `rcu_momentary_dyntick_idle()` 通知 RCU 系统当前 CPU 处于空闲状态，避免 RCU stall。\n\n### CPU 热插拔处理\n- `cpu_stopper.enabled` 标志反映 CPU 在线状态。\n- 若 CPU 离线时提交 stop 任务，则立即完成（调用 `cpu_stop_signal_done`），避免阻塞。\n- 支持从非活动 CPU（如 CPU hotplug 的 bringup 路径）调用 `stop_machine`，此时中断可能已禁用，需保存/恢复中断状态。\n\n### 死锁预防\n- `cpu_stop_queue_two_works` 函数通过嵌套锁（`SINGLE_DEPTH_NESTING`）和重试机制，确保两个 stopper 的入队操作原子性，避免与 `stop_cpus` 并发导致的死锁。\n- 使用 `preempt_disable()` 保证唤醒操作在不可抢占上下文中完成，防止唤醒丢失。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `kthread` 创建 stopper 线程，使用 `wake_up_process` 唤醒。\n- **SMP 子系统**：依赖 `smpboot.h` 的 CPU 热插拔通知机制来启用/禁用 stopper。\n- **中断子系统**：调用 `local_irq_disable/restore`、`hard_irq_disable` 控制中断。\n- **RCU 子系统**：通过 `rcu_momentary_dyntick_idle` 与 RCU 交互。\n- **NMI 子系统**：调用 `touch_nmi_watchdog` 避免 watchdog 误报。\n- **ARM64 架构**：条件编译包含 SDEI（Software Delegated Exception Interface）屏蔽/解除屏蔽。\n- **Per-CPU 基础设施**：使用 `DEFINE_PER_CPU` 和 `per_cpu_ptr` 管理 per-CPU stopper 实例。\n\n## 5. 使用场景\n\n- **CPU 热插拔**：在 CPU 上线/下线过程中执行需要全局同步的操作。\n- **内核模块加载/卸载**：某些架构或功能（如 ftrace）需要 stop_machine 来安全修改内核文本。\n- **内核热补丁（Livepatch）**：在应用补丁时冻结所有 CPU 以确保一致性。\n- **动态 tracing（如 ftrace）**：修改函数入口指令时需 stop_machine 保证原子性。\n- **内存热插拔**：某些内存操作需要全局同步。\n- **内核调试与诊断**：通过 `print_stop_info` 辅助分析 stopper 行为。\n- **架构特定操作**：如 ARM64 的 SDEI 事件处理需要在 stop_machine 上下文中屏蔽。",
      "similarity": 0.612724244594574,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/stop_machine.c",
          "start_line": 56,
          "end_line": 201,
          "content": [
            "void print_stop_info(const char *log_lvl, struct task_struct *task)",
            "{",
            "\t/*",
            "\t * If @task is a stopper task, it cannot migrate and task_cpu() is",
            "\t * stable.",
            "\t */",
            "\tstruct cpu_stopper *stopper = per_cpu_ptr(&cpu_stopper, task_cpu(task));",
            "",
            "\tif (task != stopper->thread)",
            "\t\treturn;",
            "",
            "\tprintk(\"%sStopper: %pS <- %pS\\n\", log_lvl, stopper->fn, (void *)stopper->caller);",
            "}",
            "static void cpu_stop_init_done(struct cpu_stop_done *done, unsigned int nr_todo)",
            "{",
            "\tmemset(done, 0, sizeof(*done));",
            "\tatomic_set(&done->nr_todo, nr_todo);",
            "\tinit_completion(&done->completion);",
            "}",
            "static void cpu_stop_signal_done(struct cpu_stop_done *done)",
            "{",
            "\tif (atomic_dec_and_test(&done->nr_todo))",
            "\t\tcomplete(&done->completion);",
            "}",
            "static void __cpu_stop_queue_work(struct cpu_stopper *stopper,",
            "\t\t\t\t  struct cpu_stop_work *work)",
            "{",
            "\tlist_add_tail(&work->list, &stopper->works);",
            "}",
            "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)",
            "{",
            "\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);",
            "\tunsigned long flags;",
            "\tbool enabled;",
            "",
            "\tpreempt_disable();",
            "\traw_spin_lock_irqsave(&stopper->lock, flags);",
            "\tenabled = stopper->enabled;",
            "\tif (enabled)",
            "\t\t__cpu_stop_queue_work(stopper, work);",
            "\telse if (work->done)",
            "\t\tcpu_stop_signal_done(work->done);",
            "\traw_spin_unlock_irqrestore(&stopper->lock, flags);",
            "",
            "\tif (enabled)",
            "\t\twake_up_process(stopper->thread);",
            "\tpreempt_enable();",
            "",
            "\treturn enabled;",
            "}",
            "int stop_one_cpu(unsigned int cpu, cpu_stop_fn_t fn, void *arg)",
            "{",
            "\tstruct cpu_stop_done done;",
            "\tstruct cpu_stop_work work = { .fn = fn, .arg = arg, .done = &done, .caller = _RET_IP_ };",
            "",
            "\tcpu_stop_init_done(&done, 1);",
            "\tif (!cpu_stop_queue_work(cpu, &work))",
            "\t\treturn -ENOENT;",
            "\t/*",
            "\t * In case @cpu == smp_proccessor_id() we can avoid a sleep+wakeup",
            "\t * cycle by doing a preemption:",
            "\t */",
            "\tcond_resched();",
            "\twait_for_completion(&done.completion);",
            "\treturn done.ret;",
            "}",
            "static void set_state(struct multi_stop_data *msdata,",
            "\t\t      enum multi_stop_state newstate)",
            "{",
            "\t/* Reset ack counter. */",
            "\tatomic_set(&msdata->thread_ack, msdata->num_threads);",
            "\tsmp_wmb();",
            "\tWRITE_ONCE(msdata->state, newstate);",
            "}",
            "static void ack_state(struct multi_stop_data *msdata)",
            "{",
            "\tif (atomic_dec_and_test(&msdata->thread_ack))",
            "\t\tset_state(msdata, msdata->state + 1);",
            "}",
            "notrace void __weak stop_machine_yield(const struct cpumask *cpumask)",
            "{",
            "\tcpu_relax();",
            "}",
            "static int multi_cpu_stop(void *data)",
            "{",
            "\tstruct multi_stop_data *msdata = data;",
            "\tenum multi_stop_state newstate, curstate = MULTI_STOP_NONE;",
            "\tint cpu = smp_processor_id(), err = 0;",
            "\tconst struct cpumask *cpumask;",
            "\tunsigned long flags;",
            "\tbool is_active;",
            "",
            "\t/*",
            "\t * When called from stop_machine_from_inactive_cpu(), irq might",
            "\t * already be disabled.  Save the state and restore it on exit.",
            "\t */",
            "\tlocal_save_flags(flags);",
            "",
            "\tif (!msdata->active_cpus) {",
            "\t\tcpumask = cpu_online_mask;",
            "\t\tis_active = cpu == cpumask_first(cpumask);",
            "\t} else {",
            "\t\tcpumask = msdata->active_cpus;",
            "\t\tis_active = cpumask_test_cpu(cpu, cpumask);",
            "\t}",
            "",
            "\t/* Simple state machine */",
            "\tdo {",
            "\t\t/* Chill out and ensure we re-read multi_stop_state. */",
            "\t\tstop_machine_yield(cpumask);",
            "\t\tnewstate = READ_ONCE(msdata->state);",
            "\t\tif (newstate != curstate) {",
            "\t\t\tcurstate = newstate;",
            "\t\t\tswitch (curstate) {",
            "\t\t\tcase MULTI_STOP_DISABLE_IRQ:",
            "\t\t\t\tlocal_irq_disable();",
            "\t\t\t\thard_irq_disable();",
            "#ifdef CONFIG_ARM64",
            "\t\t\t\tsdei_mask_local_cpu();",
            "#endif",
            "\t\t\t\tbreak;",
            "\t\t\tcase MULTI_STOP_RUN:",
            "\t\t\t\tif (is_active)",
            "\t\t\t\t\terr = msdata->fn(msdata->data);",
            "\t\t\t\tbreak;",
            "\t\t\tdefault:",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tack_state(msdata);",
            "\t\t} else if (curstate > MULTI_STOP_PREPARE) {",
            "\t\t\t/*",
            "\t\t\t * At this stage all other CPUs we depend on must spin",
            "\t\t\t * in the same loop. Any reason for hard-lockup should",
            "\t\t\t * be detected and reported on their side.",
            "\t\t\t */",
            "\t\t\ttouch_nmi_watchdog();",
            "\t\t}",
            "\t\trcu_momentary_dyntick_idle();",
            "\t} while (curstate != MULTI_STOP_EXIT);",
            "",
            "#ifdef CONFIG_ARM64",
            "\tsdei_unmask_local_cpu();",
            "#endif",
            "\tlocal_irq_restore(flags);",
            "\treturn err;",
            "}"
          ],
          "function_name": "print_stop_info, cpu_stop_init_done, cpu_stop_signal_done, __cpu_stop_queue_work, cpu_stop_queue_work, stop_one_cpu, set_state, ack_state, stop_machine_yield, multi_cpu_stop",
          "description": "实现了停止操作的核心控制逻辑，包括工作队列管理、状态同步、单CPU停止处理及多CPU状态机。提供打印停止信息、初始化完成状态、信号完成、排队工作、单CPU停止、状态切换等辅助函数。",
          "similarity": 0.6110575199127197
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/stop_machine.c",
          "start_line": 401,
          "end_line": 502,
          "content": [
            "static bool queue_stop_cpus_work(const struct cpumask *cpumask,",
            "\t\t\t\t cpu_stop_fn_t fn, void *arg,",
            "\t\t\t\t struct cpu_stop_done *done)",
            "{",
            "\tstruct cpu_stop_work *work;",
            "\tunsigned int cpu;",
            "\tbool queued = false;",
            "",
            "\t/*",
            "\t * Disable preemption while queueing to avoid getting",
            "\t * preempted by a stopper which might wait for other stoppers",
            "\t * to enter @fn which can lead to deadlock.",
            "\t */",
            "\tpreempt_disable();",
            "\tstop_cpus_in_progress = true;",
            "\tbarrier();",
            "\tfor_each_cpu(cpu, cpumask) {",
            "\t\twork = &per_cpu(cpu_stopper.stop_work, cpu);",
            "\t\twork->fn = fn;",
            "\t\twork->arg = arg;",
            "\t\twork->done = done;",
            "\t\twork->caller = _RET_IP_;",
            "\t\tif (cpu_stop_queue_work(cpu, work))",
            "\t\t\tqueued = true;",
            "\t}",
            "\tbarrier();",
            "\tstop_cpus_in_progress = false;",
            "\tpreempt_enable();",
            "",
            "\treturn queued;",
            "}",
            "static int __stop_cpus(const struct cpumask *cpumask,",
            "\t\t       cpu_stop_fn_t fn, void *arg)",
            "{",
            "\tstruct cpu_stop_done done;",
            "",
            "\tcpu_stop_init_done(&done, cpumask_weight(cpumask));",
            "\tif (!queue_stop_cpus_work(cpumask, fn, arg, &done))",
            "\t\treturn -ENOENT;",
            "\twait_for_completion(&done.completion);",
            "\treturn done.ret;",
            "}",
            "static int stop_cpus(const struct cpumask *cpumask, cpu_stop_fn_t fn, void *arg)",
            "{",
            "\tint ret;",
            "",
            "\t/* static works are used, process one request at a time */",
            "\tmutex_lock(&stop_cpus_mutex);",
            "\tret = __stop_cpus(cpumask, fn, arg);",
            "\tmutex_unlock(&stop_cpus_mutex);",
            "\treturn ret;",
            "}",
            "static int cpu_stop_should_run(unsigned int cpu)",
            "{",
            "\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);",
            "\tunsigned long flags;",
            "\tint run;",
            "",
            "\traw_spin_lock_irqsave(&stopper->lock, flags);",
            "\trun = !list_empty(&stopper->works);",
            "\traw_spin_unlock_irqrestore(&stopper->lock, flags);",
            "\treturn run;",
            "}",
            "static void cpu_stopper_thread(unsigned int cpu)",
            "{",
            "\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);",
            "\tstruct cpu_stop_work *work;",
            "",
            "repeat:",
            "\twork = NULL;",
            "\traw_spin_lock_irq(&stopper->lock);",
            "\tif (!list_empty(&stopper->works)) {",
            "\t\twork = list_first_entry(&stopper->works,",
            "\t\t\t\t\tstruct cpu_stop_work, list);",
            "\t\tlist_del_init(&work->list);",
            "\t}",
            "\traw_spin_unlock_irq(&stopper->lock);",
            "",
            "\tif (work) {",
            "\t\tcpu_stop_fn_t fn = work->fn;",
            "\t\tvoid *arg = work->arg;",
            "\t\tstruct cpu_stop_done *done = work->done;",
            "\t\tint ret;",
            "",
            "\t\t/* cpu stop callbacks must not sleep, make in_atomic() == T */",
            "\t\tstopper->caller = work->caller;",
            "\t\tstopper->fn = fn;",
            "\t\tpreempt_count_inc();",
            "\t\tret = fn(arg);",
            "\t\tif (done) {",
            "\t\t\tif (ret)",
            "\t\t\t\tdone->ret = ret;",
            "\t\t\tcpu_stop_signal_done(done);",
            "\t\t}",
            "\t\tpreempt_count_dec();",
            "\t\tstopper->fn = NULL;",
            "\t\tstopper->caller = 0;",
            "\t\tWARN_ONCE(preempt_count(),",
            "\t\t\t  \"cpu_stop: %ps(%p) leaked preempt count\\n\", fn, arg);",
            "\t\tgoto repeat;",
            "\t}",
            "}"
          ],
          "function_name": "queue_stop_cpus_work, __stop_cpus, stop_cpus, cpu_stop_should_run, cpu_stopper_thread",
          "description": "实现批量CPU停止的中枢逻辑，通过互斥锁保证串行化处理。包含工作分发、停止执行、状态追踪等功能，支持通用CPU掩码的停止操作，并提供预处理检查和结果收集机制。",
          "similarity": 0.6053301095962524
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/stop_machine.c",
          "start_line": 269,
          "end_line": 369,
          "content": [
            "static int cpu_stop_queue_two_works(int cpu1, struct cpu_stop_work *work1,",
            "\t\t\t\t    int cpu2, struct cpu_stop_work *work2)",
            "{",
            "\tstruct cpu_stopper *stopper1 = per_cpu_ptr(&cpu_stopper, cpu1);",
            "\tstruct cpu_stopper *stopper2 = per_cpu_ptr(&cpu_stopper, cpu2);",
            "\tint err;",
            "",
            "retry:",
            "\t/*",
            "\t * The waking up of stopper threads has to happen in the same",
            "\t * scheduling context as the queueing.  Otherwise, there is a",
            "\t * possibility of one of the above stoppers being woken up by another",
            "\t * CPU, and preempting us. This will cause us to not wake up the other",
            "\t * stopper forever.",
            "\t */",
            "\tpreempt_disable();",
            "\traw_spin_lock_irq(&stopper1->lock);",
            "\traw_spin_lock_nested(&stopper2->lock, SINGLE_DEPTH_NESTING);",
            "",
            "\tif (!stopper1->enabled || !stopper2->enabled) {",
            "\t\terr = -ENOENT;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\t/*",
            "\t * Ensure that if we race with __stop_cpus() the stoppers won't get",
            "\t * queued up in reverse order leading to system deadlock.",
            "\t *",
            "\t * We can't miss stop_cpus_in_progress if queue_stop_cpus_work() has",
            "\t * queued a work on cpu1 but not on cpu2, we hold both locks.",
            "\t *",
            "\t * It can be falsely true but it is safe to spin until it is cleared,",
            "\t * queue_stop_cpus_work() does everything under preempt_disable().",
            "\t */",
            "\tif (unlikely(stop_cpus_in_progress)) {",
            "\t\terr = -EDEADLK;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\terr = 0;",
            "\t__cpu_stop_queue_work(stopper1, work1);",
            "\t__cpu_stop_queue_work(stopper2, work2);",
            "",
            "unlock:",
            "\traw_spin_unlock(&stopper2->lock);",
            "\traw_spin_unlock_irq(&stopper1->lock);",
            "",
            "\tif (unlikely(err == -EDEADLK)) {",
            "\t\tpreempt_enable();",
            "",
            "\t\twhile (stop_cpus_in_progress)",
            "\t\t\tcpu_relax();",
            "",
            "\t\tgoto retry;",
            "\t}",
            "",
            "\tif (!err) {",
            "\t\twake_up_process(stopper1->thread);",
            "\t\twake_up_process(stopper2->thread);",
            "\t}",
            "\tpreempt_enable();",
            "",
            "\treturn err;",
            "}",
            "int stop_two_cpus(unsigned int cpu1, unsigned int cpu2, cpu_stop_fn_t fn, void *arg)",
            "{",
            "\tstruct cpu_stop_done done;",
            "\tstruct cpu_stop_work work1, work2;",
            "\tstruct multi_stop_data msdata;",
            "",
            "\tmsdata = (struct multi_stop_data){",
            "\t\t.fn = fn,",
            "\t\t.data = arg,",
            "\t\t.num_threads = 2,",
            "\t\t.active_cpus = cpumask_of(cpu1),",
            "\t};",
            "",
            "\twork1 = work2 = (struct cpu_stop_work){",
            "\t\t.fn = multi_cpu_stop,",
            "\t\t.arg = &msdata,",
            "\t\t.done = &done,",
            "\t\t.caller = _RET_IP_,",
            "\t};",
            "",
            "\tcpu_stop_init_done(&done, 2);",
            "\tset_state(&msdata, MULTI_STOP_PREPARE);",
            "",
            "\tif (cpu1 > cpu2)",
            "\t\tswap(cpu1, cpu2);",
            "\tif (cpu_stop_queue_two_works(cpu1, &work1, cpu2, &work2))",
            "\t\treturn -ENOENT;",
            "",
            "\twait_for_completion(&done.completion);",
            "\treturn done.ret;",
            "}",
            "bool stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,",
            "\t\t\tstruct cpu_stop_work *work_buf)",
            "{",
            "\t*work_buf = (struct cpu_stop_work){ .fn = fn, .arg = arg, .caller = _RET_IP_, };",
            "\treturn cpu_stop_queue_work(cpu, work_buf);",
            "}"
          ],
          "function_name": "cpu_stop_queue_two_works, stop_two_cpus, stop_one_cpu_nowait",
          "description": "实现双CPU停止操作的协同逻辑，通过原子操作防止死锁，确保两个CPU的停止工作被正确排队和唤醒。包含针对两个CPU的停止接口和非阻塞式单CPU停止标记功能。",
          "similarity": 0.5652076005935669
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/stop_machine.c",
          "start_line": 687,
          "end_line": 716,
          "content": [
            "int stop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void *data,",
            "\t\t\t\t  const struct cpumask *cpus)",
            "{",
            "\tstruct multi_stop_data msdata = { .fn = fn, .data = data,",
            "\t\t\t\t\t    .active_cpus = cpus };",
            "\tstruct cpu_stop_done done;",
            "\tint ret;",
            "",
            "\t/* Local CPU must be inactive and CPU hotplug in progress. */",
            "\tBUG_ON(cpu_active(raw_smp_processor_id()));",
            "\tmsdata.num_threads = num_active_cpus() + 1;\t/* +1 for local */",
            "",
            "\t/* No proper task established and can't sleep - busy wait for lock. */",
            "\twhile (!mutex_trylock(&stop_cpus_mutex))",
            "\t\tcpu_relax();",
            "",
            "\t/* Schedule work on other CPUs and execute directly for local CPU */",
            "\tset_state(&msdata, MULTI_STOP_PREPARE);",
            "\tcpu_stop_init_done(&done, num_active_cpus());",
            "\tqueue_stop_cpus_work(cpu_active_mask, multi_cpu_stop, &msdata,",
            "\t\t\t     &done);",
            "\tret = multi_cpu_stop(&msdata);",
            "",
            "\t/* Busy wait for completion. */",
            "\twhile (!completion_done(&done.completion))",
            "\t\tcpu_relax();",
            "",
            "\tmutex_unlock(&stop_cpus_mutex);",
            "\treturn ret ?: done.ret;",
            "}"
          ],
          "function_name": "stop_machine_from_inactive_cpu",
          "description": "该函数用于在非活跃CPU上协调多CPU的停止操作，确保在CPU热插拔期间正确执行停止回调函数。  \n通过获取互斥锁、异步调度任务并在本地直接执行，最终阻塞等待所有停止操作完成。  \n依赖未显示的辅助函数（如`queue_stop_cpus_work`和`multi_cpu_stop`），上下文可能存在不完整情况。",
          "similarity": 0.551049530506134
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/stop_machine.c",
          "start_line": 536,
          "end_line": 641,
          "content": [
            "void stop_machine_park(int cpu)",
            "{",
            "\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);",
            "\t/*",
            "\t * Lockless. cpu_stopper_thread() will take stopper->lock and flush",
            "\t * the pending works before it parks, until then it is fine to queue",
            "\t * the new works.",
            "\t */",
            "\tstopper->enabled = false;",
            "\tkthread_park(stopper->thread);",
            "}",
            "static void cpu_stop_create(unsigned int cpu)",
            "{",
            "\tsched_set_stop_task(cpu, per_cpu(cpu_stopper.thread, cpu));",
            "}",
            "static void cpu_stop_park(unsigned int cpu)",
            "{",
            "\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);",
            "",
            "\tWARN_ON(!list_empty(&stopper->works));",
            "}",
            "void stop_machine_unpark(int cpu)",
            "{",
            "\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);",
            "",
            "\tstopper->enabled = true;",
            "\tkthread_unpark(stopper->thread);",
            "}",
            "static int __init cpu_stop_init(void)",
            "{",
            "\tunsigned int cpu;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);",
            "",
            "\t\traw_spin_lock_init(&stopper->lock);",
            "\t\tINIT_LIST_HEAD(&stopper->works);",
            "\t}",
            "",
            "\tBUG_ON(smpboot_register_percpu_thread(&cpu_stop_threads));",
            "\tstop_machine_unpark(raw_smp_processor_id());",
            "\tstop_machine_initialized = true;",
            "\treturn 0;",
            "}",
            "int stop_machine_cpuslocked(cpu_stop_fn_t fn, void *data,",
            "\t\t\t    const struct cpumask *cpus)",
            "{",
            "\tstruct multi_stop_data msdata = {",
            "\t\t.fn = fn,",
            "\t\t.data = data,",
            "\t\t.num_threads = num_online_cpus(),",
            "\t\t.active_cpus = cpus,",
            "\t};",
            "",
            "\tlockdep_assert_cpus_held();",
            "",
            "\tif (!stop_machine_initialized) {",
            "\t\t/*",
            "\t\t * Handle the case where stop_machine() is called",
            "\t\t * early in boot before stop_machine() has been",
            "\t\t * initialized.",
            "\t\t */",
            "\t\tunsigned long flags;",
            "\t\tint ret;",
            "",
            "\t\tWARN_ON_ONCE(msdata.num_threads != 1);",
            "",
            "\t\tlocal_irq_save(flags);",
            "\t\thard_irq_disable();",
            "\t\tret = (*fn)(data);",
            "\t\tlocal_irq_restore(flags);",
            "",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/* Set the initial state and stop all online cpus. */",
            "\tset_state(&msdata, MULTI_STOP_PREPARE);",
            "\treturn stop_cpus(cpu_online_mask, multi_cpu_stop, &msdata);",
            "}",
            "int stop_machine(cpu_stop_fn_t fn, void *data, const struct cpumask *cpus)",
            "{",
            "\tint ret;",
            "",
            "\t/* No CPUs can come up or down during this. */",
            "\tcpus_read_lock();",
            "\tret = stop_machine_cpuslocked(fn, data, cpus);",
            "\tcpus_read_unlock();",
            "\treturn ret;",
            "}",
            "int stop_core_cpuslocked(unsigned int cpu, cpu_stop_fn_t fn, void *data)",
            "{",
            "\tconst struct cpumask *smt_mask = cpu_smt_mask(cpu);",
            "",
            "\tstruct multi_stop_data msdata = {",
            "\t\t.fn = fn,",
            "\t\t.data = data,",
            "\t\t.num_threads = cpumask_weight(smt_mask),",
            "\t\t.active_cpus = smt_mask,",
            "\t};",
            "",
            "\tlockdep_assert_cpus_held();",
            "",
            "\t/* Set the initial state and stop all online cpus. */",
            "\tset_state(&msdata, MULTI_STOP_PREPARE);",
            "\treturn stop_cpus(smt_mask, multi_cpu_stop, &msdata);",
            "}"
          ],
          "function_name": "stop_machine_park, cpu_stop_create, cpu_stop_park, stop_machine_unpark, cpu_stop_init, stop_machine_cpuslocked, stop_machine, stop_core_cpuslocked",
          "description": "负责停止器线程的生命周期管理和初始化。包含线程创建、挂起/恢复操作、核心初始化函数，以及带锁的CPU停止接口。提供针对特定CPU核心的停止功能和早期启动阶段的降级处理路径。",
          "similarity": 0.5348989367485046
        }
      ]
    }
  ]
}