{
  "query": "中断向量表在启动过程中的作用",
  "timestamp": "2025-12-26 00:34:23",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/timings.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:10:35\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\timings.c`\n\n---\n\n# irq/timings.c 技术文档\n\n## 1. 文件概述\n\n`irq/timings.c` 是 Linux 内核中用于中断时间预测的核心模块。该文件实现了基于历史中断时间戳的预测算法，旨在通过分析中断发生的周期性模式，预测下一次中断可能发生的时间。此功能主要用于低功耗场景（如 CPU 空闲状态管理），帮助调度器或电源管理子系统更精确地设置唤醒时间，从而在保证响应性的同时减少不必要的唤醒开销。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct irq_timings`：每个 CPU 私有的中断时间记录结构，包含一个循环缓冲区，用于存储 `<中断号, 时间戳>` 元组。\n- `irqt_stats`：全局 IDR（整数到指针映射）结构，用于按中断号索引中断统计信息。\n- `irq_timing_enabled`：静态分支键（`static_key`），用于在运行时动态启用/禁用中断时间跟踪功能，避免性能开销。\n\n### 主要函数\n\n- `irq_timings_enable(void)`：启用中断时间跟踪功能，激活静态分支。\n- `irq_timings_disable(void)`：禁用中断时间跟踪功能，关闭静态分支。\n- （注：实际的预测算法逻辑虽未在代码片段中完整展示，但文档详细描述了其实现原理）\n\n## 3. 关键实现\n\n### 中断时间预测算法\n\n该模块采用三阶段算法预测中断周期：\n\n#### 1) 后缀数组（Suffix Array）模式识别\n- 将中断间隔（经 `ilog2` 映射后的索引值）序列视为字符串。\n- 构建长度为 2 到 5 的后缀（受限于实际设备周期经验）。\n- 在最近 `3 × max_period`（即 15）个索引中搜索后缀的重复出现。\n- 若某后缀连续出现 3 次，则认为发现有效周期模式，其长度即为预测周期。\n\n#### 2) 对数间隔桶（Log Interval Bucketing）\n- 使用 `ilog2(interval)` 将原始时间间隔映射到 0~63 的桶索引（因 `u64` 最大为 2^64）。\n- 该方法将大范围的时间值压缩到小数组中，例如值 1123 映射到索引 10（因 2^10 = 1024 ≤ 1123 < 2048 = 2^11）。\n\n#### 3) 指数移动平均（Exponential Moving Average, EMA）\n- 每个桶维护一个 EMA 值，用于平滑同一数量级间隔的波动。\n- EMA 公式使平均值对新数据具有可调的响应速度（通过 alpha 参数隐式控制）。\n- 预测时，根据识别出的周期模式中的桶索引，返回对应桶的 EMA 值作为预测间隔。\n\n### 工作流程\n1. 中断发生时，若 `irq_timing_enabled` 为真，则将 `<irq, timestamp>` 记录到 per-CPU 的循环缓冲区。\n2. 当需要预测某中断的下次发生时间时：\n   - 清空并处理循环缓冲区，将间隔数据分发到各中断的统计结构中。\n   - 对每个中断的间隔序列执行上述三阶段算法。\n   - 若找到重复模式，则用 EMA 值计算预测时间；否则返回未预测。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/percpu.h>`：实现 per-CPU 变量 `irq_timings`。\n  - `<linux/static_key.h>`：提供静态分支优化，避免未启用时的条件判断开销。\n  - `<linux/math64.h>` 和 `<linux/log2.h>`：用于 `ilog2` 等数学运算。\n  - `<trace/events/irq.h>`：可能用于跟踪事件（虽未在片段中调用）。\n  - `\"internals.h\"`：内核中断子系统内部头文件。\n- **子系统依赖**：\n  - 通用中断子系统（`<linux/irq.h>`, `<linux/interrupt.h>`）。\n  - 内存管理（`<linux/slab.h>`）用于动态分配统计结构。\n  - IDR 机制（`<linux/idr.h>`）用于中断号到统计结构的映射。\n\n## 5. 使用场景\n\n- **CPU 空闲状态管理（cpuidle）**：在进入深度 C-state 前，预测下一次中断时间以设置精确的唤醒定时器，避免过早或过晚唤醒。\n- **实时系统调度**：辅助调度器预判周期性中断（如 tickless 系统中的高精度定时器），优化任务调度时机。\n- **电源管理**：结合设备驱动的中断模式，动态调整设备或 CPU 的电源状态。\n- **性能分析**：通过跟踪中断时间模式，诊断中断风暴或异常周期行为。\n\n该功能默认关闭，仅在需要时通过 `irq_timings_enable()` 动态启用，确保对常规系统性能无影响。",
      "similarity": 0.625352680683136,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/timings.c",
          "start_line": 1,
          "end_line": 25,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright (C) 2016, Linaro Ltd - Daniel Lezcano <daniel.lezcano@linaro.org>",
            "#define pr_fmt(fmt) \"irq_timings: \" fmt",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/static_key.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/idr.h>",
            "#include <linux/irq.h>",
            "#include <linux/math64.h>",
            "#include <linux/log2.h>",
            "",
            "#include <trace/events/irq.h>",
            "",
            "#include \"internals.h\"",
            "",
            "DEFINE_STATIC_KEY_FALSE(irq_timing_enabled);",
            "",
            "DEFINE_PER_CPU(struct irq_timings, irq_timings);",
            "",
            "static DEFINE_IDR(irqt_stats);",
            ""
          ],
          "function_name": null,
          "description": "定义中断计时模块的静态键开关和PER-CPU结构体，声明IDR管理器用于动态分配中断统计实例",
          "similarity": 0.6369167566299438
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/timings.c",
          "start_line": 26,
          "end_line": 165,
          "content": [
            "void irq_timings_enable(void)",
            "{",
            "\tstatic_branch_enable(&irq_timing_enabled);",
            "}",
            "void irq_timings_disable(void)",
            "{",
            "\tstatic_branch_disable(&irq_timing_enabled);",
            "}",
            "static u64 irq_timings_ema_new(u64 value, u64 ema_old)",
            "{",
            "\ts64 diff;",
            "",
            "\tif (unlikely(!ema_old))",
            "\t\treturn value;",
            "",
            "\tdiff = (value - ema_old) * EMA_ALPHA_VAL;",
            "\t/*",
            "\t * We can use a s64 type variable to be added with the u64",
            "\t * ema_old variable as this one will never have its topmost",
            "\t * bit set, it will be always smaller than 2^63 nanosec",
            "\t * interrupt interval (292 years).",
            "\t */",
            "\treturn ema_old + (diff >> EMA_ALPHA_SHIFT);",
            "}",
            "static int irq_timings_next_event_index(int *buffer, size_t len, int period_max)",
            "{",
            "\tint period;",
            "",
            "\t/*",
            "\t * Move the beginning pointer to the end minus the max period x 3.",
            "\t * We are at the point we can begin searching the pattern",
            "\t */",
            "\tbuffer = &buffer[len - (period_max * 3)];",
            "",
            "\t/* Adjust the length to the maximum allowed period x 3 */",
            "\tlen = period_max * 3;",
            "",
            "\t/*",
            "\t * The buffer contains the suite of intervals, in a ilog2",
            "\t * basis, we are looking for a repetition. We point the",
            "\t * beginning of the search three times the length of the",
            "\t * period beginning at the end of the buffer. We do that for",
            "\t * each suffix.",
            "\t */",
            "\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {",
            "",
            "\t\t/*",
            "\t\t * The first comparison always succeed because the",
            "\t\t * suffix is deduced from the first n-period bytes of",
            "\t\t * the buffer and we compare the initial suffix with",
            "\t\t * itself, so we can skip the first iteration.",
            "\t\t */",
            "\t\tint idx = period;",
            "\t\tsize_t size = period;",
            "",
            "\t\t/*",
            "\t\t * We look if the suite with period 'i' repeat",
            "\t\t * itself. If it is truncated at the end, as it",
            "\t\t * repeats we can use the period to find out the next",
            "\t\t * element with the modulo.",
            "\t\t */",
            "\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {",
            "",
            "\t\t\t/*",
            "\t\t\t * Move the index in a period basis",
            "\t\t\t */",
            "\t\t\tidx += size;",
            "",
            "\t\t\t/*",
            "\t\t\t * If this condition is reached, all previous",
            "\t\t\t * memcmp were successful, so the period is",
            "\t\t\t * found.",
            "\t\t\t */",
            "\t\t\tif (idx == len)",
            "\t\t\t\treturn buffer[len % period];",
            "",
            "\t\t\t/*",
            "\t\t\t * If the remaining elements to compare are",
            "\t\t\t * smaller than the period, readjust the size",
            "\t\t\t * of the comparison for the last iteration.",
            "\t\t\t */",
            "\t\t\tif (len - idx < period)",
            "\t\t\t\tsize = len - idx;",
            "\t\t}",
            "\t}",
            "",
            "\treturn -1;",
            "}",
            "static u64 __irq_timings_next_event(struct irqt_stat *irqs, int irq, u64 now)",
            "{",
            "\tint index, i, period_max, count, start, min = INT_MAX;",
            "",
            "\tif ((now - irqs->last_ts) >= NSEC_PER_SEC) {",
            "\t\tirqs->count = irqs->last_ts = 0;",
            "\t\treturn U64_MAX;",
            "\t}",
            "",
            "\t/*",
            "\t * As we want to find three times the repetition, we need a",
            "\t * number of intervals greater or equal to three times the",
            "\t * maximum period, otherwise we truncate the max period.",
            "\t */",
            "\tperiod_max = irqs->count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : irqs->count / 3;",
            "",
            "\t/*",
            "\t * If we don't have enough irq timings for this prediction,",
            "\t * just bail out.",
            "\t */",
            "\tif (period_max <= PREDICTION_PERIOD_MIN)",
            "\t\treturn U64_MAX;",
            "",
            "\t/*",
            "\t * 'count' will depends if the circular buffer wrapped or not",
            "\t */",
            "\tcount = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\tirqs->count : IRQ_TIMINGS_SIZE;",
            "",
            "\tstart = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\t0 : (irqs->count & IRQ_TIMINGS_MASK);",
            "",
            "\t/*",
            "\t * Copy the content of the circular buffer into another buffer",
            "\t * in order to linearize the buffer instead of dealing with",
            "\t * wrapping indexes and shifted array which will be prone to",
            "\t * error and extremely difficult to debug.",
            "\t */",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "",
            "\t\tirqs->timings[i] = irqs->circ_timings[index];",
            "\t\tmin = min_t(int, irqs->timings[i], min);",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(irqs->timings, count, period_max);",
            "\tif (index < 0)",
            "\t\treturn irqs->last_ts + irqs->ema_time[min];",
            "",
            "\treturn irqs->last_ts + irqs->ema_time[index];",
            "}"
          ],
          "function_name": "irq_timings_enable, irq_timings_disable, irq_timings_ema_new, irq_timings_next_event_index, __irq_timings_next_event",
          "description": "实现中断计时功能的启用/禁用控制，EMA计算算法及基于模式匹配的周期预测核心逻辑",
          "similarity": 0.6059086918830872
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/timings.c",
          "start_line": 821,
          "end_line": 923,
          "content": [
            "static int __init irq_timings_irqs_selftest(void)",
            "{",
            "\tint i, ret;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {",
            "\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",",
            "\t\t\ti, tis[i].count);",
            "\t\tret = irq_timings_test_irqs(&tis[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __init irq_timings_test_irqts(struct irq_timings *irqts,",
            "\t\t\t\t\t unsigned count)",
            "{",
            "\tint start = count >= IRQ_TIMINGS_SIZE ? count - IRQ_TIMINGS_SIZE : 0;",
            "\tint i, irq, oirq = 0xBEEF;",
            "\tu64 ots = 0xDEAD, ts;",
            "",
            "\t/*",
            "\t * Fill the circular buffer by using the dedicated function.",
            "\t */",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tpr_debug(\"%d: index=%d, ts=%llX irq=%X\\n\",",
            "\t\t\t i, i & IRQ_TIMINGS_MASK, ots + i, oirq + i);",
            "",
            "\t\tirq_timings_push(ots + i, oirq + i);",
            "\t}",
            "",
            "\t/*",
            "\t * Compute the first elements values after the index wrapped",
            "\t * up or not.",
            "\t */",
            "\tots += start;",
            "\toirq += start;",
            "",
            "\t/*",
            "\t * Test the circular buffer count is correct.",
            "\t */",
            "\tpr_debug(\"---> Checking timings array count (%d) is right\\n\", count);",
            "\tif (WARN_ON(irqts->count != count))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Test the macro allowing to browse all the irqts.",
            "\t */",
            "\tpr_debug(\"---> Checking the for_each_irqts() macro\\n\");",
            "\tfor_each_irqts(i, irqts) {",
            "",
            "\t\tirq = irq_timing_decode(irqts->values[i], &ts);",
            "",
            "\t\tpr_debug(\"index=%d, ts=%llX / %llX, irq=%X / %X\\n\",",
            "\t\t\t i, ts, ots, irq, oirq);",
            "",
            "\t\tif (WARN_ON(ts != ots || irq != oirq))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tots++; oirq++;",
            "\t}",
            "",
            "\t/*",
            "\t * The circular buffer should have be flushed when browsed",
            "\t * with for_each_irqts",
            "\t */",
            "\tpr_debug(\"---> Checking timings array is empty after browsing it\\n\");",
            "\tif (WARN_ON(irqts->count))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_irqts_selftest(void)",
            "{",
            "\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);",
            "\tint i, ret;",
            "",
            "\t/*",
            "\t * Test the circular buffer with different number of",
            "\t * elements. The purpose is to test at the limits (empty, half",
            "\t * full, full, wrapped with the cursor at the boundaries,",
            "\t * wrapped several times, etc ...",
            "\t */",
            "\tint count[] = { 0,",
            "\t\t\tIRQ_TIMINGS_SIZE >> 1,",
            "\t\t\tIRQ_TIMINGS_SIZE,",
            "\t\t\tIRQ_TIMINGS_SIZE + (IRQ_TIMINGS_SIZE >> 1),",
            "\t\t\t2 * IRQ_TIMINGS_SIZE,",
            "\t\t\t(2 * IRQ_TIMINGS_SIZE) + 3,",
            "\t};",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(count); i++) {",
            "",
            "\t\tpr_info(\"---> Checking the timings with %d/%d values\\n\",",
            "\t\t\tcount[i], IRQ_TIMINGS_SIZE);",
            "",
            "\t\tret = irq_timings_test_irqts(irqts, count[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_irqs_selftest, irq_timings_test_irqts, irq_timings_irqts_selftest",
          "description": "包含完整的中断计时模块自检框架，验证环形缓冲区操作和for_each_irqts宏的正确性",
          "similarity": 0.5789497494697571
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/irq/timings.c",
          "start_line": 927,
          "end_line": 956,
          "content": [
            "static int __init irq_timings_selftest(void)",
            "{",
            "\tint ret;",
            "",
            "\tpr_info(\"------------------- selftest start -----------------\\n\");",
            "",
            "\t/*",
            "\t * At this point, we don't except any subsystem to use the irq",
            "\t * timings but us, so it should not be enabled.",
            "\t */",
            "\tif (static_branch_unlikely(&irq_timing_enabled)) {",
            "\t\tpr_warn(\"irq timings already initialized, skipping selftest\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = irq_timings_irqts_selftest();",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tret = irq_timings_irqs_selftest();",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tret = irq_timings_next_index_selftest();",
            "out:",
            "\tpr_info(\"---------- selftest end with %s -----------\\n\",",
            "\t\tret ? \"failure\" : \"success\");",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_selftest",
          "description": "该代码段实现了中断定时功能的自我检测逻辑，用于验证中断时间戳、中断序列及索引管理等子系统的正确性。作为初始化函数，它通过调用三个子测试函数依次检查相关功能模块的行为是否符合预期。由于代码中引用了未展示的测试函数（如irq_timings_irqts_selftest），需结合上下文才能完整理解其工作机制。",
          "similarity": 0.5610449910163879
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/timings.c",
          "start_line": 594,
          "end_line": 739,
          "content": [
            "void irq_timings_free(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s) {",
            "\t\tfree_percpu(s);",
            "\t\tidr_remove(&irqt_stats, irq);",
            "\t}",
            "}",
            "int irq_timings_alloc(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tint id;",
            "",
            "\t/*",
            "\t * Some platforms can have the same private interrupt per cpu,",
            "\t * so this function may be called several times with the",
            "\t * same interrupt number. Just bail out in case the per cpu",
            "\t * stat structure is already allocated.",
            "\t */",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s)",
            "\t\treturn 0;",
            "",
            "\ts = alloc_percpu(*s);",
            "\tif (!s)",
            "\t\treturn -ENOMEM;",
            "",
            "\tidr_preload(GFP_KERNEL);",
            "\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);",
            "\tidr_preload_end();",
            "",
            "\tif (id < 0) {",
            "\t\tfree_percpu(s);",
            "\t\treturn id;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_test_next_index(struct timings_intervals *ti)",
            "{",
            "\tint _buffer[IRQ_TIMINGS_SIZE];",
            "\tint buffer[IRQ_TIMINGS_SIZE];",
            "\tint index, start, i, count, period_max;",
            "",
            "\tcount = ti->count - 1;",
            "",
            "\tperiod_max = count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : count / 3;",
            "",
            "\t/*",
            "\t * Inject all values except the last one which will be used",
            "\t * to compare with the next index result.",
            "\t */",
            "\tpr_debug(\"index suite: \");",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\t_buffer[i & IRQ_TIMINGS_MASK] = index;",
            "\t\tpr_cont(\"%d \", index);",
            "\t}",
            "",
            "\tstart = count < IRQ_TIMINGS_SIZE ? 0 :",
            "\t\tcount & IRQ_TIMINGS_MASK;",
            "",
            "\tcount = min_t(int, count, IRQ_TIMINGS_SIZE);",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "\t\tbuffer[i] = _buffer[index];",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(buffer, count, period_max);",
            "\ti = irq_timings_interval_index(ti->intervals[ti->count - 1]);",
            "",
            "\tif (index != i) {",
            "\t\tpr_err(\"Expected (%d) and computed (%d) next indexes differ\\n\",",
            "\t\t       i, index);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_next_index_selftest(void)",
            "{",
            "\tint i, ret;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {",
            "",
            "\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",",
            "\t\t\ti, tis[i].count);",
            "",
            "\t\tret = irq_timings_test_next_index(&tis[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __init irq_timings_test_irqs(struct timings_intervals *ti)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tstruct irqt_stat *irqs;",
            "\tint i, index, ret, irq = 0xACE5;",
            "",
            "\tret = irq_timings_alloc(irq);",
            "\tif (ret) {",
            "\t\tpr_err(\"Failed to allocate irq timings\\n\");",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (!s) {",
            "\t\tret = -EIDRM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tirqs = this_cpu_ptr(s);",
            "",
            "\tfor (i = 0; i < ti->count; i++) {",
            "",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\tpr_debug(\"%d: interval=%llu ema_index=%d\\n\",",
            "\t\t\t i, ti->intervals[i], index);",
            "",
            "\t\t__irq_timings_store(irq, irqs, ti->intervals[i]);",
            "\t\tif (irqs->circ_timings[i & IRQ_TIMINGS_MASK] != index) {",
            "\t\t\tret = -EBADSLT;",
            "\t\t\tpr_err(\"Failed to store in the circular buffer\\n\");",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tif (irqs->count != ti->count) {",
            "\t\tret = -ERANGE;",
            "\t\tpr_err(\"Count differs\\n\");",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = 0;",
            "out:",
            "\tirq_timings_free(irq);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_free, irq_timings_alloc, irq_timings_test_next_index, irq_timings_next_index_selftest, irq_timings_test_irqs",
          "description": "实现中断统计结构的动态分配/释放机制，包含预测算法的自检测试函数",
          "similarity": 0.5413060784339905
        }
      ]
    },
    {
      "source_file": "kernel/irq/chip.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:48:28\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\chip.c`\n\n---\n\n# `irq/chip.c` 技术文档\n\n## 1. 文件概述\n\n`irq/chip.c` 是 Linux 内核通用中断子系统（Generic IRQ）的核心实现文件之一，主要负责基于 `irq_chip` 抽象的中断控制器底层操作。该文件提供了中断芯片（IRQ chip）的注册、配置、启停、数据管理等基础接口，是架构无关的中断处理基础设施，为各种硬件中断控制器（如 GIC、APIC、MSI 等）提供统一的管理框架。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能说明 |\n|--------|--------|\n| `irq_set_chip()` | 为指定 IRQ 号绑定 `irq_chip` 操作结构体 |\n| `irq_set_irq_type()` | 设置中断触发类型（电平/边沿触发等） |\n| `irq_set_handler_data()` | 设置中断处理程序私有数据（`handler_data`） |\n| `irq_set_chip_data()` | 设置中断芯片私有数据（`chip_data`） |\n| `irq_set_msi_desc()` / `irq_set_msi_desc_off()` | 为 MSI/MSI-X 中断设置描述符 |\n| `irq_get_irq_data()` | 获取指定 IRQ 的 `irq_data` 结构指针 |\n| `irq_startup()` | 启动一个中断（调用 chip 的 `irq_startup` 或 `irq_enable`） |\n| `irq_shutdown()` | 关闭一个中断（调用 chip 的 `irq_shutdown` 或 `irq_disable`） |\n| `irq_activate()` | 激活中断（通常用于 IRQ domain 资源分配） |\n| `irq_activate_and_startup()` | 组合激活并启动中断 |\n| `irq_shutdown_and_deactivate()` | 组合关闭并去激活中断 |\n\n### 关键数据结构\n\n- **`chained_action`**：专用于级联中断（chained IRQ）的默认 `irqaction`，其处理函数 `bad_chained_irq` 会在错误调用时发出警告。\n- **`struct irq_chip`**：中断控制器操作抽象，包含 `irq_startup`、`irq_shutdown`、`irq_enable`、`irq_disable` 等回调函数。\n- **`struct irq_desc`**：中断描述符，包含中断状态、操作函数、私有数据等。\n- **`struct irq_data`**：中断数据结构，嵌入在 `irq_desc` 中，包含 `chip`、`chip_data`、状态标志（如 `IRQD_IRQ_DISABLED`）等。\n\n## 3. 关键实现\n\n### 中断状态管理\n- 使用 `irqd_set()` / `irqd_clear()` 操作 `irq_data` 中的状态位（如 `IRQD_IRQ_DISABLED`、`IRQD_IRQ_MASKED`、`IRQD_IRQ_STARTED`）。\n- `irq_startup()` 和 `irq_shutdown()` 通过检查 `irqd_is_started()` 决定是否执行完整启停流程。\n\n### 级联中断保护\n- `chained_action` 的 `bad_chained_irq` 处理函数用于防止级联中断被误当作普通中断处理，确保级联中断仅由父中断控制器驱动调用。\n\n### 管理型中断（Managed IRQ）支持\n- 在 `CONFIG_SMP` 下，`__irq_startup_managed()` 检查中断是否为“管理型”（由内核自动管理 CPU 亲和性）。\n- 若亲和性掩码中无在线 CPU，则进入 `IRQ_STARTUP_ABORT` 状态并设置 `IRQD_MANAGED_SHUTDOWN`，等待 CPU 热插拔事件重新启动。\n\n### 启动流程\n- `irq_startup()` 根据 `irq_chip` 是否提供 `irq_startup` 回调选择不同路径：\n  - 有 `irq_startup`：调用该函数，并清除 `DISABLED` 和 `MASKED` 状态。\n  - 无 `irq_startup`：调用通用 `irq_enable()`。\n- 支持亲和性设置时机控制：通过 `IRQCHIP_AFFINITY_PRE_STARTUP` 标志决定在启动前还是启动后设置 CPU 亲和性。\n\n### MSI 描述符管理\n- `irq_set_msi_desc_off()` 支持为 MSI 中断组（base + offset）设置描述符，并在 offset 为 0 时更新 `msi_desc->irq` 字段。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`：定义 `irq_chip`、`irq_desc` 等核心结构。\n  - `<linux/msi.h>`：MSI 相关定义。\n  - `<linux/irqdomain.h>`：IRQ domain 支持。\n  - `\"internals.h\"`：中断子系统内部接口。\n- **模块依赖**：\n  - 依赖通用中断子系统（Generic IRQ）的其他组件，如 `irqdesc.c`（描述符管理）、`irqdomain.c`（IRQ domain 映射）。\n  - 与 CPU 热插拔子系统交互（管理型中断场景）。\n  - 被各类中断控制器驱动（如 GIC、IOAPIC、MSI 驱动）调用以注册和配置中断。\n\n## 5. 使用场景\n\n- **中断控制器驱动初始化**：在平台或设备驱动中调用 `irq_set_chip()`、`irq_set_chip_data()` 等函数注册中断控制器操作。\n- **中断类型配置**：设备驱动通过 `irq_set_irq_type()` 设置中断触发方式（如 `IRQ_TYPE_EDGE_RISING`）。\n- **MSI/MSI-X 中断设置**：PCIe 驱动使用 `irq_set_msi_desc()` 关联 MSI 描述符与 IRQ 号。\n- **中断启停控制**：内核在 `request_irq()` / `free_irq()` 或 `enable_irq()` / `disable_irq()` 路径中调用 `irq_startup()` / `irq_shutdown()`。\n- **CPU 热插拔处理**：管理型中断在 CPU 上线/下线时自动启停，依赖本文件的 `__irq_startup_managed()` 逻辑。\n- **级联中断实现**：父中断控制器使用 `chained_action` 作为占位符，防止子中断被错误处理。",
      "similarity": 0.6251200437545776,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/chip.c",
          "start_line": 227,
          "end_line": 337,
          "content": [
            "static __always_inline int",
            "__irq_startup_managed(struct irq_desc *desc, const struct cpumask *aff,",
            "\t\t      bool force)",
            "{",
            "\treturn IRQ_STARTUP_NORMAL;",
            "}",
            "static int __irq_startup(struct irq_desc *desc)",
            "{",
            "\tstruct irq_data *d = irq_desc_get_irq_data(desc);",
            "\tint ret = 0;",
            "",
            "\t/* Warn if this interrupt is not activated but try nevertheless */",
            "\tWARN_ON_ONCE(!irqd_is_activated(d));",
            "",
            "\tif (d->chip->irq_startup) {",
            "\t\tret = d->chip->irq_startup(d);",
            "\t\tirq_state_clr_disabled(desc);",
            "\t\tirq_state_clr_masked(desc);",
            "\t} else {",
            "\t\tirq_enable(desc);",
            "\t}",
            "\tirq_state_set_started(desc);",
            "\treturn ret;",
            "}",
            "int irq_startup(struct irq_desc *desc, bool resend, bool force)",
            "{",
            "\tstruct irq_data *d = irq_desc_get_irq_data(desc);",
            "\tconst struct cpumask *aff = irq_data_get_affinity_mask(d);",
            "\tint ret = 0;",
            "",
            "\tdesc->depth = 0;",
            "",
            "\tif (irqd_is_started(d)) {",
            "\t\tirq_enable(desc);",
            "\t} else {",
            "\t\tswitch (__irq_startup_managed(desc, aff, force)) {",
            "\t\tcase IRQ_STARTUP_NORMAL:",
            "\t\t\tif (d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP)",
            "\t\t\t\tirq_setup_affinity(desc);",
            "\t\t\tret = __irq_startup(desc);",
            "\t\t\tif (!(d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP))",
            "\t\t\t\tirq_setup_affinity(desc);",
            "\t\t\tbreak;",
            "\t\tcase IRQ_STARTUP_MANAGED:",
            "\t\t\tirq_do_set_affinity(d, aff, false);",
            "\t\t\tret = __irq_startup(desc);",
            "\t\t\tbreak;",
            "\t\tcase IRQ_STARTUP_ABORT:",
            "\t\t\tirqd_set_managed_shutdown(d);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "\tif (resend)",
            "\t\tcheck_irq_resend(desc, false);",
            "",
            "\treturn ret;",
            "}",
            "int irq_activate(struct irq_desc *desc)",
            "{",
            "\tstruct irq_data *d = irq_desc_get_irq_data(desc);",
            "",
            "\tif (!irqd_affinity_is_managed(d))",
            "\t\treturn irq_domain_activate_irq(d, false);",
            "\treturn 0;",
            "}",
            "int irq_activate_and_startup(struct irq_desc *desc, bool resend)",
            "{",
            "\tif (WARN_ON(irq_activate(desc)))",
            "\t\treturn 0;",
            "\treturn irq_startup(desc, resend, IRQ_START_FORCE);",
            "}",
            "void irq_shutdown(struct irq_desc *desc)",
            "{",
            "\tif (irqd_is_started(&desc->irq_data)) {",
            "\t\tclear_irq_resend(desc);",
            "\t\tdesc->depth = 1;",
            "\t\tif (desc->irq_data.chip->irq_shutdown) {",
            "\t\t\tdesc->irq_data.chip->irq_shutdown(&desc->irq_data);",
            "\t\t\tirq_state_set_disabled(desc);",
            "\t\t\tirq_state_set_masked(desc);",
            "\t\t} else {",
            "\t\t\t__irq_disable(desc, true);",
            "\t\t}",
            "\t\tirq_state_clr_started(desc);",
            "\t}",
            "}",
            "void irq_shutdown_and_deactivate(struct irq_desc *desc)",
            "{",
            "\tirq_shutdown(desc);",
            "\t/*",
            "\t * This must be called even if the interrupt was never started up,",
            "\t * because the activation can happen before the interrupt is",
            "\t * available for request/startup. It has it's own state tracking so",
            "\t * it's safe to call it unconditionally.",
            "\t */",
            "\tirq_domain_deactivate_irq(&desc->irq_data);",
            "}",
            "void irq_enable(struct irq_desc *desc)",
            "{",
            "\tif (!irqd_irq_disabled(&desc->irq_data)) {",
            "\t\tunmask_irq(desc);",
            "\t} else {",
            "\t\tirq_state_clr_disabled(desc);",
            "\t\tif (desc->irq_data.chip->irq_enable) {",
            "\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);",
            "\t\t\tirq_state_clr_masked(desc);",
            "\t\t} else {",
            "\t\t\tunmask_irq(desc);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "__irq_startup_managed, __irq_startup, irq_startup, irq_activate, irq_activate_and_startup, irq_shutdown, irq_shutdown_and_deactivate, irq_enable",
          "description": "实现中断启动逻辑，包含管理型中断特殊处理流程，负责中断激活、启动及状态管理",
          "similarity": 0.6740182042121887
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/chip.c",
          "start_line": 22,
          "end_line": 148,
          "content": [
            "static irqreturn_t bad_chained_irq(int irq, void *dev_id)",
            "{",
            "\tWARN_ONCE(1, \"Chained irq %d should not call an action\\n\", irq);",
            "\treturn IRQ_NONE;",
            "}",
            "int irq_set_chip(unsigned int irq, const struct irq_chip *chip)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "",
            "\tdesc->irq_data.chip = (struct irq_chip *)(chip ?: &no_irq_chip);",
            "\tirq_put_desc_unlock(desc, flags);",
            "\t/*",
            "\t * For !CONFIG_SPARSE_IRQ make the irq show up in",
            "\t * allocated_irqs.",
            "\t */",
            "\tirq_mark_irq(irq);",
            "\treturn 0;",
            "}",
            "int irq_set_irq_type(unsigned int irq, unsigned int type)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);",
            "\tint ret = 0;",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "",
            "\tret = __irq_set_trigger(desc, type);",
            "\tirq_put_desc_busunlock(desc, flags);",
            "\treturn ret;",
            "}",
            "int irq_set_handler_data(unsigned int irq, void *data)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "\tdesc->irq_common_data.handler_data = data;",
            "\tirq_put_desc_unlock(desc, flags);",
            "\treturn 0;",
            "}",
            "int irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,",
            "\t\t\t struct msi_desc *entry)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_lock(irq_base + irq_offset, &flags, IRQ_GET_DESC_CHECK_GLOBAL);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "\tdesc->irq_common_data.msi_desc = entry;",
            "\tif (entry && !irq_offset)",
            "\t\tentry->irq = irq_base;",
            "\tirq_put_desc_unlock(desc, flags);",
            "\treturn 0;",
            "}",
            "int irq_set_msi_desc(unsigned int irq, struct msi_desc *entry)",
            "{",
            "\treturn irq_set_msi_desc_off(irq, 0, entry);",
            "}",
            "int irq_set_chip_data(unsigned int irq, void *data)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "\tdesc->irq_data.chip_data = data;",
            "\tirq_put_desc_unlock(desc, flags);",
            "\treturn 0;",
            "}",
            "static void irq_state_clr_disabled(struct irq_desc *desc)",
            "{",
            "\tirqd_clear(&desc->irq_data, IRQD_IRQ_DISABLED);",
            "}",
            "static void irq_state_clr_masked(struct irq_desc *desc)",
            "{",
            "\tirqd_clear(&desc->irq_data, IRQD_IRQ_MASKED);",
            "}",
            "static void irq_state_clr_started(struct irq_desc *desc)",
            "{",
            "\tirqd_clear(&desc->irq_data, IRQD_IRQ_STARTED);",
            "}",
            "static void irq_state_set_started(struct irq_desc *desc)",
            "{",
            "\tirqd_set(&desc->irq_data, IRQD_IRQ_STARTED);",
            "}",
            "static int",
            "__irq_startup_managed(struct irq_desc *desc, const struct cpumask *aff,",
            "\t\t      bool force)",
            "{",
            "\tstruct irq_data *d = irq_desc_get_irq_data(desc);",
            "",
            "\tif (!irqd_affinity_is_managed(d))",
            "\t\treturn IRQ_STARTUP_NORMAL;",
            "",
            "\tirqd_clr_managed_shutdown(d);",
            "",
            "\tif (cpumask_any_and(aff, cpu_online_mask) >= nr_cpu_ids) {",
            "\t\t/*",
            "\t\t * Catch code which fiddles with enable_irq() on a managed",
            "\t\t * and potentially shutdown IRQ. Chained interrupt",
            "\t\t * installment or irq auto probing should not happen on",
            "\t\t * managed irqs either.",
            "\t\t */",
            "\t\tif (WARN_ON_ONCE(force))",
            "\t\t\treturn IRQ_STARTUP_ABORT;",
            "\t\t/*",
            "\t\t * The interrupt was requested, but there is no online CPU",
            "\t\t * in it's affinity mask. Put it into managed shutdown",
            "\t\t * state and let the cpu hotplug mechanism start it up once",
            "\t\t * a CPU in the mask becomes available.",
            "\t\t */",
            "\t\treturn IRQ_STARTUP_ABORT;",
            "\t}",
            "\t/*",
            "\t * Managed interrupts have reserved resources, so this should not",
            "\t * happen.",
            "\t */",
            "\tif (WARN_ON(irq_domain_activate_irq(d, false)))",
            "\t\treturn IRQ_STARTUP_ABORT;",
            "\treturn IRQ_STARTUP_MANAGED;",
            "}"
          ],
          "function_name": "bad_chained_irq, irq_set_chip, irq_set_irq_type, irq_set_handler_data, irq_set_msi_desc_off, irq_set_msi_desc, irq_set_chip_data, irq_state_clr_disabled, irq_state_clr_masked, irq_state_clr_started, irq_state_set_started, __irq_startup_managed",
          "description": "实现中断芯片配置接口，包括设置中断芯片、触发类型、MSI描述符等，包含链式中断错误处理函数",
          "similarity": 0.598969578742981
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/chip.c",
          "start_line": 495,
          "end_line": 610,
          "content": [
            "static bool irq_check_poll(struct irq_desc *desc)",
            "{",
            "\tif (!(desc->istate & IRQS_POLL_INPROGRESS))",
            "\t\treturn false;",
            "\treturn irq_wait_for_poll(desc);",
            "}",
            "static bool irq_may_run(struct irq_desc *desc)",
            "{",
            "\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;",
            "",
            "\t/*",
            "\t * If the interrupt is not in progress and is not an armed",
            "\t * wakeup interrupt, proceed.",
            "\t */",
            "\tif (!irqd_has_set(&desc->irq_data, mask))",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * If the interrupt is an armed wakeup source, mark it pending",
            "\t * and suspended, disable it and notify the pm core about the",
            "\t * event.",
            "\t */",
            "\tif (irq_pm_check_wakeup(desc))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Handle a potential concurrent poll on a different core.",
            "\t */",
            "\treturn irq_check_poll(desc);",
            "}",
            "void handle_simple_irq(struct irq_desc *desc)",
            "{",
            "\traw_spin_lock(&desc->lock);",
            "",
            "\tif (!irq_may_run(desc))",
            "\t\tgoto out_unlock;",
            "",
            "\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);",
            "",
            "\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {",
            "\t\tdesc->istate |= IRQS_PENDING;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tkstat_incr_irqs_this_cpu(desc);",
            "\thandle_irq_event(desc);",
            "",
            "out_unlock:",
            "\traw_spin_unlock(&desc->lock);",
            "}",
            "void handle_untracked_irq(struct irq_desc *desc)",
            "{",
            "\traw_spin_lock(&desc->lock);",
            "",
            "\tif (!irq_may_run(desc))",
            "\t\tgoto out_unlock;",
            "",
            "\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);",
            "",
            "\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {",
            "\t\tdesc->istate |= IRQS_PENDING;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tdesc->istate &= ~IRQS_PENDING;",
            "\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);",
            "\traw_spin_unlock(&desc->lock);",
            "",
            "\t__handle_irq_event_percpu(desc);",
            "",
            "\traw_spin_lock(&desc->lock);",
            "\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);",
            "",
            "out_unlock:",
            "\traw_spin_unlock(&desc->lock);",
            "}",
            "static void cond_unmask_irq(struct irq_desc *desc)",
            "{",
            "\t/*",
            "\t * We need to unmask in the following cases:",
            "\t * - Standard level irq (IRQF_ONESHOT is not set)",
            "\t * - Oneshot irq which did not wake the thread (caused by a",
            "\t *   spurious interrupt or a primary handler handling it",
            "\t *   completely).",
            "\t */",
            "\tif (!irqd_irq_disabled(&desc->irq_data) &&",
            "\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)",
            "\t\tunmask_irq(desc);",
            "}",
            "void handle_level_irq(struct irq_desc *desc)",
            "{",
            "\traw_spin_lock(&desc->lock);",
            "\tmask_ack_irq(desc);",
            "",
            "\tif (!irq_may_run(desc))",
            "\t\tgoto out_unlock;",
            "",
            "\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);",
            "",
            "\t/*",
            "\t * If its disabled or no action available",
            "\t * keep it masked and get out of here",
            "\t */",
            "\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {",
            "\t\tdesc->istate |= IRQS_PENDING;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tkstat_incr_irqs_this_cpu(desc);",
            "\thandle_irq_event(desc);",
            "",
            "\tcond_unmask_irq(desc);",
            "",
            "out_unlock:",
            "\traw_spin_unlock(&desc->lock);",
            "}"
          ],
          "function_name": "irq_check_poll, irq_may_run, handle_simple_irq, handle_untracked_irq, cond_unmask_irq, handle_level_irq",
          "description": "实现中断处理流程控制，包含轮询检查、中断可执行性判断及不同类型中断（简单/层级）的处理逻辑",
          "similarity": 0.5821280479431152
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/irq/chip.c",
          "start_line": 984,
          "end_line": 1090,
          "content": [
            "static void",
            "__irq_do_set_handler(struct irq_desc *desc, irq_flow_handler_t handle,",
            "\t\t     int is_chained, const char *name)",
            "{",
            "\tif (!handle) {",
            "\t\thandle = handle_bad_irq;",
            "\t} else {",
            "\t\tstruct irq_data *irq_data = &desc->irq_data;",
            "#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY",
            "\t\t/*",
            "\t\t * With hierarchical domains we might run into a",
            "\t\t * situation where the outermost chip is not yet set",
            "\t\t * up, but the inner chips are there.  Instead of",
            "\t\t * bailing we install the handler, but obviously we",
            "\t\t * cannot enable/startup the interrupt at this point.",
            "\t\t */",
            "\t\twhile (irq_data) {",
            "\t\t\tif (irq_data->chip != &no_irq_chip)",
            "\t\t\t\tbreak;",
            "\t\t\t/*",
            "\t\t\t * Bail out if the outer chip is not set up",
            "\t\t\t * and the interrupt supposed to be started",
            "\t\t\t * right away.",
            "\t\t\t */",
            "\t\t\tif (WARN_ON(is_chained))",
            "\t\t\t\treturn;",
            "\t\t\t/* Try the parent */",
            "\t\t\tirq_data = irq_data->parent_data;",
            "\t\t}",
            "#endif",
            "\t\tif (WARN_ON(!irq_data || irq_data->chip == &no_irq_chip))",
            "\t\t\treturn;",
            "\t}",
            "",
            "\t/* Uninstall? */",
            "\tif (handle == handle_bad_irq) {",
            "\t\tif (desc->irq_data.chip != &no_irq_chip)",
            "\t\t\tmask_ack_irq(desc);",
            "\t\tirq_state_set_disabled(desc);",
            "\t\tif (is_chained) {",
            "\t\t\tdesc->action = NULL;",
            "\t\t\tWARN_ON(irq_chip_pm_put(irq_desc_get_irq_data(desc)));",
            "\t\t}",
            "\t\tdesc->depth = 1;",
            "\t}",
            "\tdesc->handle_irq = handle;",
            "\tdesc->name = name;",
            "",
            "\tif (handle != handle_bad_irq && is_chained) {",
            "\t\tunsigned int type = irqd_get_trigger_type(&desc->irq_data);",
            "",
            "\t\t/*",
            "\t\t * We're about to start this interrupt immediately,",
            "\t\t * hence the need to set the trigger configuration.",
            "\t\t * But the .set_type callback may have overridden the",
            "\t\t * flow handler, ignoring that we're dealing with a",
            "\t\t * chained interrupt. Reset it immediately because we",
            "\t\t * do know better.",
            "\t\t */",
            "\t\tif (type != IRQ_TYPE_NONE) {",
            "\t\t\t__irq_set_trigger(desc, type);",
            "\t\t\tdesc->handle_irq = handle;",
            "\t\t}",
            "",
            "\t\tirq_settings_set_noprobe(desc);",
            "\t\tirq_settings_set_norequest(desc);",
            "\t\tirq_settings_set_nothread(desc);",
            "\t\tdesc->action = &chained_action;",
            "\t\tWARN_ON(irq_chip_pm_get(irq_desc_get_irq_data(desc)));",
            "\t\tirq_activate_and_startup(desc, IRQ_RESEND);",
            "\t}",
            "}",
            "void",
            "__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,",
            "\t\t  const char *name)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);",
            "",
            "\tif (!desc)",
            "\t\treturn;",
            "",
            "\t__irq_do_set_handler(desc, handle, is_chained, name);",
            "\tirq_put_desc_busunlock(desc, flags);",
            "}",
            "void",
            "irq_set_chained_handler_and_data(unsigned int irq, irq_flow_handler_t handle,",
            "\t\t\t\t void *data)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);",
            "",
            "\tif (!desc)",
            "\t\treturn;",
            "",
            "\tdesc->irq_common_data.handler_data = data;",
            "\t__irq_do_set_handler(desc, handle, 1, NULL);",
            "",
            "\tirq_put_desc_busunlock(desc, flags);",
            "}",
            "void",
            "irq_set_chip_and_handler_name(unsigned int irq, const struct irq_chip *chip,",
            "\t\t\t      irq_flow_handler_t handle, const char *name)",
            "{",
            "\tirq_set_chip(irq, chip);",
            "\t__irq_set_handler(irq, handle, 0, name);",
            "}"
          ],
          "function_name": "__irq_do_set_handler, __irq_set_handler, irq_set_chained_handler_and_data, irq_set_chip_and_handler_name",
          "description": "该代码段实现了中断处理程序的动态配置，核心功能是通过多个辅助函数统一管理中断处理逻辑的安装与更新。  \n`__irq_do_set_handler` 核心处理中断处理函数的绑定逻辑，包含对链式中断的特殊处理及触发类型配置，同时协调芯片层级的依赖关系。  \n其他函数（如 `__irq_set_handler` 和 `irq_set_chained_handler_and_data`）作为封装接口，分别用于普通中断和链式中断的处理器设置，通过共享底层逻辑实现功能差异化。",
          "similarity": 0.5672451853752136
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/irq/chip.c",
          "start_line": 1098,
          "end_line": 1219,
          "content": [
            "void irq_modify_status(unsigned int irq, unsigned long clr, unsigned long set)",
            "{",
            "\tunsigned long flags, trigger, tmp;",
            "\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);",
            "",
            "\tif (!desc)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Warn when a driver sets the no autoenable flag on an already",
            "\t * active interrupt.",
            "\t */",
            "\tWARN_ON_ONCE(!desc->depth && (set & _IRQ_NOAUTOEN));",
            "",
            "\tirq_settings_clr_and_set(desc, clr, set);",
            "",
            "\ttrigger = irqd_get_trigger_type(&desc->irq_data);",
            "",
            "\tirqd_clear(&desc->irq_data, IRQD_NO_BALANCING | IRQD_PER_CPU |",
            "\t\t   IRQD_TRIGGER_MASK | IRQD_LEVEL | IRQD_MOVE_PCNTXT);",
            "\tif (irq_settings_has_no_balance_set(desc))",
            "\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);",
            "\tif (irq_settings_is_per_cpu(desc))",
            "\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);",
            "\tif (irq_settings_can_move_pcntxt(desc))",
            "\t\tirqd_set(&desc->irq_data, IRQD_MOVE_PCNTXT);",
            "\tif (irq_settings_is_level(desc))",
            "\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);",
            "",
            "\ttmp = irq_settings_get_trigger_mask(desc);",
            "\tif (tmp != IRQ_TYPE_NONE)",
            "\t\ttrigger = tmp;",
            "",
            "\tirqd_set(&desc->irq_data, trigger);",
            "",
            "\tirq_put_desc_unlock(desc, flags);",
            "}",
            "void irq_cpu_online(void)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tstruct irq_chip *chip;",
            "\tunsigned long flags;",
            "\tunsigned int irq;",
            "",
            "\tfor_each_active_irq(irq) {",
            "\t\tdesc = irq_to_desc(irq);",
            "\t\tif (!desc)",
            "\t\t\tcontinue;",
            "",
            "\t\traw_spin_lock_irqsave(&desc->lock, flags);",
            "",
            "\t\tchip = irq_data_get_irq_chip(&desc->irq_data);",
            "\t\tif (chip && chip->irq_cpu_online &&",
            "\t\t    (!(chip->flags & IRQCHIP_ONOFFLINE_ENABLED) ||",
            "\t\t     !irqd_irq_disabled(&desc->irq_data)))",
            "\t\t\tchip->irq_cpu_online(&desc->irq_data);",
            "",
            "\t\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "\t}",
            "}",
            "void irq_cpu_offline(void)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tstruct irq_chip *chip;",
            "\tunsigned long flags;",
            "\tunsigned int irq;",
            "",
            "\tfor_each_active_irq(irq) {",
            "\t\tdesc = irq_to_desc(irq);",
            "\t\tif (!desc)",
            "\t\t\tcontinue;",
            "",
            "\t\traw_spin_lock_irqsave(&desc->lock, flags);",
            "",
            "\t\tchip = irq_data_get_irq_chip(&desc->irq_data);",
            "\t\tif (chip && chip->irq_cpu_offline &&",
            "\t\t    (!(chip->flags & IRQCHIP_ONOFFLINE_ENABLED) ||",
            "\t\t     !irqd_irq_disabled(&desc->irq_data)))",
            "\t\t\tchip->irq_cpu_offline(&desc->irq_data);",
            "",
            "\t\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "\t}",
            "}",
            "void handle_fasteoi_ack_irq(struct irq_desc *desc)",
            "{",
            "\tstruct irq_chip *chip = desc->irq_data.chip;",
            "",
            "\traw_spin_lock(&desc->lock);",
            "",
            "\tif (!irq_may_run(desc))",
            "\t\tgoto out;",
            "",
            "\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);",
            "",
            "\t/*",
            "\t * If its disabled or no action available",
            "\t * then mask it and get out of here:",
            "\t */",
            "\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {",
            "\t\tdesc->istate |= IRQS_PENDING;",
            "\t\tmask_irq(desc);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tkstat_incr_irqs_this_cpu(desc);",
            "\tif (desc->istate & IRQS_ONESHOT)",
            "\t\tmask_irq(desc);",
            "",
            "\t/* Start handling the irq */",
            "\tdesc->irq_data.chip->irq_ack(&desc->irq_data);",
            "",
            "\thandle_irq_event(desc);",
            "",
            "\tcond_unmask_eoi_irq(desc, chip);",
            "",
            "\traw_spin_unlock(&desc->lock);",
            "\treturn;",
            "out:",
            "\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))",
            "\t\tchip->irq_eoi(&desc->irq_data);",
            "\traw_spin_unlock(&desc->lock);",
            "}"
          ],
          "function_name": "irq_modify_status, irq_cpu_online, irq_cpu_offline, handle_fasteoi_ack_irq",
          "description": "这段代码实现了中断状态管理及CPU状态变更通知机制：  \n1. `irq_modify_status` 修改中断的触发类型、平衡属性等状态标志，用于动态调整中断行为；  \n2. `irq_cpu_online/offline` 遍历所有活跃中断，通过芯片回调处理CPU上线/下线时的中断状态同步；  \n3. `handle_fasteoi_ack_irq` 处理快速EOI中断的ACK逻辑，包含中断屏蔽、事件分发及EOI操作，依赖具体芯片的ACK函数。",
          "similarity": 0.5639967322349548
        }
      ]
    },
    {
      "source_file": "kernel/irq/pm.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:05:54\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\pm.c`\n\n---\n\n# `irq/pm.c` 技术文档\n\n## 1. 文件概述\n\n`irq/pm.c` 是 Linux 内核中断子系统中与电源管理（Power Management, PM）紧密相关的模块。该文件实现了在系统挂起（suspend）和恢复（resume）过程中对中断的特殊处理逻辑，包括：\n\n- 在系统挂起期间禁用非唤醒中断；\n- 识别并配置可作为唤醒源的中断；\n- 在系统恢复阶段正确地重新启用中断；\n- 支持早期恢复（early resume）和强制恢复（force resume）等特殊中断行为。\n\n其核心目标是在保证系统低功耗状态的同时，确保指定的中断能够唤醒系统，并在恢复后正确还原中断状态。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|---------|\n| `irq_pm_check_wakeup()` | 检查中断是否为已武装的唤醒源，若是则执行挂起处理并通知 PM 子系统发生唤醒事件 |\n| `irq_pm_install_action()` | 在注册中断处理函数时，更新描述符中与电源管理相关的计数器（如 `no_suspend_depth`、`force_resume_depth` 等） |\n| `irq_pm_remove_action()` | 在注销中断处理函数时，相应减少电源管理相关计数器 |\n| `suspend_device_irq()` | 对单个中断描述符执行挂起操作：禁用中断、设置 `IRQS_SUSPENDED` 状态，或为唤醒中断做特殊准备 |\n| `suspend_device_irqs()` | 遍历所有中断，调用 `suspend_device_irq()` 执行系统级中断挂起 |\n| `resume_irq()` | 恢复单个中断的状态，包括清除挂起标志、还原启用/禁用状态 |\n| `resume_irqs()` | 遍历中断并根据 `want_early` 参数决定是否仅恢复带 `IRQF_EARLY_RESUME` 标志的中断 |\n| `rearm_wake_irq()` | 重新武装一个唤醒中断（通常在唤醒事件被处理后调用，以便再次唤醒） |\n| `irq_pm_syscore_resume()` | 作为 syscore 回调，在系统早期恢复阶段启用 `IRQF_EARLY_RESUME` 中断 |\n| `resume_device_irqs()` | 恢复所有非早期中断（即未设置 `IRQF_EARLY_RESUME` 的中断） |\n\n### 关键数据结构字段（位于 `struct irq_desc`）\n\n- `nr_actions`：当前注册的中断处理函数数量\n- `no_suspend_depth`：标记为 `IRQF_NO_SUSPEND` 的处理函数数量（不可挂起）\n- `cond_suspend_depth`：标记为 `IRQF_COND_SUSPEND` 的处理函数数量\n- `force_resume_depth`：标记为 `IRQF_FORCE_RESUME` 的处理函数数量（强制恢复）\n- `istate`：中断状态位，包含 `IRQS_SUSPENDED` 和 `IRQS_PENDING` 等标志\n\n### 全局变量\n\n- `irq_pm_syscore_ops`：注册到 syscore 框架的恢复操作集，用于早期中断恢复\n\n## 3. 关键实现\n\n### 中断挂起逻辑（`suspend_device_irqs`）\n\n1. 遍历所有中断描述符；\n2. 跳过嵌套线程中断（`IRQF_ONESHOT` 相关）；\n3. 对每个中断加锁后调用 `suspend_device_irq()`；\n4. 若该函数返回 `true`（通常是因为是唤醒中断），则调用 `synchronize_irq()` 确保状态变更全局可见。\n\n### 唤醒中断处理\n\n- 若中断设置了 `IRQD_WAKEUP_SET`（通过 `irq_set_irq_wake()`），则：\n  - 设置 `IRQD_WAKEUP_ARMED` 标志；\n  - 若中断当前被禁用且 irqchip 支持 `IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND`，则临时启用中断（设置 `IRQD_IRQ_ENABLED_ON_SUSPEND`）；\n  - 返回 `true` 触发 `synchronize_irq()`，确保唤醒路径安全。\n\n### 中断恢复策略\n\n- **早期恢复**：通过 `syscore_ops` 在系统恢复早期阶段启用带 `IRQF_EARLY_RESUME` 的中断（如控制台、调试串口）；\n- **常规恢复**：在 `resume_device_irqs()` 中恢复其余中断；\n- **强制恢复**：即使中断未被挂起（如因 `IRQF_NO_SUSPEND`），若存在 `IRQF_FORCE_RESUME` 处理函数，仍会模拟“挂起-恢复”流程以确保状态一致。\n\n### 状态一致性保障\n\n- 使用 `desc->lock` 保护所有状态变更；\n- 通过 `synchronize_irq()` 确保 `IRQD_WAKEUP_ARMED` 对中断处理路径可见；\n- 利用 `istate` 中的 `IRQS_SUSPENDED` 标志跟踪中断是否处于挂起状态。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`、`<linux/interrupt.h>`：中断核心 API\n  - `<linux/suspend.h>`：电源管理挂起/恢复接口\n  - `<linux/syscore_ops.h>`：系统核心操作注册机制\n  - `\"internals.h\"`：中断子系统内部实现细节\n\n- **与其他子系统交互**：\n  - **PM Core**：通过 `pm_system_irq_wakeup()` 通知唤醒事件；\n  - **IRQ Core**：依赖 `__enable_irq()`、`__disable_irq()`、`mask_irq()` 等底层操作；\n  - **Syscore Framework**：注册早期恢复回调，确保关键中断在设备驱动恢复前可用。\n\n- **编译依赖**：作为 `GENERIC_IRQ_PM` 功能的一部分，通常在支持通用中断和电源管理的架构中启用。\n\n## 5. 使用场景\n\n1. **系统挂起（Suspend-to-RAM / Hibernate）**：\n   - 调用 `suspend_device_irqs()` 禁用非唤醒中断；\n   - 唤醒中断保持可触发状态，触发时调用 `irq_pm_check_wakeup()` 通知 PM 子系统。\n\n2. **系统恢复（Resume）**：\n   - 早期阶段：通过 `syscore_ops` 恢复 `IRQF_EARLY_RESUME` 中断（如串口、定时器）；\n   - 后期阶段：调用 `resume_device_irqs()` 恢复其余中断。\n\n3. **设备驱动注册/注销中断**：\n   - 驱动使用 `IRQF_NO_SUSPEND`、`IRQF_FORCE_RESUME` 等标志时，自动更新中断描述符的电源管理计数器。\n\n4. **重复唤醒支持**：\n   - 在处理完一次唤醒事件后，驱动可调用 `rearm_wake_irq()` 重新武装中断，使其能再次唤醒系统。\n\n该模块是 Linux 电源管理与中断子系统协同工作的关键桥梁，确保系统在低功耗状态下仍能响应关键事件，并在恢复后维持中断状态的一致性。",
      "similarity": 0.621141254901886,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/pm.c",
          "start_line": 16,
          "end_line": 121,
          "content": [
            "bool irq_pm_check_wakeup(struct irq_desc *desc)",
            "{",
            "\tif (irqd_is_wakeup_armed(&desc->irq_data)) {",
            "\t\tirqd_clear(&desc->irq_data, IRQD_WAKEUP_ARMED);",
            "\t\tdesc->istate |= IRQS_SUSPENDED | IRQS_PENDING;",
            "\t\tdesc->depth++;",
            "\t\tirq_disable(desc);",
            "\t\tpm_system_irq_wakeup(irq_desc_get_irq(desc));",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "void irq_pm_install_action(struct irq_desc *desc, struct irqaction *action)",
            "{",
            "\tdesc->nr_actions++;",
            "",
            "\tif (action->flags & IRQF_FORCE_RESUME)",
            "\t\tdesc->force_resume_depth++;",
            "",
            "\tWARN_ON_ONCE(desc->force_resume_depth &&",
            "\t\t     desc->force_resume_depth != desc->nr_actions);",
            "",
            "\tif (action->flags & IRQF_NO_SUSPEND)",
            "\t\tdesc->no_suspend_depth++;",
            "\telse if (action->flags & IRQF_COND_SUSPEND)",
            "\t\tdesc->cond_suspend_depth++;",
            "",
            "\tWARN_ON_ONCE(desc->no_suspend_depth &&",
            "\t\t     (desc->no_suspend_depth +",
            "\t\t\tdesc->cond_suspend_depth) != desc->nr_actions);",
            "}",
            "void irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action)",
            "{",
            "\tdesc->nr_actions--;",
            "",
            "\tif (action->flags & IRQF_FORCE_RESUME)",
            "\t\tdesc->force_resume_depth--;",
            "",
            "\tif (action->flags & IRQF_NO_SUSPEND)",
            "\t\tdesc->no_suspend_depth--;",
            "\telse if (action->flags & IRQF_COND_SUSPEND)",
            "\t\tdesc->cond_suspend_depth--;",
            "}",
            "static bool suspend_device_irq(struct irq_desc *desc)",
            "{",
            "\tunsigned long chipflags = irq_desc_get_chip(desc)->flags;",
            "\tstruct irq_data *irqd = &desc->irq_data;",
            "",
            "\tif (!desc->action || irq_desc_is_chained(desc) ||",
            "\t    desc->no_suspend_depth)",
            "\t\treturn false;",
            "",
            "\tif (irqd_is_wakeup_set(irqd)) {",
            "\t\tirqd_set(irqd, IRQD_WAKEUP_ARMED);",
            "",
            "\t\tif ((chipflags & IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND) &&",
            "\t\t     irqd_irq_disabled(irqd)) {",
            "\t\t\t/*",
            "\t\t\t * Interrupt marked for wakeup is in disabled state.",
            "\t\t\t * Enable interrupt here to unmask/enable in irqchip",
            "\t\t\t * to be able to resume with such interrupts.",
            "\t\t\t */",
            "\t\t\t__enable_irq(desc);",
            "\t\t\tirqd_set(irqd, IRQD_IRQ_ENABLED_ON_SUSPEND);",
            "\t\t}",
            "\t\t/*",
            "\t\t * We return true here to force the caller to issue",
            "\t\t * synchronize_irq(). We need to make sure that the",
            "\t\t * IRQD_WAKEUP_ARMED is visible before we return from",
            "\t\t * suspend_device_irqs().",
            "\t\t */",
            "\t\treturn true;",
            "\t}",
            "",
            "\tdesc->istate |= IRQS_SUSPENDED;",
            "\t__disable_irq(desc);",
            "",
            "\t/*",
            "\t * Hardware which has no wakeup source configuration facility",
            "\t * requires that the non wakeup interrupts are masked at the",
            "\t * chip level. The chip implementation indicates that with",
            "\t * IRQCHIP_MASK_ON_SUSPEND.",
            "\t */",
            "\tif (chipflags & IRQCHIP_MASK_ON_SUSPEND)",
            "\t\tmask_irq(desc);",
            "\treturn true;",
            "}",
            "void suspend_device_irqs(void)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tint irq;",
            "",
            "\tfor_each_irq_desc(irq, desc) {",
            "\t\tunsigned long flags;",
            "\t\tbool sync;",
            "",
            "\t\tif (irq_settings_is_nested_thread(desc))",
            "\t\t\tcontinue;",
            "\t\traw_spin_lock_irqsave(&desc->lock, flags);",
            "\t\tsync = suspend_device_irq(desc);",
            "\t\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "",
            "\t\tif (sync)",
            "\t\t\tsynchronize_irq(irq);",
            "\t}",
            "}"
          ],
          "function_name": "irq_pm_check_wakeup, irq_pm_install_action, irq_pm_remove_action, suspend_device_irq, suspend_device_irqs",
          "description": "实现中断电源管理关键逻辑，包含检测唤醒中断、维护中断动作标记、挂起设备中断及同步机制，用于系统休眠时中断状态管理",
          "similarity": 0.6486517190933228
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/pm.c",
          "start_line": 151,
          "end_line": 233,
          "content": [
            "static void resume_irq(struct irq_desc *desc)",
            "{",
            "\tstruct irq_data *irqd = &desc->irq_data;",
            "",
            "\tirqd_clear(irqd, IRQD_WAKEUP_ARMED);",
            "",
            "\tif (irqd_is_enabled_on_suspend(irqd)) {",
            "\t\t/*",
            "\t\t * Interrupt marked for wakeup was enabled during suspend",
            "\t\t * entry. Disable such interrupts to restore them back to",
            "\t\t * original state.",
            "\t\t */",
            "\t\t__disable_irq(desc);",
            "\t\tirqd_clear(irqd, IRQD_IRQ_ENABLED_ON_SUSPEND);",
            "\t}",
            "",
            "\tif (desc->istate & IRQS_SUSPENDED)",
            "\t\tgoto resume;",
            "",
            "\t/* Force resume the interrupt? */",
            "\tif (!desc->force_resume_depth)",
            "\t\treturn;",
            "",
            "\t/* Pretend that it got disabled ! */",
            "\tdesc->depth++;",
            "\tirq_state_set_disabled(desc);",
            "\tirq_state_set_masked(desc);",
            "resume:",
            "\tdesc->istate &= ~IRQS_SUSPENDED;",
            "\t__enable_irq(desc);",
            "}",
            "static void resume_irqs(bool want_early)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tint irq;",
            "",
            "\tfor_each_irq_desc(irq, desc) {",
            "\t\tunsigned long flags;",
            "\t\tbool is_early = desc->action &&",
            "\t\t\tdesc->action->flags & IRQF_EARLY_RESUME;",
            "",
            "\t\tif (!is_early && want_early)",
            "\t\t\tcontinue;",
            "\t\tif (irq_settings_is_nested_thread(desc))",
            "\t\t\tcontinue;",
            "",
            "\t\traw_spin_lock_irqsave(&desc->lock, flags);",
            "\t\tresume_irq(desc);",
            "\t\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "\t}",
            "}",
            "void rearm_wake_irq(unsigned int irq)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);",
            "",
            "\tif (!desc)",
            "\t\treturn;",
            "",
            "\tif (!(desc->istate & IRQS_SUSPENDED) ||",
            "\t    !irqd_is_wakeup_set(&desc->irq_data))",
            "\t\tgoto unlock;",
            "",
            "\tdesc->istate &= ~IRQS_SUSPENDED;",
            "\tirqd_set(&desc->irq_data, IRQD_WAKEUP_ARMED);",
            "\t__enable_irq(desc);",
            "",
            "unlock:",
            "\tirq_put_desc_busunlock(desc, flags);",
            "}",
            "static void irq_pm_syscore_resume(void)",
            "{",
            "\tresume_irqs(true);",
            "}",
            "static int __init irq_pm_init_ops(void)",
            "{",
            "\tregister_syscore_ops(&irq_pm_syscore_ops);",
            "\treturn 0;",
            "}",
            "void resume_device_irqs(void)",
            "{",
            "\tresume_irqs(false);",
            "}"
          ],
          "function_name": "resume_irq, resume_irqs, rearm_wake_irq, irq_pm_syscore_resume, irq_pm_init_ops, resume_device_irqs",
          "description": "实现中断恢复逻辑，包含中断恢复、分阶段恢复控制、唤醒中断重置及系统核心操作注册，用于系统唤醒后中断状态重建",
          "similarity": 0.5940451622009277
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/pm.c",
          "start_line": 1,
          "end_line": 15,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2009 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.",
            " *",
            " * This file contains power management functions related to interrupts.",
            " */",
            "",
            "#include <linux/irq.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/suspend.h>",
            "#include <linux/syscore_ops.h>",
            "",
            "#include \"internals.h\"",
            ""
          ],
          "function_name": null,
          "description": "此代码块为中断电源管理模块提供基础头文件声明，包含许可证信息、核心头文件及内部实现头文件，但未包含实际实现代码，上下文不完整",
          "similarity": 0.5289040803909302
        }
      ]
    }
  ]
}