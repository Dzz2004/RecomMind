{
  "query": "page replacement policy",
  "timestamp": "2025-12-25 23:39:20",
  "retrieved_files": [
    {
      "source_file": "mm/page_io.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:03:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page_io.c`\n\n---\n\n# page_io.c 技术文档\n\n## 1. 文件概述\n\n`page_io.c` 是 Linux 内核内存管理子系统中负责页面交换 I/O 操作的核心文件。该文件实现了将匿名页写入交换设备（swap-out）和从交换设备读回内存（swap-in）的底层机制，包括基于 `bio` 的块设备交换路径和基于文件系统的直接 I/O 交换路径。此外，还提供了通用的交换文件激活逻辑，用于在启用交换文件时构建物理块到交换页的映射。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `__end_swap_bio_write()` / `end_swap_bio_write()`：处理交换写操作完成的回调，处理写错误并结束写回。\n- `__end_swap_bio_read()` / `end_swap_bio_read()`：处理交换读操作完成的回调，设置页面 uptodate 状态或报告读错误。\n- `generic_swapfile_activate()`：为基于文件的交换设备（如 swapfile）构建连续的物理块映射，填充 `swap_info_struct`。\n- `swap_writepage()`：页面写回交换区的主入口函数，支持 zswap 压缩缓存、内存控制组限制等特性。\n- `swap_writepage_fs()`：通过文件系统直接 I/O 路径（如 swap-over-NFS）执行交换写操作。\n- `sio_pool_init()`：初始化用于异步交换 I/O 的内存池。\n- `sio_write_complete()`：处理基于 kiocb 的异步交换写完成回调。\n\n### 关键数据结构\n\n- `struct swap_iocb`：封装用于文件系统交换 I/O 的 `kiocb` 和 `bio_vec` 数组，支持批量交换页写入。\n- `sio_pool`：`mempool_t` 类型的内存池，用于分配 `swap_iocb` 结构，避免高内存压力下分配失败。\n\n## 3. 关键实现\n\n### 交换 I/O 完成处理\n- 写操作失败时，页面被重新标记为 dirty 并清除 `PG_reclaim` 标志，防止被错误回收，同时输出限频警告日志。\n- 读操作失败仅输出警告；成功则设置 `PG_uptodate` 并解锁页面。\n\n### 交换文件激活 (`generic_swapfile_activate`)\n- 遍历交换文件的逻辑块，使用 `bmap()` 获取物理块号。\n- 验证每个 PAGE_SIZE 对齐区域的物理块是否连续且对齐。\n- 通过 `add_swap_extent()` 将有效的交换页范围注册到交换子系统。\n- 计算交换空间的物理跨度（`span`），用于优化交换分配策略。\n\n### 交换写入路径选择\n- 默认使用 `__swap_writepage()`（基于 `bio` 的块设备路径）。\n- 若启用了 zswap 且压缩存储成功，则跳过磁盘 I/O。\n- 若内存控制组禁用 zswap 回写，则返回 `AOP_WRITEPAGE_ACTIVATE` 以保留页面在内存中。\n- 对于 NFS 等不支持 `bmap` 的文件系统，使用 `swap_writepage_fs()` 路径，通过 `kiocb` 异步 DIO 写入。\n\n### 异步交换 I/O 批处理\n- `swap_writepage_fs()` 支持通过 `wbc->swap_plug` 合并多个相邻页面的写请求到同一个 `swap_iocb`。\n- 利用 `mempool` 保证在内存紧张时仍能分配 I/O 控制块。\n- 完成回调中处理部分写入错误，标记所有相关页面为 dirty 并结束写回。\n\n### 资源统计与控制\n- 通过 `count_swpout_vm_event()` 更新透明大页（THP）和普通页的交换出计数。\n- 在配置了 MEMCG 和 BLK_CGROUP 时，通过 `bio_associate_blkg_from_page()` 将 I/O 请求关联到页面所属的 blkcg，实现 I/O 资源隔离。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/swap.h>`、`<linux/pagemap.h>` 等，与页面回收、反向映射、内存控制组紧密集成。\n- **块设备层**：通过 `<linux/bio.h>`、`<linux/blkdev.h>` 与块 I/O 子系统交互。\n- **文件系统接口**：使用 `bmap()` 和 `kiocb` 与具体文件系统（如 ext4、xfs）或网络文件系统（如 NFS）协作。\n- **压缩子系统**：集成 `<linux/zswap.h>`，支持透明压缩交换缓存。\n- **资源控制器**：依赖 MEMCG 和 BLK_CGROUP 实现内存与 I/O 的多租户隔离。\n- **内部头文件**：包含本地 `\"swap.h\"` 获取交换子系统私有接口。\n\n## 5. 使用场景\n\n- **系统内存不足时**：页面回收机制调用 `swap_writepage()` 将匿名页换出到交换设备。\n- **启用交换文件时**：`swapon` 系统调用执行 `generic_swapfile_activate()` 初始化交换文件的物理布局。\n- **从交换区缺页中断**：当访问已换出页面时，内核通过 `end_swap_bio_read` 路径将数据读回内存。\n- **容器环境**：在启用内存和 I/O 控制组的系统中，确保交换 I/O 正确归属到对应 cgroup。\n- **使用压缩交换缓存**：当 zswap 启用时，优先尝试压缩页面而非立即写入慢速交换设备。\n- **网络交换场景**：在无本地块设备的环境中（如云实例使用 NFS 作为交换后端），通过 `swap_writepage_fs()` 路径完成交换。",
      "similarity": 0.5029632449150085,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/page_io.c",
          "start_line": 179,
          "end_line": 280,
          "content": [
            "int swap_writepage(struct page *page, struct writeback_control *wbc)",
            "{",
            "\tstruct folio *folio = page_folio(page);",
            "\tint ret;",
            "",
            "\tif (folio_free_swap(folio)) {",
            "\t\tfolio_unlock(folio);",
            "\t\treturn 0;",
            "\t}",
            "\t/*",
            "\t * Arch code may have to preserve more data than just the page",
            "\t * contents, e.g. memory tags.",
            "\t */",
            "\tret = arch_prepare_to_swap(folio);",
            "\tif (ret) {",
            "\t\tfolio_mark_dirty(folio);",
            "\t\tfolio_unlock(folio);",
            "\t\treturn ret;",
            "\t}",
            "\tif (zswap_store(folio)) {",
            "\t\tfolio_start_writeback(folio);",
            "\t\tfolio_unlock(folio);",
            "\t\tfolio_end_writeback(folio);",
            "\t\treturn 0;",
            "\t}",
            "\tif (!mem_cgroup_zswap_writeback_enabled(folio_memcg(folio))) {",
            "\t\tfolio_mark_dirty(folio);",
            "\t\treturn AOP_WRITEPAGE_ACTIVATE;",
            "\t}",
            "",
            "\t__swap_writepage(folio, wbc);",
            "\treturn 0;",
            "}",
            "static inline void count_swpout_vm_event(struct folio *folio)",
            "{",
            "#ifdef CONFIG_TRANSPARENT_HUGEPAGE",
            "\tif (unlikely(folio_test_pmd_mappable(folio))) {",
            "\t\tcount_memcg_folio_events(folio, THP_SWPOUT, 1);",
            "\t\tcount_vm_event(THP_SWPOUT);",
            "\t}",
            "\tcount_mthp_stat(folio_order(folio), MTHP_STAT_SWPOUT);",
            "#endif",
            "\tcount_memcg_folio_events(folio, PSWPOUT, folio_nr_pages(folio));",
            "\tcount_vm_events(PSWPOUT, folio_nr_pages(folio));",
            "}",
            "static void bio_associate_blkg_from_page(struct bio *bio, struct folio *folio)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct mem_cgroup *memcg;",
            "",
            "\tmemcg = folio_memcg(folio);",
            "\tif (!memcg)",
            "\t\treturn;",
            "",
            "\trcu_read_lock();",
            "\tcss = cgroup_e_css(memcg->css.cgroup, &io_cgrp_subsys);",
            "\tbio_associate_blkg_from_css(bio, css);",
            "\trcu_read_unlock();",
            "}",
            "int sio_pool_init(void)",
            "{",
            "\tif (!sio_pool) {",
            "\t\tmempool_t *pool = mempool_create_kmalloc_pool(",
            "\t\t\tSWAP_CLUSTER_MAX, sizeof(struct swap_iocb));",
            "\t\tif (cmpxchg(&sio_pool, NULL, pool))",
            "\t\t\tmempool_destroy(pool);",
            "\t}",
            "\tif (!sio_pool)",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "static void sio_write_complete(struct kiocb *iocb, long ret)",
            "{",
            "\tstruct swap_iocb *sio = container_of(iocb, struct swap_iocb, iocb);",
            "\tstruct page *page = sio->bvec[0].bv_page;",
            "\tint p;",
            "",
            "\tif (ret != sio->len) {",
            "\t\t/*",
            "\t\t * In the case of swap-over-nfs, this can be a",
            "\t\t * temporary failure if the system has limited",
            "\t\t * memory for allocating transmit buffers.",
            "\t\t * Mark the page dirty and avoid",
            "\t\t * folio_rotate_reclaimable but rate-limit the",
            "\t\t * messages but do not flag PageError like",
            "\t\t * the normal direct-to-bio case as it could",
            "\t\t * be temporary.",
            "\t\t */",
            "\t\tpr_err_ratelimited(\"Write error %ld on dio swapfile (%llu)\\n\",",
            "\t\t\t\t   ret, page_file_offset(page));",
            "\t\tfor (p = 0; p < sio->pages; p++) {",
            "\t\t\tpage = sio->bvec[p].bv_page;",
            "\t\t\tset_page_dirty(page);",
            "\t\t\tClearPageReclaim(page);",
            "\t\t}",
            "\t}",
            "",
            "\tfor (p = 0; p < sio->pages; p++)",
            "\t\tend_page_writeback(sio->bvec[p].bv_page);",
            "",
            "\tmempool_free(sio, sio_pool);",
            "}"
          ],
          "function_name": "swap_writepage, count_swpout_vm_event, bio_associate_blkg_from_page, sio_pool_init, sio_write_complete",
          "description": "swap_writepage发起页面换出流程，调用架构特定准备函数并处理ZSwap缓存；sio_write_complete处理异步写入完成，标记脏页并释放资源。",
          "similarity": 0.5359393954277039
        },
        {
          "chunk_id": 0,
          "file_path": "mm/page_io.c",
          "start_line": 1,
          "end_line": 29,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  linux/mm/page_io.c",
            " *",
            " *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds",
            " *",
            " *  Swap reorganised 29.12.95, ",
            " *  Asynchronous swapping added 30.12.95. Stephen Tweedie",
            " *  Removed race in async swapping. 14.4.1996. Bruno Haible",
            " *  Add swap of shared pages through the page cache. 20.2.1998. Stephen Tweedie",
            " *  Always use brw_page, life becomes simpler. 12 May 1998 Eric Biederman",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swapops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/psi.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/zswap.h>",
            "#include \"swap.h\"",
            ""
          ],
          "function_name": null,
          "description": "声明头文件并引入交换页面管理模块的基本依赖，为后续交换操作提供基础框架。",
          "similarity": 0.5325504541397095
        },
        {
          "chunk_id": 3,
          "file_path": "mm/page_io.c",
          "start_line": 298,
          "end_line": 400,
          "content": [
            "static void swap_writepage_fs(struct folio *folio, struct writeback_control *wbc)",
            "{",
            "\tstruct swap_iocb *sio = NULL;",
            "\tstruct swap_info_struct *sis = swp_swap_info(folio->swap);",
            "\tstruct file *swap_file = sis->swap_file;",
            "\tloff_t pos = folio_file_pos(folio);",
            "",
            "\tcount_swpout_vm_event(folio);",
            "\tfolio_start_writeback(folio);",
            "\tfolio_unlock(folio);",
            "\tif (wbc->swap_plug)",
            "\t\tsio = *wbc->swap_plug;",
            "\tif (sio) {",
            "\t\tif (sio->iocb.ki_filp != swap_file ||",
            "\t\t    sio->iocb.ki_pos + sio->len != pos) {",
            "\t\t\tswap_write_unplug(sio);",
            "\t\t\tsio = NULL;",
            "\t\t}",
            "\t}",
            "\tif (!sio) {",
            "\t\tsio = mempool_alloc(sio_pool, GFP_NOIO);",
            "\t\tinit_sync_kiocb(&sio->iocb, swap_file);",
            "\t\tsio->iocb.ki_complete = sio_write_complete;",
            "\t\tsio->iocb.ki_pos = pos;",
            "\t\tsio->pages = 0;",
            "\t\tsio->len = 0;",
            "\t}",
            "\tbvec_set_folio(&sio->bvec[sio->pages], folio, folio_size(folio), 0);",
            "\tsio->len += folio_size(folio);",
            "\tsio->pages += 1;",
            "\tif (sio->pages == ARRAY_SIZE(sio->bvec) || !wbc->swap_plug) {",
            "\t\tswap_write_unplug(sio);",
            "\t\tsio = NULL;",
            "\t}",
            "\tif (wbc->swap_plug)",
            "\t\t*wbc->swap_plug = sio;",
            "}",
            "static void swap_writepage_bdev_sync(struct folio *folio,",
            "\t\tstruct writeback_control *wbc, struct swap_info_struct *sis)",
            "{",
            "\tstruct bio_vec bv;",
            "\tstruct bio bio;",
            "",
            "\tbio_init(&bio, sis->bdev, &bv, 1,",
            "\t\t REQ_OP_WRITE | REQ_SWAP | wbc_to_write_flags(wbc));",
            "\tbio.bi_iter.bi_sector = swap_folio_sector(folio);",
            "\tbio_add_folio_nofail(&bio, folio, folio_size(folio), 0);",
            "",
            "\tbio_associate_blkg_from_page(&bio, folio);",
            "\tcount_swpout_vm_event(folio);",
            "",
            "\tfolio_start_writeback(folio);",
            "\tfolio_unlock(folio);",
            "",
            "\tsubmit_bio_wait(&bio);",
            "\t__end_swap_bio_write(&bio);",
            "}",
            "static void swap_writepage_bdev_async(struct folio *folio,",
            "\t\tstruct writeback_control *wbc, struct swap_info_struct *sis)",
            "{",
            "\tstruct bio *bio;",
            "",
            "\tbio = bio_alloc(sis->bdev, 1,",
            "\t\t\tREQ_OP_WRITE | REQ_SWAP | wbc_to_write_flags(wbc),",
            "\t\t\tGFP_NOIO);",
            "\tbio->bi_iter.bi_sector = swap_folio_sector(folio);",
            "\tbio->bi_end_io = end_swap_bio_write;",
            "\tbio_add_folio_nofail(bio, folio, folio_size(folio), 0);",
            "",
            "\tbio_associate_blkg_from_page(bio, folio);",
            "\tcount_swpout_vm_event(folio);",
            "\tfolio_start_writeback(folio);",
            "\tfolio_unlock(folio);",
            "\tsubmit_bio(bio);",
            "}",
            "void __swap_writepage(struct folio *folio, struct writeback_control *wbc)",
            "{",
            "\tstruct swap_info_struct *sis = swp_swap_info(folio->swap);",
            "",
            "\tVM_BUG_ON_FOLIO(!folio_test_swapcache(folio), folio);",
            "\t/*",
            "\t * ->flags can be updated non-atomicially (scan_swap_map_slots),",
            "\t * but that will never affect SWP_FS_OPS, so the data_race",
            "\t * is safe.",
            "\t */",
            "\tif (data_race(sis->flags & SWP_FS_OPS))",
            "\t\tswap_writepage_fs(folio, wbc);",
            "\telse if (sis->flags & SWP_SYNCHRONOUS_IO)",
            "\t\tswap_writepage_bdev_sync(folio, wbc, sis);",
            "\telse",
            "\t\tswap_writepage_bdev_async(folio, wbc, sis);",
            "}",
            "void swap_write_unplug(struct swap_iocb *sio)",
            "{",
            "\tstruct iov_iter from;",
            "\tstruct address_space *mapping = sio->iocb.ki_filp->f_mapping;",
            "\tint ret;",
            "",
            "\tiov_iter_bvec(&from, ITER_SOURCE, sio->bvec, sio->pages, sio->len);",
            "\tret = mapping->a_ops->swap_rw(&sio->iocb, &from);",
            "\tif (ret != -EIOCBQUEUED)",
            "\t\tsio_write_complete(&sio->iocb, ret);",
            "}"
          ],
          "function_name": "swap_writepage_fs, swap_writepage_bdev_sync, swap_writepage_bdev_async, __swap_writepage, swap_write_unplug",
          "description": "__swap_writepage根据配置选择同步/异步块设备写入路径，通过bio结构执行交换页面写入操作，支持批量提交优化。",
          "similarity": 0.5271734595298767
        },
        {
          "chunk_id": 4,
          "file_path": "mm/page_io.c",
          "start_line": 406,
          "end_line": 537,
          "content": [
            "static void sio_read_complete(struct kiocb *iocb, long ret)",
            "{",
            "\tstruct swap_iocb *sio = container_of(iocb, struct swap_iocb, iocb);",
            "\tint p;",
            "",
            "\tif (ret == sio->len) {",
            "\t\tfor (p = 0; p < sio->pages; p++) {",
            "\t\t\tstruct folio *folio = page_folio(sio->bvec[p].bv_page);",
            "",
            "\t\t\tcount_mthp_stat(folio_order(folio), MTHP_STAT_SWPIN);",
            "\t\t\tcount_memcg_folio_events(folio, PSWPIN, folio_nr_pages(folio));",
            "\t\t\tfolio_mark_uptodate(folio);",
            "\t\t\tfolio_unlock(folio);",
            "\t\t}",
            "\t\tcount_vm_events(PSWPIN, sio->pages);",
            "\t} else {",
            "\t\tfor (p = 0; p < sio->pages; p++) {",
            "\t\t\tstruct folio *folio = page_folio(sio->bvec[p].bv_page);",
            "",
            "\t\t\tfolio_unlock(folio);",
            "\t\t}",
            "\t\tpr_alert_ratelimited(\"Read-error on swap-device\\n\");",
            "\t}",
            "\tmempool_free(sio, sio_pool);",
            "}",
            "static void swap_read_folio_fs(struct folio *folio, struct swap_iocb **plug)",
            "{",
            "\tstruct swap_info_struct *sis = swp_swap_info(folio->swap);",
            "\tstruct swap_iocb *sio = NULL;",
            "\tloff_t pos = folio_file_pos(folio);",
            "",
            "\tif (plug)",
            "\t\tsio = *plug;",
            "\tif (sio) {",
            "\t\tif (sio->iocb.ki_filp != sis->swap_file ||",
            "\t\t    sio->iocb.ki_pos + sio->len != pos) {",
            "\t\t\tswap_read_unplug(sio);",
            "\t\t\tsio = NULL;",
            "\t\t}",
            "\t}",
            "\tif (!sio) {",
            "\t\tsio = mempool_alloc(sio_pool, GFP_KERNEL);",
            "\t\tinit_sync_kiocb(&sio->iocb, sis->swap_file);",
            "\t\tsio->iocb.ki_pos = pos;",
            "\t\tsio->iocb.ki_complete = sio_read_complete;",
            "\t\tsio->pages = 0;",
            "\t\tsio->len = 0;",
            "\t}",
            "\tbvec_set_folio(&sio->bvec[sio->pages], folio, folio_size(folio), 0);",
            "\tsio->len += folio_size(folio);",
            "\tsio->pages += 1;",
            "\tif (sio->pages == ARRAY_SIZE(sio->bvec) || !plug) {",
            "\t\tswap_read_unplug(sio);",
            "\t\tsio = NULL;",
            "\t}",
            "\tif (plug)",
            "\t\t*plug = sio;",
            "}",
            "static void swap_read_folio_bdev_sync(struct folio *folio,",
            "\t\tstruct swap_info_struct *sis)",
            "{",
            "\tstruct bio_vec bv;",
            "\tstruct bio bio;",
            "",
            "\tbio_init(&bio, sis->bdev, &bv, 1, REQ_OP_READ);",
            "\tbio.bi_iter.bi_sector = swap_folio_sector(folio);",
            "\tbio_add_folio_nofail(&bio, folio, folio_size(folio), 0);",
            "\t/*",
            "\t * Keep this task valid during swap readpage because the oom killer may",
            "\t * attempt to access it in the page fault retry time check.",
            "\t */",
            "\tget_task_struct(current);",
            "\tcount_mthp_stat(folio_order(folio), MTHP_STAT_SWPIN);",
            "\tcount_memcg_folio_events(folio, PSWPIN, folio_nr_pages(folio));",
            "\tcount_vm_events(PSWPIN, folio_nr_pages(folio));",
            "\tsubmit_bio_wait(&bio);",
            "\t__end_swap_bio_read(&bio);",
            "\tput_task_struct(current);",
            "}",
            "static void swap_read_folio_bdev_async(struct folio *folio,",
            "\t\tstruct swap_info_struct *sis)",
            "{",
            "\tstruct bio *bio;",
            "",
            "\tbio = bio_alloc(sis->bdev, 1, REQ_OP_READ, GFP_KERNEL);",
            "\tbio->bi_iter.bi_sector = swap_folio_sector(folio);",
            "\tbio->bi_end_io = end_swap_bio_read;",
            "\tbio_add_folio_nofail(bio, folio, folio_size(folio), 0);",
            "\tcount_mthp_stat(folio_order(folio), MTHP_STAT_SWPIN);",
            "\tcount_memcg_folio_events(folio, PSWPIN, folio_nr_pages(folio));",
            "\tcount_vm_events(PSWPIN, folio_nr_pages(folio));",
            "\tsubmit_bio(bio);",
            "}",
            "void swap_read_folio(struct folio *folio, struct swap_iocb **plug)",
            "{",
            "\tstruct swap_info_struct *sis = swp_swap_info(folio->swap);",
            "\tbool synchronous = sis->flags & SWP_SYNCHRONOUS_IO;",
            "\tbool workingset = folio_test_workingset(folio);",
            "\tunsigned long pflags;",
            "\tbool in_thrashing;",
            "",
            "\tVM_BUG_ON_FOLIO(!folio_test_swapcache(folio) && !synchronous, folio);",
            "\tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);",
            "\tVM_BUG_ON_FOLIO(folio_test_uptodate(folio), folio);",
            "",
            "\t/*",
            "\t * Count submission time as memory stall and delay. When the device",
            "\t * is congested, or the submitting cgroup IO-throttled, submission",
            "\t * can be a significant part of overall IO time.",
            "\t */",
            "\tif (workingset) {",
            "\t\tdelayacct_thrashing_start(&in_thrashing);",
            "\t\tpsi_memstall_enter(&pflags);",
            "\t}",
            "\tdelayacct_swapin_start();",
            "",
            "\tif (zswap_load(folio)) {",
            "\t\tfolio_unlock(folio);",
            "\t} else if (data_race(sis->flags & SWP_FS_OPS)) {",
            "\t\tswap_read_folio_fs(folio, plug);",
            "\t} else if (synchronous) {",
            "\t\tswap_read_folio_bdev_sync(folio, sis);",
            "\t} else {",
            "\t\tswap_read_folio_bdev_async(folio, sis);",
            "\t}",
            "",
            "\tif (workingset) {",
            "\t\tdelayacct_thrashing_end(&in_thrashing);",
            "\t\tpsi_memstall_leave(&pflags);",
            "\t}",
            "\tdelayacct_swapin_end();",
            "}"
          ],
          "function_name": "sio_read_complete, swap_read_folio_fs, swap_read_folio_bdev_sync, swap_read_folio_bdev_async, swap_read_folio",
          "description": "swap_read_folio启动页面换入流程，根据配置选择文件级或块设备读取路径，处理交换数据加载及状态更新。",
          "similarity": 0.5094250440597534
        },
        {
          "chunk_id": 1,
          "file_path": "mm/page_io.c",
          "start_line": 30,
          "end_line": 169,
          "content": [
            "static void __end_swap_bio_write(struct bio *bio)",
            "{",
            "\tstruct folio *folio = bio_first_folio_all(bio);",
            "",
            "\tif (bio->bi_status) {",
            "\t\t/*",
            "\t\t * We failed to write the page out to swap-space.",
            "\t\t * Re-dirty the page in order to avoid it being reclaimed.",
            "\t\t * Also print a dire warning that things will go BAD (tm)",
            "\t\t * very quickly.",
            "\t\t *",
            "\t\t * Also clear PG_reclaim to avoid folio_rotate_reclaimable()",
            "\t\t */",
            "\t\tfolio_mark_dirty(folio);",
            "\t\tpr_alert_ratelimited(\"Write-error on swap-device (%u:%u:%llu)\\n\",",
            "\t\t\t\t     MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),",
            "\t\t\t\t     (unsigned long long)bio->bi_iter.bi_sector);",
            "\t\tfolio_clear_reclaim(folio);",
            "\t}",
            "\tfolio_end_writeback(folio);",
            "}",
            "static void end_swap_bio_write(struct bio *bio)",
            "{",
            "\t__end_swap_bio_write(bio);",
            "\tbio_put(bio);",
            "}",
            "static void __end_swap_bio_read(struct bio *bio)",
            "{",
            "\tstruct folio *folio = bio_first_folio_all(bio);",
            "",
            "\tif (bio->bi_status) {",
            "\t\tpr_alert_ratelimited(\"Read-error on swap-device (%u:%u:%llu)\\n\",",
            "\t\t\t\t     MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),",
            "\t\t\t\t     (unsigned long long)bio->bi_iter.bi_sector);",
            "\t} else {",
            "\t\tfolio_mark_uptodate(folio);",
            "\t}",
            "\tfolio_unlock(folio);",
            "}",
            "static void end_swap_bio_read(struct bio *bio)",
            "{",
            "\t__end_swap_bio_read(bio);",
            "\tbio_put(bio);",
            "}",
            "int generic_swapfile_activate(struct swap_info_struct *sis,",
            "\t\t\t\tstruct file *swap_file,",
            "\t\t\t\tsector_t *span)",
            "{",
            "\tstruct address_space *mapping = swap_file->f_mapping;",
            "\tstruct inode *inode = mapping->host;",
            "\tunsigned blocks_per_page;",
            "\tunsigned long page_no;",
            "\tunsigned blkbits;",
            "\tsector_t probe_block;",
            "\tsector_t last_block;",
            "\tsector_t lowest_block = -1;",
            "\tsector_t highest_block = 0;",
            "\tint nr_extents = 0;",
            "\tint ret;",
            "",
            "\tblkbits = inode->i_blkbits;",
            "\tblocks_per_page = PAGE_SIZE >> blkbits;",
            "",
            "\t/*",
            "\t * Map all the blocks into the extent tree.  This code doesn't try",
            "\t * to be very smart.",
            "\t */",
            "\tprobe_block = 0;",
            "\tpage_no = 0;",
            "\tlast_block = i_size_read(inode) >> blkbits;",
            "\twhile ((probe_block + blocks_per_page) <= last_block &&",
            "\t\t\tpage_no < sis->max) {",
            "\t\tunsigned block_in_page;",
            "\t\tsector_t first_block;",
            "",
            "\t\tcond_resched();",
            "",
            "\t\tfirst_block = probe_block;",
            "\t\tret = bmap(inode, &first_block);",
            "\t\tif (ret || !first_block)",
            "\t\t\tgoto bad_bmap;",
            "",
            "\t\t/*",
            "\t\t * It must be PAGE_SIZE aligned on-disk",
            "\t\t */",
            "\t\tif (first_block & (blocks_per_page - 1)) {",
            "\t\t\tprobe_block++;",
            "\t\t\tgoto reprobe;",
            "\t\t}",
            "",
            "\t\tfor (block_in_page = 1; block_in_page < blocks_per_page;",
            "\t\t\t\t\tblock_in_page++) {",
            "\t\t\tsector_t block;",
            "",
            "\t\t\tblock = probe_block + block_in_page;",
            "\t\t\tret = bmap(inode, &block);",
            "\t\t\tif (ret || !block)",
            "\t\t\t\tgoto bad_bmap;",
            "",
            "\t\t\tif (block != first_block + block_in_page) {",
            "\t\t\t\t/* Discontiguity */",
            "\t\t\t\tprobe_block++;",
            "\t\t\t\tgoto reprobe;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tfirst_block >>= (PAGE_SHIFT - blkbits);",
            "\t\tif (page_no) {\t/* exclude the header page */",
            "\t\t\tif (first_block < lowest_block)",
            "\t\t\t\tlowest_block = first_block;",
            "\t\t\tif (first_block > highest_block)",
            "\t\t\t\thighest_block = first_block;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * We found a PAGE_SIZE-length, PAGE_SIZE-aligned run of blocks",
            "\t\t */",
            "\t\tret = add_swap_extent(sis, page_no, 1, first_block);",
            "\t\tif (ret < 0)",
            "\t\t\tgoto out;",
            "\t\tnr_extents += ret;",
            "\t\tpage_no++;",
            "\t\tprobe_block += blocks_per_page;",
            "reprobe:",
            "\t\tcontinue;",
            "\t}",
            "\tret = nr_extents;",
            "\t*span = 1 + highest_block - lowest_block;",
            "\tif (page_no == 0)",
            "\t\tpage_no = 1;\t/* force Empty message */",
            "\tsis->max = page_no;",
            "\tsis->pages = page_no - 1;",
            "\tsis->highest_bit = page_no - 1;",
            "out:",
            "\treturn ret;",
            "bad_bmap:",
            "\tpr_err(\"swapon: swapfile has holes\\n\");",
            "\tret = -EINVAL;",
            "\tgoto out;",
            "}"
          ],
          "function_name": "__end_swap_bio_write, end_swap_bio_write, __end_swap_bio_read, end_swap_bio_read, generic_swapfile_activate",
          "description": "实现交换I/O完成回调函数，处理写入错误重标记脏页及读取错误日志；generic_swapfile_activate扫描交换文件块并构建交换区范围。",
          "similarity": 0.48143911361694336
        }
      ]
    },
    {
      "source_file": "mm/page_isolation.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:03:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page_isolation.c`\n\n---\n\n# page_isolation.c 技术文档\n\n## 1. 文件概述\n\n`page_isolation.c` 是 Linux 内核内存管理子系统中的关键组件，主要负责**页面隔离（Page Isolation）**功能。该文件实现了将指定物理内存范围内的页面块（pageblock）标记为 `MIGRATE_ISOLATE` 迁移类型的能力，从而阻止分配器从此区域分配新页面。此机制主要用于**连续内存分配（CMA）**和**内存热插拔（Memory Hotplug）**场景，确保在执行内存迁移或离线操作前，目标区域不再被普通分配器使用。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`has_unmovable_pages()`**  \n  检查指定 PFN 范围 `[start_pfn, end_pfn)` 内是否存在不可移动页面。返回首个不可移动页面的指针（不持有引用），若全部可移动则返回 `NULL`。\n\n- **`set_migratetype_isolate()`**  \n  将包含指定页面的 pageblock 的迁移类型设置为 `MIGRATE_ISOLATE`。前提是该范围内无不可移动页面。成功时返回 0，否则返回 `-EBUSY`。\n\n- **`unset_migratetype_isolate()`**  \n  恢复 pageblock 的原始迁移类型，取消隔离状态，并将隔离期间产生的空闲页面归还到对应迁移类型的空闲链表中。\n\n- **`__first_valid_page()`**（代码片段未完整）  \n  辅助函数，用于在给定 PFN 范围内查找第一个有效的 struct page 实例。\n\n### 关键数据结构与宏\n\n- **`MIGRATE_ISOLATE`**: 特殊的迁移类型，表示该 pageblock 已被隔离，分配器应跳过。\n- **`pageblock_flags`**: 存储每个 pageblock 的迁移类型信息。\n- **`zone->nr_isolate_pageblock`**: 记录当前内存区域（zone）中被隔离的 pageblock 数量。\n\n## 3. 关键实现\n\n### 不可移动页面检测逻辑 (`has_unmovable_pages`)\n- **保留页面处理**: 所有 `PG_reserved` 页面（如 bootmem 分配、内存空洞）被视为不可移动。\n- **ZONE_MOVABLE 优化**: 若页面属于 `ZONE_MOVABLE`，则跳过详细检查（假设其内容可移动）。\n- **大页（Huge Page/THP）处理**: \n  - HugeTLB 页面需支持迁移才视为可移动。\n  - 透明大页（THP）若非 LRU 且非 `__PageMovable` 则视为不可移动。\n  - 跳过大页的尾页以避免重复检查。\n- **空闲页面处理**: Buddy 系统中的空闲页面（`PageBuddy`）可安全跳过。\n- **特殊标志处理**:\n  - 内存离线（`MEMORY_OFFLINE`）时，`PageHWPoison` 和 `PageOffline` 页面被临时视为可移动，允许驱动在离线回调中释放引用。\n- **可移动性判断**: 仅当页面属于 LRU 链表或具有 `__PageMovable` 属性时才视为可移动。\n\n### 隔离与取消隔离机制\n- **原子性保障**: 所有操作在 `zone->lock` 自旋锁保护下进行，确保并发安全。\n- **空闲页面迁移**: \n  - 隔离时调用 `move_freepages_block_isolate()` 将 pageblock 内空闲页面迁移到 `MIGRATE_ISOLATE` 链表。\n  - 取消隔离时，若存在高阶空闲页（≥ `pageblock_order`），先尝试隔离再归还，以触发 buddy 合并。\n- **错误报告**: 隔离失败时可通过 `REPORT_FAILURE` 标志触发 `dump_page()` 输出调试信息。\n\n### 限制与注意事项\n- **竞态条件**: 函数注释明确指出检测结果非精确（\"you can't expect this function should be exact\"），因未持有页面锁或 LRU 锁。\n- **范围约束**: 输入范围必须位于同一 pageblock 和同一内存区域（zone）内。\n- **CMA 特殊处理**: CMA 分配即使遇到实际不可移动页面，也强制视为可移动以支持隔离。\n\n## 4. 依赖关系\n\n- **内存管理核心**: 依赖 `<linux/mm.h>`、`internal.h` 提供的页面、区域（zone）、buddy 系统等基础功能。\n- **迁移框架**: 与 `<linux/migrate.h>` 协同工作，为页面迁移提供前置隔离能力。\n- **大页支持**: 通过 `<linux/hugetlb.h>` 处理 HugeTLB 页面的迁移属性。\n- **内存热插拔**: 服务于 `<linux/memory.h>` 中的内存离线（offline）流程。\n- **调试设施**: 使用 `<linux/page_owner.h>` 和 tracepoint（`<trace/events/page_isolation.h>`）辅助调试。\n\n## 5. 使用场景\n\n1. **连续内存分配（CMA）**  \n   在 `alloc_contig_range()` 中调用 `set_migratetype_isolate()` 隔离目标区域，确保后续迁移操作不受新分配干扰。\n\n2. **内存热插拔（Memory Hotplug）**  \n   - **内存离线**: 在 `offline_pages()` 流程中隔离待移除内存，确保无活跃分配后再迁移页面。\n   - **内存上线**: 通过 `unset_migratetype_isolate()` 恢复隔离区域，使其重新参与分配。\n\n3. **内存碎片整理（Compaction）**  \n   作为迁移前的准备步骤，隔离特定区域以进行定向碎片整理。\n\n4. **硬件错误处理**  \n   结合 `PageHWPoison` 机制，在隔离含错误页面的区域时提供特殊处理路径。",
      "similarity": 0.5013986229896545,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/page_isolation.c",
          "start_line": 305,
          "end_line": 447,
          "content": [
            "static int isolate_single_pageblock(unsigned long boundary_pfn, int flags,",
            "\t\t\tgfp_t gfp_flags, bool isolate_before, bool skip_isolation,",
            "\t\t\tint migratetype)",
            "{",
            "\tunsigned long start_pfn;",
            "\tunsigned long isolate_pageblock;",
            "\tunsigned long pfn;",
            "\tstruct zone *zone;",
            "\tint ret;",
            "",
            "\tVM_BUG_ON(!pageblock_aligned(boundary_pfn));",
            "",
            "\tif (isolate_before)",
            "\t\tisolate_pageblock = boundary_pfn - pageblock_nr_pages;",
            "\telse",
            "\t\tisolate_pageblock = boundary_pfn;",
            "",
            "\t/*",
            "\t * scan at the beginning of MAX_ORDER_NR_PAGES aligned range to avoid",
            "\t * only isolating a subset of pageblocks from a bigger than pageblock",
            "\t * free or in-use page. Also make sure all to-be-isolated pageblocks",
            "\t * are within the same zone.",
            "\t */",
            "\tzone  = page_zone(pfn_to_page(isolate_pageblock));",
            "\tstart_pfn  = max(ALIGN_DOWN(isolate_pageblock, MAX_ORDER_NR_PAGES),",
            "\t\t\t\t      zone->zone_start_pfn);",
            "",
            "\tif (skip_isolation) {",
            "\t\tint mt __maybe_unused = get_pageblock_migratetype(pfn_to_page(isolate_pageblock));",
            "",
            "\t\tVM_BUG_ON(!is_migrate_isolate(mt));",
            "\t} else {",
            "\t\tret = set_migratetype_isolate(pfn_to_page(isolate_pageblock), migratetype,",
            "\t\t\t\tflags, isolate_pageblock, isolate_pageblock + pageblock_nr_pages);",
            "",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * Bail out early when the to-be-isolated pageblock does not form",
            "\t * a free or in-use page across boundary_pfn:",
            "\t *",
            "\t * 1. isolate before boundary_pfn: the page after is not online",
            "\t * 2. isolate after boundary_pfn: the page before is not online",
            "\t *",
            "\t * This also ensures correctness. Without it, when isolate after",
            "\t * boundary_pfn and [start_pfn, boundary_pfn) are not online,",
            "\t * __first_valid_page() will return unexpected NULL in the for loop",
            "\t * below.",
            "\t */",
            "\tif (isolate_before) {",
            "\t\tif (!pfn_to_online_page(boundary_pfn))",
            "\t\t\treturn 0;",
            "\t} else {",
            "\t\tif (!pfn_to_online_page(boundary_pfn - 1))",
            "\t\t\treturn 0;",
            "\t}",
            "",
            "\tfor (pfn = start_pfn; pfn < boundary_pfn;) {",
            "\t\tstruct page *page = __first_valid_page(pfn, boundary_pfn - pfn);",
            "",
            "\t\tVM_BUG_ON(!page);",
            "\t\tpfn = page_to_pfn(page);",
            "",
            "\t\tif (PageBuddy(page)) {",
            "\t\t\tint order = buddy_order(page);",
            "",
            "\t\t\t/* move_freepages_block_isolate() handled this */",
            "\t\t\tVM_WARN_ON_ONCE(pfn + (1 << order) > boundary_pfn);",
            "",
            "\t\t\tpfn += 1UL << order;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * If a compound page is straddling our block, attempt",
            "\t\t * to migrate it out of the way.",
            "\t\t *",
            "\t\t * We don't have to worry about this creating a large",
            "\t\t * free page that straddles into our block: gigantic",
            "\t\t * pages are freed as order-0 chunks, and LRU pages",
            "\t\t * (currently) do not exceed pageblock_order.",
            "\t\t *",
            "\t\t * The block of interest has already been marked",
            "\t\t * MIGRATE_ISOLATE above, so when migration is done it",
            "\t\t * will free its pages onto the correct freelists.",
            "\t\t */",
            "\t\tif (PageCompound(page)) {",
            "\t\t\tstruct page *head = compound_head(page);",
            "\t\t\tunsigned long head_pfn = page_to_pfn(head);",
            "\t\t\tunsigned long nr_pages = compound_nr(head);",
            "",
            "\t\t\tif (head_pfn + nr_pages <= boundary_pfn) {",
            "\t\t\t\tpfn = head_pfn + nr_pages;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "#if defined CONFIG_COMPACTION || defined CONFIG_CMA",
            "\t\t\tif (PageHuge(page)) {",
            "\t\t\t\tint page_mt = get_pageblock_migratetype(page);",
            "\t\t\t\tstruct compact_control cc = {",
            "\t\t\t\t\t.nr_migratepages = 0,",
            "\t\t\t\t\t.order = -1,",
            "\t\t\t\t\t.zone = page_zone(pfn_to_page(head_pfn)),",
            "\t\t\t\t\t.mode = MIGRATE_SYNC,",
            "\t\t\t\t\t.ignore_skip_hint = true,",
            "\t\t\t\t\t.no_set_skip_hint = true,",
            "\t\t\t\t\t.gfp_mask = gfp_flags,",
            "\t\t\t\t\t.alloc_contig = true,",
            "\t\t\t\t};",
            "\t\t\t\tINIT_LIST_HEAD(&cc.migratepages);",
            "",
            "\t\t\t\tret = __alloc_contig_migrate_range(&cc, head_pfn,",
            "\t\t\t\t\t\t\thead_pfn + nr_pages, page_mt);",
            "\t\t\t\tif (ret)",
            "\t\t\t\t\tgoto failed;",
            "\t\t\t\tpfn = head_pfn + nr_pages;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\t/*",
            "\t\t\t * These pages are movable too, but they're",
            "\t\t\t * not expected to exceed pageblock_order.",
            "\t\t\t *",
            "\t\t\t * Let us know when they do, so we can add",
            "\t\t\t * proper free and split handling for them.",
            "\t\t\t */",
            "\t\t\tVM_WARN_ON_ONCE_PAGE(PageLRU(page), page);",
            "\t\t\tVM_WARN_ON_ONCE_PAGE(__PageMovable(page), page);",
            "#endif",
            "\t\t\tgoto failed;",
            "\t\t}",
            "",
            "\t\tpfn++;",
            "\t}",
            "\treturn 0;",
            "failed:",
            "\t/* restore the original migratetype */",
            "\tif (!skip_isolation)",
            "\t\tunset_migratetype_isolate(pfn_to_page(isolate_pageblock), migratetype);",
            "\treturn -EBUSY;",
            "}"
          ],
          "function_name": "isolate_single_pageblock",
          "description": "`isolate_single_pageblock`隔离单个页面块，跳过自由页面并迁移复合/巨型页面，若失败则恢复原迁移类型，确保隔离区域不含不可移动页。",
          "similarity": 0.5269315242767334
        },
        {
          "chunk_id": 3,
          "file_path": "mm/page_isolation.c",
          "start_line": 494,
          "end_line": 623,
          "content": [
            "int start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,",
            "\t\t\t     int migratetype, int flags, gfp_t gfp_flags)",
            "{",
            "\tunsigned long pfn;",
            "\tstruct page *page;",
            "\t/* isolation is done at page block granularity */",
            "\tunsigned long isolate_start = pageblock_start_pfn(start_pfn);",
            "\tunsigned long isolate_end = pageblock_align(end_pfn);",
            "\tint ret;",
            "\tbool skip_isolation = false;",
            "",
            "\t/* isolate [isolate_start, isolate_start + pageblock_nr_pages) pageblock */",
            "\tret = isolate_single_pageblock(isolate_start, flags, gfp_flags, false,",
            "\t\t\tskip_isolation, migratetype);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (isolate_start == isolate_end - pageblock_nr_pages)",
            "\t\tskip_isolation = true;",
            "",
            "\t/* isolate [isolate_end - pageblock_nr_pages, isolate_end) pageblock */",
            "\tret = isolate_single_pageblock(isolate_end, flags, gfp_flags, true,",
            "\t\t\tskip_isolation, migratetype);",
            "\tif (ret) {",
            "\t\tunset_migratetype_isolate(pfn_to_page(isolate_start), migratetype);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/* skip isolated pageblocks at the beginning and end */",
            "\tfor (pfn = isolate_start + pageblock_nr_pages;",
            "\t     pfn < isolate_end - pageblock_nr_pages;",
            "\t     pfn += pageblock_nr_pages) {",
            "\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);",
            "\t\tif (page && set_migratetype_isolate(page, migratetype, flags,",
            "\t\t\t\t\tstart_pfn, end_pfn)) {",
            "\t\t\tundo_isolate_page_range(isolate_start, pfn, migratetype);",
            "\t\t\tunset_migratetype_isolate(",
            "\t\t\t\tpfn_to_page(isolate_end - pageblock_nr_pages),",
            "\t\t\t\tmigratetype);",
            "\t\t\treturn -EBUSY;",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}",
            "void undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,",
            "\t\t\t    int migratetype)",
            "{",
            "\tunsigned long pfn;",
            "\tstruct page *page;",
            "\tunsigned long isolate_start = pageblock_start_pfn(start_pfn);",
            "\tunsigned long isolate_end = pageblock_align(end_pfn);",
            "",
            "\tfor (pfn = isolate_start;",
            "\t     pfn < isolate_end;",
            "\t     pfn += pageblock_nr_pages) {",
            "\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);",
            "\t\tif (!page || !is_migrate_isolate_page(page))",
            "\t\t\tcontinue;",
            "\t\tunset_migratetype_isolate(page, migratetype);",
            "\t}",
            "}",
            "static unsigned long",
            "__test_page_isolated_in_pageblock(unsigned long pfn, unsigned long end_pfn,",
            "\t\t\t\t  int flags)",
            "{",
            "\tstruct page *page;",
            "",
            "\twhile (pfn < end_pfn) {",
            "\t\tpage = pfn_to_page(pfn);",
            "\t\tif (PageBuddy(page))",
            "\t\t\t/*",
            "\t\t\t * If the page is on a free list, it has to be on",
            "\t\t\t * the correct MIGRATE_ISOLATE freelist. There is no",
            "\t\t\t * simple way to verify that as VM_BUG_ON(), though.",
            "\t\t\t */",
            "\t\t\tpfn += 1 << buddy_order(page);",
            "\t\telse if ((flags & MEMORY_OFFLINE) && PageHWPoison(page))",
            "\t\t\t/* A HWPoisoned page cannot be also PageBuddy */",
            "\t\t\tpfn++;",
            "\t\telse if ((flags & MEMORY_OFFLINE) && PageOffline(page) &&",
            "\t\t\t !page_count(page))",
            "\t\t\t/*",
            "\t\t\t * The responsible driver agreed to skip PageOffline()",
            "\t\t\t * pages when offlining memory by dropping its",
            "\t\t\t * reference in MEM_GOING_OFFLINE.",
            "\t\t\t */",
            "\t\t\tpfn++;",
            "\t\telse",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn pfn;",
            "}",
            "int test_pages_isolated(unsigned long start_pfn, unsigned long end_pfn,",
            "\t\t\tint isol_flags)",
            "{",
            "\tunsigned long pfn, flags;",
            "\tstruct page *page;",
            "\tstruct zone *zone;",
            "\tint ret;",
            "",
            "\t/*",
            "\t * Note: pageblock_nr_pages != MAX_PAGE_ORDER. Then, chunks of free",
            "\t * pages are not aligned to pageblock_nr_pages.",
            "\t * Then we just check migratetype first.",
            "\t */",
            "\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {",
            "\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);",
            "\t\tif (page && !is_migrate_isolate_page(page))",
            "\t\t\tbreak;",
            "\t}",
            "\tpage = __first_valid_page(start_pfn, end_pfn - start_pfn);",
            "\tif ((pfn < end_pfn) || !page) {",
            "\t\tret = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* Check all pages are free or marked as ISOLATED */",
            "\tzone = page_zone(page);",
            "\tspin_lock_irqsave(&zone->lock, flags);",
            "\tpfn = __test_page_isolated_in_pageblock(start_pfn, end_pfn, isol_flags);",
            "\tspin_unlock_irqrestore(&zone->lock, flags);",
            "",
            "\tret = pfn < end_pfn ? -EBUSY : 0;",
            "",
            "out:",
            "\ttrace_test_pages_isolated(start_pfn, end_pfn, pfn);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "start_isolate_page_range, undo_isolate_page_range, __test_page_isolated_in_pageblock, test_pages_isolated",
          "description": "`start_isolate_page_range`分步隔离连续页面块范围，`undo_isolate_page_range`撤销隔离；`test_pages_isolated`验证隔离完整性，确保所有页面处于隔离或自由状态。",
          "similarity": 0.5194828510284424
        },
        {
          "chunk_id": 1,
          "file_path": "mm/page_isolation.c",
          "start_line": 147,
          "end_line": 262,
          "content": [
            "static int set_migratetype_isolate(struct page *page, int migratetype, int isol_flags,",
            "\t\t\tunsigned long start_pfn, unsigned long end_pfn)",
            "{",
            "\tstruct zone *zone = page_zone(page);",
            "\tstruct page *unmovable;",
            "\tunsigned long flags;",
            "\tunsigned long check_unmovable_start, check_unmovable_end;",
            "",
            "\tspin_lock_irqsave(&zone->lock, flags);",
            "",
            "\t/*",
            "\t * We assume the caller intended to SET migrate type to isolate.",
            "\t * If it is already set, then someone else must have raced and",
            "\t * set it before us.",
            "\t */",
            "\tif (is_migrate_isolate_page(page)) {",
            "\t\tspin_unlock_irqrestore(&zone->lock, flags);",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\t/*",
            "\t * FIXME: Now, memory hotplug doesn't call shrink_slab() by itself.",
            "\t * We just check MOVABLE pages.",
            "\t *",
            "\t * Pass the intersection of [start_pfn, end_pfn) and the page's pageblock",
            "\t * to avoid redundant checks.",
            "\t */",
            "\tcheck_unmovable_start = max(page_to_pfn(page), start_pfn);",
            "\tcheck_unmovable_end = min(pageblock_end_pfn(page_to_pfn(page)),",
            "\t\t\t\t  end_pfn);",
            "",
            "\tunmovable = has_unmovable_pages(check_unmovable_start, check_unmovable_end,",
            "\t\t\tmigratetype, isol_flags);",
            "\tif (!unmovable) {",
            "\t\tif (!move_freepages_block_isolate(zone, page, MIGRATE_ISOLATE)) {",
            "\t\t\tspin_unlock_irqrestore(&zone->lock, flags);",
            "\t\t\treturn -EBUSY;",
            "\t\t}",
            "\t\tzone->nr_isolate_pageblock++;",
            "\t\tspin_unlock_irqrestore(&zone->lock, flags);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tspin_unlock_irqrestore(&zone->lock, flags);",
            "\tif (isol_flags & REPORT_FAILURE) {",
            "\t\t/*",
            "\t\t * printk() with zone->lock held will likely trigger a",
            "\t\t * lockdep splat, so defer it here.",
            "\t\t */",
            "\t\tdump_page(unmovable, \"unmovable page\");",
            "\t}",
            "",
            "\treturn -EBUSY;",
            "}",
            "static void unset_migratetype_isolate(struct page *page, int migratetype)",
            "{",
            "\tstruct zone *zone;",
            "\tunsigned long flags;",
            "\tbool isolated_page = false;",
            "\tunsigned int order;",
            "\tstruct page *buddy;",
            "",
            "\tzone = page_zone(page);",
            "\tspin_lock_irqsave(&zone->lock, flags);",
            "\tif (!is_migrate_isolate_page(page))",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Because freepage with more than pageblock_order on isolated",
            "\t * pageblock is restricted to merge due to freepage counting problem,",
            "\t * it is possible that there is free buddy page.",
            "\t * move_freepages_block() doesn't care of merge so we need other",
            "\t * approach in order to merge them. Isolation and free will make",
            "\t * these pages to be merged.",
            "\t */",
            "\tif (PageBuddy(page)) {",
            "\t\torder = buddy_order(page);",
            "\t\tif (order >= pageblock_order && order < MAX_PAGE_ORDER) {",
            "\t\t\tbuddy = find_buddy_page_pfn(page, page_to_pfn(page),",
            "\t\t\t\t\t\t    order, NULL);",
            "\t\t\tif (buddy && !is_migrate_isolate_page(buddy)) {",
            "\t\t\t\tisolated_page = !!__isolate_free_page(page, order);",
            "\t\t\t\t/*",
            "\t\t\t\t * Isolating a free page in an isolated pageblock",
            "\t\t\t\t * is expected to always work as watermarks don't",
            "\t\t\t\t * apply here.",
            "\t\t\t\t */",
            "\t\t\t\tVM_WARN_ON(!isolated_page);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * If we isolate freepage with more than pageblock_order, there",
            "\t * should be no freepage in the range, so we could avoid costly",
            "\t * pageblock scanning for freepage moving.",
            "\t *",
            "\t * We didn't actually touch any of the isolated pages, so place them",
            "\t * to the tail of the freelist. This is an optimization for memory",
            "\t * onlining - just onlined memory won't immediately be considered for",
            "\t * allocation.",
            "\t */",
            "\tif (!isolated_page) {",
            "\t\t/*",
            "\t\t * Isolating this block already succeeded, so this",
            "\t\t * should not fail on zone boundaries.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(!move_freepages_block_isolate(zone, page, migratetype));",
            "\t} else {",
            "\t\tset_pageblock_migratetype(page, migratetype);",
            "\t\t__putback_isolated_page(page, order, migratetype);",
            "\t}",
            "\tzone->nr_isolate_pageblock--;",
            "out:",
            "\tspin_unlock_irqrestore(&zone->lock, flags);",
            "}"
          ],
          "function_name": "set_migratetype_isolate, unset_migratetype_isolate",
          "description": "`set_migratetype_isolate`尝试设置页面块为隔离类型需先确认无不可移动页，成功则增加隔离计数；`unset_migratetype_isolate`移除隔离状态，处理自由页面合并与迁移异常情况。",
          "similarity": 0.490440309047699
        },
        {
          "chunk_id": 0,
          "file_path": "mm/page_isolation.c",
          "start_line": 1,
          "end_line": 146,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * linux/mm/page_isolation.c",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/memory.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/migrate.h>",
            "#include \"internal.h\"",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/page_isolation.h>",
            "",
            "/*",
            " * This function checks whether the range [start_pfn, end_pfn) includes",
            " * unmovable pages or not. The range must fall into a single pageblock and",
            " * consequently belong to a single zone.",
            " *",
            " * PageLRU check without isolation or lru_lock could race so that",
            " * MIGRATE_MOVABLE block might include unmovable pages. And __PageMovable",
            " * check without lock_page also may miss some movable non-lru pages at",
            " * race condition. So you can't expect this function should be exact.",
            " *",
            " * Returns a page without holding a reference. If the caller wants to",
            " * dereference that page (e.g., dumping), it has to make sure that it",
            " * cannot get removed (e.g., via memory unplug) concurrently.",
            " *",
            " */",
            "static struct page *has_unmovable_pages(unsigned long start_pfn, unsigned long end_pfn,",
            "\t\t\t\tint migratetype, int flags)",
            "{",
            "\tstruct page *page = pfn_to_page(start_pfn);",
            "\tstruct zone *zone = page_zone(page);",
            "\tunsigned long pfn;",
            "",
            "\tVM_BUG_ON(pageblock_start_pfn(start_pfn) !=",
            "\t\t  pageblock_start_pfn(end_pfn - 1));",
            "",
            "\tif (is_migrate_cma_page(page)) {",
            "\t\t/*",
            "\t\t * CMA allocations (alloc_contig_range) really need to mark",
            "\t\t * isolate CMA pageblocks even when they are not movable in fact",
            "\t\t * so consider them movable here.",
            "\t\t */",
            "\t\tif (is_migrate_cma(migratetype))",
            "\t\t\treturn NULL;",
            "",
            "\t\treturn page;",
            "\t}",
            "",
            "\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {",
            "\t\tpage = pfn_to_page(pfn);",
            "",
            "\t\t/*",
            "\t\t * Both, bootmem allocations and memory holes are marked",
            "\t\t * PG_reserved and are unmovable. We can even have unmovable",
            "\t\t * allocations inside ZONE_MOVABLE, for example when",
            "\t\t * specifying \"movablecore\".",
            "\t\t */",
            "\t\tif (PageReserved(page))",
            "\t\t\treturn page;",
            "",
            "\t\t/*",
            "\t\t * If the zone is movable and we have ruled out all reserved",
            "\t\t * pages then it should be reasonably safe to assume the rest",
            "\t\t * is movable.",
            "\t\t */",
            "\t\tif (zone_idx(zone) == ZONE_MOVABLE)",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Hugepages are not in LRU lists, but they're movable.",
            "\t\t * THPs are on the LRU, but need to be counted as #small pages.",
            "\t\t * We need not scan over tail pages because we don't",
            "\t\t * handle each tail page individually in migration.",
            "\t\t */",
            "\t\tif (PageHuge(page) || PageTransCompound(page)) {",
            "\t\t\tstruct folio *folio = page_folio(page);",
            "\t\t\tunsigned int skip_pages;",
            "",
            "\t\t\tif (PageHuge(page)) {",
            "\t\t\t\tif (!hugepage_migration_supported(folio_hstate(folio)))",
            "\t\t\t\t\treturn page;",
            "\t\t\t} else if (!folio_test_lru(folio) && !__folio_test_movable(folio)) {",
            "\t\t\t\treturn page;",
            "\t\t\t}",
            "",
            "\t\t\tskip_pages = folio_nr_pages(folio) - folio_page_idx(folio, page);",
            "\t\t\tpfn += skip_pages - 1;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * We can't use page_count without pin a page",
            "\t\t * because another CPU can free compound page.",
            "\t\t * This check already skips compound tails of THP",
            "\t\t * because their page->_refcount is zero at all time.",
            "\t\t */",
            "\t\tif (!page_ref_count(page)) {",
            "\t\t\tif (PageBuddy(page))",
            "\t\t\t\tpfn += (1 << buddy_order(page)) - 1;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * The HWPoisoned page may be not in buddy system, and",
            "\t\t * page_count() is not 0.",
            "\t\t */",
            "\t\tif ((flags & MEMORY_OFFLINE) && PageHWPoison(page))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * We treat all PageOffline() pages as movable when offlining",
            "\t\t * to give drivers a chance to decrement their reference count",
            "\t\t * in MEM_GOING_OFFLINE in order to indicate that these pages",
            "\t\t * can be offlined as there are no direct references anymore.",
            "\t\t * For actually unmovable PageOffline() where the driver does",
            "\t\t * not support this, we will fail later when trying to actually",
            "\t\t * move these pages that still have a reference count > 0.",
            "\t\t * (false negatives in this function only)",
            "\t\t */",
            "\t\tif ((flags & MEMORY_OFFLINE) && PageOffline(page))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (__PageMovable(page) || PageLRU(page))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * If there are RECLAIMABLE pages, we need to check",
            "\t\t * it.  But now, memory offline itself doesn't call",
            "\t\t * shrink_node_slabs() and it still to be fixed.",
            "\t\t */",
            "\t\treturn page;",
            "\t}",
            "\treturn NULL;",
            "}",
            "",
            "/*",
            " * This function set pageblock migratetype to isolate if no unmovable page is",
            " * present in [start_pfn, end_pfn). The pageblock must intersect with",
            " * [start_pfn, end_pfn).",
            " */"
          ],
          "function_name": null,
          "description": "函数`has_unmovable_pages`检查指定PFN范围是否存在不可移动页面，通过遍历并判断页面是否为保留、非MOVABLE或特殊类型（如HugeTLB），返回首个不可移动页面指针。结果可能因竞态存在误差。",
          "similarity": 0.47384142875671387
        }
      ]
    },
    {
      "source_file": "mm/debug_page_alloc.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:54:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `debug_page_alloc.c`\n\n---\n\n# debug_page_alloc.c 技术文档\n\n## 1. 文件概述\n\n`debug_page_alloc.c` 是 Linux 内核中用于支持页分配调试功能的核心实现文件。该文件主要提供两个关键调试机制：\n\n- **页分配调试（debug_pagealloc）**：在内存分配/释放时对页面进行特殊标记和保护，用于检测内存越界访问、重复释放等错误。\n- **守护页（guard page）机制**：在分配的大块内存前后插入不可访问的“守护页”，用于捕获缓冲区溢出等内存破坏问题。\n\n该文件通过内核启动参数控制调试功能的启用状态和行为参数，并提供底层页标志操作接口供内存管理子系统调用。\n\n## 2. 核心功能\n\n### 全局变量\n- `_debug_guardpage_minorder`：守护页机制生效的最小分配阶数阈值\n- `_debug_pagealloc_enabled_early`：早期启动阶段页分配调试的启用状态\n- `_debug_pagealloc_enabled`：运行时页分配调试功能的静态键开关\n- `_debug_guardpage_enabled`：守护页功能的静态键开关\n\n### 函数接口\n- `early_debug_pagealloc()`：解析 `debug_pagealloc=` 内核启动参数\n- `debug_guardpage_minorder_setup()`：解析 `debug_guardpage_minorder=` 内核启动参数\n- `__set_page_guard()`：为指定页面设置守护页标志和相关属性\n- `__clear_page_guard()`：清除页面的守护页标志和相关属性\n\n### 宏定义\n- `debug_guardpage_minorder()`：获取当前守护页最小阶数值（内联函数）\n\n## 3. 关键实现\n\n### 启动参数处理\n- **`debug_pagealloc` 参数**：通过 `early_param()` 在内核早期初始化阶段解析布尔值参数，控制 `_debug_pagealloc_enabled_early` 的初始状态\n- **`debug_guardpage_minorder` 参数**：解析无符号长整型参数，验证其有效性（0 ≤ value ≤ MAX_PAGE_ORDER/2），设置 `_debug_guardpage_minorder` 全局变量\n\n### 守护页管理\n- **设置守护页 (`__set_page_guard`)**：\n  - 仅当请求的分配阶数小于 `_debug_guardpage_minorder` 时才启用守护页\n  - 设置 `PG_guard` 页面标志位\n  - 初始化 buddy_list 为空链表（防止误用）\n  - 将分配阶数存储在 page->private 字段中\n- **清除守护页 (`__clear_page_guard`)**：\n  - 清除 `PG_guard` 标志位\n  - 将 page->private 重置为 0\n\n### 静态键优化\n- 使用 `DEFINE_STATIC_KEY_FALSE` 定义运行时开关，避免调试代码路径的性能开销\n- 通过 `EXPORT_SYMBOL` 导出符号供其他内核模块使用\n\n## 4. 依赖关系\n\n### 头文件依赖\n- `<linux/mm.h>`：提供核心内存管理数据结构和函数声明\n- `<linux/page-isolation.h>`：提供页面隔离相关功能（如 `__SetPageGuard` 等宏定义）\n\n### 内核配置依赖\n- `CONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT`：控制默认是否启用页分配调试功能\n- `MAX_PAGE_ORDER`：定义最大分配阶数常量，用于参数验证\n\n### 符号导出\n- `_debug_pagealloc_enabled_early` 和 `_debug_pagealloc_enabled` 被导出，供内存管理子系统（如伙伴系统）查询调试状态\n\n## 5. 使用场景\n\n### 内存错误检测\n- 在开发和调试阶段启用 `debug_pagealloc=1`，可检测内存越界写入、使用已释放内存等问题\n- 守护页机制特别适用于捕获大内存块分配时的缓冲区溢出错误\n\n### 性能敏感环境\n- 默认情况下调试功能关闭，避免运行时性能开销\n- 通过静态键机制确保禁用时调试代码路径完全不执行\n\n### 内核启动配置\n- 系统管理员可通过内核命令行参数动态调整调试行为：\n  - `debug_pagealloc=1` 启用页分配调试\n  - `debug_guardpage_minorder=N` 设置守护页触发的最小分配阶数\n\n### 内存管理子系统集成\n- 伙伴系统（buddy allocator）在页面分配/释放时调用 `__set_page_guard()` 和 `__clear_page_guard()` 管理守护页状态\n- 页面迁移、内存热插拔等子系统依赖此模块提供的页面状态管理功能",
      "similarity": 0.5009360313415527,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/debug_page_alloc.c",
          "start_line": 15,
          "end_line": 46,
          "content": [
            "static int __init early_debug_pagealloc(char *buf)",
            "{",
            "\treturn kstrtobool(buf, &_debug_pagealloc_enabled_early);",
            "}",
            "static int __init debug_guardpage_minorder_setup(char *buf)",
            "{",
            "\tunsigned long res;",
            "",
            "\tif (kstrtoul(buf, 10, &res) < 0 ||  res > MAX_PAGE_ORDER / 2) {",
            "\t\tpr_err(\"Bad debug_guardpage_minorder value\\n\");",
            "\t\treturn 0;",
            "\t}",
            "\t_debug_guardpage_minorder = res;",
            "\tpr_info(\"Setting debug_guardpage_minorder to %lu\\n\", res);",
            "\treturn 0;",
            "}",
            "bool __set_page_guard(struct zone *zone, struct page *page, unsigned int order)",
            "{",
            "\tif (order >= debug_guardpage_minorder())",
            "\t\treturn false;",
            "",
            "\t__SetPageGuard(page);",
            "\tINIT_LIST_HEAD(&page->buddy_list);",
            "\tset_page_private(page, order);",
            "",
            "\treturn true;",
            "}",
            "void __clear_page_guard(struct zone *zone, struct page *page, unsigned int order)",
            "{",
            "\t__ClearPageGuard(page);",
            "\tset_page_private(page, 0);",
            "}"
          ],
          "function_name": "early_debug_pagealloc, debug_guardpage_minorder_setup, __set_page_guard, __clear_page_guard",
          "description": "实现早期调试参数解析、最小订单值设置及页保护状态管理逻辑，通过订单阈值控制是否对页面添加守护标志并修改页面私有数据",
          "similarity": 0.4643189311027527
        },
        {
          "chunk_id": 0,
          "file_path": "mm/debug_page_alloc.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/mm.h>",
            "#include <linux/page-isolation.h>",
            "",
            "unsigned int _debug_guardpage_minorder;",
            "",
            "bool _debug_pagealloc_enabled_early __read_mostly",
            "\t\t\t= IS_ENABLED(CONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT);",
            "EXPORT_SYMBOL(_debug_pagealloc_enabled_early);",
            "DEFINE_STATIC_KEY_FALSE(_debug_pagealloc_enabled);",
            "EXPORT_SYMBOL(_debug_pagealloc_enabled);",
            "",
            "DEFINE_STATIC_KEY_FALSE(_debug_guardpage_enabled);",
            ""
          ],
          "function_name": null,
          "description": "定义调试页面分配相关全局变量及符号导出，用于控制早期调试功能启用状态和静态键，支持动态开关调试页保护机制",
          "similarity": 0.4498388469219208
        }
      ]
    }
  ]
}