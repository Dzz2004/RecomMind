{
  "query": "容器运行时如何管理进程隔离",
  "timestamp": "2025-12-26 01:50:27",
  "retrieved_files": [
    {
      "source_file": "kernel/sched/isolation.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:11:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\isolation.c`\n\n---\n\n# `sched/isolation.c` 技术文档\n\n## 1. 文件概述\n\n`sched/isolation.c` 实现了 Linux 内核中的 **housekeeping（家务管理）机制**，用于管理那些必须在特定 CPU 上运行的通用内核任务（如未绑定的工作队列、定时器、内核线程、RCU 回调、调度器相关任务等）。该机制支持通过内核启动参数（如 `nohz_full=` 和 `isolcpus=`）将某些 CPU 从常规内核任务中“隔离”出来，以提升实时性或减少干扰，常用于高性能计算、低延迟或实时系统场景。\n\n核心目标是：**允许用户指定一组“非隔离”CPU（即 housekeeping CPU）专门处理内核后台任务，而将其他 CPU 保留给用户关键任务使用**。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`enum hk_flags`**  \n  定义 housekeeping 功能类型对应的位标志，包括：\n  - `HK_FLAG_TIMER`：定时器\n  - `HK_FLAG_RCU`：RCU 回调\n  - `HK_FLAG_MISC`：杂项内核任务\n  - `HK_FLAG_SCHED`：调度器相关任务\n  - `HK_FLAG_TICK`：周期性 tick（与 NO_HZ_FULL 相关）\n  - `HK_FLAG_DOMAIN`：调度域构建\n  - `HK_FLAG_WQ`：工作队列\n  - `HK_FLAG_MANAGED_IRQ`：托管中断亲和性\n  - `HK_FLAG_KTHREAD`：内核线程\n\n- **`struct housekeeping`**  \n  全局结构体，包含：\n  - `cpumasks[HK_TYPE_MAX]`：每种 housekeeping 类型对应的 CPU 掩码\n  - `flags`：启用的 housekeeping 功能位图\n\n- **`housekeeping_overridden`**  \n  静态分支键（`static_key`），用于快速判断是否启用了自定义 housekeeping 配置。\n\n### 主要函数\n\n- **`housekeeping_enabled(enum hk_type type)`**  \n  检查指定类型的 housekeeping 是否启用。\n\n- **`housekeeping_any_cpu(enum hk_type type)`**  \n  返回适合执行指定类型 housekeeping 任务的 CPU（优先 NUMA 亲和，其次任意在线 CPU）。\n\n- **`housekeeping_cpumask(enum hk_type type)`**  \n  返回指定类型 housekeeping 任务允许运行的 CPU 掩码。\n\n- **`housekeeping_affine(struct task_struct *t, enum hk_type type)`**  \n  将任务 `t` 的 CPU 亲和性限制为指定类型 housekeeping 的 CPU 集合。\n\n- **`housekeeping_test_cpu(int cpu, enum hk_type type)`**  \n  检查指定 CPU 是否属于指定类型 housekeeping 的允许集合。\n\n- **`housekeeping_init(void)`**  \n  初始化 housekeeping 子系统，启用静态分支并验证配置。\n\n- **`housekeeping_setup(char *str, unsigned long flags)`**  \n  解析启动参数（CPU 列表），设置 housekeeping 的 CPU 掩码和功能标志。\n\n- **`housekeeping_nohz_full_setup()` / `housekeeping_isolcpus_setup()`**  \n  分别处理 `nohz_full=` 和 `isolcpus=` 内核启动参数。\n\n- **`enhanced_isolcpus_setup()`**  \n  处理 `enhanced_isolcpus` 启动参数，启用增强隔离模式（仅设标志，具体行为由其他子系统实现）。\n\n## 3. 关键实现\n\n### 静态分支优化\n使用 `static_branch_unlikely(&housekeeping_overridden)` 实现零开销快速路径：当未配置隔离时，所有 housekeeping 函数直接返回默认值（如 `smp_processor_id()` 或 `cpu_possible_mask`），避免条件判断开销。\n\n### 启动参数解析\n- **`nohz_full=cpu-list`**：自动启用 `HK_FLAG_TICK | WQ | TIMER | RCU | MISC | KTHREAD`，表示这些任务只能在非 `nohz_full` CPU 上运行。\n- **`isolcpus=flags,cpu-list`**：支持细粒度控制，如：\n  - `nohz` → 启用 `HK_FLAG_TICK`\n  - `domain` → 启用 `HK_FLAG_DOMAIN`（影响调度域构建）\n  - `managed_irq` → 启用 `HK_FLAG_MANAGED_IRQ`\n  - 无标志时默认启用 `HK_FLAG_DOMAIN`\n\n### 配置一致性检查\n若同时使用 `nohz_full=` 和 `isolcpus=`，要求两者指定的 housekeeping CPU 集合必须一致，否则报错。\n\n### 安全兜底机制\n若用户指定的 housekeeping CPU 集合中没有在线 CPU，则自动将引导 CPU（`smp_processor_id()`）加入，确保至少有一个 CPU 可处理内核任务。\n\n### NO_HZ_FULL 集成\n当启用 `HK_FLAG_TICK` 时：\n- 检查 `CONFIG_NO_HZ_FULL` 是否启用\n- 调用 `tick_nohz_full_setup()` 配置无周期 tick\n- 调用 `sched_tick_offload_init()` 初始化 tick 卸载\n\n## 4. 依赖关系\n\n- **调度器子系统 (`kernel/sched/`)**  \n  依赖 `sched_numa_find_closest()` 实现 NUMA 亲和调度；`housekeeping_affine()` 调用 `set_cpus_allowed_ptr()`。\n\n- **时间子系统 (`kernel/time/`)**  \n  与 `tick_nohz_full_setup()` 和 `sched_tick_offload_init()` 紧密集成，实现无周期 tick。\n\n- **CPU 热插拔与拓扑 (`kernel/cpu.c`, `arch/`)**  \n  使用 `cpu_possible_mask`、`cpu_online_mask`、`cpu_present_mask` 等全局 CPU 掩码。\n\n- **启动内存分配 (`mm/`)**  \n  使用 `alloc_bootmem_cpumask_var()` 在初始化阶段分配 CPU 掩码内存。\n\n- **RCU 子系统 (`kernel/rcu/`)**  \n  通过 `HK_FLAG_RCU` 控制 RCU 回调的执行 CPU。\n\n- **工作队列 (`kernel/workqueue.c`)**  \n  通过 `HK_FLAG_WQ` 限制未绑定工作队列的执行 CPU。\n\n## 5. 使用场景\n\n1. **实时系统**  \n   通过 `isolcpus=domain,managed_irq,1-7` 将 CPU 1-7 从调度域和中断中隔离，仅保留 CPU 0 处理内核任务，降低关键任务延迟。\n\n2. **高性能计算 (HPC)**  \n   使用 `nohz_full=1-15` 禁用 CPU 1-15 的周期性 tick，减少干扰，提升计算密集型应用性能。\n\n3. **低延迟应用**  \n   结合 `isolcpus=nohz,domain,1` 和用户空间任务绑定，确保 CPU 1 无内核后台活动，实现微秒级响应。\n\n4. **虚拟化环境**  \n   将部分 CPU 完全分配给虚拟机（通过隔离），避免宿主机内核任务抢占。\n\n5. **增强隔离模式**  \n   启用 `enhanced_isolcpus` 参数（需其他子系统支持），进一步限制隔离 CPU 上的内核活动（如禁止 softirq、禁止 page reclaim 等）。",
      "similarity": 0.5925150513648987,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/isolation.c",
          "start_line": 1,
          "end_line": 32,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  Housekeeping management. Manage the targets for routine code that can run on",
            " *  any CPU: unbound workqueues, timers, kthreads and any offloadable work.",
            " *",
            " * Copyright (C) 2017 Red Hat, Inc., Frederic Weisbecker",
            " * Copyright (C) 2017-2018 SUSE, Frederic Weisbecker",
            " *",
            " */",
            "",
            "enum hk_flags {",
            "\tHK_FLAG_TIMER\t\t= BIT(HK_TYPE_TIMER),",
            "\tHK_FLAG_RCU\t\t= BIT(HK_TYPE_RCU),",
            "\tHK_FLAG_MISC\t\t= BIT(HK_TYPE_MISC),",
            "\tHK_FLAG_SCHED\t\t= BIT(HK_TYPE_SCHED),",
            "\tHK_FLAG_TICK\t\t= BIT(HK_TYPE_TICK),",
            "\tHK_FLAG_DOMAIN\t\t= BIT(HK_TYPE_DOMAIN),",
            "\tHK_FLAG_WQ\t\t= BIT(HK_TYPE_WQ),",
            "\tHK_FLAG_MANAGED_IRQ\t= BIT(HK_TYPE_MANAGED_IRQ),",
            "\tHK_FLAG_KTHREAD\t\t= BIT(HK_TYPE_KTHREAD),",
            "};",
            "",
            "DEFINE_STATIC_KEY_FALSE(housekeeping_overridden);",
            "EXPORT_SYMBOL_GPL(housekeeping_overridden);",
            "",
            "struct housekeeping {",
            "\tcpumask_var_t cpumasks[HK_TYPE_MAX];",
            "\tunsigned long flags;",
            "};",
            "",
            "static struct housekeeping housekeeping;",
            ""
          ],
          "function_name": null,
          "description": "定义了用于管理不同类型housekeeping任务的标志位枚举和housekeeping结构体，其中包含各类型任务的CPU掩码数组及全局标志位，用于后续CPU亲和性控制。",
          "similarity": 0.5152246952056885
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/isolation.c",
          "start_line": 33,
          "end_line": 164,
          "content": [
            "bool housekeeping_enabled(enum hk_type type)",
            "{",
            "\treturn !!(housekeeping.flags & BIT(type));",
            "}",
            "int housekeeping_any_cpu(enum hk_type type)",
            "{",
            "\tint cpu;",
            "",
            "\tif (static_branch_unlikely(&housekeeping_overridden)) {",
            "\t\tif (housekeeping.flags & BIT(type)) {",
            "\t\t\tcpu = sched_numa_find_closest(housekeeping.cpumasks[type], smp_processor_id());",
            "\t\t\tif (cpu < nr_cpu_ids)",
            "\t\t\t\treturn cpu;",
            "",
            "\t\t\treturn cpumask_any_and(housekeeping.cpumasks[type], cpu_online_mask);",
            "\t\t}",
            "\t}",
            "\treturn smp_processor_id();",
            "}",
            "void housekeeping_affine(struct task_struct *t, enum hk_type type)",
            "{",
            "\tif (static_branch_unlikely(&housekeeping_overridden))",
            "\t\tif (housekeeping.flags & BIT(type))",
            "\t\t\tset_cpus_allowed_ptr(t, housekeeping.cpumasks[type]);",
            "}",
            "bool housekeeping_test_cpu(int cpu, enum hk_type type)",
            "{",
            "\tif (static_branch_unlikely(&housekeeping_overridden))",
            "\t\tif (housekeeping.flags & BIT(type))",
            "\t\t\treturn cpumask_test_cpu(cpu, housekeeping.cpumasks[type]);",
            "\treturn true;",
            "}",
            "void __init housekeeping_init(void)",
            "{",
            "\tenum hk_type type;",
            "",
            "\tif (!housekeeping.flags)",
            "\t\treturn;",
            "",
            "\tstatic_branch_enable(&housekeeping_overridden);",
            "",
            "\tif (housekeeping.flags & HK_FLAG_TICK)",
            "\t\tsched_tick_offload_init();",
            "",
            "\tfor_each_set_bit(type, &housekeeping.flags, HK_TYPE_MAX) {",
            "\t\t/* We need at least one CPU to handle housekeeping work */",
            "\t\tWARN_ON_ONCE(cpumask_empty(housekeeping.cpumasks[type]));",
            "\t}",
            "}",
            "static void __init housekeeping_setup_type(enum hk_type type,",
            "\t\t\t\t\t   cpumask_var_t housekeeping_staging)",
            "{",
            "",
            "\talloc_bootmem_cpumask_var(&housekeeping.cpumasks[type]);",
            "\tcpumask_copy(housekeeping.cpumasks[type],",
            "\t\t     housekeeping_staging);",
            "}",
            "static int __init housekeeping_setup(char *str, unsigned long flags)",
            "{",
            "\tcpumask_var_t non_housekeeping_mask, housekeeping_staging;",
            "\tunsigned int first_cpu;",
            "\tint err = 0;",
            "",
            "\tif ((flags & HK_FLAG_TICK) && !(housekeeping.flags & HK_FLAG_TICK)) {",
            "\t\tif (!IS_ENABLED(CONFIG_NO_HZ_FULL)) {",
            "\t\t\tpr_warn(\"Housekeeping: nohz unsupported.\"",
            "\t\t\t\t\" Build with CONFIG_NO_HZ_FULL\\n\");",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            "\talloc_bootmem_cpumask_var(&non_housekeeping_mask);",
            "\tif (cpulist_parse(str, non_housekeeping_mask) < 0) {",
            "\t\tpr_warn(\"Housekeeping: nohz_full= or isolcpus= incorrect CPU range\\n\");",
            "\t\tgoto free_non_housekeeping_mask;",
            "\t}",
            "",
            "\talloc_bootmem_cpumask_var(&housekeeping_staging);",
            "\tcpumask_andnot(housekeeping_staging,",
            "\t\t       cpu_possible_mask, non_housekeeping_mask);",
            "",
            "\tfirst_cpu = cpumask_first_and(cpu_present_mask, housekeeping_staging);",
            "\tif (first_cpu >= nr_cpu_ids || first_cpu >= setup_max_cpus) {",
            "\t\t__cpumask_set_cpu(smp_processor_id(), housekeeping_staging);",
            "\t\t__cpumask_clear_cpu(smp_processor_id(), non_housekeeping_mask);",
            "\t\tif (!housekeeping.flags) {",
            "\t\t\tpr_warn(\"Housekeeping: must include one present CPU, \"",
            "\t\t\t\t\"using boot CPU:%d\\n\", smp_processor_id());",
            "\t\t}",
            "\t}",
            "",
            "\tif (cpumask_empty(non_housekeeping_mask))",
            "\t\tgoto free_housekeeping_staging;",
            "",
            "\tif (!housekeeping.flags) {",
            "\t\t/* First setup call (\"nohz_full=\" or \"isolcpus=\") */",
            "\t\tenum hk_type type;",
            "",
            "\t\tfor_each_set_bit(type, &flags, HK_TYPE_MAX)",
            "\t\t\thousekeeping_setup_type(type, housekeeping_staging);",
            "\t} else {",
            "\t\t/* Second setup call (\"nohz_full=\" after \"isolcpus=\" or the reverse) */",
            "\t\tenum hk_type type;",
            "\t\tunsigned long iter_flags = flags & housekeeping.flags;",
            "",
            "\t\tfor_each_set_bit(type, &iter_flags, HK_TYPE_MAX) {",
            "\t\t\tif (!cpumask_equal(housekeeping_staging,",
            "\t\t\t\t\t   housekeeping.cpumasks[type])) {",
            "\t\t\t\tpr_warn(\"Housekeeping: nohz_full= must match isolcpus=\\n\");",
            "\t\t\t\tgoto free_housekeeping_staging;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\titer_flags = flags & ~housekeeping.flags;",
            "",
            "\t\tfor_each_set_bit(type, &iter_flags, HK_TYPE_MAX)",
            "\t\t\thousekeeping_setup_type(type, housekeeping_staging);",
            "\t}",
            "",
            "\tif ((flags & HK_FLAG_TICK) && !(housekeeping.flags & HK_FLAG_TICK))",
            "\t\ttick_nohz_full_setup(non_housekeeping_mask);",
            "",
            "\thousekeeping.flags |= flags;",
            "\terr = 1;",
            "",
            "free_housekeeping_staging:",
            "\tfree_bootmem_cpumask_var(housekeeping_staging);",
            "free_non_housekeeping_mask:",
            "\tfree_bootmem_cpumask_var(non_housekeeping_mask);",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "housekeeping_enabled, housekeeping_any_cpu, housekeeping_affine, housekeeping_test_cpu, housekeeping_init, housekeeping_setup_type, housekeeping_setup",
          "description": "实现了housekeeping相关核心逻辑，包括判断类型是否启用、查找可用CPU、设置任务亲和性、验证CPU归属等，同时负责初始化和配置不同类型housekeeping任务的CPU掩码。",
          "similarity": 0.5091044902801514
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/isolation.c",
          "start_line": 185,
          "end_line": 248,
          "content": [
            "static int __init housekeeping_nohz_full_setup(char *str)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tflags = HK_FLAG_TICK | HK_FLAG_WQ | HK_FLAG_TIMER | HK_FLAG_RCU |",
            "\t\tHK_FLAG_MISC | HK_FLAG_KTHREAD;",
            "",
            "\treturn housekeeping_setup(str, flags);",
            "}",
            "static int __init housekeeping_isolcpus_setup(char *str)",
            "{",
            "\tunsigned long flags = 0;",
            "\tbool illegal = false;",
            "\tchar *par;",
            "\tint len;",
            "",
            "\twhile (isalpha(*str)) {",
            "\t\tif (!strncmp(str, \"nohz,\", 5)) {",
            "\t\t\tstr += 5;",
            "\t\t\tflags |= HK_FLAG_TICK;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (!strncmp(str, \"domain,\", 7)) {",
            "\t\t\tstr += 7;",
            "\t\t\tflags |= HK_FLAG_DOMAIN;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (!strncmp(str, \"managed_irq,\", 12)) {",
            "\t\t\tstr += 12;",
            "\t\t\tflags |= HK_FLAG_MANAGED_IRQ;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Skip unknown sub-parameter and validate that it is not",
            "\t\t * containing an invalid character.",
            "\t\t */",
            "\t\tfor (par = str, len = 0; *str && *str != ','; str++, len++) {",
            "\t\t\tif (!isalpha(*str) && *str != '_')",
            "\t\t\t\tillegal = true;",
            "\t\t}",
            "",
            "\t\tif (illegal) {",
            "\t\t\tpr_warn(\"isolcpus: Invalid flag %.*s\\n\", len, par);",
            "\t\t\treturn 0;",
            "\t\t}",
            "",
            "\t\tpr_info(\"isolcpus: Skipped unknown flag %.*s\\n\", len, par);",
            "\t\tstr++;",
            "\t}",
            "",
            "\t/* Default behaviour for isolcpus without flags */",
            "\tif (!flags)",
            "\t\tflags |= HK_FLAG_DOMAIN;",
            "",
            "\treturn housekeeping_setup(str, flags);",
            "}",
            "static int __init enhanced_isolcpus_setup(char *str)",
            "{",
            "\tenhanced_isolcpus = true;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "housekeeping_nohz_full_setup, housekeeping_isolcpus_setup, enhanced_isolcpus_setup",
          "description": "提供命令行参数解析接口，通过housekeeping_nohz_full_setup和housekeeping_isolcpus_setup将参数转换为对应的标志位，调用housekeeping_setup完成CPU掩码配置，支持nohz_full和isolcpus特性。",
          "similarity": 0.48901283740997314
        }
      ]
    },
    {
      "source_file": "kernel/pid_namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:16:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid_namespace.c`\n\n---\n\n# `pid_namespace.c` 技术文档\n\n## 1. 文件概述\n\n`pid_namespace.c` 是 Linux 内核中实现 **PID 命名空间（PID Namespace）** 的核心源文件。PID 命名空间是 Linux 容器技术（如 Docker、LXC）的关键基础组件之一，用于为不同进程组提供隔离的进程 ID 视图。每个 PID 命名空间拥有独立的 PID 分配空间，使得不同命名空间中的进程可以拥有相同的 PID 而互不干扰。\n\n该文件负责 PID 命名空间的创建、销毁、引用计数管理、资源回收以及命名空间内进程的批量终止（如容器退出时清理所有子进程）等核心功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct pid_namespace`：表示一个 PID 命名空间，包含：\n  - `level`：命名空间层级（init_pid_ns 为 0，子命名空间依次递增）\n  - `parent`：指向父命名空间的指针\n  - `user_ns`：关联的用户命名空间\n  - `idr`：用于分配和管理 PID 的 IDR（整数到指针映射）结构\n  - `pid_cachep`：用于分配 `struct pid` 对象的 slab 缓存\n  - `pid_allocated`：当前命名空间中已分配的 PID 数量\n  - `ucounts`：用于限制用户命名空间下 PID 命名空间数量的计数器\n\n### 主要函数\n- `create_pid_cachep(unsigned int level)`  \n  为指定层级的 PID 命名空间创建专用的 `struct pid` slab 缓存。\n  \n- `create_pid_namespace(struct user_namespace *user_ns, struct pid_namespace *parent_pid_ns)`  \n  创建一个新的 PID 命名空间，设置层级、父命名空间、用户命名空间等属性，并初始化 IDR 和引用计数。\n\n- `copy_pid_ns(unsigned long flags, struct user_namespace *user_ns, struct pid_namespace *old_ns)`  \n  在 `clone()` 或 `unshare()` 系统调用中被调用，根据 `CLONE_NEWPID` 标志决定是否创建新的 PID 命名空间。\n\n- `put_pid_ns(struct pid_namespace *ns)`  \n  递减 PID 命名空间的引用计数，若引用计数归零则递归销毁该命名空间及其子命名空间。\n\n- `zap_pid_ns_processes(struct pid_namespace *pid_ns)`  \n  在 PID 命名空间的 init 进程退出时调用，向命名空间内所有剩余进程发送 `SIGKILL`，并等待其全部退出，确保命名空间干净回收。\n\n- `delayed_free_pidns(struct rcu_head *p)`  \n  通过 RCU 机制延迟释放 PID 命名空间结构体，确保所有并发读取完成后再释放内存。\n\n## 3. 关键实现\n\n### PID 命名空间层级与缓存管理\n- PID 命名空间支持嵌套，最大深度由 `MAX_PID_NS_LEVEL` 限制（通常为 32）。\n- 每个层级使用独立的 slab 缓存（`pid_cache[level - 1]`）来分配 `struct pid`，因为 `struct pid` 中的 `numbers[]` 数组大小依赖于命名空间层级（`level + 1`）。\n- 缓存创建通过 `create_pid_cachep()` 实现，使用互斥锁 `pid_caches_mutex` 避免并发创建冲突。\n\n### 引用计数与生命周期管理\n- 使用 `refcount_t` 管理命名空间引用计数。\n- `put_pid_ns()` 采用**尾递归方式**向上遍历父命名空间链，逐级释放无引用的命名空间。\n- 实际内存释放通过 RCU 回调 `delayed_free_pidns()` 延迟执行，保证并发安全。\n\n### 命名空间退出清理机制（`zap_pid_ns_processes`）\n- **禁用新 PID 分配**：调用 `disable_pid_allocation()` 阻止新进程加入。\n- **忽略 SIGCHLD**：使 init 进程自动回收僵尸子进程，避免阻塞。\n- **批量 SIGKILL**：遍历 IDR 中所有 PID，向对应进程发送 `SIGKILL`。\n- **等待所有进程退出**：通过 `kernel_wait4()` 回收直接子进程，并通过检查 `pid_allocated == init_pids` 确保所有进程（包括跨命名空间 fork 的僵尸进程）均已退出。\n- **RCU 安全调度**：在等待循环中调用 `exit_tasks_rcu_stop/start()` 避免与 `synchronize_rcu_tasks()` 死锁。\n\n### 资源限制\n- 通过 `inc_pid_namespaces()` / `dec_pid_namespaces()` 调用 `ucounts` 机制，限制每个用户命名空间可创建的 PID 命名空间数量，防止资源耗尽。\n\n## 4. 依赖关系\n\n- **`<linux/pid.h>` / `<linux/pid_namespace.h>`**：定义 `struct pid` 和 `struct pid_namespace`。\n- **`<linux/user_namespace.h>`**：依赖用户命名空间进行权限和资源限制。\n- **`<linux/idr.h>`**：使用 IDR 数据结构管理 PID 分配。\n- **`<linux/slab.h>`**：使用 kmem_cache 管理内存分配。\n- **`<linux/sched/*.h>`**：访问任务结构、信号处理、RCU 任务同步等。\n- **`<linux/proc_ns.h>`**：支持 `/proc/[pid]/ns/pid` 接口。\n- **`\"pid_sysctl.h\"`**：提供 sysctl 配置（如 `memfd_noexec_scope`）。\n- **`<linux/acct.h>`**：在命名空间销毁时清理进程会计信息。\n\n## 5. 使用场景\n\n- **容器启动**：当执行 `unshare(CLONE_NEWPID)` 或 `clone(CLONE_NEWPID)` 时，内核调用 `copy_pid_ns()` 创建新的 PID 命名空间，使容器内进程拥有独立的 PID 视图（容器内 PID 1 对应宿主机某个高 PID）。\n- **容器退出**：当容器的 init 进程（PID 1）退出时，内核自动调用 `zap_pid_ns_processes()` 终止命名空间内所有剩余进程，防止孤儿进程泄漏。\n- **命名空间嵌套**：支持多层容器或 sandbox 场景，如 systemd-nspawn 嵌套运行容器。\n- **资源隔离与限制**：结合用户命名空间，限制非特权用户创建过多 PID 命名空间，提升系统安全性。\n- **进程迁移与检查点**：配合 CRIU（Checkpoint/Restore in Userspace）等工具，通过 sysctl 接口控制命名空间行为（如 memfd 执行权限）。",
      "similarity": 0.5859175324440002,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/pid_namespace.c",
          "start_line": 68,
          "end_line": 208,
          "content": [
            "static void dec_pid_namespaces(struct ucounts *ucounts)",
            "{",
            "\tdec_ucount(ucounts, UCOUNT_PID_NAMESPACES);",
            "}",
            "static void delayed_free_pidns(struct rcu_head *p)",
            "{",
            "\tstruct pid_namespace *ns = container_of(p, struct pid_namespace, rcu);",
            "",
            "\tdec_pid_namespaces(ns->ucounts);",
            "\tput_user_ns(ns->user_ns);",
            "",
            "\tkmem_cache_free(pid_ns_cachep, ns);",
            "}",
            "static void destroy_pid_namespace(struct pid_namespace *ns)",
            "{",
            "\tns_free_inum(&ns->ns);",
            "",
            "\tidr_destroy(&ns->idr);",
            "\tcall_rcu(&ns->rcu, delayed_free_pidns);",
            "}",
            "void put_pid_ns(struct pid_namespace *ns)",
            "{",
            "\tstruct pid_namespace *parent;",
            "",
            "\twhile (ns != &init_pid_ns) {",
            "\t\tparent = ns->parent;",
            "\t\tif (!refcount_dec_and_test(&ns->ns.count))",
            "\t\t\tbreak;",
            "\t\tdestroy_pid_namespace(ns);",
            "\t\tns = parent;",
            "\t}",
            "}",
            "void zap_pid_ns_processes(struct pid_namespace *pid_ns)",
            "{",
            "\tint nr;",
            "\tint rc;",
            "\tstruct task_struct *task, *me = current;",
            "\tint init_pids = thread_group_leader(me) ? 1 : 2;",
            "\tstruct pid *pid;",
            "",
            "\t/* Don't allow any more processes into the pid namespace */",
            "\tdisable_pid_allocation(pid_ns);",
            "",
            "\t/*",
            "\t * Ignore SIGCHLD causing any terminated children to autoreap.",
            "\t * This speeds up the namespace shutdown, plus see the comment",
            "\t * below.",
            "\t */",
            "\tspin_lock_irq(&me->sighand->siglock);",
            "\tme->sighand->action[SIGCHLD - 1].sa.sa_handler = SIG_IGN;",
            "\tspin_unlock_irq(&me->sighand->siglock);",
            "",
            "\t/*",
            "\t * The last thread in the cgroup-init thread group is terminating.",
            "\t * Find remaining pid_ts in the namespace, signal and wait for them",
            "\t * to exit.",
            "\t *",
            "\t * Note:  This signals each threads in the namespace - even those that",
            "\t * \t  belong to the same thread group, To avoid this, we would have",
            "\t * \t  to walk the entire tasklist looking a processes in this",
            "\t * \t  namespace, but that could be unnecessarily expensive if the",
            "\t * \t  pid namespace has just a few processes. Or we need to",
            "\t * \t  maintain a tasklist for each pid namespace.",
            "\t *",
            "\t */",
            "\trcu_read_lock();",
            "\tread_lock(&tasklist_lock);",
            "\tnr = 2;",
            "\tidr_for_each_entry_continue(&pid_ns->idr, pid, nr) {",
            "\t\ttask = pid_task(pid, PIDTYPE_PID);",
            "\t\tif (task && !__fatal_signal_pending(task))",
            "\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, task, PIDTYPE_MAX);",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * Reap the EXIT_ZOMBIE children we had before we ignored SIGCHLD.",
            "\t * kernel_wait4() will also block until our children traced from the",
            "\t * parent namespace are detached and become EXIT_DEAD.",
            "\t */",
            "\tdo {",
            "\t\tclear_thread_flag(TIF_SIGPENDING);",
            "\t\tclear_thread_flag(TIF_NOTIFY_SIGNAL);",
            "\t\trc = kernel_wait4(-1, NULL, __WALL, NULL);",
            "\t} while (rc != -ECHILD);",
            "",
            "\t/*",
            "\t * kernel_wait4() misses EXIT_DEAD children, and EXIT_ZOMBIE",
            "\t * process whose parents processes are outside of the pid",
            "\t * namespace.  Such processes are created with setns()+fork().",
            "\t *",
            "\t * If those EXIT_ZOMBIE processes are not reaped by their",
            "\t * parents before their parents exit, they will be reparented",
            "\t * to pid_ns->child_reaper.  Thus pidns->child_reaper needs to",
            "\t * stay valid until they all go away.",
            "\t *",
            "\t * The code relies on the pid_ns->child_reaper ignoring",
            "\t * SIGCHILD to cause those EXIT_ZOMBIE processes to be",
            "\t * autoreaped if reparented.",
            "\t *",
            "\t * Semantically it is also desirable to wait for EXIT_ZOMBIE",
            "\t * processes before allowing the child_reaper to be reaped, as",
            "\t * that gives the invariant that when the init process of a",
            "\t * pid namespace is reaped all of the processes in the pid",
            "\t * namespace are gone.",
            "\t *",
            "\t * Once all of the other tasks are gone from the pid_namespace",
            "\t * free_pid() will awaken this task.",
            "\t */",
            "\tfor (;;) {",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\tif (pid_ns->pid_allocated == init_pids)",
            "\t\t\tbreak;",
            "\t\t/*",
            "\t\t * Release tasks_rcu_exit_srcu to avoid following deadlock:",
            "\t\t *",
            "\t\t * 1) TASK A unshare(CLONE_NEWPID)",
            "\t\t * 2) TASK A fork() twice -> TASK B (child reaper for new ns)",
            "\t\t *    and TASK C",
            "\t\t * 3) TASK B exits, kills TASK C, waits for TASK A to reap it",
            "\t\t * 4) TASK A calls synchronize_rcu_tasks()",
            "\t\t *                   -> synchronize_srcu(tasks_rcu_exit_srcu)",
            "\t\t * 5) *DEADLOCK*",
            "\t\t *",
            "\t\t * It is considered safe to release tasks_rcu_exit_srcu here",
            "\t\t * because we assume the current task can not be concurrently",
            "\t\t * reaped at this point.",
            "\t\t */",
            "\t\texit_tasks_rcu_stop();",
            "\t\tschedule();",
            "\t\texit_tasks_rcu_start();",
            "\t}",
            "\t__set_current_state(TASK_RUNNING);",
            "",
            "\tif (pid_ns->reboot)",
            "\t\tcurrent->signal->group_exit_code = pid_ns->reboot;",
            "",
            "\tacct_exit_ns(pid_ns);",
            "\treturn;",
            "}"
          ],
          "function_name": "dec_pid_namespaces, delayed_free_pidns, destroy_pid_namespace, put_pid_ns, zap_pid_ns_processes",
          "description": "包含销毁pid命名空间相关函数，其中destroy_pid_namespace通过RCU机制延迟释放资源，zap_pid_ns_processes强制终止命名空间内所有进程并回收资源，put_pid_ns管理命名空间引用计数",
          "similarity": 0.5269448757171631
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/pid_namespace.c",
          "start_line": 281,
          "end_line": 379,
          "content": [
            "static int pid_ns_ctl_handler(struct ctl_table *table, int write,",
            "\t\tvoid *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct pid_namespace *pid_ns = task_active_pid_ns(current);",
            "\tstruct ctl_table tmp = *table;",
            "\tint ret, next;",
            "",
            "\tif (write && !checkpoint_restore_ns_capable(pid_ns->user_ns))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Writing directly to ns' last_pid field is OK, since this field",
            "\t * is volatile in a living namespace anyway and a code writing to",
            "\t * it should synchronize its usage with external means.",
            "\t */",
            "",
            "\tnext = idr_get_cursor(&pid_ns->idr) - 1;",
            "",
            "\ttmp.data = &next;",
            "\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);",
            "\tif (!ret && write)",
            "\t\tidr_set_cursor(&pid_ns->idr, next + 1);",
            "",
            "\treturn ret;",
            "}",
            "int reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)",
            "{",
            "\tif (pid_ns == &init_pid_ns)",
            "\t\treturn 0;",
            "",
            "\tswitch (cmd) {",
            "\tcase LINUX_REBOOT_CMD_RESTART2:",
            "\tcase LINUX_REBOOT_CMD_RESTART:",
            "\t\tpid_ns->reboot = SIGHUP;",
            "\t\tbreak;",
            "",
            "\tcase LINUX_REBOOT_CMD_POWER_OFF:",
            "\tcase LINUX_REBOOT_CMD_HALT:",
            "\t\tpid_ns->reboot = SIGINT;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tsend_sig(SIGKILL, pid_ns->child_reaper, 1);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tdo_exit(0);",
            "",
            "\t/* Not reached */",
            "\treturn 0;",
            "}",
            "static void pidns_put(struct ns_common *ns)",
            "{",
            "\tput_pid_ns(to_pid_ns(ns));",
            "}",
            "static int pidns_install(struct nsset *nsset, struct ns_common *ns)",
            "{",
            "\tstruct nsproxy *nsproxy = nsset->nsproxy;",
            "\tstruct pid_namespace *active = task_active_pid_ns(current);",
            "\tstruct pid_namespace *ancestor, *new = to_pid_ns(ns);",
            "",
            "\tif (!ns_capable(new->user_ns, CAP_SYS_ADMIN) ||",
            "\t    !ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Only allow entering the current active pid namespace",
            "\t * or a child of the current active pid namespace.",
            "\t *",
            "\t * This is required for fork to return a usable pid value and",
            "\t * this maintains the property that processes and their",
            "\t * children can not escape their current pid namespace.",
            "\t */",
            "\tif (new->level < active->level)",
            "\t\treturn -EINVAL;",
            "",
            "\tancestor = new;",
            "\twhile (ancestor->level > active->level)",
            "\t\tancestor = ancestor->parent;",
            "\tif (ancestor != active)",
            "\t\treturn -EINVAL;",
            "",
            "\tput_pid_ns(nsproxy->pid_ns_for_children);",
            "\tnsproxy->pid_ns_for_children = get_pid_ns(new);",
            "\treturn 0;",
            "}",
            "static __init int pid_namespaces_init(void)",
            "{",
            "\tpid_ns_cachep = KMEM_CACHE(pid_namespace, SLAB_PANIC | SLAB_ACCOUNT);",
            "",
            "#ifdef CONFIG_CHECKPOINT_RESTORE",
            "\tregister_sysctl_init(\"kernel\", pid_ns_ctl_table);",
            "#endif",
            "",
            "\tregister_pid_ns_sysctl_table_vm();",
            "\treturn 0;",
            "}"
          ],
          "function_name": "pid_ns_ctl_handler, reboot_pid_ns, pidns_put, pidns_install, pid_namespaces_init",
          "description": "包含pid命名空间控制接口处理函数pid_ns_ctl_handler，reboot_pid_ns设置命名空间重启信号，pidns_install验证命名空间层级权限并进行安装操作，pid_namespaces_init完成核心数据结构初始化和sysctl注册",
          "similarity": 0.4966965615749359
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/pid_namespace.c",
          "start_line": 1,
          "end_line": 67,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Pid namespaces",
            " *",
            " * Authors:",
            " *    (C) 2007 Pavel Emelyanov <xemul@openvz.org>, OpenVZ, SWsoft Inc.",
            " *    (C) 2007 Sukadev Bhattiprolu <sukadev@us.ibm.com>, IBM",
            " *     Many thanks to Oleg Nesterov for comments and help",
            " *",
            " */",
            "",
            "#include <linux/pid.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cred.h>",
            "#include <linux/err.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/reboot.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/idr.h>",
            "#include <uapi/linux/wait.h>",
            "#include \"pid_sysctl.h\"",
            "",
            "static DEFINE_MUTEX(pid_caches_mutex);",
            "static struct kmem_cache *pid_ns_cachep;",
            "/* Write once array, filled from the beginning. */",
            "static struct kmem_cache *pid_cache[MAX_PID_NS_LEVEL];",
            "",
            "/*",
            " * creates the kmem cache to allocate pids from.",
            " * @level: pid namespace level",
            " */",
            "",
            "static struct kmem_cache *create_pid_cachep(unsigned int level)",
            "{",
            "\t/* Level 0 is init_pid_ns.pid_cachep */",
            "\tstruct kmem_cache **pkc = &pid_cache[level - 1];",
            "\tstruct kmem_cache *kc;",
            "\tchar name[4 + 10 + 1];",
            "\tunsigned int len;",
            "",
            "\tkc = READ_ONCE(*pkc);",
            "\tif (kc)",
            "\t\treturn kc;",
            "",
            "\tsnprintf(name, sizeof(name), \"pid_%u\", level + 1);",
            "\tlen = struct_size_t(struct pid, numbers, level + 1);",
            "\tmutex_lock(&pid_caches_mutex);",
            "\t/* Name collision forces to do allocation under mutex. */",
            "\tif (!*pkc)",
            "\t\t*pkc = kmem_cache_create(name, len, 0,",
            "\t\t\t\t\t SLAB_HWCACHE_ALIGN | SLAB_ACCOUNT, NULL);",
            "\tmutex_unlock(&pid_caches_mutex);",
            "\t/* current can fail, but someone else can succeed. */",
            "\treturn READ_ONCE(*pkc);",
            "}",
            "",
            "static struct ucounts *inc_pid_namespaces(struct user_namespace *ns)",
            "{",
            "\treturn inc_ucount(ns, current_euid(), UCOUNT_PID_NAMESPACES);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义用于管理pid命名空间的kmem缓存创建函数create_pid_cachep，根据层级参数为不同pid命名空间级别创建专用内存池；inc_pid_namespaces函数用于增加用户命名空间的使用计数",
          "similarity": 0.4877076745033264
        }
      ]
    },
    {
      "source_file": "kernel/cgroup/pids.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:50:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\pids.c`\n\n---\n\n# cgroup/pids.c 技术文档\n\n## 1. 文件概述\n\n`cgroup/pids.c` 实现了 Linux 内核中 cgroup 的 **PID 控制器（pids controller）**，用于限制指定 cgroup 及其子层级中可创建的最大进程（任务）数量。该控制器通过监控 `fork()` 系统调用，在进程数量即将超过设定阈值时拒绝创建新进程（返回 `-EAGAIN`），从而防止 PID 资源耗尽。该控制器支持层级继承语义，即子 cgroup 的有效限制为其自身与所有祖先中**最严格**的限制。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct pids_cgroup`**  \n  表示一个 cgroup 的 PID 控制状态，包含：\n  - `counter`：当前 cgroup 中的进程数量（64 位原子计数器）\n  - `limit`：允许的最大进程数（64 位原子值，`PIDS_MAX` 表示无限制）\n  - `watermark`：历史最高进程数（用于监控）\n  - `events` / `events_local`：事件计数器（如 `PIDCG_MAX`、`PIDCG_FORKFAIL`）\n  - `events_file` / `events_local_file`：用于通知用户空间事件发生的 cgroup 文件句柄\n\n- **`enum pidcg_event`**  \n  定义两类事件：\n  - `PIDCG_MAX`：因本 cgroup 或祖先限制被触发而导致 fork 失败\n  - `PIDCG_FORKFAIL`：在本 cgroup 中 fork 失败（用于本地事件通知）\n\n### 主要函数\n\n- **资源分配与释放**\n  - `pids_css_alloc()`：为新 cgroup 分配 `pids_cgroup` 结构，初始限制设为 `PIDS_MAX`（无限制）\n  - `pids_css_free()`：释放 `pids_cgroup` 结构\n\n- **计数操作**\n  - `pids_charge()`：**无条件**增加指定 cgroup 及其所有祖先的进程计数（用于回滚）\n  - `pids_uncharge()`：减少指定 cgroup 及其所有祖先的进程计数\n  - `pids_cancel()`：内部辅助函数，执行实际的原子减操作，并检查负值（视为 bug）\n  - `pids_try_charge()`：**有条件**增加计数，若任一祖先层级超过限制则回滚并返回 `-EAGAIN`\n\n- **cgroup 钩子函数**\n  - `pids_can_attach()`：在任务迁移到新 cgroup 时，更新源/目标 cgroup 的计数\n  - `pids_cancel_attach()`：回滚 `pids_can_attach()` 的操作\n  - `pids_can_fork()`：在 `fork()` 前检查是否允许创建新进程（未在提供的代码片段中完整显示）\n  - `pids_cancel_fork()`：回滚 fork 失败时的计数（未在提供的代码片段中完整显示）\n\n- **事件通知**\n  - `pids_event()`：当 fork 因 PID 限制失败时，记录事件并通知用户空间（通过 `cgroup_file_notify`）\n\n- **辅助函数**\n  - `css_pids()`：从 `cgroup_subsys_state` 转换为 `pids_cgroup`\n  - `parent_pids()`：获取父 cgroup 的 `pids_cgroup`\n  - `pids_update_watermark()`：更新历史最高进程数（非原子，容忍竞态）\n\n## 3. 关键实现\n\n### 层级限制语义\nPID 限制遵循 cgroup 的层级继承规则：一个进程的实际限制由其所在 cgroup 路径上**所有祖先中最小的 `limit` 值**决定。`pids_try_charge()` 在从当前 cgroup 向根方向遍历时，一旦发现任一祖先的 `counter + num > limit`，即判定为违反策略。\n\n### 原子计数与回滚机制\n- 所有计数操作均使用 `atomic64_t` 保证并发安全。\n- `pids_try_charge()` 采用“先增加后检查+回滚”策略：先原子增加所有祖先计数，再逐级检查是否超限。若超限，则从当前节点回滚到起始节点的所有增量。\n- `pids_charge()` 用于必须成功的场景（如 attach 回滚），**不检查限制**，允许临时超限。\n\n### 事件通知机制\n- 当 fork 因限制失败时，调用 `pids_event()`：\n  - 在 fork 发生的 cgroup 中记录 `PIDCG_FORKFAIL` 事件（仅首次触发时打印内核日志）\n  - 若启用了本地事件（通过 `cgroup v2` 的 `pids.local_events` 选项），则仅通知本地事件文件\n  - 否则，在**触发限制的祖先 cgroup** 中记录 `PIDCG_MAX` 事件，并向上传播通知\n\n### 无限制表示\n使用 `PIDS_MAX = PID_MAX_LIMIT + 1` 表示“无限制”，因为实际 PID 数量不可能超过 `PID_MAX_LIMIT`，因此该值可安全用于比较（`new > limit` 永远为假）。\n\n## 4. 依赖关系\n\n- **`<linux/cgroup.h>`**：cgroup 核心框架，提供 `cgroup_subsys_state`、`cgroup_taskset` 等基础结构和钩子函数接口\n- **`<linux/atomic.h>`**：提供 64 位原子操作（`atomic64_t`）\n- **`<linux/sched/task.h>`**：提供 `task_css()` 等任务与 cgroup 关联的接口\n- **`<linux/slab.h>`**：内存分配（`kzalloc`/`kfree`）\n- **`pids_cgrp_id`**：全局子系统 ID，用于从 `css_set` 或 `task_struct` 中获取 PID 控制器状态\n- **`cgroup_threadgroup_change_begin()`**：确保在 `fork` 过程中 cgroup 关联稳定（`pids_can_fork` 依赖此锁）\n\n## 5. 使用场景\n\n1. **容器资源隔离**  \n   在容器运行时（如 Docker、Podman）中限制单个容器或 Pod 可创建的最大进程数，防止 fork bomb 耗尽系统 PID 资源。\n\n2. **多租户系统防护**  \n   在共享主机环境中，为不同用户或服务分配独立的 cgroup，并设置 PID 限制，避免某一用户进程泛滥影响其他用户。\n\n3. **系统稳定性保障**  \n   通过全局或关键服务 cgroup 设置 PID 上限，确保即使某个子系统异常，也不会导致整个系统因 PID 耗尽而无法创建新进程。\n\n4. **监控与告警**  \n   通过读取 `pids.current`、`pids.max` 和 `pids.events` 文件，监控进程使用情况并在接近或达到限制时触发告警。",
      "similarity": 0.582558274269104,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 243,
          "end_line": 344,
          "content": [
            "static void pids_event(struct pids_cgroup *pids_forking,",
            "\t\t       struct pids_cgroup *pids_over_limit)",
            "{",
            "\tstruct pids_cgroup *p = pids_forking;",
            "",
            "\t/* Only log the first time limit is hit. */",
            "\tif (atomic64_inc_return(&p->events_local[PIDCG_FORKFAIL]) == 1) {",
            "\t\tpr_info(\"cgroup: fork rejected by pids controller in \");",
            "\t\tpr_cont_cgroup_path(p->css.cgroup);",
            "\t\tpr_cont(\"\\n\");",
            "\t}",
            "\tif (!cgroup_subsys_on_dfl(pids_cgrp_subsys) ||",
            "\t    cgrp_dfl_root.flags & CGRP_ROOT_PIDS_LOCAL_EVENTS) {",
            "\t\tcgroup_file_notify(&p->events_local_file);",
            "\t\treturn;",
            "\t}",
            "",
            "\tatomic64_inc(&pids_over_limit->events_local[PIDCG_MAX]);",
            "\tcgroup_file_notify(&pids_over_limit->events_local_file);",
            "",
            "\tfor (p = pids_over_limit; parent_pids(p); p = parent_pids(p)) {",
            "\t\tatomic64_inc(&p->events[PIDCG_MAX]);",
            "\t\tcgroup_file_notify(&p->events_file);",
            "\t}",
            "}",
            "static int pids_can_fork(struct task_struct *task, struct css_set *cset)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct pids_cgroup *pids, *pids_over_limit;",
            "\tint err;",
            "",
            "\tif (cset)",
            "\t\tcss = cset->subsys[pids_cgrp_id];",
            "\telse",
            "\t\tcss = task_css_check(current, pids_cgrp_id, true);",
            "\tpids = css_pids(css);",
            "\terr = pids_try_charge(pids, 1, &pids_over_limit);",
            "\tif (err)",
            "\t\tpids_event(pids, pids_over_limit);",
            "",
            "\treturn err;",
            "}",
            "static void pids_cancel_fork(struct task_struct *task, struct css_set *cset)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct pids_cgroup *pids;",
            "",
            "\tif (cset)",
            "\t\tcss = cset->subsys[pids_cgrp_id];",
            "\telse",
            "\t\tcss = task_css_check(current, pids_cgrp_id, true);",
            "\tpids = css_pids(css);",
            "\tpids_uncharge(pids, 1);",
            "}",
            "static void pids_release(struct task_struct *task)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(task_css(task, pids_cgrp_id));",
            "",
            "\tpids_uncharge(pids, 1);",
            "}",
            "static ssize_t pids_max_write(struct kernfs_open_file *of, char *buf,",
            "\t\t\t      size_t nbytes, loff_t off)",
            "{",
            "\tstruct cgroup_subsys_state *css = of_css(of);",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "\tint64_t limit;",
            "\tint err;",
            "",
            "\tbuf = strstrip(buf);",
            "\tif (!strcmp(buf, PIDS_MAX_STR)) {",
            "\t\tlimit = PIDS_MAX;",
            "\t\tgoto set_limit;",
            "\t}",
            "",
            "\terr = kstrtoll(buf, 0, &limit);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif (limit < 0 || limit >= PIDS_MAX)",
            "\t\treturn -EINVAL;",
            "",
            "set_limit:",
            "\t/*",
            "\t * Limit updates don't need to be mutex'd, since it isn't",
            "\t * critical that any racing fork()s follow the new limit.",
            "\t */",
            "\tatomic64_set(&pids->limit, limit);",
            "\treturn nbytes;",
            "}",
            "static int pids_max_show(struct seq_file *sf, void *v)",
            "{",
            "\tstruct cgroup_subsys_state *css = seq_css(sf);",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "\tint64_t limit = atomic64_read(&pids->limit);",
            "",
            "\tif (limit >= PIDS_MAX)",
            "\t\tseq_printf(sf, \"%s\\n\", PIDS_MAX_STR);",
            "\telse",
            "\t\tseq_printf(sf, \"%lld\\n\", limit);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "pids_event, pids_can_fork, pids_cancel_fork, pids_release, pids_max_write, pids_max_show",
          "description": "处理进程创建时的配额检查与事件记录，包含can_fork检查、取消fork操作、任务释放及最大进程数配置接口。当达到硬限制时触发事件通知并拒绝fork请求。",
          "similarity": 0.5994419455528259
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 91,
          "end_line": 202,
          "content": [
            "static void pids_css_free(struct cgroup_subsys_state *css)",
            "{",
            "\tkfree(css_pids(css));",
            "}",
            "static void pids_update_watermark(struct pids_cgroup *p, int64_t nr_pids)",
            "{",
            "\t/*",
            "\t * This is racy, but we don't need perfectly accurate tallying of",
            "\t * the watermark, and this lets us avoid extra atomic overhead.",
            "\t */",
            "\tif (nr_pids > READ_ONCE(p->watermark))",
            "\t\tWRITE_ONCE(p->watermark, nr_pids);",
            "}",
            "static void pids_cancel(struct pids_cgroup *pids, int num)",
            "{",
            "\t/*",
            "\t * A negative count (or overflow for that matter) is invalid,",
            "\t * and indicates a bug in the `pids` controller proper.",
            "\t */",
            "\tWARN_ON_ONCE(atomic64_add_negative(-num, &pids->counter));",
            "}",
            "static void pids_uncharge(struct pids_cgroup *pids, int num)",
            "{",
            "\tstruct pids_cgroup *p;",
            "",
            "\tfor (p = pids; parent_pids(p); p = parent_pids(p))",
            "\t\tpids_cancel(p, num);",
            "}",
            "static void pids_charge(struct pids_cgroup *pids, int num)",
            "{",
            "\tstruct pids_cgroup *p;",
            "",
            "\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {",
            "\t\tint64_t new = atomic64_add_return(num, &p->counter);",
            "",
            "\t\tpids_update_watermark(p, new);",
            "\t}",
            "}",
            "static int pids_try_charge(struct pids_cgroup *pids, int num, struct pids_cgroup **fail)",
            "{",
            "\tstruct pids_cgroup *p, *q;",
            "",
            "\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {",
            "\t\tint64_t new = atomic64_add_return(num, &p->counter);",
            "\t\tint64_t limit = atomic64_read(&p->limit);",
            "",
            "\t\t/*",
            "\t\t * Since new is capped to the maximum number of pid_t, if",
            "\t\t * p->limit is %PIDS_MAX then we know that this test will never",
            "\t\t * fail.",
            "\t\t */",
            "\t\tif (new > limit) {",
            "\t\t\t*fail = p;",
            "\t\t\tgoto revert;",
            "\t\t}",
            "\t\t/*",
            "\t\t * Not technically accurate if we go over limit somewhere up",
            "\t\t * the hierarchy, but that's tolerable for the watermark.",
            "\t\t */",
            "\t\tpids_update_watermark(p, new);",
            "\t}",
            "",
            "\treturn 0;",
            "",
            "revert:",
            "\tfor (q = pids; q != p; q = parent_pids(q))",
            "\t\tpids_cancel(q, num);",
            "\tpids_cancel(p, num);",
            "",
            "\treturn -EAGAIN;",
            "}",
            "static int pids_can_attach(struct cgroup_taskset *tset)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct cgroup_subsys_state *dst_css;",
            "",
            "\tcgroup_taskset_for_each(task, dst_css, tset) {",
            "\t\tstruct pids_cgroup *pids = css_pids(dst_css);",
            "\t\tstruct cgroup_subsys_state *old_css;",
            "\t\tstruct pids_cgroup *old_pids;",
            "",
            "\t\t/*",
            "\t\t * No need to pin @old_css between here and cancel_attach()",
            "\t\t * because cgroup core protects it from being freed before",
            "\t\t * the migration completes or fails.",
            "\t\t */",
            "\t\told_css = task_css(task, pids_cgrp_id);",
            "\t\told_pids = css_pids(old_css);",
            "",
            "\t\tpids_charge(pids, 1);",
            "\t\tpids_uncharge(old_pids, 1);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void pids_cancel_attach(struct cgroup_taskset *tset)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct cgroup_subsys_state *dst_css;",
            "",
            "\tcgroup_taskset_for_each(task, dst_css, tset) {",
            "\t\tstruct pids_cgroup *pids = css_pids(dst_css);",
            "\t\tstruct cgroup_subsys_state *old_css;",
            "\t\tstruct pids_cgroup *old_pids;",
            "",
            "\t\told_css = task_css(task, pids_cgrp_id);",
            "\t\told_pids = css_pids(old_css);",
            "",
            "\t\tpids_charge(old_pids, 1);",
            "\t\tpids_uncharge(pids, 1);",
            "\t}",
            "}"
          ],
          "function_name": "pids_css_free, pids_update_watermark, pids_cancel, pids_uncharge, pids_charge, pids_try_charge, pids_can_attach, pids_cancel_attach",
          "description": "实现了pids控制器的资源充放电逻辑，包含分配/释放CSS结构、更新水位线、充放电操作及附件检查等功能。通过遍历祖先cgroup进行全局资源追踪，确保层级间限制一致性。",
          "similarity": 0.4990788698196411
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 1,
          "end_line": 90,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Process number limiting controller for cgroups.",
            " *",
            " * Used to allow a cgroup hierarchy to stop any new processes from fork()ing",
            " * after a certain limit is reached.",
            " *",
            " * Since it is trivial to hit the task limit without hitting any kmemcg limits",
            " * in place, PIDs are a fundamental resource. As such, PID exhaustion must be",
            " * preventable in the scope of a cgroup hierarchy by allowing resource limiting",
            " * of the number of tasks in a cgroup.",
            " *",
            " * In order to use the `pids` controller, set the maximum number of tasks in",
            " * pids.max (this is not available in the root cgroup for obvious reasons). The",
            " * number of processes currently in the cgroup is given by pids.current.",
            " * Organisational operations are not blocked by cgroup policies, so it is",
            " * possible to have pids.current > pids.max. However, it is not possible to",
            " * violate a cgroup policy through fork(). fork() will return -EAGAIN if forking",
            " * would cause a cgroup policy to be violated.",
            " *",
            " * To set a cgroup to have no limit, set pids.max to \"max\". This is the default",
            " * for all new cgroups (N.B. that PID limits are hierarchical, so the most",
            " * stringent limit in the hierarchy is followed).",
            " *",
            " * pids.current tracks all child cgroup hierarchies, so parent/pids.current is",
            " * a superset of parent/child/pids.current.",
            " *",
            " * Copyright (C) 2015 Aleksa Sarai <cyphar@cyphar.com>",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/threads.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "",
            "#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)",
            "#define PIDS_MAX_STR \"max\"",
            "",
            "enum pidcg_event {",
            "\t/* Fork failed in subtree because this pids_cgroup limit was hit. */",
            "\tPIDCG_MAX,",
            "\t/* Fork failed in this pids_cgroup because ancestor limit was hit. */",
            "\tPIDCG_FORKFAIL,",
            "\tNR_PIDCG_EVENTS,",
            "};",
            "",
            "struct pids_cgroup {",
            "\tstruct cgroup_subsys_state\tcss;",
            "",
            "\t/*",
            "\t * Use 64-bit types so that we can safely represent \"max\" as",
            "\t * %PIDS_MAX = (%PID_MAX_LIMIT + 1).",
            "\t */",
            "\tatomic64_t\t\t\tcounter;",
            "\tatomic64_t\t\t\tlimit;",
            "\tint64_t\t\t\t\twatermark;",
            "",
            "\t/* Handles for pids.events[.local] */",
            "\tstruct cgroup_file\t\tevents_file;",
            "\tstruct cgroup_file\t\tevents_local_file;",
            "",
            "\tatomic64_t\t\t\tevents[NR_PIDCG_EVENTS];",
            "\tatomic64_t\t\t\tevents_local[NR_PIDCG_EVENTS];",
            "};",
            "",
            "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)",
            "{",
            "\treturn container_of(css, struct pids_cgroup, css);",
            "}",
            "",
            "static struct pids_cgroup *parent_pids(struct pids_cgroup *pids)",
            "{",
            "\treturn css_pids(pids->css.parent);",
            "}",
            "",
            "static struct cgroup_subsys_state *",
            "pids_css_alloc(struct cgroup_subsys_state *parent)",
            "{",
            "\tstruct pids_cgroup *pids;",
            "",
            "\tpids = kzalloc(sizeof(struct pids_cgroup), GFP_KERNEL);",
            "\tif (!pids)",
            "\t\treturn ERR_PTR(-ENOMEM);",
            "",
            "\tatomic64_set(&pids->limit, PIDS_MAX);",
            "\treturn &pids->css;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了cgroup的pids控制器核心结构体pids_cgroup，包含原子计数器、限制值和事件统计字段，用于跟踪任务数量以防止进程爆炸。通过CSS子系统状态关联到cgroup层级，支持基于层级的资源限制。",
          "similarity": 0.4947412610054016
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 355,
          "end_line": 394,
          "content": [
            "static s64 pids_current_read(struct cgroup_subsys_state *css,",
            "\t\t\t     struct cftype *cft)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "",
            "\treturn atomic64_read(&pids->counter);",
            "}",
            "static s64 pids_peak_read(struct cgroup_subsys_state *css,",
            "\t\t\t  struct cftype *cft)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "",
            "\treturn READ_ONCE(pids->watermark);",
            "}",
            "static int __pids_events_show(struct seq_file *sf, bool local)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(seq_css(sf));",
            "\tenum pidcg_event pe = PIDCG_MAX;",
            "\tatomic64_t *events;",
            "",
            "\tif (!cgroup_subsys_on_dfl(pids_cgrp_subsys) ||",
            "\t    cgrp_dfl_root.flags & CGRP_ROOT_PIDS_LOCAL_EVENTS) {",
            "\t\tpe = PIDCG_FORKFAIL;",
            "\t\tlocal = true;",
            "\t}",
            "\tevents = local ? pids->events_local : pids->events;",
            "",
            "\tseq_printf(sf, \"max %lld\\n\", (s64)atomic64_read(&events[pe]));",
            "\treturn 0;",
            "}",
            "static int pids_events_show(struct seq_file *sf, void *v)",
            "{",
            "\t__pids_events_show(sf, false);",
            "\treturn 0;",
            "}",
            "static int pids_events_local_show(struct seq_file *sf, void *v)",
            "{",
            "\t__pids_events_show(sf, true);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "pids_current_read, pids_peak_read, __pids_events_show, pids_events_show, pids_events_local_show",
          "description": "暴露pids控制器的监控接口，包括当前任务数读取、历史峰值查询及事件统计展示。通过seq_file接口向用户空间导出运行时统计数据。",
          "similarity": 0.4881588816642761
        }
      ]
    }
  ]
}