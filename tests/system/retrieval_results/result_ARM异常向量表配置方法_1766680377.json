{
  "query": "ARM异常向量表配置方法",
  "timestamp": "2025-12-26 00:32:57",
  "retrieved_files": [
    {
      "source_file": "mm/fail_page_alloc.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:59:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `fail_page_alloc.c`\n\n---\n\n# `fail_page_alloc.c` 技术文档\n\n## 1. 文件概述\n\n`fail_page_alloc.c` 是 Linux 内核中用于实现内存页分配故障注入（fault injection）机制的模块。该文件通过模拟 `alloc_pages()` 等内存分配函数失败的情形，帮助开发者测试内核在内存分配失败时的错误处理路径和健壮性。它基于通用的故障注入框架（`fault-inject.h`），并提供了运行时可配置的控制参数。\n\n## 2. 核心功能\n\n### 数据结构\n- **`fail_page_alloc`**：全局静态结构体，包含：\n  - `attr`：标准的 `fault_attr` 故障属性，用于控制故障注入的概率、间隔等行为。\n  - `ignore_gfp_highmem`：布尔值，若为 `true`，则忽略带有 `__GFP_HIGHMEM` 标志的分配请求。\n  - `ignore_gfp_reclaim`：布尔值，若为 `true`，则忽略带有 `__GFP_DIRECT_RECLAIM` 标志的分配请求。\n  - `min_order`：无符号 32 位整数，指定只对大于等于此阶数（order）的页分配进行故障注入。\n\n### 主要函数\n- **`setup_fail_page_alloc(char *str)`**：内核启动参数解析函数，用于通过 `fail_page_alloc=` 内核命令行参数初始化故障属性。\n- **`should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)`**：核心判断函数，根据当前分配请求的 `gfp_mask` 和 `order` 决定是否注入分配失败。\n- **`fail_page_alloc_debugfs(void)`**（条件编译）：在启用了 `CONFIG_FAULT_INJECTION_DEBUG_FS` 时，创建 debugfs 接口以动态调整故障注入参数。\n\n### 宏与注解\n- **`__setup(\"fail_page_alloc=\", setup_fail_page_alloc)`**：注册内核启动参数处理函数。\n- **`ALLOW_ERROR_INJECTION(should_fail_alloc_page, TRUE)`**：声明该函数可被错误注入框架拦截，支持动态启用/禁用。\n\n## 3. 关键实现\n\n- **故障注入条件判断**：\n  - 仅当请求的 `order >= min_order` 时才考虑注入失败。\n  - 若分配标志包含 `__GFP_NOFAIL`（表示分配必须成功），则跳过注入。\n  - 可选择性忽略高内存（`__GFP_HIGHMEM`）或直接回收（`__GFP_DIRECT_RECLAIM`）类型的分配请求。\n  - 若分配请求设置了 `__GFP_NOWARN`，则传递 `FAULT_NOWARN` 标志给底层故障注入逻辑，避免打印警告信息。\n\n- **debugfs 接口**（当 `CONFIG_FAULT_INJECTION_DEBUG_FS` 启用时）：\n  - 在 `/sys/kernel/debug/fail_page_alloc/` 目录下创建以下可调参数：\n    - `ignore-gfp-wait`：对应 `ignore_gfp_reclaim`（注：变量名与 debugfs 名称存在历史命名差异，实际控制 `__GFP_DIRECT_RECLAIM`）。\n    - `ignore-gfp-highmem`：控制是否忽略高内存分配。\n    - `min-order`：设置最小注入阶数。\n\n- **故障决策**：最终调用 `should_fail_ex()`，传入按 `order` 缩放的权重（`1 << order`），使得大块内存分配更容易被注入失败，更贴近真实场景。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/fault-inject.h>`：提供通用故障注入框架（如 `fault_attr`, `should_fail_ex`, `setup_fault_attr` 等）。\n  - `<linux/error-injection.h>`：提供 `ALLOW_ERROR_INJECTION` 宏，用于支持动态错误注入。\n  - `<linux/mm.h>`：提供内存管理相关定义，如 `gfp_t`、`__GFP_*` 标志等。\n\n- **内核配置依赖**：\n  - 必须启用 `CONFIG_FAULT_INJECTION` 才能使用基础故障注入功能。\n  - `CONFIG_FAULT_INJECTION_DEBUG_FS` 控制是否生成 debugfs 接口。\n\n- **调用关系**：\n  - `should_fail_alloc_page()` 被内存分配路径（如 `__alloc_pages()`）调用，通常通过 `__alloc_pages_nodemask()` 中的 `should_fail_alloc_page()` 检查点触发。\n\n## 5. 使用场景\n\n- **内核开发与测试**：\n  - 开发者可通过内核启动参数（如 `fail_page_alloc=10`）或 debugfs 接口动态开启页分配失败模拟，验证内核路径在内存不足时的行为。\n  - 用于测试文件系统、网络子系统、设备驱动等模块在 `kmalloc`/`alloc_pages` 失败时的错误恢复能力。\n\n- **压力测试与稳定性验证**：\n  - 结合 `failslab` 等其他故障注入模块，构建全面的内存压力测试环境。\n  - 验证 `__GFP_NOFAIL` 等关键分配是否被正确处理，防止死锁或崩溃。\n\n- **调试特定问题**：\n  - 当怀疑某段代码未正确处理内存分配失败时，可针对性地启用该模块，复现并定位问题。",
      "similarity": 0.5678247213363647,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/fail_page_alloc.c",
          "start_line": 1,
          "end_line": 18,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/fault-inject.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/mm.h>",
            "",
            "static struct {",
            "\tstruct fault_attr attr;",
            "",
            "\tbool ignore_gfp_highmem;",
            "\tbool ignore_gfp_reclaim;",
            "\tu32 min_order;",
            "} fail_page_alloc = {",
            "\t.attr = FAULT_ATTR_INITIALIZER,",
            "\t.ignore_gfp_reclaim = true,",
            "\t.ignore_gfp_highmem = true,",
            "\t.min_order = 1,",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义了一个用于配置页面分配错误注入的结构体fail_page_alloc，包含故障属性、忽略GFP标志位和最小订单等参数，用于控制内存分配失败测试场景。",
          "similarity": 0.5657978057861328
        },
        {
          "chunk_id": 1,
          "file_path": "mm/fail_page_alloc.c",
          "start_line": 19,
          "end_line": 58,
          "content": [
            "static int __init setup_fail_page_alloc(char *str)",
            "{",
            "\treturn setup_fault_attr(&fail_page_alloc.attr, str);",
            "}",
            "bool should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)",
            "{",
            "\tint flags = 0;",
            "",
            "\tif (order < fail_page_alloc.min_order)",
            "\t\treturn false;",
            "\tif (gfp_mask & __GFP_NOFAIL)",
            "\t\treturn false;",
            "\tif (fail_page_alloc.ignore_gfp_highmem && (gfp_mask & __GFP_HIGHMEM))",
            "\t\treturn false;",
            "\tif (fail_page_alloc.ignore_gfp_reclaim &&",
            "\t\t\t(gfp_mask & __GFP_DIRECT_RECLAIM))",
            "\t\treturn false;",
            "",
            "\t/* See comment in __should_failslab() */",
            "\tif (gfp_mask & __GFP_NOWARN)",
            "\t\tflags |= FAULT_NOWARN;",
            "",
            "\treturn should_fail_ex(&fail_page_alloc.attr, 1 << order, flags);",
            "}",
            "static int __init fail_page_alloc_debugfs(void)",
            "{",
            "\tumode_t mode = S_IFREG | 0600;",
            "\tstruct dentry *dir;",
            "",
            "\tdir = fault_create_debugfs_attr(\"fail_page_alloc\", NULL,",
            "\t\t\t\t\t&fail_page_alloc.attr);",
            "",
            "\tdebugfs_create_bool(\"ignore-gfp-wait\", mode, dir,",
            "\t\t\t    &fail_page_alloc.ignore_gfp_reclaim);",
            "\tdebugfs_create_bool(\"ignore-gfp-highmem\", mode, dir,",
            "\t\t\t    &fail_page_alloc.ignore_gfp_highmem);",
            "\tdebugfs_create_u32(\"min-order\", mode, dir, &fail_page_alloc.min_order);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "setup_fail_page_alloc, should_fail_alloc_page, fail_page_alloc_debugfs",
          "description": "实现了页面分配错误注入的初始化、判定逻辑和调试接口，通过解析命令行参数、检查GFP标志位及订单大小，决定是否模拟页面分配失败，并提供调试文件系统配置接口。",
          "similarity": 0.5086852312088013
        }
      ]
    },
    {
      "source_file": "kernel/irq/affinity.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:46:53\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\affinity.c`\n\n---\n\n# `irq/affinity.c` 技术文档\n\n## 1. 文件概述\n\n`irq/affinity.c` 是 Linux 内核中用于管理中断亲和性（IRQ affinity）的核心实现文件，主要负责为多队列设备（如多队列网卡、NVMe SSD 等）动态生成合理的 CPU 亲和性掩码（cpumask），以实现中断在多个 CPU 核心上的均衡分布。该文件提供了两个关键接口：  \n- `irq_create_affinity_masks()`：根据设备需求和系统 CPU 拓扑，生成每中断向量对应的 CPU 亲和性掩码。  \n- `irq_calc_affinity_vectors()`：计算在给定约束下可有效用于亲和性分配的最优中断向量数量。  \n\n该机制支持将中断向量划分为多个“集合”（sets），每个集合可独立分配 CPU 资源，适用于需要分层或分组中断处理的复杂设备。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`irq_create_affinity_masks(unsigned int nvecs, struct irq_affinity *affd)`**  \n  为指定数量的中断向量生成亲和性掩码数组。支持预定义（pre_vectors）、可管理（managed）和后置（post_vectors）三类中断向量，并通过 `group_cpus_evenly()` 实现 CPU 均匀分配。\n\n- **`irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec, const struct irq_affinity *affd)`**  \n  在 `[minvec, maxvec]` 范围内计算可用于亲和性分配的最优中断向量总数，考虑设备保留向量和系统 CPU 数量限制。\n\n### 关键数据结构\n\n- **`struct irq_affinity`**（定义于 `<linux/interrupt.h>`）  \n  描述中断亲和性分配需求：\n  - `pre_vectors` / `post_vectors`：保留的前后固定向量数（通常用于管理或特殊用途）。\n  - `calc_sets`：回调函数，用于自定义如何将可分配向量划分为多个集合（sets）。\n  - `nr_sets` / `set_size[]`：由 `calc_sets` 填充，表示集合数量及每个集合的向量数。\n\n- **`struct irq_affinity_desc`**（定义于 `<linux/interrupt.h>`）  \n  单个中断向量的亲和性描述：\n  - `mask`：该向量绑定的 CPU 掩码。\n  - `is_managed`：标志位，表示该向量是否由内核自动管理亲和性。\n\n### 辅助函数\n\n- **`default_calc_sets(struct irq_affinity *affd, unsigned int affvecs)`**  \n  默认的集合划分策略：将所有可分配向量归入单个集合。\n\n## 3. 关键实现\n\n### 亲和性掩码生成流程（`irq_create_affinity_masks`）\n\n1. **计算可分配向量数**：  \n   `affvecs = nvecs - pre_vectors - post_vectors`，若结果 ≤0 则无需分配。\n\n2. **设置集合划分策略**：  \n   若用户未提供 `calc_sets` 回调，则使用 `default_calc_sets`（单集合）。\n\n3. **生成每集合的 CPU 掩码**：  \n   对每个集合调用 `group_cpus_evenly(this_vecs)`，该函数根据系统 CPU 拓扑（如 NUMA、超线程）将 `this_vecs` 个中断均匀分配到物理 CPU 上，返回一个 `cpumask` 数组。\n\n4. **填充掩码数组**：  \n   - 前 `pre_vectors` 个向量：使用全局默认亲和性 `irq_default_affinity`。\n   - 中间 `affvecs` 个向量：按集合依次填充 `group_cpus_evenly` 的结果。\n   - 后 `post_vectors` 个向量：同样使用默认亲和性。\n   - 标记 `pre_vectors` 到 `nvecs - post_vectors` 之间的向量为 `is_managed = 1`。\n\n### 向量数量计算（`irq_calc_affinity_vectors`）\n\n- 若设备保留向量数（`resv = pre + post`）超过 `minvec`，返回 0（无法满足最小需求）。\n- 若提供 `calc_sets` 回调，则最大可分配向量数为 `maxvec - resv`。\n- 否则，以系统可能 CPU 数（`cpu_possible_mask`）为上限。\n- 最终结果：`resv + min(可分配向量上限, maxvec - resv)`。\n\n### 错误处理\n\n- 集合数超过 `IRQ_AFFINITY_MAX_SETS`（通常为 4）时触发 `WARN_ON_ONCE` 并返回 `NULL`。\n- 内存分配失败或 `group_cpus_evenly` 失败时释放已分配资源并返回 `NULL`。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/interrupt.h>`：定义 `irq_affinity`、`irq_affinity_desc` 等核心结构。\n  - `<linux/group_cpus.h>`：提供 `group_cpus_evenly()` 函数，实现基于拓扑的 CPU 分组。\n  - `<linux/cpu.h>`：访问 CPU 掩码（如 `cpu_possible_mask`）和锁机制（`cpus_read_lock/unlock`）。\n  - `<linux/slab.h>`：内存分配（`kcalloc`/`kfree`）。\n  - `<linux/kernel.h>`：基础内核 API（如 `WARN_ON_ONCE`、`min` 宏）。\n\n- **内核子系统**：\n  - **中断子系统**：与 `irqdesc`、`irqdomain` 等模块协同工作。\n  - **CPU 拓扑管理**：依赖 `group_cpus_evenly` 的底层实现（位于 `kernel/cpu.c`），该函数利用调度域（sched domain）信息进行 CPU 分组。\n\n## 5. 使用场景\n\n- **多队列设备驱动初始化**：  \n  网卡（如 `ixgbe`、`mlx5`）、NVMe SSD 等驱动在申请 MSI-X 中断时，调用 `irq_create_affinity_masks` 生成亲和性掩码，再通过 `pci_alloc_irq_vectors_affinity()` 申请中断，实现中断在 CPU 间的负载均衡。\n\n- **动态中断向量调整**：  \n  设备在运行时调整队列数量时，通过 `irq_calc_affinity_vectors` 计算可用向量数，确保不超过硬件和系统限制。\n\n- **NUMA 感知中断分配**：  \n  `group_cpus_evenly` 自动考虑 NUMA 节点拓扑，使同一队列的中断优先分配到同一 NUMA 节点的 CPU，减少跨节点访问延迟。\n\n- **保留中断向量处理**：  \n  设备可保留部分向量用于管理任务（如 `pre_vectors` 用于控制队列，`post_vectors` 用于错误处理），其余向量交由内核自动分配亲和性。",
      "similarity": 0.5652455687522888,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/affinity.c",
          "start_line": 12,
          "end_line": 35,
          "content": [
            "static void default_calc_sets(struct irq_affinity *affd, unsigned int affvecs)",
            "{",
            "\taffd->nr_sets = 1;",
            "\taffd->set_size[0] = affvecs;",
            "}",
            "unsigned int irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec,",
            "\t\t\t\t       const struct irq_affinity *affd)",
            "{",
            "\tunsigned int resv = affd->pre_vectors + affd->post_vectors;",
            "\tunsigned int set_vecs;",
            "",
            "\tif (resv > minvec)",
            "\t\treturn 0;",
            "",
            "\tif (affd->calc_sets) {",
            "\t\tset_vecs = maxvec - resv;",
            "\t} else {",
            "\t\tcpus_read_lock();",
            "\t\tset_vecs = cpumask_weight(cpu_possible_mask);",
            "\t\tcpus_read_unlock();",
            "\t}",
            "",
            "\treturn resv + min(set_vecs, maxvec - resv);",
            "}"
          ],
          "function_name": "default_calc_sets, irq_calc_affinity_vectors",
          "description": "定义默认亲和性集合计算函数并实现向量分配策略，用于确定中断向量在CPU核心间的分布方式",
          "similarity": 0.528184175491333
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/affinity.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2016 Thomas Gleixner.",
            " * Copyright (C) 2016-2017 Christoph Hellwig.",
            " */",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpu.h>",
            "#include <linux/group_cpus.h>",
            ""
          ],
          "function_name": null,
          "description": "包含中断亲和性管理所需的头文件，为IRQ核心亲和性配置提供基础支持",
          "similarity": 0.5079926252365112
        }
      ]
    },
    {
      "source_file": "kernel/irq/spurious.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:09:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\spurious.c`\n\n---\n\n# `irq/spurious.c` 技术文档\n\n## 1. 文件概述\n\n`irq/spurious.c` 是 Linux 内核中断子系统中的一个关键组件，负责处理**伪中断**（spurious interrupts）和**错误路由中断**（misrouted interrupts）。当硬件中断未被任何中断处理程序正确处理（返回 `IRQ_NONE`）时，内核会怀疑该中断是伪中断或被错误路由到当前 IRQ 线。该文件实现了检测、诊断和恢复机制，包括：\n\n- 统计未处理中断次数并判断是否为“卡住”的 IRQ\n- 在启用 `irqfixup` 选项时尝试在其他 IRQ 线上查找真正的中断源（中断错位恢复）\n- 定期轮询被禁用的伪中断线以尝试恢复共享中断设备\n- 提供诊断信息（如调用栈和注册的处理函数列表）\n\n该机制对于提高系统在硬件或固件存在缺陷时的鲁棒性至关重要。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `irqfixup`：模块参数，控制伪中断修复行为（0=禁用，1=仅对未处理中断尝试修复，2=对标记为 `IRQF_IRQPOLL` 的中断也尝试修复）\n- `poll_spurious_irq_timer`：定时器，用于定期轮询被标记为 `IRQS_SPURIOUS_DISABLED` 的中断线\n- `irq_poll_cpu`：记录当前正在执行轮询任务的 CPU ID\n- `irq_poll_active`：原子变量，防止多个 CPU 同时执行轮询\n\n### 主要函数\n- `irq_wait_for_poll(struct irq_desc *desc)`  \n  等待轮询操作完成，避免与轮询线程竞争。在 SMP 系统中自旋等待 `IRQS_POLL_INPROGRESS` 标志清除。\n  \n- `try_one_irq(struct irq_desc *desc, bool force)`  \n  尝试在指定中断描述符上执行中断处理。跳过 PER_CPU、嵌套线程和显式标记为轮询的中断。若中断被禁用，则仅在 `force=true` 时处理。支持共享中断的 `IRQS_PENDING` 重试机制。\n\n- `misrouted_irq(int irq)`  \n  遍历所有 IRQ（除 0 和当前 IRQ），调用 `try_one_irq()` 尝试在其他线上找到真正的中断源。用于中断错位恢复。\n\n- `poll_spurious_irqs(struct timer_list *unused)`  \n  定时器回调函数，轮询所有被标记为 `IRQS_SPURIOUS_DISABLED` 的中断线，强制尝试处理（`force=true`）。\n\n- `__report_bad_irq()` / `report_bad_irq()`  \n  打印伪中断诊断信息，包括中断号、错误返回值、调用栈及所有注册的处理函数。\n\n- `try_misrouted_irq()`  \n  根据 `irqfixup` 级别判断是否应尝试中断错位恢复。\n\n- `note_interrupt(struct irq_desc *desc, irqreturn_t action_ret)`  \n  中断处理结果分析入口。统计未处理中断，触发伪中断检测、诊断和恢复逻辑。\n\n## 3. 关键实现\n\n### 伪中断检测机制\n- 当 `note_interrupt()` 收到 `IRQ_NONE` 时，会递增中断描述符的未处理计数。\n- 若在 100,000 次中断中有 99,900 次未处理，则判定该 IRQ “卡住”，打印诊断信息并建议使用 `irqpoll` 启动参数。\n- 诊断信息包含所有注册的处理函数地址及符号名，便于调试。\n\n### 中断错位恢复（Misrouted IRQ Recovery）\n- 通过 `irqfixup` 内核参数启用（启动时传入 `irqfixup=1` 或 `2`）。\n- 当当前 IRQ 未被处理时，遍历其他所有 IRQ 线，尝试调用其处理函数（`try_one_irq()`）。\n- 仅适用于共享中断（`IRQF_SHARED`）且非 PER_CPU/嵌套线程类型。\n- 使用 `IRQS_POLL_INPROGRESS` 标志防止与正常中断处理冲突。\n\n### 轮询恢复机制\n- 被判定为伪中断的 IRQ 会被标记 `IRQS_SPURIOUS_DISABLED` 并禁用。\n- 启用 `irqfixup` 时，启动定时器 `poll_spurious_irq_timer`（间隔 100ms）。\n- 定时器回调 `poll_spurious_irqs()` 遍历所有 `IRQS_SPURIOUS_DISABLED` 的 IRQ，强制尝试处理（即使已禁用）。\n- 通过 `local_irq_disable/enable()` 保证轮询期间本地中断关闭，避免嵌套。\n\n### SMP 安全性\n- 使用 `irq_poll_active` 原子变量确保同一时间仅一个 CPU 执行轮询。\n- `irq_wait_for_poll()` 在 SMP 下自旋等待轮询完成，防止死锁。\n- 所有关键操作均在 `desc->lock` 保护下进行。\n\n### 线程化中断处理支持\n- 若主处理函数返回 `IRQ_WAKE_THREAD`，则延迟伪中断判断至下一次硬件中断，以等待线程处理结果。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`、`<linux/interrupt.h>`：中断核心数据结构和 API\n  - `<linux/timer.h>`：定时器支持（用于轮询）\n  - `\"internals.h\"`：中断子系统内部接口\n\n- **内核配置依赖**：\n  - `CONFIG_SMP`：影响 `irq_wait_for_poll()` 的实现\n  - `irqfixup` 模块参数：控制恢复行为\n\n- **与其他模块交互**：\n  - 被通用中断处理流程（如 `handle_irq_event()`）调用\n  - 与中断描述符管理（`irq_desc`）紧密集成\n  - 依赖内核打印和栈回溯机制（`dump_stack()`）\n\n## 5. 使用场景\n\n1. **硬件/固件缺陷处理**：  \n   当 BIOS 或硬件错误地将设备中断路由到错误的 IRQ 线时，通过 `irqfixup` 机制尝试在其他线上找到真正的处理函数。\n\n2. **共享中断线故障恢复**：  \n   在多个设备共享同一 IRQ 线时，若其中一个设备故障产生持续中断但无处理函数响应，内核可禁用该线并定期轮询，避免系统被中断风暴拖垮。\n\n3. **系统调试与诊断**：  \n   当出现“nobody cared”中断错误时，自动打印详细的处理函数列表和调用栈，帮助开发者定位问题设备或驱动。\n\n4. **高可用性系统**：  \n   在无法立即修复硬件问题的生产环境中，通过 `irqpoll` 启动参数启用轮询机制，维持系统基本运行。\n\n5. **传统 PC 兼容性**：  \n   特别处理 IRQ 0（系统定时器），因其在传统 PC 架构中的特殊地位，即使在 `irqfixup=2` 模式下也始终尝试恢复。",
      "similarity": 0.5478623509407043,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 436,
          "end_line": 467,
          "content": [
            "int noirqdebug_setup(char *str)",
            "{",
            "\tnoirqdebug = 1;",
            "\tprintk(KERN_INFO \"IRQ lockup detection disabled\\n\");",
            "",
            "\treturn 1;",
            "}",
            "static int __init irqfixup_setup(char *str)",
            "{",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {",
            "\t\tpr_warn(\"irqfixup boot option not supported with PREEMPT_RT\\n\");",
            "\t\treturn 1;",
            "\t}",
            "\tirqfixup = 1;",
            "\tprintk(KERN_WARNING \"Misrouted IRQ fixup support enabled.\\n\");",
            "\tprintk(KERN_WARNING \"This may impact system performance.\\n\");",
            "",
            "\treturn 1;",
            "}",
            "static int __init irqpoll_setup(char *str)",
            "{",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {",
            "\t\tpr_warn(\"irqpoll boot option not supported with PREEMPT_RT\\n\");",
            "\t\treturn 1;",
            "\t}",
            "\tirqfixup = 2;",
            "\tprintk(KERN_WARNING \"Misrouted IRQ fixup and polling support \"",
            "\t\t\t\t\"enabled\\n\");",
            "\tprintk(KERN_WARNING \"This may significantly impact system \"",
            "\t\t\t\t\"performance\\n\");",
            "\treturn 1;",
            "}"
          ],
          "function_name": "noirqdebug_setup, irqfixup_setup, irqpoll_setup",
          "description": "提供启动参数配置接口，用于启用或禁用irqfixup和irqpoll功能，并输出相应警告信息。",
          "similarity": 0.5854743123054504
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 1,
          "end_line": 35,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992, 1998-2004 Linus Torvalds, Ingo Molnar",
            " *",
            " * This file contains spurious interrupt handling.",
            " */",
            "",
            "#include <linux/jiffies.h>",
            "#include <linux/irq.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/timer.h>",
            "",
            "#include \"internals.h\"",
            "",
            "static int irqfixup __read_mostly;",
            "",
            "#define POLL_SPURIOUS_IRQ_INTERVAL (HZ/10)",
            "static void poll_spurious_irqs(struct timer_list *unused);",
            "static DEFINE_TIMER(poll_spurious_irq_timer, poll_spurious_irqs);",
            "static int irq_poll_cpu;",
            "static atomic_t irq_poll_active;",
            "",
            "/*",
            " * We wait here for a poller to finish.",
            " *",
            " * If the poll runs on this CPU, then we yell loudly and return",
            " * false. That will leave the interrupt line disabled in the worst",
            " * case, but it should never happen.",
            " *",
            " * We wait until the poller is done and then recheck disabled and",
            " * action (about to be disabled). Only if it's still active, we return",
            " * true and let the handler run.",
            " */"
          ],
          "function_name": null,
          "description": "定义了处理虚假中断的相关变量和定时器，用于周期性地扫描和处理可能存在的虚假中断。",
          "similarity": 0.5311407446861267
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 144,
          "end_line": 256,
          "content": [
            "static void poll_spurious_irqs(struct timer_list *unused)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tint i;",
            "",
            "\tif (atomic_inc_return(&irq_poll_active) != 1)",
            "\t\tgoto out;",
            "\tirq_poll_cpu = smp_processor_id();",
            "",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\tunsigned int state;",
            "",
            "\t\tif (!i)",
            "\t\t\t continue;",
            "",
            "\t\t/* Racy but it doesn't matter */",
            "\t\tstate = desc->istate;",
            "\t\tbarrier();",
            "\t\tif (!(state & IRQS_SPURIOUS_DISABLED))",
            "\t\t\tcontinue;",
            "",
            "\t\tlocal_irq_disable();",
            "\t\ttry_one_irq(desc, true);",
            "\t\tlocal_irq_enable();",
            "\t}",
            "out:",
            "\tatomic_dec(&irq_poll_active);",
            "\tmod_timer(&poll_spurious_irq_timer,",
            "\t\t  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);",
            "}",
            "static inline int bad_action_ret(irqreturn_t action_ret)",
            "{",
            "\tunsigned int r = action_ret;",
            "",
            "\tif (likely(r <= (IRQ_HANDLED | IRQ_WAKE_THREAD)))",
            "\t\treturn 0;",
            "\treturn 1;",
            "}",
            "static void __report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)",
            "{",
            "\tunsigned int irq = irq_desc_get_irq(desc);",
            "\tstruct irqaction *action;",
            "\tunsigned long flags;",
            "",
            "\tif (bad_action_ret(action_ret)) {",
            "\t\tprintk(KERN_ERR \"irq event %d: bogus return value %x\\n\",",
            "\t\t\t\tirq, action_ret);",
            "\t} else {",
            "\t\tprintk(KERN_ERR \"irq %d: nobody cared (try booting with \"",
            "\t\t\t\t\"the \\\"irqpoll\\\" option)\\n\", irq);",
            "\t}",
            "\tdump_stack();",
            "\tprintk(KERN_ERR \"handlers:\\n\");",
            "",
            "\t/*",
            "\t * We need to take desc->lock here. note_interrupt() is called",
            "\t * w/o desc->lock held, but IRQ_PROGRESS set. We might race",
            "\t * with something else removing an action. It's ok to take",
            "\t * desc->lock here. See synchronize_irq().",
            "\t */",
            "\traw_spin_lock_irqsave(&desc->lock, flags);",
            "\tfor_each_action_of_desc(desc, action) {",
            "\t\tprintk(KERN_ERR \"[<%p>] %ps\", action->handler, action->handler);",
            "\t\tif (action->thread_fn)",
            "\t\t\tprintk(KERN_CONT \" threaded [<%p>] %ps\",",
            "\t\t\t\t\taction->thread_fn, action->thread_fn);",
            "\t\tprintk(KERN_CONT \"\\n\");",
            "\t}",
            "\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "}",
            "static void report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)",
            "{",
            "\tstatic int count = 100;",
            "",
            "\tif (count > 0) {",
            "\t\tcount--;",
            "\t\t__report_bad_irq(desc, action_ret);",
            "\t}",
            "}",
            "static inline int",
            "try_misrouted_irq(unsigned int irq, struct irq_desc *desc,",
            "\t\t  irqreturn_t action_ret)",
            "{",
            "\tstruct irqaction *action;",
            "",
            "\tif (!irqfixup)",
            "\t\treturn 0;",
            "",
            "\t/* We didn't actually handle the IRQ - see if it was misrouted? */",
            "\tif (action_ret == IRQ_NONE)",
            "\t\treturn 1;",
            "",
            "\t/*",
            "\t * But for 'irqfixup == 2' we also do it for handled interrupts if",
            "\t * they are marked as IRQF_IRQPOLL (or for irq zero, which is the",
            "\t * traditional PC timer interrupt.. Legacy)",
            "\t */",
            "\tif (irqfixup < 2)",
            "\t\treturn 0;",
            "",
            "\tif (!irq)",
            "\t\treturn 1;",
            "",
            "\t/*",
            "\t * Since we don't get the descriptor lock, \"action\" can",
            "\t * change under us.  We don't really care, but we don't",
            "\t * want to follow a NULL pointer. So tell the compiler to",
            "\t * just load it once by using a barrier.",
            "\t */",
            "\taction = desc->action;",
            "\tbarrier();",
            "\treturn action && (action->flags & IRQF_IRQPOLL);",
            "}"
          ],
          "function_name": "poll_spurious_irqs, bad_action_ret, __report_bad_irq, report_bad_irq, try_misrouted_irq",
          "description": "poll_spurious_irqs定时扫描中断描述符并处理疑似虚假中断，包含错误报告辅助函数和误路由检测逻辑。",
          "similarity": 0.5143382549285889
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 36,
          "end_line": 136,
          "content": [
            "bool irq_wait_for_poll(struct irq_desc *desc)",
            "\t__must_hold(&desc->lock)",
            "{",
            "\tif (WARN_ONCE(irq_poll_cpu == smp_processor_id(),",
            "\t\t      \"irq poll in progress on cpu %d for irq %d\\n\",",
            "\t\t      smp_processor_id(), desc->irq_data.irq))",
            "\t\treturn false;",
            "",
            "#ifdef CONFIG_SMP",
            "\tdo {",
            "\t\traw_spin_unlock(&desc->lock);",
            "\t\twhile (irqd_irq_inprogress(&desc->irq_data))",
            "\t\t\tcpu_relax();",
            "\t\traw_spin_lock(&desc->lock);",
            "\t} while (irqd_irq_inprogress(&desc->irq_data));",
            "\t/* Might have been disabled in meantime */",
            "\treturn !irqd_irq_disabled(&desc->irq_data) && desc->action;",
            "#else",
            "\treturn false;",
            "#endif",
            "}",
            "static int try_one_irq(struct irq_desc *desc, bool force)",
            "{",
            "\tirqreturn_t ret = IRQ_NONE;",
            "\tstruct irqaction *action;",
            "",
            "\traw_spin_lock(&desc->lock);",
            "",
            "\t/*",
            "\t * PER_CPU, nested thread interrupts and interrupts explicitly",
            "\t * marked polled are excluded from polling.",
            "\t */",
            "\tif (irq_settings_is_per_cpu(desc) ||",
            "\t    irq_settings_is_nested_thread(desc) ||",
            "\t    irq_settings_is_polled(desc))",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Do not poll disabled interrupts unless the spurious",
            "\t * disabled poller asks explicitly.",
            "\t */",
            "\tif (irqd_irq_disabled(&desc->irq_data) && !force)",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * All handlers must agree on IRQF_SHARED, so we test just the",
            "\t * first.",
            "\t */",
            "\taction = desc->action;",
            "\tif (!action || !(action->flags & IRQF_SHARED) ||",
            "\t    (action->flags & __IRQF_TIMER))",
            "\t\tgoto out;",
            "",
            "\t/* Already running on another processor */",
            "\tif (irqd_irq_inprogress(&desc->irq_data)) {",
            "\t\t/*",
            "\t\t * Already running: If it is shared get the other",
            "\t\t * CPU to go looking for our mystery interrupt too",
            "\t\t */",
            "\t\tdesc->istate |= IRQS_PENDING;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* Mark it poll in progress */",
            "\tdesc->istate |= IRQS_POLL_INPROGRESS;",
            "\tdo {",
            "\t\tif (handle_irq_event(desc) == IRQ_HANDLED)",
            "\t\t\tret = IRQ_HANDLED;",
            "\t\t/* Make sure that there is still a valid action */",
            "\t\taction = desc->action;",
            "\t} while ((desc->istate & IRQS_PENDING) && action);",
            "\tdesc->istate &= ~IRQS_POLL_INPROGRESS;",
            "out:",
            "\traw_spin_unlock(&desc->lock);",
            "\treturn ret == IRQ_HANDLED;",
            "}",
            "static int misrouted_irq(int irq)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tint i, ok = 0;",
            "",
            "\tif (atomic_inc_return(&irq_poll_active) != 1)",
            "\t\tgoto out;",
            "",
            "\tirq_poll_cpu = smp_processor_id();",
            "",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\tif (!i)",
            "\t\t\t continue;",
            "",
            "\t\tif (i == irq)\t/* Already tried */",
            "\t\t\tcontinue;",
            "",
            "\t\tif (try_one_irq(desc, false))",
            "\t\t\tok = 1;",
            "\t}",
            "out:",
            "\tatomic_dec(&irq_poll_active);",
            "\t/* So the caller can adjust the irq error counts */",
            "\treturn ok;",
            "}"
          ],
          "function_name": "irq_wait_for_poll, try_one_irq, misrouted_irq",
          "description": "实现了irq_wait_for_poll用于等待轮询完成，try_one_irq尝试处理单个中断，misrouted_irq尝试修复误路由中断。",
          "similarity": 0.49569541215896606
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/spurious.c",
          "start_line": 272,
          "end_line": 432,
          "content": [
            "void note_interrupt(struct irq_desc *desc, irqreturn_t action_ret)",
            "{",
            "\tunsigned int irq;",
            "",
            "\tif (desc->istate & IRQS_POLL_INPROGRESS ||",
            "\t    irq_settings_is_polled(desc))",
            "\t\treturn;",
            "",
            "\tif (bad_action_ret(action_ret)) {",
            "\t\treport_bad_irq(desc, action_ret);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * We cannot call note_interrupt from the threaded handler",
            "\t * because we need to look at the compound of all handlers",
            "\t * (primary and threaded). Aside of that in the threaded",
            "\t * shared case we have no serialization against an incoming",
            "\t * hardware interrupt while we are dealing with a threaded",
            "\t * result.",
            "\t *",
            "\t * So in case a thread is woken, we just note the fact and",
            "\t * defer the analysis to the next hardware interrupt.",
            "\t *",
            "\t * The threaded handlers store whether they successfully",
            "\t * handled an interrupt and we check whether that number",
            "\t * changed versus the last invocation.",
            "\t *",
            "\t * We could handle all interrupts with the delayed by one",
            "\t * mechanism, but for the non forced threaded case we'd just",
            "\t * add pointless overhead to the straight hardirq interrupts",
            "\t * for the sake of a few lines less code.",
            "\t */",
            "\tif (action_ret & IRQ_WAKE_THREAD) {",
            "\t\t/*",
            "\t\t * There is a thread woken. Check whether one of the",
            "\t\t * shared primary handlers returned IRQ_HANDLED. If",
            "\t\t * not we defer the spurious detection to the next",
            "\t\t * interrupt.",
            "\t\t */",
            "\t\tif (action_ret == IRQ_WAKE_THREAD) {",
            "\t\t\tint handled;",
            "\t\t\t/*",
            "\t\t\t * We use bit 31 of thread_handled_last to",
            "\t\t\t * denote the deferred spurious detection",
            "\t\t\t * active. No locking necessary as",
            "\t\t\t * thread_handled_last is only accessed here",
            "\t\t\t * and we have the guarantee that hard",
            "\t\t\t * interrupts are not reentrant.",
            "\t\t\t */",
            "\t\t\tif (!(desc->threads_handled_last & SPURIOUS_DEFERRED)) {",
            "\t\t\t\tdesc->threads_handled_last |= SPURIOUS_DEFERRED;",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t\t/*",
            "\t\t\t * Check whether one of the threaded handlers",
            "\t\t\t * returned IRQ_HANDLED since the last",
            "\t\t\t * interrupt happened.",
            "\t\t\t *",
            "\t\t\t * For simplicity we just set bit 31, as it is",
            "\t\t\t * set in threads_handled_last as well. So we",
            "\t\t\t * avoid extra masking. And we really do not",
            "\t\t\t * care about the high bits of the handled",
            "\t\t\t * count. We just care about the count being",
            "\t\t\t * different than the one we saw before.",
            "\t\t\t */",
            "\t\t\thandled = atomic_read(&desc->threads_handled);",
            "\t\t\thandled |= SPURIOUS_DEFERRED;",
            "\t\t\tif (handled != desc->threads_handled_last) {",
            "\t\t\t\taction_ret = IRQ_HANDLED;",
            "\t\t\t\t/*",
            "\t\t\t\t * Note: We keep the SPURIOUS_DEFERRED",
            "\t\t\t\t * bit set. We are handling the",
            "\t\t\t\t * previous invocation right now.",
            "\t\t\t\t * Keep it for the current one, so the",
            "\t\t\t\t * next hardware interrupt will",
            "\t\t\t\t * account for it.",
            "\t\t\t\t */",
            "\t\t\t\tdesc->threads_handled_last = handled;",
            "\t\t\t} else {",
            "\t\t\t\t/*",
            "\t\t\t\t * None of the threaded handlers felt",
            "\t\t\t\t * responsible for the last interrupt",
            "\t\t\t\t *",
            "\t\t\t\t * We keep the SPURIOUS_DEFERRED bit",
            "\t\t\t\t * set in threads_handled_last as we",
            "\t\t\t\t * need to account for the current",
            "\t\t\t\t * interrupt as well.",
            "\t\t\t\t */",
            "\t\t\t\taction_ret = IRQ_NONE;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\t/*",
            "\t\t\t * One of the primary handlers returned",
            "\t\t\t * IRQ_HANDLED. So we don't care about the",
            "\t\t\t * threaded handlers on the same line. Clear",
            "\t\t\t * the deferred detection bit.",
            "\t\t\t *",
            "\t\t\t * In theory we could/should check whether the",
            "\t\t\t * deferred bit is set and take the result of",
            "\t\t\t * the previous run into account here as",
            "\t\t\t * well. But it's really not worth the",
            "\t\t\t * trouble. If every other interrupt is",
            "\t\t\t * handled we never trigger the spurious",
            "\t\t\t * detector. And if this is just the one out",
            "\t\t\t * of 100k unhandled ones which is handled",
            "\t\t\t * then we merily delay the spurious detection",
            "\t\t\t * by one hard interrupt. Not a real problem.",
            "\t\t\t */",
            "\t\t\tdesc->threads_handled_last &= ~SPURIOUS_DEFERRED;",
            "\t\t}",
            "\t}",
            "",
            "\tif (unlikely(action_ret == IRQ_NONE)) {",
            "\t\t/*",
            "\t\t * If we are seeing only the odd spurious IRQ caused by",
            "\t\t * bus asynchronicity then don't eventually trigger an error,",
            "\t\t * otherwise the counter becomes a doomsday timer for otherwise",
            "\t\t * working systems",
            "\t\t */",
            "\t\tif (time_after(jiffies, desc->last_unhandled + HZ/10))",
            "\t\t\tdesc->irqs_unhandled = 1;",
            "\t\telse",
            "\t\t\tdesc->irqs_unhandled++;",
            "\t\tdesc->last_unhandled = jiffies;",
            "\t}",
            "",
            "\tirq = irq_desc_get_irq(desc);",
            "\tif (unlikely(try_misrouted_irq(irq, desc, action_ret))) {",
            "\t\tint ok = misrouted_irq(irq);",
            "\t\tif (action_ret == IRQ_NONE)",
            "\t\t\tdesc->irqs_unhandled -= ok;",
            "\t}",
            "",
            "\tif (likely(!desc->irqs_unhandled))",
            "\t\treturn;",
            "",
            "\t/* Now getting into unhandled irq detection */",
            "\tdesc->irq_count++;",
            "\tif (likely(desc->irq_count < 100000))",
            "\t\treturn;",
            "",
            "\tdesc->irq_count = 0;",
            "\tif (unlikely(desc->irqs_unhandled > 99900)) {",
            "\t\t/*",
            "\t\t * The interrupt is stuck",
            "\t\t */",
            "\t\t__report_bad_irq(desc, action_ret);",
            "\t\t/*",
            "\t\t * Now kill the IRQ",
            "\t\t */",
            "\t\tprintk(KERN_EMERG \"Disabling IRQ #%d\\n\", irq);",
            "\t\tdesc->istate |= IRQS_SPURIOUS_DISABLED;",
            "\t\tdesc->depth++;",
            "\t\tirq_disable(desc);",
            "",
            "\t\tmod_timer(&poll_spurious_irq_timer,",
            "\t\t\t  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);",
            "\t}",
            "\tdesc->irqs_unhandled = 0;",
            "}"
          ],
          "function_name": "note_interrupt",
          "description": "note_interrupt记录中断事件，检测未处理中断并触发报告，处理线程唤醒场景下的特殊逻辑。",
          "similarity": 0.49329063296318054
        }
      ]
    }
  ]
}