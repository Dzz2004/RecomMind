{
  "query": "银行家算法实现步骤",
  "timestamp": "2025-12-26 01:03:52",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/bloom_filter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:56:28\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bloom_filter.c`\n\n---\n\n# `bpf/bloom_filter.c` 技术文档\n\n## 1. 文件概述\n\n该文件实现了 Linux 内核中 eBPF（extended Berkeley Packet Filter）子系统所支持的 **布隆过滤器（Bloom Filter）映射类型**。布隆过滤器是一种空间高效的概率型数据结构，用于快速判断某个元素是否**可能存在于集合中**（允许假阳性，但不允许假阴性）。该映射类型专为只写入、只查询、不可删除的场景设计，适用于高性能、低内存开销的成员存在性检测。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct bpf_bloom_filter`**  \n  布隆过滤器的具体实现结构体，包含：\n  - `struct bpf_map map`：继承自通用 eBPF 映射结构。\n  - `u32 bitset_mask`：位图掩码，用于快速取模（因位图大小为 2 的幂）。\n  - `u32 hash_seed`：哈希种子，用于初始化哈希函数（可选随机化）。\n  - `u32 nr_hash_funcs`：使用的哈希函数数量（1–15，由 `map_extra` 指定）。\n  - `unsigned long bitset[]`：柔性数组，存储位图数据。\n\n### 主要函数\n\n| 函数名 | 功能说明 |\n|--------|--------|\n| `hash()` | 根据输入值、哈希种子和索引计算哈希值，并通过 `bitset_mask` 取模得到位图索引。支持 4 字节对齐和非对齐数据。 |\n| `bloom_map_peek_elem()` | 查询元素是否存在：对每个哈希函数计算位图位置，若任一位为 0 则返回 `-ENOENT`（不存在）；否则返回 0（可能存在）。 |\n| `bloom_map_push_elem()` | 插入元素：对每个哈希函数计算位图位置并置位。仅支持 `BPF_ANY` 标志。 |\n| `bloom_map_alloc()` | 分配并初始化布隆过滤器映射。根据 `max_entries` 和 `map_extra`（哈希函数数）计算最优位图大小，并向上取整为 2 的幂。 |\n| `bloom_map_free()` | 释放布隆过滤器占用的内存。 |\n| `bloom_map_alloc_check()` | 在创建映射前校验参数合法性（如 `value_size` 不超过 `KMALLOC_MAX_SIZE`）。 |\n| `bloom_map_check_btf()` | BTF（BPF Type Format）校验：要求 key 类型为 `void`（无 key）。 |\n| `bloom_map_mem_usage()` | 返回该映射实际占用的内存大小（含位图）。 |\n\n### 不支持的操作（返回 `-EOPNOTSUPP` 或 `-EINVAL`）\n\n- `bloom_map_pop_elem()`：不支持弹出元素。\n- `bloom_map_delete_elem()`：不支持删除元素。\n- `bloom_map_get_next_key()`：不支持遍历。\n- `bloom_map_lookup_elem()` / `bloom_map_update_elem()`：eBPF 程序应使用 `map_peek_elem` 和 `map_push_elem` 替代。\n\n### 映射操作表\n\n- `bloom_filter_map_ops`：定义了该映射类型支持的所有操作回调函数，注册到 eBPF 子系统。\n\n## 3. 关键实现\n\n### 布隆过滤器参数计算\n\n- **哈希函数数量**：由用户通过 `attr->map_extra & 0xF` 指定（1–15），若为 0 则默认使用 5 个。\n- **位图大小计算**：\n  - 理论最优位数：`n * k / ln(2)`，其中 `n = max_entries`，`k = nr_hash_funcs`。\n  - 代码使用 `7/5 ≈ 1/ln(2)` 近似计算：`nr_bits = (max_entries * k * 7) / 5`。\n  - 为提升哈希效率，将 `nr_bits` **向上取整为 2 的幂**，从而可用 `& (size - 1)` 替代取模运算。\n  - 若计算溢出（> 2^31），则使用最大位图（`U32_MAX` 位，约 512 MB）。\n\n### 哈希函数\n\n- 使用内核提供的 `jhash()` 和 `jhash2()`（Jenkins 哈希）。\n- 每个哈希函数通过 `hash_seed + index` 区分，确保独立性。\n- 支持任意长度的 `value`（由 `value_size` 指定），自动选择对齐/非对齐版本。\n\n### 内存分配\n\n- 使用 `bpf_map_area_alloc()` 分配连续内存，包含结构体头和位图。\n- 位图大小按 `unsigned long` 对齐，确保位操作效率。\n\n### 安全与校验\n\n- 严格校验创建参数：`key_size` 必须为 0，`value_size` 和 `max_entries` 必须 > 0。\n- 仅允许特定 `map_flags`（`BPF_F_NUMA_NODE`、`BPF_F_ZERO_SEED`、`BPF_F_ACCESS_MASK`）。\n- BTF 校验强制 key 类型为 `void`，符合“无 key”设计。\n\n## 4. 依赖关系\n\n- **内核头文件**：\n  - `<linux/bitmap.h>`：提供 `test_bit()`、`set_bit()` 等位操作。\n  - `<linux/bpf.h>`：eBPF 核心定义（`bpf_map`、操作码等）。\n  - `<linux/btf.h>`：BTF 类型系统支持。\n  - `<linux/jhash.h>`：Jenkins 哈希函数实现。\n  - `<linux/random.h>`：`get_random_u32()` 用于生成哈希种子。\n- **eBPF 子系统**：通过 `bpf_map_ops` 机制集成到 eBPF 映射框架中。\n- **内存管理**：依赖 `bpf_map_area_alloc/free` 进行 NUMA 感知内存分配。\n\n## 5. 使用场景\n\n- **网络数据包过滤**：快速判断 IP 地址、端口等是否在可疑集合中。\n- **安全监控**：检测进程、文件路径是否属于已知恶意样本（允许少量误报）。\n- **性能分析**：记录已观测到的事件 ID，避免重复处理。\n- **资源去重**：在无法存储完整集合的场景下，高效判断元素是否已存在。\n\n> **注意**：由于布隆过滤器**不支持删除操作**，且存在**假阳性**，适用于“写一次、查多次”且可容忍少量误报的场景。eBPF 程序需通过 `bpf_map_peek_elem()` 查询，通过 `bpf_map_push_elem()` 插入。",
      "similarity": 0.49008238315582275,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bloom_filter.c",
          "start_line": 23,
          "end_line": 117,
          "content": [
            "static u32 hash(struct bpf_bloom_filter *bloom, void *value,",
            "\t\tu32 value_size, u32 index)",
            "{",
            "\tu32 h;",
            "",
            "\tif (likely(value_size % 4 == 0))",
            "\t\th = jhash2(value, value_size / 4, bloom->hash_seed + index);",
            "\telse",
            "\t\th = jhash(value, value_size, bloom->hash_seed + index);",
            "",
            "\treturn h & bloom->bitset_mask;",
            "}",
            "static long bloom_map_peek_elem(struct bpf_map *map, void *value)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "\tu32 i, h;",
            "",
            "\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {",
            "\t\th = hash(bloom, value, map->value_size, i);",
            "\t\tif (!test_bit(h, bloom->bitset))",
            "\t\t\treturn -ENOENT;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static long bloom_map_push_elem(struct bpf_map *map, void *value, u64 flags)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "\tu32 i, h;",
            "",
            "\tif (flags != BPF_ANY)",
            "\t\treturn -EINVAL;",
            "",
            "\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {",
            "\t\th = hash(bloom, value, map->value_size, i);",
            "\t\tset_bit(h, bloom->bitset);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static long bloom_map_pop_elem(struct bpf_map *map, void *value)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static long bloom_map_delete_elem(struct bpf_map *map, void *value)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static int bloom_map_get_next_key(struct bpf_map *map, void *key, void *next_key)",
            "{",
            "\treturn -EOPNOTSUPP;",
            "}",
            "static int bloom_map_alloc_check(union bpf_attr *attr)",
            "{",
            "\tif (attr->value_size > KMALLOC_MAX_SIZE)",
            "\t\t/* if value_size is bigger, the user space won't be able to",
            "\t\t * access the elements.",
            "\t\t */",
            "\t\treturn -E2BIG;",
            "",
            "\treturn 0;",
            "}",
            "static void bloom_map_free(struct bpf_map *map)",
            "{",
            "\tstruct bpf_bloom_filter *bloom =",
            "\t\tcontainer_of(map, struct bpf_bloom_filter, map);",
            "",
            "\tbpf_map_area_free(bloom);",
            "}",
            "static long bloom_map_update_elem(struct bpf_map *map, void *key,",
            "\t\t\t\t  void *value, u64 flags)",
            "{",
            "\t/* The eBPF program should use map_push_elem instead */",
            "\treturn -EINVAL;",
            "}",
            "static int bloom_map_check_btf(const struct bpf_map *map,",
            "\t\t\t       const struct btf *btf,",
            "\t\t\t       const struct btf_type *key_type,",
            "\t\t\t       const struct btf_type *value_type)",
            "{",
            "\t/* Bloom filter maps are keyless */",
            "\treturn btf_type_is_void(key_type) ? 0 : -EINVAL;",
            "}",
            "static u64 bloom_map_mem_usage(const struct bpf_map *map)",
            "{",
            "\tstruct bpf_bloom_filter *bloom;",
            "\tu64 bitset_bytes;",
            "",
            "\tbloom = container_of(map, struct bpf_bloom_filter, map);",
            "\tbitset_bytes = BITS_TO_BYTES((u64)bloom->bitset_mask + 1);",
            "\tbitset_bytes = roundup(bitset_bytes, sizeof(unsigned long));",
            "\treturn sizeof(*bloom) + bitset_bytes;",
            "}"
          ],
          "function_name": "hash, bloom_map_peek_elem, bloom_map_push_elem, bloom_map_pop_elem, bloom_map_delete_elem, bloom_map_get_next_key, bloom_map_alloc_check, bloom_map_free, bloom_map_update_elem, bloom_map_check_btf, bloom_map_mem_usage",
          "description": "实现Bloom过滤器核心操作，包括哈希计算、元素存在性检测、插入操作、内存校验、资源释放及内存占用统计，部分接口暂不支持并返回相应错误码",
          "similarity": 0.5121509432792664
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bloom_filter.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Copyright (c) 2021 Facebook */",
            "",
            "#include <linux/bitmap.h>",
            "#include <linux/bpf.h>",
            "#include <linux/btf.h>",
            "#include <linux/err.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/btf_ids.h>",
            "",
            "#define BLOOM_CREATE_FLAG_MASK \\",
            "\t(BPF_F_NUMA_NODE | BPF_F_ZERO_SEED | BPF_F_ACCESS_MASK)",
            "",
            "struct bpf_bloom_filter {",
            "\tstruct bpf_map map;",
            "\tu32 bitset_mask;",
            "\tu32 hash_seed;",
            "\tu32 nr_hash_funcs;",
            "\tunsigned long bitset[];",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义Bloom过滤器内核结构体，包含位图掩码、哈希种子、哈希函数数及动态扩展的位集合数组，用于eBPF程序中的布隆过滤器实现",
          "similarity": 0.43050920963287354
        }
      ]
    },
    {
      "source_file": "kernel/bpf/map_iter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:18:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\map_iter.c`\n\n---\n\n# `bpf/map_iter.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/map_iter.c` 是 Linux 内核 BPF（Berkeley Packet Filter）子系统中的一个核心文件，用于实现对 BPF map 的迭代器（iterator）支持。该文件提供了两种类型的 BPF 迭代器：\n\n- **`bpf_map` 迭代器**：用于遍历系统中所有已注册的 BPF map。\n- **`bpf_map_elem` 迭代器**：用于遍历指定 BPF map 中的所有键值对元素。\n\n此外，该文件还定义了一个 BPF kfunc（内核函数）`bpf_map_sum_elem_count`，用于安全地获取 per-CPU 类型 map 的总元素数量。整个实现基于内核的 seq_file 机制和 BPF 迭代器框架，允许用户空间通过 BPF 程序安全、高效地访问 map 元数据或内容。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bpf_iter_seq_map_info`**  \n  用于在 seq_file 迭代过程中保存当前遍历的 map ID。\n\n- **`struct bpf_iter__bpf_map`**  \n  BPF 程序上下文结构，作为 `bpf_map` 迭代器的元数据传递给 BPF 程序，包含指向当前 `bpf_map` 的指针。\n\n- **`struct bpf_iter__bpf_map_elem`**（隐式定义）  \n  由 `DEFINE_BPF_ITER_FUNC(bpf_map_elem, ...)` 宏生成，用于 `bpf_map_elem` 迭代器，包含 `map`、`key` 和 `value` 指针。\n\n- **`bpf_map_seq_ops`**  \n  实现 `seq_operations` 接口，用于遍历所有 BPF map。\n\n- **`bpf_map_reg_info` 与 `bpf_map_elem_reg_info`**  \n  分别注册 `bpf_map` 和 `bpf_map_elem` 两种 BPF 迭代器目标。\n\n- **`bpf_map_iter_kfunc_set`**  \n  注册 BPF kfunc `bpf_map_sum_elem_count`，供 BPF 程序调用。\n\n### 主要函数\n\n- **`bpf_map_seq_start/next/stop/show`**  \n  实现 seq_file 接口，用于遍历所有 BPF map。\n\n- **`__bpf_map_seq_show`**  \n  调用关联的 BPF 程序处理当前 map。\n\n- **`bpf_iter_attach_map` / `bpf_iter_detach_map`**  \n  在 `bpf_map_elem` 迭代器 attach/detach 时管理 map 引用计数，并验证访问权限。\n\n- **`bpf_iter_map_show_fdinfo` / `bpf_iter_map_fill_link_info`**  \n  提供迭代器链接的调试信息和用户空间查询接口。\n\n- **`bpf_map_sum_elem_count`**  \n  BPF kfunc，安全累加 per-CPU map 的元素计数。\n\n- **`bpf_map_iter_init`**  \n  模块初始化函数，注册两个 BPF 迭代器目标。\n\n- **`init_subsystem`**  \n  注册 BPF kfunc 到 BTF 系统。\n\n## 3. 关键实现\n\n### BPF Map 全局遍历（`bpf_map` 迭代器）\n\n- 使用 `bpf_map_get_curr_or_next(&map_id)` 按 ID 顺序遍历所有 map。\n- `seq_file` 的 `start`/`next` 函数通过递增 `map_id` 实现迭代。\n- 每次访问 map 后通过 `bpf_map_put()` 释放引用，确保资源安全。\n- 在 `stop` 阶段，若 `v == NULL`（表示迭代结束），会再次调用 `__bpf_map_seq_show` 并传入 `in_stop=true`，用于通知 BPF 程序迭代已结束。\n\n### BPF Map 元素遍历（`bpf_map_elem` 迭代器）\n\n- 通过 `bpf_iter_attach_map` 从用户传入的 `map_fd` 获取 map 实例。\n- 支持的 map 类型包括：`HASH`、`LRU_HASH`、`ARRAY` 及其 per-CPU 变体。\n- 在 attach 时验证 BPF 程序对 key/value 的最大访问尺寸是否超过 map 定义的尺寸，防止越界访问。\n- 对 per-CPU map，value 大小计算为 `round_up(value_size, 8) * num_possible_cpus()`，符合内核 per-CPU 布局。\n\n### BPF kfunc：`bpf_map_sum_elem_count`\n\n- 仅当 `map->elem_count` 非空时（通常由支持计数的 map 类型提供）才进行累加。\n- 使用 `for_each_possible_cpu` 遍历所有 CPU，通过 `per_cpu_ptr` 安全读取 per-CPU 计数。\n- 使用 `READ_ONCE` 避免编译器优化导致的非原子读取问题。\n- 标记为 `KF_TRUSTED_ARGS`，表示参数来自内核可信上下文。\n\n### BTF 与类型安全\n\n- 通过 `BTF_ID_LIST_GLOBAL_SINGLE` 获取 `struct bpf_map` 的 BTF ID，用于类型验证。\n- `ctx_arg_info` 中使用 `PTR_TO_BTF_ID_OR_NULL | PTR_TRUSTED` 确保传递给 BPF 程序的 map 指针类型安全且可信。\n- kfunc 通过 `BTF_SET8` 注册，并关联 `KFUNC` 类型标志。\n\n## 4. 依赖关系\n\n- **`<linux/bpf.h>` / `<linux/filter.h>`**：BPF 核心接口和程序执行框架。\n- **`<linux/fs.h>`**：seq_file 机制，用于实现迭代器输出。\n- **`<linux/btf_ids.h>`**：BTF（BPF Type Format）支持，用于类型验证和 kfunc 注册。\n- **`bpf_map_get_curr_or_next` / `bpf_map_put`**：来自 BPF map 管理子系统（`kernel/bpf/syscall.c` 等）。\n- **`bpf_iter_get_info` / `bpf_iter_run_prog`**：BPF 迭代器运行时支持（`kernel/bpf/bpf_iter.c`）。\n- **`register_btf_kfunc_id_set`**：BPF kfunc 注册机制。\n\n## 5. 使用场景\n\n- **系统监控与调试**：用户可通过 BPF 程序遍历所有 BPF map，收集其类型、ID、引用计数等元信息，用于性能分析或调试。\n- **Map 内容导出**：通过 `bpf_map_elem` 迭代器，用户空间可安全遍历指定 map 的所有键值对，实现 map 数据导出（如 `bpftool map dump` 的底层机制）。\n- **安全审计**：结合 BPF 程序，可对 map 访问模式进行监控或策略检查。\n- **Per-CPU 统计聚合**：BPF 程序可调用 `bpf_map_sum_elem_count` 快速获取 per-CPU map 的总元素数，用于指标采集。\n- **内核自省**：作为 BPF 迭代器框架的一部分，为内核提供标准化的 map 遍历能力，避免直接暴露内部数据结构。",
      "similarity": 0.48985981941223145,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/map_iter.c",
          "start_line": 44,
          "end_line": 156,
          "content": [
            "static int __bpf_map_seq_show(struct seq_file *seq, void *v, bool in_stop)",
            "{",
            "\tstruct bpf_iter__bpf_map ctx;",
            "\tstruct bpf_iter_meta meta;",
            "\tstruct bpf_prog *prog;",
            "\tint ret = 0;",
            "",
            "\tctx.meta = &meta;",
            "\tctx.map = v;",
            "\tmeta.seq = seq;",
            "\tprog = bpf_iter_get_info(&meta, in_stop);",
            "\tif (prog)",
            "\t\tret = bpf_iter_run_prog(prog, &ctx);",
            "",
            "\treturn ret;",
            "}",
            "static int bpf_map_seq_show(struct seq_file *seq, void *v)",
            "{",
            "\treturn __bpf_map_seq_show(seq, v, false);",
            "}",
            "static void bpf_map_seq_stop(struct seq_file *seq, void *v)",
            "{",
            "\tif (!v)",
            "\t\t(void)__bpf_map_seq_show(seq, v, true);",
            "\telse",
            "\t\tbpf_map_put((struct bpf_map *)v);",
            "}",
            "static int bpf_iter_attach_map(struct bpf_prog *prog,",
            "\t\t\t       union bpf_iter_link_info *linfo,",
            "\t\t\t       struct bpf_iter_aux_info *aux)",
            "{",
            "\tu32 key_acc_size, value_acc_size, key_size, value_size;",
            "\tstruct bpf_map *map;",
            "\tbool is_percpu = false;",
            "\tint err = -EINVAL;",
            "",
            "\tif (!linfo->map.map_fd)",
            "\t\treturn -EBADF;",
            "",
            "\tmap = bpf_map_get_with_uref(linfo->map.map_fd);",
            "\tif (IS_ERR(map))",
            "\t\treturn PTR_ERR(map);",
            "",
            "\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||",
            "\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||",
            "\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY)",
            "\t\tis_percpu = true;",
            "\telse if (map->map_type != BPF_MAP_TYPE_HASH &&",
            "\t\t map->map_type != BPF_MAP_TYPE_LRU_HASH &&",
            "\t\t map->map_type != BPF_MAP_TYPE_ARRAY)",
            "\t\tgoto put_map;",
            "",
            "\tkey_acc_size = prog->aux->max_rdonly_access;",
            "\tvalue_acc_size = prog->aux->max_rdwr_access;",
            "\tkey_size = map->key_size;",
            "\tif (!is_percpu)",
            "\t\tvalue_size = map->value_size;",
            "\telse",
            "\t\tvalue_size = round_up(map->value_size, 8) * num_possible_cpus();",
            "",
            "\tif (key_acc_size > key_size || value_acc_size > value_size) {",
            "\t\terr = -EACCES;",
            "\t\tgoto put_map;",
            "\t}",
            "",
            "\taux->map = map;",
            "\treturn 0;",
            "",
            "put_map:",
            "\tbpf_map_put_with_uref(map);",
            "\treturn err;",
            "}",
            "static void bpf_iter_detach_map(struct bpf_iter_aux_info *aux)",
            "{",
            "\tbpf_map_put_with_uref(aux->map);",
            "}",
            "void bpf_iter_map_show_fdinfo(const struct bpf_iter_aux_info *aux,",
            "\t\t\t      struct seq_file *seq)",
            "{",
            "\tseq_printf(seq, \"map_id:\\t%u\\n\", aux->map->id);",
            "}",
            "int bpf_iter_map_fill_link_info(const struct bpf_iter_aux_info *aux,",
            "\t\t\t\tstruct bpf_link_info *info)",
            "{",
            "\tinfo->iter.map.map_id = aux->map->id;",
            "\treturn 0;",
            "}",
            "static int __init bpf_map_iter_init(void)",
            "{",
            "\tint ret;",
            "",
            "\tbpf_map_reg_info.ctx_arg_info[0].btf_id = *btf_bpf_map_id;",
            "\tret = bpf_iter_reg_target(&bpf_map_reg_info);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn bpf_iter_reg_target(&bpf_map_elem_reg_info);",
            "}",
            "__bpf_kfunc s64 bpf_map_sum_elem_count(const struct bpf_map *map)",
            "{",
            "\ts64 *pcount;",
            "\ts64 ret = 0;",
            "\tint cpu;",
            "",
            "\tif (!map || !map->elem_count)",
            "\t\treturn 0;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tpcount = per_cpu_ptr(map->elem_count, cpu);",
            "\t\tret += READ_ONCE(*pcount);",
            "\t}",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__bpf_map_seq_show, bpf_map_seq_show, bpf_map_seq_stop, bpf_iter_attach_map, bpf_iter_detach_map, bpf_iter_map_show_fdinfo, bpf_iter_map_fill_link_info, bpf_map_iter_init, bpf_map_sum_elem_count",
          "description": "包含BPF map迭代器辅助函数实现，包括map属性展示、权限校验、元素计数统计及链接信息填充，支持通过BPF程序对map进行遍历操作，包含map附加/分离逻辑和子系统初始化",
          "similarity": 0.4860413372516632
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/map_iter.c",
          "start_line": 1,
          "end_line": 43,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2020 Facebook */",
            "#include <linux/bpf.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kernel.h>",
            "#include <linux/btf_ids.h>",
            "",
            "struct bpf_iter_seq_map_info {",
            "\tu32 map_id;",
            "};",
            "",
            "static void *bpf_map_seq_start(struct seq_file *seq, loff_t *pos)",
            "{",
            "\tstruct bpf_iter_seq_map_info *info = seq->private;",
            "\tstruct bpf_map *map;",
            "",
            "\tmap = bpf_map_get_curr_or_next(&info->map_id);",
            "\tif (!map)",
            "\t\treturn NULL;",
            "",
            "\tif (*pos == 0)",
            "\t\t++*pos;",
            "\treturn map;",
            "}",
            "",
            "static void *bpf_map_seq_next(struct seq_file *seq, void *v, loff_t *pos)",
            "{",
            "\tstruct bpf_iter_seq_map_info *info = seq->private;",
            "",
            "\t++*pos;",
            "\t++info->map_id;",
            "\tbpf_map_put((struct bpf_map *)v);",
            "\treturn bpf_map_get_curr_or_next(&info->map_id);",
            "}",
            "",
            "struct bpf_iter__bpf_map {",
            "\t__bpf_md_ptr(struct bpf_iter_meta *, meta);",
            "\t__bpf_md_ptr(struct bpf_map *, map);",
            "};",
            "",
            "DEFINE_BPF_ITER_FUNC(bpf_map, struct bpf_iter_meta *meta, struct bpf_map *map)",
            ""
          ],
          "function_name": null,
          "description": "实现BPF map迭代器框架，提供seq_file遍历接口，通过bpf_map_seq_start和bpf_map_seq_next函数依次获取当前map及下一个map对象，使用 DEFINE_BPF_ITER_FUNC 注册迭代器回调函数",
          "similarity": 0.4850851595401764
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/map_iter.c",
          "start_line": 225,
          "end_line": 228,
          "content": [
            "static int init_subsystem(void)",
            "{",
            "\treturn register_btf_kfunc_id_set(BPF_PROG_TYPE_UNSPEC, &bpf_map_iter_kfunc_set);",
            "}"
          ],
          "function_name": "init_subsystem",
          "description": "注册BPF kfunc集合到BTF系统，用于关联bpf_map_sum_elem_count函数，实现多CPU环境下map元素数量的统计功能",
          "similarity": 0.43810147047042847
        }
      ]
    },
    {
      "source_file": "kernel/bpf/bpf_iter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:58:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bpf_iter.c`\n\n---\n\n# bpf/bpf_iter.c 技术文档\n\n## 1. 文件概述\n\n`bpf_iter.c` 是 Linux 内核中 BPF（Berkeley Packet Filter）子系统的一部分，实现了 **BPF 迭代器（BPF Iterator）** 的核心机制。BPF 迭代器是一种特殊的 BPF 程序类型，允许用户空间通过文件接口（如 `/sys/fs/bpf/` 下的文件）安全、高效地遍历内核中的数据结构（如任务、映射、网络连接等），而无需引入新的系统调用或暴露原始内核指针。\n\n该文件负责：\n- 管理 BPF 迭代器目标（target）的注册与注销\n- 实现自定义的 `seq_file` 读取逻辑（`bpf_seq_read`）\n- 管理迭代器会话的私有数据和生命周期\n- 提供文件操作接口（`file_operations`）供用户空间读取\n\n## 2. 核心功能\n\n### 主要数据结构\n\n| 结构体 | 说明 |\n|--------|------|\n| `struct bpf_iter_target_info` | 表示一个 BPF 迭代器目标的注册信息，包含 `bpf_iter_reg` 和缓存的 BTF ID |\n| `struct bpf_iter_link` | 继承自 `bpf_link`，用于将 BPF 程序与特定迭代器目标关联 |\n| `struct bpf_iter_priv_data` | `seq_file` 的私有数据，包含目标信息、BPF 程序、会话 ID、序列号等状态 |\n\n### 主要函数\n\n| 函数 | 功能 |\n|------|------|\n| `bpf_iter_reg_target()` | 注册一个新的 BPF 迭代器目标类型 |\n| `bpf_iter_unreg_target()` | 注销已注册的 BPF 迭代器目标 |\n| `bpf_iter_prog_supported()` | 检查 BPF 程序是否为有效的迭代器程序（基于函数名前缀和 BTF ID 匹配） |\n| `bpf_seq_read()` | 自定义的 `seq_file` 读取实现，支持 BPF 程序在 `start/next/show/stop` 回调中执行 |\n| `iter_open()` / `iter_release()` | 文件打开/释放回调，初始化和清理迭代器会话 |\n| `bpf_iter_inc_seq_num()` / `bpf_iter_dec_seq_num()` | 管理当前迭代对象的序列号（用于跳过对象时回退） |\n| `bpf_iter_done_stop()` | 标记迭代已正常结束 |\n\n### 全局变量\n\n- `targets`：已注册迭代器目标的链表\n- `session_id`：全局递增的会话 ID，用于区分不同迭代会话\n- `bpf_iter_fops`：提供给 VFS 的文件操作接口\n\n## 3. 关键实现\n\n### BPF 迭代器工作流程\n1. **注册**：内核子系统（如 `task_iter`、`map_iter`）通过 `bpf_iter_reg_target()` 注册其迭代器实现（`bpf_iter_reg`）。\n2. **程序加载**：用户加载 BPF 程序时，若其 `attach_func_name` 以 `bpf_iter_` 开头，则调用 `bpf_iter_prog_supported()` 验证并绑定到对应目标。\n3. **文件打开**：用户打开 BPF 迭代器链接创建的文件时，`iter_open()` 调用 `prepare_seq_file()` 初始化 `seq_file`。\n4. **数据读取**：`bpf_seq_read()` 驱动迭代过程：\n   - 调用 `seq->op->start()` 获取首个对象\n   - 循环调用 `next()` 和 `show()`，其中 `show()` 可能执行 BPF 程序生成输出\n   - 支持在 `show()` 中返回 `>0` 跳过当前对象（通过 `bpf_iter_dec_seq_num()` 回退序列号）\n   - 限制最大迭代对象数（`MAX_ITER_OBJECTS = 1,000,000`）防止无限循环\n   - 支持可抢占目标（`BPF_ITER_RESCHED` 特性）在循环中调用 `cond_resched()`\n5. **结束**：`stop()` 回调被调用，可能再次执行 BPF 程序进行清理。\n\n### 安全与健壮性机制\n- **溢出保护**：检查 `seq_has_overflowed()` 防止缓冲区溢出，返回 `-E2BIG`\n- **对象数量限制**：防止恶意程序导致内核长时间占用 CPU\n- **序列号管理**：精确跟踪当前迭代位置，支持对象跳过\n- **会话隔离**：每个文件打开对应独立的 `session_id` 和私有数据\n\n### BTF ID 缓存优化\n- 首次匹配目标时，将程序的 `attach_btf_id` 缓存到 `tinfo->btf_id`\n- 后续程序可直接通过 BTF ID 快速匹配，避免字符串比较\n\n## 4. 依赖关系\n\n- **BPF 核心**：依赖 `linux/bpf.h`、`bpf_link` 机制和 BPF 程序管理（`bpf_prog_put`）\n- **VFS/seq_file**：基于 `linux/fs.h` 和 `seq_file` 框架实现迭代输出\n- **内存管理**：使用 `kvmalloc` 分配大缓冲区（`PAGE_SIZE << 3`）\n- **RCU/锁机制**：使用 `mutex`（`targets_mutex`, `link_mutex`）保护全局链表\n- **BTF（BPF Type Format）**：通过 `attach_btf_id` 和函数名匹配程序与目标\n- **调度器**：支持可抢占目标时调用 `cond_resched()`\n\n## 5. 使用场景\n\n1. **内核数据遍历**：用户空间安全读取内核内部数据结构，例如：\n   - 遍历所有进程（`bpf_iter_task`）\n   - 遍历 BPF 映射内容（`bpf_iter_map_elem`）\n   - 遍历网络连接（`bpf_iter_tcp`）\n2. **调试与监控**：替代 `/proc` 或 `debugfs` 接口，提供更灵活、可编程的数据导出\n3. **性能分析**：高效收集内核状态快照，避免频繁系统调用开销\n4. **安全审计**：以只读方式检查内核对象，无需暴露原始指针或增加系统调用\n\n> **注**：该文件被截断，实际 `bpf_iter_prog_supported()` 函数未完整显示，但核心逻辑已涵盖。完整实现还需处理 `ctx_arg_info` 等上下文参数配置。",
      "similarity": 0.4871863126754761,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 577,
          "end_line": 699,
          "content": [
            "static void init_seq_meta(struct bpf_iter_priv_data *priv_data,",
            "\t\t\t  struct bpf_iter_target_info *tinfo,",
            "\t\t\t  const struct bpf_iter_seq_info *seq_info,",
            "\t\t\t  struct bpf_prog *prog)",
            "{",
            "\tpriv_data->tinfo = tinfo;",
            "\tpriv_data->seq_info = seq_info;",
            "\tpriv_data->prog = prog;",
            "\tpriv_data->session_id = atomic64_inc_return(&session_id);",
            "\tpriv_data->seq_num = 0;",
            "\tpriv_data->done_stop = false;",
            "}",
            "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,",
            "\t\t\t    const struct bpf_iter_seq_info *seq_info)",
            "{",
            "\tstruct bpf_iter_priv_data *priv_data;",
            "\tstruct bpf_iter_target_info *tinfo;",
            "\tstruct bpf_prog *prog;",
            "\tu32 total_priv_dsize;",
            "\tstruct seq_file *seq;",
            "\tint err = 0;",
            "",
            "\tmutex_lock(&link_mutex);",
            "\tprog = link->link.prog;",
            "\tbpf_prog_inc(prog);",
            "\tmutex_unlock(&link_mutex);",
            "",
            "\ttinfo = link->tinfo;",
            "\ttotal_priv_dsize = offsetof(struct bpf_iter_priv_data, target_private) +",
            "\t\t\t   seq_info->seq_priv_size;",
            "\tpriv_data = __seq_open_private(file, seq_info->seq_ops,",
            "\t\t\t\t       total_priv_dsize);",
            "\tif (!priv_data) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto release_prog;",
            "\t}",
            "",
            "\tif (seq_info->init_seq_private) {",
            "\t\terr = seq_info->init_seq_private(priv_data->target_private, &link->aux);",
            "\t\tif (err)",
            "\t\t\tgoto release_seq_file;",
            "\t}",
            "",
            "\tinit_seq_meta(priv_data, tinfo, seq_info, prog);",
            "\tseq = file->private_data;",
            "\tseq->private = priv_data->target_private;",
            "",
            "\treturn 0;",
            "",
            "release_seq_file:",
            "\tseq_release_private(file->f_inode, file);",
            "\tfile->private_data = NULL;",
            "release_prog:",
            "\tbpf_prog_put(prog);",
            "\treturn err;",
            "}",
            "int bpf_iter_new_fd(struct bpf_link *link)",
            "{",
            "\tstruct bpf_iter_link *iter_link;",
            "\tstruct file *file;",
            "\tunsigned int flags;",
            "\tint err, fd;",
            "",
            "\tif (link->ops != &bpf_iter_link_lops)",
            "\t\treturn -EINVAL;",
            "",
            "\tflags = O_RDONLY | O_CLOEXEC;",
            "\tfd = get_unused_fd_flags(flags);",
            "\tif (fd < 0)",
            "\t\treturn fd;",
            "",
            "\tfile = anon_inode_getfile(\"bpf_iter\", &bpf_iter_fops, NULL, flags);",
            "\tif (IS_ERR(file)) {",
            "\t\terr = PTR_ERR(file);",
            "\t\tgoto free_fd;",
            "\t}",
            "",
            "\titer_link = container_of(link, struct bpf_iter_link, link);",
            "\terr = prepare_seq_file(file, iter_link, __get_seq_info(iter_link));",
            "\tif (err)",
            "\t\tgoto free_file;",
            "",
            "\tfd_install(fd, file);",
            "\treturn fd;",
            "",
            "free_file:",
            "\tfput(file);",
            "free_fd:",
            "\tput_unused_fd(fd);",
            "\treturn err;",
            "}",
            "int bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)",
            "{",
            "\tstruct bpf_run_ctx run_ctx, *old_run_ctx;",
            "\tint ret;",
            "",
            "\tif (prog->sleepable) {",
            "\t\trcu_read_lock_trace();",
            "\t\tmigrate_disable();",
            "\t\tmight_fault();",
            "\t\told_run_ctx = bpf_set_run_ctx(&run_ctx);",
            "\t\tret = bpf_prog_run(prog, ctx);",
            "\t\tbpf_reset_run_ctx(old_run_ctx);",
            "\t\tmigrate_enable();",
            "\t\trcu_read_unlock_trace();",
            "\t} else {",
            "\t\trcu_read_lock();",
            "\t\tmigrate_disable();",
            "\t\told_run_ctx = bpf_set_run_ctx(&run_ctx);",
            "\t\tret = bpf_prog_run(prog, ctx);",
            "\t\tbpf_reset_run_ctx(old_run_ctx);",
            "\t\tmigrate_enable();",
            "\t\trcu_read_unlock();",
            "\t}",
            "",
            "\t/* bpf program can only return 0 or 1:",
            "\t *  0 : okay",
            "\t *  1 : retry the same object",
            "\t * The bpf_iter_run_prog() return value",
            "\t * will be seq_ops->show() return value.",
            "\t */",
            "\treturn ret == 0 ? 0 : -EAGAIN;",
            "}"
          ],
          "function_name": "init_seq_meta, prepare_seq_file, bpf_iter_new_fd, bpf_iter_run_prog",
          "description": "实现序列文件元数据初始化、迭代器文件创建和BPF程序执行逻辑，通过prepare_seq_file准备序列上下文，bpf_iter_run_prog执行程序并根据返回值控制迭代行为。",
          "similarity": 0.5247901678085327
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 44,
          "end_line": 226,
          "content": [
            "static void bpf_iter_inc_seq_num(struct seq_file *seq)",
            "{",
            "\tstruct bpf_iter_priv_data *iter_priv;",
            "",
            "\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,",
            "\t\t\t\t target_private);",
            "\titer_priv->seq_num++;",
            "}",
            "static void bpf_iter_dec_seq_num(struct seq_file *seq)",
            "{",
            "\tstruct bpf_iter_priv_data *iter_priv;",
            "",
            "\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,",
            "\t\t\t\t target_private);",
            "\titer_priv->seq_num--;",
            "}",
            "static void bpf_iter_done_stop(struct seq_file *seq)",
            "{",
            "\tstruct bpf_iter_priv_data *iter_priv;",
            "",
            "\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,",
            "\t\t\t\t target_private);",
            "\titer_priv->done_stop = true;",
            "}",
            "static inline bool bpf_iter_target_support_resched(const struct bpf_iter_target_info *tinfo)",
            "{",
            "\treturn tinfo->reg_info->feature & BPF_ITER_RESCHED;",
            "}",
            "static bool bpf_iter_support_resched(struct seq_file *seq)",
            "{",
            "\tstruct bpf_iter_priv_data *iter_priv;",
            "",
            "\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,",
            "\t\t\t\t target_private);",
            "\treturn bpf_iter_target_support_resched(iter_priv->tinfo);",
            "}",
            "static ssize_t bpf_seq_read(struct file *file, char __user *buf, size_t size,",
            "\t\t\t    loff_t *ppos)",
            "{",
            "\tstruct seq_file *seq = file->private_data;",
            "\tsize_t n, offs, copied = 0;",
            "\tint err = 0, num_objs = 0;",
            "\tbool can_resched;",
            "\tvoid *p;",
            "",
            "\tmutex_lock(&seq->lock);",
            "",
            "\tif (!seq->buf) {",
            "\t\tseq->size = PAGE_SIZE << 3;",
            "\t\tseq->buf = kvmalloc(seq->size, GFP_KERNEL);",
            "\t\tif (!seq->buf) {",
            "\t\t\terr = -ENOMEM;",
            "\t\t\tgoto done;",
            "\t\t}",
            "\t}",
            "",
            "\tif (seq->count) {",
            "\t\tn = min(seq->count, size);",
            "\t\terr = copy_to_user(buf, seq->buf + seq->from, n);",
            "\t\tif (err) {",
            "\t\t\terr = -EFAULT;",
            "\t\t\tgoto done;",
            "\t\t}",
            "\t\tseq->count -= n;",
            "\t\tseq->from += n;",
            "\t\tcopied = n;",
            "\t\tgoto done;",
            "\t}",
            "",
            "\tseq->from = 0;",
            "\tp = seq->op->start(seq, &seq->index);",
            "\tif (!p)",
            "\t\tgoto stop;",
            "\tif (IS_ERR(p)) {",
            "\t\terr = PTR_ERR(p);",
            "\t\tseq->op->stop(seq, p);",
            "\t\tseq->count = 0;",
            "\t\tgoto done;",
            "\t}",
            "",
            "\terr = seq->op->show(seq, p);",
            "\tif (err > 0) {",
            "\t\t/* object is skipped, decrease seq_num, so next",
            "\t\t * valid object can reuse the same seq_num.",
            "\t\t */",
            "\t\tbpf_iter_dec_seq_num(seq);",
            "\t\tseq->count = 0;",
            "\t} else if (err < 0 || seq_has_overflowed(seq)) {",
            "\t\tif (!err)",
            "\t\t\terr = -E2BIG;",
            "\t\tseq->op->stop(seq, p);",
            "\t\tseq->count = 0;",
            "\t\tgoto done;",
            "\t}",
            "",
            "\tcan_resched = bpf_iter_support_resched(seq);",
            "\twhile (1) {",
            "\t\tloff_t pos = seq->index;",
            "",
            "\t\tnum_objs++;",
            "\t\toffs = seq->count;",
            "\t\tp = seq->op->next(seq, p, &seq->index);",
            "\t\tif (pos == seq->index) {",
            "\t\t\tpr_info_ratelimited(\"buggy seq_file .next function %ps \"",
            "\t\t\t\t\"did not updated position index\\n\",",
            "\t\t\t\tseq->op->next);",
            "\t\t\tseq->index++;",
            "\t\t}",
            "",
            "\t\tif (IS_ERR_OR_NULL(p))",
            "\t\t\tbreak;",
            "",
            "\t\t/* got a valid next object, increase seq_num */",
            "\t\tbpf_iter_inc_seq_num(seq);",
            "",
            "\t\tif (seq->count >= size)",
            "\t\t\tbreak;",
            "",
            "\t\tif (num_objs >= MAX_ITER_OBJECTS) {",
            "\t\t\tif (offs == 0) {",
            "\t\t\t\terr = -EAGAIN;",
            "\t\t\t\tseq->op->stop(seq, p);",
            "\t\t\t\tgoto done;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\terr = seq->op->show(seq, p);",
            "\t\tif (err > 0) {",
            "\t\t\tbpf_iter_dec_seq_num(seq);",
            "\t\t\tseq->count = offs;",
            "\t\t} else if (err < 0 || seq_has_overflowed(seq)) {",
            "\t\t\tseq->count = offs;",
            "\t\t\tif (offs == 0) {",
            "\t\t\t\tif (!err)",
            "\t\t\t\t\terr = -E2BIG;",
            "\t\t\t\tseq->op->stop(seq, p);",
            "\t\t\t\tgoto done;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (can_resched)",
            "\t\t\tcond_resched();",
            "\t}",
            "stop:",
            "\toffs = seq->count;",
            "\tif (IS_ERR(p)) {",
            "\t\tseq->op->stop(seq, NULL);",
            "\t\terr = PTR_ERR(p);",
            "\t\tgoto done;",
            "\t}",
            "\t/* bpf program called if !p */",
            "\tseq->op->stop(seq, p);",
            "\tif (!p) {",
            "\t\tif (!seq_has_overflowed(seq)) {",
            "\t\t\tbpf_iter_done_stop(seq);",
            "\t\t} else {",
            "\t\t\tseq->count = offs;",
            "\t\t\tif (offs == 0) {",
            "\t\t\t\terr = -E2BIG;",
            "\t\t\t\tgoto done;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tn = min(seq->count, size);",
            "\terr = copy_to_user(buf, seq->buf, n);",
            "\tif (err) {",
            "\t\terr = -EFAULT;",
            "\t\tgoto done;",
            "\t}",
            "\tcopied = n;",
            "\tseq->count -= n;",
            "\tseq->from = n;",
            "done:",
            "\tif (!copied)",
            "\t\tcopied = err;",
            "\telse",
            "\t\t*ppos += copied;",
            "\tmutex_unlock(&seq->lock);",
            "\treturn copied;",
            "}"
          ],
          "function_name": "bpf_iter_inc_seq_num, bpf_iter_dec_seq_num, bpf_iter_done_stop, bpf_iter_target_support_resched, bpf_iter_support_resched, bpf_seq_read",
          "description": "实现BPF迭代器的序列文件操作辅助函数，包含计数器增减、支持重新调度判断和seq_read方法，通过维护seq_num和done_stop标志控制迭代流程并处理对象展示。",
          "similarity": 0.52422696352005
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 786,
          "end_line": 821,
          "content": [
            "__bpf_kfunc int bpf_iter_num_new(struct bpf_iter_num *it, int start, int end)",
            "{",
            "\tstruct bpf_iter_num_kern *s = (void *)it;",
            "",
            "\tBUILD_BUG_ON(sizeof(struct bpf_iter_num_kern) != sizeof(struct bpf_iter_num));",
            "\tBUILD_BUG_ON(__alignof__(struct bpf_iter_num_kern) != __alignof__(struct bpf_iter_num));",
            "",
            "\t/* start == end is legit, it's an empty range and we'll just get NULL",
            "\t * on first (and any subsequent) bpf_iter_num_next() call",
            "\t */",
            "\tif (start > end) {",
            "\t\ts->cur = s->end = 0;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* avoid overflows, e.g., if start == INT_MIN and end == INT_MAX */",
            "\tif ((s64)end - (s64)start > BPF_MAX_LOOPS) {",
            "\t\ts->cur = s->end = 0;",
            "\t\treturn -E2BIG;",
            "\t}",
            "",
            "\t/* user will call bpf_iter_num_next() first,",
            "\t * which will set s->cur to exactly start value;",
            "\t * underflow shouldn't matter",
            "\t */",
            "\ts->cur = start - 1;",
            "\ts->end = end;",
            "",
            "\treturn 0;",
            "}",
            "__bpf_kfunc void bpf_iter_num_destroy(struct bpf_iter_num *it)",
            "{",
            "\tstruct bpf_iter_num_kern *s = (void *)it;",
            "",
            "\ts->cur = s->end = 0;",
            "}"
          ],
          "function_name": "bpf_iter_num_new, bpf_iter_num_destroy",
          "description": "该代码段实现了BPF数值范围迭代器的创建与销毁功能。`bpf_iter_num_new`用于初始化一个指定起始/终止值的迭代器对象并进行边界检查，`bpf_iter_num_destroy`负责清空迭代器状态。因上下文不完整，未展示迭代器实际遍历逻辑及配套API。",
          "similarity": 0.47810354828834534
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 402,
          "end_line": 562,
          "content": [
            "static void bpf_iter_link_dealloc(struct bpf_link *link)",
            "{",
            "\tstruct bpf_iter_link *iter_link =",
            "\t\tcontainer_of(link, struct bpf_iter_link, link);",
            "",
            "\tkfree(iter_link);",
            "}",
            "static int bpf_iter_link_replace(struct bpf_link *link,",
            "\t\t\t\t struct bpf_prog *new_prog,",
            "\t\t\t\t struct bpf_prog *old_prog)",
            "{",
            "\tint ret = 0;",
            "",
            "\tmutex_lock(&link_mutex);",
            "\tif (old_prog && link->prog != old_prog) {",
            "\t\tret = -EPERM;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tif (link->prog->type != new_prog->type ||",
            "\t    link->prog->expected_attach_type != new_prog->expected_attach_type ||",
            "\t    link->prog->aux->attach_btf_id != new_prog->aux->attach_btf_id) {",
            "\t\tret = -EINVAL;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\told_prog = xchg(&link->prog, new_prog);",
            "\tbpf_prog_put(old_prog);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&link_mutex);",
            "\treturn ret;",
            "}",
            "static void bpf_iter_link_show_fdinfo(const struct bpf_link *link,",
            "\t\t\t\t      struct seq_file *seq)",
            "{",
            "\tstruct bpf_iter_link *iter_link =",
            "\t\tcontainer_of(link, struct bpf_iter_link, link);",
            "\tbpf_iter_show_fdinfo_t show_fdinfo;",
            "",
            "\tseq_printf(seq,",
            "\t\t   \"target_name:\\t%s\\n\",",
            "\t\t   iter_link->tinfo->reg_info->target);",
            "",
            "\tshow_fdinfo = iter_link->tinfo->reg_info->show_fdinfo;",
            "\tif (show_fdinfo)",
            "\t\tshow_fdinfo(&iter_link->aux, seq);",
            "}",
            "static int bpf_iter_link_fill_link_info(const struct bpf_link *link,",
            "\t\t\t\t\tstruct bpf_link_info *info)",
            "{",
            "\tstruct bpf_iter_link *iter_link =",
            "\t\tcontainer_of(link, struct bpf_iter_link, link);",
            "\tchar __user *ubuf = u64_to_user_ptr(info->iter.target_name);",
            "\tbpf_iter_fill_link_info_t fill_link_info;",
            "\tu32 ulen = info->iter.target_name_len;",
            "\tconst char *target_name;",
            "\tu32 target_len;",
            "",
            "\tif (!ulen ^ !ubuf)",
            "\t\treturn -EINVAL;",
            "",
            "\ttarget_name = iter_link->tinfo->reg_info->target;",
            "\ttarget_len =  strlen(target_name);",
            "\tinfo->iter.target_name_len = target_len + 1;",
            "",
            "\tif (ubuf) {",
            "\t\tif (ulen >= target_len + 1) {",
            "\t\t\tif (copy_to_user(ubuf, target_name, target_len + 1))",
            "\t\t\t\treturn -EFAULT;",
            "\t\t} else {",
            "\t\t\tchar zero = '\\0';",
            "",
            "\t\t\tif (copy_to_user(ubuf, target_name, ulen - 1))",
            "\t\t\t\treturn -EFAULT;",
            "\t\t\tif (put_user(zero, ubuf + ulen - 1))",
            "\t\t\t\treturn -EFAULT;",
            "\t\t\treturn -ENOSPC;",
            "\t\t}",
            "\t}",
            "",
            "\tfill_link_info = iter_link->tinfo->reg_info->fill_link_info;",
            "\tif (fill_link_info)",
            "\t\treturn fill_link_info(&iter_link->aux, info);",
            "",
            "\treturn 0;",
            "}",
            "bool bpf_link_is_iter(struct bpf_link *link)",
            "{",
            "\treturn link->ops == &bpf_iter_link_lops;",
            "}",
            "int bpf_iter_link_attach(const union bpf_attr *attr, bpfptr_t uattr,",
            "\t\t\t struct bpf_prog *prog)",
            "{",
            "\tstruct bpf_iter_target_info *tinfo = NULL, *iter;",
            "\tstruct bpf_link_primer link_primer;",
            "\tunion bpf_iter_link_info linfo;",
            "\tstruct bpf_iter_link *link;",
            "\tu32 prog_btf_id, linfo_len;",
            "\tbpfptr_t ulinfo;",
            "\tint err;",
            "",
            "\tif (attr->link_create.target_fd || attr->link_create.flags)",
            "\t\treturn -EINVAL;",
            "",
            "\tmemset(&linfo, 0, sizeof(union bpf_iter_link_info));",
            "",
            "\tulinfo = make_bpfptr(attr->link_create.iter_info, uattr.is_kernel);",
            "\tlinfo_len = attr->link_create.iter_info_len;",
            "\tif (bpfptr_is_null(ulinfo) ^ !linfo_len)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!bpfptr_is_null(ulinfo)) {",
            "\t\terr = bpf_check_uarg_tail_zero(ulinfo, sizeof(linfo),",
            "\t\t\t\t\t       linfo_len);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t\tlinfo_len = min_t(u32, linfo_len, sizeof(linfo));",
            "\t\tif (copy_from_bpfptr(&linfo, ulinfo, linfo_len))",
            "\t\t\treturn -EFAULT;",
            "\t}",
            "",
            "\tprog_btf_id = prog->aux->attach_btf_id;",
            "\tmutex_lock(&targets_mutex);",
            "\tlist_for_each_entry(iter, &targets, list) {",
            "\t\tif (iter->btf_id == prog_btf_id) {",
            "\t\t\ttinfo = iter;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&targets_mutex);",
            "\tif (!tinfo)",
            "\t\treturn -ENOENT;",
            "",
            "\t/* Only allow sleepable program for resched-able iterator */",
            "\tif (prog->sleepable && !bpf_iter_target_support_resched(tinfo))",
            "\t\treturn -EINVAL;",
            "",
            "\tlink = kzalloc(sizeof(*link), GFP_USER | __GFP_NOWARN);",
            "\tif (!link)",
            "\t\treturn -ENOMEM;",
            "",
            "\tbpf_link_init(&link->link, BPF_LINK_TYPE_ITER, &bpf_iter_link_lops, prog);",
            "\tlink->tinfo = tinfo;",
            "",
            "\terr = bpf_link_prime(&link->link, &link_primer);",
            "\tif (err) {",
            "\t\tkfree(link);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tif (tinfo->reg_info->attach_target) {",
            "\t\terr = tinfo->reg_info->attach_target(prog, &linfo, &link->aux);",
            "\t\tif (err) {",
            "\t\t\tbpf_link_cleanup(&link_primer);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t}",
            "",
            "\treturn bpf_link_settle(&link_primer);",
            "}"
          ],
          "function_name": "bpf_iter_link_dealloc, bpf_iter_link_replace, bpf_iter_link_show_fdinfo, bpf_iter_link_fill_link_info, bpf_link_is_iter, bpf_iter_link_attach",
          "description": "定义BPF迭代器链接操作函数，包含链接销毁、替换、信息展示和附件绑定逻辑，验证链接类型并处理目标附加参数，确保迭代器链接的生命周期管理。",
          "similarity": 0.4259665608406067
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 1,
          "end_line": 43,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2020 Facebook */",
            "",
            "#include <linux/fs.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/rcupdate_trace.h>",
            "",
            "struct bpf_iter_target_info {",
            "\tstruct list_head list;",
            "\tconst struct bpf_iter_reg *reg_info;",
            "\tu32 btf_id;\t/* cached value */",
            "};",
            "",
            "struct bpf_iter_link {",
            "\tstruct bpf_link link;",
            "\tstruct bpf_iter_aux_info aux;",
            "\tstruct bpf_iter_target_info *tinfo;",
            "};",
            "",
            "struct bpf_iter_priv_data {",
            "\tstruct bpf_iter_target_info *tinfo;",
            "\tconst struct bpf_iter_seq_info *seq_info;",
            "\tstruct bpf_prog *prog;",
            "\tu64 session_id;",
            "\tu64 seq_num;",
            "\tbool done_stop;",
            "\tu8 target_private[] __aligned(8);",
            "};",
            "",
            "static struct list_head targets = LIST_HEAD_INIT(targets);",
            "static DEFINE_MUTEX(targets_mutex);",
            "",
            "/* protect bpf_iter_link changes */",
            "static DEFINE_MUTEX(link_mutex);",
            "",
            "/* incremented on every opened seq_file */",
            "static atomic64_t session_id;",
            "",
            "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,",
            "\t\t\t    const struct bpf_iter_seq_info *seq_info);",
            ""
          ],
          "function_name": null,
          "description": "声明BPF迭代器相关结构体及全局变量，定义用于管理迭代器目标信息、链接和私有数据的结构体，并初始化保护目标列表的互斥锁和会话ID原子变量。",
          "similarity": 0.4233681559562683
        }
      ]
    }
  ]
}