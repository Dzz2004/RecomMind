{
  "query": "Linux内核中task_struct结构体的作用",
  "timestamp": "2025-12-26 00:45:13",
  "retrieved_files": [
    {
      "source_file": "kernel/taskstats.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:34:26\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `taskstats.c`\n\n---\n\n# taskstats.c 技术文档\n\n## 1. 文件概述\n\n`taskstats.c` 是 Linux 内核中用于向用户空间导出每个任务（task）统计信息的核心实现文件。该模块通过通用 Netlink（Generic Netlink, genetlink）接口，提供对进程和线程组（TGID）的详细资源使用统计，包括 CPU 时间、上下文切换、延迟会计（delay accounting）、扩展会计（extended accounting）以及可执行文件元数据等。此外，还支持基于 CPU 掩码的监听器注册机制，允许用户空间程序订阅特定 CPU 上任务退出时的统计信息。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct listener`**：表示一个注册的监听器，包含 PID 和有效性标志。\n- **`struct listener_list`**：每个 CPU 上的监听器链表，受读写信号量保护。\n- **`taskstats_cache`**：用于分配 `struct taskstats` 的 slab 缓存。\n- **`family`**：Generic Netlink 通信家族实例。\n\n### 主要函数\n\n- **`prepare_reply()`**：为 Generic Netlink 消息准备回复缓冲区。\n- **`send_reply()`**：向请求者发送单播回复。\n- **`send_cpu_listeners()`**：向注册在特定 CPU 上的所有监听器广播任务统计信息。\n- **`fill_stats()`**：填充单个任务的完整统计信息。\n- **`fill_stats_for_pid()`**：根据 PID 填充对应任务的统计。\n- **`fill_stats_for_tgid()`**：聚合线程组内所有活跃线程的统计信息。\n- **`fill_tgid_exit()`**：在线程退出时，将其统计累加到所属线程组的汇总结构中。\n- **`add_del_listener()`**：注册或注销监听特定 CPU 任务退出事件的用户空间进程。\n- **`exe_add_tsk()`**：提取任务可执行文件的设备号和 inode 号。\n\n### Netlink 策略定义\n\n- `taskstats_cmd_get_policy[]`：定义 `TASKSTATS_CMD_ATTR_*` 属性的解析规则。\n- `cgroupstats_cmd_get_policy[]`：定义 `CGROUPSTATS_CMD_ATTR_FD` 属性的解析规则。\n\n## 3. 关键实现\n\n### 统计信息聚合机制\n\n- **单任务统计**：通过 `fill_stats()` 调用多个子系统（如 `delayacct_add_tsk`、`bacct_add_tsk`、`xacct_add_tsk`）分别填充延迟、基础会计、扩展会计等字段。\n- **线程组统计**：`fill_stats_for_tgid()` 遍历线程组内所有非退出线程，累加 CPU 时间、上下文切换次数，并计算运行时长（`ac_etime`）。\n- **退出时聚合**：当线程退出时，`fill_tgid_exit()` 将其统计信息累加到 `task_struct->signal->stats` 中，供后续查询使用。\n\n### 监听器管理\n\n- 每个 CPU 维护一个独立的 `listener_list`，使用 per-CPU 变量 `listener_array` 存储。\n- 监听器通过 `add_del_listener()` 注册/注销，仅允许在初始用户命名空间和 PID 命名空间中操作。\n- 发送消息时采用“克隆 skb”策略：除最后一个监听器外，其余均使用 `skb_clone()` 保证每个接收者获得独立副本。\n- 自动清理无效监听器：若 `genlmsg_unicast()` 返回 `-ECONNREFUSED`，标记该监听器无效，并在后续批量删除。\n\n### 安全与命名空间限制\n\n- 仅允许 `init_user_ns` 和 `init_pid_ns` 中的进程注册监听器，防止容器内进程干扰全局统计。\n- 对注册的 CPU 掩码进行合法性校验（必须是 `cpu_possible_mask` 的子集）。\n\n### 内存与并发控制\n\n- 使用 `rw_semaphore` 保护监听器链表，读操作（发送）并发，写操作（增删）互斥。\n- `taskstats_seqnum` 为 per-CPU 序列号，用于无请求上下文时的消息标识。\n- 所有动态分配均考虑 NUMA 节点亲和性（`kmalloc_node`）。\n\n## 4. 依赖关系\n\n- **Generic Netlink (`<net/genetlink.h>`)**：提供用户空间通信通道。\n- **延迟会计 (`<linux/delayacct.h>`)**：提供 I/O、调度等延迟统计。\n- **进程会计 (`<linux/acct.h>`, `<linux/tsacct_kern.h>`)**：提供基础和扩展会计信息。\n- **CGroup 统计 (`<linux/cgroupstats.h>`)**：虽未在截断代码中完整体现，但头文件包含表明支持 cgroup 级别统计。\n- **调度与任务管理 (`<linux/sched/cputime.h>`, `<linux/pid_namespace.h>`)**：获取任务 CPU 时间、PID 命名空间信息。\n- **内存管理 (`<linux/slab.h>`, `<linux/percpu.h>`)**：slab 缓存和 per-CPU 数据结构支持。\n\n## 5. 使用场景\n\n- **性能分析工具**：如 `pidstat`、`perf` 等可通过 taskstats 获取高精度任务资源使用数据。\n- **资源监控系统**：实时收集进程 CPU、上下文切换、延迟等指标，用于系统调优或异常检测。\n- **作业调度器**：根据历史任务统计信息优化任务放置策略。\n- **容器运行时**：虽受限于命名空间，但宿主机监控工具可利用此接口获取容器内进程统计（需通过宿主机 PID）。\n- **内核调试**：开发人员可通过监听任务退出事件，分析进程生命周期行为。",
      "similarity": 0.6604220867156982,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/taskstats.c",
          "start_line": 1,
          "end_line": 65,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * taskstats.c - Export per-task statistics to userland",
            " *",
            " * Copyright (C) Shailabh Nagar, IBM Corp. 2006",
            " *           (C) Balbir Singh,   IBM Corp. 2006",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/pid_namespace.h>",
            "#include <net/genetlink.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/cputime.h>",
            "",
            "/*",
            " * Maximum length of a cpumask that can be specified in",
            " * the TASKSTATS_CMD_ATTR_REGISTER/DEREGISTER_CPUMASK attribute",
            " */",
            "#define TASKSTATS_CPUMASK_MAXLEN\t(100+6*NR_CPUS)",
            "",
            "static DEFINE_PER_CPU(__u32, taskstats_seqnum);",
            "static int family_registered;",
            "struct kmem_cache *taskstats_cache;",
            "",
            "static struct genl_family family;",
            "",
            "static const struct nla_policy taskstats_cmd_get_policy[] = {",
            "\t[TASKSTATS_CMD_ATTR_PID]  = { .type = NLA_U32 },",
            "\t[TASKSTATS_CMD_ATTR_TGID] = { .type = NLA_U32 },",
            "\t[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK] = { .type = NLA_STRING },",
            "\t[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK] = { .type = NLA_STRING },};",
            "",
            "static const struct nla_policy cgroupstats_cmd_get_policy[] = {",
            "\t[CGROUPSTATS_CMD_ATTR_FD] = { .type = NLA_U32 },",
            "};",
            "",
            "struct listener {",
            "\tstruct list_head list;",
            "\tpid_t pid;",
            "\tchar valid;",
            "};",
            "",
            "struct listener_list {",
            "\tstruct rw_semaphore sem;",
            "\tstruct list_head list;",
            "};",
            "static DEFINE_PER_CPU(struct listener_list, listener_array);",
            "",
            "enum actions {",
            "\tREGISTER,",
            "\tDEREGISTER,",
            "\tCPU_DONT_CARE",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义TASKSTATS模块的GENL协议族及其属性策略，初始化用于任务统计的内核结构体和全局变量，支持通过Netlink接口导出任务统计信息。",
          "similarity": 0.590475857257843
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/taskstats.c",
          "start_line": 690,
          "end_line": 711,
          "content": [
            "void __init taskstats_init_early(void)",
            "{",
            "\tunsigned int i;",
            "",
            "\ttaskstats_cache = KMEM_CACHE(taskstats, SLAB_PANIC);",
            "\tfor_each_possible_cpu(i) {",
            "\t\tINIT_LIST_HEAD(&(per_cpu(listener_array, i).list));",
            "\t\tinit_rwsem(&(per_cpu(listener_array, i).sem));",
            "\t}",
            "}",
            "static int __init taskstats_init(void)",
            "{",
            "\tint rc;",
            "",
            "\trc = genl_register_family(&family);",
            "\tif (rc)",
            "\t\treturn rc;",
            "",
            "\tfamily_registered = 1;",
            "\tpr_info(\"registered taskstats version %d\\n\", TASKSTATS_GENL_VERSION);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "taskstats_init_early, taskstats_init",
          "description": "该代码段实现了任务统计模块的初始化逻辑，包含两个关键函数：  \n1. `taskstats_init_early` 初始化任务统计缓存及CPU本地监听器数据结构，用于多核环境下的同步与资源管理；  \n2. `taskstats_init` 注册GENL（Generic Netlink）家族以启用任务统计的网络接口通信。",
          "similarity": 0.5849666595458984
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/taskstats.c",
          "start_line": 66,
          "end_line": 189,
          "content": [
            "static int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,",
            "\t\t\t\tsize_t size)",
            "{",
            "\tstruct sk_buff *skb;",
            "\tvoid *reply;",
            "",
            "\t/*",
            "\t * If new attributes are added, please revisit this allocation",
            "\t */",
            "\tskb = genlmsg_new(size, GFP_KERNEL);",
            "\tif (!skb)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (!info) {",
            "\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;",
            "",
            "\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);",
            "\t} else",
            "\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);",
            "\tif (reply == NULL) {",
            "\t\tnlmsg_free(skb);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t*skbp = skb;",
            "\treturn 0;",
            "}",
            "static int send_reply(struct sk_buff *skb, struct genl_info *info)",
            "{",
            "\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));",
            "\tvoid *reply = genlmsg_data(genlhdr);",
            "",
            "\tgenlmsg_end(skb, reply);",
            "",
            "\treturn genlmsg_reply(skb, info);",
            "}",
            "static void send_cpu_listeners(struct sk_buff *skb,",
            "\t\t\t\t\tstruct listener_list *listeners)",
            "{",
            "\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));",
            "\tstruct listener *s, *tmp;",
            "\tstruct sk_buff *skb_next, *skb_cur = skb;",
            "\tvoid *reply = genlmsg_data(genlhdr);",
            "\tint delcount = 0;",
            "",
            "\tgenlmsg_end(skb, reply);",
            "",
            "\tdown_read(&listeners->sem);",
            "\tlist_for_each_entry(s, &listeners->list, list) {",
            "\t\tint rc;",
            "",
            "\t\tskb_next = NULL;",
            "\t\tif (!list_is_last(&s->list, &listeners->list)) {",
            "\t\t\tskb_next = skb_clone(skb_cur, GFP_KERNEL);",
            "\t\t\tif (!skb_next)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\trc = genlmsg_unicast(&init_net, skb_cur, s->pid);",
            "\t\tif (rc == -ECONNREFUSED) {",
            "\t\t\ts->valid = 0;",
            "\t\t\tdelcount++;",
            "\t\t}",
            "\t\tskb_cur = skb_next;",
            "\t}",
            "\tup_read(&listeners->sem);",
            "",
            "\tif (skb_cur)",
            "\t\tnlmsg_free(skb_cur);",
            "",
            "\tif (!delcount)",
            "\t\treturn;",
            "",
            "\t/* Delete invalidated entries */",
            "\tdown_write(&listeners->sem);",
            "\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {",
            "\t\tif (!s->valid) {",
            "\t\t\tlist_del(&s->list);",
            "\t\t\tkfree(s);",
            "\t\t}",
            "\t}",
            "\tup_write(&listeners->sem);",
            "}",
            "static void exe_add_tsk(struct taskstats *stats, struct task_struct *tsk)",
            "{",
            "\t/* No idea if I'm allowed to access that here, now. */",
            "\tstruct file *exe_file = get_task_exe_file(tsk);",
            "",
            "\tif (exe_file) {",
            "\t\t/* Following cp_new_stat64() in stat.c . */",
            "\t\tstats->ac_exe_dev =",
            "\t\t\thuge_encode_dev(exe_file->f_inode->i_sb->s_dev);",
            "\t\tstats->ac_exe_inode = exe_file->f_inode->i_ino;",
            "\t\tfput(exe_file);",
            "\t} else {",
            "\t\tstats->ac_exe_dev = 0;",
            "\t\tstats->ac_exe_inode = 0;",
            "\t}",
            "}",
            "static void fill_stats(struct user_namespace *user_ns,",
            "\t\t       struct pid_namespace *pid_ns,",
            "\t\t       struct task_struct *tsk, struct taskstats *stats)",
            "{",
            "\tmemset(stats, 0, sizeof(*stats));",
            "\t/*",
            "\t * Each accounting subsystem adds calls to its functions to",
            "\t * fill in relevant parts of struct taskstsats as follows",
            "\t *",
            "\t *\tper-task-foo(stats, tsk);",
            "\t */",
            "",
            "\tdelayacct_add_tsk(stats, tsk);",
            "",
            "\t/* fill in basic acct fields */",
            "\tstats->version = TASKSTATS_VERSION;",
            "\tstats->nvcsw = tsk->nvcsw;",
            "\tstats->nivcsw = tsk->nivcsw;",
            "\tbacct_add_tsk(user_ns, pid_ns, stats, tsk);",
            "",
            "\t/* fill in extended acct fields */",
            "\txacct_add_tsk(stats, tsk);",
            "",
            "\t/* add executable info */",
            "\texe_add_tsk(stats, tsk);",
            "}"
          ],
          "function_name": "prepare_reply, send_reply, send_cpu_listeners, exe_add_tsk, fill_stats",
          "description": "实现任务统计数据封装与分发逻辑，prepare_reply构造响应报文，send_reply发送响应，send_cpu_listeners向指定CPU的监听者广播数据，fill_stats填充任务核心统计字段。",
          "similarity": 0.560111403465271
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/taskstats.c",
          "start_line": 494,
          "end_line": 623,
          "content": [
            "static int cmd_attr_pid(struct genl_info *info)",
            "{",
            "\tstruct taskstats *stats;",
            "\tstruct sk_buff *rep_skb;",
            "\tsize_t size;",
            "\tu32 pid;",
            "\tint rc;",
            "",
            "\tsize = taskstats_packet_size();",
            "",
            "\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);",
            "\tif (rc < 0)",
            "\t\treturn rc;",
            "",
            "\trc = -EINVAL;",
            "\tpid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_PID]);",
            "\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID, pid);",
            "\tif (!stats)",
            "\t\tgoto err;",
            "",
            "\trc = fill_stats_for_pid(pid, stats);",
            "\tif (rc < 0)",
            "\t\tgoto err;",
            "\treturn send_reply(rep_skb, info);",
            "err:",
            "\tnlmsg_free(rep_skb);",
            "\treturn rc;",
            "}",
            "static int cmd_attr_tgid(struct genl_info *info)",
            "{",
            "\tstruct taskstats *stats;",
            "\tstruct sk_buff *rep_skb;",
            "\tsize_t size;",
            "\tu32 tgid;",
            "\tint rc;",
            "",
            "\tsize = taskstats_packet_size();",
            "",
            "\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);",
            "\tif (rc < 0)",
            "\t\treturn rc;",
            "",
            "\trc = -EINVAL;",
            "\ttgid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_TGID]);",
            "\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID, tgid);",
            "\tif (!stats)",
            "\t\tgoto err;",
            "",
            "\trc = fill_stats_for_tgid(tgid, stats);",
            "\tif (rc < 0)",
            "\t\tgoto err;",
            "\treturn send_reply(rep_skb, info);",
            "err:",
            "\tnlmsg_free(rep_skb);",
            "\treturn rc;",
            "}",
            "static int taskstats_user_cmd(struct sk_buff *skb, struct genl_info *info)",
            "{",
            "\tif (info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK])",
            "\t\treturn cmd_attr_register_cpumask(info);",
            "\telse if (info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK])",
            "\t\treturn cmd_attr_deregister_cpumask(info);",
            "\telse if (info->attrs[TASKSTATS_CMD_ATTR_PID])",
            "\t\treturn cmd_attr_pid(info);",
            "\telse if (info->attrs[TASKSTATS_CMD_ATTR_TGID])",
            "\t\treturn cmd_attr_tgid(info);",
            "\telse",
            "\t\treturn -EINVAL;",
            "}",
            "void taskstats_exit(struct task_struct *tsk, int group_dead)",
            "{",
            "\tint rc;",
            "\tstruct listener_list *listeners;",
            "\tstruct taskstats *stats;",
            "\tstruct sk_buff *rep_skb;",
            "\tsize_t size;",
            "\tint is_thread_group;",
            "",
            "\tif (!family_registered)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Size includes space for nested attributes",
            "\t */",
            "\tsize = taskstats_packet_size();",
            "",
            "\tis_thread_group = !!taskstats_tgid_alloc(tsk);",
            "\tif (is_thread_group) {",
            "\t\t/* PID + STATS + TGID + STATS */",
            "\t\tsize = 2 * size;",
            "\t\t/* fill the tsk->signal->stats structure */",
            "\t\tfill_tgid_exit(tsk);",
            "\t}",
            "",
            "\tlisteners = raw_cpu_ptr(&listener_array);",
            "\tif (list_empty(&listeners->list))",
            "\t\treturn;",
            "",
            "\trc = prepare_reply(NULL, TASKSTATS_CMD_NEW, &rep_skb, size);",
            "\tif (rc < 0)",
            "\t\treturn;",
            "",
            "\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID,",
            "\t\t\t task_pid_nr_ns(tsk, &init_pid_ns));",
            "\tif (!stats)",
            "\t\tgoto err;",
            "",
            "\tfill_stats(&init_user_ns, &init_pid_ns, tsk, stats);",
            "\tif (group_dead)",
            "\t\tstats->ac_flag |= AGROUP;",
            "",
            "\t/*",
            "\t * Doesn't matter if tsk is the leader or the last group member leaving",
            "\t */",
            "\tif (!is_thread_group || !group_dead)",
            "\t\tgoto send;",
            "",
            "\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID,",
            "\t\t\t task_tgid_nr_ns(tsk, &init_pid_ns));",
            "\tif (!stats)",
            "\t\tgoto err;",
            "",
            "\tmemcpy(stats, tsk->signal->stats, sizeof(*stats));",
            "",
            "send:",
            "\tsend_cpu_listeners(rep_skb, listeners);",
            "\treturn;",
            "err:",
            "\tnlmsg_free(rep_skb);",
            "}"
          ],
          "function_name": "cmd_attr_pid, cmd_attr_tgid, taskstats_user_cmd, taskstats_exit",
          "description": "处理TASKSTATS用户命令的主入口，cmd_attr_pid/tgid分别根据PID/TGID获取统计信息，taskstats_exit在任务终止时触发统计信息广播到所有已注册的监听器。",
          "similarity": 0.5207424759864807
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/taskstats.c",
          "start_line": 201,
          "end_line": 350,
          "content": [
            "static int fill_stats_for_pid(pid_t pid, struct taskstats *stats)",
            "{",
            "\tstruct task_struct *tsk;",
            "",
            "\ttsk = find_get_task_by_vpid(pid);",
            "\tif (!tsk)",
            "\t\treturn -ESRCH;",
            "\tfill_stats(current_user_ns(), task_active_pid_ns(current), tsk, stats);",
            "\tput_task_struct(tsk);",
            "\treturn 0;",
            "}",
            "static int fill_stats_for_tgid(pid_t tgid, struct taskstats *stats)",
            "{",
            "\tstruct task_struct *tsk, *first;",
            "\tunsigned long flags;",
            "\tint rc = -ESRCH;",
            "\tu64 delta, utime, stime;",
            "\tu64 start_time;",
            "",
            "\t/*",
            "\t * Add additional stats from live tasks except zombie thread group",
            "\t * leaders who are already counted with the dead tasks",
            "\t */",
            "\trcu_read_lock();",
            "\tfirst = find_task_by_vpid(tgid);",
            "",
            "\tif (!first || !lock_task_sighand(first, &flags))",
            "\t\tgoto out;",
            "",
            "\tif (first->signal->stats)",
            "\t\tmemcpy(stats, first->signal->stats, sizeof(*stats));",
            "\telse",
            "\t\tmemset(stats, 0, sizeof(*stats));",
            "",
            "\ttsk = first;",
            "\tstart_time = ktime_get_ns();",
            "\tdo {",
            "\t\tif (tsk->exit_state)",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * Accounting subsystem can call its functions here to",
            "\t\t * fill in relevant parts of struct taskstsats as follows",
            "\t\t *",
            "\t\t *\tper-task-foo(stats, tsk);",
            "\t\t */",
            "\t\tdelayacct_add_tsk(stats, tsk);",
            "",
            "\t\t/* calculate task elapsed time in nsec */",
            "\t\tdelta = start_time - tsk->start_time;",
            "\t\t/* Convert to micro seconds */",
            "\t\tdo_div(delta, NSEC_PER_USEC);",
            "\t\tstats->ac_etime += delta;",
            "",
            "\t\ttask_cputime(tsk, &utime, &stime);",
            "\t\tstats->ac_utime += div_u64(utime, NSEC_PER_USEC);",
            "\t\tstats->ac_stime += div_u64(stime, NSEC_PER_USEC);",
            "",
            "\t\tstats->nvcsw += tsk->nvcsw;",
            "\t\tstats->nivcsw += tsk->nivcsw;",
            "\t} while_each_thread(first, tsk);",
            "",
            "\tunlock_task_sighand(first, &flags);",
            "\trc = 0;",
            "out:",
            "\trcu_read_unlock();",
            "",
            "\tstats->version = TASKSTATS_VERSION;",
            "\t/*",
            "\t * Accounting subsystems can also add calls here to modify",
            "\t * fields of taskstats.",
            "\t */",
            "\treturn rc;",
            "}",
            "static void fill_tgid_exit(struct task_struct *tsk)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&tsk->sighand->siglock, flags);",
            "\tif (!tsk->signal->stats)",
            "\t\tgoto ret;",
            "",
            "\t/*",
            "\t * Each accounting subsystem calls its functions here to",
            "\t * accumalate its per-task stats for tsk, into the per-tgid structure",
            "\t *",
            "\t *\tper-task-foo(tsk->signal->stats, tsk);",
            "\t */",
            "\tdelayacct_add_tsk(tsk->signal->stats, tsk);",
            "ret:",
            "\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);",
            "\treturn;",
            "}",
            "static int add_del_listener(pid_t pid, const struct cpumask *mask, int isadd)",
            "{",
            "\tstruct listener_list *listeners;",
            "\tstruct listener *s, *tmp, *s2;",
            "\tunsigned int cpu;",
            "\tint ret = 0;",
            "",
            "\tif (!cpumask_subset(mask, cpu_possible_mask))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (current_user_ns() != &init_user_ns)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (task_active_pid_ns(current) != &init_pid_ns)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (isadd == REGISTER) {",
            "\t\tfor_each_cpu(cpu, mask) {",
            "\t\t\ts = kmalloc_node(sizeof(struct listener),",
            "\t\t\t\t\tGFP_KERNEL, cpu_to_node(cpu));",
            "\t\t\tif (!s) {",
            "\t\t\t\tret = -ENOMEM;",
            "\t\t\t\tgoto cleanup;",
            "\t\t\t}",
            "\t\t\ts->pid = pid;",
            "\t\t\ts->valid = 1;",
            "",
            "\t\t\tlisteners = &per_cpu(listener_array, cpu);",
            "\t\t\tdown_write(&listeners->sem);",
            "\t\t\tlist_for_each_entry(s2, &listeners->list, list) {",
            "\t\t\t\tif (s2->pid == pid && s2->valid)",
            "\t\t\t\t\tgoto exists;",
            "\t\t\t}",
            "\t\t\tlist_add(&s->list, &listeners->list);",
            "\t\t\ts = NULL;",
            "exists:",
            "\t\t\tup_write(&listeners->sem);",
            "\t\t\tkfree(s); /* nop if NULL */",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/* Deregister or cleanup */",
            "cleanup:",
            "\tfor_each_cpu(cpu, mask) {",
            "\t\tlisteners = &per_cpu(listener_array, cpu);",
            "\t\tdown_write(&listeners->sem);",
            "\t\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {",
            "\t\t\tif (s->pid == pid) {",
            "\t\t\t\tlist_del(&s->list);",
            "\t\t\t\tkfree(s);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tup_write(&listeners->sem);",
            "\t}",
            "\treturn ret;",
            "}"
          ],
          "function_name": "fill_stats_for_pid, fill_stats_for_tgid, fill_tgid_exit, add_del_listener",
          "description": "提供基于PID/TGID的任务统计查询接口，fill_stats_for_pid/tgid收集单个/整个线程组的统计信息，fill_tgid_exit处理进程组退出时的统计更新，add_del_listener管理跨CPU的监听器注册/注销。",
          "similarity": 0.5150934457778931
        }
      ]
    },
    {
      "source_file": "kernel/rseq.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:54:26\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `rseq.c`\n\n---\n\n# rseq.c 技术文档\n\n## 文件概述\n\n`rseq.c` 实现了 Linux 内核对 **Restartable Sequences（可重启序列）** 系统调用的支持。该机制允许用户空间程序在不使用重量级原子操作的前提下，高效地执行与调度器抢占、信号投递和 CPU 迁移相关的**伪原子操作**，特别适用于高性能的每 CPU（per-CPU）数据结构操作。该文件负责管理用户空间注册的 `struct rseq` TLS（线程局部存储）区域，并在任务被抢占、迁移或收到信号时，安全地中止并重定向用户空间执行流。\n\n## 核心功能\n\n### 主要数据结构\n- `struct rseq`：用户空间注册的 TLS 结构，包含 `cpu_id_start`、`cpu_id`、`node_id`、`mm_cid` 和 `rseq_cs`（critical section 描述符指针）等字段。\n- `struct rseq_cs`：用户空间关键区（critical section）的描述结构，包含起始地址、提交地址、中止地址和标志位。\n\n### 主要函数\n- `rseq_update_cpu_node_id(struct task_struct *t)`  \n  更新任务的 `rseq` TLS 区域中的 CPU ID、NUMA 节点 ID 和内存上下文 ID（mm_cid），用于反映当前执行上下文。\n  \n- `rseq_reset_rseq_cpu_node_id(struct task_struct *t)`  \n  将任务的 `rseq` TLS 区域重置为初始状态（`cpu_id` 设为 `RSEQ_CPU_ID_UNINITIALIZED`）。\n\n- `rseq_get_rseq_cs_ptr_val(struct rseq __user *rseq, u64 *rseq_cs)`  \n  从用户空间 `rseq` 结构中安全读取 `rseq_cs` 指针值。\n\n- `rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)`  \n  若 `rseq_cs` 指针有效，则从用户空间复制并验证 `struct rseq_cs` 内容（代码片段未完整展示）。\n\n- `rseq_validate_ro_fields(struct task_struct *t)`（仅在 `CONFIG_DEBUG_RSEQ` 下启用）  \n  验证用户空间 `rseq` 结构中应为只读的字段是否与内核副本一致，防止用户空间篡改。\n\n### 宏定义\n- `rseq_unsafe_put_user()`：在写入用户空间 `rseq` 字段的同时，同步更新内核中的副本（调试模式下），确保状态一致性。\n- `RSEQ_CS_NO_RESTART_FLAGS`：定义关键区中禁止因抢占、信号或迁移而重启的标志组合。\n\n## 关键实现\n\n### 可重启序列执行模型\n用户空间关键区执行流程如下：\n1. 将关键区描述符地址写入 TLS 的 `rseq->rseq_cs`；\n2. 比较 `cpu_id_start` 与当前 `cpu_id`，不一致则跳转至 `abort_ip`；\n3. 执行关键区操作；\n4. 成功提交后继续正常执行。\n\n若在步骤 1–3 之间发生**抢占、CPU 迁移或信号投递**，内核会：\n- 清空 `rseq->rseq_cs`（设为 NULL）；\n- 将用户空间返回地址设置为 `abort_ip`；\n- 恢复执行时跳转至中止处理逻辑。\n\n### 安全访问与调试支持\n- 使用 `user_read_access_begin/end()` 和 `user_write_access_begin/end()` 确保对用户空间内存的安全访问。\n- 在 `CONFIG_DEBUG_RSEQ` 模式下，内核维护 `rseq` 字段的内核副本，并在每次更新前后校验用户空间只读字段的一致性，防止恶意或错误的用户空间修改。\n- 通过 `trace_rseq_update()` 提供跟踪点，便于性能分析和调试。\n\n### 兼容性处理\n- 原始 `rseq` 结构大小为 32 字节（`ORIG_RSEQ_SIZE`）；\n- 对于扩展字段（如 `mm_cid`），仅在 `t->rseq_len > ORIG_RSEQ_SIZE` 时才进行更新或重置，确保向后兼容。\n\n## 依赖关系\n\n- **调度子系统**：依赖 `raw_smp_processor_id()` 获取当前 CPU，`task_mm_cid()` 获取内存上下文 ID。\n- **内存管理**：使用 `cpu_to_node()` 获取 NUMA 节点信息。\n- **用户空间访问**：依赖 `uaccess.h` 提供的安全用户空间读写原语（如 `unsafe_get_user`/`unsafe_put_user`）。\n- **跟踪系统**：通过 `trace/events/rseq.h` 集成内核跟踪基础设施。\n- **架构支持**：依赖 `asm/ptrace.h` 处理信号/抢占后的用户空间返回地址重定向（完整实现位于架构相关代码中）。\n\n## 使用场景\n\n- **高性能 per-CPU 操作**：如无锁计数器、每 CPU 队列等，避免传统原子操作或锁的开销。\n- **实时/低延迟应用**：减少因内核同步原语引入的延迟抖动。\n- **用户空间调度器/运行时**：如 Go、Java 虚拟机等，用于实现高效的线程本地状态管理。\n- **系统调用 `sys_rseq()`**：由用户空间通过 `rseq(2)` 系统调用注册或注销 `rseq` TLS 区域，本文件提供内核侧支持逻辑（注册/注销时调用 `rseq_update_cpu_node_id` 或 `rseq_reset_rseq_cpu_node_id`）。",
      "similarity": 0.6412889957427979,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/rseq.c",
          "start_line": 1,
          "end_line": 34,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * Restartable sequences system call",
            " *",
            " * Copyright (C) 2015, Google, Inc.,",
            " * Paul Turner <pjt@google.com> and Andrew Hunter <ahh@google.com>",
            " * Copyright (C) 2015-2018, EfficiOS Inc.,",
            " * Mathieu Desnoyers <mathieu.desnoyers@efficios.com>",
            " */",
            "",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/rseq.h>",
            "#include <linux/types.h>",
            "#include <linux/ratelimit.h>",
            "#include <asm/ptrace.h>",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/rseq.h>",
            "",
            "/* The original rseq structure size (including padding) is 32 bytes. */",
            "#define ORIG_RSEQ_SIZE\t\t32",
            "",
            "#define RSEQ_CS_NO_RESTART_FLAGS (RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT | \\",
            "\t\t\t\t  RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL | \\",
            "\t\t\t\t  RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE)",
            "",
            "#ifdef CONFIG_DEBUG_RSEQ",
            "static struct rseq *rseq_kernel_fields(struct task_struct *t)",
            "{",
            "\treturn (struct rseq *) t->rseq_fields;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义rseq内核字段访问函数，用于获取当前任务的rseq结构体指针，供后续验证和操作使用。",
          "similarity": 0.5590394139289856
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/rseq.c",
          "start_line": 242,
          "end_line": 346,
          "content": [
            "static int rseq_get_rseq_cs_ptr_val(struct rseq __user *rseq, u64 *rseq_cs)",
            "{",
            "\tif (!rseq_cs)",
            "\t\treturn -EFAULT;",
            "",
            "#ifdef CONFIG_64BIT",
            "\tif (get_user(*rseq_cs, &rseq->rseq_cs))",
            "\t\treturn -EFAULT;",
            "#else",
            "\tif (copy_from_user(rseq_cs, &rseq->rseq_cs, sizeof(*rseq_cs)))",
            "\t\treturn -EFAULT;",
            "#endif",
            "",
            "\treturn 0;",
            "}",
            "static int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)",
            "{",
            "\tstruct rseq_cs __user *urseq_cs;",
            "\tu64 ptr;",
            "\tu32 __user *usig;",
            "\tu32 sig;",
            "\tint ret;",
            "",
            "\tret = rseq_get_rseq_cs_ptr_val(t->rseq, &ptr);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/* If the rseq_cs pointer is NULL, return a cleared struct rseq_cs. */",
            "\tif (!ptr) {",
            "\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));",
            "\t\treturn 0;",
            "\t}",
            "\t/* Check that the pointer value fits in the user-space process space. */",
            "\tif (ptr >= TASK_SIZE)",
            "\t\treturn -EINVAL;",
            "\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;",
            "\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))",
            "\t\treturn -EFAULT;",
            "",
            "\tif (rseq_cs->start_ip >= TASK_SIZE ||",
            "\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||",
            "\t    rseq_cs->abort_ip >= TASK_SIZE ||",
            "\t    rseq_cs->version > 0)",
            "\t\treturn -EINVAL;",
            "\t/* Check for overflow. */",
            "\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)",
            "\t\treturn -EINVAL;",
            "\t/* Ensure that abort_ip is not in the critical section. */",
            "\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)",
            "\t\treturn -EINVAL;",
            "",
            "\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));",
            "\tret = get_user(sig, usig);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (current->rseq_sig != sig) {",
            "\t\tprintk_ratelimited(KERN_WARNING",
            "\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",",
            "\t\t\tsig, current->rseq_sig, current->pid, usig);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}",
            "static bool rseq_warn_flags(const char *str, u32 flags)",
            "{",
            "\tu32 test_flags;",
            "",
            "\tif (!flags)",
            "\t\treturn false;",
            "\ttest_flags = flags & RSEQ_CS_NO_RESTART_FLAGS;",
            "\tif (test_flags)",
            "\t\tpr_warn_once(\"Deprecated flags (%u) in %s ABI structure\", test_flags, str);",
            "\ttest_flags = flags & ~RSEQ_CS_NO_RESTART_FLAGS;",
            "\tif (test_flags)",
            "\t\tpr_warn_once(\"Unknown flags (%u) in %s ABI structure\", test_flags, str);",
            "\treturn true;",
            "}",
            "static int rseq_need_restart(struct task_struct *t, u32 cs_flags)",
            "{",
            "\tu32 flags, event_mask;",
            "\tint ret;",
            "",
            "\tif (rseq_warn_flags(\"rseq_cs\", cs_flags))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Get thread flags. */",
            "\tret = get_user(flags, &t->rseq->flags);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (rseq_warn_flags(\"rseq\", flags))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Load and clear event mask atomically with respect to",
            "\t * scheduler preemption.",
            "\t */",
            "\tpreempt_disable();",
            "\tevent_mask = t->rseq_event_mask;",
            "\tt->rseq_event_mask = 0;",
            "\tpreempt_enable();",
            "",
            "\treturn !!event_mask;",
            "}"
          ],
          "function_name": "rseq_get_rseq_cs_ptr_val, rseq_get_rseq_cs, rseq_warn_flags, rseq_need_restart",
          "description": "提供rseq_cs指针解析、结构体验证、标志位检查及是否需要重启的判定逻辑，保障安全性和兼容性。",
          "similarity": 0.54659104347229
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/rseq.c",
          "start_line": 35,
          "end_line": 159,
          "content": [
            "static int rseq_validate_ro_fields(struct task_struct *t)",
            "{",
            "\tstatic DEFINE_RATELIMIT_STATE(_rs,",
            "\t\t\t\t      DEFAULT_RATELIMIT_INTERVAL,",
            "\t\t\t\t      DEFAULT_RATELIMIT_BURST);",
            "\tu32 cpu_id_start, cpu_id, node_id, mm_cid;",
            "\tstruct rseq __user *rseq = t->rseq;",
            "",
            "\t/*",
            "\t * Validate fields which are required to be read-only by",
            "\t * user-space.",
            "\t */",
            "\tif (!user_read_access_begin(rseq, t->rseq_len))",
            "\t\tgoto efault;",
            "\tunsafe_get_user(cpu_id_start, &rseq->cpu_id_start, efault_end);",
            "\tunsafe_get_user(cpu_id, &rseq->cpu_id, efault_end);",
            "\tunsafe_get_user(node_id, &rseq->node_id, efault_end);",
            "\tunsafe_get_user(mm_cid, &rseq->mm_cid, efault_end);",
            "\tuser_read_access_end();",
            "",
            "\tif ((cpu_id_start != rseq_kernel_fields(t)->cpu_id_start ||",
            "\t    cpu_id != rseq_kernel_fields(t)->cpu_id ||",
            "\t    node_id != rseq_kernel_fields(t)->node_id ||",
            "\t    mm_cid != rseq_kernel_fields(t)->mm_cid) && __ratelimit(&_rs)) {",
            "",
            "\t\tpr_warn(\"Detected rseq corruption for pid: %d, name: %s\\n\"",
            "\t\t\t\"\\tcpu_id_start: %u ?= %u\\n\"",
            "\t\t\t\"\\tcpu_id:       %u ?= %u\\n\"",
            "\t\t\t\"\\tnode_id:      %u ?= %u\\n\"",
            "\t\t\t\"\\tmm_cid:       %u ?= %u\\n\",",
            "\t\t\tt->pid, t->comm,",
            "\t\t\tcpu_id_start, rseq_kernel_fields(t)->cpu_id_start,",
            "\t\t\tcpu_id, rseq_kernel_fields(t)->cpu_id,",
            "\t\t\tnode_id, rseq_kernel_fields(t)->node_id,",
            "\t\t\tmm_cid, rseq_kernel_fields(t)->mm_cid);",
            "\t}",
            "",
            "\t/* For now, only print a console warning on mismatch. */",
            "\treturn 0;",
            "",
            "efault_end:",
            "\tuser_read_access_end();",
            "efault:",
            "\treturn -EFAULT;",
            "}",
            "static int rseq_validate_ro_fields(struct task_struct *t)",
            "{",
            "\treturn 0;",
            "}",
            "static int rseq_update_cpu_node_id(struct task_struct *t)",
            "{",
            "\tstruct rseq __user *rseq = t->rseq;",
            "\tu32 cpu_id = raw_smp_processor_id();",
            "\tu32 node_id = cpu_to_node(cpu_id);",
            "\tu32 mm_cid = task_mm_cid(t);",
            "",
            "\t/*",
            "\t * Validate read-only rseq fields.",
            "\t */",
            "\tif (rseq_validate_ro_fields(t))",
            "\t\tgoto efault;",
            "\tWARN_ON_ONCE((int) mm_cid < 0);",
            "\tif (!user_write_access_begin(rseq, t->rseq_len))",
            "\t\tgoto efault;",
            "",
            "\trseq_unsafe_put_user(t, cpu_id, cpu_id_start, efault_end);",
            "\trseq_unsafe_put_user(t, cpu_id, cpu_id, efault_end);",
            "\trseq_unsafe_put_user(t, node_id, node_id, efault_end);",
            "\trseq_unsafe_put_user(t, mm_cid, mm_cid, efault_end);",
            "",
            "\t/*",
            "\t * Additional feature fields added after ORIG_RSEQ_SIZE",
            "\t * need to be conditionally updated only if",
            "\t * t->rseq_len != ORIG_RSEQ_SIZE.",
            "\t */",
            "\tuser_write_access_end();",
            "\ttrace_rseq_update(t);",
            "\treturn 0;",
            "",
            "efault_end:",
            "\tuser_write_access_end();",
            "efault:",
            "\treturn -EFAULT;",
            "}",
            "static int rseq_reset_rseq_cpu_node_id(struct task_struct *t)",
            "{",
            "\tstruct rseq __user *rseq = t->rseq;",
            "\tu32 cpu_id_start = 0, cpu_id = RSEQ_CPU_ID_UNINITIALIZED, node_id = 0,",
            "\t    mm_cid = 0;",
            "",
            "\t/*",
            "\t * Validate read-only rseq fields.",
            "\t */",
            "\tif (rseq_validate_ro_fields(t))",
            "\t\tgoto efault;",
            "",
            "\tif (!user_write_access_begin(rseq, t->rseq_len))",
            "\t\tgoto efault;",
            "",
            "\t/*",
            "\t * Reset all fields to their initial state.",
            "\t *",
            "\t * All fields have an initial state of 0 except cpu_id which is set to",
            "\t * RSEQ_CPU_ID_UNINITIALIZED, so that any user coming in after",
            "\t * unregistration can figure out that rseq needs to be registered",
            "\t * again.",
            "\t */",
            "\trseq_unsafe_put_user(t, cpu_id_start, cpu_id_start, efault_end);",
            "\trseq_unsafe_put_user(t, cpu_id, cpu_id, efault_end);",
            "\trseq_unsafe_put_user(t, node_id, node_id, efault_end);",
            "\trseq_unsafe_put_user(t, mm_cid, mm_cid, efault_end);",
            "",
            "\t/*",
            "\t * Additional feature fields added after ORIG_RSEQ_SIZE",
            "\t * need to be conditionally reset only if",
            "\t * t->rseq_len != ORIG_RSEQ_SIZE.",
            "\t */",
            "\tuser_write_access_end();",
            "\treturn 0;",
            "",
            "efault_end:",
            "\tuser_write_access_end();",
            "efault:",
            "\treturn -EFAULT;",
            "}"
          ],
          "function_name": "rseq_validate_ro_fields, rseq_validate_ro_fields, rseq_update_cpu_node_id, rseq_reset_rseq_cpu_node_id",
          "description": "实现rseq只读字段校验、CPU/节点ID更新及重置功能，检测并防止用户态对只读字段的篡改。",
          "similarity": 0.5071377158164978
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/rseq.c",
          "start_line": 355,
          "end_line": 442,
          "content": [
            "static int clear_rseq_cs(struct rseq __user *rseq)",
            "{",
            "\t/*",
            "\t * The rseq_cs field is set to NULL on preemption or signal",
            "\t * delivery on top of rseq assembly block, as well as on top",
            "\t * of code outside of the rseq assembly block. This performs",
            "\t * a lazy clear of the rseq_cs field.",
            "\t *",
            "\t * Set rseq_cs to NULL.",
            "\t */",
            "#ifdef CONFIG_64BIT",
            "\treturn put_user(0UL, &rseq->rseq_cs);",
            "#else",
            "\tif (clear_user(&rseq->rseq_cs, sizeof(rseq->rseq_cs)))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "#endif",
            "}",
            "static bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)",
            "{",
            "\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;",
            "}",
            "static int rseq_ip_fixup(struct pt_regs *regs)",
            "{",
            "\tunsigned long ip = instruction_pointer(regs);",
            "\tstruct task_struct *t = current;",
            "\tstruct rseq_cs rseq_cs;",
            "\tint ret;",
            "",
            "\tret = rseq_get_rseq_cs(t, &rseq_cs);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/*",
            "\t * Handle potentially not being within a critical section.",
            "\t * If not nested over a rseq critical section, restart is useless.",
            "\t * Clear the rseq_cs pointer and return.",
            "\t */",
            "\tif (!in_rseq_cs(ip, &rseq_cs))",
            "\t\treturn clear_rseq_cs(t->rseq);",
            "\tret = rseq_need_restart(t, rseq_cs.flags);",
            "\tif (ret <= 0)",
            "\t\treturn ret;",
            "\tret = clear_rseq_cs(t->rseq);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\ttrace_rseq_ip_fixup(ip, rseq_cs.start_ip, rseq_cs.post_commit_offset,",
            "\t\t\t    rseq_cs.abort_ip);",
            "\tinstruction_pointer_set(regs, (unsigned long)rseq_cs.abort_ip);",
            "\treturn 0;",
            "}",
            "void __rseq_handle_notify_resume(struct ksignal *ksig, struct pt_regs *regs)",
            "{",
            "\tstruct task_struct *t = current;",
            "\tint ret, sig;",
            "",
            "\tif (unlikely(t->flags & PF_EXITING))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * regs is NULL if and only if the caller is in a syscall path.  Skip",
            "\t * fixup and leave rseq_cs as is so that rseq_sycall() will detect and",
            "\t * kill a misbehaving userspace on debug kernels.",
            "\t */",
            "\tif (regs) {",
            "\t\tret = rseq_ip_fixup(regs);",
            "\t\tif (unlikely(ret < 0))",
            "\t\t\tgoto error;",
            "\t}",
            "\tif (unlikely(rseq_update_cpu_node_id(t)))",
            "\t\tgoto error;",
            "\treturn;",
            "",
            "error:",
            "\tsig = ksig ? ksig->sig : 0;",
            "\tforce_sigsegv(sig);",
            "}",
            "void rseq_syscall(struct pt_regs *regs)",
            "{",
            "\tunsigned long ip = instruction_pointer(regs);",
            "\tstruct task_struct *t = current;",
            "\tstruct rseq_cs rseq_cs;",
            "",
            "\tif (!t->rseq)",
            "\t\treturn;",
            "\tif (rseq_get_rseq_cs(t, &rseq_cs) || in_rseq_cs(ip, &rseq_cs))",
            "\t\tforce_sig(SIGSEGV);",
            "}"
          ],
          "function_name": "clear_rseq_cs, in_rseq_cs, rseq_ip_fixup, __rseq_handle_notify_resume, rseq_syscall",
          "description": "实现rseq异常处理流程，包括临界区IP修复、通知恢复处理和系统调用保护，确保rseq执行的安全边界。",
          "similarity": 0.4499436020851135
        }
      ]
    },
    {
      "source_file": "kernel/tsacct.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:42:02\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `tsacct.c`\n\n---\n\n# tsacct.c 技术文档\n\n## 1. 文件概述\n\n`tsacct.c` 是 Linux 内核中实现任务统计（taskstats）接口下系统记账（accounting）功能的核心文件。它负责收集进程/任务的资源使用信息，包括基本记账（basic accounting）和扩展记账（extended accounting）两类数据。这些数据通过 `taskstats` 接口暴露给用户空间，用于系统监控、资源审计和性能分析等用途。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`bacct_add_tsk()`**  \n  填充任务的基本记账信息到 `struct taskstats` 结构体中，包括进程 ID、父进程 ID、用户/组 ID、CPU 时间、启动时间、退出码、调度策略、nice 值、缺页次数、命令名等。\n\n- **`xacct_add_tsk()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  填充任务的扩展记账信息，包括内存使用积分（RSS/VM）、I/O 字节数、系统调用次数等。\n\n- **`acct_update_integrals()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  在中断上下文中安全地更新任务的内存使用积分（RSS 和虚拟内存的时间积分）。\n\n- **`acct_account_cputime()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  在已知 CPU 时间更新后，直接调用内部函数更新内存积分，避免重复获取时间。\n\n- **`acct_clear_integrals()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  清除任务结构体中的内存积分字段，通常在进程创建或复用时调用。\n\n### 关键数据结构\n\n- **`struct taskstats`**  \n  用户空间通过 netlink 接口获取的统计信息结构体，包含 `ac_*` 前缀的各类记账字段。\n\n- **`struct task_struct` 中的扩展字段**（仅当 `CONFIG_TASK_XACCT` 启用时）：\n  - `acct_rss_mem1`：RSS 内存使用的时间积分（单位：页·纳秒 / 1024）\n  - `acct_vm_mem1`：虚拟内存使用的时间积分（单位：页·纳秒 / 1024）\n  - `acct_timexpd`：上次更新积分时的累计 CPU 时间（纳秒）\n\n## 3. 关键实现\n\n### 基本记账实现细节\n\n- **时间计算**：\n  - `ac_etime`：任务自启动以来的经过时间（微秒）。\n  - `ac_tgetime`：整个线程组自组长启动以来的经过时间（微秒）。\n  - `ac_btime` / `ac_btime64`：任务启动的绝对时间（Unix 时间戳），前者限制为 32 位以兼容旧接口。\n\n- **身份与关系信息**：\n  - 使用 `from_kuid_munged()` 和 `from_kgid_munged()` 将内核 UID/GID 映射到指定用户命名空间。\n  - 父进程 ID（`ac_ppid`）通过 RCU 读取 `real_parent`，并在进程已退出时设为 0。\n\n- **CPU 时间**：\n  - 使用 `task_cputime()` 获取任务及其子线程的累计用户态和内核态 CPU 时间（纳秒）。\n  - 同时提供原始时间和按 CPU 频率缩放后的时间（`ac_utimescaled` / `ac_stimescaled`）。\n\n- **退出与特权标志**：\n  - 根据任务标志（如 `PF_EXITING`、`PF_SUPERPRIV` 等）设置 `ac_flag` 中的对应位（`AXSIG`、`ASU` 等）。\n\n### 扩展记账实现细节（`CONFIG_TASK_XACCT`）\n\n- **内存积分算法**：\n  - 通过 `__acct_update_integrals()` 定期累积 `RSS × 时间` 和 `VM × 时间`。\n  - 积分单位为“页·纳秒”，右移 10 位（即除以 1024）防止溢出。\n  - 最终在 `xacct_add_tsk()` 中转换为 **MB·微秒**（通过 `PAGE_SIZE / (1000 * KB)`）。\n\n- **高水位内存统计**：\n  - 从 `mm_struct` 中获取历史最高 RSS 和 VM 值，并转换为 KB 单位。\n\n- **I/O 统计**：\n  - 从 `task_struct->ioac` 获取字符级和字节级的读写统计。\n  - 使用 `KB_MASK` 对结果向下对齐到 KB 边界（即清除低 10 位）。\n  - 若未启用 `CONFIG_TASK_IO_ACCOUNTING`，则 I/O 字节字段置零。\n\n- **中断安全更新**：\n  - `acct_update_integrals()` 使用 `local_irq_save/restore` 禁用本地中断，确保在中断上下文中安全更新。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/tsacct_kern.h>`：定义 `taskstats` 结构和相关接口。\n  - `<linux/acct.h>`：提供记账相关的常量和类型。\n  - `<linux/sched/*.h>`：访问任务调度、CPU 时间、凭证等信息。\n  - `<linux/mm.h>`：访问内存管理结构（如 `mm_struct`）。\n  - `<linux/jiffies.h>` 和 `<linux/kernel.h>`：时间转换和基础宏。\n\n- **配置依赖**：\n  - 基本记账功能始终编译。\n  - 扩展记账功能（`xacct_add_tsk` 及相关函数）依赖 `CONFIG_TASK_XACCT`。\n  - I/O 字节统计依赖 `CONFIG_TASK_IO_ACCOUNTING`。\n\n- **与其他子系统交互**：\n  - **调度子系统**：通过 `task_cputime()` 获取 CPU 时间。\n  - **内存管理子系统**：通过 `get_task_mm()` 和 `get_mm_hiwater_*` 获取内存使用情况。\n  - **用户命名空间**：通过 `user_ns` 参数进行 UID/GID 映射。\n  - **进程管理**：访问 `task_struct` 的各种字段（如 `start_time`、`exit_code`、`flags` 等）。\n\n## 5. 使用场景\n\n- **用户空间监控工具**：如 `nmon`、`atop`、`sadc` 等通过 taskstats netlink 接口获取进程资源使用详情。\n- **作业调度系统**：HPC 或容器平台（如 Slurm、Kubernetes）利用扩展记账数据进行资源配额和计费。\n- **系统审计**：记录进程的 CPU、内存、I/O 消耗，用于安全分析或性能瓶颈定位。\n- **内核自身记账**：在进程退出或通过 `TASKSTATS_CMD_ATTR_PID` 查询时，填充并返回 `taskstats` 数据。\n- **cgroup v1/v2 集成**：部分记账数据可被 cgroup 控制器复用或聚合。",
      "similarity": 0.6336572170257568,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/tsacct.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * tsacct.c - System accounting over taskstats interface",
            " *",
            " * Copyright (C) Jay Lan,\t<jlan@sgi.com>",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/mm.h>",
            "",
            "/*",
            " * fill in basic accounting fields",
            " */"
          ],
          "function_name": null,
          "description": "定义系统任务统计（taskstats）接口的会计模块，包含基础头文件和注释，声明TS_COMM_LEN常量，为后续会计字段填充提供上下文；上下文不完整",
          "similarity": 0.5586519241333008
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/tsacct.c",
          "start_line": 20,
          "end_line": 133,
          "content": [
            "void bacct_add_tsk(struct user_namespace *user_ns,",
            "\t\t   struct pid_namespace *pid_ns,",
            "\t\t   struct taskstats *stats, struct task_struct *tsk)",
            "{",
            "\tconst struct cred *tcred;",
            "\tu64 utime, stime, utimescaled, stimescaled;",
            "\tu64 now_ns, delta;",
            "\ttime64_t btime;",
            "",
            "\tBUILD_BUG_ON(TS_COMM_LEN < TASK_COMM_LEN);",
            "",
            "\t/* calculate task elapsed time in nsec */",
            "\tnow_ns = ktime_get_ns();",
            "\t/* store whole group time first */",
            "\tdelta = now_ns - tsk->group_leader->start_time;",
            "\t/* Convert to micro seconds */",
            "\tdo_div(delta, NSEC_PER_USEC);",
            "\tstats->ac_tgetime = delta;",
            "\tdelta = now_ns - tsk->start_time;",
            "\tdo_div(delta, NSEC_PER_USEC);",
            "\tstats->ac_etime = delta;",
            "\t/* Convert to seconds for btime (note y2106 limit) */",
            "\tbtime = ktime_get_real_seconds() - div_u64(delta, USEC_PER_SEC);",
            "\tstats->ac_btime = clamp_t(time64_t, btime, 0, U32_MAX);",
            "\tstats->ac_btime64 = btime;",
            "",
            "\tif (tsk->flags & PF_EXITING)",
            "\t\tstats->ac_exitcode = tsk->exit_code;",
            "\tif (thread_group_leader(tsk) && (tsk->flags & PF_FORKNOEXEC))",
            "\t\tstats->ac_flag |= AFORK;",
            "\tif (tsk->flags & PF_SUPERPRIV)",
            "\t\tstats->ac_flag |= ASU;",
            "\tif (tsk->flags & PF_DUMPCORE)",
            "\t\tstats->ac_flag |= ACORE;",
            "\tif (tsk->flags & PF_SIGNALED)",
            "\t\tstats->ac_flag |= AXSIG;",
            "\tstats->ac_nice\t = task_nice(tsk);",
            "\tstats->ac_sched\t = tsk->policy;",
            "\tstats->ac_pid\t = task_pid_nr_ns(tsk, pid_ns);",
            "\tstats->ac_tgid   = task_tgid_nr_ns(tsk, pid_ns);",
            "\trcu_read_lock();",
            "\ttcred = __task_cred(tsk);",
            "\tstats->ac_uid\t = from_kuid_munged(user_ns, tcred->uid);",
            "\tstats->ac_gid\t = from_kgid_munged(user_ns, tcred->gid);",
            "\tstats->ac_ppid\t = pid_alive(tsk) ?",
            "\t\ttask_tgid_nr_ns(rcu_dereference(tsk->real_parent), pid_ns) : 0;",
            "\trcu_read_unlock();",
            "",
            "\ttask_cputime(tsk, &utime, &stime);",
            "\tstats->ac_utime = div_u64(utime, NSEC_PER_USEC);",
            "\tstats->ac_stime = div_u64(stime, NSEC_PER_USEC);",
            "",
            "\ttask_cputime_scaled(tsk, &utimescaled, &stimescaled);",
            "\tstats->ac_utimescaled = div_u64(utimescaled, NSEC_PER_USEC);",
            "\tstats->ac_stimescaled = div_u64(stimescaled, NSEC_PER_USEC);",
            "",
            "\tstats->ac_minflt = tsk->min_flt;",
            "\tstats->ac_majflt = tsk->maj_flt;",
            "",
            "\tstrscpy_pad(stats->ac_comm, tsk->comm);",
            "}",
            "void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)",
            "{",
            "\tstruct mm_struct *mm;",
            "",
            "\t/* convert pages-nsec/1024 to Mbyte-usec, see __acct_update_integrals */",
            "\tstats->coremem = p->acct_rss_mem1 * PAGE_SIZE;",
            "\tdo_div(stats->coremem, 1000 * KB);",
            "\tstats->virtmem = p->acct_vm_mem1 * PAGE_SIZE;",
            "\tdo_div(stats->virtmem, 1000 * KB);",
            "\tmm = get_task_mm(p);",
            "\tif (mm) {",
            "\t\t/* adjust to KB unit */",
            "\t\tstats->hiwater_rss   = get_mm_hiwater_rss(mm) * PAGE_SIZE / KB;",
            "\t\tstats->hiwater_vm    = get_mm_hiwater_vm(mm)  * PAGE_SIZE / KB;",
            "\t\tmmput(mm);",
            "\t}",
            "\tstats->read_char\t= p->ioac.rchar & KB_MASK;",
            "\tstats->write_char\t= p->ioac.wchar & KB_MASK;",
            "\tstats->read_syscalls\t= p->ioac.syscr & KB_MASK;",
            "\tstats->write_syscalls\t= p->ioac.syscw & KB_MASK;",
            "#ifdef CONFIG_TASK_IO_ACCOUNTING",
            "\tstats->read_bytes\t= p->ioac.read_bytes & KB_MASK;",
            "\tstats->write_bytes\t= p->ioac.write_bytes & KB_MASK;",
            "\tstats->cancelled_write_bytes = p->ioac.cancelled_write_bytes & KB_MASK;",
            "#else",
            "\tstats->read_bytes\t= 0;",
            "\tstats->write_bytes\t= 0;",
            "\tstats->cancelled_write_bytes = 0;",
            "#endif",
            "}",
            "static void __acct_update_integrals(struct task_struct *tsk,",
            "\t\t\t\t    u64 utime, u64 stime)",
            "{",
            "\tu64 time, delta;",
            "",
            "\tif (!likely(tsk->mm))",
            "\t\treturn;",
            "",
            "\ttime = stime + utime;",
            "\tdelta = time - tsk->acct_timexpd;",
            "",
            "\tif (delta < TICK_NSEC)",
            "\t\treturn;",
            "",
            "\ttsk->acct_timexpd = time;",
            "\t/*",
            "\t * Divide by 1024 to avoid overflow, and to avoid division.",
            "\t * The final unit reported to userspace is Mbyte-usecs,",
            "\t * the rest of the math is done in xacct_add_tsk.",
            "\t */",
            "\ttsk->acct_rss_mem1 += delta * get_mm_rss(tsk->mm) >> 10;",
            "\ttsk->acct_vm_mem1 += delta * READ_ONCE(tsk->mm->total_vm) >> 10;",
            "}"
          ],
          "function_name": "bacct_add_tsk, xacct_add_tsk, __acct_update_integrals",
          "description": "bacct_add_tsk填充任务基本信息（如PID、用户UID/GID、调度策略、时间戳等），xacct_add_tsk统计内存及I/O数据，__acct_update_integrals计算并累加CPU时间与内存使用积分",
          "similarity": 0.5546131134033203
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/tsacct.c",
          "start_line": 152,
          "end_line": 171,
          "content": [
            "void acct_update_integrals(struct task_struct *tsk)",
            "{",
            "\tu64 utime, stime;",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "\ttask_cputime(tsk, &utime, &stime);",
            "\t__acct_update_integrals(tsk, utime, stime);",
            "\tlocal_irq_restore(flags);",
            "}",
            "void acct_account_cputime(struct task_struct *tsk)",
            "{",
            "\t__acct_update_integrals(tsk, tsk->utime, tsk->stime);",
            "}",
            "void acct_clear_integrals(struct task_struct *tsk)",
            "{",
            "\ttsk->acct_timexpd = 0;",
            "\ttsk->acct_rss_mem1 = 0;",
            "\ttsk->acct_vm_mem1 = 0;",
            "}"
          ],
          "function_name": "acct_update_integrals, acct_account_cputime, acct_clear_integrals",
          "description": "acct_update_integrals获取当前CPU时间并更新积分数据，acct_account_cputime直接记录任务CPU时间到积分，acct_clear_integrals重置任务积分相关统计变量",
          "similarity": 0.456501305103302
        }
      ]
    }
  ]
}