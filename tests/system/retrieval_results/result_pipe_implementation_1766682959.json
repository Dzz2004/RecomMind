{
  "query": "pipe implementation",
  "timestamp": "2025-12-26 01:15:59",
  "retrieved_files": [
    {
      "source_file": "kernel/trace/trace_uprobe.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:40:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_uprobe.c`\n\n---\n\n# `trace_uprobe.c` 技术文档\n\n## 1. 文件概述\n\n`trace_uprobe.c` 是 Linux 内核中用于实现基于 **uprobes** 的动态用户空间函数追踪事件的核心模块。该文件将 uprobes 机制与内核的通用追踪子系统（ftrace）集成，允许用户在不修改目标程序的情况下，在用户空间可执行文件的指定偏移地址处动态插入探针（probe），用于采集函数调用、返回值、寄存器状态、栈内容及内存数据等信息。支持普通探针（uprobe）和返回探针（uretprobe）两种模式，并可通过 tracefs 接口进行动态创建、查询和销毁。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct trace_uprobe`**  \n  表示一个 uprobe 追踪事件实例，包含：\n  - `devent`：动态事件基类，用于注册到 `dyn_event` 框架\n  - `consumer`：uprobes 消费者回调（`uprobe_dispatcher` / `uretprobe_dispatcher`）\n  - `path` / `inode` / `filename`：目标可执行文件路径信息\n  - `offset`：在文件中的插入偏移地址\n  - `ref_ctr_offset`：引用计数器偏移（用于 uretprobe）\n  - `tp`：通用追踪探针结构（`trace_probe`），管理参数、过滤器、事件格式等\n\n- **`struct uprobe_trace_entry_head`**  \n  追踪事件记录的头部结构，包含标准 `trace_entry` 和可变长度的虚拟地址数组（用于存储插入地址及返回地址）\n\n- **`trace_uprobe_ops`**  \n  实现 `dyn_event_operations` 接口，提供动态事件的创建、显示、释放、匹配等操作\n\n### 主要函数\n\n- **事件生命周期管理**\n  - `trace_uprobe_create()`：解析用户命令并创建 uprobe 事件\n  - `register_uprobe_event()` / `unregister_uprobe_event()`：注册/注销 uprobe 到 uprobes 子系统\n  - `trace_uprobe_release()`：释放 uprobe 资源\n  - `trace_uprobe_is_busy()`：检查事件是否处于启用状态\n\n- **探针触发回调**\n  - `uprobe_dispatcher()`：普通 uprobe 触发时的处理函数\n  - `uretprobe_dispatcher()`：uretprobe（函数返回探针）触发时的处理函数\n\n- **数据采集与解析**\n  - `process_fetch_insn()`：根据指令码从用户上下文（寄存器、栈、内存等）提取数据\n  - `fetch_store_string()` / `fetch_store_strlen()`：安全读取用户空间字符串\n  - `get_user_stack_nth()`：读取用户栈第 N 个字（考虑栈增长方向）\n  - `translate_user_vaddr()`：将文件偏移转换为运行时虚拟地址\n\n- **辅助函数**\n  - `is_ret_probe()`：判断是否为返回探针\n  - `trace_uprobe_match()`：匹配动态事件查询条件\n  - `for_each_trace_uprobe()`：遍历所有 uprobe 事件的宏\n\n## 3. 关键实现\n\n### 动态事件集成\n通过 `dyn_event` 框架将 uprobe 事件纳入统一管理，支持通过 tracefs 的 `dyn_events` 接口进行动态操作（如 `echo 'p:uprobes/myprobe /bin/bash:0x1234' > /sys/kernel/tracing/dynamic_events`）。\n\n### 用户空间数据安全读取\n所有从用户空间读取数据的操作（如 `copy_from_user`、`strncpy_from_user`）均被封装在 `nokprobe_inline` 函数中，确保在 kprobe/uprobe 上下文中安全执行，避免页面错误。\n\n### 栈方向适配\n通过 `CONFIG_STACK_GROWSUP` 宏判断架构栈增长方向，`adjust_stack_addr()` 动态计算栈偏移，保证跨架构兼容性。\n\n### 字符串处理\n使用“数据位置描述符”（data location descriptor）机制存储变长字符串：\n- `fetch_store_string()` 将字符串拷贝到事件记录缓冲区，并返回 `(长度 << 16) | 偏移` 的 32 位描述符\n- 支持特殊令牌 `FETCH_TOKEN_COMM` 直接读取当前进程名\n\n### 地址翻译\n`translate_user_vaddr()` 利用 `current->utask->vaddr` 中存储的 `uprobe_dispatch_data`，将文件偏移（`code->immediate`）转换为进程实际加载的虚拟地址，用于内存读取。\n\n### 指令驱动的数据提取\n`process_fetch_insn()` 实现基于字节码的灵活数据提取：\n- 支持寄存器（`FETCH_OP_REG`）、栈（`FETCH_OP_STACK`）、返回值（`FETCH_OP_RETVAL`）等上下文源\n- 通过 `process_common_fetch_insn()` 处理通用操作（如立即数、间接寻址）\n- 最终调用 `process_fetch_insn_bottom()` 将值存入目标缓冲区\n\n## 4. 依赖关系\n\n- **核心依赖**\n  - `<linux/uprobes.h>`：uprobes 子系统 API（注册/注销探针、消费者回调）\n  - `\"trace_probe.h\"` / `\"trace_dynevent.h\"`：通用追踪探针框架和动态事件管理\n  - `<linux/filter.h>`：事件过滤支持\n  - `<linux/bpf-cgroup.h>`：BPF 程序附加支持（用于 perf 事件）\n\n- **架构依赖**\n  - `user_stack_pointer()` / `regs_get_register()`：架构相关的寄存器和栈指针访问\n  - `regs_return_value()`：架构相关的函数返回值获取\n\n- **安全与内存**\n  - `<linux/uaccess.h>`：用户空间内存安全访问\n  - `<linux/security.h>`：LSM 安全钩子（未在片段中体现，但通常用于权限检查）\n\n## 5. 使用场景\n\n- **动态用户空间函数追踪**  \n  开发者或系统管理员可通过 tracefs 动态在任意用户程序的指定地址插入探针，监控函数调用、参数、返回值等，无需重新编译程序。\n\n- **性能分析与调试**  \n  结合 ftrace 或 perf 工具，采集用户程序热点函数的执行时间、调用栈、内存状态，用于性能瓶颈分析或故障诊断。\n\n- **安全监控**  \n  监控敏感系统调用或库函数（如 `execve`、`open`）的调用行为，结合 eBPF 实现运行时安全策略。\n\n- **uretprobe 返回值捕获**  \n  在函数返回时自动捕获返回值和调用上下文，适用于监控 API 调用结果（如系统调用成功/失败）。\n\n- **生产环境无侵入观测**  \n  由于 uprobes 基于动态指令替换（插入 `int3` 断点），对目标程序性能影响极小，适合在生产环境中临时启用观测。",
      "similarity": 0.4860178232192993,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/trace_uprobe.c",
          "start_line": 534,
          "end_line": 721,
          "content": [
            "static int __trace_uprobe_create(int argc, const char **argv)",
            "{",
            "\tstruct trace_uprobe *tu;",
            "\tconst char *event = NULL, *group = UPROBE_EVENT_SYSTEM;",
            "\tchar *arg, *filename, *rctr, *rctr_end, *tmp;",
            "\tchar buf[MAX_EVENT_NAME_LEN];",
            "\tchar gbuf[MAX_EVENT_NAME_LEN];",
            "\tenum probe_print_type ptype;",
            "\tstruct path path;",
            "\tunsigned long offset, ref_ctr_offset;",
            "\tbool is_return = false;",
            "\tint i, ret;",
            "",
            "\tref_ctr_offset = 0;",
            "",
            "\tswitch (argv[0][0]) {",
            "\tcase 'r':",
            "\t\tis_return = true;",
            "\t\tbreak;",
            "\tcase 'p':",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -ECANCELED;",
            "\t}",
            "",
            "\tif (argc < 2)",
            "\t\treturn -ECANCELED;",
            "\tif (argc - 2 > MAX_TRACE_ARGS)",
            "\t\treturn -E2BIG;",
            "",
            "\tif (argv[0][1] == ':')",
            "\t\tevent = &argv[0][2];",
            "",
            "\tif (!strchr(argv[1], '/'))",
            "\t\treturn -ECANCELED;",
            "",
            "\tfilename = kstrdup(argv[1], GFP_KERNEL);",
            "\tif (!filename)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/* Find the last occurrence, in case the path contains ':' too. */",
            "\targ = strrchr(filename, ':');",
            "\tif (!arg || !isdigit(arg[1])) {",
            "\t\tkfree(filename);",
            "\t\treturn -ECANCELED;",
            "\t}",
            "",
            "\ttrace_probe_log_init(\"trace_uprobe\", argc, argv);",
            "\ttrace_probe_log_set_index(1);\t/* filename is the 2nd argument */",
            "",
            "\t*arg++ = '\\0';",
            "\tret = kern_path(filename, LOOKUP_FOLLOW, &path);",
            "\tif (ret) {",
            "\t\ttrace_probe_log_err(0, FILE_NOT_FOUND);",
            "\t\tkfree(filename);",
            "\t\ttrace_probe_log_clear();",
            "\t\treturn ret;",
            "\t}",
            "\tif (!d_is_reg(path.dentry)) {",
            "\t\ttrace_probe_log_err(0, NO_REGULAR_FILE);",
            "\t\tret = -EINVAL;",
            "\t\tgoto fail_address_parse;",
            "\t}",
            "",
            "\t/* Parse reference counter offset if specified. */",
            "\trctr = strchr(arg, '(');",
            "\tif (rctr) {",
            "\t\trctr_end = strchr(rctr, ')');",
            "\t\tif (!rctr_end) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\trctr_end = rctr + strlen(rctr);",
            "\t\t\ttrace_probe_log_err(rctr_end - filename,",
            "\t\t\t\t\t    REFCNT_OPEN_BRACE);",
            "\t\t\tgoto fail_address_parse;",
            "\t\t} else if (rctr_end[1] != '\\0') {",
            "\t\t\tret = -EINVAL;",
            "\t\t\ttrace_probe_log_err(rctr_end + 1 - filename,",
            "\t\t\t\t\t    BAD_REFCNT_SUFFIX);",
            "\t\t\tgoto fail_address_parse;",
            "\t\t}",
            "",
            "\t\t*rctr++ = '\\0';",
            "\t\t*rctr_end = '\\0';",
            "\t\tret = kstrtoul(rctr, 0, &ref_ctr_offset);",
            "\t\tif (ret) {",
            "\t\t\ttrace_probe_log_err(rctr - filename, BAD_REFCNT);",
            "\t\t\tgoto fail_address_parse;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Check if there is %return suffix */",
            "\ttmp = strchr(arg, '%');",
            "\tif (tmp) {",
            "\t\tif (!strcmp(tmp, \"%return\")) {",
            "\t\t\t*tmp = '\\0';",
            "\t\t\tis_return = true;",
            "\t\t} else {",
            "\t\t\ttrace_probe_log_err(tmp - filename, BAD_ADDR_SUFFIX);",
            "\t\t\tret = -EINVAL;",
            "\t\t\tgoto fail_address_parse;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Parse uprobe offset. */",
            "\tret = kstrtoul(arg, 0, &offset);",
            "\tif (ret) {",
            "\t\ttrace_probe_log_err(arg - filename, BAD_UPROBE_OFFS);",
            "\t\tgoto fail_address_parse;",
            "\t}",
            "",
            "\t/* setup a probe */",
            "\ttrace_probe_log_set_index(0);",
            "\tif (event) {",
            "\t\tret = traceprobe_parse_event_name(&event, &group, gbuf,",
            "\t\t\t\t\t\t  event - argv[0]);",
            "\t\tif (ret)",
            "\t\t\tgoto fail_address_parse;",
            "\t}",
            "",
            "\tif (!event) {",
            "\t\tchar *tail;",
            "\t\tchar *ptr;",
            "",
            "\t\ttail = kstrdup(kbasename(filename), GFP_KERNEL);",
            "\t\tif (!tail) {",
            "\t\t\tret = -ENOMEM;",
            "\t\t\tgoto fail_address_parse;",
            "\t\t}",
            "",
            "\t\tptr = strpbrk(tail, \".-_\");",
            "\t\tif (ptr)",
            "\t\t\t*ptr = '\\0';",
            "",
            "\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_%s_0x%lx\", 'p', tail, offset);",
            "\t\tevent = buf;",
            "\t\tkfree(tail);",
            "\t}",
            "",
            "\targc -= 2;",
            "\targv += 2;",
            "",
            "\ttu = alloc_trace_uprobe(group, event, argc, is_return);",
            "\tif (IS_ERR(tu)) {",
            "\t\tret = PTR_ERR(tu);",
            "\t\t/* This must return -ENOMEM otherwise there is a bug */",
            "\t\tWARN_ON_ONCE(ret != -ENOMEM);",
            "\t\tgoto fail_address_parse;",
            "\t}",
            "\ttu->offset = offset;",
            "\ttu->ref_ctr_offset = ref_ctr_offset;",
            "\ttu->path = path;",
            "\ttu->filename = filename;",
            "",
            "\t/* parse arguments */",
            "\tfor (i = 0; i < argc; i++) {",
            "\t\tstruct traceprobe_parse_context ctx = {",
            "\t\t\t.flags = (is_return ? TPARG_FL_RETURN : 0) | TPARG_FL_USER,",
            "\t\t};",
            "",
            "\t\ttrace_probe_log_set_index(i + 2);",
            "\t\tret = traceprobe_parse_probe_arg(&tu->tp, i, argv[i], &ctx);",
            "\t\ttraceprobe_finish_parse(&ctx);",
            "\t\tif (ret)",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tptype = is_ret_probe(tu) ? PROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;",
            "\tret = traceprobe_set_print_fmt(&tu->tp, ptype);",
            "\tif (ret < 0)",
            "\t\tgoto error;",
            "",
            "\tret = register_trace_uprobe(tu);",
            "\tif (!ret)",
            "\t\tgoto out;",
            "",
            "error:",
            "\tfree_trace_uprobe(tu);",
            "out:",
            "\ttrace_probe_log_clear();",
            "\treturn ret;",
            "",
            "fail_address_parse:",
            "\ttrace_probe_log_clear();",
            "\tpath_put(&path);",
            "\tkfree(filename);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__trace_uprobe_create",
          "description": "实现 uprobes 探针创建主流程，解析命令行参数构建路径与偏移量，设置打印格式并调用 register_trace_uprobe 注册探针，完成从用户输入到内核探针结构的完整转换与验证。",
          "similarity": 0.5073310136795044
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_uprobe.c",
          "start_line": 723,
          "end_line": 846,
          "content": [
            "int trace_uprobe_create(const char *raw_command)",
            "{",
            "\treturn trace_probe_create(raw_command, __trace_uprobe_create);",
            "}",
            "static int create_or_delete_trace_uprobe(const char *raw_command)",
            "{",
            "\tint ret;",
            "",
            "\tif (raw_command[0] == '-')",
            "\t\treturn dyn_event_release(raw_command, &trace_uprobe_ops);",
            "",
            "\tret = dyn_event_create(raw_command, &trace_uprobe_ops);",
            "\treturn ret == -ECANCELED ? -EINVAL : ret;",
            "}",
            "static int trace_uprobe_release(struct dyn_event *ev)",
            "{",
            "\tstruct trace_uprobe *tu = to_trace_uprobe(ev);",
            "",
            "\treturn unregister_trace_uprobe(tu);",
            "}",
            "static int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev)",
            "{",
            "\tstruct trace_uprobe *tu = to_trace_uprobe(ev);",
            "\tchar c = is_ret_probe(tu) ? 'r' : 'p';",
            "\tint i;",
            "",
            "\tseq_printf(m, \"%c:%s/%s %s:0x%0*lx\", c, trace_probe_group_name(&tu->tp),",
            "\t\t\ttrace_probe_name(&tu->tp), tu->filename,",
            "\t\t\t(int)(sizeof(void *) * 2), tu->offset);",
            "",
            "\tif (tu->ref_ctr_offset)",
            "\t\tseq_printf(m, \"(0x%lx)\", tu->ref_ctr_offset);",
            "",
            "\tfor (i = 0; i < tu->tp.nr_args; i++)",
            "\t\tseq_printf(m, \" %s=%s\", tu->tp.args[i].name, tu->tp.args[i].comm);",
            "",
            "\tseq_putc(m, '\\n');",
            "\treturn 0;",
            "}",
            "static int probes_seq_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct dyn_event *ev = v;",
            "",
            "\tif (!is_trace_uprobe(ev))",
            "\t\treturn 0;",
            "",
            "\treturn trace_uprobe_show(m, ev);",
            "}",
            "static int probes_open(struct inode *inode, struct file *file)",
            "{",
            "\tint ret;",
            "",
            "\tret = security_locked_down(LOCKDOWN_TRACEFS);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {",
            "\t\tret = dyn_events_release_all(&trace_uprobe_ops);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\treturn seq_open(file, &probes_seq_op);",
            "}",
            "static ssize_t probes_write(struct file *file, const char __user *buffer,",
            "\t\t\t    size_t count, loff_t *ppos)",
            "{",
            "\treturn trace_parse_run_command(file, buffer, count, ppos,",
            "\t\t\t\t\tcreate_or_delete_trace_uprobe);",
            "}",
            "static int probes_profile_seq_show(struct seq_file *m, void *v)",
            "{",
            "\tstruct dyn_event *ev = v;",
            "\tstruct trace_uprobe *tu;",
            "",
            "\tif (!is_trace_uprobe(ev))",
            "\t\treturn 0;",
            "",
            "\ttu = to_trace_uprobe(ev);",
            "\tseq_printf(m, \"  %s %-44s %15lu\\n\", tu->filename,",
            "\t\t\ttrace_probe_name(&tu->tp), tu->nhit);",
            "\treturn 0;",
            "}",
            "static int profile_open(struct inode *inode, struct file *file)",
            "{",
            "\tint ret;",
            "",
            "\tret = security_locked_down(LOCKDOWN_TRACEFS);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn seq_open(file, &profile_seq_op);",
            "}",
            "static int uprobe_buffer_init(void)",
            "{",
            "\tint cpu, err_cpu;",
            "",
            "\tuprobe_cpu_buffer = alloc_percpu(struct uprobe_cpu_buffer);",
            "\tif (uprobe_cpu_buffer == NULL)",
            "\t\treturn -ENOMEM;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tstruct page *p = alloc_pages_node(cpu_to_node(cpu),",
            "\t\t\t\t\t\t  GFP_KERNEL, 0);",
            "\t\tif (p == NULL) {",
            "\t\t\terr_cpu = cpu;",
            "\t\t\tgoto err;",
            "\t\t}",
            "\t\tper_cpu_ptr(uprobe_cpu_buffer, cpu)->buf = page_address(p);",
            "\t\tmutex_init(&per_cpu_ptr(uprobe_cpu_buffer, cpu)->mutex);",
            "\t}",
            "",
            "\treturn 0;",
            "",
            "err:",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tif (cpu == err_cpu)",
            "\t\t\tbreak;",
            "\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer, cpu)->buf);",
            "\t}",
            "",
            "\tfree_percpu(uprobe_cpu_buffer);",
            "\treturn -ENOMEM;",
            "}"
          ],
          "function_name": "trace_uprobe_create, create_or_delete_trace_uprobe, trace_uprobe_release, trace_uprobe_show, probes_seq_show, probes_open, probes_write, probes_profile_seq_show, profile_open, uprobe_buffer_init",
          "description": "实现 uprobes 动态事件管理，提供创建/删除探针接口，初始化 CPU 缓冲区并管理引用计数，包含探针展示、文件打开/写入及事件触发逻辑",
          "similarity": 0.49115628004074097
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/trace/trace_uprobe.c",
          "start_line": 1304,
          "end_line": 1428,
          "content": [
            "static int uprobe_perf_close(struct trace_event_call *call,",
            "\t\t\t     struct perf_event *event)",
            "{",
            "\tstruct trace_probe *tp;",
            "\tstruct trace_uprobe *tu;",
            "\tint ret = 0;",
            "",
            "\ttp = trace_probe_primary_from_call(call);",
            "\tif (WARN_ON_ONCE(!tp))",
            "\t\treturn -ENODEV;",
            "",
            "\ttu = container_of(tp, struct trace_uprobe, tp);",
            "\tif (trace_uprobe_filter_remove(tu->tp.event->filter, event))",
            "\t\treturn 0;",
            "",
            "\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {",
            "\t\tret = uprobe_apply(tu->uprobe, &tu->consumer, false);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int uprobe_perf_open(struct trace_event_call *call,",
            "\t\t\t    struct perf_event *event)",
            "{",
            "\tstruct trace_probe *tp;",
            "\tstruct trace_uprobe *tu;",
            "\tint err = 0;",
            "",
            "\ttp = trace_probe_primary_from_call(call);",
            "\tif (WARN_ON_ONCE(!tp))",
            "\t\treturn -ENODEV;",
            "",
            "\ttu = container_of(tp, struct trace_uprobe, tp);",
            "\tif (trace_uprobe_filter_add(tu->tp.event->filter, event))",
            "\t\treturn 0;",
            "",
            "\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {",
            "\t\terr = uprobe_apply(tu->uprobe, &tu->consumer, true);",
            "\t\tif (err) {",
            "\t\t\tuprobe_perf_close(call, event);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\treturn err;",
            "}",
            "static bool uprobe_perf_filter(struct uprobe_consumer *uc, struct mm_struct *mm)",
            "{",
            "\tstruct trace_uprobe_filter *filter;",
            "\tstruct trace_uprobe *tu;",
            "\tint ret;",
            "",
            "\ttu = container_of(uc, struct trace_uprobe, consumer);",
            "\tfilter = tu->tp.event->filter;",
            "",
            "\tread_lock(&filter->rwlock);",
            "\tret = __uprobe_perf_filter(filter, mm);",
            "\tread_unlock(&filter->rwlock);",
            "",
            "\treturn ret;",
            "}",
            "static void __uprobe_perf_func(struct trace_uprobe *tu,",
            "\t\t\t       unsigned long func, struct pt_regs *regs,",
            "\t\t\t       struct uprobe_cpu_buffer **ucbp)",
            "{",
            "\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);",
            "\tstruct uprobe_trace_entry_head *entry;",
            "\tstruct uprobe_cpu_buffer *ucb;",
            "\tstruct hlist_head *head;",
            "\tvoid *data;",
            "\tint size, esize;",
            "\tint rctx;",
            "",
            "#ifdef CONFIG_BPF_EVENTS",
            "\tif (bpf_prog_array_valid(call)) {",
            "\t\tconst struct bpf_prog_array *array;",
            "\t\tu32 ret;",
            "",
            "\t\trcu_read_lock_trace();",
            "\t\tarray = rcu_dereference_check(call->prog_array, rcu_read_lock_trace_held());",
            "\t\tret = bpf_prog_run_array_uprobe(array, regs, bpf_prog_run);",
            "\t\trcu_read_unlock_trace();",
            "\t\tif (!ret)",
            "\t\t\treturn;",
            "\t}",
            "#endif /* CONFIG_BPF_EVENTS */",
            "",
            "\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));",
            "",
            "\tucb = prepare_uprobe_buffer(tu, regs, ucbp);",
            "\tsize = esize + ucb->dsize;",
            "\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);",
            "\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))",
            "\t\treturn;",
            "",
            "\tpreempt_disable();",
            "\thead = this_cpu_ptr(call->perf_events);",
            "\tif (hlist_empty(head))",
            "\t\tgoto out;",
            "",
            "\tentry = perf_trace_buf_alloc(size, NULL, &rctx);",
            "\tif (!entry)",
            "\t\tgoto out;",
            "",
            "\tif (is_ret_probe(tu)) {",
            "\t\tentry->vaddr[0] = func;",
            "\t\tentry->vaddr[1] = instruction_pointer(regs);",
            "\t\tdata = DATAOF_TRACE_ENTRY(entry, true);",
            "\t} else {",
            "\t\tentry->vaddr[0] = instruction_pointer(regs);",
            "\t\tdata = DATAOF_TRACE_ENTRY(entry, false);",
            "\t}",
            "",
            "\tmemcpy(data, ucb->buf, ucb->dsize);",
            "",
            "\tif (size - esize > ucb->dsize)",
            "\t\tmemset(data + ucb->dsize, 0, size - esize - ucb->dsize);",
            "",
            "\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,",
            "\t\t\t      head, NULL);",
            " out:",
            "\tpreempt_enable();",
            "}"
          ],
          "function_name": "uprobe_perf_close, uprobe_perf_open, uprobe_perf_filter, __uprobe_perf_func",
          "description": "实现 uprobes 性能事件的注册/注销逻辑，通过 BPF 扩展支持，处理事件数据采集并提交至 perf 追踪缓冲区",
          "similarity": 0.48968082666397095
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/trace/trace_uprobe.c",
          "start_line": 1434,
          "end_line": 1561,
          "content": [
            "static int uprobe_perf_func(struct trace_uprobe *tu, struct pt_regs *regs,",
            "\t\t\t    struct uprobe_cpu_buffer **ucbp)",
            "{",
            "\tif (!uprobe_perf_filter(&tu->consumer, current->mm))",
            "\t\treturn UPROBE_HANDLER_REMOVE;",
            "",
            "\tif (!is_ret_probe(tu))",
            "\t\t__uprobe_perf_func(tu, 0, regs, ucbp);",
            "\treturn 0;",
            "}",
            "static void uretprobe_perf_func(struct trace_uprobe *tu, unsigned long func,",
            "\t\t\t\tstruct pt_regs *regs,",
            "\t\t\t\tstruct uprobe_cpu_buffer **ucbp)",
            "{",
            "\t__uprobe_perf_func(tu, func, regs, ucbp);",
            "}",
            "int bpf_get_uprobe_info(const struct perf_event *event, u32 *fd_type,",
            "\t\t\tconst char **filename, u64 *probe_offset,",
            "\t\t\tu64 *probe_addr, bool perf_type_tracepoint)",
            "{",
            "\tconst char *pevent = trace_event_name(event->tp_event);",
            "\tconst char *group = event->tp_event->class->system;",
            "\tstruct trace_uprobe *tu;",
            "",
            "\tif (perf_type_tracepoint)",
            "\t\ttu = find_probe_event(pevent, group);",
            "\telse",
            "\t\ttu = trace_uprobe_primary_from_call(event->tp_event);",
            "\tif (!tu)",
            "\t\treturn -EINVAL;",
            "",
            "\t*fd_type = is_ret_probe(tu) ? BPF_FD_TYPE_URETPROBE",
            "\t\t\t\t    : BPF_FD_TYPE_UPROBE;",
            "\t*filename = tu->filename;",
            "\t*probe_offset = tu->offset;",
            "\t*probe_addr = 0;",
            "\treturn 0;",
            "}",
            "static int",
            "trace_uprobe_register(struct trace_event_call *event, enum trace_reg type,",
            "\t\t      void *data)",
            "{",
            "\tstruct trace_event_file *file = data;",
            "",
            "\tswitch (type) {",
            "\tcase TRACE_REG_REGISTER:",
            "\t\treturn probe_event_enable(event, file, NULL);",
            "",
            "\tcase TRACE_REG_UNREGISTER:",
            "\t\tprobe_event_disable(event, file);",
            "\t\treturn 0;",
            "",
            "#ifdef CONFIG_PERF_EVENTS",
            "\tcase TRACE_REG_PERF_REGISTER:",
            "\t\treturn probe_event_enable(event, NULL, uprobe_perf_filter);",
            "",
            "\tcase TRACE_REG_PERF_UNREGISTER:",
            "\t\tprobe_event_disable(event, NULL);",
            "\t\treturn 0;",
            "",
            "\tcase TRACE_REG_PERF_OPEN:",
            "\t\treturn uprobe_perf_open(event, data);",
            "",
            "\tcase TRACE_REG_PERF_CLOSE:",
            "\t\treturn uprobe_perf_close(event, data);",
            "",
            "#endif",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs,",
            "\t\t\t     __u64 *data)",
            "{",
            "\tstruct trace_uprobe *tu;",
            "\tstruct uprobe_dispatch_data udd;",
            "\tstruct uprobe_cpu_buffer *ucb = NULL;",
            "\tint ret = 0;",
            "",
            "\ttu = container_of(con, struct trace_uprobe, consumer);",
            "\ttu->nhit++;",
            "",
            "\tudd.tu = tu;",
            "\tudd.bp_addr = instruction_pointer(regs);",
            "",
            "\tcurrent->utask->vaddr = (unsigned long) &udd;",
            "",
            "\tif (WARN_ON_ONCE(!uprobe_cpu_buffer))",
            "\t\treturn 0;",
            "",
            "\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_TRACE))",
            "\t\tret |= uprobe_trace_func(tu, regs, &ucb);",
            "",
            "#ifdef CONFIG_PERF_EVENTS",
            "\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_PROFILE))",
            "\t\tret |= uprobe_perf_func(tu, regs, &ucb);",
            "#endif",
            "\tuprobe_buffer_put(ucb);",
            "\treturn ret;",
            "}",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,",
            "\t\t\t\tunsigned long func, struct pt_regs *regs,",
            "\t\t\t\t__u64 *data)",
            "{",
            "\tstruct trace_uprobe *tu;",
            "\tstruct uprobe_dispatch_data udd;",
            "\tstruct uprobe_cpu_buffer *ucb = NULL;",
            "",
            "\ttu = container_of(con, struct trace_uprobe, consumer);",
            "",
            "\tudd.tu = tu;",
            "\tudd.bp_addr = func;",
            "",
            "\tcurrent->utask->vaddr = (unsigned long) &udd;",
            "",
            "\tif (WARN_ON_ONCE(!uprobe_cpu_buffer))",
            "\t\treturn 0;",
            "",
            "\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_TRACE))",
            "\t\turetprobe_trace_func(tu, func, regs, &ucb);",
            "",
            "#ifdef CONFIG_PERF_EVENTS",
            "\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_PROFILE))",
            "\t\turetprobe_perf_func(tu, func, regs, &ucb);",
            "#endif",
            "\tuprobe_buffer_put(ucb);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "uprobe_perf_func, uretprobe_perf_func, bpf_get_uprobe_info, trace_uprobe_register, uprobe_dispatcher, uretprobe_dispatcher",
          "description": "该代码段实现了用户空间探针（uprobe）和返回探针（uretprobe）的事件注册与分发机制，支持性能事件采样和BPF程序关联。  \n`uprobe_perf_func` 和 `uretprobe_perf_func` 处理性能事件的触发逻辑，`bpf_get_uprobe_info` 提供BPF程序所需的探针元信息，`trace_uprobe_register` 管理探针事件的注册与注销。  \n`uprobe_dispatcher` 和 `uretprobe_dispatcher` 分别作为入口点，根据配置标志调用对应处理函数并封装数据至缓冲区以供后续分析。",
          "similarity": 0.47328996658325195
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/trace/trace_uprobe.c",
          "start_line": 1579,
          "end_line": 1624,
          "content": [
            "static inline void init_trace_event_call(struct trace_uprobe *tu)",
            "{",
            "\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);",
            "\tcall->event.funcs = &uprobe_funcs;",
            "\tcall->class->fields_array = uprobe_fields_array;",
            "",
            "\tcall->flags = TRACE_EVENT_FL_UPROBE | TRACE_EVENT_FL_CAP_ANY;",
            "\tcall->class->reg = trace_uprobe_register;",
            "}",
            "static int register_uprobe_event(struct trace_uprobe *tu)",
            "{",
            "\tinit_trace_event_call(tu);",
            "",
            "\treturn trace_probe_register_event_call(&tu->tp);",
            "}",
            "static int unregister_uprobe_event(struct trace_uprobe *tu)",
            "{",
            "\treturn trace_probe_unregister_event_call(&tu->tp);",
            "}",
            "void destroy_local_trace_uprobe(struct trace_event_call *event_call)",
            "{",
            "\tstruct trace_uprobe *tu;",
            "",
            "\ttu = trace_uprobe_primary_from_call(event_call);",
            "",
            "\tfree_trace_uprobe(tu);",
            "}",
            "static __init int init_uprobe_trace(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = dyn_event_register(&trace_uprobe_ops);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = tracing_init_dentry();",
            "\tif (ret)",
            "\t\treturn 0;",
            "",
            "\ttrace_create_file(\"uprobe_events\", TRACE_MODE_WRITE, NULL,",
            "\t\t\t\t    NULL, &uprobe_events_ops);",
            "\t/* Profile interface */",
            "\ttrace_create_file(\"uprobe_profile\", TRACE_MODE_READ, NULL,",
            "\t\t\t\t    NULL, &uprobe_profile_ops);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "init_trace_event_call, register_uprobe_event, unregister_uprobe_event, destroy_local_trace_uprobe, init_uprobe_trace",
          "description": "该代码段实现了 uprobes 跟踪事件的注册与管理功能，主要包含事件结构初始化、注册/注销逻辑及模块初始化。  \n`init_trace_event_call` 初始化跟踪事件结构并绑定uprobes专用函数集，`register_uprobe_event` 和 `unregister_uprobe_event` 分别负责注册与注销事件调用，`destroy_local_trace_uprobe` 用于清理本地跟踪探针资源。  \n上下文完整，代码展示了 uprobes 跟踪模块的事件生命周期管理和初始化流程。",
          "similarity": 0.45689642429351807
        }
      ]
    },
    {
      "source_file": "kernel/bpf/cpumap.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:06:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\cpumap.c`\n\n---\n\n# bpf/cpumap.c 技术文档\n\n## 文件概述\n\n`bpf/cpumap.c` 实现了 BPF CPU Map（cpumap）这一内核数据结构，主要用于 XDP（eXpress Data Path）框架中的跨 CPU 重定向功能。该机制允许 XDP 程序通过 `bpf_redirect_map()` 辅助函数将原始 XDP 数据帧重定向到指定的目标 CPU，由目标 CPU 上运行的专用内核线程（kthread）接收并将其转换为 `sk_buff` 后送入常规网络协议栈处理。cpumap 的核心目标是实现高性能、低延迟的网络预过滤，通过将 XDP 处理阶段与主网络栈解耦，提升系统在 10Gbps 及以上速率下的可扩展性和隔离性。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct bpf_cpu_map`**  \n  表示整个 CPU Map 对象，继承自 `struct bpf_map`，包含一个指向 `bpf_cpu_map_entry` 指针数组的 `cpu_map` 成员，用于按 CPU ID 索引目标条目。\n\n- **`struct bpf_cpu_map_entry`**  \n  表示映射到单个目标 CPU 的条目，关键成员包括：\n  - `cpu`：目标 CPU 编号\n  - `queue`：`ptr_ring` 类型的无锁环形缓冲队列，用于暂存重定向的 XDP 帧\n  - `kthread`：绑定到该 CPU 的消费者内核线程\n  - `prog`：可选的附加 BPF 程序，在帧入队后、送入协议栈前执行二次处理\n  - `bulkq`：每 CPU 的批量入队缓存（`xdp_bulk_queue`），用于提升入队性能\n\n- **`struct xdp_bulk_queue`**  \n  每 CPU 的批量队列结构，用于暂存最多 `CPU_MAP_BULK_SIZE`（默认 8）个待入队的 XDP 帧，减少对共享 `ptr_ring` 的频繁访问。\n\n### 主要函数\n\n- **`cpu_map_alloc()`**  \n  分配并初始化一个新的 CPU Map 实例，校验属性合法性（如 key/value 大小、最大条目数不超过 `NR_CPUS`）。\n\n- **`cpu_map_kthread_run()`**  \n  目标 CPU 上运行的消费者内核线程主循环，从 `ptr_ring` 队列批量消费 XDP 帧，执行可选 BPF 程序，并将结果帧转换为 `sk_buff` 送入网络栈。\n\n- **`cpu_map_bpf_prog_run_xdp()`**  \n  在消费线程中执行附加的 XDP 类型 BPF 程序，支持 `XDP_PASS`、`XDP_REDIRECT`、`XDP_DROP` 等动作。\n\n- **`cpu_map_bpf_prog_run_skb()`**  \n  处理已转换为 `sk_buff` 的数据包（通常来自重定向失败或特殊路径），执行通用 XDP BPF 程序。\n\n- **`__cpu_map_ring_cleanup()`**  \n  安全清理 `ptr_ring` 队列中的残留帧，确保资源正确释放。\n\n## 关键实现\n\n### 无锁批量入队与消费\n\n- **生产者侧（XDP 程序）**：使用每 CPU 的 `xdp_bulk_queue` 缓存待入队帧。当缓存满或需要 flush 时，一次性将批量帧原子地推入目标 CPU 条目的 `ptr_ring` 队列，减少锁竞争。\n- **消费者侧（kthread）**：每个 `bpf_cpu_map_entry` 绑定一个专用 kthread，独占消费其 `ptr_ring`。通过 `__ptr_ring_consume_batched()` 批量获取帧，提升吞吐。\n\n### 跨 CPU 重定向流程\n\n1. XDP 程序调用 `bpf_redirect_map(map, cpu_id, 0)`。\n2. 内核将当前 XDP 帧暂存到当前 CPU 对应目标 `cpu_id` 的 `bulkq` 中。\n3. 在驱动 `->poll()` 结束或显式 flush 时，将 `bulkq` 中的帧批量推入目标 CPU 的 `ptr_ring`。\n4. 目标 CPU 的 kthread 被唤醒，消费帧，执行可选 BPF 程序，转换为 `sk_buff` 并调用 `netif_receive_skb_list()` 送入协议栈。\n\n### BPF 程序二次处理\n\n每个 `bpf_cpu_map_entry` 可关联一个 BPF 程序。消费线程在处理帧前会执行该程序，支持进一步过滤、修改或重定向（如再次重定向到设备或另一个 CPU），增强了灵活性。\n\n### 内存与资源管理\n\n- 使用 `__ptr_set_bit(0, &ptr)` 标记 `sk_buff` 指针（最低位为 1），普通 XDP 帧指针最低位为 0，便于在清理时区分类型。\n- kthread 在退出前确保队列为空，防止内存泄漏。\n- 通过 RCU 机制安全地更新和释放 map 条目。\n\n## 依赖关系\n\n- **BPF 子系统**：依赖 `bpf.h`、`filter.h` 提供 map 基础框架、BPF 程序执行接口。\n- **XDP 框架**：依赖 `xdp.h`、`xdp_frame` 结构及 `xdp_do_redirect()` 等重定向机制。\n- **网络核心**：使用 `netdevice.h` 的 `netif_receive_skb_list()` 将数据包送入协议栈。\n- **内核同步原语**：使用 `ptr_ring`（无锁环形缓冲区）、`completion`（线程启动同步）、`rcu_work`（延迟释放）。\n- **调度与线程**：依赖 `kthread` 创建 CPU 绑定的消费者线程。\n- **追踪**：集成 `trace/events/xdp.h` 提供 XDP 事件追踪。\n\n## 使用场景\n\n- **高性能网络预过滤**：在专用 CPU 上运行 XDP 程序进行 DDoS 防御、ACL 过滤等，将合法流量重定向到其他 CPU 的协议栈处理，避免主 CPU 过载。\n- **负载均衡**：将流量按策略分发到多个 CPU，提升多核系统的网络处理能力。\n- **服务链（Service Chaining）**：通过级联 cpumap 和 devmap，构建复杂的流量处理流水线。\n- **隔离关键路径**：将 XDP 处理与应用层网络处理隔离到不同 CPU，减少相互干扰，保障低延迟。",
      "similarity": 0.48235905170440674,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/cpumap.c",
          "start_line": 117,
          "end_line": 232,
          "content": [
            "static void __cpu_map_ring_cleanup(struct ptr_ring *ring)",
            "{",
            "\t/* The tear-down procedure should have made sure that queue is",
            "\t * empty.  See __cpu_map_entry_replace() and work-queue",
            "\t * invoked cpu_map_kthread_stop(). Catch any broken behaviour",
            "\t * gracefully and warn once.",
            "\t */",
            "\tvoid *ptr;",
            "",
            "\twhile ((ptr = ptr_ring_consume(ring))) {",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tif (unlikely(__ptr_test_bit(0, &ptr))) {",
            "\t\t\t__ptr_clear_bit(0, &ptr);",
            "\t\t\tkfree_skb(ptr);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\txdp_return_frame(ptr);",
            "\t}",
            "}",
            "static void cpu_map_bpf_prog_run_skb(struct bpf_cpu_map_entry *rcpu,",
            "\t\t\t\t     struct list_head *listp,",
            "\t\t\t\t     struct xdp_cpumap_stats *stats)",
            "{",
            "\tstruct sk_buff *skb, *tmp;",
            "\tstruct xdp_buff xdp;",
            "\tu32 act;",
            "\tint err;",
            "",
            "\tlist_for_each_entry_safe(skb, tmp, listp, list) {",
            "\t\tact = bpf_prog_run_generic_xdp(skb, &xdp, rcpu->prog);",
            "\t\tswitch (act) {",
            "\t\tcase XDP_PASS:",
            "\t\t\tbreak;",
            "\t\tcase XDP_REDIRECT:",
            "\t\t\tskb_list_del_init(skb);",
            "\t\t\terr = xdp_do_generic_redirect(skb->dev, skb, &xdp,",
            "\t\t\t\t\t\t      rcpu->prog);",
            "\t\t\tif (unlikely(err)) {",
            "\t\t\t\tkfree_skb(skb);",
            "\t\t\t\tstats->drop++;",
            "\t\t\t} else {",
            "\t\t\t\tstats->redirect++;",
            "\t\t\t}",
            "\t\t\treturn;",
            "\t\tdefault:",
            "\t\t\tbpf_warn_invalid_xdp_action(NULL, rcpu->prog, act);",
            "\t\t\tfallthrough;",
            "\t\tcase XDP_ABORTED:",
            "\t\t\ttrace_xdp_exception(skb->dev, rcpu->prog, act);",
            "\t\t\tfallthrough;",
            "\t\tcase XDP_DROP:",
            "\t\t\tskb_list_del_init(skb);",
            "\t\t\tkfree_skb(skb);",
            "\t\t\tstats->drop++;",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "}",
            "static int cpu_map_bpf_prog_run_xdp(struct bpf_cpu_map_entry *rcpu,",
            "\t\t\t\t    void **frames, int n,",
            "\t\t\t\t    struct xdp_cpumap_stats *stats)",
            "{",
            "\tstruct xdp_rxq_info rxq = {};",
            "\tstruct xdp_buff xdp;",
            "\tint i, nframes = 0;",
            "",
            "\txdp_set_return_frame_no_direct();",
            "\txdp.rxq = &rxq;",
            "",
            "\tfor (i = 0; i < n; i++) {",
            "\t\tstruct xdp_frame *xdpf = frames[i];",
            "\t\tu32 act;",
            "\t\tint err;",
            "",
            "\t\trxq.dev = xdpf->dev_rx;",
            "\t\trxq.mem = xdpf->mem;",
            "\t\t/* TODO: report queue_index to xdp_rxq_info */",
            "",
            "\t\txdp_convert_frame_to_buff(xdpf, &xdp);",
            "",
            "\t\tact = bpf_prog_run_xdp(rcpu->prog, &xdp);",
            "\t\tswitch (act) {",
            "\t\tcase XDP_PASS:",
            "\t\t\terr = xdp_update_frame_from_buff(&xdp, xdpf);",
            "\t\t\tif (err < 0) {",
            "\t\t\t\txdp_return_frame(xdpf);",
            "\t\t\t\tstats->drop++;",
            "\t\t\t} else {",
            "\t\t\t\tframes[nframes++] = xdpf;",
            "\t\t\t\tstats->pass++;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\tcase XDP_REDIRECT:",
            "\t\t\terr = xdp_do_redirect(xdpf->dev_rx, &xdp,",
            "\t\t\t\t\t      rcpu->prog);",
            "\t\t\tif (unlikely(err)) {",
            "\t\t\t\txdp_return_frame(xdpf);",
            "\t\t\t\tstats->drop++;",
            "\t\t\t} else {",
            "\t\t\t\tstats->redirect++;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbpf_warn_invalid_xdp_action(NULL, rcpu->prog, act);",
            "\t\t\tfallthrough;",
            "\t\tcase XDP_DROP:",
            "\t\t\txdp_return_frame(xdpf);",
            "\t\t\tstats->drop++;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\txdp_clear_return_frame_no_direct();",
            "",
            "\treturn nframes;",
            "}"
          ],
          "function_name": "__cpu_map_ring_cleanup, cpu_map_bpf_prog_run_skb, cpu_map_bpf_prog_run_xdp",
          "description": "实现XDP程序对数据包的处理逻辑，包括skb处理流程(cpu_map_bpf_prog_run_skb)和xdp_frame处理流程(cpu_map_bpf_prog_run_xdp)，提供XDP_PASS/XDP_REDIRECT等动作的分支处理。",
          "similarity": 0.47833311557769775
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/cpumap.c",
          "start_line": 367,
          "end_line": 472,
          "content": [
            "static int __cpu_map_load_bpf_program(struct bpf_cpu_map_entry *rcpu,",
            "\t\t\t\t      struct bpf_map *map, int fd)",
            "{",
            "\tstruct bpf_prog *prog;",
            "",
            "\tprog = bpf_prog_get_type(fd, BPF_PROG_TYPE_XDP);",
            "\tif (IS_ERR(prog))",
            "\t\treturn PTR_ERR(prog);",
            "",
            "\tif (prog->expected_attach_type != BPF_XDP_CPUMAP ||",
            "\t    !bpf_prog_map_compatible(map, prog)) {",
            "\t\tbpf_prog_put(prog);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\trcpu->value.bpf_prog.id = prog->aux->id;",
            "\trcpu->prog = prog;",
            "",
            "\treturn 0;",
            "}",
            "static void __cpu_map_entry_free(struct work_struct *work)",
            "{",
            "\tstruct bpf_cpu_map_entry *rcpu;",
            "",
            "\t/* This cpu_map_entry have been disconnected from map and one",
            "\t * RCU grace-period have elapsed. Thus, XDP cannot queue any",
            "\t * new packets and cannot change/set flush_needed that can",
            "\t * find this entry.",
            "\t */",
            "\trcpu = container_of(to_rcu_work(work), struct bpf_cpu_map_entry, free_work);",
            "",
            "\t/* kthread_stop will wake_up_process and wait for it to complete.",
            "\t * cpu_map_kthread_run() makes sure the pointer ring is empty",
            "\t * before exiting.",
            "\t */",
            "\tkthread_stop(rcpu->kthread);",
            "",
            "\tif (rcpu->prog)",
            "\t\tbpf_prog_put(rcpu->prog);",
            "\t/* The queue should be empty at this point */",
            "\t__cpu_map_ring_cleanup(rcpu->queue);",
            "\tptr_ring_cleanup(rcpu->queue, NULL);",
            "\tkfree(rcpu->queue);",
            "\tfree_percpu(rcpu->bulkq);",
            "\tkfree(rcpu);",
            "}",
            "static void __cpu_map_entry_replace(struct bpf_cpu_map *cmap,",
            "\t\t\t\t    u32 key_cpu, struct bpf_cpu_map_entry *rcpu)",
            "{",
            "\tstruct bpf_cpu_map_entry *old_rcpu;",
            "",
            "\told_rcpu = unrcu_pointer(xchg(&cmap->cpu_map[key_cpu], RCU_INITIALIZER(rcpu)));",
            "\tif (old_rcpu) {",
            "\t\tINIT_RCU_WORK(&old_rcpu->free_work, __cpu_map_entry_free);",
            "\t\tqueue_rcu_work(system_wq, &old_rcpu->free_work);",
            "\t}",
            "}",
            "static long cpu_map_delete_elem(struct bpf_map *map, void *key)",
            "{",
            "\tstruct bpf_cpu_map *cmap = container_of(map, struct bpf_cpu_map, map);",
            "\tu32 key_cpu = *(u32 *)key;",
            "",
            "\tif (key_cpu >= map->max_entries)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* notice caller map_delete_elem() uses rcu_read_lock() */",
            "\t__cpu_map_entry_replace(cmap, key_cpu, NULL);",
            "\treturn 0;",
            "}",
            "static long cpu_map_update_elem(struct bpf_map *map, void *key, void *value,",
            "\t\t\t\tu64 map_flags)",
            "{",
            "\tstruct bpf_cpu_map *cmap = container_of(map, struct bpf_cpu_map, map);",
            "\tstruct bpf_cpumap_val cpumap_value = {};",
            "\tstruct bpf_cpu_map_entry *rcpu;",
            "\t/* Array index key correspond to CPU number */",
            "\tu32 key_cpu = *(u32 *)key;",
            "",
            "\tmemcpy(&cpumap_value, value, map->value_size);",
            "",
            "\tif (unlikely(map_flags > BPF_EXIST))",
            "\t\treturn -EINVAL;",
            "\tif (unlikely(key_cpu >= cmap->map.max_entries))",
            "\t\treturn -E2BIG;",
            "\tif (unlikely(map_flags == BPF_NOEXIST))",
            "\t\treturn -EEXIST;",
            "\tif (unlikely(cpumap_value.qsize > 16384)) /* sanity limit on qsize */",
            "\t\treturn -EOVERFLOW;",
            "",
            "\t/* Make sure CPU is a valid possible cpu */",
            "\tif (key_cpu >= nr_cpumask_bits || !cpu_possible(key_cpu))",
            "\t\treturn -ENODEV;",
            "",
            "\tif (cpumap_value.qsize == 0) {",
            "\t\trcpu = NULL; /* Same as deleting */",
            "\t} else {",
            "\t\t/* Updating qsize cause re-allocation of bpf_cpu_map_entry */",
            "\t\trcpu = __cpu_map_entry_alloc(map, &cpumap_value, key_cpu);",
            "\t\tif (!rcpu)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "\trcu_read_lock();",
            "\t__cpu_map_entry_replace(cmap, key_cpu, rcpu);",
            "\trcu_read_unlock();",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__cpu_map_load_bpf_program, __cpu_map_entry_free, __cpu_map_entry_replace, cpu_map_delete_elem, cpu_map_update_elem",
          "description": "实现cpu_map_entry的生命周期管理，包括BPF程序加载验证(__cpu_map_load_bpf_program)、条目替换(__cpu_map_entry_replace)、资源释放(__cpu_map_entry_free)等核心操作。",
          "similarity": 0.4660281538963318
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/cpumap.c",
          "start_line": 1,
          "end_line": 116,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* bpf/cpumap.c",
            " *",
            " * Copyright (c) 2017 Jesper Dangaard Brouer, Red Hat Inc.",
            " */",
            "",
            "/**",
            " * DOC: cpu map",
            " * The 'cpumap' is primarily used as a backend map for XDP BPF helper",
            " * call bpf_redirect_map() and XDP_REDIRECT action, like 'devmap'.",
            " *",
            " * Unlike devmap which redirects XDP frames out to another NIC device,",
            " * this map type redirects raw XDP frames to another CPU.  The remote",
            " * CPU will do SKB-allocation and call the normal network stack.",
            " */",
            "/*",
            " * This is a scalability and isolation mechanism, that allow",
            " * separating the early driver network XDP layer, from the rest of the",
            " * netstack, and assigning dedicated CPUs for this stage.  This",
            " * basically allows for 10G wirespeed pre-filtering via bpf.",
            " */",
            "#include <linux/bitops.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/ptr_ring.h>",
            "#include <net/xdp.h>",
            "",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <trace/events/xdp.h>",
            "#include <linux/btf_ids.h>",
            "",
            "#include <linux/netdevice.h>   /* netif_receive_skb_list */",
            "#include <linux/etherdevice.h> /* eth_type_trans */",
            "",
            "/* General idea: XDP packets getting XDP redirected to another CPU,",
            " * will maximum be stored/queued for one driver ->poll() call.  It is",
            " * guaranteed that queueing the frame and the flush operation happen on",
            " * same CPU.  Thus, cpu_map_flush operation can deduct via this_cpu_ptr()",
            " * which queue in bpf_cpu_map_entry contains packets.",
            " */",
            "",
            "#define CPU_MAP_BULK_SIZE 8  /* 8 == one cacheline on 64-bit archs */",
            "struct bpf_cpu_map_entry;",
            "struct bpf_cpu_map;",
            "",
            "struct xdp_bulk_queue {",
            "\tvoid *q[CPU_MAP_BULK_SIZE];",
            "\tstruct list_head flush_node;",
            "\tstruct bpf_cpu_map_entry *obj;",
            "\tunsigned int count;",
            "};",
            "",
            "/* Struct for every remote \"destination\" CPU in map */",
            "struct bpf_cpu_map_entry {",
            "\tu32 cpu;    /* kthread CPU and map index */",
            "\tint map_id; /* Back reference to map */",
            "",
            "\t/* XDP can run multiple RX-ring queues, need __percpu enqueue store */",
            "\tstruct xdp_bulk_queue __percpu *bulkq;",
            "",
            "\t/* Queue with potential multi-producers, and single-consumer kthread */",
            "\tstruct ptr_ring *queue;",
            "\tstruct task_struct *kthread;",
            "",
            "\tstruct bpf_cpumap_val value;",
            "\tstruct bpf_prog *prog;",
            "",
            "\tstruct completion kthread_running;",
            "\tstruct rcu_work free_work;",
            "};",
            "",
            "struct bpf_cpu_map {",
            "\tstruct bpf_map map;",
            "\t/* Below members specific for map type */",
            "\tstruct bpf_cpu_map_entry __rcu **cpu_map;",
            "};",
            "",
            "static DEFINE_PER_CPU(struct list_head, cpu_map_flush_list);",
            "",
            "static struct bpf_map *cpu_map_alloc(union bpf_attr *attr)",
            "{",
            "\tu32 value_size = attr->value_size;",
            "\tstruct bpf_cpu_map *cmap;",
            "",
            "\t/* check sanity of attributes */",
            "\tif (attr->max_entries == 0 || attr->key_size != 4 ||",
            "\t    (value_size != offsetofend(struct bpf_cpumap_val, qsize) &&",
            "\t     value_size != offsetofend(struct bpf_cpumap_val, bpf_prog.fd)) ||",
            "\t    attr->map_flags & ~BPF_F_NUMA_NODE)",
            "\t\treturn ERR_PTR(-EINVAL);",
            "",
            "\t/* Pre-limit array size based on NR_CPUS, not final CPU check */",
            "\tif (attr->max_entries > NR_CPUS)",
            "\t\treturn ERR_PTR(-E2BIG);",
            "",
            "\tcmap = bpf_map_area_alloc(sizeof(*cmap), NUMA_NO_NODE);",
            "\tif (!cmap)",
            "\t\treturn ERR_PTR(-ENOMEM);",
            "",
            "\tbpf_map_init_from_attr(&cmap->map, attr);",
            "",
            "\t/* Alloc array for possible remote \"destination\" CPUs */",
            "\tcmap->cpu_map = bpf_map_area_alloc(cmap->map.max_entries *",
            "\t\t\t\t\t   sizeof(struct bpf_cpu_map_entry *),",
            "\t\t\t\t\t   cmap->map.numa_node);",
            "\tif (!cmap->cpu_map) {",
            "\t\tbpf_map_area_free(cmap);",
            "\t\treturn ERR_PTR(-ENOMEM);",
            "\t}",
            "",
            "\treturn &cmap->map;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了cpu_map的数据结构及初始化函数，用于XDP帧跨CPU重定向。实现基于RCU的cpu_map_entry数组管理，支持通过BPF程序过滤并转发网络数据包到指定CPU。",
          "similarity": 0.4576877951622009
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/cpumap.c",
          "start_line": 728,
          "end_line": 774,
          "content": [
            "int cpu_map_enqueue(struct bpf_cpu_map_entry *rcpu, struct xdp_frame *xdpf,",
            "\t\t    struct net_device *dev_rx)",
            "{",
            "\t/* Info needed when constructing SKB on remote CPU */",
            "\txdpf->dev_rx = dev_rx;",
            "",
            "\tbq_enqueue(rcpu, xdpf);",
            "\treturn 0;",
            "}",
            "int cpu_map_generic_redirect(struct bpf_cpu_map_entry *rcpu,",
            "\t\t\t     struct sk_buff *skb)",
            "{",
            "\tint ret;",
            "",
            "\t__skb_pull(skb, skb->mac_len);",
            "\tskb_set_redirected(skb, false);",
            "\t__ptr_set_bit(0, &skb);",
            "",
            "\tret = ptr_ring_produce(rcpu->queue, skb);",
            "\tif (ret < 0)",
            "\t\tgoto trace;",
            "",
            "\twake_up_process(rcpu->kthread);",
            "trace:",
            "\ttrace_xdp_cpumap_enqueue(rcpu->map_id, !ret, !!ret, rcpu->cpu);",
            "\treturn ret;",
            "}",
            "void __cpu_map_flush(void)",
            "{",
            "\tstruct list_head *flush_list = this_cpu_ptr(&cpu_map_flush_list);",
            "\tstruct xdp_bulk_queue *bq, *tmp;",
            "",
            "\tlist_for_each_entry_safe(bq, tmp, flush_list, flush_node) {",
            "\t\tbq_flush_to_queue(bq);",
            "",
            "\t\t/* If already running, costs spin_lock_irqsave + smb_mb */",
            "\t\twake_up_process(bq->obj->kthread);",
            "\t}",
            "}",
            "static int __init cpu_map_init(void)",
            "{",
            "\tint cpu;",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tINIT_LIST_HEAD(&per_cpu(cpu_map_flush_list, cpu));",
            "\treturn 0;",
            "}"
          ],
          "function_name": "cpu_map_enqueue, cpu_map_generic_redirect, __cpu_map_flush, cpu_map_init",
          "description": "该代码块实现了CPU映射机制中的数据分发与同步功能。  \n`cpu_map_enqueue`将XDP帧注册到远程CPU队列，`cpu_map_generic_redirect`处理skb并将其分发至目标队列，`__cpu_map_flush`负责批量刷新队列以避免阻塞，`cpu_map_init`初始化各CPU的刷新链表。  \n上下文不完整：关键函数如`bq_enqueue`、`ptr_ring_produce`及结构体`struct bpf_cpu_map_entry`等未在片段中定义。",
          "similarity": 0.45235496759414673
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/cpumap.c",
          "start_line": 564,
          "end_line": 678,
          "content": [
            "static void cpu_map_free(struct bpf_map *map)",
            "{",
            "\tstruct bpf_cpu_map *cmap = container_of(map, struct bpf_cpu_map, map);",
            "\tu32 i;",
            "",
            "\t/* At this point bpf_prog->aux->refcnt == 0 and this map->refcnt == 0,",
            "\t * so the bpf programs (can be more than one that used this map) were",
            "\t * disconnected from events. Wait for outstanding critical sections in",
            "\t * these programs to complete. synchronize_rcu() below not only",
            "\t * guarantees no further \"XDP/bpf-side\" reads against",
            "\t * bpf_cpu_map->cpu_map, but also ensure pending flush operations",
            "\t * (if any) are completed.",
            "\t */",
            "\tsynchronize_rcu();",
            "",
            "\t/* The only possible user of bpf_cpu_map_entry is",
            "\t * cpu_map_kthread_run().",
            "\t */",
            "\tfor (i = 0; i < cmap->map.max_entries; i++) {",
            "\t\tstruct bpf_cpu_map_entry *rcpu;",
            "",
            "\t\trcpu = rcu_dereference_raw(cmap->cpu_map[i]);",
            "\t\tif (!rcpu)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Stop kthread and cleanup entry directly */",
            "\t\t__cpu_map_entry_free(&rcpu->free_work.work);",
            "\t}",
            "\tbpf_map_area_free(cmap->cpu_map);",
            "\tbpf_map_area_free(cmap);",
            "}",
            "static int cpu_map_get_next_key(struct bpf_map *map, void *key, void *next_key)",
            "{",
            "\tstruct bpf_cpu_map *cmap = container_of(map, struct bpf_cpu_map, map);",
            "\tu32 index = key ? *(u32 *)key : U32_MAX;",
            "\tu32 *next = next_key;",
            "",
            "\tif (index >= cmap->map.max_entries) {",
            "\t\t*next = 0;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tif (index == cmap->map.max_entries - 1)",
            "\t\treturn -ENOENT;",
            "\t*next = index + 1;",
            "\treturn 0;",
            "}",
            "static long cpu_map_redirect(struct bpf_map *map, u64 index, u64 flags)",
            "{",
            "\treturn __bpf_xdp_redirect_map(map, index, flags, 0,",
            "\t\t\t\t      __cpu_map_lookup_elem);",
            "}",
            "static u64 cpu_map_mem_usage(const struct bpf_map *map)",
            "{",
            "\tu64 usage = sizeof(struct bpf_cpu_map);",
            "",
            "\t/* Currently the dynamically allocated elements are not counted */",
            "\tusage += (u64)map->max_entries * sizeof(struct bpf_cpu_map_entry *);",
            "\treturn usage;",
            "}",
            "static void bq_flush_to_queue(struct xdp_bulk_queue *bq)",
            "{",
            "\tstruct bpf_cpu_map_entry *rcpu = bq->obj;",
            "\tunsigned int processed = 0, drops = 0;",
            "\tconst int to_cpu = rcpu->cpu;",
            "\tstruct ptr_ring *q;",
            "\tint i;",
            "",
            "\tif (unlikely(!bq->count))",
            "\t\treturn;",
            "",
            "\tq = rcpu->queue;",
            "\tspin_lock(&q->producer_lock);",
            "",
            "\tfor (i = 0; i < bq->count; i++) {",
            "\t\tstruct xdp_frame *xdpf = bq->q[i];",
            "\t\tint err;",
            "",
            "\t\terr = __ptr_ring_produce(q, xdpf);",
            "\t\tif (err) {",
            "\t\t\tdrops++;",
            "\t\t\txdp_return_frame_rx_napi(xdpf);",
            "\t\t}",
            "\t\tprocessed++;",
            "\t}",
            "\tbq->count = 0;",
            "\tspin_unlock(&q->producer_lock);",
            "",
            "\t__list_del_clearprev(&bq->flush_node);",
            "",
            "\t/* Feedback loop via tracepoints */",
            "\ttrace_xdp_cpumap_enqueue(rcpu->map_id, processed, drops, to_cpu);",
            "}",
            "static void bq_enqueue(struct bpf_cpu_map_entry *rcpu, struct xdp_frame *xdpf)",
            "{",
            "\tstruct list_head *flush_list = this_cpu_ptr(&cpu_map_flush_list);",
            "\tstruct xdp_bulk_queue *bq = this_cpu_ptr(rcpu->bulkq);",
            "",
            "\tif (unlikely(bq->count == CPU_MAP_BULK_SIZE))",
            "\t\tbq_flush_to_queue(bq);",
            "",
            "\t/* Notice, xdp_buff/page MUST be queued here, long enough for",
            "\t * driver to code invoking us to finished, due to driver",
            "\t * (e.g. ixgbe) recycle tricks based on page-refcnt.",
            "\t *",
            "\t * Thus, incoming xdp_frame is always queued here (else we race",
            "\t * with another CPU on page-refcnt and remaining driver code).",
            "\t * Queue time is very short, as driver will invoke flush",
            "\t * operation, when completing napi->poll call.",
            "\t */",
            "\tbq->q[bq->count++] = xdpf;",
            "",
            "\tif (!bq->flush_node.prev)",
            "\t\tlist_add(&bq->flush_node, flush_list);",
            "}"
          ],
          "function_name": "cpu_map_free, cpu_map_get_next_key, cpu_map_redirect, cpu_map_mem_usage, bq_flush_to_queue, bq_enqueue",
          "description": "提供映射销毁(cpu_map_free)、键遍历(cpu_map_get_next_key)、内存使用统计(cpu_map_mem_usage)等功能，包含批量队列刷新(bq_flush_to_queue)和帧入队(bq_enqueue)的底层实现。",
          "similarity": 0.43648529052734375
        }
      ]
    },
    {
      "source_file": "kernel/events/uprobes.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:25:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `events\\uprobes.c`\n\n---\n\n# `events/uprobes.c` 技术文档\n\n## 1. 文件概述\n\n`events/uprobes.c` 是 Linux 内核中实现 **用户空间探针（User-space Probes, uprobes）** 的核心文件。UProbes 允许内核在用户空间程序的指定地址动态插入断点，从而在不修改目标程序的前提下，实现对用户态函数调用、指令执行等行为的动态追踪与监控。该机制广泛用于性能分析（如 perf）、调试工具（如 SystemTap、ftrace）以及安全审计等场景。\n\n本文件负责 uprobes 的注册、注销、断点插入/恢复、执行时拦截、单步执行（single-step）以及与内存管理子系统的协同工作。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct uprobe`**  \n  表示一个用户空间探针实例，包含：\n  - `rb_node`：用于在全局红黑树 `uprobes_tree` 中索引（按 inode + offset）\n  - `ref`：引用计数\n  - `inode` 和 `offset`：目标可执行文件及其偏移位置\n  - `arch`：架构相关字段（如原始指令 `insn` 和执行副本 `ixol`）\n  - `consumers`：关联的消费者（如 perf 事件）\n  - `pending_list`：待处理的 mmap 事件队列\n\n- **`struct xol_area`**（Execute Out of Line Area）  \n  每个被探测进程的私有区域，用于存放被断点替换的原始指令副本，供单步执行时使用。包含：\n  - `vaddr`：虚拟地址\n  - `pages[2]`：最多两页的匿名可执行内存\n  - `bitmap`：槽位分配状态\n  - `slot_count`：当前使用槽位数\n\n- **`struct delayed_uprobe`**  \n  延迟处理的 uprobe 事件，用于在进程 mmap 时异步注册探针。\n\n- **全局变量**：\n  - `uprobes_tree`：所有已注册 uprobes 的红黑树（按 inode + offset 排序）\n  - `uprobes_treelock`：保护红黑树的读写锁\n  - `uprobes_mmap_mutex[]`：哈希桶数组，用于序列化同一 inode 的 mmap 处理\n  - `delayed_uprobe_list`：延迟注册队列\n\n### 主要函数\n\n- **`valid_vma()`**：判断 VMA 是否为可执行且适合插入 uprobe（注册时要求可写，注销时放宽）\n- **`offset_to_vaddr()` / `vaddr_to_offset()`**：在文件偏移与虚拟地址间转换\n- **`__replace_page()`**：替换 VMA 中某页为新页（用于写时复制 COW 以插入断点）\n- **`is_swbp_insn()` / `is_trap_insn()`**：判断指令是否为软件断点（弱符号，可由架构覆盖）\n- **`copy_from_page()` / `copy_to_page()`**：原子地从/向页面拷贝数据（使用 `kmap_atomic`）\n\n## 3. 关键实现\n\n### 探针注册与查找\n- 所有 `uprobe` 实例通过 `(inode, offset)` 作为键存入全局红黑树 `uprobes_tree`。\n- 使用 `uprobes_treelock` 读写锁保护树结构的并发访问。\n- `no_uprobe_events()` 宏用于快速判断是否有活跃探针，避免不必要的 mmap 钩子调用。\n\n### 断点插入机制\n- 当进程 mmap 包含 uprobe 的可执行文件时，内核通过 `uprobe_mmap` 钩子介入。\n- 若 VMA 有效（`valid_vma`），则尝试在目标地址插入软件断点指令（如 `int3`）。\n- 为避免修改共享页，使用 `__replace_page()` 执行 COW：分配新匿名页，复制原内容，修改目标指令为断点，再替换页表项。\n\n### 单步执行（XOL）\n- 触发断点后，内核为当前任务分配 `xol_area`（若无则创建）。\n- 从 `xol_area` 的槽位中取出原始指令副本，设置单步执行模式（`user_enable_single_step`）。\n- 单步完成后恢复原上下文，并释放槽位。\n\n### 延迟注册\n- 若在进程执行过程中注册 uprobe，而目标 VMA 尚未映射，则将事件加入 `delayed_uprobe_list`。\n- 在后续 `mmap` 或 `exec` 时处理延迟事件，确保探针最终生效。\n\n### 架构抽象\n- 通过 `struct arch_uprobe` 封装架构相关逻辑（如指令分析、单步支持）。\n- 提供弱符号函数 `is_swbp_insn()` 和 `is_trap_insn()`，允许架构代码覆盖默认实现（如 PowerPC 支持多种 trap 指令）。\n\n## 4. 依赖关系\n\n- **内存管理子系统**：依赖 `mm/` 中的页表操作（`pte` 修改）、COW 机制、`rmap`、`mmu_notifier` 等。\n- **VFS 层**：通过 `struct inode` 关联可执行文件。\n- **调度器**：使用 `task_work` 机制处理异步任务，依赖 `mm_struct` 生命周期管理。\n- **架构代码**：依赖各架构实现的断点指令、单步执行支持（如 x86 的 `int3` 和 TF 标志）。\n- **其他内核组件**：\n  - `kdebug.h`：用于注册通知链（如 page fault 回调）\n  - `percpu-rwsem.h`：用于 `dup_mmap_sem` 同步 fork 时的内存拷贝\n  - `shmem_fs.h` / `khugepaged.h`：处理共享内存和透明大页场景\n\n## 5. 使用场景\n\n- **动态追踪**：perf、ftrace、eBPF 等工具通过 uprobes 在用户函数入口/出口插入探针，收集性能数据。\n- **调试器支持**：GDB 等调试器可利用 uprobes 实现非侵入式断点。\n- **安全监控**：监控敏感系统调用或库函数的调用行为（如 `execve`、`open`）。\n- **程序行为分析**：在不重新编译程序的情况下，分析第三方闭源程序的执行路径。\n- **热补丁**：结合 livepatch 技术，在用户空间实现运行时修复。",
      "similarity": 0.4739459156990051,
      "chunks": [
        {
          "chunk_id": 15,
          "file_path": "kernel/events/uprobes.c",
          "start_line": 2717,
          "end_line": 2788,
          "content": [
            "static void handle_singlestep(struct uprobe_task *utask, struct pt_regs *regs)",
            "{",
            "\tstruct uprobe *uprobe;",
            "\tint err = 0;",
            "",
            "\tuprobe = utask->active_uprobe;",
            "\tif (utask->state == UTASK_SSTEP_ACK)",
            "\t\terr = arch_uprobe_post_xol(&uprobe->arch, regs);",
            "\telse if (utask->state == UTASK_SSTEP_TRAPPED)",
            "\t\tarch_uprobe_abort_xol(&uprobe->arch, regs);",
            "\telse",
            "\t\tWARN_ON_ONCE(1);",
            "",
            "\tput_uprobe(uprobe);",
            "\tutask->active_uprobe = NULL;",
            "\tutask->state = UTASK_RUNNING;",
            "\txol_free_insn_slot(utask);",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "\trecalc_sigpending(); /* see uprobe_deny_signal() */",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "",
            "\tif (unlikely(err)) {",
            "\t\tuprobe_warn(current, \"execute the probed insn, sending SIGILL.\");",
            "\t\tforce_sig(SIGILL);",
            "\t}",
            "}",
            "void uprobe_notify_resume(struct pt_regs *regs)",
            "{",
            "\tstruct uprobe_task *utask;",
            "",
            "\tclear_thread_flag(TIF_UPROBE);",
            "",
            "\tutask = current->utask;",
            "\tif (utask && utask->active_uprobe)",
            "\t\thandle_singlestep(utask, regs);",
            "\telse",
            "\t\thandle_swbp(regs);",
            "}",
            "int uprobe_pre_sstep_notifier(struct pt_regs *regs)",
            "{",
            "\tif (!current->mm)",
            "\t\treturn 0;",
            "",
            "\tif (!test_bit(MMF_HAS_UPROBES, &current->mm->flags) &&",
            "\t    (!current->utask || !current->utask->return_instances))",
            "\t\treturn 0;",
            "",
            "\tset_thread_flag(TIF_UPROBE);",
            "\treturn 1;",
            "}",
            "int uprobe_post_sstep_notifier(struct pt_regs *regs)",
            "{",
            "\tstruct uprobe_task *utask = current->utask;",
            "",
            "\tif (!current->mm || !utask || !utask->active_uprobe)",
            "\t\t/* task is currently not uprobed */",
            "\t\treturn 0;",
            "",
            "\tutask->state = UTASK_SSTEP_ACK;",
            "\tset_thread_flag(TIF_UPROBE);",
            "\treturn 1;",
            "}",
            "void __init uprobes_init(void)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < UPROBES_HASH_SZ; i++)",
            "\t\tmutex_init(&uprobes_mmap_mutex[i]);",
            "",
            "\tBUG_ON(register_die_notifier(&uprobe_exception_nb));",
            "}"
          ],
          "function_name": "handle_singlestep, uprobe_notify_resume, uprobe_pre_sstep_notifier, uprobe_post_sstep_notifier, uprobes_init",
          "description": "这段代码实现了 uprobes 功能的核心逻辑，用于跟踪和拦截用户空间指令执行。`handle_singlestep` 处理单步执行完成后的行为，如调用架构相关处理函数并释放资源；`uprobe_notify_resume` 在任务恢复时判断是否需触发探针处理，`uprobe_pre_sstep_notifier` 和 `uprobe_post_sstep_notifier` 分别用于标记单步执行前后状态变化；`uprobes_init` 初始化互斥锁并注册异常通知链表节点。",
          "similarity": 0.5007521510124207
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/events/uprobes.c",
          "start_line": 429,
          "end_line": 570,
          "content": [
            "static void update_ref_ctr_warn(struct uprobe *uprobe,",
            "\t\t\t\tstruct mm_struct *mm, short d)",
            "{",
            "\tpr_warn(\"ref_ctr %s failed for inode: 0x%lx offset: \"",
            "\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\",",
            "\t\td > 0 ? \"increment\" : \"decrement\", uprobe->inode->i_ino,",
            "\t\t(unsigned long long) uprobe->offset,",
            "\t\t(unsigned long long) uprobe->ref_ctr_offset, mm);",
            "}",
            "static int update_ref_ctr(struct uprobe *uprobe, struct mm_struct *mm,",
            "\t\t\t  short d)",
            "{",
            "\tstruct vm_area_struct *rc_vma;",
            "\tunsigned long rc_vaddr;",
            "\tint ret = 0;",
            "",
            "\trc_vma = find_ref_ctr_vma(uprobe, mm);",
            "",
            "\tif (rc_vma) {",
            "\t\trc_vaddr = offset_to_vaddr(rc_vma, uprobe->ref_ctr_offset);",
            "\t\tret = __update_ref_ctr(mm, rc_vaddr, d);",
            "\t\tif (ret)",
            "\t\t\tupdate_ref_ctr_warn(uprobe, mm, d);",
            "",
            "\t\tif (d > 0)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\tmutex_lock(&delayed_uprobe_lock);",
            "\tif (d > 0)",
            "\t\tret = delayed_uprobe_add(uprobe, mm);",
            "\telse",
            "\t\tdelayed_uprobe_remove(uprobe, mm);",
            "\tmutex_unlock(&delayed_uprobe_lock);",
            "",
            "\treturn ret;",
            "}",
            "int uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm,",
            "\t\t\tunsigned long vaddr, uprobe_opcode_t opcode)",
            "{",
            "\tstruct uprobe *uprobe;",
            "\tstruct page *old_page, *new_page;",
            "\tstruct vm_area_struct *vma;",
            "\tint ret, is_register, ref_ctr_updated = 0;",
            "\tbool orig_page_huge = false;",
            "\tunsigned int gup_flags = FOLL_FORCE;",
            "",
            "\tis_register = is_swbp_insn(&opcode);",
            "\tuprobe = container_of(auprobe, struct uprobe, arch);",
            "",
            "retry:",
            "\tif (is_register)",
            "\t\tgup_flags |= FOLL_SPLIT_PMD;",
            "\t/* Read the page with vaddr into memory */",
            "\told_page = get_user_page_vma_remote(mm, vaddr, gup_flags, &vma);",
            "\tif (IS_ERR_OR_NULL(old_page))",
            "\t\treturn old_page ? PTR_ERR(old_page) : 0;",
            "",
            "\tret = verify_opcode(old_page, vaddr, &opcode);",
            "\tif (ret <= 0)",
            "\t\tgoto put_old;",
            "",
            "\tif (is_zero_page(old_page)) {",
            "\t\tret = -EINVAL;",
            "\t\tgoto put_old;",
            "\t}",
            "",
            "\tif (WARN(!is_register && PageCompound(old_page),",
            "\t\t \"uprobe unregister should never work on compound page\\n\")) {",
            "\t\tret = -EINVAL;",
            "\t\tgoto put_old;",
            "\t}",
            "",
            "\t/* We are going to replace instruction, update ref_ctr. */",
            "\tif (!ref_ctr_updated && uprobe->ref_ctr_offset) {",
            "\t\tret = update_ref_ctr(uprobe, mm, is_register ? 1 : -1);",
            "\t\tif (ret)",
            "\t\t\tgoto put_old;",
            "",
            "\t\tref_ctr_updated = 1;",
            "\t}",
            "",
            "\tret = 0;",
            "\tif (!is_register && !PageAnon(old_page))",
            "\t\tgoto put_old;",
            "",
            "\tret = anon_vma_prepare(vma);",
            "\tif (ret)",
            "\t\tgoto put_old;",
            "",
            "\tret = -ENOMEM;",
            "\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vaddr);",
            "\tif (!new_page)",
            "\t\tgoto put_old;",
            "",
            "\t__SetPageUptodate(new_page);",
            "\tcopy_highpage(new_page, old_page);",
            "\tcopy_to_page(new_page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);",
            "",
            "\tif (!is_register) {",
            "\t\tstruct page *orig_page;",
            "\t\tpgoff_t index;",
            "",
            "\t\tVM_BUG_ON_PAGE(!PageAnon(old_page), old_page);",
            "",
            "\t\tindex = vaddr_to_offset(vma, vaddr & PAGE_MASK) >> PAGE_SHIFT;",
            "\t\torig_page = find_get_page(vma->vm_file->f_inode->i_mapping,",
            "\t\t\t\t\t  index);",
            "",
            "\t\tif (orig_page) {",
            "\t\t\tif (PageUptodate(orig_page) &&",
            "\t\t\t    pages_identical(new_page, orig_page)) {",
            "\t\t\t\t/* let go new_page */",
            "\t\t\t\tput_page(new_page);",
            "\t\t\t\tnew_page = NULL;",
            "",
            "\t\t\t\tif (PageCompound(orig_page))",
            "\t\t\t\t\torig_page_huge = true;",
            "\t\t\t}",
            "\t\t\tput_page(orig_page);",
            "\t\t}",
            "\t}",
            "",
            "\tret = __replace_page(vma, vaddr & PAGE_MASK, old_page, new_page);",
            "\tif (new_page)",
            "\t\tput_page(new_page);",
            "put_old:",
            "\tput_page(old_page);",
            "",
            "\tif (unlikely(ret == -EAGAIN))",
            "\t\tgoto retry;",
            "",
            "\t/* Revert back reference counter if instruction update failed. */",
            "\tif (ret && is_register && ref_ctr_updated)",
            "\t\tupdate_ref_ctr(uprobe, mm, -1);",
            "",
            "\t/* try collapse pmd for compound page */",
            "\tif (!ret && orig_page_huge)",
            "\t\tcollapse_pte_mapped_thp(mm, vaddr, false);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "update_ref_ctr_warn, update_ref_ctr, uprobe_write_opcode",
          "description": "实现引用计数更新(update_ref_ctr)和指令写入(uprobe_write_opcode)逻辑，包含指令验证(verify_opcode)、页面替换(__replace_page)及异常处理，保证 uprobes 修改操作的正确性。",
          "similarity": 0.4947036802768707
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/events/uprobes.c",
          "start_line": 2020,
          "end_line": 2122,
          "content": [
            "static void ri_timer(struct timer_list *timer)",
            "{",
            "\tstruct uprobe_task *utask = container_of(timer, struct uprobe_task, ri_timer);",
            "\tstruct return_instance *ri;",
            "",
            "\t/* SRCU protects uprobe from reuse for the cmpxchg() inside hprobe_expire(). */",
            "\tguard(srcu)(&uretprobes_srcu);",
            "\t/* RCU protects return_instance from freeing. */",
            "\tguard(rcu)();",
            "",
            "\t/*",
            "\t * See free_ret_instance() for notes on seqcount use.",
            "\t * We also employ raw API variants to avoid lockdep false-positive",
            "\t * warning complaining about enabled preemption. The timer can only be",
            "\t * invoked once for a uprobe_task. Therefore there can only be one",
            "\t * writer. The reader does not require an even sequence count to make",
            "\t * progress, so it is OK to remain preemptible on PREEMPT_RT.",
            "\t */",
            "\traw_write_seqcount_begin(&utask->ri_seqcount);",
            "",
            "\tfor_each_ret_instance_rcu(ri, utask->return_instances)",
            "\t\thprobe_expire(&ri->hprobe, false);",
            "",
            "\traw_write_seqcount_end(&utask->ri_seqcount);",
            "}",
            "static int dup_utask(struct task_struct *t, struct uprobe_task *o_utask)",
            "{",
            "\tstruct uprobe_task *n_utask;",
            "\tstruct return_instance **p, *o, *n;",
            "\tstruct uprobe *uprobe;",
            "",
            "\tn_utask = alloc_utask();",
            "\tif (!n_utask)",
            "\t\treturn -ENOMEM;",
            "\tt->utask = n_utask;",
            "",
            "\t/* protect uprobes from freeing, we'll need try_get_uprobe() them */",
            "\tguard(srcu)(&uretprobes_srcu);",
            "",
            "\tp = &n_utask->return_instances;",
            "\tfor (o = o_utask->return_instances; o; o = o->next) {",
            "\t\tn = dup_return_instance(o);",
            "\t\tif (!n)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\t/* if uprobe is non-NULL, we'll have an extra refcount for uprobe */",
            "\t\tuprobe = hprobe_expire(&o->hprobe, true);",
            "",
            "\t\t/*",
            "\t\t * New utask will have stable properly refcounted uprobe or",
            "\t\t * NULL. Even if we failed to get refcounted uprobe, we still",
            "\t\t * need to preserve full set of return_instances for proper",
            "\t\t * uretprobe handling and nesting in forked task.",
            "\t\t */",
            "\t\thprobe_init_stable(&n->hprobe, uprobe);",
            "",
            "\t\tn->next = NULL;",
            "\t\trcu_assign_pointer(*p, n);",
            "\t\tp = &n->next;",
            "",
            "\t\tn_utask->depth++;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void dup_xol_work(struct callback_head *work)",
            "{",
            "\tif (current->flags & PF_EXITING)",
            "\t\treturn;",
            "",
            "\tif (!__create_xol_area(current->utask->dup_xol_addr) &&",
            "\t\t\t!fatal_signal_pending(current))",
            "\t\tuprobe_warn(current, \"dup xol area\");",
            "}",
            "void uprobe_copy_process(struct task_struct *t, unsigned long flags)",
            "{",
            "\tstruct uprobe_task *utask = current->utask;",
            "\tstruct mm_struct *mm = current->mm;",
            "\tstruct xol_area *area;",
            "",
            "\tt->utask = NULL;",
            "",
            "\tif (!utask || !utask->return_instances)",
            "\t\treturn;",
            "",
            "\tif (mm == t->mm && !(flags & CLONE_VFORK))",
            "\t\treturn;",
            "",
            "\tif (dup_utask(t, utask))",
            "\t\treturn uprobe_warn(t, \"dup ret instances\");",
            "",
            "\t/* The task can fork() after dup_xol_work() fails */",
            "\tarea = mm->uprobes_state.xol_area;",
            "\tif (!area)",
            "\t\treturn uprobe_warn(t, \"dup xol area\");",
            "",
            "\tif (mm == t->mm)",
            "\t\treturn;",
            "",
            "\tt->utask->dup_xol_addr = area->vaddr;",
            "\tinit_task_work(&t->utask->dup_xol_work, dup_xol_work);",
            "\ttask_work_add(t, &t->utask->dup_xol_work, TWA_RESUME);",
            "}"
          ],
          "function_name": "ri_timer, dup_utask, dup_xol_work, uprobe_copy_process",
          "description": "实现返回实例定时器回调，通过SRCU/RCU保护机制处理返回实例过期逻辑；复制uprobe任务结构及其返回实例链表，确保子进程继承父进程的uprobes状态；处理XOL区域复制工作队列，用于fork场景下的XOL区域重建；实现进程级uprobes复制逻辑，处理不同MM空间下的uprobe实例复制需求。",
          "similarity": 0.47579365968704224
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/events/uprobes.c",
          "start_line": 1323,
          "end_line": 1435,
          "content": [
            "void uprobe_unregister_nosync(struct uprobe *uprobe, struct uprobe_consumer *uc)",
            "{",
            "\tint err;",
            "",
            "\tdown_write(&uprobe->register_rwsem);",
            "\tconsumer_del(uprobe, uc);",
            "\terr = register_for_each_vma(uprobe, NULL);",
            "\tup_write(&uprobe->register_rwsem);",
            "",
            "\t/* TODO : cant unregister? schedule a worker thread */",
            "\tif (unlikely(err)) {",
            "\t\tuprobe_warn(current, \"unregister, leaking uprobe\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tput_uprobe(uprobe);",
            "}",
            "void uprobe_unregister_sync(void)",
            "{",
            "\t/*",
            "\t * Now that handler_chain() and handle_uretprobe_chain() iterate over",
            "\t * uprobe->consumers list under RCU protection without holding",
            "\t * uprobe->register_rwsem, we need to wait for RCU grace period to",
            "\t * make sure that we can't call into just unregistered",
            "\t * uprobe_consumer's callbacks anymore. If we don't do that, fast and",
            "\t * unlucky enough caller can free consumer's memory and cause",
            "\t * handler_chain() or handle_uretprobe_chain() to do an use-after-free.",
            "\t */",
            "\tsynchronize_rcu_tasks_trace();",
            "\tsynchronize_srcu(&uretprobes_srcu);",
            "}",
            "int uprobe_apply(struct uprobe *uprobe, struct uprobe_consumer *uc, bool add)",
            "{",
            "\tstruct uprobe_consumer *con;",
            "\tint ret = -ENOENT;",
            "",
            "\tdown_write(&uprobe->register_rwsem);",
            "",
            "\trcu_read_lock_trace();",
            "\tlist_for_each_entry_rcu(con, &uprobe->consumers, cons_node, rcu_read_lock_trace_held()) {",
            "\t\tif (con == uc) {",
            "\t\t\tret = register_for_each_vma(uprobe, add ? uc : NULL);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\trcu_read_unlock_trace();",
            "",
            "\tup_write(&uprobe->register_rwsem);",
            "",
            "\treturn ret;",
            "}",
            "static int unapply_uprobe(struct uprobe *uprobe, struct mm_struct *mm)",
            "{",
            "\tVMA_ITERATOR(vmi, mm, 0);",
            "\tstruct vm_area_struct *vma;",
            "\tint err = 0;",
            "",
            "\tmmap_read_lock(mm);",
            "\tfor_each_vma(vmi, vma) {",
            "\t\tunsigned long vaddr;",
            "\t\tloff_t offset;",
            "",
            "\t\tif (!valid_vma(vma, false) ||",
            "\t\t    file_inode(vma->vm_file) != uprobe->inode)",
            "\t\t\tcontinue;",
            "",
            "\t\toffset = (loff_t)vma->vm_pgoff << PAGE_SHIFT;",
            "\t\tif (uprobe->offset <  offset ||",
            "\t\t    uprobe->offset >= offset + vma->vm_end - vma->vm_start)",
            "\t\t\tcontinue;",
            "",
            "\t\tvaddr = offset_to_vaddr(vma, uprobe->offset);",
            "\t\terr |= remove_breakpoint(uprobe, mm, vaddr);",
            "\t}",
            "\tmmap_read_unlock(mm);",
            "",
            "\treturn err;",
            "}",
            "static void build_probe_list(struct inode *inode,",
            "\t\t\t\tstruct vm_area_struct *vma,",
            "\t\t\t\tunsigned long start, unsigned long end,",
            "\t\t\t\tstruct list_head *head)",
            "{",
            "\tloff_t min, max;",
            "\tstruct rb_node *n, *t;",
            "\tstruct uprobe *u;",
            "",
            "\tINIT_LIST_HEAD(head);",
            "\tmin = vaddr_to_offset(vma, start);",
            "\tmax = min + (end - start) - 1;",
            "",
            "\tread_lock(&uprobes_treelock);",
            "\tn = find_node_in_range(inode, min, max);",
            "\tif (n) {",
            "\t\tfor (t = n; t; t = rb_prev(t)) {",
            "\t\t\tu = rb_entry(t, struct uprobe, rb_node);",
            "\t\t\tif (u->inode != inode || u->offset < min)",
            "\t\t\t\tbreak;",
            "\t\t\t/* if uprobe went away, it's safe to ignore it */",
            "\t\t\tif (try_get_uprobe(u))",
            "\t\t\t\tlist_add(&u->pending_list, head);",
            "\t\t}",
            "\t\tfor (t = n; (t = rb_next(t)); ) {",
            "\t\t\tu = rb_entry(t, struct uprobe, rb_node);",
            "\t\t\tif (u->inode != inode || u->offset > max)",
            "\t\t\t\tbreak;",
            "\t\t\t/* if uprobe went away, it's safe to ignore it */",
            "\t\t\tif (try_get_uprobe(u))",
            "\t\t\t\tlist_add(&u->pending_list, head);",
            "\t\t}",
            "\t}",
            "\tread_unlock(&uprobes_treelock);",
            "}"
          ],
          "function_name": "uprobe_unregister_nosync, uprobe_unregister_sync, uprobe_apply, unapply_uprobe, build_probe_list",
          "description": "uprobe_unregister_nosync/unregister_sync处理探针注销及RCU同步；uprobe_apply控制探针注册/注销；build_probe_list构建待处理探针列表，通过读锁遍历红黑树查找匹配项",
          "similarity": 0.4539334774017334
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/events/uprobes.c",
          "start_line": 1549,
          "end_line": 1657,
          "content": [
            "static int delayed_ref_ctr_inc(struct vm_area_struct *vma)",
            "{",
            "\tstruct list_head *pos, *q;",
            "\tstruct delayed_uprobe *du;",
            "\tunsigned long vaddr;",
            "\tint ret = 0, err = 0;",
            "",
            "\tmutex_lock(&delayed_uprobe_lock);",
            "\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {",
            "\t\tdu = list_entry(pos, struct delayed_uprobe, list);",
            "",
            "\t\tif (du->mm != vma->vm_mm ||",
            "\t\t    !valid_ref_ctr_vma(du->uprobe, vma))",
            "\t\t\tcontinue;",
            "",
            "\t\tvaddr = offset_to_vaddr(vma, du->uprobe->ref_ctr_offset);",
            "\t\tret = __update_ref_ctr(vma->vm_mm, vaddr, 1);",
            "\t\tif (ret) {",
            "\t\t\tupdate_ref_ctr_warn(du->uprobe, vma->vm_mm, 1);",
            "\t\t\tif (!err)",
            "\t\t\t\terr = ret;",
            "\t\t}",
            "\t\tdelayed_uprobe_delete(du);",
            "\t}",
            "\tmutex_unlock(&delayed_uprobe_lock);",
            "\treturn err;",
            "}",
            "int uprobe_mmap(struct vm_area_struct *vma)",
            "{",
            "\tstruct list_head tmp_list;",
            "\tstruct uprobe *uprobe, *u;",
            "\tstruct inode *inode;",
            "",
            "\tif (no_uprobe_events())",
            "\t\treturn 0;",
            "",
            "\tif (vma->vm_file &&",
            "\t    (vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&",
            "\t    test_bit(MMF_HAS_UPROBES, &vma->vm_mm->flags))",
            "\t\tdelayed_ref_ctr_inc(vma);",
            "",
            "\tif (!valid_vma(vma, true))",
            "\t\treturn 0;",
            "",
            "\tinode = file_inode(vma->vm_file);",
            "\tif (!inode)",
            "\t\treturn 0;",
            "",
            "\tmutex_lock(uprobes_mmap_hash(inode));",
            "\tbuild_probe_list(inode, vma, vma->vm_start, vma->vm_end, &tmp_list);",
            "\t/*",
            "\t * We can race with uprobe_unregister(), this uprobe can be already",
            "\t * removed. But in this case filter_chain() must return false, all",
            "\t * consumers have gone away.",
            "\t */",
            "\tlist_for_each_entry_safe(uprobe, u, &tmp_list, pending_list) {",
            "\t\tif (!fatal_signal_pending(current) &&",
            "\t\t    filter_chain(uprobe, vma->vm_mm)) {",
            "\t\t\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->offset);",
            "\t\t\tinstall_breakpoint(uprobe, vma->vm_mm, vma, vaddr);",
            "\t\t}",
            "\t\tput_uprobe(uprobe);",
            "\t}",
            "\tmutex_unlock(uprobes_mmap_hash(inode));",
            "",
            "\treturn 0;",
            "}",
            "static bool",
            "vma_has_uprobes(struct vm_area_struct *vma, unsigned long start, unsigned long end)",
            "{",
            "\tloff_t min, max;",
            "\tstruct inode *inode;",
            "\tstruct rb_node *n;",
            "",
            "\tinode = file_inode(vma->vm_file);",
            "",
            "\tmin = vaddr_to_offset(vma, start);",
            "\tmax = min + (end - start) - 1;",
            "",
            "\tread_lock(&uprobes_treelock);",
            "\tn = find_node_in_range(inode, min, max);",
            "\tread_unlock(&uprobes_treelock);",
            "",
            "\treturn !!n;",
            "}",
            "void uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end)",
            "{",
            "\tif (no_uprobe_events() || !valid_vma(vma, false))",
            "\t\treturn;",
            "",
            "\tif (!atomic_read(&vma->vm_mm->mm_users)) /* called by mmput() ? */",
            "\t\treturn;",
            "",
            "\tif (!test_bit(MMF_HAS_UPROBES, &vma->vm_mm->flags) ||",
            "\t     test_bit(MMF_RECALC_UPROBES, &vma->vm_mm->flags))",
            "\t\treturn;",
            "",
            "\tif (vma_has_uprobes(vma, start, end))",
            "\t\tset_bit(MMF_RECALC_UPROBES, &vma->vm_mm->flags);",
            "}",
            "static vm_fault_t xol_fault(const struct vm_special_mapping *sm,",
            "\t\t\t    struct vm_area_struct *vma, struct vm_fault *vmf)",
            "{",
            "\tstruct xol_area *area = vma->vm_mm->uprobes_state.xol_area;",
            "",
            "\tvmf->page = area->page;",
            "\tget_page(vmf->page);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "delayed_ref_ctr_inc, uprobe_mmap, vma_has_uprobes, uprobe_munmap, xol_fault",
          "description": "delayed_ref_ctr_inc更新引用计数器；uprobe_mmap在地址映射时检测并安装断点；vma_has_uprobes查询VMA范围内的探针存在性；uprobe_munmap标记需重新计算的MM标志位；xol_fault处理特殊映射页访问",
          "similarity": 0.4534316658973694
        }
      ]
    }
  ]
}