{
  "query": "Linux中线程的task_struct结构",
  "timestamp": "2025-12-26 00:46:42",
  "retrieved_files": [
    {
      "source_file": "kernel/workqueue_internal.h",
      "md_summary": "> 自动生成时间: 2025-10-25 17:54:04\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `workqueue_internal.h`\n\n---\n\n# `workqueue_internal.h` 技术文档\n\n## 1. 文件概述\n\n`workqueue_internal.h` 是 Linux 内核工作队列（workqueue）子系统的内部头文件，仅限工作队列核心代码及内核关键子系统（如 `async` 和调度器）包含使用。该文件定义了工作队列内部使用的 `struct worker` 数据结构，并声明了调度器与工作队列交互所需的钩子函数。其主要作用是封装工作线程（worker）的内部状态和行为，为并发管理型工作队列（Concurrency Managed Workqueue, CMWQ）提供底层支持。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct worker`**  \n  表示一个工作队列的工作线程（worker），包含其运行状态、当前处理的工作项、所属线程池、调度信息等。关键字段包括：\n  - `entry` / `hentry`：联合体，用于在空闲时挂入空闲链表，繁忙时挂入哈希表。\n  - `current_work` / `current_func`：当前正在执行的工作项及其回调函数。\n  - `current_pwq`：当前工作项所属的 `pool_workqueue`。\n  - `sleeping`：标识该 worker 是否处于睡眠状态。\n  - `scheduled`：已调度但尚未执行的工作项链表。\n  - `task`：对应的内核线程（kthread）任务结构。\n  - `pool`：所属的 `worker_pool`。\n  - `flags` / `id`：worker 的标志位和唯一标识。\n  - `desc`：用于调试的描述字符串（通过 `work_set_desc()` 设置）。\n  - `rescue_wq`：仅用于 rescuer worker，指向需要被救援的工作队列。\n\n- **内联函数**\n  - **`current_wq_worker()`**：判断当前执行上下文是否为工作队列 worker 线程。若是，则返回对应的 `struct worker` 指针；否则返回 `NULL`。通过检查 `current->flags & PF_WQ_WORKER` 并调用 `kthread_data()` 实现。\n\n### 函数声明（调度器钩子）\n\n- **`wq_worker_running(struct task_struct *task)`**  \n  通知工作队列子系统：指定 worker 线程已开始运行。\n\n- **`wq_worker_sleeping(struct task_struct *task)`**  \n  通知工作队列子系统：指定 worker 线程即将进入睡眠状态。\n\n- **`wq_worker_tick(struct task_struct *task)`**  \n  由调度器周期性调用，用于更新 worker 的运行时统计信息（如 CPU 时间）。\n\n- **`wq_worker_last_func(struct task_struct *task)`**  \n  返回指定 worker 线程最近执行的工作函数指针，供调度器或调试使用。\n\n## 3. 关键实现\n\n- **Worker 状态管理**  \n  `struct worker` 使用联合体 `entry/hentry` 实现状态复用：空闲时通过 `entry` 挂入 `worker_pool` 的空闲链表；执行工作时通过 `hentry` 挂入 busy 哈希表，便于快速查找和管理。\n\n- **并发管理支持**  \n  通过 `sleeping` 字段和调度器钩子函数（如 `wq_worker_sleeping`/`wq_worker_running`），工作队列子系统可精确跟踪 worker 的运行状态，从而动态调整线程池大小，实现高效的并发控制。\n\n- **调试支持**  \n  `desc` 字段允许通过 `work_set_desc()` 为工作项设置可读描述，在内核崩溃（WARN/BUG/panic）或 SysRq 调试时输出，便于定位问题。\n\n- **Rescuer 机制**  \n  `rescue_wq` 字段专用于 rescuer worker（用于处理内存压力下无法创建新 worker 的紧急情况），指向需要被“救援”的工作队列。\n\n- **锁注释约定**  \n  结构体字段注释中的字母（如 `L`, `K`, `I`, `A`, `S`）表示访问该字段所需的锁或上下文，具体含义需参考 `workqueue.c` 中的说明（例如 `L` 表示 pool->lock，`K` 表示需要关闭内核抢占等）。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/workqueue.h>`：提供工作队列公共接口和基础类型（如 `work_struct`、`work_func_t`）。\n  - `<linux/kthread.h>`：提供内核线程相关功能（如 `kthread_data()`）。\n  - `<linux/preempt.h>`：用于内核抢占控制。\n\n- **模块依赖**：\n  - **`workqueue.c`**：工作队列核心实现，定义了 `struct worker` 的操作逻辑。\n  - **`kernel/async.c`**：异步初始化框架，使用内部 worker 结构。\n  - **`kernel/sched/`**：调度器子系统，调用 `wq_worker_*` 钩子函数以集成工作队列状态管理。\n\n## 5. 使用场景\n\n- **工作队列执行路径**  \n  当工作项被调度执行时，内核从 `worker_pool` 中唤醒或创建 `worker`，通过 `current_wq_worker()` 获取当前上下文的 worker 结构，并更新其状态字段（如 `current_work`、`last_func`）。\n\n- **调度器集成**  \n  调度器在 worker 线程状态切换（运行/睡眠）或时钟滴答（tick）时调用相应钩子，使工作队列子系统能动态管理线程池并发度。\n\n- **内存压力恢复**  \n  在内存紧张无法创建新 worker 时，rescuer worker 被激活，通过 `rescue_wq` 字段处理阻塞的工作队列。\n\n- **内核调试与诊断**  \n  在系统崩溃或通过 SysRq 触发任务转储时，`desc` 字段提供工作项的语义信息，辅助开发者分析死锁或性能问题。",
      "similarity": 0.6418561935424805,
      "chunks": []
    },
    {
      "source_file": "kernel/taskstats.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:34:26\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `taskstats.c`\n\n---\n\n# taskstats.c 技术文档\n\n## 1. 文件概述\n\n`taskstats.c` 是 Linux 内核中用于向用户空间导出每个任务（task）统计信息的核心实现文件。该模块通过通用 Netlink（Generic Netlink, genetlink）接口，提供对进程和线程组（TGID）的详细资源使用统计，包括 CPU 时间、上下文切换、延迟会计（delay accounting）、扩展会计（extended accounting）以及可执行文件元数据等。此外，还支持基于 CPU 掩码的监听器注册机制，允许用户空间程序订阅特定 CPU 上任务退出时的统计信息。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct listener`**：表示一个注册的监听器，包含 PID 和有效性标志。\n- **`struct listener_list`**：每个 CPU 上的监听器链表，受读写信号量保护。\n- **`taskstats_cache`**：用于分配 `struct taskstats` 的 slab 缓存。\n- **`family`**：Generic Netlink 通信家族实例。\n\n### 主要函数\n\n- **`prepare_reply()`**：为 Generic Netlink 消息准备回复缓冲区。\n- **`send_reply()`**：向请求者发送单播回复。\n- **`send_cpu_listeners()`**：向注册在特定 CPU 上的所有监听器广播任务统计信息。\n- **`fill_stats()`**：填充单个任务的完整统计信息。\n- **`fill_stats_for_pid()`**：根据 PID 填充对应任务的统计。\n- **`fill_stats_for_tgid()`**：聚合线程组内所有活跃线程的统计信息。\n- **`fill_tgid_exit()`**：在线程退出时，将其统计累加到所属线程组的汇总结构中。\n- **`add_del_listener()`**：注册或注销监听特定 CPU 任务退出事件的用户空间进程。\n- **`exe_add_tsk()`**：提取任务可执行文件的设备号和 inode 号。\n\n### Netlink 策略定义\n\n- `taskstats_cmd_get_policy[]`：定义 `TASKSTATS_CMD_ATTR_*` 属性的解析规则。\n- `cgroupstats_cmd_get_policy[]`：定义 `CGROUPSTATS_CMD_ATTR_FD` 属性的解析规则。\n\n## 3. 关键实现\n\n### 统计信息聚合机制\n\n- **单任务统计**：通过 `fill_stats()` 调用多个子系统（如 `delayacct_add_tsk`、`bacct_add_tsk`、`xacct_add_tsk`）分别填充延迟、基础会计、扩展会计等字段。\n- **线程组统计**：`fill_stats_for_tgid()` 遍历线程组内所有非退出线程，累加 CPU 时间、上下文切换次数，并计算运行时长（`ac_etime`）。\n- **退出时聚合**：当线程退出时，`fill_tgid_exit()` 将其统计信息累加到 `task_struct->signal->stats` 中，供后续查询使用。\n\n### 监听器管理\n\n- 每个 CPU 维护一个独立的 `listener_list`，使用 per-CPU 变量 `listener_array` 存储。\n- 监听器通过 `add_del_listener()` 注册/注销，仅允许在初始用户命名空间和 PID 命名空间中操作。\n- 发送消息时采用“克隆 skb”策略：除最后一个监听器外，其余均使用 `skb_clone()` 保证每个接收者获得独立副本。\n- 自动清理无效监听器：若 `genlmsg_unicast()` 返回 `-ECONNREFUSED`，标记该监听器无效，并在后续批量删除。\n\n### 安全与命名空间限制\n\n- 仅允许 `init_user_ns` 和 `init_pid_ns` 中的进程注册监听器，防止容器内进程干扰全局统计。\n- 对注册的 CPU 掩码进行合法性校验（必须是 `cpu_possible_mask` 的子集）。\n\n### 内存与并发控制\n\n- 使用 `rw_semaphore` 保护监听器链表，读操作（发送）并发，写操作（增删）互斥。\n- `taskstats_seqnum` 为 per-CPU 序列号，用于无请求上下文时的消息标识。\n- 所有动态分配均考虑 NUMA 节点亲和性（`kmalloc_node`）。\n\n## 4. 依赖关系\n\n- **Generic Netlink (`<net/genetlink.h>`)**：提供用户空间通信通道。\n- **延迟会计 (`<linux/delayacct.h>`)**：提供 I/O、调度等延迟统计。\n- **进程会计 (`<linux/acct.h>`, `<linux/tsacct_kern.h>`)**：提供基础和扩展会计信息。\n- **CGroup 统计 (`<linux/cgroupstats.h>`)**：虽未在截断代码中完整体现，但头文件包含表明支持 cgroup 级别统计。\n- **调度与任务管理 (`<linux/sched/cputime.h>`, `<linux/pid_namespace.h>`)**：获取任务 CPU 时间、PID 命名空间信息。\n- **内存管理 (`<linux/slab.h>`, `<linux/percpu.h>`)**：slab 缓存和 per-CPU 数据结构支持。\n\n## 5. 使用场景\n\n- **性能分析工具**：如 `pidstat`、`perf` 等可通过 taskstats 获取高精度任务资源使用数据。\n- **资源监控系统**：实时收集进程 CPU、上下文切换、延迟等指标，用于系统调优或异常检测。\n- **作业调度器**：根据历史任务统计信息优化任务放置策略。\n- **容器运行时**：虽受限于命名空间，但宿主机监控工具可利用此接口获取容器内进程统计（需通过宿主机 PID）。\n- **内核调试**：开发人员可通过监听任务退出事件，分析进程生命周期行为。",
      "similarity": 0.6198862195014954,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/taskstats.c",
          "start_line": 690,
          "end_line": 711,
          "content": [
            "void __init taskstats_init_early(void)",
            "{",
            "\tunsigned int i;",
            "",
            "\ttaskstats_cache = KMEM_CACHE(taskstats, SLAB_PANIC);",
            "\tfor_each_possible_cpu(i) {",
            "\t\tINIT_LIST_HEAD(&(per_cpu(listener_array, i).list));",
            "\t\tinit_rwsem(&(per_cpu(listener_array, i).sem));",
            "\t}",
            "}",
            "static int __init taskstats_init(void)",
            "{",
            "\tint rc;",
            "",
            "\trc = genl_register_family(&family);",
            "\tif (rc)",
            "\t\treturn rc;",
            "",
            "\tfamily_registered = 1;",
            "\tpr_info(\"registered taskstats version %d\\n\", TASKSTATS_GENL_VERSION);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "taskstats_init_early, taskstats_init",
          "description": "该代码段实现了任务统计模块的初始化逻辑，包含两个关键函数：  \n1. `taskstats_init_early` 初始化任务统计缓存及CPU本地监听器数据结构，用于多核环境下的同步与资源管理；  \n2. `taskstats_init` 注册GENL（Generic Netlink）家族以启用任务统计的网络接口通信。",
          "similarity": 0.5899686813354492
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/taskstats.c",
          "start_line": 201,
          "end_line": 350,
          "content": [
            "static int fill_stats_for_pid(pid_t pid, struct taskstats *stats)",
            "{",
            "\tstruct task_struct *tsk;",
            "",
            "\ttsk = find_get_task_by_vpid(pid);",
            "\tif (!tsk)",
            "\t\treturn -ESRCH;",
            "\tfill_stats(current_user_ns(), task_active_pid_ns(current), tsk, stats);",
            "\tput_task_struct(tsk);",
            "\treturn 0;",
            "}",
            "static int fill_stats_for_tgid(pid_t tgid, struct taskstats *stats)",
            "{",
            "\tstruct task_struct *tsk, *first;",
            "\tunsigned long flags;",
            "\tint rc = -ESRCH;",
            "\tu64 delta, utime, stime;",
            "\tu64 start_time;",
            "",
            "\t/*",
            "\t * Add additional stats from live tasks except zombie thread group",
            "\t * leaders who are already counted with the dead tasks",
            "\t */",
            "\trcu_read_lock();",
            "\tfirst = find_task_by_vpid(tgid);",
            "",
            "\tif (!first || !lock_task_sighand(first, &flags))",
            "\t\tgoto out;",
            "",
            "\tif (first->signal->stats)",
            "\t\tmemcpy(stats, first->signal->stats, sizeof(*stats));",
            "\telse",
            "\t\tmemset(stats, 0, sizeof(*stats));",
            "",
            "\ttsk = first;",
            "\tstart_time = ktime_get_ns();",
            "\tdo {",
            "\t\tif (tsk->exit_state)",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * Accounting subsystem can call its functions here to",
            "\t\t * fill in relevant parts of struct taskstsats as follows",
            "\t\t *",
            "\t\t *\tper-task-foo(stats, tsk);",
            "\t\t */",
            "\t\tdelayacct_add_tsk(stats, tsk);",
            "",
            "\t\t/* calculate task elapsed time in nsec */",
            "\t\tdelta = start_time - tsk->start_time;",
            "\t\t/* Convert to micro seconds */",
            "\t\tdo_div(delta, NSEC_PER_USEC);",
            "\t\tstats->ac_etime += delta;",
            "",
            "\t\ttask_cputime(tsk, &utime, &stime);",
            "\t\tstats->ac_utime += div_u64(utime, NSEC_PER_USEC);",
            "\t\tstats->ac_stime += div_u64(stime, NSEC_PER_USEC);",
            "",
            "\t\tstats->nvcsw += tsk->nvcsw;",
            "\t\tstats->nivcsw += tsk->nivcsw;",
            "\t} while_each_thread(first, tsk);",
            "",
            "\tunlock_task_sighand(first, &flags);",
            "\trc = 0;",
            "out:",
            "\trcu_read_unlock();",
            "",
            "\tstats->version = TASKSTATS_VERSION;",
            "\t/*",
            "\t * Accounting subsystems can also add calls here to modify",
            "\t * fields of taskstats.",
            "\t */",
            "\treturn rc;",
            "}",
            "static void fill_tgid_exit(struct task_struct *tsk)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&tsk->sighand->siglock, flags);",
            "\tif (!tsk->signal->stats)",
            "\t\tgoto ret;",
            "",
            "\t/*",
            "\t * Each accounting subsystem calls its functions here to",
            "\t * accumalate its per-task stats for tsk, into the per-tgid structure",
            "\t *",
            "\t *\tper-task-foo(tsk->signal->stats, tsk);",
            "\t */",
            "\tdelayacct_add_tsk(tsk->signal->stats, tsk);",
            "ret:",
            "\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);",
            "\treturn;",
            "}",
            "static int add_del_listener(pid_t pid, const struct cpumask *mask, int isadd)",
            "{",
            "\tstruct listener_list *listeners;",
            "\tstruct listener *s, *tmp, *s2;",
            "\tunsigned int cpu;",
            "\tint ret = 0;",
            "",
            "\tif (!cpumask_subset(mask, cpu_possible_mask))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (current_user_ns() != &init_user_ns)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (task_active_pid_ns(current) != &init_pid_ns)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (isadd == REGISTER) {",
            "\t\tfor_each_cpu(cpu, mask) {",
            "\t\t\ts = kmalloc_node(sizeof(struct listener),",
            "\t\t\t\t\tGFP_KERNEL, cpu_to_node(cpu));",
            "\t\t\tif (!s) {",
            "\t\t\t\tret = -ENOMEM;",
            "\t\t\t\tgoto cleanup;",
            "\t\t\t}",
            "\t\t\ts->pid = pid;",
            "\t\t\ts->valid = 1;",
            "",
            "\t\t\tlisteners = &per_cpu(listener_array, cpu);",
            "\t\t\tdown_write(&listeners->sem);",
            "\t\t\tlist_for_each_entry(s2, &listeners->list, list) {",
            "\t\t\t\tif (s2->pid == pid && s2->valid)",
            "\t\t\t\t\tgoto exists;",
            "\t\t\t}",
            "\t\t\tlist_add(&s->list, &listeners->list);",
            "\t\t\ts = NULL;",
            "exists:",
            "\t\t\tup_write(&listeners->sem);",
            "\t\t\tkfree(s); /* nop if NULL */",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/* Deregister or cleanup */",
            "cleanup:",
            "\tfor_each_cpu(cpu, mask) {",
            "\t\tlisteners = &per_cpu(listener_array, cpu);",
            "\t\tdown_write(&listeners->sem);",
            "\t\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {",
            "\t\t\tif (s->pid == pid) {",
            "\t\t\t\tlist_del(&s->list);",
            "\t\t\t\tkfree(s);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tup_write(&listeners->sem);",
            "\t}",
            "\treturn ret;",
            "}"
          ],
          "function_name": "fill_stats_for_pid, fill_stats_for_tgid, fill_tgid_exit, add_del_listener",
          "description": "提供基于PID/TGID的任务统计查询接口，fill_stats_for_pid/tgid收集单个/整个线程组的统计信息，fill_tgid_exit处理进程组退出时的统计更新，add_del_listener管理跨CPU的监听器注册/注销。",
          "similarity": 0.588207483291626
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/taskstats.c",
          "start_line": 1,
          "end_line": 65,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * taskstats.c - Export per-task statistics to userland",
            " *",
            " * Copyright (C) Shailabh Nagar, IBM Corp. 2006",
            " *           (C) Balbir Singh,   IBM Corp. 2006",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/pid_namespace.h>",
            "#include <net/genetlink.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/cputime.h>",
            "",
            "/*",
            " * Maximum length of a cpumask that can be specified in",
            " * the TASKSTATS_CMD_ATTR_REGISTER/DEREGISTER_CPUMASK attribute",
            " */",
            "#define TASKSTATS_CPUMASK_MAXLEN\t(100+6*NR_CPUS)",
            "",
            "static DEFINE_PER_CPU(__u32, taskstats_seqnum);",
            "static int family_registered;",
            "struct kmem_cache *taskstats_cache;",
            "",
            "static struct genl_family family;",
            "",
            "static const struct nla_policy taskstats_cmd_get_policy[] = {",
            "\t[TASKSTATS_CMD_ATTR_PID]  = { .type = NLA_U32 },",
            "\t[TASKSTATS_CMD_ATTR_TGID] = { .type = NLA_U32 },",
            "\t[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK] = { .type = NLA_STRING },",
            "\t[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK] = { .type = NLA_STRING },};",
            "",
            "static const struct nla_policy cgroupstats_cmd_get_policy[] = {",
            "\t[CGROUPSTATS_CMD_ATTR_FD] = { .type = NLA_U32 },",
            "};",
            "",
            "struct listener {",
            "\tstruct list_head list;",
            "\tpid_t pid;",
            "\tchar valid;",
            "};",
            "",
            "struct listener_list {",
            "\tstruct rw_semaphore sem;",
            "\tstruct list_head list;",
            "};",
            "static DEFINE_PER_CPU(struct listener_list, listener_array);",
            "",
            "enum actions {",
            "\tREGISTER,",
            "\tDEREGISTER,",
            "\tCPU_DONT_CARE",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义TASKSTATS模块的GENL协议族及其属性策略，初始化用于任务统计的内核结构体和全局变量，支持通过Netlink接口导出任务统计信息。",
          "similarity": 0.5682528018951416
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/taskstats.c",
          "start_line": 66,
          "end_line": 189,
          "content": [
            "static int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,",
            "\t\t\t\tsize_t size)",
            "{",
            "\tstruct sk_buff *skb;",
            "\tvoid *reply;",
            "",
            "\t/*",
            "\t * If new attributes are added, please revisit this allocation",
            "\t */",
            "\tskb = genlmsg_new(size, GFP_KERNEL);",
            "\tif (!skb)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (!info) {",
            "\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;",
            "",
            "\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);",
            "\t} else",
            "\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);",
            "\tif (reply == NULL) {",
            "\t\tnlmsg_free(skb);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t*skbp = skb;",
            "\treturn 0;",
            "}",
            "static int send_reply(struct sk_buff *skb, struct genl_info *info)",
            "{",
            "\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));",
            "\tvoid *reply = genlmsg_data(genlhdr);",
            "",
            "\tgenlmsg_end(skb, reply);",
            "",
            "\treturn genlmsg_reply(skb, info);",
            "}",
            "static void send_cpu_listeners(struct sk_buff *skb,",
            "\t\t\t\t\tstruct listener_list *listeners)",
            "{",
            "\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));",
            "\tstruct listener *s, *tmp;",
            "\tstruct sk_buff *skb_next, *skb_cur = skb;",
            "\tvoid *reply = genlmsg_data(genlhdr);",
            "\tint delcount = 0;",
            "",
            "\tgenlmsg_end(skb, reply);",
            "",
            "\tdown_read(&listeners->sem);",
            "\tlist_for_each_entry(s, &listeners->list, list) {",
            "\t\tint rc;",
            "",
            "\t\tskb_next = NULL;",
            "\t\tif (!list_is_last(&s->list, &listeners->list)) {",
            "\t\t\tskb_next = skb_clone(skb_cur, GFP_KERNEL);",
            "\t\t\tif (!skb_next)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\trc = genlmsg_unicast(&init_net, skb_cur, s->pid);",
            "\t\tif (rc == -ECONNREFUSED) {",
            "\t\t\ts->valid = 0;",
            "\t\t\tdelcount++;",
            "\t\t}",
            "\t\tskb_cur = skb_next;",
            "\t}",
            "\tup_read(&listeners->sem);",
            "",
            "\tif (skb_cur)",
            "\t\tnlmsg_free(skb_cur);",
            "",
            "\tif (!delcount)",
            "\t\treturn;",
            "",
            "\t/* Delete invalidated entries */",
            "\tdown_write(&listeners->sem);",
            "\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {",
            "\t\tif (!s->valid) {",
            "\t\t\tlist_del(&s->list);",
            "\t\t\tkfree(s);",
            "\t\t}",
            "\t}",
            "\tup_write(&listeners->sem);",
            "}",
            "static void exe_add_tsk(struct taskstats *stats, struct task_struct *tsk)",
            "{",
            "\t/* No idea if I'm allowed to access that here, now. */",
            "\tstruct file *exe_file = get_task_exe_file(tsk);",
            "",
            "\tif (exe_file) {",
            "\t\t/* Following cp_new_stat64() in stat.c . */",
            "\t\tstats->ac_exe_dev =",
            "\t\t\thuge_encode_dev(exe_file->f_inode->i_sb->s_dev);",
            "\t\tstats->ac_exe_inode = exe_file->f_inode->i_ino;",
            "\t\tfput(exe_file);",
            "\t} else {",
            "\t\tstats->ac_exe_dev = 0;",
            "\t\tstats->ac_exe_inode = 0;",
            "\t}",
            "}",
            "static void fill_stats(struct user_namespace *user_ns,",
            "\t\t       struct pid_namespace *pid_ns,",
            "\t\t       struct task_struct *tsk, struct taskstats *stats)",
            "{",
            "\tmemset(stats, 0, sizeof(*stats));",
            "\t/*",
            "\t * Each accounting subsystem adds calls to its functions to",
            "\t * fill in relevant parts of struct taskstsats as follows",
            "\t *",
            "\t *\tper-task-foo(stats, tsk);",
            "\t */",
            "",
            "\tdelayacct_add_tsk(stats, tsk);",
            "",
            "\t/* fill in basic acct fields */",
            "\tstats->version = TASKSTATS_VERSION;",
            "\tstats->nvcsw = tsk->nvcsw;",
            "\tstats->nivcsw = tsk->nivcsw;",
            "\tbacct_add_tsk(user_ns, pid_ns, stats, tsk);",
            "",
            "\t/* fill in extended acct fields */",
            "\txacct_add_tsk(stats, tsk);",
            "",
            "\t/* add executable info */",
            "\texe_add_tsk(stats, tsk);",
            "}"
          ],
          "function_name": "prepare_reply, send_reply, send_cpu_listeners, exe_add_tsk, fill_stats",
          "description": "实现任务统计数据封装与分发逻辑，prepare_reply构造响应报文，send_reply发送响应，send_cpu_listeners向指定CPU的监听者广播数据，fill_stats填充任务核心统计字段。",
          "similarity": 0.5682078003883362
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/taskstats.c",
          "start_line": 494,
          "end_line": 623,
          "content": [
            "static int cmd_attr_pid(struct genl_info *info)",
            "{",
            "\tstruct taskstats *stats;",
            "\tstruct sk_buff *rep_skb;",
            "\tsize_t size;",
            "\tu32 pid;",
            "\tint rc;",
            "",
            "\tsize = taskstats_packet_size();",
            "",
            "\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);",
            "\tif (rc < 0)",
            "\t\treturn rc;",
            "",
            "\trc = -EINVAL;",
            "\tpid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_PID]);",
            "\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID, pid);",
            "\tif (!stats)",
            "\t\tgoto err;",
            "",
            "\trc = fill_stats_for_pid(pid, stats);",
            "\tif (rc < 0)",
            "\t\tgoto err;",
            "\treturn send_reply(rep_skb, info);",
            "err:",
            "\tnlmsg_free(rep_skb);",
            "\treturn rc;",
            "}",
            "static int cmd_attr_tgid(struct genl_info *info)",
            "{",
            "\tstruct taskstats *stats;",
            "\tstruct sk_buff *rep_skb;",
            "\tsize_t size;",
            "\tu32 tgid;",
            "\tint rc;",
            "",
            "\tsize = taskstats_packet_size();",
            "",
            "\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);",
            "\tif (rc < 0)",
            "\t\treturn rc;",
            "",
            "\trc = -EINVAL;",
            "\ttgid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_TGID]);",
            "\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID, tgid);",
            "\tif (!stats)",
            "\t\tgoto err;",
            "",
            "\trc = fill_stats_for_tgid(tgid, stats);",
            "\tif (rc < 0)",
            "\t\tgoto err;",
            "\treturn send_reply(rep_skb, info);",
            "err:",
            "\tnlmsg_free(rep_skb);",
            "\treturn rc;",
            "}",
            "static int taskstats_user_cmd(struct sk_buff *skb, struct genl_info *info)",
            "{",
            "\tif (info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK])",
            "\t\treturn cmd_attr_register_cpumask(info);",
            "\telse if (info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK])",
            "\t\treturn cmd_attr_deregister_cpumask(info);",
            "\telse if (info->attrs[TASKSTATS_CMD_ATTR_PID])",
            "\t\treturn cmd_attr_pid(info);",
            "\telse if (info->attrs[TASKSTATS_CMD_ATTR_TGID])",
            "\t\treturn cmd_attr_tgid(info);",
            "\telse",
            "\t\treturn -EINVAL;",
            "}",
            "void taskstats_exit(struct task_struct *tsk, int group_dead)",
            "{",
            "\tint rc;",
            "\tstruct listener_list *listeners;",
            "\tstruct taskstats *stats;",
            "\tstruct sk_buff *rep_skb;",
            "\tsize_t size;",
            "\tint is_thread_group;",
            "",
            "\tif (!family_registered)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Size includes space for nested attributes",
            "\t */",
            "\tsize = taskstats_packet_size();",
            "",
            "\tis_thread_group = !!taskstats_tgid_alloc(tsk);",
            "\tif (is_thread_group) {",
            "\t\t/* PID + STATS + TGID + STATS */",
            "\t\tsize = 2 * size;",
            "\t\t/* fill the tsk->signal->stats structure */",
            "\t\tfill_tgid_exit(tsk);",
            "\t}",
            "",
            "\tlisteners = raw_cpu_ptr(&listener_array);",
            "\tif (list_empty(&listeners->list))",
            "\t\treturn;",
            "",
            "\trc = prepare_reply(NULL, TASKSTATS_CMD_NEW, &rep_skb, size);",
            "\tif (rc < 0)",
            "\t\treturn;",
            "",
            "\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID,",
            "\t\t\t task_pid_nr_ns(tsk, &init_pid_ns));",
            "\tif (!stats)",
            "\t\tgoto err;",
            "",
            "\tfill_stats(&init_user_ns, &init_pid_ns, tsk, stats);",
            "\tif (group_dead)",
            "\t\tstats->ac_flag |= AGROUP;",
            "",
            "\t/*",
            "\t * Doesn't matter if tsk is the leader or the last group member leaving",
            "\t */",
            "\tif (!is_thread_group || !group_dead)",
            "\t\tgoto send;",
            "",
            "\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID,",
            "\t\t\t task_tgid_nr_ns(tsk, &init_pid_ns));",
            "\tif (!stats)",
            "\t\tgoto err;",
            "",
            "\tmemcpy(stats, tsk->signal->stats, sizeof(*stats));",
            "",
            "send:",
            "\tsend_cpu_listeners(rep_skb, listeners);",
            "\treturn;",
            "err:",
            "\tnlmsg_free(rep_skb);",
            "}"
          ],
          "function_name": "cmd_attr_pid, cmd_attr_tgid, taskstats_user_cmd, taskstats_exit",
          "description": "处理TASKSTATS用户命令的主入口，cmd_attr_pid/tgid分别根据PID/TGID获取统计信息，taskstats_exit在任务终止时触发统计信息广播到所有已注册的监听器。",
          "similarity": 0.5585528016090393
        }
      ]
    },
    {
      "source_file": "kernel/workqueue.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:53:20\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `workqueue.c`\n\n---\n\n# workqueue.c 技术文档\n\n## 1. 文件概述\n\n`workqueue.c` 是 Linux 内核中实现通用异步执行机制的核心文件，提供基于共享工作线程池（worker pool）的延迟任务调度功能。工作项（work items）在进程上下文中执行，支持 CPU 绑定和非绑定两种模式。每个 CPU 默认拥有两个标准工作池（普通优先级和高优先级），同时支持动态创建非绑定工作池以满足不同工作队列的需求。该机制替代了早期的 taskqueue/keventd 实现，具有更高的可扩展性和资源利用率。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct worker_pool`**  \n  工作线程池结构体，管理一组工作线程（workers），包含：\n  - `lock`：保护池状态的自旋锁\n  - `cpu` / `node`：关联的 CPU 和 NUMA 节点（绑定池）\n  - `worklist`：待处理工作项队列\n  - `idle_list` / `busy_hash`：空闲和忙碌工作线程的管理结构\n  - `nr_workers` / `nr_idle`：工作线程数量统计\n  - `attrs`：工作线程属性（如优先级、CPU 亲和性）\n  - `mayday_timer`：紧急情况下的救援请求定时器\n\n- **`struct pool_workqueue`**  \n  工作队列与工作池之间的关联结构，每个工作队列在每个池中都有一个对应的 `pool_workqueue` 实例，用于：\n  - 管理工作项的入队和执行\n  - 实现 `max_active` 限制（控制并发执行数）\n  - 支持 flush 操作（等待所有工作完成）\n  - 统计性能指标（如启动/完成次数、CPU 时间等）\n\n- **`struct worker`**（定义在 `workqueue_internal.h`）  \n  工作线程的运行时上下文，包含状态标志（如 `WORKER_IDLE`, `WORKER_UNBOUND`）、当前执行的工作项等。\n\n### 关键枚举与常量\n\n- **池/工作线程标志**：\n  - `POOL_DISASSOCIATED`：CPU 离线时池进入非绑定状态\n  - `WORKER_UNBOUND`：工作线程可在任意 CPU 上运行\n  - `WORKER_CPU_INTENSIVE`：标记 CPU 密集型任务，影响并发控制\n\n- **配置参数**：\n  - `NR_STD_WORKER_POOLS = 2`：每 CPU 标准池数量（普通 + 高优先级）\n  - `IDLE_WORKER_TIMEOUT = 300 * HZ`：空闲线程保留时间（5 分钟）\n  - `MAYDAY_INITIAL_TIMEOUT`：工作积压时触发救援的延迟（10ms）\n\n- **统计指标**（`pool_workqueue_stats`）：\n  - `PWQ_STAT_STARTED` / `PWQ_STAT_COMPLETED`：工作项执行统计\n  - `PWQ_STAT_MAYDAY` / `PWQ_STAT_RESCUED`：紧急救援事件计数\n\n## 3. 关键实现\n\n### 工作池管理\n- **绑定池（Bound Pool）**：与特定 CPU 关联，工作线程默认绑定到该 CPU。当 CPU 离线时，池进入 `DISASSOCIATED` 状态，工作线程转为非绑定模式。\n- **非绑定池（Unbound Pool）**：动态创建，通过哈希表（`unbound_pool_hash`）按属性（`workqueue_attrs`）去重，支持跨 CPU 调度。\n- **并发控制**：通过 `nr_running` 计数器和 `max_active` 限制，防止工作项过度并发执行。\n\n### 工作线程生命周期\n- **空闲管理**：空闲线程加入 `idle_list`，超时（`IDLE_WORKER_TIMEOUT`）后被回收。\n- **动态伸缩**：当工作积压时，通过 `mayday_timer` 触发新线程创建；若创建失败，向全局救援线程（rescuer）求助。\n- **状态标志**：使用位标志（如 `WORKER_IDLE`, `WORKER_PREP`）高效管理线程状态，避免锁竞争。\n\n### 内存与同步\n- **RCU 保护**：工作池销毁通过 RCU 延迟释放，确保 `get_work_pool()` 等读取路径无锁安全。\n- **锁分层**：\n  - `pool->lock`（自旋锁）：保护池内部状态\n  - `wq_pool_mutex`：全局池管理互斥锁\n  - `wq_pool_attach_mutex`：防止 CPU 绑定状态变更冲突\n\n### 工作项调度\n- **数据指针复用**：`work_struct->data` 的高有效位存储 `pool_workqueue` 指针，低有效位用于标志位（如 `WORK_STRUCT_INACTIVE`）。\n- **优先级支持**：高优先级工作池使用 `HIGHPRI_NICE_LEVEL = MIN_NICE` 提升调度优先级。\n\n## 4. 依赖关系\n\n- **内核子系统**：\n  - **调度器**（`<linux/sched.h>`）：创建工作线程（kworker），管理 CPU 亲和性\n  - **内存管理**（`<linux/slab.h>`）：分配工作池、工作队列等结构\n  - **CPU 热插拔**（`<linux/cpu.h>`）：处理 CPU 上下线时的池绑定状态切换\n  - **RCU**（`<linux/rculist.h>`）：实现无锁读取路径\n  - **定时器**（`<linux/timer.h>`）：实现空闲超时和救援机制\n\n- **内部依赖**：\n  - `workqueue_internal.h`：定义 `struct worker` 等内部结构\n  - `Documentation/core-api/workqueue.rst`：详细设计文档\n\n## 5. 使用场景\n\n- **驱动程序延迟操作**：硬件中断后调度下半部处理（如网络包处理、磁盘 I/O 完成回调）。\n- **内核子系统异步任务**：文件系统元数据更新、内存回收、电源管理状态切换。\n- **高优先级任务**：使用 `WQ_HIGHPRI` 标志创建工作队列，确保关键任务及时执行（如死锁恢复）。\n- **CPU 密集型任务**：标记 `WQ_CPU_INTENSIVE` 避免占用过多并发槽位，提升系统响应性。\n- **NUMA 感知调度**：非绑定工作队列可指定 NUMA 节点，优化内存访问延迟。",
      "similarity": 0.6179001927375793,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/workqueue.c",
          "start_line": 1334,
          "end_line": 1463,
          "content": [
            "void wq_worker_tick(struct task_struct *task)",
            "{",
            "\tstruct worker *worker = kthread_data(task);",
            "\tstruct pool_workqueue *pwq = worker->current_pwq;",
            "\tstruct worker_pool *pool = worker->pool;",
            "",
            "\tif (!pwq)",
            "\t\treturn;",
            "",
            "\tpwq->stats[PWQ_STAT_CPU_TIME] += TICK_USEC;",
            "",
            "\tif (!wq_cpu_intensive_thresh_us)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * If the current worker is concurrency managed and hogged the CPU for",
            "\t * longer than wq_cpu_intensive_thresh_us, it's automatically marked",
            "\t * CPU_INTENSIVE to avoid stalling other concurrency-managed work items.",
            "\t *",
            "\t * Set @worker->sleeping means that @worker is in the process of",
            "\t * switching out voluntarily and won't be contributing to",
            "\t * @pool->nr_running until it wakes up. As wq_worker_sleeping() also",
            "\t * decrements ->nr_running, setting CPU_INTENSIVE here can lead to",
            "\t * double decrements. The task is releasing the CPU anyway. Let's skip.",
            "\t * We probably want to make this prettier in the future.",
            "\t */",
            "\tif ((worker->flags & WORKER_NOT_RUNNING) || READ_ONCE(worker->sleeping) ||",
            "\t    worker->task->se.sum_exec_runtime - worker->current_at <",
            "\t    wq_cpu_intensive_thresh_us * NSEC_PER_USEC)",
            "\t\treturn;",
            "",
            "\traw_spin_lock(&pool->lock);",
            "",
            "\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);",
            "\twq_cpu_intensive_report(worker->current_func);",
            "\tpwq->stats[PWQ_STAT_CPU_INTENSIVE]++;",
            "",
            "\tif (kick_pool(pool))",
            "\t\tpwq->stats[PWQ_STAT_CM_WAKEUP]++;",
            "",
            "\traw_spin_unlock(&pool->lock);",
            "}",
            "work_func_t wq_worker_last_func(struct task_struct *task)",
            "{",
            "\tstruct worker *worker = kthread_data(task);",
            "",
            "\treturn worker->last_func;",
            "}",
            "static void get_pwq(struct pool_workqueue *pwq)",
            "{",
            "\tlockdep_assert_held(&pwq->pool->lock);",
            "\tWARN_ON_ONCE(pwq->refcnt <= 0);",
            "\tpwq->refcnt++;",
            "}",
            "static void put_pwq(struct pool_workqueue *pwq)",
            "{",
            "\tlockdep_assert_held(&pwq->pool->lock);",
            "\tif (likely(--pwq->refcnt))",
            "\t\treturn;",
            "\t/*",
            "\t * @pwq can't be released under pool->lock, bounce to a dedicated",
            "\t * kthread_worker to avoid A-A deadlocks.",
            "\t */",
            "\tkthread_queue_work(pwq_release_worker, &pwq->release_work);",
            "}",
            "static void put_pwq_unlocked(struct pool_workqueue *pwq)",
            "{",
            "\tif (pwq) {",
            "\t\t/*",
            "\t\t * As both pwqs and pools are RCU protected, the",
            "\t\t * following lock operations are safe.",
            "\t\t */",
            "\t\traw_spin_lock_irq(&pwq->pool->lock);",
            "\t\tput_pwq(pwq);",
            "\t\traw_spin_unlock_irq(&pwq->pool->lock);",
            "\t}",
            "}",
            "static void pwq_activate_inactive_work(struct work_struct *work)",
            "{",
            "\tstruct pool_workqueue *pwq = get_work_pwq(work);",
            "",
            "\ttrace_workqueue_activate_work(work);",
            "\tif (list_empty(&pwq->pool->worklist))",
            "\t\tpwq->pool->watchdog_ts = jiffies;",
            "\tmove_linked_works(work, &pwq->pool->worklist, NULL);",
            "\t__clear_bit(WORK_STRUCT_INACTIVE_BIT, work_data_bits(work));",
            "\tpwq->nr_active++;",
            "}",
            "static void pwq_activate_first_inactive(struct pool_workqueue *pwq)",
            "{",
            "\tstruct work_struct *work = list_first_entry(&pwq->inactive_works,",
            "\t\t\t\t\t\t    struct work_struct, entry);",
            "",
            "\tpwq_activate_inactive_work(work);",
            "}",
            "static void pwq_dec_nr_in_flight(struct pool_workqueue *pwq, unsigned long work_data)",
            "{",
            "\tint color = get_work_color(work_data);",
            "",
            "\tif (!(work_data & WORK_STRUCT_INACTIVE)) {",
            "\t\tpwq->nr_active--;",
            "\t\tif (!list_empty(&pwq->inactive_works)) {",
            "\t\t\t/* one down, submit an inactive one */",
            "\t\t\tif (pwq->nr_active < pwq->max_active)",
            "\t\t\t\tpwq_activate_first_inactive(pwq);",
            "\t\t}",
            "\t}",
            "",
            "\tpwq->nr_in_flight[color]--;",
            "",
            "\t/* is flush in progress and are we at the flushing tip? */",
            "\tif (likely(pwq->flush_color != color))",
            "\t\tgoto out_put;",
            "",
            "\t/* are there still in-flight works? */",
            "\tif (pwq->nr_in_flight[color])",
            "\t\tgoto out_put;",
            "",
            "\t/* this pwq is done, clear flush_color */",
            "\tpwq->flush_color = -1;",
            "",
            "\t/*",
            "\t * If this was the last pwq, wake up the first flusher.  It",
            "\t * will handle the rest.",
            "\t */",
            "\tif (atomic_dec_and_test(&pwq->wq->nr_pwqs_to_flush))",
            "\t\tcomplete(&pwq->wq->first_flusher->done);",
            "out_put:",
            "\tput_pwq(pwq);",
            "}"
          ],
          "function_name": "wq_worker_tick, wq_worker_last_func, get_pwq, put_pwq, put_pwq_unlocked, pwq_activate_inactive_work, pwq_activate_first_inactive, pwq_dec_nr_in_flight",
          "description": "该代码块定义了工作队列中worker的CPU使用监控及PWQ管理。wq_worker_tick检测worker是否成为CPU密集型任务并更新统计信息；get_pwq/put_pwq管理PWQ引用计数；pwq_activate_inactive_work激活处于inactive状态的工作项并更新nr_active计数。",
          "similarity": 0.5965710282325745
        },
        {
          "chunk_id": 21,
          "file_path": "kernel/workqueue.c",
          "start_line": 4591,
          "end_line": 4693,
          "content": [
            "static int alloc_and_link_pwqs(struct workqueue_struct *wq)",
            "{",
            "\tbool highpri = wq->flags & WQ_HIGHPRI;",
            "\tint cpu, ret;",
            "",
            "\twq->cpu_pwq = alloc_percpu(struct pool_workqueue *);",
            "\tif (!wq->cpu_pwq)",
            "\t\tgoto enomem;",
            "",
            "\tif (!(wq->flags & WQ_UNBOUND)) {",
            "\t\tfor_each_possible_cpu(cpu) {",
            "\t\t\tstruct pool_workqueue **pwq_p =",
            "\t\t\t\tper_cpu_ptr(wq->cpu_pwq, cpu);",
            "\t\t\tstruct worker_pool *pool =",
            "\t\t\t\t&(per_cpu_ptr(cpu_worker_pools, cpu)[highpri]);",
            "",
            "\t\t\t*pwq_p = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL,",
            "\t\t\t\t\t\t       pool->node);",
            "\t\t\tif (!*pwq_p)",
            "\t\t\t\tgoto enomem;",
            "",
            "\t\t\tinit_pwq(*pwq_p, wq, pool);",
            "",
            "\t\t\tmutex_lock(&wq->mutex);",
            "\t\t\tlink_pwq(*pwq_p);",
            "\t\t\tmutex_unlock(&wq->mutex);",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tcpus_read_lock();",
            "\tif (wq->flags & __WQ_ORDERED) {",
            "\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);",
            "\t\t/* there should only be single pwq for ordering guarantee */",
            "\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||",
            "\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),",
            "\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);",
            "\t} else {",
            "\t\tret = apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);",
            "\t}",
            "\tcpus_read_unlock();",
            "",
            "\t/* for unbound pwq, flush the pwq_release_worker ensures that the",
            "\t * pwq_release_workfn() completes before calling kfree(wq).",
            "\t */",
            "\tif (ret)",
            "\t\tkthread_flush_worker(pwq_release_worker);",
            "",
            "\treturn ret;",
            "",
            "enomem:",
            "\tif (wq->cpu_pwq) {",
            "\t\tfor_each_possible_cpu(cpu) {",
            "\t\t\tstruct pool_workqueue *pwq = *per_cpu_ptr(wq->cpu_pwq, cpu);",
            "",
            "\t\t\tif (pwq)",
            "\t\t\t\tkmem_cache_free(pwq_cache, pwq);",
            "\t\t}",
            "\t\tfree_percpu(wq->cpu_pwq);",
            "\t\twq->cpu_pwq = NULL;",
            "\t}",
            "\treturn -ENOMEM;",
            "}",
            "static int wq_clamp_max_active(int max_active, unsigned int flags,",
            "\t\t\t       const char *name)",
            "{",
            "\tif (max_active < 1 || max_active > WQ_MAX_ACTIVE)",
            "\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",",
            "\t\t\tmax_active, name, 1, WQ_MAX_ACTIVE);",
            "",
            "\treturn clamp_val(max_active, 1, WQ_MAX_ACTIVE);",
            "}",
            "static int init_rescuer(struct workqueue_struct *wq)",
            "{",
            "\tstruct worker *rescuer;",
            "\tint ret;",
            "",
            "\tif (!(wq->flags & WQ_MEM_RECLAIM))",
            "\t\treturn 0;",
            "",
            "\trescuer = alloc_worker(NUMA_NO_NODE);",
            "\tif (!rescuer) {",
            "\t\tpr_err(\"workqueue: Failed to allocate a rescuer for wq \\\"%s\\\"\\n\",",
            "\t\t       wq->name);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\trescuer->rescue_wq = wq;",
            "\trescuer->task = kthread_create(rescuer_thread, rescuer, \"kworker/R-%s\", wq->name);",
            "\tif (IS_ERR(rescuer->task)) {",
            "\t\tret = PTR_ERR(rescuer->task);",
            "\t\tpr_err(\"workqueue: Failed to create a rescuer kthread for wq \\\"%s\\\": %pe\",",
            "\t\t       wq->name, ERR_PTR(ret));",
            "\t\tkfree(rescuer);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\twq->rescuer = rescuer;",
            "\tkthread_bind_mask(rescuer->task, cpu_possible_mask);",
            "\twake_up_process(rescuer->task);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "alloc_and_link_pwqs, wq_clamp_max_active, init_rescuer",
          "description": "包含分配并链接池工作队列的alloc_and_link_pwqs函数，wq_clamp_max_active用于限制最大活跃任务数范围，init_rescuer初始化救援线程以处理内存回收场景下的异常情况。",
          "similarity": 0.582442045211792
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/workqueue.c",
          "start_line": 895,
          "end_line": 1037,
          "content": [
            "static inline void worker_clr_flags(struct worker *worker, unsigned int flags)",
            "{",
            "\tstruct worker_pool *pool = worker->pool;",
            "\tunsigned int oflags = worker->flags;",
            "",
            "\tlockdep_assert_held(&pool->lock);",
            "",
            "\tworker->flags &= ~flags;",
            "",
            "\t/*",
            "\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note",
            "\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask",
            "\t * of multiple flags, not a single flag.",
            "\t */",
            "\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))",
            "\t\tif (!(worker->flags & WORKER_NOT_RUNNING))",
            "\t\t\tpool->nr_running++;",
            "}",
            "static void worker_enter_idle(struct worker *worker)",
            "{",
            "\tstruct worker_pool *pool = worker->pool;",
            "",
            "\tif (WARN_ON_ONCE(worker->flags & WORKER_IDLE) ||",
            "\t    WARN_ON_ONCE(!list_empty(&worker->entry) &&",
            "\t\t\t (worker->hentry.next || worker->hentry.pprev)))",
            "\t\treturn;",
            "",
            "\t/* can't use worker_set_flags(), also called from create_worker() */",
            "\tworker->flags |= WORKER_IDLE;",
            "\tpool->nr_idle++;",
            "\tworker->last_active = jiffies;",
            "",
            "\t/* idle_list is LIFO */",
            "\tlist_add(&worker->entry, &pool->idle_list);",
            "",
            "\tif (too_many_workers(pool) && !timer_pending(&pool->idle_timer))",
            "\t\tmod_timer(&pool->idle_timer, jiffies + IDLE_WORKER_TIMEOUT);",
            "",
            "\t/* Sanity check nr_running. */",
            "\tWARN_ON_ONCE(pool->nr_workers == pool->nr_idle && pool->nr_running);",
            "}",
            "static void worker_leave_idle(struct worker *worker)",
            "{",
            "\tstruct worker_pool *pool = worker->pool;",
            "",
            "\tif (WARN_ON_ONCE(!(worker->flags & WORKER_IDLE)))",
            "\t\treturn;",
            "\tworker_clr_flags(worker, WORKER_IDLE);",
            "\tpool->nr_idle--;",
            "\tlist_del_init(&worker->entry);",
            "}",
            "static void move_linked_works(struct work_struct *work, struct list_head *head,",
            "\t\t\t      struct work_struct **nextp)",
            "{",
            "\tstruct work_struct *n;",
            "",
            "\t/*",
            "\t * Linked worklist will always end before the end of the list,",
            "\t * use NULL for list head.",
            "\t */",
            "\tlist_for_each_entry_safe_from(work, n, NULL, entry) {",
            "\t\tlist_move_tail(&work->entry, head);",
            "\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\t/*",
            "\t * If we're already inside safe list traversal and have moved",
            "\t * multiple works to the scheduled queue, the next position",
            "\t * needs to be updated.",
            "\t */",
            "\tif (nextp)",
            "\t\t*nextp = n;",
            "}",
            "static bool assign_work(struct work_struct *work, struct worker *worker,",
            "\t\t\tstruct work_struct **nextp)",
            "{",
            "\tstruct worker_pool *pool = worker->pool;",
            "\tstruct worker *collision;",
            "",
            "\tlockdep_assert_held(&pool->lock);",
            "",
            "\t/*",
            "\t * A single work shouldn't be executed concurrently by multiple workers.",
            "\t * __queue_work() ensures that @work doesn't jump to a different pool",
            "\t * while still running in the previous pool. Here, we should ensure that",
            "\t * @work is not executed concurrently by multiple workers from the same",
            "\t * pool. Check whether anyone is already processing the work. If so,",
            "\t * defer the work to the currently executing one.",
            "\t */",
            "\tcollision = find_worker_executing_work(pool, work);",
            "\tif (unlikely(collision)) {",
            "\t\tmove_linked_works(work, &collision->scheduled, nextp);",
            "\t\treturn false;",
            "\t}",
            "",
            "\tmove_linked_works(work, &worker->scheduled, nextp);",
            "\treturn true;",
            "}",
            "static bool kick_pool(struct worker_pool *pool)",
            "{",
            "\tstruct worker *worker = first_idle_worker(pool);",
            "\tstruct task_struct *p;",
            "",
            "\tlockdep_assert_held(&pool->lock);",
            "",
            "\tif (!need_more_worker(pool) || !worker)",
            "\t\treturn false;",
            "",
            "\tp = worker->task;",
            "",
            "#ifdef CONFIG_SMP",
            "\t/*",
            "\t * Idle @worker is about to execute @work and waking up provides an",
            "\t * opportunity to migrate @worker at a lower cost by setting the task's",
            "\t * wake_cpu field. Let's see if we want to move @worker to improve",
            "\t * execution locality.",
            "\t *",
            "\t * We're waking the worker that went idle the latest and there's some",
            "\t * chance that @worker is marked idle but hasn't gone off CPU yet. If",
            "\t * so, setting the wake_cpu won't do anything. As this is a best-effort",
            "\t * optimization and the race window is narrow, let's leave as-is for",
            "\t * now. If this becomes pronounced, we can skip over workers which are",
            "\t * still on cpu when picking an idle worker.",
            "\t *",
            "\t * If @pool has non-strict affinity, @worker might have ended up outside",
            "\t * its affinity scope. Repatriate.",
            "\t */",
            "\tif (!pool->attrs->affn_strict &&",
            "\t    !cpumask_test_cpu(p->wake_cpu, pool->attrs->__pod_cpumask)) {",
            "\t\tstruct work_struct *work = list_first_entry(&pool->worklist,",
            "\t\t\t\t\t\tstruct work_struct, entry);",
            "\t\tint wake_cpu = cpumask_any_and_distribute(pool->attrs->__pod_cpumask,",
            "\t\t\t\t\t\t\t  cpu_online_mask);",
            "\t\tif (wake_cpu < nr_cpu_ids) {",
            "\t\t\tp->wake_cpu = wake_cpu;",
            "\t\t\tget_work_pwq(work)->stats[PWQ_STAT_REPATRIATED]++;",
            "\t\t}",
            "\t}",
            "#endif",
            "\twake_up_process(p);",
            "\treturn true;",
            "}"
          ],
          "function_name": "worker_clr_flags, worker_enter_idle, worker_leave_idle, move_linked_works, assign_work, kick_pool",
          "description": "实现工作者线程空闲状态切换和工作项迁移机制，包含空闲工作者列表管理、链接工作项批量转移功能，以及唤醒工作者线程的调度逻辑，支持跨CPU亲和性迁移优化，确保工作项正确分发到可用工作者线程。",
          "similarity": 0.5792611837387085
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/workqueue.c",
          "start_line": 692,
          "end_line": 797,
          "content": [
            "static void set_work_pool_and_clear_pending(struct work_struct *work,",
            "\t\t\t\t\t    int pool_id)",
            "{",
            "\t/*",
            "\t * The following wmb is paired with the implied mb in",
            "\t * test_and_set_bit(PENDING) and ensures all updates to @work made",
            "\t * here are visible to and precede any updates by the next PENDING",
            "\t * owner.",
            "\t */",
            "\tsmp_wmb();",
            "\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT, 0);",
            "\t/*",
            "\t * The following mb guarantees that previous clear of a PENDING bit",
            "\t * will not be reordered with any speculative LOADS or STORES from",
            "\t * work->current_func, which is executed afterwards.  This possible",
            "\t * reordering can lead to a missed execution on attempt to queue",
            "\t * the same @work.  E.g. consider this case:",
            "\t *",
            "\t *   CPU#0                         CPU#1",
            "\t *   ----------------------------  --------------------------------",
            "\t *",
            "\t * 1  STORE event_indicated",
            "\t * 2  queue_work_on() {",
            "\t * 3    test_and_set_bit(PENDING)",
            "\t * 4 }                             set_..._and_clear_pending() {",
            "\t * 5                                 set_work_data() # clear bit",
            "\t * 6                                 smp_mb()",
            "\t * 7                               work->current_func() {",
            "\t * 8\t\t\t\t      LOAD event_indicated",
            "\t *\t\t\t\t   }",
            "\t *",
            "\t * Without an explicit full barrier speculative LOAD on line 8 can",
            "\t * be executed before CPU#0 does STORE on line 1.  If that happens,",
            "\t * CPU#0 observes the PENDING bit is still set and new execution of",
            "\t * a @work is not queued in a hope, that CPU#1 will eventually",
            "\t * finish the queued @work.  Meanwhile CPU#1 does not see",
            "\t * event_indicated is set, because speculative LOAD was executed",
            "\t * before actual STORE.",
            "\t */",
            "\tsmp_mb();",
            "}",
            "static void clear_work_data(struct work_struct *work)",
            "{",
            "\tsmp_wmb();\t/* see set_work_pool_and_clear_pending() */",
            "\tset_work_data(work, WORK_STRUCT_NO_POOL, 0);",
            "}",
            "static int get_work_pool_id(struct work_struct *work)",
            "{",
            "\tunsigned long data = atomic_long_read(&work->data);",
            "",
            "\tif (data & WORK_STRUCT_PWQ)",
            "\t\treturn work_struct_pwq(data)->pool->id;",
            "",
            "\treturn data >> WORK_OFFQ_POOL_SHIFT;",
            "}",
            "static void mark_work_canceling(struct work_struct *work)",
            "{",
            "\tunsigned long pool_id = get_work_pool_id(work);",
            "",
            "\tpool_id <<= WORK_OFFQ_POOL_SHIFT;",
            "\tset_work_data(work, pool_id | WORK_OFFQ_CANCELING, WORK_STRUCT_PENDING);",
            "}",
            "static bool work_is_canceling(struct work_struct *work)",
            "{",
            "\tunsigned long data = atomic_long_read(&work->data);",
            "",
            "\treturn !(data & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_CANCELING);",
            "}",
            "static bool need_more_worker(struct worker_pool *pool)",
            "{",
            "\treturn !list_empty(&pool->worklist) && !pool->nr_running;",
            "}",
            "static bool may_start_working(struct worker_pool *pool)",
            "{",
            "\treturn pool->nr_idle;",
            "}",
            "static bool keep_working(struct worker_pool *pool)",
            "{",
            "\treturn !list_empty(&pool->worklist) && (pool->nr_running <= 1);",
            "}",
            "static bool need_to_create_worker(struct worker_pool *pool)",
            "{",
            "\treturn need_more_worker(pool) && !may_start_working(pool);",
            "}",
            "static bool too_many_workers(struct worker_pool *pool)",
            "{",
            "\tbool managing = pool->flags & POOL_MANAGER_ACTIVE;",
            "\tint nr_idle = pool->nr_idle + managing; /* manager is considered idle */",
            "\tint nr_busy = pool->nr_workers - nr_idle;",
            "",
            "\treturn nr_idle > 2 && (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO >= nr_busy;",
            "}",
            "static inline void worker_set_flags(struct worker *worker, unsigned int flags)",
            "{",
            "\tstruct worker_pool *pool = worker->pool;",
            "",
            "\tlockdep_assert_held(&pool->lock);",
            "",
            "\t/* If transitioning into NOT_RUNNING, adjust nr_running. */",
            "\tif ((flags & WORKER_NOT_RUNNING) &&",
            "\t    !(worker->flags & WORKER_NOT_RUNNING)) {",
            "\t\tpool->nr_running--;",
            "\t}",
            "",
            "\tworker->flags |= flags;",
            "}"
          ],
          "function_name": "set_work_pool_and_clear_pending, clear_work_data, get_work_pool_id, mark_work_canceling, work_is_canceling, need_more_worker, may_start_working, keep_working, need_to_create_worker, too_many_workers, worker_set_flags",
          "description": "实现工作者线程池状态控制逻辑，包含需要创建新工作者的判断条件、工作者空闲状态管理、工作项冲突检测及任务分配函数，通过锁保护保证池状态一致性，维护工作者线程与待处理工作项的匹配关系。",
          "similarity": 0.5782322287559509
        },
        {
          "chunk_id": 14,
          "file_path": "kernel/workqueue.c",
          "start_line": 3156,
          "end_line": 3314,
          "content": [
            "static void touch_wq_lockdep_map(struct workqueue_struct *wq)",
            "{",
            "\tlock_map_acquire(&wq->lockdep_map);",
            "\tlock_map_release(&wq->lockdep_map);",
            "}",
            "static void touch_work_lockdep_map(struct work_struct *work,",
            "\t\t\t\t   struct workqueue_struct *wq)",
            "{",
            "\tlock_map_acquire(&work->lockdep_map);",
            "\tlock_map_release(&work->lockdep_map);",
            "}",
            "void __flush_workqueue(struct workqueue_struct *wq)",
            "{",
            "\tstruct wq_flusher this_flusher = {",
            "\t\t.list = LIST_HEAD_INIT(this_flusher.list),",
            "\t\t.flush_color = -1,",
            "\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),",
            "\t};",
            "\tint next_color;",
            "",
            "\tif (WARN_ON(!wq_online))",
            "\t\treturn;",
            "",
            "\ttouch_wq_lockdep_map(wq);",
            "",
            "\tmutex_lock(&wq->mutex);",
            "",
            "\t/*",
            "\t * Start-to-wait phase",
            "\t */",
            "\tnext_color = work_next_color(wq->work_color);",
            "",
            "\tif (next_color != wq->flush_color) {",
            "\t\t/*",
            "\t\t * Color space is not full.  The current work_color",
            "\t\t * becomes our flush_color and work_color is advanced",
            "\t\t * by one.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));",
            "\t\tthis_flusher.flush_color = wq->work_color;",
            "\t\twq->work_color = next_color;",
            "",
            "\t\tif (!wq->first_flusher) {",
            "\t\t\t/* no flush in progress, become the first flusher */",
            "\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);",
            "",
            "\t\t\twq->first_flusher = &this_flusher;",
            "",
            "\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,",
            "\t\t\t\t\t\t       wq->work_color)) {",
            "\t\t\t\t/* nothing to flush, done */",
            "\t\t\t\twq->flush_color = next_color;",
            "\t\t\t\twq->first_flusher = NULL;",
            "\t\t\t\tgoto out_unlock;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\t/* wait in queue */",
            "\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);",
            "\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);",
            "\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);",
            "\t\t}",
            "\t} else {",
            "\t\t/*",
            "\t\t * Oops, color space is full, wait on overflow queue.",
            "\t\t * The next flush completion will assign us",
            "\t\t * flush_color and transfer to flusher_queue.",
            "\t\t */",
            "\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);",
            "\t}",
            "",
            "\tcheck_flush_dependency(wq, NULL, false);",
            "",
            "\tmutex_unlock(&wq->mutex);",
            "",
            "\twait_for_completion(&this_flusher.done);",
            "",
            "\t/*",
            "\t * Wake-up-and-cascade phase",
            "\t *",
            "\t * First flushers are responsible for cascading flushes and",
            "\t * handling overflow.  Non-first flushers can simply return.",
            "\t */",
            "\tif (READ_ONCE(wq->first_flusher) != &this_flusher)",
            "\t\treturn;",
            "",
            "\tmutex_lock(&wq->mutex);",
            "",
            "\t/* we might have raced, check again with mutex held */",
            "\tif (wq->first_flusher != &this_flusher)",
            "\t\tgoto out_unlock;",
            "",
            "\tWRITE_ONCE(wq->first_flusher, NULL);",
            "",
            "\tWARN_ON_ONCE(!list_empty(&this_flusher.list));",
            "\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);",
            "",
            "\twhile (true) {",
            "\t\tstruct wq_flusher *next, *tmp;",
            "",
            "\t\t/* complete all the flushers sharing the current flush color */",
            "\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {",
            "\t\t\tif (next->flush_color != wq->flush_color)",
            "\t\t\t\tbreak;",
            "\t\t\tlist_del_init(&next->list);",
            "\t\t\tcomplete(&next->done);",
            "\t\t}",
            "",
            "\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&",
            "\t\t\t     wq->flush_color != work_next_color(wq->work_color));",
            "",
            "\t\t/* this flush_color is finished, advance by one */",
            "\t\twq->flush_color = work_next_color(wq->flush_color);",
            "",
            "\t\t/* one color has been freed, handle overflow queue */",
            "\t\tif (!list_empty(&wq->flusher_overflow)) {",
            "\t\t\t/*",
            "\t\t\t * Assign the same color to all overflowed",
            "\t\t\t * flushers, advance work_color and append to",
            "\t\t\t * flusher_queue.  This is the start-to-wait",
            "\t\t\t * phase for these overflowed flushers.",
            "\t\t\t */",
            "\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)",
            "\t\t\t\ttmp->flush_color = wq->work_color;",
            "",
            "\t\t\twq->work_color = work_next_color(wq->work_color);",
            "",
            "\t\t\tlist_splice_tail_init(&wq->flusher_overflow,",
            "\t\t\t\t\t      &wq->flusher_queue);",
            "\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);",
            "\t\t}",
            "",
            "\t\tif (list_empty(&wq->flusher_queue)) {",
            "\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Need to flush more colors.  Make the next flusher",
            "\t\t * the new first flusher and arm pwqs.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);",
            "\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);",
            "",
            "\t\tlist_del_init(&next->list);",
            "\t\twq->first_flusher = next;",
            "",
            "\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * Meh... this color is already done, clear first",
            "\t\t * flusher and repeat cascading.",
            "\t\t */",
            "\t\twq->first_flusher = NULL;",
            "\t}",
            "",
            "out_unlock:",
            "\tmutex_unlock(&wq->mutex);",
            "}"
          ],
          "function_name": "touch_wq_lockdep_map, touch_work_lockdep_map, __flush_workqueue",
          "description": "实现工作队列强制刷新的核心逻辑，包含颜色轮转管理、依赖关系检查及多阶段刷新流程控制",
          "similarity": 0.57695472240448
        }
      ]
    }
  ]
}