{
  "query": "系统调用性能优化",
  "timestamp": "2025-12-26 02:08:36",
  "retrieved_files": [
    {
      "source_file": "kernel/sched/cpufreq_schedutil.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:03:51\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\cpufreq_schedutil.c`\n\n---\n\n# `sched/cpufreq_schedutil.c` 技术文档\n\n## 1. 文件概述\n\n`sched/cpufreq_schedutil.c` 实现了 Linux 内核中基于调度器提供的 CPU 利用率数据的 **schedutil CPUFreq 调速器（governor）**。该调速器通过实时获取调度器计算的 CPU 利用率（包括 CFS、RT、DL 任务以及 I/O 等待状态），动态调整 CPU 频率，以在性能与能效之间取得平衡。其核心优势在于直接利用调度器的 `util` 信息，避免传统调速器依赖采样机制带来的延迟和不准确性。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct sugov_tunables`**  \n  调速器可调参数，包含：\n  - `rate_limit_us`：频率更新的最小时间间隔（微秒），防止过于频繁的频率切换。\n\n- **`struct sugov_policy`**  \n  每个 `cpufreq_policy` 对应的 schedutil 策略实例，包含：\n  - `policy`：关联的 CPUFreq 策略。\n  - `update_lock`：保护频率更新的自旋锁。\n  - `last_freq_update_time` / `freq_update_delay_ns`：控制频率更新速率。\n  - `next_freq` / `cached_raw_freq`：目标频率与原始计算频率缓存。\n  - `irq_work` / `worker` / `thread`：用于慢速切换平台（非 fast-switch）的异步工作队列机制。\n  - `limits_changed` / `need_freq_update`：标志策略限制（如 min/max freq）是否变更。\n\n- **`struct sugov_cpu`**  \n  每个 CPU 的 schedutil 状态，包含：\n  - `update_util`：注册到调度器的回调接口（`update_util_data`）。\n  - `util` / `bw_min`：当前有效利用率及带宽最小值。\n  - `iowait_boost` / `iowait_boost_pending`：I/O 等待唤醒时的频率提升机制。\n  - `last_update`：上次更新时间戳。\n\n### 主要函数\n\n- **`sugov_should_update_freq()`**  \n  判断是否应执行频率更新，考虑硬件是否支持本 CPU 更新、策略限制变更、以及频率更新间隔限制。\n\n- **`sugov_update_next_freq()`**  \n  更新目标频率，处理策略限制变更场景，避免不必要的驱动回调。\n\n- **`get_next_freq()`**  \n  核心频率计算函数，根据 CPU 利用率、最大容量和参考频率，计算目标频率，并通过 `cpufreq_driver_resolve_freq()` 映射到驱动支持的频率。\n\n- **`sugov_get_util()`**  \n  获取当前 CPU 的综合利用率，整合 CFS/RT/DL 任务利用率、boost 值，并调用 `sugov_effective_cpu_perf()` 计算有效性能目标。\n\n- **`sugov_effective_cpu_perf()`**  \n  计算最终的有效性能目标，确保不低于最小性能要求，并限制不超过实际需求。\n\n- **`sugov_iowait_reset()` / `sugov_iowait_boost()`**  \n  实现 I/O 等待唤醒时的动态频率提升机制：短时间内连续 I/O 唤醒会逐步提升 boost 值（从 `IOWAIT_BOOST_MIN` 到最大 OPP），超过一个 tick 无 I/O 唤醒则重置。\n\n- **`get_capacity_ref_freq()`**  \n  获取用于计算 CPU 容量的参考频率，优先使用架构特定的 `arch_scale_freq_ref()`，其次为最大频率或当前频率。\n\n- **`sugov_deferred_update()`**  \n  在不支持 fast-switch 的平台上，通过 `irq_work` 触发异步频率更新。\n\n## 3. 关键实现\n\n### 频率计算算法\n- **频率不变性支持**：若系统支持频率不变调度（`arch_scale_freq_invariant()`），则直接使用调度器提供的频率不变利用率 `util`，按比例计算目标频率：  \n  `next_freq = C * max_freq * util / max`  \n  其中常数 `C = 1.25`，使在 `util/max = 0.8` 时达到 `max_freq`，提供性能余量。\n- **非频率不变性**：使用原始利用率 `util_raw` 乘以 `(curr_freq / max_freq)` 近似频率不变利用率，再计算目标频率。\n\n### I/O 等待 Boost 机制\n- 当任务因 I/O 完成而唤醒时，标记 `SCHED_CPUFREQ_IOWAIT`。\n- 若在 **一个 tick 内** 多次发生 I/O 唤醒，则 `iowait_boost` 值倍增（上限为最大 OPP 对应的利用率）。\n- 若超过一个 tick 无 I/O 唤醒，则重置 boost 值为 `IOWAIT_BOOST_MIN`（`SCHED_CAPACITY_SCALE / 8`），避免对偶发 I/O 过度响应，提升能效。\n\n### 快速切换（Fast-Switch）与异步更新\n- **Fast-Switch 平台**：支持在调度上下文中直接调用 `cpufreq_driver_fast_switch()` 更新频率，延迟最低。\n- **非 Fast-Switch 平台**：通过 `irq_work` 触发内核线程（`kthread_worker`）异步执行频率更新，避免在中断上下文或持有 rq 锁时调用可能阻塞的驱动接口。\n\n### 策略限制变更处理\n- 当用户空间修改 policy 的 min/max 频率时，`sugov_limits()` 设置 `limits_changed` 标志。\n- 下次更新时，强制重新计算频率，并通过内存屏障（`smp_mb()`）确保读取到最新的策略限制。\n\n## 4. 依赖关系\n\n- **调度器子系统**：\n  - 依赖 `update_util_data` 回调机制（通过 `cpufreq_add_update_util_hook()` 注册）。\n  - 调用 `cpu_util_cfs_boost()`、`effective_cpu_util()` 等函数获取综合利用率。\n  - 使用 `scx_cpuperf_target()`（若启用了 SCHED_CLASS_EXT）。\n- **CPUFreq 核心**：\n  - 依赖 `cpufreq_policy`、`cpufreq_driver_resolve_freq()`、`cpufreq_driver_fast_switch()` 等接口。\n  - 使用 `cpufreq_this_cpu_can_update()` 判断硬件更新能力。\n- **架构相关支持**：\n  - 依赖 `arch_scale_freq_ref()` 和 `arch_scale_freq_invariant()` 提供频率不变性信息。\n- **内核基础设施**：\n  - 使用 `irq_work`、`kthread_worker` 实现异步更新。\n  - 依赖 `TICK_NSEC` 定义 tick 时间。\n\n## 5. 使用场景\n\n- **默认高性能能效平衡场景**：现代 Linux 发行版通常将 `schedutil` 作为默认 CPUFreq 调速器，适用于大多数桌面、服务器和移动设备。\n- **实时性要求较高的系统**：由于其低延迟特性（尤其在 fast-switch 平台上），适合对响应时间敏感的应用。\n- **能效敏感设备**：通过 I/O boost 机制和精确的利用率跟踪，在保证交互性能的同时降低空闲功耗。\n- **异构多核系统（如 big.LITTLE）**：结合调度器的 CPU capacity 信息，为不同性能核提供差异化频率调整。",
      "similarity": 0.634888768196106,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/cpufreq_schedutil.c",
          "start_line": 204,
          "end_line": 330,
          "content": [
            "unsigned long sugov_effective_cpu_perf(int cpu, unsigned long actual,",
            "\t\t\t\t unsigned long min,",
            "\t\t\t\t unsigned long max)",
            "{",
            "\t/* Add dvfs headroom to actual utilization */",
            "\tactual = map_util_perf(actual);",
            "\t/* Actually we don't need to target the max performance */",
            "\tif (actual < max)",
            "\t\tmax = actual;",
            "",
            "\t/*",
            "\t * Ensure at least minimum performance while providing more compute",
            "\t * capacity when possible.",
            "\t */",
            "\treturn max(min, max);",
            "}",
            "static void sugov_get_util(struct sugov_cpu *sg_cpu, unsigned long boost)",
            "{",
            "\tunsigned long min, max, util = scx_cpuperf_target(sg_cpu->cpu);",
            "",
            "\tif (!scx_switched_all())",
            "\t\tutil += cpu_util_cfs_boost(sg_cpu->cpu);",
            "\tutil = effective_cpu_util(sg_cpu->cpu, util, &min, &max);",
            "\tutil = max(util, boost);",
            "\tsg_cpu->bw_min = min;",
            "\tsg_cpu->util = sugov_effective_cpu_perf(sg_cpu->cpu, util, min, max);",
            "}",
            "static bool sugov_iowait_reset(struct sugov_cpu *sg_cpu, u64 time,",
            "\t\t\t       bool set_iowait_boost)",
            "{",
            "\ts64 delta_ns = time - sg_cpu->last_update;",
            "",
            "\t/* Reset boost only if a tick has elapsed since last request */",
            "\tif (delta_ns <= TICK_NSEC)",
            "\t\treturn false;",
            "",
            "\tsg_cpu->iowait_boost = set_iowait_boost ? IOWAIT_BOOST_MIN : 0;",
            "\tsg_cpu->iowait_boost_pending = set_iowait_boost;",
            "",
            "\treturn true;",
            "}",
            "static void sugov_iowait_boost(struct sugov_cpu *sg_cpu, u64 time,",
            "\t\t\t       unsigned int flags)",
            "{",
            "\tbool set_iowait_boost = flags & SCHED_CPUFREQ_IOWAIT;",
            "",
            "\t/* Reset boost if the CPU appears to have been idle enough */",
            "\tif (sg_cpu->iowait_boost &&",
            "\t    sugov_iowait_reset(sg_cpu, time, set_iowait_boost))",
            "\t\treturn;",
            "",
            "\t/* Boost only tasks waking up after IO */",
            "\tif (!set_iowait_boost)",
            "\t\treturn;",
            "",
            "\t/* Ensure boost doubles only one time at each request */",
            "\tif (sg_cpu->iowait_boost_pending)",
            "\t\treturn;",
            "\tsg_cpu->iowait_boost_pending = true;",
            "",
            "\t/* Double the boost at each request */",
            "\tif (sg_cpu->iowait_boost) {",
            "\t\tsg_cpu->iowait_boost =",
            "\t\t\tmin_t(unsigned int, sg_cpu->iowait_boost << 1, SCHED_CAPACITY_SCALE);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* First wakeup after IO: start with minimum boost */",
            "\tsg_cpu->iowait_boost = IOWAIT_BOOST_MIN;",
            "}",
            "static unsigned long sugov_iowait_apply(struct sugov_cpu *sg_cpu, u64 time,",
            "\t\t\t       unsigned long max_cap)",
            "{",
            "\t/* No boost currently required */",
            "\tif (!sg_cpu->iowait_boost)",
            "\t\treturn 0;",
            "",
            "\t/* Reset boost if the CPU appears to have been idle enough */",
            "\tif (sugov_iowait_reset(sg_cpu, time, false))",
            "\t\treturn 0;",
            "",
            "\tif (!sg_cpu->iowait_boost_pending) {",
            "\t\t/*",
            "\t\t * No boost pending; reduce the boost value.",
            "\t\t */",
            "\t\tsg_cpu->iowait_boost >>= 1;",
            "\t\tif (sg_cpu->iowait_boost < IOWAIT_BOOST_MIN) {",
            "\t\t\tsg_cpu->iowait_boost = 0;",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            "\tsg_cpu->iowait_boost_pending = false;",
            "",
            "\t/*",
            "\t * sg_cpu->util is already in capacity scale; convert iowait_boost",
            "\t * into the same scale so we can compare.",
            "\t */",
            "\treturn (sg_cpu->iowait_boost * max_cap) >> SCHED_CAPACITY_SHIFT;",
            "}",
            "static bool sugov_hold_freq(struct sugov_cpu *sg_cpu)",
            "{",
            "\tunsigned long idle_calls;",
            "\tbool ret;",
            "",
            "\t/*",
            "\t * The heuristics in this function is for the fair class. For SCX, the",
            "\t * performance target comes directly from the BPF scheduler. Let's just",
            "\t * follow it.",
            "\t */",
            "\tif (scx_switched_all())",
            "\t\treturn false;",
            "",
            "\t/* if capped by uclamp_max, always update to be in compliance */",
            "\tif (uclamp_rq_is_capped(cpu_rq(sg_cpu->cpu)))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Maintain the frequency if the CPU has not been idle recently, as",
            "\t * reduction is likely to be premature.",
            "\t */",
            "\tidle_calls = tick_nohz_get_idle_calls_cpu(sg_cpu->cpu);",
            "\tret = idle_calls == sg_cpu->saved_idle_calls;",
            "",
            "\tsg_cpu->saved_idle_calls = idle_calls;",
            "\treturn ret;",
            "}"
          ],
          "function_name": "sugov_effective_cpu_perf, sugov_get_util, sugov_iowait_reset, sugov_iowait_boost, sugov_iowait_apply, sugov_hold_freq",
          "description": "处理利用率计算和I/O等待优化，sugov_effective_cpu_perf计算有效性能需求，sugov_get_util获取考虑boost后的利用率，sugov_iowait_*系列函数管理I/O等待场景下的频率提升机制。",
          "similarity": 0.6377929449081421
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/sched/cpufreq_schedutil.c",
          "start_line": 508,
          "end_line": 651,
          "content": [
            "static void",
            "sugov_update_shared(struct update_util_data *hook, u64 time, unsigned int flags)",
            "{",
            "\tstruct sugov_cpu *sg_cpu = container_of(hook, struct sugov_cpu, update_util);",
            "\tstruct sugov_policy *sg_policy = sg_cpu->sg_policy;",
            "\tunsigned int next_f;",
            "",
            "\traw_spin_lock(&sg_policy->update_lock);",
            "",
            "\tsugov_iowait_boost(sg_cpu, time, flags);",
            "\tsg_cpu->last_update = time;",
            "",
            "\tignore_dl_rate_limit(sg_cpu);",
            "",
            "\tif (sugov_should_update_freq(sg_policy, time)) {",
            "\t\tnext_f = sugov_next_freq_shared(sg_cpu, time);",
            "",
            "\t\tif (!sugov_update_next_freq(sg_policy, time, next_f))",
            "\t\t\tgoto unlock;",
            "",
            "\t\tif (sg_policy->policy->fast_switch_enabled)",
            "\t\t\tcpufreq_driver_fast_switch(sg_policy->policy, next_f);",
            "\t\telse",
            "\t\t\tsugov_deferred_update(sg_policy);",
            "\t}",
            "unlock:",
            "\traw_spin_unlock(&sg_policy->update_lock);",
            "}",
            "static void sugov_work(struct kthread_work *work)",
            "{",
            "\tstruct sugov_policy *sg_policy = container_of(work, struct sugov_policy, work);",
            "\tunsigned int freq;",
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * Hold sg_policy->update_lock shortly to handle the case where:",
            "\t * in case sg_policy->next_freq is read here, and then updated by",
            "\t * sugov_deferred_update() just before work_in_progress is set to false",
            "\t * here, we may miss queueing the new update.",
            "\t *",
            "\t * Note: If a work was queued after the update_lock is released,",
            "\t * sugov_work() will just be called again by kthread_work code; and the",
            "\t * request will be proceed before the sugov thread sleeps.",
            "\t */",
            "\traw_spin_lock_irqsave(&sg_policy->update_lock, flags);",
            "\tfreq = sg_policy->next_freq;",
            "\tsg_policy->work_in_progress = false;",
            "\traw_spin_unlock_irqrestore(&sg_policy->update_lock, flags);",
            "",
            "\tmutex_lock(&sg_policy->work_lock);",
            "\t__cpufreq_driver_target(sg_policy->policy, freq, CPUFREQ_RELATION_L);",
            "\tmutex_unlock(&sg_policy->work_lock);",
            "}",
            "static void sugov_irq_work(struct irq_work *irq_work)",
            "{",
            "\tstruct sugov_policy *sg_policy;",
            "",
            "\tsg_policy = container_of(irq_work, struct sugov_policy, irq_work);",
            "",
            "\tkthread_queue_work(&sg_policy->worker, &sg_policy->work);",
            "}",
            "static ssize_t rate_limit_us_show(struct gov_attr_set *attr_set, char *buf)",
            "{",
            "\tstruct sugov_tunables *tunables = to_sugov_tunables(attr_set);",
            "",
            "\treturn sprintf(buf, \"%u\\n\", tunables->rate_limit_us);",
            "}",
            "static ssize_t",
            "rate_limit_us_store(struct gov_attr_set *attr_set, const char *buf, size_t count)",
            "{",
            "\tstruct sugov_tunables *tunables = to_sugov_tunables(attr_set);",
            "\tstruct sugov_policy *sg_policy;",
            "\tunsigned int rate_limit_us;",
            "",
            "\tif (kstrtouint(buf, 10, &rate_limit_us))",
            "\t\treturn -EINVAL;",
            "",
            "\ttunables->rate_limit_us = rate_limit_us;",
            "",
            "\tlist_for_each_entry(sg_policy, &attr_set->policy_list, tunables_hook)",
            "\t\tsg_policy->freq_update_delay_ns = rate_limit_us * NSEC_PER_USEC;",
            "",
            "\treturn count;",
            "}",
            "static void sugov_tunables_free(struct kobject *kobj)",
            "{",
            "\tstruct gov_attr_set *attr_set = to_gov_attr_set(kobj);",
            "",
            "\tkfree(to_sugov_tunables(attr_set));",
            "}",
            "static void sugov_policy_free(struct sugov_policy *sg_policy)",
            "{",
            "\tkfree(sg_policy);",
            "}",
            "static int sugov_kthread_create(struct sugov_policy *sg_policy)",
            "{",
            "\tstruct task_struct *thread;",
            "\tstruct sched_attr attr = {",
            "\t\t.size\t\t= sizeof(struct sched_attr),",
            "\t\t.sched_policy\t= SCHED_DEADLINE,",
            "\t\t.sched_flags\t= SCHED_FLAG_SUGOV,",
            "\t\t.sched_nice\t= 0,",
            "\t\t.sched_priority\t= 0,",
            "\t\t/*",
            "\t\t * Fake (unused) bandwidth; workaround to \"fix\"",
            "\t\t * priority inheritance.",
            "\t\t */",
            "\t\t.sched_runtime\t=  1000000,",
            "\t\t.sched_deadline = 10000000,",
            "\t\t.sched_period\t= 10000000,",
            "\t};",
            "\tstruct cpufreq_policy *policy = sg_policy->policy;",
            "\tint ret;",
            "",
            "\t/* kthread only required for slow path */",
            "\tif (policy->fast_switch_enabled)",
            "\t\treturn 0;",
            "",
            "\tkthread_init_work(&sg_policy->work, sugov_work);",
            "\tkthread_init_worker(&sg_policy->worker);",
            "\tthread = kthread_create(kthread_worker_fn, &sg_policy->worker,",
            "\t\t\t\t\"sugov:%d\",",
            "\t\t\t\tcpumask_first(policy->related_cpus));",
            "\tif (IS_ERR(thread)) {",
            "\t\tpr_err(\"failed to create sugov thread: %ld\\n\", PTR_ERR(thread));",
            "\t\treturn PTR_ERR(thread);",
            "\t}",
            "",
            "\tret = sched_setattr_nocheck(thread, &attr);",
            "\tif (ret) {",
            "\t\tkthread_stop(thread);",
            "\t\tpr_warn(\"%s: failed to set SCHED_DEADLINE\\n\", __func__);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tsg_policy->thread = thread;",
            "\tkthread_bind_mask(thread, policy->related_cpus);",
            "\tinit_irq_work(&sg_policy->irq_work, sugov_irq_work);",
            "\tmutex_init(&sg_policy->work_lock);",
            "",
            "\twake_up_process(thread);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "sugov_update_shared, sugov_work, sugov_irq_work, rate_limit_us_show, rate_limit_us_store, sugov_tunables_free, sugov_policy_free, sugov_kthread_create",
          "description": "管理频率调节的工作线程和参数配置，sugov_kthread_create创建慢速切换场景的后台线程，rate_limit_us_*/提供速率限制配置接口，sugov_work/sugov_irq_work处理异步频率更新任务。",
          "similarity": 0.615495502948761
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/sched/cpufreq_schedutil.c",
          "start_line": 827,
          "end_line": 916,
          "content": [
            "static int sugov_start(struct cpufreq_policy *policy)",
            "{",
            "\tstruct sugov_policy *sg_policy = policy->governor_data;",
            "\tvoid (*uu)(struct update_util_data *data, u64 time, unsigned int flags);",
            "\tunsigned int cpu;",
            "",
            "\tsg_policy->freq_update_delay_ns\t= sg_policy->tunables->rate_limit_us * NSEC_PER_USEC;",
            "\tsg_policy->last_freq_update_time\t= 0;",
            "\tsg_policy->next_freq\t\t\t= 0;",
            "\tsg_policy->work_in_progress\t\t= false;",
            "\tsg_policy->limits_changed\t\t= false;",
            "\tsg_policy->cached_raw_freq\t\t= 0;",
            "",
            "\tsg_policy->need_freq_update = cpufreq_driver_test_flags(CPUFREQ_NEED_UPDATE_LIMITS);",
            "",
            "\tfor_each_cpu(cpu, policy->cpus) {",
            "\t\tstruct sugov_cpu *sg_cpu = &per_cpu(sugov_cpu, cpu);",
            "",
            "\t\tmemset(sg_cpu, 0, sizeof(*sg_cpu));",
            "\t\tsg_cpu->cpu\t\t\t= cpu;",
            "\t\tsg_cpu->sg_policy\t\t= sg_policy;",
            "\t}",
            "",
            "\tif (policy_is_shared(policy))",
            "\t\tuu = sugov_update_shared;",
            "\telse if (policy->fast_switch_enabled && cpufreq_driver_has_adjust_perf())",
            "\t\tuu = sugov_update_single_perf;",
            "\telse",
            "\t\tuu = sugov_update_single_freq;",
            "",
            "\tfor_each_cpu(cpu, policy->cpus) {",
            "\t\tstruct sugov_cpu *sg_cpu = &per_cpu(sugov_cpu, cpu);",
            "",
            "\t\tcpufreq_add_update_util_hook(cpu, &sg_cpu->update_util, uu);",
            "\t}",
            "\treturn 0;",
            "}",
            "static void sugov_stop(struct cpufreq_policy *policy)",
            "{",
            "\tstruct sugov_policy *sg_policy = policy->governor_data;",
            "\tunsigned int cpu;",
            "",
            "\tfor_each_cpu(cpu, policy->cpus)",
            "\t\tcpufreq_remove_update_util_hook(cpu);",
            "",
            "\tsynchronize_rcu();",
            "",
            "\tif (!policy->fast_switch_enabled) {",
            "\t\tirq_work_sync(&sg_policy->irq_work);",
            "\t\tkthread_cancel_work_sync(&sg_policy->work);",
            "\t}",
            "}",
            "static void sugov_limits(struct cpufreq_policy *policy)",
            "{",
            "\tstruct sugov_policy *sg_policy = policy->governor_data;",
            "",
            "\tif (!policy->fast_switch_enabled) {",
            "\t\tmutex_lock(&sg_policy->work_lock);",
            "\t\tcpufreq_policy_apply_limits(policy);",
            "\t\tmutex_unlock(&sg_policy->work_lock);",
            "\t}",
            "",
            "\t/*",
            "\t * The limits_changed update below must take place before the updates",
            "\t * of policy limits in cpufreq_set_policy() or a policy limits update",
            "\t * might be missed, so use a memory barrier to ensure it.",
            "\t *",
            "\t * This pairs with the memory barrier in sugov_should_update_freq().",
            "\t */",
            "\tsmp_wmb();",
            "",
            "\tWRITE_ONCE(sg_policy->limits_changed, true);",
            "}",
            "static void rebuild_sd_workfn(struct work_struct *work)",
            "{",
            "\trebuild_sched_domains_energy();",
            "}",
            "void sched_cpufreq_governor_change(struct cpufreq_policy *policy,",
            "\t\t\t\t  struct cpufreq_governor *old_gov)",
            "{",
            "\tif (old_gov == &schedutil_gov || policy->governor == &schedutil_gov) {",
            "\t\t/*",
            "\t\t * When called from the cpufreq_register_driver() path, the",
            "\t\t * cpu_hotplug_lock is already held, so use a work item to",
            "\t\t * avoid nested locking in rebuild_sched_domains().",
            "\t\t */",
            "\t\tschedule_work(&rebuild_sd_work);",
            "\t}",
            "",
            "}"
          ],
          "function_name": "sugov_start, sugov_stop, sugov_limits, rebuild_sd_workfn, sched_cpufreq_governor_change",
          "description": "sugov_start 注册CPU利用率更新钩子函数并初始化频率更新参数；sugov_stop 移除所有CPU的更新钩子并同步RCU状态；sugov_limits 应用频率限制并标记策略变更；rebuild_sd_workfn 触发调度域能量重新构建；sched_cpufreq_governor_change 在策略切换时安排调度域重建工作",
          "similarity": 0.615368127822876
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/sched/cpufreq_schedutil.c",
          "start_line": 381,
          "end_line": 496,
          "content": [
            "static inline bool sugov_hold_freq(struct sugov_cpu *sg_cpu) { return false; }",
            "static inline void ignore_dl_rate_limit(struct sugov_cpu *sg_cpu)",
            "{",
            "\tif (cpu_bw_dl(cpu_rq(sg_cpu->cpu)) > sg_cpu->bw_min)",
            "\t\tWRITE_ONCE(sg_cpu->sg_policy->limits_changed, true);",
            "}",
            "static inline bool sugov_update_single_common(struct sugov_cpu *sg_cpu,",
            "\t\t\t\t\t      u64 time, unsigned long max_cap,",
            "\t\t\t\t\t      unsigned int flags)",
            "{",
            "\tunsigned long boost;",
            "",
            "\tsugov_iowait_boost(sg_cpu, time, flags);",
            "\tsg_cpu->last_update = time;",
            "",
            "\tignore_dl_rate_limit(sg_cpu);",
            "",
            "\tif (!sugov_should_update_freq(sg_cpu->sg_policy, time))",
            "\t\treturn false;",
            "",
            "\tboost = sugov_iowait_apply(sg_cpu, time, max_cap);",
            "\tsugov_get_util(sg_cpu, boost);",
            "",
            "\treturn true;",
            "}",
            "static void sugov_update_single_freq(struct update_util_data *hook, u64 time,",
            "\t\t\t\t     unsigned int flags)",
            "{",
            "\tstruct sugov_cpu *sg_cpu = container_of(hook, struct sugov_cpu, update_util);",
            "\tstruct sugov_policy *sg_policy = sg_cpu->sg_policy;",
            "\tunsigned int cached_freq = sg_policy->cached_raw_freq;",
            "\tunsigned long max_cap;",
            "\tunsigned int next_f;",
            "",
            "\tmax_cap = arch_scale_cpu_capacity(sg_cpu->cpu);",
            "",
            "\tif (!sugov_update_single_common(sg_cpu, time, max_cap, flags))",
            "\t\treturn;",
            "",
            "\tnext_f = get_next_freq(sg_policy, sg_cpu->util, max_cap);",
            "",
            "\tif (sugov_hold_freq(sg_cpu) && next_f < sg_policy->next_freq &&",
            "\t    !sg_policy->need_freq_update) {",
            "\t\tnext_f = sg_policy->next_freq;",
            "",
            "\t\t/* Restore cached freq as next_freq has changed */",
            "\t\tsg_policy->cached_raw_freq = cached_freq;",
            "\t}",
            "",
            "\tif (!sugov_update_next_freq(sg_policy, time, next_f))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * This code runs under rq->lock for the target CPU, so it won't run",
            "\t * concurrently on two different CPUs for the same target and it is not",
            "\t * necessary to acquire the lock in the fast switch case.",
            "\t */",
            "\tif (sg_policy->policy->fast_switch_enabled) {",
            "\t\tcpufreq_driver_fast_switch(sg_policy->policy, next_f);",
            "\t} else {",
            "\t\traw_spin_lock(&sg_policy->update_lock);",
            "\t\tsugov_deferred_update(sg_policy);",
            "\t\traw_spin_unlock(&sg_policy->update_lock);",
            "\t}",
            "}",
            "static void sugov_update_single_perf(struct update_util_data *hook, u64 time,",
            "\t\t\t\t     unsigned int flags)",
            "{",
            "\tstruct sugov_cpu *sg_cpu = container_of(hook, struct sugov_cpu, update_util);",
            "\tunsigned long prev_util = sg_cpu->util;",
            "\tunsigned long max_cap;",
            "",
            "\t/*",
            "\t * Fall back to the \"frequency\" path if frequency invariance is not",
            "\t * supported, because the direct mapping between the utilization and",
            "\t * the performance levels depends on the frequency invariance.",
            "\t */",
            "\tif (!arch_scale_freq_invariant()) {",
            "\t\tsugov_update_single_freq(hook, time, flags);",
            "\t\treturn;",
            "\t}",
            "",
            "\tmax_cap = arch_scale_cpu_capacity(sg_cpu->cpu);",
            "",
            "\tif (!sugov_update_single_common(sg_cpu, time, max_cap, flags))",
            "\t\treturn;",
            "",
            "\tif (sugov_hold_freq(sg_cpu) && sg_cpu->util < prev_util)",
            "\t\tsg_cpu->util = prev_util;",
            "",
            "\tcpufreq_driver_adjust_perf(sg_cpu->cpu, sg_cpu->bw_min,",
            "\t\t\t\t   sg_cpu->util, max_cap);",
            "",
            "\tsg_cpu->sg_policy->last_freq_update_time = time;",
            "}",
            "static unsigned int sugov_next_freq_shared(struct sugov_cpu *sg_cpu, u64 time)",
            "{",
            "\tstruct sugov_policy *sg_policy = sg_cpu->sg_policy;",
            "\tstruct cpufreq_policy *policy = sg_policy->policy;",
            "\tunsigned long util = 0, max_cap;",
            "\tunsigned int j;",
            "",
            "\tmax_cap = arch_scale_cpu_capacity(sg_cpu->cpu);",
            "",
            "\tfor_each_cpu(j, policy->cpus) {",
            "\t\tstruct sugov_cpu *j_sg_cpu = &per_cpu(sugov_cpu, j);",
            "\t\tunsigned long boost;",
            "",
            "\t\tboost = sugov_iowait_apply(j_sg_cpu, time, max_cap);",
            "\t\tsugov_get_util(j_sg_cpu, boost);",
            "",
            "\t\tutil = max(j_sg_cpu->util, util);",
            "\t}",
            "",
            "\treturn get_next_freq(sg_policy, util, max_cap);",
            "}"
          ],
          "function_name": "sugov_hold_freq, ignore_dl_rate_limit, sugov_update_single_common, sugov_update_single_freq, sugov_update_single_perf, sugov_next_freq_shared",
          "description": "实现单核/多核频率调整逻辑，sugov_update_single_freq处理单核频率更新，sugov_update_single_perf处理性能调优路径，sugov_next_freq_shared计算多核共享场景下的全局目标频率。",
          "similarity": 0.5983960628509521
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/sched/cpufreq_schedutil.c",
          "start_line": 701,
          "end_line": 809,
          "content": [
            "static void sugov_kthread_stop(struct sugov_policy *sg_policy)",
            "{",
            "\t/* kthread only required for slow path */",
            "\tif (sg_policy->policy->fast_switch_enabled)",
            "\t\treturn;",
            "",
            "\tkthread_flush_worker(&sg_policy->worker);",
            "\tkthread_stop(sg_policy->thread);",
            "\tmutex_destroy(&sg_policy->work_lock);",
            "}",
            "static void sugov_clear_global_tunables(void)",
            "{",
            "\tif (!have_governor_per_policy())",
            "\t\tglobal_tunables = NULL;",
            "}",
            "static int sugov_init(struct cpufreq_policy *policy)",
            "{",
            "\tstruct sugov_policy *sg_policy;",
            "\tstruct sugov_tunables *tunables;",
            "\tint ret = 0;",
            "",
            "\t/* State should be equivalent to EXIT */",
            "\tif (policy->governor_data)",
            "\t\treturn -EBUSY;",
            "",
            "\tcpufreq_enable_fast_switch(policy);",
            "",
            "\tsg_policy = sugov_policy_alloc(policy);",
            "\tif (!sg_policy) {",
            "\t\tret = -ENOMEM;",
            "\t\tgoto disable_fast_switch;",
            "\t}",
            "",
            "\tret = sugov_kthread_create(sg_policy);",
            "\tif (ret)",
            "\t\tgoto free_sg_policy;",
            "",
            "\tmutex_lock(&global_tunables_lock);",
            "",
            "\tif (global_tunables) {",
            "\t\tif (WARN_ON(have_governor_per_policy())) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tgoto stop_kthread;",
            "\t\t}",
            "\t\tpolicy->governor_data = sg_policy;",
            "\t\tsg_policy->tunables = global_tunables;",
            "",
            "\t\tgov_attr_set_get(&global_tunables->attr_set, &sg_policy->tunables_hook);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\ttunables = sugov_tunables_alloc(sg_policy);",
            "\tif (!tunables) {",
            "\t\tret = -ENOMEM;",
            "\t\tgoto stop_kthread;",
            "\t}",
            "",
            "\ttunables->rate_limit_us = cpufreq_policy_transition_delay_us(policy);",
            "",
            "\tpolicy->governor_data = sg_policy;",
            "\tsg_policy->tunables = tunables;",
            "",
            "\tret = kobject_init_and_add(&tunables->attr_set.kobj, &sugov_tunables_ktype,",
            "\t\t\t\t   get_governor_parent_kobj(policy), \"%s\",",
            "\t\t\t\t   schedutil_gov.name);",
            "\tif (ret)",
            "\t\tgoto fail;",
            "",
            "out:",
            "\tmutex_unlock(&global_tunables_lock);",
            "\treturn 0;",
            "",
            "fail:",
            "\tkobject_put(&tunables->attr_set.kobj);",
            "\tpolicy->governor_data = NULL;",
            "\tsugov_clear_global_tunables();",
            "",
            "stop_kthread:",
            "\tsugov_kthread_stop(sg_policy);",
            "\tmutex_unlock(&global_tunables_lock);",
            "",
            "free_sg_policy:",
            "\tsugov_policy_free(sg_policy);",
            "",
            "disable_fast_switch:",
            "\tcpufreq_disable_fast_switch(policy);",
            "",
            "\tpr_err(\"initialization failed (error %d)\\n\", ret);",
            "\treturn ret;",
            "}",
            "static void sugov_exit(struct cpufreq_policy *policy)",
            "{",
            "\tstruct sugov_policy *sg_policy = policy->governor_data;",
            "\tstruct sugov_tunables *tunables = sg_policy->tunables;",
            "\tunsigned int count;",
            "",
            "\tmutex_lock(&global_tunables_lock);",
            "",
            "\tcount = gov_attr_set_put(&tunables->attr_set, &sg_policy->tunables_hook);",
            "\tpolicy->governor_data = NULL;",
            "\tif (!count)",
            "\t\tsugov_clear_global_tunables();",
            "",
            "\tmutex_unlock(&global_tunables_lock);",
            "",
            "\tsugov_kthread_stop(sg_policy);",
            "\tsugov_policy_free(sg_policy);",
            "\tcpufreq_disable_fast_switch(policy);",
            "}"
          ],
          "function_name": "sugov_kthread_stop, sugov_clear_global_tunables, sugov_init, sugov_exit",
          "description": "sugov_kthread_stop 停止慢速路径相关内核线程并释放锁资源；sugov_clear_global_tunables 清除全局调谐参数指针；sugov_init 初始化CPU频率策略模块，分配策略结构体并创建内核线程；sugov_exit 释放策略资源，停止线程并禁用快速切换功能",
          "similarity": 0.5913521647453308
        }
      ]
    },
    {
      "source_file": "kernel/sys.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:30:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sys.c`\n\n---\n\n# `sys.c` 内核源码技术文档\n\n## 1. 文件概述\n\n`sys.c` 是 Linux 内核中实现系统调用（system calls）的核心源文件之一，位于 `kernel/` 目录下。该文件主要负责处理与进程调度优先级、用户/组 ID 溢出处理、系统信息查询等相关的通用系统调用。其历史可追溯至 Linus Torvalds 早期开发阶段，是内核中提供 POSIX 兼容性的重要组成部分。当前文档所涵盖的代码片段聚焦于 `setpriority` 和 `getpriority` 系统调用的实现，以及与 UID/GID 溢出相关的全局变量定义。\n\n## 2. 核心功能\n\n### 全局变量\n- `overflowuid` / `overflowgid`：用于在 32 位 UID/GID 架构中表示无法表示的旧式 16 位 UID/GID 的回退值，默认为 `DEFAULT_OVERFLOWUID`/`DEFAULT_OVERFLOWGID`。\n- `fs_overflowuid` / `fs_overflowgid`：专用于仅支持 16 位 UID/GID 的文件系统的溢出回退值，适用于所有架构。\n\n### 主要函数\n- `set_one_prio_perm(struct task_struct *p)`：检查当前进程是否有权限修改目标进程 `p` 的调度优先级（nice 值）。\n- `set_one_prio(struct task_struct *p, int niceval, int error)`：在权限检查通过后，实际设置目标进程的 nice 值。\n- `SYSCALL_DEFINE3(setpriority, int, which, int, who, int, niceval)`：实现 `setpriority(2)` 系统调用，支持按进程、进程组或用户 ID 修改一组进程的优先级。\n- `SYSCALL_DEFINE2(getpriority, int, which, int, who)`：实现 `getpriority(2)` 系统调用，返回指定范围（进程、进程组、用户）内最高优先级（即最小 nice 值）对应的兼容值。\n\n## 3. 关键实现\n\n### 权限控制机制\n- `set_one_prio_perm()` 函数通过比较当前进程的有效 UID（`euid`）与目标进程的 UID 或有效 UID 是否相等来判断基本权限。\n- 若不满足 UID 匹配，则检查当前进程是否在目标进程所属的用户命名空间（`user_ns`）中拥有 `CAP_SYS_NICE` 能力。\n- 所有凭证（`cred`）访问均在 RCU 读锁保护下进行，确保并发安全。\n\n### 优先级设置逻辑\n- `setpriority` 系统调用首先将用户传入的 `niceval` 限制在 `[MIN_NICE, MAX_NICE]` 范围内（通常为 -20 到 19）。\n- 根据 `which` 参数（`PRIO_PROCESS`、`PRIO_PGRP` 或 `PRIO_USER`）分别处理：\n  - **进程**：通过 `find_task_by_vpid()` 查找目标进程。\n  - **进程组**：使用 `do_each_pid_thread()` 遍历指定进程组内的所有线程。\n  - **用户**：遍历所有进程，筛选 UID 匹配的进程；若目标 UID 非当前用户，则通过 `find_user()` 获取用户结构并最终 `free_uid()` 释放引用。\n- 实际设置前调用 LSM（Linux Security Module）钩子 `security_task_setnice()` 进行安全策略检查。\n\n### 优先级获取的兼容性处理\n- `getpriority` 返回值采用历史兼容格式：将实际 nice 值（-20~19）转换为 `20 - nice`，即返回 1~40 的正整数。\n- 该转换通过 `nice_to_rlimit()` 宏实现（定义在 `<linux/resource.h>` 中）。\n- 返回的是指定范围内**最高优先级**（即最大 `nice_to_rlimit` 值，对应最小实际 nice 值）。\n\n### 架构无关性处理\n- 文件开头通过一系列 `#ifndef` 宏定义（如 `SET_UNALIGN_CTL`、`GET_FP_MODE` 等）为不支持特定 CPU 控制功能的架构提供默认 `-EINVAL` 返回值，避免编译错误。\n\n## 4. 依赖关系\n\n### 头文件依赖\n- **调度子系统**：`<linux/sched.h>` 及其子头文件（如 `sched/task.h`、`sched/cputime.h`）提供任务结构、nice 值操作和遍历接口。\n- **用户/组管理**：`<linux/cred.h>`、`<linux/uidgid.h>`、`<linux/user_namespace.h>` 处理凭证、UID/GID 映射及命名空间。\n- **安全模块**：`<linux/security.h>`、`<linux/capability.h>` 提供 LSM 钩子和能力检查。\n- **进程管理**：`<linux/pid.h>`（通过 `find_vpid` 等）、`<linux/rcupdate.h>`（RCU 锁）、`<linux/task_io_accounting_ops.h>`。\n- **系统调用框架**：`<linux/syscalls.h>`、`<linux/uaccess.h>`。\n- **其他**：`<linux/resource.h>`（`nice_to_rlimit`）、`<linux/utsname.h>`（系统信息）、`<generated/utsrelease.h>`（内核版本）。\n\n### 内核子系统交互\n- **调度器**：通过 `set_user_nice()` 和 `task_nice()` 与核心调度逻辑交互。\n- **用户命名空间**：在 UID 比较和能力检查中依赖用户命名空间隔离机制。\n- **LSM 框架**：调用 `security_task_setnice()` 允许安全模块（如 SELinux、AppArmor）拦截优先级修改。\n- **进程遍历机制**：使用 `for_each_process_thread()` 和 `do_each_pid_thread()` 安全遍历进程列表。\n\n## 5. 使用场景\n\n- **用户空间程序调用 `setpriority()`/`getpriority()`**：如 `nice`、`renice` 命令，或应用程序动态调整自身/子进程 CPU 调度优先级。\n- **系统初始化**：`overflowuid`/`overflowgid` 等变量在内核启动时初始化，供 VFS 和 IPC 子系统在处理旧式 16 位 UID/GID 时使用。\n- **容器与命名空间环境**：在用户命名空间中，`setpriority` 的权限检查基于目标进程的用户命名空间，确保容器内进程无法越权修改宿主机进程优先级。\n- **安全审计与限制**：通过 LSM 钩子，系统可记录或阻止非特权进程提升优先级的行为。\n- **跨架构兼容**：为不支持浮点控制、对齐控制等特性的 CPU 架构提供统一的系统调用接口，避免架构特定代码污染通用逻辑。",
      "similarity": 0.6149173378944397,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/sys.c",
          "start_line": 666,
          "end_line": 811,
          "content": [
            "long __sys_setuid(uid_t uid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkuid_t kuid;",
            "",
            "\tkuid = make_kuid(ns, uid);",
            "\tif (!uid_valid(kuid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (ns_capable_setid(old->user_ns, CAP_SETUID)) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_uid(new, kuid);",
            "\t\tiee_set_cred_suid(new, kuid);",
            "\t\t#else",
            "\t\tnew->suid = new->uid = kuid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(kuid, old->uid)) {",
            "\t\t\tretval = set_user(new);",
            "\t\t\tif (retval < 0)",
            "\t\t\t\tgoto error;",
            "\t\t}",
            "\t} else if (!uid_eq(kuid, old->uid) && !uid_eq(kuid, new->suid)) {",
            "\t\tgoto error;",
            "\t}",
            "",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_euid(new, kuid);",
            "\tiee_set_cred_fsuid(new, kuid);",
            "\t#else",
            "\tnew->fsuid = new->euid = kuid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setuid(new, old, LSM_SETID_ID);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tretval = set_cred_ucounts(new);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tflag_nproc_exceeded(new);",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}",
            "long __sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkuid_t kruid, keuid, ksuid;",
            "\tbool ruid_new, euid_new, suid_new;",
            "",
            "\tkruid = make_kuid(ns, ruid);",
            "\tkeuid = make_kuid(ns, euid);",
            "\tksuid = make_kuid(ns, suid);",
            "",
            "\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((euid != (uid_t) -1) && !uid_valid(keuid))",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((suid != (uid_t) -1) && !uid_valid(ksuid))",
            "\t\treturn -EINVAL;",
            "",
            "\told = current_cred();",
            "",
            "\t/* check for no-op */",
            "\tif ((ruid == (uid_t) -1 || uid_eq(kruid, old->uid)) &&",
            "\t    (euid == (uid_t) -1 || (uid_eq(keuid, old->euid) &&",
            "\t\t\t\t    uid_eq(keuid, old->fsuid))) &&",
            "\t    (suid == (uid_t) -1 || uid_eq(ksuid, old->suid)))",
            "\t\treturn 0;",
            "",
            "\truid_new = ruid != (uid_t) -1        && !uid_eq(kruid, old->uid) &&",
            "\t\t   !uid_eq(kruid, old->euid) && !uid_eq(kruid, old->suid);",
            "\teuid_new = euid != (uid_t) -1        && !uid_eq(keuid, old->uid) &&",
            "\t\t   !uid_eq(keuid, old->euid) && !uid_eq(keuid, old->suid);",
            "\tsuid_new = suid != (uid_t) -1        && !uid_eq(ksuid, old->uid) &&",
            "\t\t   !uid_eq(ksuid, old->euid) && !uid_eq(ksuid, old->suid);",
            "\tif ((ruid_new || euid_new || suid_new) &&",
            "\t    !ns_capable_setid(old->user_ns, CAP_SETUID))",
            "\t\treturn -EPERM;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (ruid != (uid_t) -1) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_uid(new, kruid);",
            "\t\t#else",
            "\t\tnew->uid = kruid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(kruid, old->uid)) {",
            "\t\t\tretval = set_user(new);",
            "\t\t\tif (retval < 0)",
            "\t\t\t\tgoto error;",
            "\t\t}",
            "\t}",
            "\tif (euid != (uid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_euid(new, keuid);",
            "\t\t#else",
            "\t\tnew->euid = keuid;",
            "\t\t#endif",
            "\tif (suid != (uid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_suid(new, ksuid);",
            "\t\t#else",
            "\t\tnew->suid = ksuid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsuid(new, new->euid);",
            "\t#else",
            "\tnew->fsuid = new->euid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setuid(new, old, LSM_SETID_RES);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tretval = set_cred_ucounts(new);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tflag_nproc_exceeded(new);",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "__sys_setuid, __sys_setresuid",
          "description": "实现用户ID调整接口，支持基础UID设置与资源管理UID设置，包含完整性校验和用户结构体更新操作。",
          "similarity": 0.5769752264022827
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sys.c",
          "start_line": 458,
          "end_line": 628,
          "content": [
            "long __sys_setgid(gid_t gid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkgid_t kgid;",
            "",
            "\tkgid = make_kgid(ns, gid);",
            "\tif (!gid_valid(kgid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_sgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t\tiee_set_cred_gid(new, kgid);",
            "\t}",
            "\t\t#else",
            "\t\tnew->gid = new->egid = new->sgid = new->fsgid = kgid;",
            "\t\t#endif",
            "\telse if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t}",
            "\t\t#else",
            "\t\tnew->egid = new->fsgid = kgid;",
            "\t\t#endif",
            "\telse",
            "\t\tgoto error;",
            "",
            "\tretval = security_task_fix_setgid(new, old, LSM_SETID_ID);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}",
            "\telse if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t}",
            "static int set_user(struct cred *new)",
            "{",
            "\tstruct user_struct *new_user;",
            "",
            "\tnew_user = alloc_uid(new->uid);",
            "\tif (!new_user)",
            "\t\treturn -EAGAIN;",
            "",
            "\tfree_uid(new->user);",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_user(new, new_user);",
            "\t#else",
            "\tnew->user = new_user;",
            "\t#endif",
            "\treturn 0;",
            "}",
            "static void flag_nproc_exceeded(struct cred *new)",
            "{",
            "\tif (new->ucounts == current_ucounts())",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * We don't fail in case of NPROC limit excess here because too many",
            "\t * poorly written programs don't check set*uid() return code, assuming",
            "\t * it never fails if called by root.  We may still enforce NPROC limit",
            "\t * for programs doing set*uid()+execve() by harmlessly deferring the",
            "\t * failure to the execve() stage.",
            "\t */",
            "\tif (is_rlimit_overlimit(new->ucounts, UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC)) &&",
            "\t\t\tnew->user != INIT_USER)",
            "\t\tcurrent->flags |= PF_NPROC_EXCEEDED;",
            "\telse",
            "\t\tcurrent->flags &= ~PF_NPROC_EXCEEDED;",
            "}",
            "long __sys_setreuid(uid_t ruid, uid_t euid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkuid_t kruid, keuid;",
            "",
            "\tkruid = make_kuid(ns, ruid);",
            "\tkeuid = make_kuid(ns, euid);",
            "",
            "\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))",
            "\t\treturn -EINVAL;",
            "\tif ((euid != (uid_t) -1) && !uid_valid(keuid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (ruid != (uid_t) -1) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_uid(new, kruid);",
            "\t\t#else",
            "\t\tnew->uid = kruid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(old->uid, kruid) &&",
            "\t\t    !uid_eq(old->euid, kruid) &&",
            "\t\t    !ns_capable_setid(old->user_ns, CAP_SETUID))",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tif (euid != (uid_t) -1) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_euid(new, keuid);",
            "\t\t#else",
            "\t\tnew->euid = keuid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(old->uid, keuid) &&",
            "\t\t    !uid_eq(old->euid, keuid) &&",
            "\t\t    !uid_eq(old->suid, keuid) &&",
            "\t\t    !ns_capable_setid(old->user_ns, CAP_SETUID))",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tif (!uid_eq(new->uid, old->uid)) {",
            "\t\tretval = set_user(new);",
            "\t\tif (retval < 0)",
            "\t\t\tgoto error;",
            "\t}",
            "\tif (ruid != (uid_t) -1 ||",
            "\t    (euid != (uid_t) -1 && !uid_eq(keuid, old->uid)))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_suid(new, new->euid);",
            "\t\t#else",
            "\t\tnew->suid = new->euid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsuid(new, new->euid);",
            "\t#else",
            "\tnew->fsuid = new->euid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setuid(new, old, LSM_SETID_RE);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tretval = set_cred_ucounts(new);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tflag_nproc_exceeded(new);",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "__sys_setgid, if, set_user, flag_nproc_exceeded, __sys_setreuid",
          "description": "实现用户ID调整逻辑，包含用户结构体分配、NPROC限制检测及用户命名空间权限校验，更新进程的有效/实始用户ID。",
          "similarity": 0.5768157243728638
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/sys.c",
          "start_line": 1755,
          "end_line": 1795,
          "content": [
            "static void rlim64_to_rlim(const struct rlimit64 *rlim64, struct rlimit *rlim)",
            "{",
            "\tif (rlim64_is_infinity(rlim64->rlim_cur))",
            "\t\trlim->rlim_cur = RLIM_INFINITY;",
            "\telse",
            "\t\trlim->rlim_cur = (unsigned long)rlim64->rlim_cur;",
            "\tif (rlim64_is_infinity(rlim64->rlim_max))",
            "\t\trlim->rlim_max = RLIM_INFINITY;",
            "\telse",
            "\t\trlim->rlim_max = (unsigned long)rlim64->rlim_max;",
            "}",
            "static int check_prlimit_permission(struct task_struct *task,",
            "\t\t\t\t    unsigned int flags)",
            "{",
            "\tconst struct cred *cred = current_cred(), *tcred;",
            "\tbool id_match;",
            "",
            "\tif (current == task)",
            "\t\treturn 0;",
            "",
            "\ttcred = __task_cred(task);",
            "\tid_match = (uid_eq(cred->uid, tcred->euid) &&",
            "\t\t    uid_eq(cred->uid, tcred->suid) &&",
            "\t\t    uid_eq(cred->uid, tcred->uid)  &&",
            "\t\t    gid_eq(cred->gid, tcred->egid) &&",
            "\t\t    gid_eq(cred->gid, tcred->sgid) &&",
            "\t\t    gid_eq(cred->gid, tcred->gid));",
            "\tif (!id_match && !ns_capable(tcred->user_ns, CAP_SYS_RESOURCE))",
            "\t\treturn -EPERM;",
            "",
            "\treturn security_task_prlimit(cred, tcred, flags);",
            "}",
            "static void accumulate_thread_rusage(struct task_struct *t, struct rusage *r)",
            "{",
            "\tr->ru_nvcsw += t->nvcsw;",
            "\tr->ru_nivcsw += t->nivcsw;",
            "\tr->ru_minflt += t->min_flt;",
            "\tr->ru_majflt += t->maj_flt;",
            "\tr->ru_inblock += task_io_get_inblock(t);",
            "\tr->ru_oublock += task_io_get_oublock(t);",
            "}"
          ],
          "function_name": "rlim64_to_rlim, check_prlimit_permission, accumulate_thread_rusage",
          "description": "该代码块包含三个辅助函数：  \n1. `rlim64_to_rlim` 实现从64位资源限制结构体到传统32位`struct rlimit`的类型转换，处理无穷大的边界条件；  \n2. `check_prlimit_permission` 检查当前进程对目标任务执行`prlimit`系统调用的权限，通过对比有效UID/GID及命名空间能力进行访问控制；  \n3. `accumulate_thread_rusage` 累加子线程的资源使用统计信息至父线程的`rusage`结构，用于进程资源消耗追踪。  \n\n所有函数均基于完整上下文实现，未引入额外API或机制。",
          "similarity": 0.5701249837875366
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/sys.c",
          "start_line": 851,
          "end_line": 966,
          "content": [
            "long __sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkgid_t krgid, kegid, ksgid;",
            "\tbool rgid_new, egid_new, sgid_new;",
            "",
            "\tkrgid = make_kgid(ns, rgid);",
            "\tkegid = make_kgid(ns, egid);",
            "\tksgid = make_kgid(ns, sgid);",
            "",
            "\tif ((rgid != (gid_t) -1) && !gid_valid(krgid))",
            "\t\treturn -EINVAL;",
            "\tif ((egid != (gid_t) -1) && !gid_valid(kegid))",
            "\t\treturn -EINVAL;",
            "\tif ((sgid != (gid_t) -1) && !gid_valid(ksgid))",
            "\t\treturn -EINVAL;",
            "",
            "\told = current_cred();",
            "",
            "\t/* check for no-op */",
            "\tif ((rgid == (gid_t) -1 || gid_eq(krgid, old->gid)) &&",
            "\t    (egid == (gid_t) -1 || (gid_eq(kegid, old->egid) &&",
            "\t\t\t\t    gid_eq(kegid, old->fsgid))) &&",
            "\t    (sgid == (gid_t) -1 || gid_eq(ksgid, old->sgid)))",
            "\t\treturn 0;",
            "",
            "\trgid_new = rgid != (gid_t) -1        && !gid_eq(krgid, old->gid) &&",
            "\t\t   !gid_eq(krgid, old->egid) && !gid_eq(krgid, old->sgid);",
            "\tegid_new = egid != (gid_t) -1        && !gid_eq(kegid, old->gid) &&",
            "\t\t   !gid_eq(kegid, old->egid) && !gid_eq(kegid, old->sgid);",
            "\tsgid_new = sgid != (gid_t) -1        && !gid_eq(ksgid, old->gid) &&",
            "\t\t   !gid_eq(ksgid, old->egid) && !gid_eq(ksgid, old->sgid);",
            "\tif ((rgid_new || egid_new || sgid_new) &&",
            "\t    !ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\treturn -EPERM;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (rgid != (gid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_gid(new, krgid);",
            "\t\t#else",
            "\t\tnew->gid = krgid;",
            "\t\t#endif",
            "\tif (egid != (gid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_egid(new, kegid);",
            "\t\t#else",
            "\t\tnew->egid = kegid;",
            "\t\t#endif",
            "\tif (sgid != (gid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_sgid(new, ksgid);",
            "\t\t#else",
            "\t\tnew->sgid = ksgid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsgid(new, new->egid);",
            "\t#else",
            "\tnew->fsgid = new->egid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setgid(new, old, LSM_SETID_RES);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}",
            "long __sys_setfsuid(uid_t uid)",
            "{",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tuid_t old_fsuid;",
            "\tkuid_t kuid;",
            "",
            "\told = current_cred();",
            "\told_fsuid = from_kuid_munged(old->user_ns, old->fsuid);",
            "",
            "\tkuid = make_kuid(old->user_ns, uid);",
            "\tif (!uid_valid(kuid))",
            "\t\treturn old_fsuid;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn old_fsuid;",
            "",
            "\tif (uid_eq(kuid, old->uid)  || uid_eq(kuid, old->euid)  ||",
            "\t    uid_eq(kuid, old->suid) || uid_eq(kuid, old->fsuid) ||",
            "\t    ns_capable_setid(old->user_ns, CAP_SETUID)) {",
            "\t\tif (!uid_eq(kuid, old->fsuid)) {",
            "\t\t\t#ifdef CONFIG_CREDP",
            "\t\t\tiee_set_cred_fsuid(new, kuid);",
            "\t\t\t#else",
            "\t\t\tnew->fsuid = kuid;",
            "\t\t\t#endif",
            "\t\t\tif (security_task_fix_setuid(new, old, LSM_SETID_FS) == 0)",
            "\t\t\t\tgoto change_okay;",
            "\t\t}",
            "\t}",
            "",
            "\tabort_creds(new);",
            "\treturn old_fsuid;",
            "",
            "change_okay:",
            "\tcommit_creds(new);",
            "\treturn old_fsuid;",
            "}"
          ],
          "function_name": "__sys_setresgid, __sys_setfsuid",
          "description": "实现组ID资源管理接口及文件系统用户ID设置，包含组ID字段更新和文件系统用户ID的权限控制逻辑。",
          "similarity": 0.5688579082489014
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/sys.c",
          "start_line": 182,
          "end_line": 286,
          "content": [
            "static bool set_one_prio_perm(struct task_struct *p)",
            "{",
            "\tconst struct cred *cred = current_cred(), *pcred = __task_cred(p);",
            "",
            "\tif (uid_eq(pcred->uid,  cred->euid) ||",
            "\t    uid_eq(pcred->euid, cred->euid))",
            "\t\treturn true;",
            "\tif (ns_capable(pcred->user_ns, CAP_SYS_NICE))",
            "\t\treturn true;",
            "\treturn false;",
            "}",
            "static int set_one_prio(struct task_struct *p, int niceval, int error)",
            "{",
            "\tint no_nice;",
            "",
            "\tif (!set_one_prio_perm(p)) {",
            "\t\terror = -EPERM;",
            "\t\tgoto out;",
            "\t}",
            "\tif (niceval < task_nice(p) && !can_nice(p, niceval)) {",
            "\t\terror = -EACCES;",
            "\t\tgoto out;",
            "\t}",
            "\tno_nice = security_task_setnice(p, niceval);",
            "\tif (no_nice) {",
            "\t\terror = no_nice;",
            "\t\tgoto out;",
            "\t}",
            "\tif (error == -ESRCH)",
            "\t\terror = 0;",
            "\tset_user_nice(p, niceval);",
            "out:",
            "\treturn error;",
            "}",
            "long __sys_setregid(gid_t rgid, gid_t egid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkgid_t krgid, kegid;",
            "",
            "\tkrgid = make_kgid(ns, rgid);",
            "\tkegid = make_kgid(ns, egid);",
            "",
            "\tif ((rgid != (gid_t) -1) && !gid_valid(krgid))",
            "\t\treturn -EINVAL;",
            "\tif ((egid != (gid_t) -1) && !gid_valid(kegid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (rgid != (gid_t) -1) {",
            "\t\tif (gid_eq(old->gid, krgid) ||",
            "\t\t    gid_eq(old->egid, krgid) ||",
            "\t\t    ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\t\t#ifdef CONFIG_CREDP",
            "\t\t\tiee_set_cred_gid(new, krgid);",
            "\t\t\t#else",
            "\t\t\tnew->gid = krgid;",
            "\t\t\t#endif",
            "\t\telse",
            "\t\t\tgoto error;",
            "\t}",
            "\tif (egid != (gid_t) -1) {",
            "\t\tif (gid_eq(old->gid, kegid) ||",
            "\t\t    gid_eq(old->egid, kegid) ||",
            "\t\t    gid_eq(old->sgid, kegid) ||",
            "\t\t    ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\t\t#ifdef CONFIG_CREDP",
            "\t\t\tiee_set_cred_egid(new, kegid);",
            "\t\t\t#else",
            "\t\t\tnew->egid = kegid;",
            "\t\t\t#endif",
            "\t\telse",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tif (rgid != (gid_t) -1 ||",
            "\t    (egid != (gid_t) -1 && !gid_eq(kegid, old->gid)))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_sgid(new, new->egid);",
            "\t\t#else",
            "\t\tnew->sgid = new->egid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsgid(new, new->egid);",
            "\t#else",
            "\tnew->fsgid = new->egid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setgid(new, old, LSM_SETID_RE);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "set_one_prio_perm, set_one_prio, __sys_setregid",
          "description": "实现组ID调整逻辑，包含优先级调整权限验证及组ID设置，通过cred结构体更新目标进程的gid/egid字段。",
          "similarity": 0.5582967400550842
        }
      ]
    },
    {
      "source_file": "kernel/sched/rt.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:14:51\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\rt.c`\n\n---\n\n# `sched/rt.c` 技术文档\n\n## 1. 文件概述\n\n`sched/rt.c` 是 Linux 内核调度子系统中实现实时（Real-Time, RT）调度类的核心文件，主要支持 `SCHED_FIFO` 和 `SCHED_RR` 两种 POSIX 实时调度策略。该文件负责管理实时任务的运行队列、优先级调度、时间片分配、带宽限制（RT throttling）以及在多核系统（SMP）下的负载均衡机制。此外，它还提供了对实时任务组调度（RT Group Scheduling）的支持，允许通过 cgroups 对实时任务的 CPU 使用进行资源控制。\n\n## 2. 核心功能\n\n### 全局变量\n- `sched_rr_timeslice`：定义 `SCHED_RR` 策略的默认时间片长度（单位：调度 tick）。\n- `max_rt_runtime`：实时任务在单个周期内可使用的最大运行时间上限（通常为 4 小时以上）。\n- `sysctl_sched_rt_period`：实时带宽控制的周期，默认为 1,000,000 微秒（1 秒）。\n- `sysctl_sched_rt_runtime`：每个周期内允许实时任务运行的时间，默认为 950,000 微秒（0.95 秒）。\n\n### sysctl 接口（`CONFIG_SYSCTL` 启用时）\n- `/proc/sys/kernel/sched_rt_period_us`：设置 RT 带宽控制周期。\n- `/proc/sys/kernel/sched_rt_runtime_us`：设置 RT 带宽控制运行时间（可设为 -1 表示无限制）。\n- `/proc/sys/kernel/sched_rr_timeslice_ms`：设置 `SCHED_RR` 时间片（毫秒）。\n\n### 主要函数\n- `init_rt_rq(struct rt_rq *rt_rq)`：初始化实时运行队列（`rt_rq`），包括优先级位图、链表、SMP 相关字段及带宽控制状态。\n- `init_rt_bandwidth(struct rt_bandwidth *rt_b, u64 period, u64 runtime)`：初始化 RT 带宽控制结构，配置高精度定时器。\n- `sched_rt_period_timer(struct hrtimer *timer)`：高精度定时器回调函数，用于周期性重置 RT 运行时间配额。\n- `start_rt_bandwidth(struct rt_bandwidth *rt_b)`：启动 RT 带宽控制定时器。\n- `alloc_rt_sched_group / free_rt_sched_group / unregister_rt_sched_group`：管理实时任务组（task group）的资源分配与释放。\n- `init_tg_rt_entry`：初始化任务组在指定 CPU 上的 RT 调度实体和运行队列。\n- `rt_task_of / rq_of_rt_rq / rt_rq_of_se / rq_of_rt_se`：辅助函数，用于在调度实体、任务、运行队列和 CPU 队列之间相互转换。\n\n### SMP 支持函数（`CONFIG_SMP` 启用时）\n- `need_pull_rt_task`：判断是否需要从其他 CPU 拉取高优先级 RT 任务。\n- `rt_overloaded` / `rt_set_overload`：用于跟踪系统中是否存在过载的 RT 运行队列，支持 RT 任务迁移。\n\n## 3. 关键实现\n\n### 实时运行队列（`rt_rq`）管理\n- 使用 `rt_prio_array` 结构维护 0 到 `MAX_RT_PRIO-1`（通常为 99）共 100 个优先级的双向链表。\n- 通过位图（`bitmap`）快速查找最高优先级的可运行任务，`__set_bit(MAX_RT_PRIO, bitmap)` 作为位图搜索的终止标记。\n- `rt_queued` 标志表示是否有 RT 任务入队；`highest_prio.curr/next` 跟踪当前和下一个最高优先级（SMP 专用）。\n\n### RT 带宽控制（Throttling）\n- 通过 `rt_bandwidth` 结构限制 RT 任务在每个 `rt_period` 内最多使用 `rt_runtime` 的 CPU 时间。\n- 使用高精度定时器（`hrtimer`）实现周期性重置：每经过 `rt_period`，将 `rt_time` 清零并解除 throttling。\n- 若 `rt_runtime == RUNTIME_INF`（即 -1），则禁用带宽限制。\n- 定时器回调 `sched_rt_period_timer` 支持处理定时器 overrun（跳过多个周期），确保带宽控制的准确性。\n\n### RT 任务组调度（`CONFIG_RT_GROUP_SCHED`）\n- 每个 `task_group` 拥有 per-CPU 的 `rt_rq` 和 `sched_rt_entity`。\n- 根叶节点（普通任务）的 `rt_se` 直接链接到 CPU 的全局 `rt_rq`；非叶节点（cgroup）的 `rt_se` 链接到父组的 `rt_rq`，形成调度树。\n- `rt_entity_is_task()` 用于区分调度实体是任务还是任务组。\n\n### SMP 负载均衡\n- 当某 CPU 上运行的 RT 任务优先级降低（如被抢占或阻塞），若其当前最高优先级高于刚被替换的任务，则触发 `need_pull_rt_task`，尝试从其他 CPU 拉取更高优先级的 RT 任务。\n- `overloaded` 标志和 `pushable_tasks` 链表用于支持 RT 任务的主动推送（push）和拉取（pull）机制，确保高优先级任务尽快运行。\n\n## 4. 依赖关系\n\n- **调度核心**：依赖 `kernel/sched/core.c` 提供的通用调度框架、运行队列（`rq`）结构和调度类注册机制。\n- **高精度定时器**：使用 `kernel/time/hrtimer.c` 实现 RT 带宽控制的周期性重置。\n- **SMP 调度**：与 `kernel/sched/topology.c` 和 `kernel/sched/fair.c` 协同实现跨 CPU 的 RT 任务迁移。\n- **cgroups**：当启用 `CONFIG_RT_GROUP_SCHED` 时，与 `kernel/cgroup/` 子系统集成，支持基于 cgroup v1/v2 的 RT 带宽分配。\n- **sysctl**：通过 `kernel/sysctl.c` 暴露运行时可调参数。\n\n## 5. 使用场景\n\n- **实时应用调度**：为音视频处理、工业控制、机器人等需要确定性延迟的应用提供 `SCHED_FIFO`/`SCHED_RR` 调度支持。\n- **系统资源保护**：通过 `sched_rt_runtime_us` 限制 RT 任务的 CPU 占用率（默认 95%），防止其独占 CPU 导致系统僵死。\n- **多租户 RT 资源隔离**：在容器或虚拟化环境中，利用 RT 任务组调度为不同租户分配独立的 RT 带宽配额。\n- **SMP 实时性能优化**：在多核系统中，通过 RT 任务迁移机制减少高优先级任务的调度延迟，提升实时响应能力。",
      "similarity": 0.6147981882095337,
      "chunks": [
        {
          "chunk_id": 13,
          "file_path": "kernel/sched/rt.c",
          "start_line": 1776,
          "end_line": 1992,
          "content": [
            "static int pick_rt_task(struct rq *rq, struct task_struct *p, int cpu)",
            "{",
            "\tif (!task_on_cpu(rq, p) &&",
            "\t    cpumask_test_cpu(cpu, &p->cpus_mask))",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static int find_lowest_rq(struct task_struct *task)",
            "{",
            "\tstruct sched_domain *sd;",
            "\tstruct cpumask *lowest_mask = this_cpu_cpumask_var_ptr(local_cpu_mask);",
            "\tint this_cpu = smp_processor_id();",
            "\tint cpu      = task_cpu(task);",
            "\tint ret;",
            "",
            "\t/* Make sure the mask is initialized first */",
            "\tif (unlikely(!lowest_mask))",
            "\t\treturn -1;",
            "",
            "\tif (task->nr_cpus_allowed == 1)",
            "\t\treturn -1; /* No other targets possible */",
            "",
            "\t/*",
            "\t * If we're on asym system ensure we consider the different capacities",
            "\t * of the CPUs when searching for the lowest_mask.",
            "\t */",
            "\tif (sched_asym_cpucap_active()) {",
            "",
            "\t\tret = cpupri_find_fitness(&task_rq(task)->rd->cpupri,",
            "\t\t\t\t\t  task, lowest_mask,",
            "\t\t\t\t\t  rt_task_fits_capacity);",
            "\t} else {",
            "",
            "\t\tret = cpupri_find(&task_rq(task)->rd->cpupri,",
            "\t\t\t\t  task, lowest_mask);",
            "\t}",
            "",
            "\tif (!ret)",
            "\t\treturn -1; /* No targets found */",
            "",
            "\t/*",
            "\t * At this point we have built a mask of CPUs representing the",
            "\t * lowest priority tasks in the system.  Now we want to elect",
            "\t * the best one based on our affinity and topology.",
            "\t *",
            "\t * We prioritize the last CPU that the task executed on since",
            "\t * it is most likely cache-hot in that location.",
            "\t */",
            "\tif (cpumask_test_cpu(cpu, lowest_mask))",
            "\t\treturn cpu;",
            "",
            "\t/*",
            "\t * Otherwise, we consult the sched_domains span maps to figure",
            "\t * out which CPU is logically closest to our hot cache data.",
            "\t */",
            "\tif (!cpumask_test_cpu(this_cpu, lowest_mask))",
            "\t\tthis_cpu = -1; /* Skip this_cpu opt if not among lowest */",
            "",
            "\trcu_read_lock();",
            "\tfor_each_domain(cpu, sd) {",
            "\t\tif (sd->flags & SD_WAKE_AFFINE) {",
            "\t\t\tint best_cpu;",
            "",
            "\t\t\t/*",
            "\t\t\t * \"this_cpu\" is cheaper to preempt than a",
            "\t\t\t * remote processor.",
            "\t\t\t */",
            "\t\t\tif (this_cpu != -1 &&",
            "\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {",
            "\t\t\t\trcu_read_unlock();",
            "\t\t\t\treturn this_cpu;",
            "\t\t\t}",
            "",
            "\t\t\tbest_cpu = cpumask_any_and_distribute(lowest_mask,",
            "\t\t\t\t\t\t\t      sched_domain_span(sd));",
            "\t\t\tif (best_cpu < nr_cpu_ids) {",
            "\t\t\t\trcu_read_unlock();",
            "\t\t\t\treturn best_cpu;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * And finally, if there were no matches within the domains",
            "\t * just give the caller *something* to work with from the compatible",
            "\t * locations.",
            "\t */",
            "\tif (this_cpu != -1)",
            "\t\treturn this_cpu;",
            "",
            "\tcpu = cpumask_any_distribute(lowest_mask);",
            "\tif (cpu < nr_cpu_ids)",
            "\t\treturn cpu;",
            "",
            "\treturn -1;",
            "}",
            "static int push_rt_task(struct rq *rq, bool pull)",
            "{",
            "\tstruct task_struct *next_task;",
            "\tstruct rq *lowest_rq;",
            "\tint ret = 0;",
            "",
            "\tif (!rq->rt.overloaded)",
            "\t\treturn 0;",
            "",
            "\tnext_task = pick_next_pushable_task(rq);",
            "\tif (!next_task)",
            "\t\treturn 0;",
            "",
            "retry:",
            "\t/*",
            "\t * It's possible that the next_task slipped in of",
            "\t * higher priority than current. If that's the case",
            "\t * just reschedule current.",
            "\t */",
            "\tif (unlikely(next_task->prio < rq->curr->prio)) {",
            "\t\tresched_curr(rq);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tif (is_migration_disabled(next_task)) {",
            "\t\tstruct task_struct *push_task = NULL;",
            "\t\tint cpu;",
            "",
            "\t\tif (!pull || rq->push_busy)",
            "\t\t\treturn 0;",
            "",
            "\t\t/*",
            "\t\t * Invoking find_lowest_rq() on anything but an RT task doesn't",
            "\t\t * make sense. Per the above priority check, curr has to",
            "\t\t * be of higher priority than next_task, so no need to",
            "\t\t * reschedule when bailing out.",
            "\t\t *",
            "\t\t * Note that the stoppers are masqueraded as SCHED_FIFO",
            "\t\t * (cf. sched_set_stop_task()), so we can't rely on rt_task().",
            "\t\t */",
            "\t\tif (rq->curr->sched_class != &rt_sched_class)",
            "\t\t\treturn 0;",
            "",
            "\t\tcpu = find_lowest_rq(rq->curr);",
            "\t\tif (cpu == -1 || cpu == rq->cpu)",
            "\t\t\treturn 0;",
            "",
            "\t\t/*",
            "\t\t * Given we found a CPU with lower priority than @next_task,",
            "\t\t * therefore it should be running. However we cannot migrate it",
            "\t\t * to this other CPU, instead attempt to push the current",
            "\t\t * running task on this CPU away.",
            "\t\t */",
            "\t\tpush_task = get_push_task(rq);",
            "\t\tif (push_task) {",
            "\t\t\tpreempt_disable();",
            "\t\t\traw_spin_rq_unlock(rq);",
            "\t\t\tstop_one_cpu_nowait(rq->cpu, push_cpu_stop,",
            "\t\t\t\t\t    push_task, &rq->push_work);",
            "\t\t\tpreempt_enable();",
            "\t\t\traw_spin_rq_lock(rq);",
            "\t\t}",
            "",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tif (WARN_ON(next_task == rq->curr))",
            "\t\treturn 0;",
            "",
            "\t/* We might release rq lock */",
            "\tget_task_struct(next_task);",
            "",
            "\t/* find_lock_lowest_rq locks the rq if found */",
            "\tlowest_rq = find_lock_lowest_rq(next_task, rq);",
            "\tif (!lowest_rq) {",
            "\t\tstruct task_struct *task;",
            "\t\t/*",
            "\t\t * find_lock_lowest_rq releases rq->lock",
            "\t\t * so it is possible that next_task has migrated.",
            "\t\t *",
            "\t\t * We need to make sure that the task is still on the same",
            "\t\t * run-queue and is also still the next task eligible for",
            "\t\t * pushing.",
            "\t\t */",
            "\t\ttask = pick_next_pushable_task(rq);",
            "\t\tif (task == next_task) {",
            "\t\t\t/*",
            "\t\t\t * The task hasn't migrated, and is still the next",
            "\t\t\t * eligible task, but we failed to find a run-queue",
            "\t\t\t * to push it to.  Do not retry in this case, since",
            "\t\t\t * other CPUs will pull from us when ready.",
            "\t\t\t */",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tif (!task)",
            "\t\t\t/* No more tasks, just exit */",
            "\t\t\tgoto out;",
            "",
            "\t\t/*",
            "\t\t * Something has shifted, try again.",
            "\t\t */",
            "\t\tput_task_struct(next_task);",
            "\t\tnext_task = task;",
            "\t\tgoto retry;",
            "\t}",
            "",
            "\tdeactivate_task(rq, next_task, 0);",
            "\tset_task_cpu(next_task, lowest_rq->cpu);",
            "\tactivate_task(lowest_rq, next_task, 0);",
            "\tresched_curr(lowest_rq);",
            "\tret = 1;",
            "",
            "\tdouble_unlock_balance(rq, lowest_rq);",
            "out:",
            "\tput_task_struct(next_task);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "pick_rt_task, find_lowest_rq, push_rt_task",
          "description": "实现实时任务选择算法、低优先级CPU搜索及强制迁移逻辑，支持异构系统下的能效优化和拓扑感知调度。",
          "similarity": 0.6749006509780884
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/sched/rt.c",
          "start_line": 1449,
          "end_line": 1589,
          "content": [
            "static void dequeue_rt_entity(struct sched_rt_entity *rt_se, unsigned int flags)",
            "{",
            "\tstruct rq *rq = rq_of_rt_se(rt_se);",
            "",
            "\tupdate_stats_dequeue_rt(rt_rq_of_se(rt_se), rt_se, flags);",
            "",
            "\tdequeue_rt_stack(rt_se, flags);",
            "",
            "\tfor_each_sched_rt_entity(rt_se) {",
            "\t\tstruct rt_rq *rt_rq = group_rt_rq(rt_se);",
            "",
            "\t\tif (rt_rq && rt_rq->rt_nr_running)",
            "\t\t\t__enqueue_rt_entity(rt_se, flags);",
            "\t}",
            "\tenqueue_top_rt_rq(&rq->rt);",
            "}",
            "static void",
            "enqueue_task_rt(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tstruct sched_rt_entity *rt_se = &p->rt;",
            "",
            "\tif (flags & ENQUEUE_WAKEUP)",
            "\t\trt_se->timeout = 0;",
            "",
            "\tcheck_schedstat_required();",
            "\tupdate_stats_wait_start_rt(rt_rq_of_se(rt_se), rt_se);",
            "",
            "\tenqueue_rt_entity(rt_se, flags);",
            "",
            "\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)",
            "\t\tenqueue_pushable_task(rq, p);",
            "}",
            "static bool dequeue_task_rt(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tstruct sched_rt_entity *rt_se = &p->rt;",
            "",
            "\tupdate_curr_rt(rq);",
            "\tdequeue_rt_entity(rt_se, flags);",
            "",
            "\tdequeue_pushable_task(rq, p);",
            "",
            "\treturn true;",
            "}",
            "static void",
            "requeue_rt_entity(struct rt_rq *rt_rq, struct sched_rt_entity *rt_se, int head)",
            "{",
            "\tif (on_rt_rq(rt_se)) {",
            "\t\tstruct rt_prio_array *array = &rt_rq->active;",
            "\t\tstruct list_head *queue = array->queue + rt_se_prio(rt_se);",
            "",
            "\t\tif (head)",
            "\t\t\tlist_move(&rt_se->run_list, queue);",
            "\t\telse",
            "\t\t\tlist_move_tail(&rt_se->run_list, queue);",
            "\t}",
            "}",
            "static void requeue_task_rt(struct rq *rq, struct task_struct *p, int head)",
            "{",
            "\tstruct sched_rt_entity *rt_se = &p->rt;",
            "\tstruct rt_rq *rt_rq;",
            "",
            "\tfor_each_sched_rt_entity(rt_se) {",
            "\t\trt_rq = rt_rq_of_se(rt_se);",
            "\t\trequeue_rt_entity(rt_rq, rt_se, head);",
            "\t}",
            "}",
            "static void yield_task_rt(struct rq *rq)",
            "{",
            "\trequeue_task_rt(rq, rq->curr, 0);",
            "}",
            "static int",
            "select_task_rq_rt(struct task_struct *p, int cpu, int flags)",
            "{",
            "\tstruct task_struct *curr;",
            "\tstruct rq *rq;",
            "\tbool test;",
            "",
            "\t/* For anything but wake ups, just return the task_cpu */",
            "\tif (!(flags & (WF_TTWU | WF_FORK)))",
            "\t\tgoto out;",
            "",
            "\trq = cpu_rq(cpu);",
            "",
            "\trcu_read_lock();",
            "\tcurr = READ_ONCE(rq->curr); /* unlocked access */",
            "",
            "\t/*",
            "\t * If the current task on @p's runqueue is an RT task, then",
            "\t * try to see if we can wake this RT task up on another",
            "\t * runqueue. Otherwise simply start this RT task",
            "\t * on its current runqueue.",
            "\t *",
            "\t * We want to avoid overloading runqueues. If the woken",
            "\t * task is a higher priority, then it will stay on this CPU",
            "\t * and the lower prio task should be moved to another CPU.",
            "\t * Even though this will probably make the lower prio task",
            "\t * lose its cache, we do not want to bounce a higher task",
            "\t * around just because it gave up its CPU, perhaps for a",
            "\t * lock?",
            "\t *",
            "\t * For equal prio tasks, we just let the scheduler sort it out.",
            "\t *",
            "\t * Otherwise, just let it ride on the affined RQ and the",
            "\t * post-schedule router will push the preempted task away",
            "\t *",
            "\t * This test is optimistic, if we get it wrong the load-balancer",
            "\t * will have to sort it out.",
            "\t *",
            "\t * We take into account the capacity of the CPU to ensure it fits the",
            "\t * requirement of the task - which is only important on heterogeneous",
            "\t * systems like big.LITTLE.",
            "\t */",
            "\ttest = curr &&",
            "\t       unlikely(rt_task(curr)) &&",
            "\t       (curr->nr_cpus_allowed < 2 || curr->prio <= p->prio);",
            "",
            "\tif (test || !rt_task_fits_capacity(p, cpu)) {",
            "\t\tint target = find_lowest_rq(p);",
            "",
            "\t\t/*",
            "\t\t * Bail out if we were forcing a migration to find a better",
            "\t\t * fitting CPU but our search failed.",
            "\t\t */",
            "\t\tif (!test && target != -1 && !rt_task_fits_capacity(p, target))",
            "\t\t\tgoto out_unlock;",
            "",
            "\t\t/*",
            "\t\t * Don't bother moving it if the destination CPU is",
            "\t\t * not running a lower priority task.",
            "\t\t */",
            "\t\tif (target != -1 &&",
            "\t\t    p->prio < cpu_rq(target)->rt.highest_prio.curr)",
            "\t\t\tcpu = target;",
            "\t}",
            "",
            "out_unlock:",
            "\trcu_read_unlock();",
            "",
            "out:",
            "\treturn cpu;",
            "}"
          ],
          "function_name": "dequeue_rt_entity, enqueue_task_rt, dequeue_task_rt, requeue_rt_entity, requeue_task_rt, yield_task_rt, select_task_rq_rt",
          "description": "实现实时任务的出队逻辑、唤醒和迁移策略，提供CPU亲和性选择及负载均衡支持，维护优先级队列的动态调整。",
          "similarity": 0.6473381519317627
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/sched/rt.c",
          "start_line": 529,
          "end_line": 633,
          "content": [
            "static void sched_rt_rq_enqueue(struct rt_rq *rt_rq)",
            "{",
            "\tstruct task_struct *curr = rq_of_rt_rq(rt_rq)->curr;",
            "\tstruct rq *rq = rq_of_rt_rq(rt_rq);",
            "\tstruct sched_rt_entity *rt_se;",
            "",
            "\tint cpu = cpu_of(rq);",
            "",
            "\trt_se = rt_rq->tg->rt_se[cpu];",
            "",
            "\tif (rt_rq->rt_nr_running) {",
            "\t\tif (!rt_se)",
            "\t\t\tenqueue_top_rt_rq(rt_rq);",
            "\t\telse if (!on_rt_rq(rt_se))",
            "\t\t\tenqueue_rt_entity(rt_se, 0);",
            "",
            "\t\tif (rt_rq->highest_prio.curr < curr->prio)",
            "\t\t\tresched_curr(rq);",
            "\t}",
            "}",
            "static void sched_rt_rq_dequeue(struct rt_rq *rt_rq)",
            "{",
            "\tstruct sched_rt_entity *rt_se;",
            "\tint cpu = cpu_of(rq_of_rt_rq(rt_rq));",
            "",
            "\trt_se = rt_rq->tg->rt_se[cpu];",
            "",
            "\tif (!rt_se) {",
            "\t\tdequeue_top_rt_rq(rt_rq, rt_rq->rt_nr_running);",
            "\t\t/* Kick cpufreq (see the comment in kernel/sched/sched.h). */",
            "\t\tcpufreq_update_util(rq_of_rt_rq(rt_rq), 0);",
            "\t}",
            "\telse if (on_rt_rq(rt_se))",
            "\t\tdequeue_rt_entity(rt_se, 0);",
            "}",
            "static inline int rt_rq_throttled(struct rt_rq *rt_rq)",
            "{",
            "\treturn rt_rq->rt_throttled && !rt_rq->rt_nr_boosted;",
            "}",
            "static int rt_se_boosted(struct sched_rt_entity *rt_se)",
            "{",
            "\tstruct rt_rq *rt_rq = group_rt_rq(rt_se);",
            "\tstruct task_struct *p;",
            "",
            "\tif (rt_rq)",
            "\t\treturn !!rt_rq->rt_nr_boosted;",
            "",
            "\tp = rt_task_of(rt_se);",
            "\treturn p->prio != p->normal_prio;",
            "}",
            "bool sched_rt_bandwidth_account(struct rt_rq *rt_rq)",
            "{",
            "\tstruct rt_bandwidth *rt_b = sched_rt_bandwidth(rt_rq);",
            "",
            "\treturn (hrtimer_active(&rt_b->rt_period_timer) ||",
            "\t\trt_rq->rt_time < rt_b->rt_runtime);",
            "}",
            "static void do_balance_runtime(struct rt_rq *rt_rq)",
            "{",
            "\tstruct rt_bandwidth *rt_b = sched_rt_bandwidth(rt_rq);",
            "\tstruct root_domain *rd = rq_of_rt_rq(rt_rq)->rd;",
            "\tint i, weight;",
            "\tu64 rt_period;",
            "",
            "\tweight = cpumask_weight(rd->span);",
            "",
            "\traw_spin_lock(&rt_b->rt_runtime_lock);",
            "\trt_period = ktime_to_ns(rt_b->rt_period);",
            "\tfor_each_cpu(i, rd->span) {",
            "\t\tstruct rt_rq *iter = sched_rt_period_rt_rq(rt_b, i);",
            "\t\ts64 diff;",
            "",
            "\t\tif (iter == rt_rq)",
            "\t\t\tcontinue;",
            "",
            "\t\traw_spin_lock(&iter->rt_runtime_lock);",
            "\t\t/*",
            "\t\t * Either all rqs have inf runtime and there's nothing to steal",
            "\t\t * or __disable_runtime() below sets a specific rq to inf to",
            "\t\t * indicate its been disabled and disallow stealing.",
            "\t\t */",
            "\t\tif (iter->rt_runtime == RUNTIME_INF)",
            "\t\t\tgoto next;",
            "",
            "\t\t/*",
            "\t\t * From runqueues with spare time, take 1/n part of their",
            "\t\t * spare time, but no more than our period.",
            "\t\t */",
            "\t\tdiff = iter->rt_runtime - iter->rt_time;",
            "\t\tif (diff > 0) {",
            "\t\t\tdiff = div_u64((u64)diff, weight);",
            "\t\t\tif (rt_rq->rt_runtime + diff > rt_period)",
            "\t\t\t\tdiff = rt_period - rt_rq->rt_runtime;",
            "\t\t\titer->rt_runtime -= diff;",
            "\t\t\trt_rq->rt_runtime += diff;",
            "\t\t\tif (rt_rq->rt_runtime == rt_period) {",
            "\t\t\t\traw_spin_unlock(&iter->rt_runtime_lock);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "next:",
            "\t\traw_spin_unlock(&iter->rt_runtime_lock);",
            "\t}",
            "\traw_spin_unlock(&rt_b->rt_runtime_lock);",
            "}"
          ],
          "function_name": "sched_rt_rq_enqueue, sched_rt_rq_dequeue, rt_rq_throttled, rt_se_boosted, sched_rt_bandwidth_account, do_balance_runtime",
          "description": "实现实时任务队列的插入/移除逻辑，跟踪运行时间消耗，通过跨CPU运行时间平衡算法实现带宽公平分配。",
          "similarity": 0.6446036696434021
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/sched/rt.c",
          "start_line": 1607,
          "end_line": 1716,
          "content": [
            "static void check_preempt_equal_prio(struct rq *rq, struct task_struct *p)",
            "{",
            "\t/*",
            "\t * Current can't be migrated, useless to reschedule,",
            "\t * let's hope p can move out.",
            "\t */",
            "\tif (rq->curr->nr_cpus_allowed == 1 ||",
            "\t    !cpupri_find(&rq->rd->cpupri, rq->curr, NULL))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * p is migratable, so let's not schedule it and",
            "\t * see if it is pushed or pulled somewhere else.",
            "\t */",
            "\tif (p->nr_cpus_allowed != 1 &&",
            "\t    cpupri_find(&rq->rd->cpupri, p, NULL))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * There appear to be other CPUs that can accept",
            "\t * the current task but none can run 'p', so lets reschedule",
            "\t * to try and push the current task away:",
            "\t */",
            "\trequeue_task_rt(rq, p, 1);",
            "\tresched_curr(rq);",
            "}",
            "static int balance_rt(struct rq *rq, struct task_struct *p, struct rq_flags *rf)",
            "{",
            "\tif (!on_rt_rq(&p->rt) && need_pull_rt_task(rq, p)) {",
            "\t\t/*",
            "\t\t * This is OK, because current is on_cpu, which avoids it being",
            "\t\t * picked for load-balance and preemption/IRQs are still",
            "\t\t * disabled avoiding further scheduler activity on it and we've",
            "\t\t * not yet started the picking loop.",
            "\t\t */",
            "\t\trq_unpin_lock(rq, rf);",
            "\t\tpull_rt_task(rq);",
            "\t\trq_repin_lock(rq, rf);",
            "\t}",
            "",
            "\treturn sched_stop_runnable(rq) || sched_dl_runnable(rq) || sched_rt_runnable(rq);",
            "}",
            "static void wakeup_preempt_rt(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tif (p->prio < rq->curr->prio) {",
            "\t\tresched_curr(rq);",
            "\t\treturn;",
            "\t}",
            "",
            "#ifdef CONFIG_SMP",
            "\t/*",
            "\t * If:",
            "\t *",
            "\t * - the newly woken task is of equal priority to the current task",
            "\t * - the newly woken task is non-migratable while current is migratable",
            "\t * - current will be preempted on the next reschedule",
            "\t *",
            "\t * we should check to see if current can readily move to a different",
            "\t * cpu.  If so, we will reschedule to allow the push logic to try",
            "\t * to move current somewhere else, making room for our non-migratable",
            "\t * task.",
            "\t */",
            "\tif (p->prio == rq->curr->prio && !test_tsk_need_resched(rq->curr))",
            "\t\tcheck_preempt_equal_prio(rq, p);",
            "#endif",
            "}",
            "static inline void set_next_task_rt(struct rq *rq, struct task_struct *p, bool first)",
            "{",
            "\tstruct sched_rt_entity *rt_se = &p->rt;",
            "\tstruct rt_rq *rt_rq = &rq->rt;",
            "",
            "\tp->se.exec_start = rq_clock_task(rq);",
            "\tif (on_rt_rq(&p->rt))",
            "\t\tupdate_stats_wait_end_rt(rt_rq, rt_se);",
            "",
            "\t/* The running task is never eligible for pushing */",
            "\tdequeue_pushable_task(rq, p);",
            "",
            "\tif (!first)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * If prev task was rt, put_prev_task() has already updated the",
            "\t * utilization. We only care of the case where we start to schedule a",
            "\t * rt task",
            "\t */",
            "\tif (rq->curr->sched_class != &rt_sched_class)",
            "\t\tupdate_rt_rq_load_avg(rq_clock_pelt(rq), rq, 0);",
            "",
            "\trt_queue_push_tasks(rq);",
            "}",
            "static void put_prev_task_rt(struct rq *rq, struct task_struct *p, struct task_struct *next)",
            "{",
            "\tstruct sched_rt_entity *rt_se = &p->rt;",
            "\tstruct rt_rq *rt_rq = &rq->rt;",
            "",
            "\tif (on_rt_rq(&p->rt))",
            "\t\tupdate_stats_wait_start_rt(rt_rq, rt_se);",
            "",
            "\tupdate_curr_rt(rq);",
            "",
            "\tupdate_rt_rq_load_avg(rq_clock_pelt(rq), rq, 1);",
            "",
            "\t/*",
            "\t * The previous task needs to be made eligible for pushing",
            "\t * if it is still active",
            "\t */",
            "\tif (on_rt_rq(&p->rt) && p->nr_cpus_allowed > 1)",
            "\t\tenqueue_pushable_task(rq, p);",
            "}"
          ],
          "function_name": "check_preempt_equal_prio, balance_rt, wakeup_preempt_rt, set_next_task_rt, put_prev_task_rt",
          "description": "实现同优先级抢占检测、实时任务负载平衡、唤醒抢占触发机制以及调度器状态更新与负载计算。",
          "similarity": 0.6438588500022888
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/rt.c",
          "start_line": 57,
          "end_line": 159,
          "content": [
            "static int __init sched_rt_sysctl_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", sched_rt_sysctls);",
            "\treturn 0;",
            "}",
            "void init_rt_rq(struct rt_rq *rt_rq)",
            "{",
            "\tstruct rt_prio_array *array;",
            "\tint i;",
            "",
            "\tarray = &rt_rq->active;",
            "\tfor (i = 0; i < MAX_RT_PRIO; i++) {",
            "\t\tINIT_LIST_HEAD(array->queue + i);",
            "\t\t__clear_bit(i, array->bitmap);",
            "\t}",
            "\t/* delimiter for bitsearch: */",
            "\t__set_bit(MAX_RT_PRIO, array->bitmap);",
            "",
            "#if defined CONFIG_SMP",
            "\trt_rq->highest_prio.curr = MAX_RT_PRIO-1;",
            "\trt_rq->highest_prio.next = MAX_RT_PRIO-1;",
            "\trt_rq->overloaded = 0;",
            "\tplist_head_init(&rt_rq->pushable_tasks);",
            "#endif /* CONFIG_SMP */",
            "\t/* We start is dequeued state, because no RT tasks are queued */",
            "\trt_rq->rt_queued = 0;",
            "",
            "#ifdef CONFIG_RT_GROUP_SCHED",
            "\trt_rq->rt_time = 0;",
            "\trt_rq->rt_throttled = 0;",
            "\trt_rq->rt_runtime = 0;",
            "\traw_spin_lock_init(&rt_rq->rt_runtime_lock);",
            "#endif",
            "}",
            "static enum hrtimer_restart sched_rt_period_timer(struct hrtimer *timer)",
            "{",
            "\tstruct rt_bandwidth *rt_b =",
            "\t\tcontainer_of(timer, struct rt_bandwidth, rt_period_timer);",
            "\tint idle = 0;",
            "\tint overrun;",
            "",
            "\traw_spin_lock(&rt_b->rt_runtime_lock);",
            "\tfor (;;) {",
            "\t\toverrun = hrtimer_forward_now(timer, rt_b->rt_period);",
            "\t\tif (!overrun)",
            "\t\t\tbreak;",
            "",
            "\t\traw_spin_unlock(&rt_b->rt_runtime_lock);",
            "\t\tidle = do_sched_rt_period_timer(rt_b, overrun);",
            "\t\traw_spin_lock(&rt_b->rt_runtime_lock);",
            "\t}",
            "\tif (idle)",
            "\t\trt_b->rt_period_active = 0;",
            "\traw_spin_unlock(&rt_b->rt_runtime_lock);",
            "",
            "\treturn idle ? HRTIMER_NORESTART : HRTIMER_RESTART;",
            "}",
            "void init_rt_bandwidth(struct rt_bandwidth *rt_b, u64 period, u64 runtime)",
            "{",
            "\trt_b->rt_period = ns_to_ktime(period);",
            "\trt_b->rt_runtime = runtime;",
            "",
            "\traw_spin_lock_init(&rt_b->rt_runtime_lock);",
            "",
            "\thrtimer_init(&rt_b->rt_period_timer, CLOCK_MONOTONIC,",
            "\t\t     HRTIMER_MODE_REL_HARD);",
            "\trt_b->rt_period_timer.function = sched_rt_period_timer;",
            "}",
            "static inline void do_start_rt_bandwidth(struct rt_bandwidth *rt_b)",
            "{",
            "\traw_spin_lock(&rt_b->rt_runtime_lock);",
            "\tif (!rt_b->rt_period_active) {",
            "\t\trt_b->rt_period_active = 1;",
            "\t\t/*",
            "\t\t * SCHED_DEADLINE updates the bandwidth, as a run away",
            "\t\t * RT task with a DL task could hog a CPU. But DL does",
            "\t\t * not reset the period. If a deadline task was running",
            "\t\t * without an RT task running, it can cause RT tasks to",
            "\t\t * throttle when they start up. Kick the timer right away",
            "\t\t * to update the period.",
            "\t\t */",
            "\t\thrtimer_forward_now(&rt_b->rt_period_timer, ns_to_ktime(0));",
            "\t\thrtimer_start_expires(&rt_b->rt_period_timer,",
            "\t\t\t\t      HRTIMER_MODE_ABS_PINNED_HARD);",
            "\t}",
            "\traw_spin_unlock(&rt_b->rt_runtime_lock);",
            "}",
            "static void start_rt_bandwidth(struct rt_bandwidth *rt_b)",
            "{",
            "\tif (!rt_bandwidth_enabled() || rt_b->rt_runtime == RUNTIME_INF)",
            "\t\treturn;",
            "",
            "\tdo_start_rt_bandwidth(rt_b);",
            "}",
            "static void destroy_rt_bandwidth(struct rt_bandwidth *rt_b)",
            "{",
            "\thrtimer_cancel(&rt_b->rt_period_timer);",
            "}",
            "void unregister_rt_sched_group(struct task_group *tg)",
            "{",
            "\tif (tg->rt_se)",
            "\t\tdestroy_rt_bandwidth(&tg->rt_bandwidth);",
            "}"
          ],
          "function_name": "sched_rt_sysctl_init, init_rt_rq, sched_rt_period_timer, init_rt_bandwidth, do_start_rt_bandwidth, start_rt_bandwidth, destroy_rt_bandwidth, unregister_rt_sched_group",
          "description": "初始化实时调度相关数据结构，管理实时任务周期定时器，控制实时带宽分配与回收，实现基于时间片轮转的调度策略。",
          "similarity": 0.6434828042984009
        }
      ]
    }
  ]
}