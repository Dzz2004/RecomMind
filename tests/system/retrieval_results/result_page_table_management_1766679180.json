{
  "query": "page table management",
  "timestamp": "2025-12-26 00:13:00",
  "retrieved_files": [
    {
      "source_file": "mm/page_table_check.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:06:25\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page_table_check.c`\n\n---\n\n# page_table_check.c 技术文档\n\n## 1. 文件概述\n\n`page_table_check.c` 是 Linux 内核中用于检测和验证页表映射一致性的调试模块。该模块通过跟踪每个物理页面被匿名（anonymous）或文件（file-backed）方式映射的次数，确保页表操作（如设置或清除 PTE/PMD/PUD 条目）不会破坏内存管理的基本不变量。当检测到不一致（如计数器为负、混合映射类型等）时，会触发 `BUG_ON()` 导致内核崩溃，从而帮助开发者及早发现页表管理中的逻辑错误。\n\n该功能默认可通过 `CONFIG_PAGE_TABLE_CHECK_ENFORCED` 配置选项启用，并支持通过内核启动参数 `page_table_check=0/1` 动态控制。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct page_table_check`**  \n  每个物理页面关联的检查状态结构体，包含两个原子计数器：\n  - `anon_map_count`：记录该页面被匿名映射的次数。\n  - `file_map_count`：记录该页面被文件映射的次数。\n\n- **`page_table_check_ops`**  \n  `struct page_ext_operations` 类型的全局变量，用于将 `page_table_check` 结构集成到内核的 `page_ext` 扩展机制中，定义了大小、初始化条件、初始化函数等。\n\n- **`page_table_check_disabled`**  \n  静态分支键（`static_key`），用于在运行时高效地启用/禁用检查逻辑。默认为 `true`（即禁用），若启用则调用 `static_branch_disable()` 关闭该键以激活检查。\n\n### 主要函数\n\n- **`__page_table_check_zero()`**  \n  在页面分配或释放时调用，验证指定 order 范围内的所有页面的映射计数器均为零。\n\n- **`__page_table_check_pte_clear()` / `__page_table_check_pmd_clear()` / `__page_table_check_pud_clear()`**  \n  在清除用户页表项（PTE/PMD/PUD）时调用，减少对应物理页面的映射计数，并验证类型一致性。\n\n- **`__page_table_check_ptes_set()` / `__page_table_check_pmd_set()` / `__page_table_check_pud_set()`**  \n  在设置新的用户页表项时调用，先清除旧项（如有），再增加新项对应页面的映射计数，并进行类型和写权限检查。\n\n- **`__page_table_check_pte_clear_range()`**  \n  在释放整个 PMD 对应的 PTE 表时，遍历并清除所有 PTE 条目对应的页面计数。\n\n- **`page_table_check_pte_flags()` / `page_table_check_pmd_flags()`**  \n  检查页表项中的特殊标志位（如 `uffd_wp`）与写权限的一致性，防止非法组合。\n\n## 3. 关键实现\n\n### 映射类型互斥性检查\n- 每个物理页面只能属于**匿名页面**（如堆、栈、匿名 mmap）或**文件页面**（如文件 mmap、page cache），不能同时被两种方式映射。\n- 在 `page_table_check_set/clear` 中，通过 `PageAnon(page)` 判断页面类型，并确保另一类型的计数器始终为 0（`BUG_ON(atomic_read(...))`）。\n\n### 计数器边界检查\n- **清除操作**：调用 `atomic_dec_return()` 后检查结果是否 `< 0`，防止过度解除映射。\n- **设置操作**：\n  - 对于**文件页面**：仅检查计数器非负（实际应始终 ≥0）。\n  - 对于**匿名页面**：若为**可写映射**（`rw == true`），则限制 `anon_map_count` 最多为 1（即不允许同一匿名页面被多个进程以可写方式共享，除非是 COW 前的只读共享）。\n\n### 用户地址空间过滤\n- 所有检查函数均跳过 `init_mm`（内核地址空间），仅处理用户空间页表操作。\n- 使用 `pte_user_accessible_page()` 等宏判断页表项是否指向用户可访问的普通内存页面（排除特殊条目如 swap、hwpoison 等）。\n\n### Swap 条目写权限检查\n- 在设置包含 `uffd_wp`（用户故障委托写保护）标志的 swap PTE/PMD 时，通过 `swap_cached_writable()` 检查底层 swap 条目是否缓存了“可写”信息，若存在则报 `WARN_ON_ONCE`，因为 `uffd_wp` 要求页面不可写。\n\n### Page Extension 集成\n- 利用内核的 `page_ext` 机制为每个 `struct page` 附加 `page_table_check` 数据，避免修改核心 `struct page`。\n- 通过 `page_ext_get/put` 和 `page_ext_next` 安全地访问连续页面的扩展数据。\n\n## 4. 依赖关系\n\n- **`<linux/page_ext.h>`**：通过 `page_ext_operations` 机制集成到页面扩展框架。\n- **`<linux/mm.h>`**：使用核心内存管理 API，如 `pfn_to_page()`、`PageAnon()`、`PageSlab()` 等。\n- **`<linux/swap.h>` / `<linux/swapops.h>`**：处理 swap 页表项及其标志位（如 `is_swap_pte()`、`pte_to_swp_entry()`）。\n- **`<linux/kstrtox.h>`**：解析内核启动参数。\n- **页表操作宏**：依赖架构相关的页表操作宏（如 `pte_pfn()`、`pmd_write()` 等），这些由各架构的 `pgtable.h` 提供。\n- **`CONFIG_PAGE_TABLE_CHECK_ENFORCED`**：编译时配置选项，决定默认是否启用检查。\n\n## 5. 使用场景\n\n- **内核开发与调试**：在开发新内存管理功能（如新页表操作、COW 优化、大页处理）时，启用此模块可捕获页表操作中的逻辑错误。\n- **回归测试**：作为内核测试套件的一部分，确保页表修改不会破坏映射一致性。\n- **安全加固**（潜在）：虽然主要用于调试，但其强制的映射类型互斥性也可防止某些内存破坏漏洞的利用。\n- **启动参数控制**：系统管理员可在启动时通过 `page_table_check=1` 临时启用检查以诊断问题，或通过 `=0` 在已知兼容性问题的系统上禁用。",
      "similarity": 0.5883716940879822,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/page_table_check.c",
          "start_line": 1,
          "end_line": 26,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "/*",
            " * Copyright (c) 2021, Google LLC.",
            " * Pasha Tatashin <pasha.tatashin@soleen.com>",
            " */",
            "#include <linux/kstrtox.h>",
            "#include <linux/mm.h>",
            "#include <linux/page_table_check.h>",
            "#include <linux/swap.h>",
            "#include <linux/swapops.h>",
            "",
            "#undef pr_fmt",
            "#define pr_fmt(fmt)\t\"page_table_check: \" fmt",
            "",
            "struct page_table_check {",
            "\tatomic_t anon_map_count;",
            "\tatomic_t file_map_count;",
            "};",
            "",
            "static bool __page_table_check_enabled __initdata =",
            "\t\t\t\tIS_ENABLED(CONFIG_PAGE_TABLE_CHECK_ENFORCED);",
            "",
            "DEFINE_STATIC_KEY_TRUE(page_table_check_disabled);",
            "EXPORT_SYMBOL(page_table_check_disabled);",
            ""
          ],
          "function_name": null,
          "description": "定义page_table_check结构体，包含匿名和文件映射计数器，通过静态键控制检查状态，用于跟踪页表检查启用情况",
          "similarity": 0.6080918312072754
        },
        {
          "chunk_id": 2,
          "file_path": "mm/page_table_check.c",
          "start_line": 163,
          "end_line": 269,
          "content": [
            "void __page_table_check_pte_clear(struct mm_struct *mm, pte_t pte)",
            "{",
            "\tif (&init_mm == mm)",
            "\t\treturn;",
            "",
            "\tif (pte_user_accessible_page(pte)) {",
            "\t\tpage_table_check_clear(pte_pfn(pte), PAGE_SIZE >> PAGE_SHIFT);",
            "\t}",
            "}",
            "void __page_table_check_pmd_clear(struct mm_struct *mm, pmd_t pmd)",
            "{",
            "\tif (&init_mm == mm)",
            "\t\treturn;",
            "",
            "\tif (pmd_user_accessible_page(pmd)) {",
            "\t\tpage_table_check_clear(pmd_pfn(pmd), PMD_SIZE >> PAGE_SHIFT);",
            "\t}",
            "}",
            "void __page_table_check_pud_clear(struct mm_struct *mm, pud_t pud)",
            "{",
            "\tif (&init_mm == mm)",
            "\t\treturn;",
            "",
            "\tif (pud_user_accessible_page(pud)) {",
            "\t\tpage_table_check_clear(pud_pfn(pud), PUD_SIZE >> PAGE_SHIFT);",
            "\t}",
            "}",
            "static inline bool swap_cached_writable(swp_entry_t entry)",
            "{",
            "\treturn is_writable_device_exclusive_entry(entry) ||",
            "\t    is_writable_device_private_entry(entry) ||",
            "\t    is_writable_migration_entry(entry);",
            "}",
            "static inline void page_table_check_pte_flags(pte_t pte)",
            "{",
            "\tif (pte_present(pte) && pte_uffd_wp(pte))",
            "\t\tWARN_ON_ONCE(pte_write(pte));",
            "\telse if (is_swap_pte(pte) && pte_swp_uffd_wp(pte))",
            "\t\tWARN_ON_ONCE(swap_cached_writable(pte_to_swp_entry(pte)));",
            "}",
            "void __page_table_check_ptes_set(struct mm_struct *mm, pte_t *ptep, pte_t pte,",
            "\t\tunsigned int nr)",
            "{",
            "\tunsigned int i;",
            "",
            "\tif (&init_mm == mm)",
            "\t\treturn;",
            "",
            "\tpage_table_check_pte_flags(pte);",
            "",
            "\tfor (i = 0; i < nr; i++)",
            "\t\t__page_table_check_pte_clear(mm, ptep_get(ptep + i));",
            "\tif (pte_user_accessible_page(pte))",
            "\t\tpage_table_check_set(pte_pfn(pte), nr, pte_write(pte));",
            "}",
            "static inline void page_table_check_pmd_flags(pmd_t pmd)",
            "{",
            "\tif (pmd_present(pmd) && pmd_uffd_wp(pmd))",
            "\t\tWARN_ON_ONCE(pmd_write(pmd));",
            "\telse if (is_swap_pmd(pmd) && pmd_swp_uffd_wp(pmd))",
            "\t\tWARN_ON_ONCE(swap_cached_writable(pmd_to_swp_entry(pmd)));",
            "}",
            "void __page_table_check_pmd_set(struct mm_struct *mm, pmd_t *pmdp, pmd_t pmd)",
            "{",
            "\tif (&init_mm == mm)",
            "\t\treturn;",
            "",
            "\tpage_table_check_pmd_flags(pmd);",
            "",
            "\t__page_table_check_pmd_clear(mm, *pmdp);",
            "\tif (pmd_user_accessible_page(pmd)) {",
            "\t\tpage_table_check_set(pmd_pfn(pmd), PMD_SIZE >> PAGE_SHIFT,",
            "\t\t\t\t     pmd_write(pmd));",
            "\t}",
            "}",
            "void __page_table_check_pud_set(struct mm_struct *mm, pud_t *pudp, pud_t pud)",
            "{",
            "\tif (&init_mm == mm)",
            "\t\treturn;",
            "",
            "\t__page_table_check_pud_clear(mm, *pudp);",
            "\tif (pud_user_accessible_page(pud)) {",
            "\t\tpage_table_check_set(pud_pfn(pud), PUD_SIZE >> PAGE_SHIFT,",
            "\t\t\t\t     pud_write(pud));",
            "\t}",
            "}",
            "void __page_table_check_pte_clear_range(struct mm_struct *mm,",
            "\t\t\t\t\tunsigned long addr,",
            "\t\t\t\t\tpmd_t pmd)",
            "{",
            "\tif (&init_mm == mm)",
            "\t\treturn;",
            "",
            "\tif (!pmd_bad(pmd) && !pmd_leaf(pmd)) {",
            "\t\tpte_t *ptep = pte_offset_map(&pmd, addr);",
            "\t\tunsigned long i;",
            "",
            "\t\tif (WARN_ON(!ptep))",
            "\t\t\treturn;",
            "\t\tfor (i = 0; i < PTRS_PER_PTE; i++) {",
            "\t\t\t__page_table_check_pte_clear(mm, ptep_get(ptep));",
            "\t\t\taddr += PAGE_SIZE;",
            "\t\t\tptep++;",
            "\t\t}",
            "\t\tpte_unmap(ptep - PTRS_PER_PTE);",
            "\t}",
            "}"
          ],
          "function_name": "__page_table_check_pte_clear, __page_table_check_pmd_clear, __page_table_check_pud_clear, swap_cached_writable, page_table_check_pte_flags, __page_table_check_ptes_set, page_table_check_pmd_flags, __page_table_check_pmd_set, __page_table_check_pud_set, __page_table_check_pte_clear_range",
          "description": "集成到页表操作回调中，在pte/pmd/pud清除时触发检查，验证用户访问权限和交换缓存可写性，确保页表状态与物理页面计数匹配",
          "similarity": 0.5733227133750916
        },
        {
          "chunk_id": 1,
          "file_path": "mm/page_table_check.c",
          "start_line": 27,
          "end_line": 128,
          "content": [
            "static int __init early_page_table_check_param(char *buf)",
            "{",
            "\treturn kstrtobool(buf, &__page_table_check_enabled);",
            "}",
            "static bool __init need_page_table_check(void)",
            "{",
            "\treturn __page_table_check_enabled;",
            "}",
            "static void __init init_page_table_check(void)",
            "{",
            "\tif (!__page_table_check_enabled)",
            "\t\treturn;",
            "\tstatic_branch_disable(&page_table_check_disabled);",
            "}",
            "static void page_table_check_clear(unsigned long pfn, unsigned long pgcnt)",
            "{",
            "\tstruct page_ext *page_ext;",
            "\tstruct page *page;",
            "\tunsigned long i;",
            "\tbool anon;",
            "",
            "\tif (!pfn_valid(pfn))",
            "\t\treturn;",
            "",
            "\tpage = pfn_to_page(pfn);",
            "\tpage_ext = page_ext_get(page);",
            "",
            "\tif (!page_ext)",
            "\t\treturn;",
            "",
            "\tBUG_ON(PageSlab(page));",
            "\tanon = PageAnon(page);",
            "",
            "\tfor (i = 0; i < pgcnt; i++) {",
            "\t\tstruct page_table_check *ptc = get_page_table_check(page_ext);",
            "",
            "\t\tif (anon) {",
            "\t\t\tBUG_ON(atomic_read(&ptc->file_map_count));",
            "\t\t\tBUG_ON(atomic_dec_return(&ptc->anon_map_count) < 0);",
            "\t\t} else {",
            "\t\t\tBUG_ON(atomic_read(&ptc->anon_map_count));",
            "\t\t\tBUG_ON(atomic_dec_return(&ptc->file_map_count) < 0);",
            "\t\t}",
            "\t\tpage_ext = page_ext_next(page_ext);",
            "\t}",
            "\tpage_ext_put(page_ext);",
            "}",
            "static void page_table_check_set(unsigned long pfn, unsigned long pgcnt,",
            "\t\t\t\t bool rw)",
            "{",
            "\tstruct page_ext *page_ext;",
            "\tstruct page *page;",
            "\tunsigned long i;",
            "\tbool anon;",
            "",
            "\tif (!pfn_valid(pfn))",
            "\t\treturn;",
            "",
            "\tpage = pfn_to_page(pfn);",
            "\tpage_ext = page_ext_get(page);",
            "",
            "\tif (!page_ext)",
            "\t\treturn;",
            "",
            "\tBUG_ON(PageSlab(page));",
            "\tanon = PageAnon(page);",
            "",
            "\tfor (i = 0; i < pgcnt; i++) {",
            "\t\tstruct page_table_check *ptc = get_page_table_check(page_ext);",
            "",
            "\t\tif (anon) {",
            "\t\t\tBUG_ON(atomic_read(&ptc->file_map_count));",
            "\t\t\tBUG_ON(atomic_inc_return(&ptc->anon_map_count) > 1 && rw);",
            "\t\t} else {",
            "\t\t\tBUG_ON(atomic_read(&ptc->anon_map_count));",
            "\t\t\tBUG_ON(atomic_inc_return(&ptc->file_map_count) < 0);",
            "\t\t}",
            "\t\tpage_ext = page_ext_next(page_ext);",
            "\t}",
            "\tpage_ext_put(page_ext);",
            "}",
            "void __page_table_check_zero(struct page *page, unsigned int order)",
            "{",
            "\tstruct page_ext *page_ext;",
            "\tunsigned long i;",
            "",
            "\tBUG_ON(PageSlab(page));",
            "",
            "\tpage_ext = page_ext_get(page);",
            "",
            "\tif (!page_ext)",
            "\t\treturn;",
            "",
            "\tfor (i = 0; i < (1ul << order); i++) {",
            "\t\tstruct page_table_check *ptc = get_page_table_check(page_ext);",
            "",
            "\t\tBUG_ON(atomic_read(&ptc->anon_map_count));",
            "\t\tBUG_ON(atomic_read(&ptc->file_map_count));",
            "\t\tpage_ext = page_ext_next(page_ext);",
            "\t}",
            "\tpage_ext_put(page_ext);",
            "}"
          ],
          "function_name": "early_page_table_check_param, need_page_table_check, init_page_table_check, page_table_check_clear, page_table_check_set, __page_table_check_zero",
          "description": "实现页表检查的初始化参数解析、启用判断及核心计数器操作，通过原子操作管理页面映射计数，在页面释放时验证计数一致性",
          "similarity": 0.5696744918823242
        }
      ]
    },
    {
      "source_file": "mm/pgtable-generic.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:12:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pgtable-generic.c`\n\n---\n\n# pgtable-generic.c 技术文档\n\n## 1. 文件概述\n\n`pgtable-generic.c` 是 Linux 内核内存管理子系统中的一个通用页表操作实现文件，位于 `mm/` 目录下。该文件提供了在不同架构上通用的页表项（Page Table Entry, PTE）及相关高层页表项（如 PMD、PUD、P4D、PGD）的操作函数。这些函数主要用于处理页表项的清除、访问标志设置、TLB 刷新、透明大页（Transparent Huge Page, THP）管理等核心内存管理任务。\n\n当特定架构未提供优化的汇编或内联实现（通过 `__HAVE_ARCH_*` 宏判断）时，内核将回退使用本文件中提供的通用 C 语言实现，确保跨架构的一致性和功能完整性。\n\n## 2. 核心功能\n\n### 主要函数列表：\n\n- **页表项错误处理**：\n  - `pgd_clear_bad(pgd_t *pgd)`\n  - `p4d_clear_bad(p4d_t *p4d)`（若未折叠）\n  - `pud_clear_bad(pud_t *pud)`（若未折叠）\n  - `pmd_clear_bad(pmd_t *pmd)`\n\n- **PTE 访问控制与刷新**：\n  - `ptep_set_access_flags()`：设置 PTE 的访问/脏位及写权限\n  - `ptep_clear_flush_young()`：清除并返回 PTE 的 young 位，并刷新 TLB\n  - `ptep_clear_flush()`：原子清除 PTE 并刷新 TLB（若可访问）\n\n- **透明大页（THP）相关操作**：\n  - `pmdp_set_access_flags()`：为 PMD 设置访问标志\n  - `pmdp_clear_flush_young()`：清除 PMD 的 young 位并刷新 TLB\n  - `pmdp_huge_clear_flush()`：清除 huge PMD 并刷新 TLB\n  - `pudp_huge_clear_flush()`（若支持 PUD THP）：清除 huge PUD 并刷新 TLB\n  - `pgtable_trans_huge_deposit()` / `pgtable_trans_huge_withdraw()`：管理与 PMD 关联的页表页（用于拆分/合并 THP）\n  - `pmdp_invalidate()` / `pmdp_invalidate_ad()`：使 PMD 无效\n  - `pmdp_collapse_flush()`：在 THP 折叠过程中清除 PMD 并刷新对应范围的 TLB\n\n- **延迟释放 PTE 页表**：\n  - `pte_free_defer()`：通过 RCU 延迟释放 PTE 页表页\n\n- **无锁 PTE 映射辅助**：\n  - `__pte_offset_map()`：安全地映射 PTE 页表（考虑 SMP 和迁移条目）\n\n## 3. 关键实现\n\n### 3.1 页表项“坏”状态处理\n当页表遍历过程中发现非法或损坏的页表项（如保留位被置位），调用 `*_clear_bad()` 函数：\n- 首先通过 `*_ERROR()` 宏记录错误（通常打印警告）\n- 然后调用 `*_clear()` 将该项置为“空”（none），防止后续误用\n- 这些函数通常由 `p?d_none_or_clear_bad` 宏在检测到 bad entry 时调用\n\n### 3.2 访问标志更新与 TLB 一致性\n- `ptep_set_access_flags()` 仅在 PTE 实际发生变化时才更新页表并调用 `flush_tlb_fix_spurious_fault()`，避免不必要的 TLB 刷新。\n- 类似逻辑应用于 `pmdp_set_access_flags()`，但刷新范围是整个大页（`HPAGE_PMD_SIZE`）。\n\n### 3.3 透明大页（THP）管理\n- **页表页沉积/提取**：`pgtable_trans_huge_deposit/withdraw` 使用链表 FIFO 管理与 PMD 关联的 PTE 页表页，用于 THP 拆分时恢复原始 PTE。\n- **PMD 无效化**：`pmdp_invalidate` 使用 `pmdp_establish` 原子地将 PMD 置为无效状态，并刷新对应 TLB 范围。\n- **折叠刷新**：`pmdp_collapse_flush` 在 THP 创建过程中清除 PMD，但刷新的是整个地址范围（而非仅 PMD 粒度），因为此时底层 PTE 仍存在。\n\n### 3.4 无锁 PTE 映射（`__pte_offset_map`）\n- 在 CONFIG_GUP_GET_PXX_LOW_HIGH 且 SMP/RCU_PREEMPT 下，通过禁用本地中断确保 `pmdp_get_lockless()` 读取的高低半字属于同一 PMD 值（防止 TLB 刷新导致不一致）。\n- 检查 PMD 是否为 none、迁移条目、透明大页或 bad，若任一条件成立则返回 NULL。\n- 否则调用 `__pte_map()` 返回实际 PTE 地址，并保持 RCU 锁定。\n\n### 3.5 RCU 延迟释放\n- `pte_free_defer` 将待释放的页表页加入 RCU 回调，在宽限期结束后调用 `pte_free_now` 执行实际释放，确保并发访问安全。\n\n## 4. 依赖关系\n\n### 头文件依赖：\n- `<linux/pagemap.h>`：页面缓存相关\n- `<linux/hugetlb.h>`：大页支持\n- `<linux/pgtable.h>`：页表抽象接口\n- `<linux/swap.h>` / `<linux/swapops.h>`：交换机制\n- `<linux/mm_inline.h>`：内联内存管理函数\n- `<asm/pgalloc.h>`：架构相关的页表分配\n- `<asm/tlb.h>`：TLB 刷新接口\n\n### 架构依赖：\n- 依赖架构是否定义了 `__PAGETABLE_P4D_FOLDED`、`__PAGETABLE_PUD_FOLDED` 等宏来决定是否编译对应层级的函数。\n- 若架构定义了 `__HAVE_ARCH_*` 宏（如 `__HAVE_ARCH_PTEP_SET_ACCESS_FLAGS`），则跳过通用实现，使用架构优化版本。\n- 依赖 `CONFIG_TRANSPARENT_HUGEPAGE` 配置选项启用 THP 相关代码。\n\n### 内核子系统交互：\n- **内存管理（MM）**：与 VMA、mm_struct、页表锁等紧密集成\n- **TLB 管理**：调用 `flush_tlb_*` 系列函数维护 CPU 缓存一致性\n- **RCU 子系统**：用于安全延迟释放页表页\n- **交换子系统**：处理迁移页表项（migration entries）\n\n## 5. 使用场景\n\n- **页错误处理**：在缺页异常中更新 PTE/PMD 的访问/脏位时调用 `ptep/pmdp_set_access_flags`。\n- **内存回收与迁移**：在页面迁移或回收过程中，可能需要清除 young 位（`ptep/pmdp_clear_flush_young`）或完全清除页表项（`ptep/pmdp_clear_flush`）。\n- **透明大页操作**：\n  - THP 合并（collapse）时调用 `pmdp_collapse_flush`\n  - THP 拆分（split）时通过 `pgtable_trans_huge_withdraw` 获取原始 PTE 页表\n  - THP 无效化时调用 `pmdp_invalidate`\n- **GUP（Get User Pages）**：`__pte_offset_map` 被 `gup` 系列函数用于无锁安全地访问 PTE。\n- **页表初始化/清理**：在进程创建/销毁或内存映射变更时，可能触发 bad 页表项清理。\n- **延迟释放**：在大量页表释放场景（如进程退出）中，`pte_free_defer` 提供高效且安全的释放机制。",
      "similarity": 0.5767210721969604,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/pgtable-generic.c",
          "start_line": 25,
          "end_line": 130,
          "content": [
            "void pgd_clear_bad(pgd_t *pgd)",
            "{",
            "\tpgd_ERROR(*pgd);",
            "\tpgd_clear(pgd);",
            "}",
            "void p4d_clear_bad(p4d_t *p4d)",
            "{",
            "\tp4d_ERROR(*p4d);",
            "\tp4d_clear(p4d);",
            "}",
            "void pud_clear_bad(pud_t *pud)",
            "{",
            "\tpud_ERROR(*pud);",
            "\tpud_clear(pud);",
            "}",
            "void pmd_clear_bad(pmd_t *pmd)",
            "{",
            "\tpmd_ERROR(*pmd);",
            "\tpmd_clear(pmd);",
            "}",
            "int ptep_set_access_flags(struct vm_area_struct *vma,",
            "\t\t\t  unsigned long address, pte_t *ptep,",
            "\t\t\t  pte_t entry, int dirty)",
            "{",
            "\tint changed = !pte_same(ptep_get(ptep), entry);",
            "\tif (changed) {",
            "\t\tset_pte_at(vma->vm_mm, address, ptep, entry);",
            "\t\tflush_tlb_fix_spurious_fault(vma, address, ptep);",
            "\t}",
            "\treturn changed;",
            "}",
            "int ptep_clear_flush_young(struct vm_area_struct *vma,",
            "\t\t\t   unsigned long address, pte_t *ptep)",
            "{",
            "\tint young;",
            "\tyoung = ptep_test_and_clear_young(vma, address, ptep);",
            "\tif (young)",
            "\t\tflush_tlb_page(vma, address);",
            "\treturn young;",
            "}",
            "pte_t ptep_clear_flush(struct vm_area_struct *vma, unsigned long address,",
            "\t\t       pte_t *ptep)",
            "{",
            "\tstruct mm_struct *mm = (vma)->vm_mm;",
            "\tpte_t pte;",
            "\tpte = ptep_get_and_clear(mm, address, ptep);",
            "\tif (pte_accessible(mm, pte))",
            "\t\tflush_tlb_page(vma, address);",
            "\treturn pte;",
            "}",
            "int pmdp_set_access_flags(struct vm_area_struct *vma,",
            "\t\t\t  unsigned long address, pmd_t *pmdp,",
            "\t\t\t  pmd_t entry, int dirty)",
            "{",
            "\tint changed = !pmd_same(*pmdp, entry);",
            "\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);",
            "\tif (changed) {",
            "\t\tset_pmd_at(vma->vm_mm, address, pmdp, entry);",
            "\t\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);",
            "\t}",
            "\treturn changed;",
            "}",
            "int pmdp_clear_flush_young(struct vm_area_struct *vma,",
            "\t\t\t   unsigned long address, pmd_t *pmdp)",
            "{",
            "\tint young;",
            "\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);",
            "\tyoung = pmdp_test_and_clear_young(vma, address, pmdp);",
            "\tif (young)",
            "\t\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);",
            "\treturn young;",
            "}",
            "pmd_t pmdp_huge_clear_flush(struct vm_area_struct *vma, unsigned long address,",
            "\t\t\t    pmd_t *pmdp)",
            "{",
            "\tpmd_t pmd;",
            "\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);",
            "\tVM_BUG_ON(pmd_present(*pmdp) && !pmd_trans_huge(*pmdp) &&",
            "\t\t\t   !pmd_devmap(*pmdp));",
            "\tpmd = pmdp_huge_get_and_clear(vma->vm_mm, address, pmdp);",
            "\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);",
            "\treturn pmd;",
            "}",
            "pud_t pudp_huge_clear_flush(struct vm_area_struct *vma, unsigned long address,",
            "\t\t\t    pud_t *pudp)",
            "{",
            "\tpud_t pud;",
            "",
            "\tVM_BUG_ON(address & ~HPAGE_PUD_MASK);",
            "\tVM_BUG_ON(!pud_trans_huge(*pudp) && !pud_devmap(*pudp));",
            "\tpud = pudp_huge_get_and_clear(vma->vm_mm, address, pudp);",
            "\tflush_pud_tlb_range(vma, address, address + HPAGE_PUD_SIZE);",
            "\treturn pud;",
            "}",
            "void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,",
            "\t\t\t\tpgtable_t pgtable)",
            "{",
            "\tassert_spin_locked(pmd_lockptr(mm, pmdp));",
            "",
            "\t/* FIFO */",
            "\tif (!pmd_huge_pte(mm, pmdp))",
            "\t\tINIT_LIST_HEAD(&pgtable->lru);",
            "\telse",
            "\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);",
            "\tpmd_huge_pte(mm, pmdp) = pgtable;",
            "}"
          ],
          "function_name": "pgd_clear_bad, p4d_clear_bad, pud_clear_bad, pmd_clear_bad, ptep_set_access_flags, ptep_clear_flush_young, ptep_clear_flush, pmdp_set_access_flags, pmdp_clear_flush_young, pmdp_huge_clear_flush, pudp_huge_clear_flush, pgtable_trans_huge_deposit",
          "description": "该代码段实现了针对多级页表（PGD/P4D/PUD/PMD/PTE）的错误清除、访问标志设置及TLB刷新功能，主要用于处理大页（Huge Page）场景下的页表维护。各函数通过清除页表项的无效状态、更新访问属性并触发TLB失效，确保内存访问一致性；其中`pgtable_trans_huge_deposit`负责管理透明大页（THP）的LRU缓存。  \n由于代码未包含完整上下文（如全局变量或外部依赖），部分函数行为需结合内核其他模块进一步确认。",
          "similarity": 0.5821225643157959
        },
        {
          "chunk_id": 2,
          "file_path": "mm/pgtable-generic.c",
          "start_line": 181,
          "end_line": 252,
          "content": [
            "pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp)",
            "{",
            "\tpgtable_t pgtable;",
            "",
            "\tassert_spin_locked(pmd_lockptr(mm, pmdp));",
            "",
            "\t/* FIFO */",
            "\tpgtable = pmd_huge_pte(mm, pmdp);",
            "\tpmd_huge_pte(mm, pmdp) = list_first_entry_or_null(&pgtable->lru,",
            "\t\t\t\t\t\t\t  struct page, lru);",
            "\tif (pmd_huge_pte(mm, pmdp))",
            "\t\tlist_del(&pgtable->lru);",
            "\treturn pgtable;",
            "}",
            "pmd_t pmdp_invalidate(struct vm_area_struct *vma, unsigned long address,",
            "\t\t     pmd_t *pmdp)",
            "{",
            "\tVM_WARN_ON_ONCE(!pmd_present(*pmdp));",
            "\tpmd_t old = pmdp_establish(vma, address, pmdp, pmd_mkinvalid(*pmdp));",
            "\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);",
            "\treturn old;",
            "}",
            "pmd_t pmdp_invalidate_ad(struct vm_area_struct *vma, unsigned long address,",
            "\t\t\t pmd_t *pmdp)",
            "{",
            "\tVM_WARN_ON_ONCE(!pmd_present(*pmdp));",
            "\treturn pmdp_invalidate(vma, address, pmdp);",
            "}",
            "pmd_t pmdp_collapse_flush(struct vm_area_struct *vma, unsigned long address,",
            "\t\t\t  pmd_t *pmdp)",
            "{",
            "\t/*",
            "\t * pmd and hugepage pte format are same. So we could",
            "\t * use the same function.",
            "\t */",
            "\tpmd_t pmd;",
            "",
            "\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);",
            "\tVM_BUG_ON(pmd_trans_huge(*pmdp));",
            "\tpmd = pmdp_huge_get_and_clear(vma->vm_mm, address, pmdp);",
            "",
            "\t/* collapse entails shooting down ptes not pmd */",
            "\tflush_tlb_range(vma, address, address + HPAGE_PMD_SIZE);",
            "\treturn pmd;",
            "}",
            "static void pte_free_now(struct rcu_head *head)",
            "{",
            "\tstruct page *page;",
            "",
            "\tpage = container_of(head, struct page, rcu_head);",
            "\tpte_free(NULL /* mm not passed and not used */, (pgtable_t)page);",
            "}",
            "void pte_free_defer(struct mm_struct *mm, pgtable_t pgtable)",
            "{",
            "\tstruct page *page;",
            "",
            "\tpage = pgtable;",
            "\tcall_rcu(&page->rcu_head, pte_free_now);",
            "}",
            "static unsigned long pmdp_get_lockless_start(void)",
            "{",
            "\tunsigned long irqflags;",
            "",
            "\tlocal_irq_save(irqflags);",
            "\treturn irqflags;",
            "}",
            "static void pmdp_get_lockless_end(unsigned long irqflags)",
            "{",
            "\tlocal_irq_restore(irqflags);",
            "}",
            "static unsigned long pmdp_get_lockless_start(void) { return 0; }",
            "static void pmdp_get_lockless_end(unsigned long irqflags) { }"
          ],
          "function_name": "pgtable_trans_huge_withdraw, pmdp_invalidate, pmdp_invalidate_ad, pmdp_collapse_flush, pte_free_now, pte_free_defer, pmdp_get_lockless_start, pmdp_get_lockless_end, pmdp_get_lockless_start, pmdp_get_lockless_end",
          "description": "该代码段主要处理大页（HugeTLB）相关页表操作及回收机制，包含页表项无效化、大页折叠、延迟释放等功能。  \n其中`pmdp_invalidate`系列函数负责使PMD无效并触发TLB刷新，`pte_free_defer`通过RCU机制延迟释放页表项，而`pmdp_get_lockless_start/end`因重复定义导致上下文不完整。",
          "similarity": 0.5372337698936462
        },
        {
          "chunk_id": 0,
          "file_path": "mm/pgtable-generic.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  mm/pgtable-generic.c",
            " *",
            " *  Generic pgtable methods declared in linux/pgtable.h",
            " *",
            " *  Copyright (C) 2010  Linus Torvalds",
            " */",
            "",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/swap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "",
            "/*",
            " * If a p?d_bad entry is found while walking page tables, report",
            " * the error, before resetting entry to p?d_none.  Usually (but",
            " * very seldom) called out from the p?d_none_or_clear_bad macros.",
            " */",
            ""
          ],
          "function_name": null,
          "description": "该代码片段属于Linux内核内存管理模块中的通用页表实现文件，主要职责是提供跨架构的页表操作基础支持。当前代码段仅包含头文件引用和注释说明，未展示具体函数实现，因此无法确认其完整的功能性细节。上下文不完整，需结合后续代码分析具体行为。",
          "similarity": 0.47193053364753723
        }
      ]
    },
    {
      "source_file": "mm/page_owner.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:04:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page_owner.c`\n\n---\n\n# page_owner.c 技术文档\n\n## 1. 文件概述\n\n`page_owner.c` 是 Linux 内核中用于追踪物理内存页分配与释放信息的调试模块。它通过记录每个页面（或页块）的分配者、释放者、分配时间、调用栈、GFP 标志、进程上下文等元数据，帮助开发者诊断内存泄漏、非法释放、重复释放等内存管理问题。该功能可通过内核启动参数 `page_owner=on` 启用，并通过 debugfs 接口（如 `/sys/kernel/debug/page_owner`）导出详细信息。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct page_owner`**：存储单个页面（或页块）的归属信息\n  - `order`：分配时的页阶数（2^order 个连续页）\n  - `last_migrate_reason`：最后一次迁移的原因（-1 表示未迁移）\n  - `gfp_mask`：分配时使用的 GFP 标志\n  - `handle` / `free_handle`：分配/释放时的调用栈句柄（由 stackdepot 管理）\n  - `ts_nsec` / `free_ts_nsec`：分配/释放的时间戳（纳秒级）\n  - `comm` / `pid` / `tgid`：分配进程的名称、PID 和线程组 ID\n  - `free_pid` / `free_tgid`：释放进程的 PID 和线程组 ID\n\n### 主要函数\n\n- **`__set_page_owner()`**：在页面分配时记录归属信息\n- **`__reset_page_owner()`**：在页面释放时记录释放信息\n- **`__set_page_owner_migrate_reason()`**：记录页面迁移原因\n- **`__split_page_owner()`**：在页面分裂时更新页阶信息\n- **`__folio_copy_owner()`**：在 folio 迁移时复制归属信息\n- **`pagetypeinfo_showmixedcount_print()`**：统计并打印混合迁移类型的页块信息（未完整实现）\n\n### 全局变量与初始化\n\n- `page_owner_enabled`：是否启用 page owner 功能（由启动参数控制）\n- `page_owner_inited`：静态跳转键，标识 page owner 是否已初始化\n- `dummy_handle` / `failure_handle` / `early_handle`：特殊调用栈句柄，用于避免递归或处理异常情况\n- `page_owner_ops`：`page_ext` 框架的操作集，用于注册 page owner 扩展\n\n## 3. 关键实现\n\n### 调用栈捕获与去重\n\n- 使用 `stack_trace_save()` 捕获深度为 `PAGE_OWNER_STACK_DEPTH`（16 层）的调用栈\n- 通过 `stack_depot_save()` 将调用栈存入全局去重仓库（stack depot），返回紧凑句柄\n- 为避免在分配 page owner 元数据时触发递归（如 stack depot 自身需要分配内存），使用 `current->in_page_owner` 标志临时禁用追踪，并返回 `dummy_handle`\n\n### 页面扩展（page_ext）集成\n\n- 利用内核的 `page_ext` 机制为每个 struct page 附加 `struct page_owner` 元数据\n- 通过 `page_ext_get()` / `page_ext_put()` 安全访问扩展数据\n- 在 `init_page_owner()` 中注册 `page_owner_ops`，使 page_ext 框架在初始化时为所有页面预留空间\n\n### 特殊句柄处理\n\n- **`dummy_handle`**：用于递归保护场景\n- **`failure_handle`**：当 `stack_depot_save()` 失败时的备用句柄\n- **`early_handle`**：用于早期分配页面（如 memblock 阶段）的归属标记\n\n### 内存操作一致性\n\n- 在页面分配（`__set_page_owner`）、释放（`__reset_page_owner`）、迁移（`__folio_copy_owner`）和分裂（`__split_page_owner`）等关键路径上同步更新元数据\n- 使用 `PAGE_EXT_OWNER_ALLOCATED` 位标记页面当前是否处于已分配状态\n- 时间戳使用 `local_clock()` 获取高精度单调时钟\n\n## 4. 依赖关系\n\n- **`<linux/page_ext.h>`**：提供页面扩展框架，用于附加元数据\n- **`<linux/stackdepot.h>`**：提供调用栈去重存储服务\n- **`<linux/stacktrace.h>`**：提供调用栈捕获接口\n- **`<linux/debugfs.h>`**：用于创建 debugfs 接口（虽未在代码片段中体现，但通常配套实现）\n- **`mm/internal.h`**：包含内部内存管理辅助函数\n- **`<linux/memcontrol.h>`**、**`<linux/migrate.h>`**：支持内存控制组和页面迁移场景\n\n## 5. 使用场景\n\n- **内存泄漏检测**：通过分析未释放页面的分配栈和进程上下文定位泄漏源\n- **Use-after-free 调试**：检查已释放页面的释放者信息，判断非法访问来源\n- **内存碎片分析**：结合迁移类型和分配模式，识别导致碎片化的分配行为\n- **性能调优**：通过分配/释放时间戳分析内存分配延迟\n- **内核开发与测试**：在启用 `CONFIG_PAGE_OWNER` 配置选项后，作为内存子系统的重要调试工具\n\n> 注：该功能会显著增加内存开销（每个页面约 64 字节元数据）和运行时开销，仅建议在调试环境中启用。",
      "similarity": 0.5663314461708069,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/page_owner.c",
          "start_line": 1,
          "end_line": 47,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/debugfs.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memblock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/migrate.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/sched/clock.h>",
            "",
            "#include \"internal.h\"",
            "",
            "/*",
            " * TODO: teach PAGE_OWNER_STACK_DEPTH (__dump_page_owner and save_stack)",
            " * to use off stack temporal storage",
            " */",
            "#define PAGE_OWNER_STACK_DEPTH (16)",
            "",
            "struct page_owner {",
            "\tunsigned short order;",
            "\tshort last_migrate_reason;",
            "\tgfp_t gfp_mask;",
            "\tdepot_stack_handle_t handle;",
            "\tdepot_stack_handle_t free_handle;",
            "\tu64 ts_nsec;",
            "\tu64 free_ts_nsec;",
            "\tchar comm[TASK_COMM_LEN];",
            "\tpid_t pid;",
            "\tpid_t tgid;",
            "\tpid_t free_pid;",
            "\tpid_t free_tgid;",
            "};",
            "",
            "static bool page_owner_enabled __initdata;",
            "DEFINE_STATIC_KEY_FALSE(page_owner_inited);",
            "",
            "static depot_stack_handle_t dummy_handle;",
            "static depot_stack_handle_t failure_handle;",
            "static depot_stack_handle_t early_handle;",
            "",
            "static void init_early_allocated_pages(void);",
            ""
          ],
          "function_name": null,
          "description": "定义page_owner结构体及辅助变量，用于跟踪页面分配信息，包含订单、时间戳、进程ID、堆栈句柄等字段，为核心数据结构和初始化参数。",
          "similarity": 0.5765146017074585
        },
        {
          "chunk_id": 3,
          "file_path": "mm/page_owner.c",
          "start_line": 366,
          "end_line": 510,
          "content": [
            "static inline int print_page_owner_memcg(char *kbuf, size_t count, int ret,",
            "\t\t\t\t\t struct page *page)",
            "{",
            "#ifdef CONFIG_MEMCG",
            "\tunsigned long memcg_data;",
            "\tstruct mem_cgroup *memcg;",
            "\tbool online;",
            "\tchar name[80];",
            "",
            "\trcu_read_lock();",
            "\tmemcg_data = READ_ONCE(page->memcg_data);",
            "\tif (!memcg_data)",
            "\t\tgoto out_unlock;",
            "",
            "\tif (memcg_data & MEMCG_DATA_OBJEXTS)",
            "\t\tret += scnprintf(kbuf + ret, count - ret,",
            "\t\t\t\t\"Slab cache page\\n\");",
            "",
            "\tmemcg = page_memcg_check(page);",
            "\tif (!memcg)",
            "\t\tgoto out_unlock;",
            "",
            "\tonline = (memcg->css.flags & CSS_ONLINE);",
            "\tcgroup_name(memcg->css.cgroup, name, sizeof(name));",
            "\tret += scnprintf(kbuf + ret, count - ret,",
            "\t\t\t\"Charged %sto %smemcg %s\\n\",",
            "\t\t\tPageMemcgKmem(page) ? \"(via objcg) \" : \"\",",
            "\t\t\tonline ? \"\" : \"offline \",",
            "\t\t\tname);",
            "out_unlock:",
            "\trcu_read_unlock();",
            "#endif /* CONFIG_MEMCG */",
            "",
            "\treturn ret;",
            "}",
            "static ssize_t",
            "print_page_owner(char __user *buf, size_t count, unsigned long pfn,",
            "\t\tstruct page *page, struct page_owner *page_owner,",
            "\t\tdepot_stack_handle_t handle)",
            "{",
            "\tint ret, pageblock_mt, page_mt;",
            "\tchar *kbuf;",
            "",
            "\tcount = min_t(size_t, count, PAGE_SIZE);",
            "\tkbuf = kmalloc(count, GFP_KERNEL);",
            "\tif (!kbuf)",
            "\t\treturn -ENOMEM;",
            "",
            "\tret = scnprintf(kbuf, count,",
            "\t\t\t\"Page allocated via order %u, mask %#x(%pGg), pid %d, tgid %d (%s), ts %llu ns\\n\",",
            "\t\t\tpage_owner->order, page_owner->gfp_mask,",
            "\t\t\t&page_owner->gfp_mask, page_owner->pid,",
            "\t\t\tpage_owner->tgid, page_owner->comm,",
            "\t\t\tpage_owner->ts_nsec);",
            "",
            "\t/* Print information relevant to grouping pages by mobility */",
            "\tpageblock_mt = get_pageblock_migratetype(page);",
            "\tpage_mt  = gfp_migratetype(page_owner->gfp_mask);",
            "\tret += scnprintf(kbuf + ret, count - ret,",
            "\t\t\t\"PFN 0x%lx type %s Block %lu type %s Flags %pGp\\n\",",
            "\t\t\tpfn,",
            "\t\t\tmigratetype_names[page_mt],",
            "\t\t\tpfn >> pageblock_order,",
            "\t\t\tmigratetype_names[pageblock_mt],",
            "\t\t\t&page->flags);",
            "",
            "\tret += stack_depot_snprint(handle, kbuf + ret, count - ret, 0);",
            "\tif (ret >= count)",
            "\t\tgoto err;",
            "",
            "\tif (page_owner->last_migrate_reason != -1) {",
            "\t\tret += scnprintf(kbuf + ret, count - ret,",
            "\t\t\t\"Page has been migrated, last migrate reason: %s\\n\",",
            "\t\t\tmigrate_reason_names[page_owner->last_migrate_reason]);",
            "\t}",
            "",
            "\tret = print_page_owner_memcg(kbuf, count, ret, page);",
            "",
            "\tret += snprintf(kbuf + ret, count - ret, \"\\n\");",
            "\tif (ret >= count)",
            "\t\tgoto err;",
            "",
            "\tif (copy_to_user(buf, kbuf, ret))",
            "\t\tret = -EFAULT;",
            "",
            "\tkfree(kbuf);",
            "\treturn ret;",
            "",
            "err:",
            "\tkfree(kbuf);",
            "\treturn -ENOMEM;",
            "}",
            "void __dump_page_owner(const struct page *page)",
            "{",
            "\tstruct page_ext *page_ext = page_ext_get((void *)page);",
            "\tstruct page_owner *page_owner;",
            "\tdepot_stack_handle_t handle;",
            "\tgfp_t gfp_mask;",
            "\tint mt;",
            "",
            "\tif (unlikely(!page_ext)) {",
            "\t\tpr_alert(\"There is not page extension available.\\n\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tpage_owner = get_page_owner(page_ext);",
            "\tgfp_mask = page_owner->gfp_mask;",
            "\tmt = gfp_migratetype(gfp_mask);",
            "",
            "\tif (!test_bit(PAGE_EXT_OWNER, &page_ext->flags)) {",
            "\t\tpr_alert(\"page_owner info is not present (never set?)\\n\");",
            "\t\tpage_ext_put(page_ext);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (test_bit(PAGE_EXT_OWNER_ALLOCATED, &page_ext->flags))",
            "\t\tpr_alert(\"page_owner tracks the page as allocated\\n\");",
            "\telse",
            "\t\tpr_alert(\"page_owner tracks the page as freed\\n\");",
            "",
            "\tpr_alert(\"page last allocated via order %u, migratetype %s, gfp_mask %#x(%pGg), pid %d, tgid %d (%s), ts %llu, free_ts %llu\\n\",",
            "\t\t page_owner->order, migratetype_names[mt], gfp_mask, &gfp_mask,",
            "\t\t page_owner->pid, page_owner->tgid, page_owner->comm,",
            "\t\t page_owner->ts_nsec, page_owner->free_ts_nsec);",
            "",
            "\thandle = READ_ONCE(page_owner->handle);",
            "\tif (!handle)",
            "\t\tpr_alert(\"page_owner allocation stack trace missing\\n\");",
            "\telse",
            "\t\tstack_depot_print(handle);",
            "",
            "\thandle = READ_ONCE(page_owner->free_handle);",
            "\tif (!handle) {",
            "\t\tpr_alert(\"page_owner free stack trace missing\\n\");",
            "\t} else {",
            "\t\tpr_alert(\"page last free pid %d tgid %d stack trace:\\n\",",
            "\t\t\t  page_owner->free_pid, page_owner->free_tgid);",
            "\t\tstack_depot_print(handle);",
            "\t}",
            "",
            "\tif (page_owner->last_migrate_reason != -1)",
            "\t\tpr_alert(\"page has been migrated, last migrate reason: %s\\n\",",
            "\t\t\tmigrate_reason_names[page_owner->last_migrate_reason]);",
            "\tpage_ext_put(page_ext);",
            "}"
          ],
          "function_name": "print_page_owner_memcg, print_page_owner, __dump_page_owner",
          "description": "实现页面所有者信息的格式化输出，包含分配/释放堆栈追踪、内存控制组关联信息，并支持调试警告输出。",
          "similarity": 0.5720252394676208
        },
        {
          "chunk_id": 2,
          "file_path": "mm/page_owner.c",
          "start_line": 189,
          "end_line": 357,
          "content": [
            "noinline void __set_page_owner(struct page *page, unsigned short order,",
            "\t\t\t\t\tgfp_t gfp_mask)",
            "{",
            "\tstruct page_ext *page_ext;",
            "\tdepot_stack_handle_t handle;",
            "",
            "\thandle = save_stack(gfp_mask);",
            "",
            "\tpage_ext = page_ext_get(page);",
            "\tif (unlikely(!page_ext))",
            "\t\treturn;",
            "\t__set_page_owner_handle(page_ext, handle, order, gfp_mask);",
            "\tpage_ext_put(page_ext);",
            "}",
            "void __set_page_owner_migrate_reason(struct page *page, int reason)",
            "{",
            "\tstruct page_ext *page_ext = page_ext_get(page);",
            "\tstruct page_owner *page_owner;",
            "",
            "\tif (unlikely(!page_ext))",
            "\t\treturn;",
            "",
            "\tpage_owner = get_page_owner(page_ext);",
            "\tpage_owner->last_migrate_reason = reason;",
            "\tpage_ext_put(page_ext);",
            "}",
            "void __split_page_owner(struct page *page, int old_order, int new_order)",
            "{",
            "\tint i;",
            "\tstruct page_ext *page_ext = page_ext_get(page);",
            "\tstruct page_owner *page_owner;",
            "",
            "\tif (unlikely(!page_ext))",
            "\t\treturn;",
            "",
            "\tfor (i = 0; i < (1 << old_order); i++) {",
            "\t\tpage_owner = get_page_owner(page_ext);",
            "\t\tpage_owner->order = new_order;",
            "\t\tpage_ext = page_ext_next(page_ext);",
            "\t}",
            "\tpage_ext_put(page_ext);",
            "}",
            "void __folio_copy_owner(struct folio *newfolio, struct folio *old)",
            "{",
            "\tstruct page_ext *old_ext;",
            "\tstruct page_ext *new_ext;",
            "\tstruct page_owner *old_page_owner, *new_page_owner;",
            "",
            "\told_ext = page_ext_get(&old->page);",
            "\tif (unlikely(!old_ext))",
            "\t\treturn;",
            "",
            "\tnew_ext = page_ext_get(&newfolio->page);",
            "\tif (unlikely(!new_ext)) {",
            "\t\tpage_ext_put(old_ext);",
            "\t\treturn;",
            "\t}",
            "",
            "\told_page_owner = get_page_owner(old_ext);",
            "\tnew_page_owner = get_page_owner(new_ext);",
            "\tnew_page_owner->order = old_page_owner->order;",
            "\tnew_page_owner->gfp_mask = old_page_owner->gfp_mask;",
            "\tnew_page_owner->last_migrate_reason =",
            "\t\told_page_owner->last_migrate_reason;",
            "\tnew_page_owner->handle = old_page_owner->handle;",
            "\tnew_page_owner->pid = old_page_owner->pid;",
            "\tnew_page_owner->tgid = old_page_owner->tgid;",
            "\tnew_page_owner->free_pid = old_page_owner->free_pid;",
            "\tnew_page_owner->free_tgid = old_page_owner->free_tgid;",
            "\tnew_page_owner->ts_nsec = old_page_owner->ts_nsec;",
            "\tnew_page_owner->free_ts_nsec = old_page_owner->ts_nsec;",
            "\tstrcpy(new_page_owner->comm, old_page_owner->comm);",
            "",
            "\t/*",
            "\t * We don't clear the bit on the old folio as it's going to be freed",
            "\t * after migration. Until then, the info can be useful in case of",
            "\t * a bug, and the overall stats will be off a bit only temporarily.",
            "\t * Also, migrate_misplaced_transhuge_page() can still fail the",
            "\t * migration and then we want the old folio to retain the info. But",
            "\t * in that case we also don't need to explicitly clear the info from",
            "\t * the new page, which will be freed.",
            "\t */",
            "\t__set_bit(PAGE_EXT_OWNER, &new_ext->flags);",
            "\t__set_bit(PAGE_EXT_OWNER_ALLOCATED, &new_ext->flags);",
            "\tpage_ext_put(new_ext);",
            "\tpage_ext_put(old_ext);",
            "}",
            "void pagetypeinfo_showmixedcount_print(struct seq_file *m,",
            "\t\t\t\t       pg_data_t *pgdat, struct zone *zone)",
            "{",
            "\tstruct page *page;",
            "\tstruct page_ext *page_ext;",
            "\tstruct page_owner *page_owner;",
            "\tunsigned long pfn, block_end_pfn;",
            "\tunsigned long end_pfn = zone_end_pfn(zone);",
            "\tunsigned long count[MIGRATE_TYPES] = { 0, };",
            "\tint pageblock_mt, page_mt;",
            "\tint i;",
            "",
            "\t/* Scan block by block. First and last block may be incomplete */",
            "\tpfn = zone->zone_start_pfn;",
            "",
            "\t/*",
            "\t * Walk the zone in pageblock_nr_pages steps. If a page block spans",
            "\t * a zone boundary, it will be double counted between zones. This does",
            "\t * not matter as the mixed block count will still be correct",
            "\t */",
            "\tfor (; pfn < end_pfn; ) {",
            "\t\tpage = pfn_to_online_page(pfn);",
            "\t\tif (!page) {",
            "\t\t\tpfn = ALIGN(pfn + 1, MAX_ORDER_NR_PAGES);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tblock_end_pfn = pageblock_end_pfn(pfn);",
            "\t\tblock_end_pfn = min(block_end_pfn, end_pfn);",
            "",
            "\t\tpageblock_mt = get_pageblock_migratetype(page);",
            "",
            "\t\tfor (; pfn < block_end_pfn; pfn++) {",
            "\t\t\t/* The pageblock is online, no need to recheck. */",
            "\t\t\tpage = pfn_to_page(pfn);",
            "",
            "\t\t\tif (page_zone(page) != zone)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tif (PageBuddy(page)) {",
            "\t\t\t\tunsigned long freepage_order;",
            "",
            "\t\t\t\tfreepage_order = buddy_order_unsafe(page);",
            "\t\t\t\tif (freepage_order <= MAX_PAGE_ORDER)",
            "\t\t\t\t\tpfn += (1UL << freepage_order) - 1;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\tif (PageReserved(page))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tpage_ext = page_ext_get(page);",
            "\t\t\tif (unlikely(!page_ext))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tif (!test_bit(PAGE_EXT_OWNER_ALLOCATED, &page_ext->flags))",
            "\t\t\t\tgoto ext_put_continue;",
            "",
            "\t\t\tpage_owner = get_page_owner(page_ext);",
            "\t\t\tpage_mt = gfp_migratetype(page_owner->gfp_mask);",
            "\t\t\tif (pageblock_mt != page_mt) {",
            "\t\t\t\tif (is_migrate_cma(pageblock_mt))",
            "\t\t\t\t\tcount[MIGRATE_MOVABLE]++;",
            "\t\t\t\telse",
            "\t\t\t\t\tcount[pageblock_mt]++;",
            "",
            "\t\t\t\tpfn = block_end_pfn;",
            "\t\t\t\tpage_ext_put(page_ext);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tpfn += (1UL << page_owner->order) - 1;",
            "ext_put_continue:",
            "\t\t\tpage_ext_put(page_ext);",
            "\t\t}",
            "\t}",
            "",
            "\t/* Print counts */",
            "\tseq_printf(m, \"Node %d, zone %8s \", pgdat->node_id, zone->name);",
            "\tfor (i = 0; i < MIGRATE_TYPES; i++)",
            "\t\tseq_printf(m, \"%12lu \", count[i]);",
            "\tseq_putc(m, '\\n');",
            "}"
          ],
          "function_name": "__set_page_owner, __set_page_owner_migrate_reason, __split_page_owner, __folio_copy_owner, pagetypeinfo_showmixedcount_print",
          "description": "提供页面所有者信息的设置、分裂、复制及混合统计打印功能，通过遍历页面扩展结构体维护分配/释放状态和迁移类型信息。",
          "similarity": 0.5609535574913025
        },
        {
          "chunk_id": 4,
          "file_path": "mm/page_owner.c",
          "start_line": 514,
          "end_line": 624,
          "content": [
            "static ssize_t",
            "read_page_owner(struct file *file, char __user *buf, size_t count, loff_t *ppos)",
            "{",
            "\tunsigned long pfn;",
            "\tstruct page *page;",
            "\tstruct page_ext *page_ext;",
            "\tstruct page_owner *page_owner;",
            "\tdepot_stack_handle_t handle;",
            "",
            "\tif (!static_branch_unlikely(&page_owner_inited))",
            "\t\treturn -EINVAL;",
            "",
            "\tpage = NULL;",
            "\tif (*ppos == 0)",
            "\t\tpfn = min_low_pfn;",
            "\telse",
            "\t\tpfn = *ppos;",
            "\t/* Find a valid PFN or the start of a MAX_ORDER_NR_PAGES area */",
            "\twhile (!pfn_valid(pfn) && (pfn & (MAX_ORDER_NR_PAGES - 1)) != 0)",
            "\t\tpfn++;",
            "",
            "\t/* Find an allocated page */",
            "\tfor (; pfn < max_pfn; pfn++) {",
            "\t\t/*",
            "\t\t * This temporary page_owner is required so",
            "\t\t * that we can avoid the context switches while holding",
            "\t\t * the rcu lock and copying the page owner information to",
            "\t\t * user through copy_to_user() or GFP_KERNEL allocations.",
            "\t\t */",
            "\t\tstruct page_owner page_owner_tmp;",
            "",
            "\t\t/*",
            "\t\t * If the new page is in a new MAX_ORDER_NR_PAGES area,",
            "\t\t * validate the area as existing, skip it if not",
            "\t\t */",
            "\t\tif ((pfn & (MAX_ORDER_NR_PAGES - 1)) == 0 && !pfn_valid(pfn)) {",
            "\t\t\tpfn += MAX_ORDER_NR_PAGES - 1;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tpage = pfn_to_page(pfn);",
            "\t\tif (PageBuddy(page)) {",
            "\t\t\tunsigned long freepage_order = buddy_order_unsafe(page);",
            "",
            "\t\t\tif (freepage_order <= MAX_PAGE_ORDER)",
            "\t\t\t\tpfn += (1UL << freepage_order) - 1;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tpage_ext = page_ext_get(page);",
            "\t\tif (unlikely(!page_ext))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Some pages could be missed by concurrent allocation or free,",
            "\t\t * because we don't hold the zone lock.",
            "\t\t */",
            "\t\tif (!test_bit(PAGE_EXT_OWNER, &page_ext->flags))",
            "\t\t\tgoto ext_put_continue;",
            "",
            "\t\t/*",
            "\t\t * Although we do have the info about past allocation of free",
            "\t\t * pages, it's not relevant for current memory usage.",
            "\t\t */",
            "\t\tif (!test_bit(PAGE_EXT_OWNER_ALLOCATED, &page_ext->flags))",
            "\t\t\tgoto ext_put_continue;",
            "",
            "\t\tpage_owner = get_page_owner(page_ext);",
            "",
            "\t\t/*",
            "\t\t * Don't print \"tail\" pages of high-order allocations as that",
            "\t\t * would inflate the stats.",
            "\t\t */",
            "\t\tif (!IS_ALIGNED(pfn, 1 << page_owner->order))",
            "\t\t\tgoto ext_put_continue;",
            "",
            "\t\t/*",
            "\t\t * Access to page_ext->handle isn't synchronous so we should",
            "\t\t * be careful to access it.",
            "\t\t */",
            "\t\thandle = READ_ONCE(page_owner->handle);",
            "\t\tif (!handle)",
            "\t\t\tgoto ext_put_continue;",
            "",
            "\t\t/* Record the next PFN to read in the file offset */",
            "\t\t*ppos = pfn + 1;",
            "",
            "\t\tpage_owner_tmp = *page_owner;",
            "\t\tpage_ext_put(page_ext);",
            "\t\treturn print_page_owner(buf, count, pfn, page,",
            "\t\t\t\t&page_owner_tmp, handle);",
            "ext_put_continue:",
            "\t\tpage_ext_put(page_ext);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static loff_t lseek_page_owner(struct file *file, loff_t offset, int orig)",
            "{",
            "\tswitch (orig) {",
            "\tcase SEEK_SET:",
            "\t\tfile->f_pos = offset;",
            "\t\tbreak;",
            "\tcase SEEK_CUR:",
            "\t\tfile->f_pos += offset;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn file->f_pos;",
            "}"
          ],
          "function_name": "read_page_owner, lseek_page_owner",
          "description": "提供基于文件操作的页面所有者信息遍历接口，通过PFN扫描实现按序读取页面分配记录，支持文件指针偏移量管理和数据同步访问。",
          "similarity": 0.5557142496109009
        },
        {
          "chunk_id": 1,
          "file_path": "mm/page_owner.c",
          "start_line": 48,
          "end_line": 157,
          "content": [
            "static int __init early_page_owner_param(char *buf)",
            "{",
            "\tint ret = kstrtobool(buf, &page_owner_enabled);",
            "",
            "\tif (page_owner_enabled)",
            "\t\tstack_depot_request_early_init();",
            "",
            "\treturn ret;",
            "}",
            "static __init bool need_page_owner(void)",
            "{",
            "\treturn page_owner_enabled;",
            "}",
            "static noinline void register_dummy_stack(void)",
            "{",
            "\tdummy_handle = create_dummy_stack();",
            "}",
            "static noinline void register_failure_stack(void)",
            "{",
            "\tfailure_handle = create_dummy_stack();",
            "}",
            "static noinline void register_early_stack(void)",
            "{",
            "\tearly_handle = create_dummy_stack();",
            "}",
            "static __init void init_page_owner(void)",
            "{",
            "\tif (!page_owner_enabled)",
            "\t\treturn;",
            "",
            "\tregister_dummy_stack();",
            "\tregister_failure_stack();",
            "\tregister_early_stack();",
            "\tstatic_branch_enable(&page_owner_inited);",
            "\tinit_early_allocated_pages();",
            "}",
            "static noinline depot_stack_handle_t save_stack(gfp_t flags)",
            "{",
            "\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];",
            "\tdepot_stack_handle_t handle;",
            "\tunsigned int nr_entries;",
            "",
            "\t/*",
            "\t * Avoid recursion.",
            "\t *",
            "\t * Sometimes page metadata allocation tracking requires more",
            "\t * memory to be allocated:",
            "\t * - when new stack trace is saved to stack depot",
            "\t */",
            "\tif (current->in_page_owner)",
            "\t\treturn dummy_handle;",
            "\tcurrent->in_page_owner = 1;",
            "",
            "\tnr_entries = stack_trace_save(entries, ARRAY_SIZE(entries), 2);",
            "\thandle = stack_depot_save(entries, nr_entries, flags);",
            "\tif (!handle)",
            "\t\thandle = failure_handle;",
            "",
            "\tcurrent->in_page_owner = 0;",
            "\treturn handle;",
            "}",
            "void __reset_page_owner(struct page *page, unsigned short order)",
            "{",
            "\tint i;",
            "\tstruct page_ext *page_ext;",
            "\tdepot_stack_handle_t handle;",
            "\tstruct page_owner *page_owner;",
            "\tu64 free_ts_nsec = local_clock();",
            "",
            "\tpage_ext = page_ext_get(page);",
            "\tif (unlikely(!page_ext))",
            "\t\treturn;",
            "",
            "\thandle = save_stack(GFP_NOWAIT | __GFP_NOWARN);",
            "\tfor (i = 0; i < (1 << order); i++) {",
            "\t\t__clear_bit(PAGE_EXT_OWNER_ALLOCATED, &page_ext->flags);",
            "\t\tpage_owner = get_page_owner(page_ext);",
            "\t\tpage_owner->free_handle = handle;",
            "\t\tpage_owner->free_ts_nsec = free_ts_nsec;",
            "\t\tpage_owner->free_pid = current->pid;",
            "\t\tpage_owner->free_tgid = current->tgid;",
            "\t\tpage_ext = page_ext_next(page_ext);",
            "\t}",
            "\tpage_ext_put(page_ext);",
            "}",
            "static inline void __set_page_owner_handle(struct page_ext *page_ext,",
            "\t\t\t\t\tdepot_stack_handle_t handle,",
            "\t\t\t\t\tunsigned short order, gfp_t gfp_mask)",
            "{",
            "\tstruct page_owner *page_owner;",
            "\tint i;",
            "\tu64 ts_nsec = local_clock();",
            "",
            "\tfor (i = 0; i < (1 << order); i++) {",
            "\t\tpage_owner = get_page_owner(page_ext);",
            "\t\tpage_owner->handle = handle;",
            "\t\tpage_owner->order = order;",
            "\t\tpage_owner->gfp_mask = gfp_mask;",
            "\t\tpage_owner->last_migrate_reason = -1;",
            "\t\tpage_owner->pid = current->pid;",
            "\t\tpage_owner->tgid = current->tgid;",
            "\t\tpage_owner->ts_nsec = ts_nsec;",
            "\t\tstrscpy(page_owner->comm, current->comm,",
            "\t\t\tsizeof(page_owner->comm));",
            "\t\t__set_bit(PAGE_EXT_OWNER, &page_ext->flags);",
            "\t\t__set_bit(PAGE_EXT_OWNER_ALLOCATED, &page_ext->flags);",
            "",
            "\t\tpage_ext = page_ext_next(page_ext);",
            "\t}",
            "}"
          ],
          "function_name": "early_page_owner_param, need_page_owner, register_dummy_stack, register_failure_stack, register_early_stack, init_page_owner, save_stack, __reset_page_owner, __set_page_owner_handle",
          "description": "实现页面所有者跟踪模块的初始化逻辑，包含堆栈句柄注册、堆栈保存、页面释放标记更新等功能，支持递归保护和堆栈深度限制。",
          "similarity": 0.5451019406318665
        }
      ]
    }
  ]
}