{
  "query": "fork系统调用在内核中的实现原理",
  "timestamp": "2025-12-26 00:39:01",
  "retrieved_files": [
    {
      "source_file": "kernel/fork.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:30:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `fork.c`\n\n---\n\n# fork.c 技术文档\n\n## 1. 文件概述\n\n`fork.c` 是 Linux 内核中实现进程创建（fork）系统调用的核心源文件。该文件包含了创建新进程所需的所有辅助例程，负责复制父进程的资源（如内存、文件描述符、信号处理等）以生成子进程。虽然 fork 逻辑本身概念简单，但其涉及的内存管理（尤其是写时复制 COW 机制）极为复杂，实际内存页的复制由 `mm/memory.c` 中的 `copy_page_range()` 等函数处理。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `total_forks`: 累计系统自启动以来创建的进程总数\n- `nr_threads`: 当前系统中的线程总数（不包括 idle 线程）\n- `max_threads`: 可配置的线程数量上限（默认为 `FUTEX_TID_MASK`）\n- `process_counts`: 每 CPU 的进程计数器（per-CPU 变量）\n- `tasklist_lock`: 保护任务链表的读写锁（全局任务列表的同步原语）\n\n### 关键辅助函数\n- `nr_processes()`: 计算系统中所有进程的总数（聚合各 CPU 的 `process_counts`）\n- `arch_release_task_struct()`: 架构相关的 task_struct 释放钩子（弱符号，默认为空）\n- `alloc_task_struct_node()` / `free_task_struct()`: 分配/释放 `task_struct` 结构（基于 slab 分配器）\n- `alloc_thread_stack_node()` / `thread_stack_delayed_free()`: 分配/延迟释放线程内核栈（支持 `CONFIG_VMAP_STACK`）\n\n### 核心数据结构\n- `resident_page_types[]`: 用于内存统计的页面类型名称映射数组\n- `vm_stack`: 用于 RCU 延迟释放的虚拟内存栈封装结构\n- `cached_stacks[NR_CACHED_STACKS]`: 每 CPU 的内核栈缓存（减少频繁 vmalloc/vfree 开销）\n\n## 3. 关键实现\n\n### 进程/线程计数管理\n- 使用 per-CPU 变量 `process_counts` 避免全局锁竞争\n- 全局计数器 `nr_threads` 和 `total_forks` 由 `tasklist_lock` 保护\n- `nr_processes()` 通过遍历所有可能的 CPU 聚合计数\n\n### 内核栈分配策略（`CONFIG_VMAP_STACK`）\n- **缓存机制**：每个 CPU 缓存最多 2 个已释放的栈（`NR_CACHED_STACKS`），减少 TLB 刷新和 vmalloc 开销\n- **内存分配**：\n  - 优先从本地缓存获取栈\n  - 缓存未命中时使用 `__vmalloc_node_range()` 分配连续虚拟地址空间\n  - 显式禁用 `__GFP_ACCOUNT`（因后续手动进行 memcg 计费）\n- **安全清理**：\n  - 重用栈时清零内存（`memset(stack, 0, THREAD_SIZE)`）\n  - KASAN 消毒（`kasan_unpoison_range`）和标签重置\n- **延迟释放**：\n  - 通过 RCU 机制延迟释放栈（`call_rcu`）\n  - 释放时尝试回填缓存，失败则直接 `vfree`\n\n### 内存控制组（memcg）集成\n- 手动对栈的每个物理页进行 memcg 计费（`memcg_kmem_charge_page`）\n- 计费失败时回滚已计费页面（`memcg_kmem_uncharge_page`）\n- 确保内核栈内存纳入 cgroup 内存限制\n\n### 锁与同步\n- `tasklist_lock` 作为全局任务列表的保护锁（读写锁）\n- 提供 `lockdep_tasklist_lock_is_held()` 供 RCU 锁验证使用\n- RCU 用于安全延迟释放内核栈资源\n\n## 4. 依赖关系\n\n### 内核子系统依赖\n- **内存管理 (MM)**：`<linux/mm.h>`, `<linux/vmalloc.h>`, `<linux/memcontrol.h>`\n- **调度器 (Scheduler)**：`<linux/sched/*.h>`, 任务状态和 CPU 绑定\n- **安全模块**：`<linux/security.h>`, `<linux/capability.h>`, `<linux/seccomp.h>`\n- **命名空间**：`<linux/nsproxy.h>`（UTS, IPC, PID, 网络等）\n- **文件系统**：`<linux/fs.h>`, `<linux/fdtable.h>`（文件描述符复制）\n- **跟踪与调试**：`<trace/events/sched.h>`, `<linux/ftrace.h>`, KASAN/KMSAN\n\n### 架构相关依赖\n- `<asm/pgalloc.h>`：页表分配\n- `<asm/mmu_context.h>`：MMU 上下文切换\n- `<asm/tlbflush.h>`：TLB 刷新操作\n- 架构特定的 `THREAD_SIZE` 和栈对齐要求\n\n### 配置选项依赖\n- `CONFIG_VMAP_STACK`：启用虚拟内存分配内核栈\n- `CONFIG_PROVE_RCU`：RCU 锁验证支持\n- `CONFIG_ARCH_TASK_STRUCT_ALLOCATOR`：架构自定义 task_struct 分配器\n- `CONFIG_MEMCG_KMEM`：内核内存 cgroup 支持\n\n## 5. 使用场景\n\n### 进程创建路径\n- **系统调用入口**：`sys_fork()`, `sys_vfork()`, `sys_clone()` 最终调用 `_do_fork()`\n- **内核线程创建**：`kthread_create()` 通过 `kernel_thread()` 触发 fork 逻辑\n- **容器/命名空间初始化**：新 PID/UTS/IPC 命名空间创建时伴随进程 fork\n\n### 资源复制关键点\n- **内存描述符 (mm_struct)**：通过 `dup_mm()` 复制地址空间（COW 页表）\n- **文件描述符表**：`dup_fd()` 复制打开文件表\n- **信号处理**：复制信号掩码和处理函数\n- **POSIX 定时器/异步 I/O**：复制相关上下文（如 `aio`, `posix-timers`）\n\n### 特殊场景处理\n- **写时复制优化**：避免物理内存立即复制，提升 fork 性能\n- **OOM Killer 集成**：在内存不足时参与进程选择\n- **审计与监控**：通过 `audit_alloc()` 和 `proc` 文件系统暴露进程信息\n- **实时性保障**：RT 任务 fork 时保持调度策略和优先级",
      "similarity": 0.7014840841293335,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/fork.c",
          "start_line": 666,
          "end_line": 845,
          "content": [
            "static __latent_entropy int dup_mmap(struct mm_struct *mm,",
            "\t\t\t\t\tstruct mm_struct *oldmm)",
            "{",
            "\tstruct vm_area_struct *mpnt, *tmp;",
            "\tint retval;",
            "\tunsigned long charge = 0;",
            "\tLIST_HEAD(uf);",
            "\tVMA_ITERATOR(vmi, mm, 0);",
            "",
            "\tuprobe_start_dup_mmap();",
            "\tif (mmap_write_lock_killable(oldmm)) {",
            "\t\tretval = -EINTR;",
            "\t\tgoto fail_uprobe_end;",
            "\t}",
            "\tflush_cache_dup_mm(oldmm);",
            "\tuprobe_dup_mmap(oldmm, mm);",
            "\t/*",
            "\t * Not linked in yet - no deadlock potential:",
            "\t */",
            "\tmmap_write_lock_nested(mm, SINGLE_DEPTH_NESTING);",
            "",
            "\t/* No ordering required: file already has been exposed. */",
            "\tdup_mm_exe_file(mm, oldmm);",
            "",
            "\tmm->total_vm = oldmm->total_vm;",
            "\tmm->data_vm = oldmm->data_vm;",
            "\tmm->exec_vm = oldmm->exec_vm;",
            "\tmm->stack_vm = oldmm->stack_vm;",
            "",
            "\t/* Use __mt_dup() to efficiently build an identical maple tree. */",
            "\tretval = __mt_dup(&oldmm->mm_mt, &mm->mm_mt, GFP_KERNEL);",
            "\tif (unlikely(retval))",
            "\t\tgoto out;",
            "",
            "\tmt_clear_in_rcu(vmi.mas.tree);",
            "\tfor_each_vma(vmi, mpnt) {",
            "\t\tstruct file *file;",
            "",
            "\t\tvma_start_write(mpnt);",
            "\t\tif (mpnt->vm_flags & VM_DONTCOPY) {",
            "\t\t\tretval = vma_iter_clear_gfp(&vmi, mpnt->vm_start,",
            "\t\t\t\t\t\t    mpnt->vm_end, GFP_KERNEL);",
            "\t\t\tif (retval)",
            "\t\t\t\tgoto loop_out;",
            "",
            "\t\t\tvm_stat_account(mm, mpnt->vm_flags, -vma_pages(mpnt));",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tcharge = 0;",
            "\t\t/*",
            "\t\t * Don't duplicate many vmas if we've been oom-killed (for",
            "\t\t * example)",
            "\t\t */",
            "\t\tif (fatal_signal_pending(current)) {",
            "\t\t\tretval = -EINTR;",
            "\t\t\tgoto loop_out;",
            "\t\t}",
            "\t\tif (mpnt->vm_flags & VM_ACCOUNT) {",
            "\t\t\tunsigned long len = vma_pages(mpnt);",
            "",
            "\t\t\tif (security_vm_enough_memory_mm(oldmm, len)) /* sic */",
            "\t\t\t\tgoto fail_nomem;",
            "\t\t\tcharge = len;",
            "\t\t}",
            "\t\ttmp = vm_area_dup(mpnt);",
            "\t\tif (!tmp)",
            "\t\t\tgoto fail_nomem;",
            "",
            "\t\t/* track_pfn_copy() will later take care of copying internal state. */",
            "\t\tif (unlikely(tmp->vm_flags & VM_PFNMAP))",
            "\t\t\tuntrack_pfn_clear(tmp);",
            "",
            "\t\tretval = vma_dup_policy(mpnt, tmp);",
            "\t\tif (retval)",
            "\t\t\tgoto fail_nomem_policy;",
            "\t\ttmp->vm_mm = mm;",
            "\t\tretval = dup_userfaultfd(tmp, &uf);",
            "\t\tif (retval)",
            "\t\t\tgoto fail_nomem_anon_vma_fork;",
            "\t\tif (tmp->vm_flags & VM_WIPEONFORK) {",
            "\t\t\t/*",
            "\t\t\t * VM_WIPEONFORK gets a clean slate in the child.",
            "\t\t\t * Don't prepare anon_vma until fault since we don't",
            "\t\t\t * copy page for current vma.",
            "\t\t\t */",
            "\t\t\ttmp->anon_vma = NULL;",
            "\t\t} else if (anon_vma_fork(tmp, mpnt))",
            "\t\t\tgoto fail_nomem_anon_vma_fork;",
            "\t\tvm_flags_clear(tmp, VM_LOCKED_MASK);",
            "\t\tfile = tmp->vm_file;",
            "\t\tif (file) {",
            "\t\t\tstruct address_space *mapping = file->f_mapping;",
            "",
            "\t\t\tget_file(file);",
            "\t\t\ti_mmap_lock_write(mapping);",
            "\t\t\tif (vma_is_shared_maywrite(tmp))",
            "\t\t\t\tmapping_allow_writable(mapping);",
            "\t\t\tflush_dcache_mmap_lock(mapping);",
            "\t\t\t/* insert tmp into the share list, just after mpnt */",
            "\t\t\tvma_interval_tree_insert_after(tmp, mpnt,",
            "\t\t\t\t\t&mapping->i_mmap);",
            "\t\t\tflush_dcache_mmap_unlock(mapping);",
            "\t\t\ti_mmap_unlock_write(mapping);",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Copy/update hugetlb private vma information.",
            "\t\t */",
            "\t\tif (is_vm_hugetlb_page(tmp))",
            "\t\t\thugetlb_dup_vma_private(tmp);",
            "",
            "\t\t/*",
            "\t\t * Link the vma into the MT. After using __mt_dup(), memory",
            "\t\t * allocation is not necessary here, so it cannot fail.",
            "\t\t */",
            "\t\tvma_iter_bulk_store(&vmi, tmp);",
            "",
            "\t\tmm->map_count++;",
            "\t\tif (!(tmp->vm_flags & VM_WIPEONFORK))",
            "\t\t\tretval = copy_page_range(tmp, mpnt);",
            "",
            "\t\tif (tmp->vm_ops && tmp->vm_ops->open)",
            "\t\t\ttmp->vm_ops->open(tmp);",
            "",
            "\t\tif (retval) {",
            "\t\t\tmpnt = vma_next(&vmi);",
            "\t\t\tgoto loop_out;",
            "\t\t}",
            "\t}",
            "\t/* a new mm has just been created */",
            "\tretval = arch_dup_mmap(oldmm, mm);",
            "loop_out:",
            "\tvma_iter_free(&vmi);",
            "\tif (!retval) {",
            "\t\tmt_set_in_rcu(vmi.mas.tree);",
            "\t\tksm_fork(mm, oldmm);",
            "\t\tkhugepaged_fork(mm, oldmm);",
            "\t} else {",
            "",
            "\t\t/*",
            "\t\t * The entire maple tree has already been duplicated. If the",
            "\t\t * mmap duplication fails, mark the failure point with",
            "\t\t * XA_ZERO_ENTRY. In exit_mmap(), if this marker is encountered,",
            "\t\t * stop releasing VMAs that have not been duplicated after this",
            "\t\t * point.",
            "\t\t */",
            "\t\tif (mpnt) {",
            "\t\t\tmas_set_range(&vmi.mas, mpnt->vm_start, mpnt->vm_end - 1);",
            "\t\t\tmas_store(&vmi.mas, XA_ZERO_ENTRY);",
            "\t\t\t/* Avoid OOM iterating a broken tree */",
            "\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);",
            "\t\t}",
            "\t\t/*",
            "\t\t * The mm_struct is going to exit, but the locks will be dropped",
            "\t\t * first.  Set the mm_struct as unstable is advisable as it is",
            "\t\t * not fully initialised.",
            "\t\t */",
            "\t\tset_bit(MMF_UNSTABLE, &mm->flags);",
            "\t}",
            "out:",
            "\tmmap_write_unlock(mm);",
            "\tflush_tlb_mm(oldmm);",
            "\tmmap_write_unlock(oldmm);",
            "\tif (!retval)",
            "\t\tdup_userfaultfd_complete(&uf);",
            "\telse",
            "\t\tdup_userfaultfd_fail(&uf);",
            "fail_uprobe_end:",
            "\tuprobe_end_dup_mmap();",
            "\treturn retval;",
            "",
            "fail_nomem_anon_vma_fork:",
            "\tmpol_put(vma_policy(tmp));",
            "fail_nomem_policy:",
            "\tvm_area_free(tmp);",
            "fail_nomem:",
            "\tretval = -ENOMEM;",
            "\tvm_unacct_memory(charge);",
            "\tgoto loop_out;",
            "}"
          ],
          "function_name": "dup_mmap",
          "description": "实现进程fork时的内存映射复制逻辑，深度遍历原进程的VMA结构创建副本，处理共享文件映射、hugetlb页等特殊内存类型，并管理OOM异常情况下的失败恢复。",
          "similarity": 0.6219190955162048
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/fork.c",
          "start_line": 1,
          "end_line": 158,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/kernel/fork.c",
            " *",
            " *  Copyright (C) 1991, 1992  Linus Torvalds",
            " */",
            "",
            "/*",
            " *  'fork.c' contains the help-routines for the 'fork' system call",
            " * (see also entry.S and others).",
            " * Fork is rather simple, once you get the hang of it, but the memory",
            " * management can be a bitch. See 'mm/memory.c': 'copy_page_range()'",
            " */",
            "",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/ext.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/init.h>",
            "#include <linux/unistd.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/completion.h>",
            "#include <linux/personality.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/sem.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/key.h>",
            "#include <linux/kmsan.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/mman.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memblock.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/capability.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/security.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/syscall_user_dispatch.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/futex.h>",
            "#include <linux/compat.h>",
            "#include <linux/kthread.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/mount.h>",
            "#include <linux/audit.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/profile.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/acct.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/magic.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/oom.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/aio.h>",
            "#include <linux/compiler.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/kcov.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/scs.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/bpf.h>",
            "#include <linux/stackprotector.h>",
            "#include <linux/user_events.h>",
            "#include <linux/iommu.h>",
            "#include <linux/rseq.h>",
            "#include <uapi/linux/pidfd.h>",
            "#include <linux/pidfs.h>",
            "#include <linux/tick.h>",
            "",
            "#include <asm/pgalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/tlbflush.h>",
            "",
            "#include <trace/events/sched.h>",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/task.h>",
            "",
            "#ifdef CONFIG_IEE",
            "#include <asm/iee-token.h>",
            "#endif",
            "",
            "#include <kunit/visibility.h>",
            "",
            "/*",
            " * Minimum number of threads to boot the kernel",
            " */",
            "#define MIN_THREADS 20",
            "",
            "/*",
            " * Maximum number of threads",
            " */",
            "#define MAX_THREADS FUTEX_TID_MASK",
            "",
            "/*",
            " * Protected counters by write_lock_irq(&tasklist_lock)",
            " */",
            "unsigned long total_forks;\t/* Handle normal Linux uptimes. */",
            "int nr_threads;\t\t\t/* The idle threads do not count.. */",
            "",
            "static int max_threads;\t\t/* tunable limit on nr_threads */",
            "",
            "#define NAMED_ARRAY_INDEX(x)\t[x] = __stringify(x)",
            "",
            "static const char * const resident_page_types[] = {",
            "\tNAMED_ARRAY_INDEX(MM_FILEPAGES),",
            "\tNAMED_ARRAY_INDEX(MM_ANONPAGES),",
            "\tNAMED_ARRAY_INDEX(MM_SWAPENTS),",
            "\tNAMED_ARRAY_INDEX(MM_SHMEMPAGES),",
            "};",
            "",
            "DEFINE_PER_CPU(unsigned long, process_counts) = 0;",
            "",
            "__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);  /* outer */",
            "",
            "#ifdef CONFIG_PROVE_RCU"
          ],
          "function_name": null,
          "description": "此代码块包含fork.c的头文件和全局变量定义，主要用于声明任务列表锁、线程计数器及内核栈相关配置，为后续的进程fork操作提供基础设施支持。",
          "similarity": 0.6120731830596924
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/fork.c",
          "start_line": 2176,
          "end_line": 2282,
          "content": [
            "static void rv_task_fork(struct task_struct *p)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < RV_PER_TASK_MONITORS; i++)",
            "\t\tp->rv[i].da_mon.monitoring = false;",
            "}",
            "static inline void init_idle_pids(struct task_struct *idle)",
            "{",
            "\tenum pid_type type;",
            "",
            "\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {",
            "\t\tINIT_HLIST_NODE(&idle->pid_links[type]); /* not really needed */",
            "\t\tinit_task_pid(idle, type, &init_struct_pid);",
            "\t}",
            "}",
            "static int idle_dummy(void *dummy)",
            "{",
            "\t/* This function is never called */",
            "\treturn 0;",
            "}",
            "pid_t kernel_clone(struct kernel_clone_args *args)",
            "{",
            "\tu64 clone_flags = args->flags;",
            "\tstruct completion vfork;",
            "\tstruct pid *pid;",
            "\tstruct task_struct *p;",
            "\tint trace = 0;",
            "\tpid_t nr;",
            "",
            "\t/*",
            "\t * For legacy clone() calls, CLONE_PIDFD uses the parent_tid argument",
            "\t * to return the pidfd. Hence, CLONE_PIDFD and CLONE_PARENT_SETTID are",
            "\t * mutually exclusive. With clone3() CLONE_PIDFD has grown a separate",
            "\t * field in struct clone_args and it still doesn't make sense to have",
            "\t * them both point at the same memory location. Performing this check",
            "\t * here has the advantage that we don't need to have a separate helper",
            "\t * to check for legacy clone().",
            "\t */",
            "\tif ((args->flags & CLONE_PIDFD) &&",
            "\t    (args->flags & CLONE_PARENT_SETTID) &&",
            "\t    (args->pidfd == args->parent_tid))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Determine whether and which event to report to ptracer.  When",
            "\t * called from kernel_thread or CLONE_UNTRACED is explicitly",
            "\t * requested, no event is reported; otherwise, report if the event",
            "\t * for the type of forking is enabled.",
            "\t */",
            "\tif (!(clone_flags & CLONE_UNTRACED)) {",
            "\t\tif (clone_flags & CLONE_VFORK)",
            "\t\t\ttrace = PTRACE_EVENT_VFORK;",
            "\t\telse if (args->exit_signal != SIGCHLD)",
            "\t\t\ttrace = PTRACE_EVENT_CLONE;",
            "\t\telse",
            "\t\t\ttrace = PTRACE_EVENT_FORK;",
            "",
            "\t\tif (likely(!ptrace_event_enabled(current, trace)))",
            "\t\t\ttrace = 0;",
            "\t}",
            "",
            "\tp = copy_process(NULL, trace, NUMA_NO_NODE, args);",
            "\tadd_latent_entropy();",
            "",
            "\tif (IS_ERR(p))",
            "\t\treturn PTR_ERR(p);",
            "",
            "\t/*",
            "\t * Do this prior waking up the new thread - the thread pointer",
            "\t * might get invalid after that point, if the thread exits quickly.",
            "\t */",
            "\ttrace_sched_process_fork(current, p);",
            "",
            "\tpid = get_task_pid(p, PIDTYPE_PID);",
            "\tnr = pid_vnr(pid);",
            "",
            "\tif (clone_flags & CLONE_PARENT_SETTID)",
            "\t\tput_user(nr, args->parent_tid);",
            "",
            "\tif (clone_flags & CLONE_VFORK) {",
            "\t\tp->vfork_done = &vfork;",
            "\t\tinit_completion(&vfork);",
            "\t\tget_task_struct(p);",
            "\t}",
            "",
            "\tif (IS_ENABLED(CONFIG_LRU_GEN_WALKS_MMU) && !(clone_flags & CLONE_VM)) {",
            "\t\t/* lock the task to synchronize with memcg migration */",
            "\t\ttask_lock(p);",
            "\t\tlru_gen_add_mm(p->mm);",
            "\t\ttask_unlock(p);",
            "\t}",
            "",
            "\twake_up_new_task(p);",
            "",
            "\t/* forking complete and child started to run, tell ptracer */",
            "\tif (unlikely(trace))",
            "\t\tptrace_event_pid(trace, pid);",
            "",
            "\tif (clone_flags & CLONE_VFORK) {",
            "\t\tif (!wait_for_vfork_done(p, &vfork))",
            "\t\t\tptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);",
            "\t}",
            "",
            "\tput_pid(pid);",
            "\treturn nr;",
            "}"
          ],
          "function_name": "rv_task_fork, init_idle_pids, idle_dummy, kernel_clone",
          "description": "实现kernel_clone核心逻辑，创建新进程并处理克隆标志，管理子进程启动、vfork等待及进程树遍历，包含空闲任务PID初始化与RV监控器重置",
          "similarity": 0.5618375539779663
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/fork.c",
          "start_line": 1503,
          "end_line": 1608,
          "content": [
            "int replace_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)",
            "{",
            "\tstruct vm_area_struct *vma;",
            "\tstruct file *old_exe_file;",
            "\tint ret = 0;",
            "",
            "\t/* Forbid mm->exe_file change if old file still mapped. */",
            "\told_exe_file = get_mm_exe_file(mm);",
            "\tif (old_exe_file) {",
            "\t\tVMA_ITERATOR(vmi, mm, 0);",
            "\t\tmmap_read_lock(mm);",
            "\t\tfor_each_vma(vmi, vma) {",
            "\t\t\tif (!vma->vm_file)",
            "\t\t\t\tcontinue;",
            "\t\t\tif (path_equal(&vma->vm_file->f_path,",
            "\t\t\t\t       &old_exe_file->f_path)) {",
            "\t\t\t\tret = -EBUSY;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tmmap_read_unlock(mm);",
            "\t\tfput(old_exe_file);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\tret = deny_write_access(new_exe_file);",
            "\tif (ret)",
            "\t\treturn -EACCES;",
            "\tget_file(new_exe_file);",
            "",
            "\t/* set the new file */",
            "\tmmap_write_lock(mm);",
            "\told_exe_file = rcu_dereference_raw(mm->exe_file);",
            "\trcu_assign_pointer(mm->exe_file, new_exe_file);",
            "\tmmap_write_unlock(mm);",
            "",
            "\tif (old_exe_file) {",
            "\t\tallow_write_access(old_exe_file);",
            "\t\tfput(old_exe_file);",
            "\t}",
            "\treturn 0;",
            "}",
            "static void complete_vfork_done(struct task_struct *tsk)",
            "{",
            "\tstruct completion *vfork;",
            "",
            "\ttask_lock(tsk);",
            "\tvfork = tsk->vfork_done;",
            "\tif (likely(vfork)) {",
            "\t\ttsk->vfork_done = NULL;",
            "\t\tcomplete(vfork);",
            "\t}",
            "\ttask_unlock(tsk);",
            "}",
            "static int wait_for_vfork_done(struct task_struct *child,",
            "\t\t\t\tstruct completion *vfork)",
            "{",
            "\tunsigned int state = TASK_UNINTERRUPTIBLE|TASK_KILLABLE|TASK_FREEZABLE;",
            "\tint killed;",
            "",
            "\tcgroup_enter_frozen();",
            "\tkilled = wait_for_completion_state(vfork, state);",
            "\tcgroup_leave_frozen(false);",
            "",
            "\tif (killed) {",
            "\t\ttask_lock(child);",
            "\t\tchild->vfork_done = NULL;",
            "\t\ttask_unlock(child);",
            "\t}",
            "",
            "\tput_task_struct(child);",
            "\treturn killed;",
            "}",
            "static void mm_release(struct task_struct *tsk, struct mm_struct *mm)",
            "{",
            "\tuprobe_free_utask(tsk);",
            "",
            "\t/* Get rid of any cached register state */",
            "\tdeactivate_mm(tsk, mm);",
            "",
            "\t/*",
            "\t * Signal userspace if we're not exiting with a core dump",
            "\t * because we want to leave the value intact for debugging",
            "\t * purposes.",
            "\t */",
            "\tif (tsk->clear_child_tid) {",
            "\t\tif (atomic_read(&mm->mm_users) > 1) {",
            "\t\t\t/*",
            "\t\t\t * We don't check the error code - if userspace has",
            "\t\t\t * not set up a proper pointer then tough luck.",
            "\t\t\t */",
            "\t\t\tput_user(0, tsk->clear_child_tid);",
            "\t\t\tdo_futex(tsk->clear_child_tid, FUTEX_WAKE,",
            "\t\t\t\t\t1, NULL, NULL, 0, 0);",
            "\t\t}",
            "\t\ttsk->clear_child_tid = NULL;",
            "\t}",
            "",
            "\t/*",
            "\t * All done, finally we can wake up parent and return this mm to him.",
            "\t * Also kthread_stop() uses this completion for synchronization.",
            "\t */",
            "\tif (tsk->vfork_done)",
            "\t\tcomplete_vfork_done(tsk);",
            "}"
          ],
          "function_name": "replace_mm_exe_file, complete_vfork_done, wait_for_vfork_done, mm_release",
          "description": "替换当前mm的可执行文件，完成vfork同步操作并等待子进程完成，释放mm时通知父进程完成vfork同步。",
          "similarity": 0.5463411808013916
        },
        {
          "chunk_id": 13,
          "file_path": "kernel/fork.c",
          "start_line": 2924,
          "end_line": 3037,
          "content": [
            "pid_t kernel_thread(int (*fn)(void *), void *arg, const char *name,",
            "\t\t    unsigned long flags)",
            "{",
            "\tstruct kernel_clone_args args = {",
            "\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |",
            "\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),",
            "\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),",
            "\t\t.fn\t\t= fn,",
            "\t\t.fn_arg\t\t= arg,",
            "\t\t.name\t\t= name,",
            "\t\t.kthread\t= 1,",
            "\t};",
            "",
            "\treturn kernel_clone(&args);",
            "}",
            "pid_t user_mode_thread(int (*fn)(void *), void *arg, unsigned long flags)",
            "{",
            "\tstruct kernel_clone_args args = {",
            "\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |",
            "\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),",
            "\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),",
            "\t\t.fn\t\t= fn,",
            "\t\t.fn_arg\t\t= arg,",
            "\t};",
            "",
            "\treturn kernel_clone(&args);",
            "}",
            "noinline static int copy_clone_args_from_user(struct kernel_clone_args *kargs,",
            "\t\t\t\t\t      struct clone_args __user *uargs,",
            "\t\t\t\t\t      size_t usize)",
            "{",
            "\tint err;",
            "\tstruct clone_args args;",
            "\tpid_t *kset_tid = kargs->set_tid;",
            "",
            "\tBUILD_BUG_ON(offsetofend(struct clone_args, tls) !=",
            "\t\t     CLONE_ARGS_SIZE_VER0);",
            "\tBUILD_BUG_ON(offsetofend(struct clone_args, set_tid_size) !=",
            "\t\t     CLONE_ARGS_SIZE_VER1);",
            "\tBUILD_BUG_ON(offsetofend(struct clone_args, cgroup) !=",
            "\t\t     CLONE_ARGS_SIZE_VER2);",
            "\tBUILD_BUG_ON(sizeof(struct clone_args) != CLONE_ARGS_SIZE_VER2);",
            "",
            "\tif (unlikely(usize > PAGE_SIZE))",
            "\t\treturn -E2BIG;",
            "\tif (unlikely(usize < CLONE_ARGS_SIZE_VER0))",
            "\t\treturn -EINVAL;",
            "",
            "\terr = copy_struct_from_user(&args, sizeof(args), uargs, usize);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif (unlikely(args.set_tid_size > MAX_PID_NS_LEVEL))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (unlikely(!args.set_tid && args.set_tid_size > 0))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (unlikely(args.set_tid && args.set_tid_size == 0))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Verify that higher 32bits of exit_signal are unset and that",
            "\t * it is a valid signal",
            "\t */",
            "\tif (unlikely((args.exit_signal & ~((u64)CSIGNAL)) ||",
            "\t\t     !valid_signal(args.exit_signal)))",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((args.flags & CLONE_INTO_CGROUP) &&",
            "\t    (args.cgroup > INT_MAX || usize < CLONE_ARGS_SIZE_VER2))",
            "\t\treturn -EINVAL;",
            "",
            "\t*kargs = (struct kernel_clone_args){",
            "\t\t.flags\t\t= args.flags,",
            "\t\t.pidfd\t\t= u64_to_user_ptr(args.pidfd),",
            "\t\t.child_tid\t= u64_to_user_ptr(args.child_tid),",
            "\t\t.parent_tid\t= u64_to_user_ptr(args.parent_tid),",
            "\t\t.exit_signal\t= args.exit_signal,",
            "\t\t.stack\t\t= args.stack,",
            "\t\t.stack_size\t= args.stack_size,",
            "\t\t.tls\t\t= args.tls,",
            "\t\t.set_tid_size\t= args.set_tid_size,",
            "\t\t.cgroup\t\t= args.cgroup,",
            "\t};",
            "",
            "\tif (args.set_tid &&",
            "\t\tcopy_from_user(kset_tid, u64_to_user_ptr(args.set_tid),",
            "\t\t\t(kargs->set_tid_size * sizeof(pid_t))))",
            "\t\treturn -EFAULT;",
            "",
            "\tkargs->set_tid = kset_tid;",
            "",
            "\treturn 0;",
            "}",
            "static inline bool clone3_stack_valid(struct kernel_clone_args *kargs)",
            "{",
            "\tif (kargs->stack == 0) {",
            "\t\tif (kargs->stack_size > 0)",
            "\t\t\treturn false;",
            "\t} else {",
            "\t\tif (kargs->stack_size == 0)",
            "\t\t\treturn false;",
            "",
            "\t\tif (!access_ok((void __user *)kargs->stack, kargs->stack_size))",
            "\t\t\treturn false;",
            "",
            "#if !defined(CONFIG_STACK_GROWSUP)",
            "\t\tkargs->stack += kargs->stack_size;",
            "#endif",
            "\t}",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "kernel_thread, user_mode_thread, copy_clone_args_from_user, clone3_stack_valid",
          "description": "提供内核线程与用户线程创建接口，解析并验证clone3参数，转换用户空间clone_args到内核结构体，校验栈地址有效性",
          "similarity": 0.5445186495780945
        }
      ]
    },
    {
      "source_file": "kernel/sys_ni.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:31:37\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sys_ni.c`\n\n---\n\n# sys_ni.c 技术文档\n\n## 1. 文件概述\n\n`sys_ni.c` 是 Linux 内核中用于处理**未实现系统调用（Not Implemented Syscall）**的核心文件。当某个系统调用在当前架构或配置下未被实现时，内核会将其重定向到 `sys_ni_syscall()` 函数，该函数统一返回 `-ENOSYS` 错误码（表示“Function not implemented”）。此机制确保了即使某些系统调用未被支持，用户空间程序调用它们时也不会导致内核崩溃，而是获得标准错误响应。\n\n此外，该文件通过宏 `COND_SYSCALL` 和 `COND_SYSCALL_COMPAT` 为大量系统调用提供**弱符号（weak symbol）定义**，使得链接器在找不到具体实现时自动链接到 `sys_ni_syscall`，从而实现“按需启用、默认未实现”的灵活架构。\n\n## 2. 核心功能\n\n### 主要函数\n- **`sys_ni_syscall(void)`**  \n  所有未实现系统调用的默认入口点，返回 `-ENOSYS`。\n\n### 关键宏定义\n- **`COND_SYSCALL(name)`**  \n  展开为 `cond_syscall(sys_##name)`，为指定系统调用名生成弱符号引用。\n- **`COND_SYSCALL_COMPAT(name)`**  \n  展开为 `cond_syscall(compat_sys_##name)`，为 32 位兼容模式下的系统调用生成弱符号引用。\n- **`cond_syscall()`**（由链接器脚本或汇编支持）  \n  实际由链接器处理，将未定义的系统调用符号指向 `sys_ni_syscall`。\n\n## 3. 关键实现\n\n### 未实现系统调用的统一处理\n- 所有未在内核中实际实现的系统调用最终都会跳转到 `sys_ni_syscall()`，该函数仅返回 `-ENOSYS`，实现简洁且安全。\n- 通过 `asmlinkage` 修饰符确保函数使用正确的调用约定（通常为栈传参），与系统调用入口一致。\n\n### 弱符号机制\n- 使用 `COND_SYSCALL(name)` 宏为每个可能未实现的系统调用生成一个弱符号声明。\n- 在链接阶段，若某系统调用（如 `sys_io_setup`）有实际实现，则链接器使用其实现；若无，则自动绑定到 `sys_ni_syscall`。\n- 此机制避免了为每个架构手动维护大量空 stub 函数，提高了代码可维护性。\n\n### 兼容性支持\n- `COND_SYSCALL_COMPAT` 专门处理 32 位兼容层（如 x86_64 上运行 32 位程序）的系统调用，确保兼容模式下未实现的调用同样返回 `-ENOSYS`。\n- 支持架构特定的 syscall wrapper（通过 `CONFIG_ARCH_HAS_SYSCALL_WRAPPER`），允许某些架构自定义 `COND_SYSCALL` 行为。\n\n### 系统调用列表组织\n- 列表严格遵循 `include/uapi/asm-generic/unistd.h` 中的顺序，便于维护一致性。\n- 包含：\n  - 通用系统调用（如 `io_uring_*`, `epoll_*`, `timerfd_*`）\n  - 架构特定调用（如 x86 的 `vm86`、s390 的 `s390_ipc`）\n  - 已废弃但仍被某些架构需要的调用（如 `epoll_create`, `inotify_init`）\n  - 条件编译调用（如 `__ARCH_WANT_SYS_CLONE3` 控制的 `clone3`）\n\n## 4. 依赖关系\n\n### 头文件依赖\n- `<linux/linkage.h>`：提供 `asmlinkage` 宏定义\n- `<linux/errno.h>`：提供 `-ENOSYS` 错误码\n- `<asm/unistd.h>`：包含架构相关的系统调用编号定义\n- `<asm/syscall_wrapper.h>`（条件包含）：允许架构覆盖 `COND_SYSCALL` 宏\n\n### 内核构建系统依赖\n- 依赖链接器脚本（如 `vmlinux.lds`）中的 `__cond_syscall` 段处理弱符号\n- 与 `arch/*/kernel/syscall_table.c` 或等效文件协同工作，后者提供实际系统调用表\n\n### 配置选项依赖\n- `CONFIG_ARCH_HAS_SYSCALL_WRAPPER`：控制是否使用架构自定义 syscall wrapper\n- 各种 `CONFIG_*` 选项（如 `CONFIG_MMU`、`CONFIG_FANOTIFY`）间接影响哪些 `COND_SYSCALL` 条目生效\n\n## 5. 使用场景\n\n### 内核构建时\n- 在编译内核时，若某系统调用未被任何源文件实现（例如因配置选项关闭或架构不支持），链接器自动将其绑定到 `sys_ni_syscall`。\n- 避免链接错误，同时保证系统调用表完整性。\n\n### 用户空间调用未实现 syscall 时\n- 用户程序调用未实现的系统调用（如在不支持 `landlock` 的内核上调用 `landlock_create_ruleset`）。\n- 内核安全返回 `-ENOSYS`，程序可据此进行功能检测或降级处理。\n\n### 架构移植与兼容层\n- 新架构移植时，无需立即实现所有系统调用，未实现部分自动返回 `-ENOSYS`。\n- 32/64 位兼容层（如 x86_64 的 compat 模式）中，未实现的 32 位专用 syscall 同样得到正确处理。\n\n### 废弃 syscall 的平滑过渡\n- 对于已废弃但仍保留在 uAPI 中的系统调用（如 `epoll_create`），通过此机制确保旧程序在新内核上仍能获得明确错误而非崩溃。",
      "similarity": 0.5852943658828735,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sys_ni.c",
          "start_line": 20,
          "end_line": 23,
          "content": [
            "asmlinkage long sys_ni_syscall(void)",
            "{",
            "\treturn -ENOSYS;",
            "}"
          ],
          "function_name": "sys_ni_syscall",
          "description": "该函数实现作为默认的未实现系统调用处理程序，始终返回-ENOSYS错误码以指示系统调用不可用",
          "similarity": 0.5077019929885864
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sys_ni.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "#include <linux/linkage.h>",
            "#include <linux/errno.h>",
            "",
            "#include <asm/unistd.h>",
            "",
            "#ifdef CONFIG_ARCH_HAS_SYSCALL_WRAPPER",
            "/* Architectures may override COND_SYSCALL and COND_SYSCALL_COMPAT */",
            "#include <asm/syscall_wrapper.h>",
            "#endif /* CONFIG_ARCH_HAS_SYSCALL_WRAPPER */",
            "",
            "/*  we can't #include <linux/syscalls.h> here,",
            "    but tell gcc to not warn with -Wmissing-prototypes  */",
            "asmlinkage long sys_ni_syscall(void);",
            "",
            "/*",
            " * Non-implemented system calls get redirected here.",
            " */"
          ],
          "function_name": null,
          "description": "该代码块声明处理未实现系统调用的入口函数sys_ni_syscall，并包含必要头文件及架构相关兼容性支持，但缺少函数具体实现，上下文不完整",
          "similarity": 0.49645155668258667
        }
      ]
    },
    {
      "source_file": "kernel/sys.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:30:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sys.c`\n\n---\n\n# `sys.c` 内核源码技术文档\n\n## 1. 文件概述\n\n`sys.c` 是 Linux 内核中实现系统调用（system calls）的核心源文件之一，位于 `kernel/` 目录下。该文件主要负责处理与进程调度优先级、用户/组 ID 溢出处理、系统信息查询等相关的通用系统调用。其历史可追溯至 Linus Torvalds 早期开发阶段，是内核中提供 POSIX 兼容性的重要组成部分。当前文档所涵盖的代码片段聚焦于 `setpriority` 和 `getpriority` 系统调用的实现，以及与 UID/GID 溢出相关的全局变量定义。\n\n## 2. 核心功能\n\n### 全局变量\n- `overflowuid` / `overflowgid`：用于在 32 位 UID/GID 架构中表示无法表示的旧式 16 位 UID/GID 的回退值，默认为 `DEFAULT_OVERFLOWUID`/`DEFAULT_OVERFLOWGID`。\n- `fs_overflowuid` / `fs_overflowgid`：专用于仅支持 16 位 UID/GID 的文件系统的溢出回退值，适用于所有架构。\n\n### 主要函数\n- `set_one_prio_perm(struct task_struct *p)`：检查当前进程是否有权限修改目标进程 `p` 的调度优先级（nice 值）。\n- `set_one_prio(struct task_struct *p, int niceval, int error)`：在权限检查通过后，实际设置目标进程的 nice 值。\n- `SYSCALL_DEFINE3(setpriority, int, which, int, who, int, niceval)`：实现 `setpriority(2)` 系统调用，支持按进程、进程组或用户 ID 修改一组进程的优先级。\n- `SYSCALL_DEFINE2(getpriority, int, which, int, who)`：实现 `getpriority(2)` 系统调用，返回指定范围（进程、进程组、用户）内最高优先级（即最小 nice 值）对应的兼容值。\n\n## 3. 关键实现\n\n### 权限控制机制\n- `set_one_prio_perm()` 函数通过比较当前进程的有效 UID（`euid`）与目标进程的 UID 或有效 UID 是否相等来判断基本权限。\n- 若不满足 UID 匹配，则检查当前进程是否在目标进程所属的用户命名空间（`user_ns`）中拥有 `CAP_SYS_NICE` 能力。\n- 所有凭证（`cred`）访问均在 RCU 读锁保护下进行，确保并发安全。\n\n### 优先级设置逻辑\n- `setpriority` 系统调用首先将用户传入的 `niceval` 限制在 `[MIN_NICE, MAX_NICE]` 范围内（通常为 -20 到 19）。\n- 根据 `which` 参数（`PRIO_PROCESS`、`PRIO_PGRP` 或 `PRIO_USER`）分别处理：\n  - **进程**：通过 `find_task_by_vpid()` 查找目标进程。\n  - **进程组**：使用 `do_each_pid_thread()` 遍历指定进程组内的所有线程。\n  - **用户**：遍历所有进程，筛选 UID 匹配的进程；若目标 UID 非当前用户，则通过 `find_user()` 获取用户结构并最终 `free_uid()` 释放引用。\n- 实际设置前调用 LSM（Linux Security Module）钩子 `security_task_setnice()` 进行安全策略检查。\n\n### 优先级获取的兼容性处理\n- `getpriority` 返回值采用历史兼容格式：将实际 nice 值（-20~19）转换为 `20 - nice`，即返回 1~40 的正整数。\n- 该转换通过 `nice_to_rlimit()` 宏实现（定义在 `<linux/resource.h>` 中）。\n- 返回的是指定范围内**最高优先级**（即最大 `nice_to_rlimit` 值，对应最小实际 nice 值）。\n\n### 架构无关性处理\n- 文件开头通过一系列 `#ifndef` 宏定义（如 `SET_UNALIGN_CTL`、`GET_FP_MODE` 等）为不支持特定 CPU 控制功能的架构提供默认 `-EINVAL` 返回值，避免编译错误。\n\n## 4. 依赖关系\n\n### 头文件依赖\n- **调度子系统**：`<linux/sched.h>` 及其子头文件（如 `sched/task.h`、`sched/cputime.h`）提供任务结构、nice 值操作和遍历接口。\n- **用户/组管理**：`<linux/cred.h>`、`<linux/uidgid.h>`、`<linux/user_namespace.h>` 处理凭证、UID/GID 映射及命名空间。\n- **安全模块**：`<linux/security.h>`、`<linux/capability.h>` 提供 LSM 钩子和能力检查。\n- **进程管理**：`<linux/pid.h>`（通过 `find_vpid` 等）、`<linux/rcupdate.h>`（RCU 锁）、`<linux/task_io_accounting_ops.h>`。\n- **系统调用框架**：`<linux/syscalls.h>`、`<linux/uaccess.h>`。\n- **其他**：`<linux/resource.h>`（`nice_to_rlimit`）、`<linux/utsname.h>`（系统信息）、`<generated/utsrelease.h>`（内核版本）。\n\n### 内核子系统交互\n- **调度器**：通过 `set_user_nice()` 和 `task_nice()` 与核心调度逻辑交互。\n- **用户命名空间**：在 UID 比较和能力检查中依赖用户命名空间隔离机制。\n- **LSM 框架**：调用 `security_task_setnice()` 允许安全模块（如 SELinux、AppArmor）拦截优先级修改。\n- **进程遍历机制**：使用 `for_each_process_thread()` 和 `do_each_pid_thread()` 安全遍历进程列表。\n\n## 5. 使用场景\n\n- **用户空间程序调用 `setpriority()`/`getpriority()`**：如 `nice`、`renice` 命令，或应用程序动态调整自身/子进程 CPU 调度优先级。\n- **系统初始化**：`overflowuid`/`overflowgid` 等变量在内核启动时初始化，供 VFS 和 IPC 子系统在处理旧式 16 位 UID/GID 时使用。\n- **容器与命名空间环境**：在用户命名空间中，`setpriority` 的权限检查基于目标进程的用户命名空间，确保容器内进程无法越权修改宿主机进程优先级。\n- **安全审计与限制**：通过 LSM 钩子，系统可记录或阻止非特权进程提升优先级的行为。\n- **跨架构兼容**：为不支持浮点控制、对齐控制等特性的 CPU 架构提供统一的系统调用接口，避免架构特定代码污染通用逻辑。",
      "similarity": 0.5828521847724915,
      "chunks": [
        {
          "chunk_id": 6,
          "file_path": "kernel/sys.c",
          "start_line": 1386,
          "end_line": 1491,
          "content": [
            "static int override_release(char __user *release, size_t len)",
            "{",
            "\tint ret = 0;",
            "",
            "\tif (current->personality & UNAME26) {",
            "\t\tconst char *rest = UTS_RELEASE;",
            "\t\tchar buf[65] = { 0 };",
            "\t\tint ndots = 0;",
            "\t\tunsigned v;",
            "\t\tsize_t copy;",
            "",
            "\t\twhile (*rest) {",
            "\t\t\tif (*rest == '.' && ++ndots >= 3)",
            "\t\t\t\tbreak;",
            "\t\t\tif (!isdigit(*rest) && *rest != '.')",
            "\t\t\t\tbreak;",
            "\t\t\trest++;",
            "\t\t}",
            "\t\tv = LINUX_VERSION_PATCHLEVEL + 60;",
            "\t\tcopy = clamp_t(size_t, len, 1, sizeof(buf));",
            "\t\tcopy = scnprintf(buf, copy, \"2.6.%u%s\", v, rest);",
            "\t\tret = copy_to_user(release, buf, copy + 1);",
            "\t}",
            "\treturn ret;",
            "}",
            "static int do_prlimit(struct task_struct *tsk, unsigned int resource,",
            "\t\t      struct rlimit *new_rlim, struct rlimit *old_rlim)",
            "{",
            "\tstruct rlimit *rlim;",
            "\tint retval = 0;",
            "",
            "\tif (resource >= RLIM_NLIMITS)",
            "\t\treturn -EINVAL;",
            "\tresource = array_index_nospec(resource, RLIM_NLIMITS);",
            "",
            "\tif (new_rlim) {",
            "\t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)",
            "\t\t\treturn -EINVAL;",
            "\t\tif (resource == RLIMIT_NOFILE &&",
            "\t\t\t\tnew_rlim->rlim_max > sysctl_nr_open)",
            "\t\t\treturn -EPERM;",
            "\t}",
            "",
            "\t/* Holding a refcount on tsk protects tsk->signal from disappearing. */",
            "\trlim = tsk->signal->rlim + resource;",
            "\ttask_lock(tsk->group_leader);",
            "\tif (new_rlim) {",
            "\t\t/*",
            "\t\t * Keep the capable check against init_user_ns until cgroups can",
            "\t\t * contain all limits.",
            "\t\t */",
            "\t\tif (new_rlim->rlim_max > rlim->rlim_max &&",
            "\t\t\t\t!capable(CAP_SYS_RESOURCE))",
            "\t\t\tretval = -EPERM;",
            "\t\tif (!retval)",
            "\t\t\tretval = security_task_setrlimit(tsk, resource, new_rlim);",
            "\t}",
            "\tif (!retval) {",
            "\t\tif (old_rlim)",
            "\t\t\t*old_rlim = *rlim;",
            "\t\tif (new_rlim)",
            "\t\t\t*rlim = *new_rlim;",
            "\t}",
            "\ttask_unlock(tsk->group_leader);",
            "",
            "\t/*",
            "\t * RLIMIT_CPU handling. Arm the posix CPU timer if the limit is not",
            "\t * infinite. In case of RLIM_INFINITY the posix CPU timer code",
            "\t * ignores the rlimit.",
            "\t */",
            "\tif (!retval && new_rlim && resource == RLIMIT_CPU &&",
            "\t    new_rlim->rlim_cur != RLIM_INFINITY &&",
            "\t    IS_ENABLED(CONFIG_POSIX_TIMERS)) {",
            "\t\t/*",
            "\t\t * update_rlimit_cpu can fail if the task is exiting, but there",
            "\t\t * may be other tasks in the thread group that are not exiting,",
            "\t\t * and they need their cpu timers adjusted.",
            "\t\t *",
            "\t\t * The group_leader is the last task to be released, so if we",
            "\t\t * cannot update_rlimit_cpu on it, then the entire process is",
            "\t\t * exiting and we do not need to update at all.",
            "\t\t */",
            "\t\tupdate_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);",
            "\t}",
            "",
            "\treturn retval;",
            "}",
            "static inline bool rlim64_is_infinity(__u64 rlim64)",
            "{",
            "#if BITS_PER_LONG < 64",
            "\treturn rlim64 >= ULONG_MAX;",
            "#else",
            "\treturn rlim64 == RLIM64_INFINITY;",
            "#endif",
            "}",
            "static void rlim_to_rlim64(const struct rlimit *rlim, struct rlimit64 *rlim64)",
            "{",
            "\tif (rlim->rlim_cur == RLIM_INFINITY)",
            "\t\trlim64->rlim_cur = RLIM64_INFINITY;",
            "\telse",
            "\t\trlim64->rlim_cur = rlim->rlim_cur;",
            "\tif (rlim->rlim_max == RLIM_INFINITY)",
            "\t\trlim64->rlim_max = RLIM64_INFINITY;",
            "\telse",
            "\t\trlim64->rlim_max = rlim->rlim_max;",
            "}"
          ],
          "function_name": "override_release, do_prlimit, rlim64_is_infinity, rlim_to_rlim64",
          "description": "该代码段主要实现三个功能：  \n1. **`override_release`** 函数用于覆盖内核版本字符串，在 `UNAME26` 人格模式下强制替换 `UTS_RELEASE` 字符串为自定义格式（如 `2.6.xxxx`），并复制至用户空间。  \n2. **`do_prlimit`** 函数负责处理进程资源限制（如文件数、CPU时间等），执行有效性校验、权限检查，并通过安全钩子更新限制值，同时对 CPU 资源触发 POSIX 定时器。  \n3. **`rlim64_is_infinity` 和 `rlim_to_rlim64`** 分别用于判断 64 位资源限制是否为无穷大，以及将传统 32 位 `rlimit` 结构转换为 64 位版本以适配更大数值范围。",
          "similarity": 0.5194672346115112
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sys.c",
          "start_line": 1,
          "end_line": 181,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  linux/kernel/sys.c",
            " *",
            " *  Copyright (C) 1991, 1992  Linus Torvalds",
            " */",
            "",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mman.h>",
            "#include <linux/reboot.h>",
            "#include <linux/prctl.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/ksm.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/resource.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/capability.h>",
            "#include <linux/device.h>",
            "#include <linux/key.h>",
            "#include <linux/times.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/security.h>",
            "#include <linux/random.h>",
            "#include <linux/suspend.h>",
            "#include <linux/tty.h>",
            "#include <linux/signal.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/getcpu.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/personality.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/gfp.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/version.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscall_user_dispatch.h>",
            "",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/time_namespace.h>",
            "#include <linux/binfmts.h>",
            "",
            "#include <linux/sched.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/cred.h>",
            "",
            "#include <linux/nospec.h>",
            "",
            "#include <linux/kmsg_dump.h>",
            "/* Move somewhere else to avoid recompiling? */",
            "#include <generated/utsrelease.h>",
            "",
            "#include <linux/uaccess.h>",
            "#include <asm/io.h>",
            "#include <asm/unistd.h>",
            "",
            "#ifdef CONFIG_CREDP",
            "#include <asm/iee-cred.h>",
            "#endif",
            "",
            "#include \"uid16.h\"",
            "",
            "#ifndef SET_UNALIGN_CTL",
            "# define SET_UNALIGN_CTL(a, b)\t(-EINVAL)",
            "#endif",
            "#ifndef GET_UNALIGN_CTL",
            "# define GET_UNALIGN_CTL(a, b)\t(-EINVAL)",
            "#endif",
            "#ifndef SET_FPEMU_CTL",
            "# define SET_FPEMU_CTL(a, b)\t(-EINVAL)",
            "#endif",
            "#ifndef GET_FPEMU_CTL",
            "# define GET_FPEMU_CTL(a, b)\t(-EINVAL)",
            "#endif",
            "#ifndef SET_FPEXC_CTL",
            "# define SET_FPEXC_CTL(a, b)\t(-EINVAL)",
            "#endif",
            "#ifndef GET_FPEXC_CTL",
            "# define GET_FPEXC_CTL(a, b)\t(-EINVAL)",
            "#endif",
            "#ifndef GET_ENDIAN",
            "# define GET_ENDIAN(a, b)\t(-EINVAL)",
            "#endif",
            "#ifndef SET_ENDIAN",
            "# define SET_ENDIAN(a, b)\t(-EINVAL)",
            "#endif",
            "#ifndef GET_TSC_CTL",
            "# define GET_TSC_CTL(a)\t\t(-EINVAL)",
            "#endif",
            "#ifndef SET_TSC_CTL",
            "# define SET_TSC_CTL(a)\t\t(-EINVAL)",
            "#endif",
            "#ifndef GET_FP_MODE",
            "# define GET_FP_MODE(a)\t\t(-EINVAL)",
            "#endif",
            "#ifndef SET_FP_MODE",
            "# define SET_FP_MODE(a,b)\t(-EINVAL)",
            "#endif",
            "#ifndef SVE_SET_VL",
            "# define SVE_SET_VL(a)\t\t(-EINVAL)",
            "#endif",
            "#ifndef SVE_GET_VL",
            "# define SVE_GET_VL()\t\t(-EINVAL)",
            "#endif",
            "#ifndef SME_SET_VL",
            "# define SME_SET_VL(a)\t\t(-EINVAL)",
            "#endif",
            "#ifndef SME_GET_VL",
            "# define SME_GET_VL()\t\t(-EINVAL)",
            "#endif",
            "#ifndef PAC_RESET_KEYS",
            "# define PAC_RESET_KEYS(a, b)\t(-EINVAL)",
            "#endif",
            "#ifndef PAC_SET_ENABLED_KEYS",
            "# define PAC_SET_ENABLED_KEYS(a, b, c)\t(-EINVAL)",
            "#endif",
            "#ifndef PAC_GET_ENABLED_KEYS",
            "# define PAC_GET_ENABLED_KEYS(a)\t(-EINVAL)",
            "#endif",
            "#ifndef SET_TAGGED_ADDR_CTRL",
            "# define SET_TAGGED_ADDR_CTRL(a)\t(-EINVAL)",
            "#endif",
            "#ifndef GET_TAGGED_ADDR_CTRL",
            "# define GET_TAGGED_ADDR_CTRL()\t\t(-EINVAL)",
            "#endif",
            "#ifndef RISCV_V_SET_CONTROL",
            "# define RISCV_V_SET_CONTROL(a)\t\t(-EINVAL)",
            "#endif",
            "#ifndef RISCV_V_GET_CONTROL",
            "# define RISCV_V_GET_CONTROL()\t\t(-EINVAL)",
            "#endif",
            "",
            "/*",
            " * this is where the system-wide overflow UID and GID are defined, for",
            " * architectures that now have 32-bit UID/GID but didn't in the past",
            " */",
            "",
            "int overflowuid = DEFAULT_OVERFLOWUID;",
            "int overflowgid = DEFAULT_OVERFLOWGID;",
            "",
            "EXPORT_SYMBOL(overflowuid);",
            "EXPORT_SYMBOL(overflowgid);",
            "",
            "/*",
            " * the same as above, but for filesystems which can only store a 16-bit",
            " * UID and GID. as such, this is needed on all architectures",
            " */",
            "",
            "int fs_overflowuid = DEFAULT_FS_OVERFLOWUID;",
            "int fs_overflowgid = DEFAULT_FS_OVERFLOWGID;",
            "",
            "EXPORT_SYMBOL(fs_overflowuid);",
            "EXPORT_SYMBOL(fs_overflowgid);",
            "",
            "/*",
            " * Returns true if current's euid is same as p's uid or euid,",
            " * or has CAP_SYS_NICE to p's user_ns.",
            " *",
            " * Called with rcu_read_lock, creds are safe",
            " */"
          ],
          "function_name": null,
          "description": "定义UID/GID溢出值全局变量并导出符号，用于处理旧架构下32位UID/GID兼容性问题。",
          "similarity": 0.4864618182182312
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sys.c",
          "start_line": 458,
          "end_line": 628,
          "content": [
            "long __sys_setgid(gid_t gid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkgid_t kgid;",
            "",
            "\tkgid = make_kgid(ns, gid);",
            "\tif (!gid_valid(kgid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_sgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t\tiee_set_cred_gid(new, kgid);",
            "\t}",
            "\t\t#else",
            "\t\tnew->gid = new->egid = new->sgid = new->fsgid = kgid;",
            "\t\t#endif",
            "\telse if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t}",
            "\t\t#else",
            "\t\tnew->egid = new->fsgid = kgid;",
            "\t\t#endif",
            "\telse",
            "\t\tgoto error;",
            "",
            "\tretval = security_task_fix_setgid(new, old, LSM_SETID_ID);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}",
            "\telse if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t}",
            "static int set_user(struct cred *new)",
            "{",
            "\tstruct user_struct *new_user;",
            "",
            "\tnew_user = alloc_uid(new->uid);",
            "\tif (!new_user)",
            "\t\treturn -EAGAIN;",
            "",
            "\tfree_uid(new->user);",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_user(new, new_user);",
            "\t#else",
            "\tnew->user = new_user;",
            "\t#endif",
            "\treturn 0;",
            "}",
            "static void flag_nproc_exceeded(struct cred *new)",
            "{",
            "\tif (new->ucounts == current_ucounts())",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * We don't fail in case of NPROC limit excess here because too many",
            "\t * poorly written programs don't check set*uid() return code, assuming",
            "\t * it never fails if called by root.  We may still enforce NPROC limit",
            "\t * for programs doing set*uid()+execve() by harmlessly deferring the",
            "\t * failure to the execve() stage.",
            "\t */",
            "\tif (is_rlimit_overlimit(new->ucounts, UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC)) &&",
            "\t\t\tnew->user != INIT_USER)",
            "\t\tcurrent->flags |= PF_NPROC_EXCEEDED;",
            "\telse",
            "\t\tcurrent->flags &= ~PF_NPROC_EXCEEDED;",
            "}",
            "long __sys_setreuid(uid_t ruid, uid_t euid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkuid_t kruid, keuid;",
            "",
            "\tkruid = make_kuid(ns, ruid);",
            "\tkeuid = make_kuid(ns, euid);",
            "",
            "\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))",
            "\t\treturn -EINVAL;",
            "\tif ((euid != (uid_t) -1) && !uid_valid(keuid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (ruid != (uid_t) -1) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_uid(new, kruid);",
            "\t\t#else",
            "\t\tnew->uid = kruid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(old->uid, kruid) &&",
            "\t\t    !uid_eq(old->euid, kruid) &&",
            "\t\t    !ns_capable_setid(old->user_ns, CAP_SETUID))",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tif (euid != (uid_t) -1) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_euid(new, keuid);",
            "\t\t#else",
            "\t\tnew->euid = keuid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(old->uid, keuid) &&",
            "\t\t    !uid_eq(old->euid, keuid) &&",
            "\t\t    !uid_eq(old->suid, keuid) &&",
            "\t\t    !ns_capable_setid(old->user_ns, CAP_SETUID))",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tif (!uid_eq(new->uid, old->uid)) {",
            "\t\tretval = set_user(new);",
            "\t\tif (retval < 0)",
            "\t\t\tgoto error;",
            "\t}",
            "\tif (ruid != (uid_t) -1 ||",
            "\t    (euid != (uid_t) -1 && !uid_eq(keuid, old->uid)))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_suid(new, new->euid);",
            "\t\t#else",
            "\t\tnew->suid = new->euid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsuid(new, new->euid);",
            "\t#else",
            "\tnew->fsuid = new->euid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setuid(new, old, LSM_SETID_RE);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tretval = set_cred_ucounts(new);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tflag_nproc_exceeded(new);",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "__sys_setgid, if, set_user, flag_nproc_exceeded, __sys_setreuid",
          "description": "实现用户ID调整逻辑，包含用户结构体分配、NPROC限制检测及用户命名空间权限校验，更新进程的有效/实始用户ID。",
          "similarity": 0.4855690002441406
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/sys.c",
          "start_line": 1755,
          "end_line": 1795,
          "content": [
            "static void rlim64_to_rlim(const struct rlimit64 *rlim64, struct rlimit *rlim)",
            "{",
            "\tif (rlim64_is_infinity(rlim64->rlim_cur))",
            "\t\trlim->rlim_cur = RLIM_INFINITY;",
            "\telse",
            "\t\trlim->rlim_cur = (unsigned long)rlim64->rlim_cur;",
            "\tif (rlim64_is_infinity(rlim64->rlim_max))",
            "\t\trlim->rlim_max = RLIM_INFINITY;",
            "\telse",
            "\t\trlim->rlim_max = (unsigned long)rlim64->rlim_max;",
            "}",
            "static int check_prlimit_permission(struct task_struct *task,",
            "\t\t\t\t    unsigned int flags)",
            "{",
            "\tconst struct cred *cred = current_cred(), *tcred;",
            "\tbool id_match;",
            "",
            "\tif (current == task)",
            "\t\treturn 0;",
            "",
            "\ttcred = __task_cred(task);",
            "\tid_match = (uid_eq(cred->uid, tcred->euid) &&",
            "\t\t    uid_eq(cred->uid, tcred->suid) &&",
            "\t\t    uid_eq(cred->uid, tcred->uid)  &&",
            "\t\t    gid_eq(cred->gid, tcred->egid) &&",
            "\t\t    gid_eq(cred->gid, tcred->sgid) &&",
            "\t\t    gid_eq(cred->gid, tcred->gid));",
            "\tif (!id_match && !ns_capable(tcred->user_ns, CAP_SYS_RESOURCE))",
            "\t\treturn -EPERM;",
            "",
            "\treturn security_task_prlimit(cred, tcred, flags);",
            "}",
            "static void accumulate_thread_rusage(struct task_struct *t, struct rusage *r)",
            "{",
            "\tr->ru_nvcsw += t->nvcsw;",
            "\tr->ru_nivcsw += t->nivcsw;",
            "\tr->ru_minflt += t->min_flt;",
            "\tr->ru_majflt += t->maj_flt;",
            "\tr->ru_inblock += task_io_get_inblock(t);",
            "\tr->ru_oublock += task_io_get_oublock(t);",
            "}"
          ],
          "function_name": "rlim64_to_rlim, check_prlimit_permission, accumulate_thread_rusage",
          "description": "该代码块包含三个辅助函数：  \n1. `rlim64_to_rlim` 实现从64位资源限制结构体到传统32位`struct rlimit`的类型转换，处理无穷大的边界条件；  \n2. `check_prlimit_permission` 检查当前进程对目标任务执行`prlimit`系统调用的权限，通过对比有效UID/GID及命名空间能力进行访问控制；  \n3. `accumulate_thread_rusage` 累加子线程的资源使用统计信息至父线程的`rusage`结构，用于进程资源消耗追踪。  \n\n所有函数均基于完整上下文实现，未引入额外API或机制。",
          "similarity": 0.48448699712753296
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/sys.c",
          "start_line": 182,
          "end_line": 286,
          "content": [
            "static bool set_one_prio_perm(struct task_struct *p)",
            "{",
            "\tconst struct cred *cred = current_cred(), *pcred = __task_cred(p);",
            "",
            "\tif (uid_eq(pcred->uid,  cred->euid) ||",
            "\t    uid_eq(pcred->euid, cred->euid))",
            "\t\treturn true;",
            "\tif (ns_capable(pcred->user_ns, CAP_SYS_NICE))",
            "\t\treturn true;",
            "\treturn false;",
            "}",
            "static int set_one_prio(struct task_struct *p, int niceval, int error)",
            "{",
            "\tint no_nice;",
            "",
            "\tif (!set_one_prio_perm(p)) {",
            "\t\terror = -EPERM;",
            "\t\tgoto out;",
            "\t}",
            "\tif (niceval < task_nice(p) && !can_nice(p, niceval)) {",
            "\t\terror = -EACCES;",
            "\t\tgoto out;",
            "\t}",
            "\tno_nice = security_task_setnice(p, niceval);",
            "\tif (no_nice) {",
            "\t\terror = no_nice;",
            "\t\tgoto out;",
            "\t}",
            "\tif (error == -ESRCH)",
            "\t\terror = 0;",
            "\tset_user_nice(p, niceval);",
            "out:",
            "\treturn error;",
            "}",
            "long __sys_setregid(gid_t rgid, gid_t egid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkgid_t krgid, kegid;",
            "",
            "\tkrgid = make_kgid(ns, rgid);",
            "\tkegid = make_kgid(ns, egid);",
            "",
            "\tif ((rgid != (gid_t) -1) && !gid_valid(krgid))",
            "\t\treturn -EINVAL;",
            "\tif ((egid != (gid_t) -1) && !gid_valid(kegid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (rgid != (gid_t) -1) {",
            "\t\tif (gid_eq(old->gid, krgid) ||",
            "\t\t    gid_eq(old->egid, krgid) ||",
            "\t\t    ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\t\t#ifdef CONFIG_CREDP",
            "\t\t\tiee_set_cred_gid(new, krgid);",
            "\t\t\t#else",
            "\t\t\tnew->gid = krgid;",
            "\t\t\t#endif",
            "\t\telse",
            "\t\t\tgoto error;",
            "\t}",
            "\tif (egid != (gid_t) -1) {",
            "\t\tif (gid_eq(old->gid, kegid) ||",
            "\t\t    gid_eq(old->egid, kegid) ||",
            "\t\t    gid_eq(old->sgid, kegid) ||",
            "\t\t    ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\t\t#ifdef CONFIG_CREDP",
            "\t\t\tiee_set_cred_egid(new, kegid);",
            "\t\t\t#else",
            "\t\t\tnew->egid = kegid;",
            "\t\t\t#endif",
            "\t\telse",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tif (rgid != (gid_t) -1 ||",
            "\t    (egid != (gid_t) -1 && !gid_eq(kegid, old->gid)))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_sgid(new, new->egid);",
            "\t\t#else",
            "\t\tnew->sgid = new->egid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsgid(new, new->egid);",
            "\t#else",
            "\tnew->fsgid = new->egid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setgid(new, old, LSM_SETID_RE);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "set_one_prio_perm, set_one_prio, __sys_setregid",
          "description": "实现组ID调整逻辑，包含优先级调整权限验证及组ID设置，通过cred结构体更新目标进程的gid/egid字段。",
          "similarity": 0.479529470205307
        }
      ]
    }
  ]
}