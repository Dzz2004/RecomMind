{
  "query": "操作系统安全权限控制机制",
  "timestamp": "2025-12-25 23:32:17",
  "retrieved_files": [
    {
      "source_file": "kernel/seccomp.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:23:11\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `seccomp.c`\n\n---\n\n# seccomp.c 技术文档\n\n## 文件概述\n\n`seccomp.c` 是 Linux 内核中实现安全计算（Secure Computing，简称 seccomp）机制的核心文件。该机制用于限制进程可执行的系统调用，从而提升系统安全性。文件支持两种主要模式：\n\n- **Mode 1（严格模式）**：仅允许 `read`、`write`、`exit` 和 `sigreturn` 四个系统调用。\n- **Mode 2（过滤器模式）**：允许用户通过 Berkeley Packet Filter（BPF）形式定义自定义的系统调用过滤规则。\n\n此外，该文件还实现了 **用户空间通知（user-space notification）** 功能，允许内核在遇到特定系统调用时暂停执行并通知用户态监听器进行处理。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct seccomp_filter`**  \n  表示一个 seccomp BPF 过滤器实例，包含：\n  - 引用计数（`refs` 和 `users`）\n  - BPF 程序指针（`prog`）\n  - 通知相关结构（`notif`、`notify_lock`、`wqh`）\n  - 动作缓存（`cache`）\n  - 指向前一个过滤器的指针（`prev`），构成过滤器链\n\n- **`struct notification`**  \n  管理用户空间通知的容器，包含请求计数器、标志位、下一个通知 ID 和通知链表。\n\n- **`struct seccomp_knotif`**  \n  表示一个待处理的用户通知请求，记录触发通知的任务、系统调用数据、状态（INIT/SENT/REPLIED）、返回值及完成信号量。\n\n- **`struct seccomp_kaddfd`**  \n  用于 `SECCOMP_IOCTL_NOTIF_ADDFD` 操作，允许监听器向目标进程注入文件描述符。\n\n- **`struct action_cache`**（条件编译）  \n  针对原生和兼容架构的系统调用动作缓存，用于快速判断是否允许某系统调用，避免重复执行 BPF 程序。\n\n### 关键枚举与常量\n\n- **`enum notify_state`**：通知状态机（INIT → SENT → REPLIED）\n- **`SECCOMP_MODE_DEAD`**：内部使用的特殊模式，表示进程已进入不可恢复的 seccomp 状态\n- **`MAX_INSNS_PER_PATH`**：限制 BPF 指令路径总长度不超过 256KB，防止资源耗尽\n\n### 特殊兼容性处理\n\n- **`SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR`**：为兼容早期错误的 ioctl 命令方向而保留的旧定义\n\n## 关键实现\n\n### 过滤器生命周期管理\n\n- 使用双重引用计数机制：\n  - `refs`：控制对象内存释放（包括任务引用、依赖过滤器、通知监听器）\n  - `users`：跟踪直接或间接使用该过滤器的任务数量，用于判断是否还能被新任务继承\n- 过滤器一旦附加到任务，除引用计数外不可修改，确保并发安全\n\n### 用户空间通知机制\n\n- 当 BPF 程序返回 `SECCOMP_RET_USER_NOTIF` 时，内核创建 `seccomp_knotif` 并加入通知队列\n- 用户态通过文件描述符读取通知，内核将状态置为 `SENT`\n- 监听器通过 `ioctl` 回复结果，状态转为 `REPLIED`，触发 `completion` 使原任务继续执行\n- 支持通过 `SECCOMP_IOCTL_NOTIF_ADDFD` 向目标进程注入文件描述符\n\n### 动作缓存优化（`action_cache`）\n\n- 在支持 `SECCOMP_ARCH_NATIVE` 的架构上，为每个系统调用编号维护一个“始终允许”位图\n- 若缓存命中（即该系统调用在所有路径下均返回 `ALLOW`），可跳过 BPF 执行，提升性能\n- 分别处理原生（native）和兼容（compat）系统调用空间\n\n### 安全与资源限制\n\n- 限制 BPF 指令总路径长度，防止深度嵌套或循环导致 DoS\n- 通知机制使用互斥锁（`notify_lock`）和完成量（`completion`）保证状态一致性\n- 支持 `wait_killable_recv` 选项，使等待通知回复的进程可被信号中断\n\n## 依赖关系\n\n- **BPF 子系统**：依赖 `linux/filter.h` 提供的 socket filter/BPF 执行引擎\n- **进程管理**：与 `sched.h`、`task_struct` 紧密集成，管理 per-task seccomp 状态\n- **文件系统与 fd 管理**：通过 `file.h`、`uaccess.h` 实现跨进程 fd 注入\n- **审计与日志**：集成 `audit.h` 支持 seccomp 事件审计\n- **架构相关代码**：通过 `asm/syscall.h` 获取系统调用号和参数\n- **能力机制**：依赖 `capability.h` 检查特权操作权限\n- **内存管理**：使用 `slab.h` 分配过滤器和通知结构\n\n## 使用场景\n\n1. **容器安全**：Docker、LXC 等容器运行时使用 seccomp 过滤器限制容器内进程的系统调用，防止逃逸\n2. **沙箱应用**：Chromium、Firefox 等浏览器使用 seccomp 构建渲染进程沙箱\n3. **最小权限原则**：特权服务（如 systemd、sshd）在初始化后启用 seccomp 以减少攻击面\n4. **动态策略执行**：通过 `SECCOMP_RET_USER_NOTIF` 实现用户态代理系统调用（如 ptrace 替代方案）\n5. **安全审计**：结合 `SECCOMP_RET_LOG` 记录所有被拦截或允许的系统调用行为\n6. **系统加固**：在不可信环境中运行程序时，强制限制其系统调用能力",
      "similarity": 0.6301063299179077,
      "chunks": [
        {
          "chunk_id": 8,
          "file_path": "kernel/seccomp.c",
          "start_line": 1340,
          "end_line": 1443,
          "content": [
            "static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,",
            "\t\t\t    const bool recheck_after_trace)",
            "{",
            "\tBUG();",
            "",
            "\treturn -1;",
            "}",
            "int __secure_computing(const struct seccomp_data *sd)",
            "{",
            "\tint mode = current->seccomp.mode;",
            "\tint this_syscall;",
            "",
            "\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&",
            "\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))",
            "\t\treturn 0;",
            "",
            "\tthis_syscall = sd ? sd->nr :",
            "\t\tsyscall_get_nr(current, current_pt_regs());",
            "",
            "\tswitch (mode) {",
            "\tcase SECCOMP_MODE_STRICT:",
            "\t\t__secure_computing_strict(this_syscall);  /* may call do_exit */",
            "\t\treturn 0;",
            "\tcase SECCOMP_MODE_FILTER:",
            "\t\treturn __seccomp_filter(this_syscall, sd, false);",
            "\t/* Surviving SECCOMP_RET_KILL_* must be proactively impossible. */",
            "\tcase SECCOMP_MODE_DEAD:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tdo_exit(SIGKILL);",
            "\t\treturn -1;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "}",
            "long prctl_get_seccomp(void)",
            "{",
            "\treturn current->seccomp.mode;",
            "}",
            "static long seccomp_set_mode_strict(void)",
            "{",
            "\tconst unsigned long seccomp_mode = SECCOMP_MODE_STRICT;",
            "\tlong ret = -EINVAL;",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "",
            "\tif (!seccomp_may_assign_mode(seccomp_mode))",
            "\t\tgoto out;",
            "",
            "#ifdef TIF_NOTSC",
            "\tdisable_TSC();",
            "#endif",
            "\tseccomp_assign_mode(current, seccomp_mode, 0);",
            "\tret = 0;",
            "",
            "out:",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "",
            "\treturn ret;",
            "}",
            "static void seccomp_notify_free(struct seccomp_filter *filter)",
            "{",
            "\tkfree(filter->notif);",
            "\tfilter->notif = NULL;",
            "}",
            "static void seccomp_notify_detach(struct seccomp_filter *filter)",
            "{",
            "\tstruct seccomp_knotif *knotif;",
            "",
            "\tif (!filter)",
            "\t\treturn;",
            "",
            "\tmutex_lock(&filter->notify_lock);",
            "",
            "\t/*",
            "\t * If this file is being closed because e.g. the task who owned it",
            "\t * died, let's wake everyone up who was waiting on us.",
            "\t */",
            "\tlist_for_each_entry(knotif, &filter->notif->notifications, list) {",
            "\t\tif (knotif->state == SECCOMP_NOTIFY_REPLIED)",
            "\t\t\tcontinue;",
            "",
            "\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;",
            "\t\tknotif->error = -ENOSYS;",
            "\t\tknotif->val = 0;",
            "",
            "\t\t/*",
            "\t\t * We do not need to wake up any pending addfd messages, as",
            "\t\t * the notifier will do that for us, as this just looks",
            "\t\t * like a standard reply.",
            "\t\t */",
            "\t\tcomplete(&knotif->ready);",
            "\t}",
            "",
            "\tseccomp_notify_free(filter);",
            "\tmutex_unlock(&filter->notify_lock);",
            "}",
            "static int seccomp_notify_release(struct inode *inode, struct file *file)",
            "{",
            "\tstruct seccomp_filter *filter = file->private_data;",
            "",
            "\tseccomp_notify_detach(filter);",
            "\t__put_seccomp_filter(filter);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__seccomp_filter, __secure_computing, prctl_get_seccomp, seccomp_set_mode_strict, seccomp_notify_free, seccomp_notify_detach, seccomp_notify_release",
          "description": "提供seccomp模式切换接口(prctl_get_seccomp/seccomp_set_mode_strict)，实现通知资源释放(detach/release)机制",
          "similarity": 0.6242853403091431
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/seccomp.c",
          "start_line": 937,
          "end_line": 1066,
          "content": [
            "static void __get_seccomp_filter(struct seccomp_filter *filter)",
            "{",
            "\trefcount_inc(&filter->refs);",
            "}",
            "void get_seccomp_filter(struct task_struct *tsk)",
            "{",
            "\tstruct seccomp_filter *orig = tsk->seccomp.filter;",
            "\tif (!orig)",
            "\t\treturn;",
            "\t__get_seccomp_filter(orig);",
            "\trefcount_inc(&orig->users);",
            "}",
            "static inline void seccomp_log(unsigned long syscall, long signr, u32 action,",
            "\t\t\t       bool requested)",
            "{",
            "\tbool log = false;",
            "",
            "\tswitch (action) {",
            "\tcase SECCOMP_RET_ALLOW:",
            "\t\tbreak;",
            "\tcase SECCOMP_RET_TRAP:",
            "\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;",
            "\t\tbreak;",
            "\tcase SECCOMP_RET_ERRNO:",
            "\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;",
            "\t\tbreak;",
            "\tcase SECCOMP_RET_TRACE:",
            "\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;",
            "\t\tbreak;",
            "\tcase SECCOMP_RET_USER_NOTIF:",
            "\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_USER_NOTIF;",
            "\t\tbreak;",
            "\tcase SECCOMP_RET_LOG:",
            "\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;",
            "\t\tbreak;",
            "\tcase SECCOMP_RET_KILL_THREAD:",
            "\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;",
            "\t\tbreak;",
            "\tcase SECCOMP_RET_KILL_PROCESS:",
            "\tdefault:",
            "\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;",
            "\t}",
            "",
            "\t/*",
            "\t * Emit an audit message when the action is RET_KILL_*, RET_LOG, or the",
            "\t * FILTER_FLAG_LOG bit was set. The admin has the ability to silence",
            "\t * any action from being logged by removing the action name from the",
            "\t * seccomp_actions_logged sysctl.",
            "\t */",
            "\tif (!log)",
            "\t\treturn;",
            "",
            "\taudit_seccomp(syscall, signr, action);",
            "}",
            "static void __secure_computing_strict(int this_syscall)",
            "{",
            "\tconst int *allowed_syscalls = mode1_syscalls;",
            "#ifdef CONFIG_COMPAT",
            "\tif (in_compat_syscall())",
            "\t\tallowed_syscalls = get_compat_mode1_syscalls();",
            "#endif",
            "\tdo {",
            "\t\tif (*allowed_syscalls == this_syscall)",
            "\t\t\treturn;",
            "\t} while (*++allowed_syscalls != -1);",
            "",
            "#ifdef SECCOMP_DEBUG",
            "\tdump_stack();",
            "#endif",
            "\tcurrent->seccomp.mode = SECCOMP_MODE_DEAD;",
            "\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);",
            "\tdo_exit(SIGKILL);",
            "}",
            "void secure_computing_strict(int this_syscall)",
            "{",
            "\tint mode = current->seccomp.mode;",
            "",
            "\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&",
            "\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))",
            "\t\treturn;",
            "",
            "\tif (mode == SECCOMP_MODE_DISABLED)",
            "\t\treturn;",
            "\telse if (mode == SECCOMP_MODE_STRICT)",
            "\t\t__secure_computing_strict(this_syscall);",
            "\telse",
            "\t\tBUG();",
            "}",
            "static u64 seccomp_next_notify_id(struct seccomp_filter *filter)",
            "{",
            "\t/*",
            "\t * Note: overflow is ok here, the id just needs to be unique per",
            "\t * filter.",
            "\t */",
            "\tlockdep_assert_held(&filter->notify_lock);",
            "\treturn filter->notif->next_id++;",
            "}",
            "static void seccomp_handle_addfd(struct seccomp_kaddfd *addfd, struct seccomp_knotif *n)",
            "{",
            "\tint fd;",
            "",
            "\t/*",
            "\t * Remove the notification, and reset the list pointers, indicating",
            "\t * that it has been handled.",
            "\t */",
            "\tlist_del_init(&addfd->list);",
            "\tif (!addfd->setfd)",
            "\t\tfd = receive_fd(addfd->file, addfd->flags);",
            "\telse",
            "\t\tfd = receive_fd_replace(addfd->fd, addfd->file, addfd->flags);",
            "\taddfd->ret = fd;",
            "",
            "\tif (addfd->ioctl_flags & SECCOMP_ADDFD_FLAG_SEND) {",
            "\t\t/* If we fail reset and return an error to the notifier */",
            "\t\tif (fd < 0) {",
            "\t\t\tn->state = SECCOMP_NOTIFY_SENT;",
            "\t\t} else {",
            "\t\t\t/* Return the FD we just added */",
            "\t\t\tn->flags = 0;",
            "\t\t\tn->error = 0;",
            "\t\t\tn->val = fd;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * Mark the notification as completed. From this point, addfd mem",
            "\t * might be invalidated and we can't safely read it anymore.",
            "\t */",
            "\tcomplete(&addfd->completion);",
            "}"
          ],
          "function_name": "__get_seccomp_filter, get_seccomp_filter, seccomp_log, __secure_computing_strict, secure_computing_strict, seccomp_next_notify_id, seccomp_handle_addfd",
          "description": "管理seccomp过滤器引用计数及日志记录，secure_computing_strict强制模式检查系统调用合法性，seccomp_handle_addfd处理文件描述符添加通知",
          "similarity": 0.575427234172821
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/seccomp.c",
          "start_line": 1111,
          "end_line": 1212,
          "content": [
            "static bool should_sleep_killable(struct seccomp_filter *match,",
            "\t\t\t\t  struct seccomp_knotif *n)",
            "{",
            "\treturn match->wait_killable_recv && n->state == SECCOMP_NOTIFY_SENT;",
            "}",
            "static int seccomp_do_user_notification(int this_syscall,",
            "\t\t\t\t\tstruct seccomp_filter *match,",
            "\t\t\t\t\tconst struct seccomp_data *sd)",
            "{",
            "\tint err;",
            "\tu32 flags = 0;",
            "\tlong ret = 0;",
            "\tstruct seccomp_knotif n = {};",
            "\tstruct seccomp_kaddfd *addfd, *tmp;",
            "",
            "\tmutex_lock(&match->notify_lock);",
            "\terr = -ENOSYS;",
            "\tif (!match->notif)",
            "\t\tgoto out;",
            "",
            "\tn.task = current;",
            "\tn.state = SECCOMP_NOTIFY_INIT;",
            "\tn.data = sd;",
            "\tn.id = seccomp_next_notify_id(match);",
            "\tinit_completion(&n.ready);",
            "\tlist_add_tail(&n.list, &match->notif->notifications);",
            "\tINIT_LIST_HEAD(&n.addfd);",
            "",
            "\tatomic_inc(&match->notif->requests);",
            "\tif (match->notif->flags & SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP)",
            "\t\twake_up_poll_on_current_cpu(&match->wqh, EPOLLIN | EPOLLRDNORM);",
            "\telse",
            "\t\twake_up_poll(&match->wqh, EPOLLIN | EPOLLRDNORM);",
            "",
            "\t/*",
            "\t * This is where we wait for a reply from userspace.",
            "\t */",
            "\tdo {",
            "\t\tbool wait_killable = should_sleep_killable(match, &n);",
            "",
            "\t\tmutex_unlock(&match->notify_lock);",
            "\t\tif (wait_killable)",
            "\t\t\terr = wait_for_completion_killable(&n.ready);",
            "\t\telse",
            "\t\t\terr = wait_for_completion_interruptible(&n.ready);",
            "\t\tmutex_lock(&match->notify_lock);",
            "",
            "\t\tif (err != 0) {",
            "\t\t\t/*",
            "\t\t\t * Check to see if the notifcation got picked up and",
            "\t\t\t * whether we should switch to wait killable.",
            "\t\t\t */",
            "\t\t\tif (!wait_killable && should_sleep_killable(match, &n))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tgoto interrupted;",
            "\t\t}",
            "",
            "\t\taddfd = list_first_entry_or_null(&n.addfd,",
            "\t\t\t\t\t\t struct seccomp_kaddfd, list);",
            "\t\t/* Check if we were woken up by a addfd message */",
            "\t\tif (addfd)",
            "\t\t\tseccomp_handle_addfd(addfd, &n);",
            "",
            "\t}  while (n.state != SECCOMP_NOTIFY_REPLIED);",
            "",
            "\tret = n.val;",
            "\terr = n.error;",
            "\tflags = n.flags;",
            "",
            "interrupted:",
            "\t/* If there were any pending addfd calls, clear them out */",
            "\tlist_for_each_entry_safe(addfd, tmp, &n.addfd, list) {",
            "\t\t/* The process went away before we got a chance to handle it */",
            "\t\taddfd->ret = -ESRCH;",
            "\t\tlist_del_init(&addfd->list);",
            "\t\tcomplete(&addfd->completion);",
            "\t}",
            "",
            "\t/*",
            "\t * Note that it's possible the listener died in between the time when",
            "\t * we were notified of a response (or a signal) and when we were able to",
            "\t * re-acquire the lock, so only delete from the list if the",
            "\t * notification actually exists.",
            "\t *",
            "\t * Also note that this test is only valid because there's no way to",
            "\t * *reattach* to a notifier right now. If one is added, we'll need to",
            "\t * keep track of the notif itself and make sure they match here.",
            "\t */",
            "\tif (match->notif)",
            "\t\tlist_del(&n.list);",
            "out:",
            "\tmutex_unlock(&match->notify_lock);",
            "",
            "\t/* Userspace requests to continue the syscall. */",
            "\tif (flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE)",
            "\t\treturn 0;",
            "",
            "\tsyscall_set_return_value(current, current_pt_regs(),",
            "\t\t\t\t err, ret);",
            "\treturn -1;",
            "}"
          ],
          "function_name": "should_sleep_killable, seccomp_do_user_notification",
          "description": "实现用户空间通知等待逻辑，seccomp_do_user_notification处理通知状态转换、文件描述符传递及超时控制",
          "similarity": 0.5609490275382996
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/seccomp.c",
          "start_line": 1477,
          "end_line": 1578,
          "content": [
            "static int recv_wake_function(wait_queue_entry_t *wait, unsigned int mode, int sync,",
            "\t\t\t\t  void *key)",
            "{",
            "\t/* Avoid a wakeup if event not interesting for us. */",
            "\tif (key && !(key_to_poll(key) & (EPOLLIN | EPOLLERR)))",
            "\t\treturn 0;",
            "\treturn autoremove_wake_function(wait, mode, sync, key);",
            "}",
            "static int recv_wait_event(struct seccomp_filter *filter)",
            "{",
            "\tDEFINE_WAIT_FUNC(wait, recv_wake_function);",
            "\tint ret;",
            "",
            "\tif (atomic_dec_if_positive(&filter->notif->requests) >= 0)",
            "\t\treturn 0;",
            "",
            "\tfor (;;) {",
            "\t\tret = prepare_to_wait_event(&filter->wqh, &wait, TASK_INTERRUPTIBLE);",
            "",
            "\t\tif (atomic_dec_if_positive(&filter->notif->requests) >= 0)",
            "\t\t\tbreak;",
            "",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "",
            "\t\tschedule();",
            "\t}",
            "\tfinish_wait(&filter->wqh, &wait);",
            "\treturn 0;",
            "}",
            "static long seccomp_notify_recv(struct seccomp_filter *filter,",
            "\t\t\t\tvoid __user *buf)",
            "{",
            "\tstruct seccomp_knotif *knotif = NULL, *cur;",
            "\tstruct seccomp_notif unotif;",
            "\tssize_t ret;",
            "",
            "\t/* Verify that we're not given garbage to keep struct extensible. */",
            "\tret = check_zeroed_user(buf, sizeof(unotif));",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "\tif (!ret)",
            "\t\treturn -EINVAL;",
            "",
            "\tmemset(&unotif, 0, sizeof(unotif));",
            "",
            "\tret = recv_wait_event(filter);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tmutex_lock(&filter->notify_lock);",
            "\tlist_for_each_entry(cur, &filter->notif->notifications, list) {",
            "\t\tif (cur->state == SECCOMP_NOTIFY_INIT) {",
            "\t\t\tknotif = cur;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * If we didn't find a notification, it could be that the task was",
            "\t * interrupted by a fatal signal between the time we were woken and",
            "\t * when we were able to acquire the rw lock.",
            "\t */",
            "\tif (!knotif) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tunotif.id = knotif->id;",
            "\tunotif.pid = task_pid_vnr(knotif->task);",
            "\tunotif.data = *(knotif->data);",
            "",
            "\tknotif->state = SECCOMP_NOTIFY_SENT;",
            "\twake_up_poll(&filter->wqh, EPOLLOUT | EPOLLWRNORM);",
            "\tret = 0;",
            "out:",
            "\tmutex_unlock(&filter->notify_lock);",
            "",
            "\tif (ret == 0 && copy_to_user(buf, &unotif, sizeof(unotif))) {",
            "\t\tret = -EFAULT;",
            "",
            "\t\t/*",
            "\t\t * Userspace screwed up. To make sure that we keep this",
            "\t\t * notification alive, let's reset it back to INIT. It",
            "\t\t * may have died when we released the lock, so we need to make",
            "\t\t * sure it's still around.",
            "\t\t */",
            "\t\tmutex_lock(&filter->notify_lock);",
            "\t\tknotif = find_notification(filter, unotif.id);",
            "\t\tif (knotif) {",
            "\t\t\t/* Reset the process to make sure it's not stuck */",
            "\t\t\tif (should_sleep_killable(filter, knotif))",
            "\t\t\t\tcomplete(&knotif->ready);",
            "\t\t\tknotif->state = SECCOMP_NOTIFY_INIT;",
            "\t\t\tatomic_inc(&filter->notif->requests);",
            "\t\t\twake_up_poll(&filter->wqh, EPOLLIN | EPOLLRDNORM);",
            "\t\t}",
            "\t\tmutex_unlock(&filter->notify_lock);",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "recv_wake_function, recv_wait_event, seccomp_notify_recv",
          "description": "实现通知接收等待队列管理(recv_wait_event)和用户态数据接收(seccomp_notify_recv)的同步控制",
          "similarity": 0.5601153373718262
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/seccomp.c",
          "start_line": 1582,
          "end_line": 1778,
          "content": [
            "static long seccomp_notify_send(struct seccomp_filter *filter,",
            "\t\t\t\tvoid __user *buf)",
            "{",
            "\tstruct seccomp_notif_resp resp = {};",
            "\tstruct seccomp_knotif *knotif;",
            "\tlong ret;",
            "",
            "\tif (copy_from_user(&resp, buf, sizeof(resp)))",
            "\t\treturn -EFAULT;",
            "",
            "\tif (resp.flags & ~SECCOMP_USER_NOTIF_FLAG_CONTINUE)",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((resp.flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE) &&",
            "\t    (resp.error || resp.val))",
            "\t\treturn -EINVAL;",
            "",
            "\tret = mutex_lock_interruptible(&filter->notify_lock);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tknotif = find_notification(filter, resp.id);",
            "\tif (!knotif) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* Allow exactly one reply. */",
            "\tif (knotif->state != SECCOMP_NOTIFY_SENT) {",
            "\t\tret = -EINPROGRESS;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = 0;",
            "\tknotif->state = SECCOMP_NOTIFY_REPLIED;",
            "\tknotif->error = resp.error;",
            "\tknotif->val = resp.val;",
            "\tknotif->flags = resp.flags;",
            "\tif (filter->notif->flags & SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP)",
            "\t\tcomplete_on_current_cpu(&knotif->ready);",
            "\telse",
            "\t\tcomplete(&knotif->ready);",
            "out:",
            "\tmutex_unlock(&filter->notify_lock);",
            "\treturn ret;",
            "}",
            "static long seccomp_notify_id_valid(struct seccomp_filter *filter,",
            "\t\t\t\t    void __user *buf)",
            "{",
            "\tstruct seccomp_knotif *knotif;",
            "\tu64 id;",
            "\tlong ret;",
            "",
            "\tif (copy_from_user(&id, buf, sizeof(id)))",
            "\t\treturn -EFAULT;",
            "",
            "\tret = mutex_lock_interruptible(&filter->notify_lock);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tknotif = find_notification(filter, id);",
            "\tif (knotif && knotif->state == SECCOMP_NOTIFY_SENT)",
            "\t\tret = 0;",
            "\telse",
            "\t\tret = -ENOENT;",
            "",
            "\tmutex_unlock(&filter->notify_lock);",
            "\treturn ret;",
            "}",
            "static long seccomp_notify_set_flags(struct seccomp_filter *filter,",
            "\t\t\t\t    unsigned long flags)",
            "{",
            "\tlong ret;",
            "",
            "\tif (flags & ~SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP)",
            "\t\treturn -EINVAL;",
            "",
            "\tret = mutex_lock_interruptible(&filter->notify_lock);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "\tfilter->notif->flags = flags;",
            "\tmutex_unlock(&filter->notify_lock);",
            "\treturn 0;",
            "}",
            "static long seccomp_notify_addfd(struct seccomp_filter *filter,",
            "\t\t\t\t struct seccomp_notif_addfd __user *uaddfd,",
            "\t\t\t\t unsigned int size)",
            "{",
            "\tstruct seccomp_notif_addfd addfd;",
            "\tstruct seccomp_knotif *knotif;",
            "\tstruct seccomp_kaddfd kaddfd;",
            "\tint ret;",
            "",
            "\tBUILD_BUG_ON(sizeof(addfd) < SECCOMP_NOTIFY_ADDFD_SIZE_VER0);",
            "\tBUILD_BUG_ON(sizeof(addfd) != SECCOMP_NOTIFY_ADDFD_SIZE_LATEST);",
            "",
            "\tif (size < SECCOMP_NOTIFY_ADDFD_SIZE_VER0 || size >= PAGE_SIZE)",
            "\t\treturn -EINVAL;",
            "",
            "\tret = copy_struct_from_user(&addfd, sizeof(addfd), uaddfd, size);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (addfd.newfd_flags & ~O_CLOEXEC)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (addfd.flags & ~(SECCOMP_ADDFD_FLAG_SETFD | SECCOMP_ADDFD_FLAG_SEND))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (addfd.newfd && !(addfd.flags & SECCOMP_ADDFD_FLAG_SETFD))",
            "\t\treturn -EINVAL;",
            "",
            "\tkaddfd.file = fget(addfd.srcfd);",
            "\tif (!kaddfd.file)",
            "\t\treturn -EBADF;",
            "",
            "\tkaddfd.ioctl_flags = addfd.flags;",
            "\tkaddfd.flags = addfd.newfd_flags;",
            "\tkaddfd.setfd = addfd.flags & SECCOMP_ADDFD_FLAG_SETFD;",
            "\tkaddfd.fd = addfd.newfd;",
            "\tinit_completion(&kaddfd.completion);",
            "",
            "\tret = mutex_lock_interruptible(&filter->notify_lock);",
            "\tif (ret < 0)",
            "\t\tgoto out;",
            "",
            "\tknotif = find_notification(filter, addfd.id);",
            "\tif (!knotif) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\t/*",
            "\t * We do not want to allow for FD injection to occur before the",
            "\t * notification has been picked up by a userspace handler, or after",
            "\t * the notification has been replied to.",
            "\t */",
            "\tif (knotif->state != SECCOMP_NOTIFY_SENT) {",
            "\t\tret = -EINPROGRESS;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tif (addfd.flags & SECCOMP_ADDFD_FLAG_SEND) {",
            "\t\t/*",
            "\t\t * Disallow queuing an atomic addfd + send reply while there are",
            "\t\t * some addfd requests still to process.",
            "\t\t *",
            "\t\t * There is no clear reason to support it and allows us to keep",
            "\t\t * the loop on the other side straight-forward.",
            "\t\t */",
            "\t\tif (!list_empty(&knotif->addfd)) {",
            "\t\t\tret = -EBUSY;",
            "\t\t\tgoto out_unlock;",
            "\t\t}",
            "",
            "\t\t/* Allow exactly only one reply */",
            "\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;",
            "\t}",
            "",
            "\tlist_add(&kaddfd.list, &knotif->addfd);",
            "\tcomplete(&knotif->ready);",
            "\tmutex_unlock(&filter->notify_lock);",
            "",
            "\t/* Now we wait for it to be processed or be interrupted */",
            "\tret = wait_for_completion_interruptible(&kaddfd.completion);",
            "\tif (ret == 0) {",
            "\t\t/*",
            "\t\t * We had a successful completion. The other side has already",
            "\t\t * removed us from the addfd queue, and",
            "\t\t * wait_for_completion_interruptible has a memory barrier upon",
            "\t\t * success that lets us read this value directly without",
            "\t\t * locking.",
            "\t\t */",
            "\t\tret = kaddfd.ret;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tmutex_lock(&filter->notify_lock);",
            "\t/*",
            "\t * Even though we were woken up by a signal and not a successful",
            "\t * completion, a completion may have happened in the mean time.",
            "\t *",
            "\t * We need to check again if the addfd request has been handled,",
            "\t * and if not, we will remove it from the queue.",
            "\t */",
            "\tif (list_empty(&kaddfd.list))",
            "\t\tret = kaddfd.ret;",
            "\telse",
            "\t\tlist_del(&kaddfd.list);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&filter->notify_lock);",
            "out:",
            "\tfput(kaddfd.file);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "seccomp_notify_send, seccomp_notify_id_valid, seccomp_notify_set_flags, seccomp_notify_addfd",
          "description": "该代码段实现了seccomp过滤器中用户空间通知机制的相关功能，核心作用是处理通知响应、验证通知ID、配置通知标志及管理文件描述符注入。  \n`seccomp_notify_send`接收并处理用户空间的响应数据，校验合法性后更新通知状态；`seccomp_notify_id_valid`验证指定ID的通知是否存在；`seccomp_notify_set_flags`和`seccomp_notify_addfd`分别用于设置通知标志和安全地注入文件描述符，均通过互斥锁保护关键操作。  \n代码片段完整，未引入额外API，所有行为均基于现有内核seccomp通知框架实现。",
          "similarity": 0.5568863153457642
        }
      ]
    },
    {
      "source_file": "kernel/capability.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:39:00\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `capability.c`\n\n---\n\n# capability.c 技术文档\n\n## 1. 文件概述\n\n`capability.c` 是 Linux 内核中实现 POSIX 能力（Capabilities）机制的核心文件，位于 `kernel/` 目录下。该文件主要负责提供用户空间与内核之间进行能力获取（`capget`）和设置（`capset`）的系统调用接口，并维护能力模型的版本兼容性、安全策略检查以及与 LSM（Linux Security Module）框架的集成。能力机制允许将传统超级用户权限细分为多个独立的特权单元，从而实现最小权限原则。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `file_caps_enabled`：控制是否启用文件能力（File Capabilities）功能的全局开关，默认启用。可通过内核启动参数 `no_file_caps` 禁用。\n\n### 主要函数\n- **`cap_validate_magic()`**：验证用户传入的能力结构体版本号，支持 v1、v2、v3 版本，并对旧版本发出警告。\n- **`cap_get_target_pid()`**：安全地获取指定进程（通过 PID）的有效（Effective）、可继承（Inheritable）和允许（Permitted）能力集。\n- **`sys_capget()`**：`capget(2)` 系统调用的实现，用于查询指定进程的能力集。\n- **`sys_capset()`**：`capset(2)` 系统调用的实现，用于设置当前进程的能力集（仅限自身）。\n- **`mk_kernel_cap()`**：将用户空间传入的高低 32 位能力值组合成内核内部的 `kernel_cap_t` 类型。\n- **`has_ns_capability()`**（截断）：检查指定任务在给定用户命名空间中是否拥有某项能力（函数体在提供的代码中被截断）。\n\n### 辅助函数\n- `warn_legacy_capability_use()`：对使用 v1（32 位）能力接口的应用程序发出一次性警告。\n- `warn_deprecated_v2()`：对使用已弃用的 v2 能力接口的应用程序发出一次性警告。\n\n## 3. 关键实现\n\n### 能力版本兼容性处理\n- 支持三种能力结构版本：\n  - **v1 (`_LINUX_CAPABILITY_VERSION_1`)**：仅支持 32 位能力（旧版），调用时触发 `warn_legacy_capability_use()`。\n  - **v2 (`_LINUX_CAPABILITY_VERSION_2`)**：支持 64 位能力但存在安全风险，调用时触发 `warn_deprecated_v2()`。\n  - **v3 (`_LINUX_CAPABILITY_VERSION_3`)**：当前推荐版本，功能等同于 v2 但通过头文件变更避免误用。\n- 对于无效版本，内核会尝试将当前支持的版本号写回用户空间并返回 `-EINVAL`。\n\n### 能力数据传输格式\n- 用户空间使用两个 `__user_cap_data_struct` 结构体（`kdata[2]`）来表示 64 位能力值：\n  - `kdata[0]` 存储低 32 位\n  - `kdata[1]` 存储高 32 位\n- 在 `capget` 中，内核能力值被拆分为高低 32 位写入用户缓冲区；在 `capset` 中则反向组合。\n- **向后兼容策略**：当用户空间请求的版本只支持 32 位（`tocopy = 1`）时，内核会静默丢弃高 32 位能力，避免旧版 `libcap` 应用崩溃。\n\n### 安全限制\n- **`capset` 限制**：仅允许进程修改自身能力（`pid` 必须为 0 或当前进程 PID），修改其他进程能力的功能已被移除。\n- **能力设置规则**（由 LSM 实现，如 `security_capset`）：\n  - 新的 **可继承集（I）** 和 **允许集（P）** 只能是旧允许集的子集。\n  - 新的 **有效集（E）** 必须是新允许集的子集。\n- 使用 `prepare_creds()` / `commit_creds()` 机制安全地更新进程凭证（credentials），并在失败时通过 `abort_creds()` 回滚。\n\n### 并发与锁机制\n- 获取**其他进程**能力时，使用 `rcu_read_lock()` 保护对进程链表的访问（通过 `find_task_by_vpid()`）。\n- 获取**当前进程**能力时无需加锁，因为能力修改是原子的（通过凭证替换）。\n\n### 审计与日志\n- `capset` 成功时调用 `audit_log_capset()` 记录能力变更事件，用于安全审计。\n- 对旧版能力接口的使用通过 `pr_info_once()` 发出一次性内核日志警告。\n\n## 4. 依赖关系\n\n- **LSM 框架**：通过 `security_capget()` 和 `security_capset()` 钩子与安全模块（如 SELinux、AppArmor）交互，实际的能力检查和设置策略由 LSM 实现。\n- **凭证子系统**：依赖 `cred` 结构体管理进程权限，使用 `prepare_creds()`、`commit_creds()` 等函数安全更新。\n- **命名空间**：支持用户命名空间（`user_namespace.h`），能力检查与命名空间隔离相关（体现在 `has_ns_capability` 等函数中）。\n- **审计子系统**：通过 `audit.h` 提供能力变更的审计日志。\n- **系统调用接口**：通过 `SYSCALL_DEFINE2` 定义 `capget` 和 `capset` 系统调用。\n- **用户空间访问**：使用 `uaccess.h` 中的 `copy_to_user()` 和 `copy_from_user()` 安全传输数据。\n\n## 5. 使用场景\n\n- **容器与沙箱**：容器运行时（如 Docker、runc）通过 `capset` 限制容器内进程的能力集，实现权限隔离。\n- **特权程序降权**：需要临时提升权限的程序（如 `ping` 使用 `CAP_NET_RAW`）可在执行关键操作后通过 `capset` 丢弃多余能力。\n- **安全策略实施**：系统管理员或安全模块通过限制进程能力，遵循最小权限原则，减少攻击面。\n- **调试与监控**：安全工具（如 `getpcaps`）通过 `capget` 查询进程当前能力状态，用于诊断或合规检查。\n- **文件能力加载**：虽然本文件不直接处理文件能力，但 `file_caps_enabled` 开关控制是否启用基于文件扩展属性（xattr）的能力加载机制（由 `fs/` 子系统实现）。",
      "similarity": 0.6285444498062134,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/capability.c",
          "start_line": 25,
          "end_line": 125,
          "content": [
            "static int __init file_caps_disable(char *str)",
            "{",
            "\tfile_caps_enabled = 0;",
            "\treturn 1;",
            "}",
            "static void warn_legacy_capability_use(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static void warn_deprecated_v2(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static int cap_validate_magic(cap_user_header_t header, unsigned *tocopy)",
            "{",
            "\t__u32 version;",
            "",
            "\tif (get_user(version, &header->version))",
            "\t\treturn -EFAULT;",
            "",
            "\tswitch (version) {",
            "\tcase _LINUX_CAPABILITY_VERSION_1:",
            "\t\twarn_legacy_capability_use();",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_1;",
            "\t\tbreak;",
            "\tcase _LINUX_CAPABILITY_VERSION_2:",
            "\t\twarn_deprecated_v2();",
            "\t\tfallthrough;\t/* v3 is otherwise equivalent to v2 */",
            "\tcase _LINUX_CAPABILITY_VERSION_3:",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_3;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tif (put_user((u32)_KERNEL_CAPABILITY_VERSION, &header->version))",
            "\t\t\treturn -EFAULT;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,",
            "\t\t\t\t     kernel_cap_t *pIp, kernel_cap_t *pPp)",
            "{",
            "\tint ret;",
            "",
            "\tif (pid && (pid != task_pid_vnr(current))) {",
            "\t\tconst struct task_struct *target;",
            "",
            "\t\trcu_read_lock();",
            "",
            "\t\ttarget = find_task_by_vpid(pid);",
            "\t\tif (!target)",
            "\t\t\tret = -ESRCH;",
            "\t\telse",
            "\t\t\tret = security_capget(target, pEp, pIp, pPp);",
            "",
            "\t\trcu_read_unlock();",
            "\t} else",
            "\t\tret = security_capget(current, pEp, pIp, pPp);",
            "",
            "\treturn ret;",
            "}",
            "static kernel_cap_t mk_kernel_cap(u32 low, u32 high)",
            "{",
            "\treturn (kernel_cap_t) { (low | ((u64)high << 32)) & CAP_VALID_MASK };",
            "}",
            "bool has_ns_capability(struct task_struct *t,",
            "\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability(t, &init_user_ns, cap);",
            "}",
            "bool has_ns_capability_noaudit(struct task_struct *t,",
            "\t\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability_noaudit(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);",
            "}"
          ],
          "function_name": "file_caps_disable, warn_legacy_capability_use, warn_deprecated_v2, cap_validate_magic, cap_get_target_pid, mk_kernel_cap, has_ns_capability, has_capability, has_ns_capability_noaudit, has_capability_noaudit",
          "description": "提供能力相关辅助函数，包括禁用文件能力标志、版本验证警告、目标进程能力获取及能力结构构建，实现命名空间能力检查和权限验证逻辑",
          "similarity": 0.6070294380187988
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/capability.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * linux/kernel/capability.c",
            " *",
            " * Copyright (C) 1997  Andrew Main <zefram@fysh.org>",
            " *",
            " * Integrated into 2.1.97+,  Andrew G. Morgan <morgan@kernel.org>",
            " * 30 May 2002:\tCleanup, Robert M. Love <rml@tech9.net>",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/uaccess.h>",
            "",
            "int file_caps_enabled = 1;",
            ""
          ],
          "function_name": null,
          "description": "声明模块许可证并包含必要的头文件，定义控制文件能力启用状态的全局变量file_caps_enabled",
          "similarity": 0.5594521164894104
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/capability.c",
          "start_line": 351,
          "end_line": 424,
          "content": [
            "static bool ns_capable_common(struct user_namespace *ns,",
            "\t\t\t      int cap,",
            "\t\t\t      unsigned int opts)",
            "{",
            "\tint capable;",
            "",
            "\tif (unlikely(!cap_valid(cap))) {",
            "\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);",
            "\t\tBUG();",
            "\t}",
            "",
            "\tcapable = security_capable(current_cred(), ns, cap, opts);",
            "\tif (capable == 0) {",
            "\t\tcurrent->flags |= PF_SUPERPRIV;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "bool ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NONE);",
            "}",
            "bool ns_capable_noaudit(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);",
            "}",
            "bool ns_capable_setid(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);",
            "}",
            "bool capable(int cap)",
            "{",
            "\treturn ns_capable(&init_user_ns, cap);",
            "}",
            "bool file_ns_capable(const struct file *file, struct user_namespace *ns,",
            "\t\t     int cap)",
            "{",
            "",
            "\tif (WARN_ON_ONCE(!cap_valid(cap)))",
            "\t\treturn false;",
            "",
            "\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "bool privileged_wrt_inode_uidgid(struct user_namespace *ns,",
            "\t\t\t\t struct mnt_idmap *idmap,",
            "\t\t\t\t const struct inode *inode)",
            "{",
            "\treturn vfsuid_has_mapping(ns, i_uid_into_vfsuid(idmap, inode)) &&",
            "\t       vfsgid_has_mapping(ns, i_gid_into_vfsgid(idmap, inode));",
            "}",
            "bool capable_wrt_inode_uidgid(struct mnt_idmap *idmap,",
            "\t\t\t      const struct inode *inode, int cap)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "",
            "\treturn ns_capable(ns, cap) &&",
            "\t       privileged_wrt_inode_uidgid(ns, idmap, inode);",
            "}",
            "bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)",
            "{",
            "\tint ret = 0;  /* An absent tracer adds no restrictions */",
            "\tconst struct cred *cred;",
            "",
            "\trcu_read_lock();",
            "\tcred = rcu_dereference(tsk->ptracer_cred);",
            "\tif (cred)",
            "\t\tret = security_capable(cred, ns, CAP_SYS_PTRACE,",
            "\t\t\t\t       CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "\treturn (ret == 0);",
            "}"
          ],
          "function_name": "ns_capable_common, ns_capable, ns_capable_noaudit, ns_capable_setid, capable, file_ns_capable, privileged_wrt_inode_uidgid, capable_wrt_inode_uidgid, ptracer_capable",
          "description": "实现核心能力检查函数，包含通用命名空间能力检测、当前命名空间能力检查、文件能力验证、基于inode UID/GID的特权判断及跟踪者能力检查等功能",
          "similarity": 0.5508467555046082
        }
      ]
    },
    {
      "source_file": "kernel/pid_sysctl.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:17:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid_sysctl.h`\n\n---\n\n# `pid_sysctl.h` 技术文档\n\n## 1. 文件概述\n\n`pid_sysctl.h` 是 Linux 内核中用于定义与 PID 命名空间（`pid_namespace`）相关的系统控制（sysctl）接口的头文件。其核心功能是提供对 `memfd_noexec` 系统策略的运行时配置支持，该策略用于控制通过 `memfd_create()` 创建的内存文件是否允许执行代码。该配置具有层级继承语义：子 PID 命名空间的策略不能比其父命名空间更宽松，以确保安全策略的向下兼容性和强制性。\n\n## 2. 核心功能\n\n### 函数\n\n- **`pid_mfd_noexec_dointvec_minmax`**  \n  自定义的 sysctl 处理函数，用于读写 `memfd_noexec` 策略值。在写入时执行权限检查和策略继承约束验证。\n\n- **`register_pid_ns_sysctl_table_vm`**  \n  内联函数，用于向内核 sysctl 子系统注册 `vm.memfd_noexec` 控制项（仅在 `CONFIG_SYSCTL` 和 `CONFIG_MEMFD_CREATE` 同时启用时有效）。\n\n### 数据结构\n\n- **`pid_ns_ctl_table_vm`**  \n  `ctl_table` 类型的静态数组，定义了 `vm.memfd_noexec` sysctl 条目，包括其名称、数据指针、访问权限、处理函数及取值范围（0 到 2）。\n\n## 3. 关键实现\n\n- **权限控制**：  \n  在写入 `memfd_noexec` 值时，调用 `ns_capable(ns->user_ns, CAP_SYS_ADMIN)` 检查当前任务是否在对应用户命名空间中拥有 `CAP_SYS_ADMIN` 能力，防止非特权用户修改安全策略。\n\n- **策略继承约束**：  \n  通过 `pidns_memfd_noexec_scope(ns->parent)` 获取父 PID 命名空间的策略值 `parent_scope`，并确保当前命名空间的策略值 `scope` 不小于父策略（即不能更宽松）。实际写入前使用 `max(READ_ONCE(ns->memfd_noexec_scope), parent_scope)` 保证该约束。\n\n- **原子读写**：  \n  使用 `READ_ONCE()` 和 `WRITE_ONCE()` 对 `ns->memfd_noexec_scope` 进行访问，确保在并发环境下内存访问的可见性和顺序性。\n\n- **sysctl 注册**：  \n  通过 `register_sysctl(\"vm\", pid_ns_ctl_table_vm)` 将控制项注册到 `/proc/sys/vm/memfd_noexec` 路径下，供用户空间通过标准 sysctl 接口访问。\n\n- **条件编译**：  \n  整个功能仅在 `CONFIG_SYSCTL`（启用 sysctl 支持）和 `CONFIG_MEMFD_CREATE`（启用 memfd_create 系统调用）同时配置时编译，否则 `register_pid_ns_sysctl_table_vm` 为空内联函数，避免代码膨胀。\n\n## 4. 依赖关系\n\n- **`<linux/pid_namespace.h>`**：  \n  提供 `struct pid_namespace` 定义及辅助函数如 `task_active_pid_ns()` 和 `pidns_memfd_noexec_scope()`。\n\n- **`CONFIG_SYSCTL`**：  \n  内核配置选项，启用 sysctl 框架支持，提供 `register_sysctl`、`proc_dointvec_minmax` 等接口。\n\n- **`CONFIG_MEMFD_CREATE`**：  \n  内核配置选项，启用 `memfd_create()` 系统调用及相关功能（如 `memfd_noexec_scope` 字段）。\n\n- **能力子系统（Capabilities）**：  \n  依赖 `ns_capable()` 进行命名空间感知的权限检查。\n\n## 5. 使用场景\n\n- **安全策略配置**：  \n  系统管理员或容器运行时可通过写入 `/proc/sys/vm/memfd_noexec` 设置当前 PID 命名空间中 `memfd` 文件的执行限制级别（0=允许执行，1=禁止执行但可覆盖，2=严格禁止执行），用于防御基于内存文件的代码注入攻击。\n\n- **容器隔离**：  \n  在容器化环境中，不同容器运行在独立的 PID 命名空间中。父命名空间（如宿主机）可设置较严格的 `memfd_noexec` 策略，子容器无法降低该策略级别，从而实现自上而下的安全策略强制。\n\n- **运行时动态调整**：  \n  允许在系统运行期间动态调整 `memfd` 执行策略，无需重启或重新加载内核模块，提升系统灵活性与安全性。",
      "similarity": 0.6221086382865906,
      "chunks": []
    }
  ]
}