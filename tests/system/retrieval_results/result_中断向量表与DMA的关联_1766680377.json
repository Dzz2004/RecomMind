{
  "query": "中断向量表与DMA的关联",
  "timestamp": "2025-12-26 00:32:57",
  "retrieved_files": [
    {
      "source_file": "kernel/dma/map_benchmark.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:13:45\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `dma\\map_benchmark.c`\n\n---\n\n# `dma/map_benchmark.c` 技术文档\n\n## 1. 文件概述\n\n`dma/map_benchmark.c` 是 Linux 内核中用于对 DMA（Direct Memory Access）映射和解映射操作进行性能基准测试的模块。该模块通过用户空间 ioctl 接口接收测试参数，创建多个内核线程并发执行 `dma_map_single()` 和 `dma_unmap_single()` 操作，统计其平均延迟和标准差，用于评估不同硬件平台或驱动实现下 DMA 映射的性能开销。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct map_benchmark_data`**  \n  封装测试上下文，包含：\n  - `bparam`：用户传入的测试参数（线程数、测试时长、DMA 方向、粒度等）\n  - `dev`：关联的设备结构体，用于 DMA 操作\n  - `debugfs`：用于调试的 debugfs 条目\n  - `dir`：转换后的 DMA 数据方向（`DMA_BIDIRECTIONAL` 等）\n  - 多个 `atomic64_t` 字段用于线程安全地累积映射/解映射耗时及其平方值，以及循环次数\n\n### 主要函数\n\n- **`map_benchmark_thread(void *data)`**  \n  内核线程主函数，循环执行以下操作：\n  - 分配指定大小的内存缓冲区（按页对齐）\n  - 若非 `DMA_FROM_DEVICE`，预填充缓冲区以模拟缓存污染\n  - 调用 `dma_map_single()` 并记录耗时\n  - 模拟 DMA 传输延迟（`ndelay`）\n  - 调用 `dma_unmap_single()` 并记录耗时\n  - 累加耗时（以 100 纳秒为单位）及其平方值，用于后续统计\n  - 定期调用 `cond_resched()` 避免阻塞调度\n\n- **`do_map_benchmark(struct map_benchmark_data *map)`**  \n  启动并管理多个测试线程：\n  - 根据参数创建指定数量的内核线程（可绑定到指定 NUMA 节点）\n  - 重置统计计数器\n  - 启动所有线程并休眠指定秒数\n  - 停止所有线程并收集结果\n  - 计算平均延迟和标准差（基于方差公式）\n\n- **`map_benchmark_ioctl(struct file *file, unsigned int cmd, unsigned long arg)`**  \n  用户空间 ioctl 接口处理函数：\n  - 验证输入参数合法性（线程数、时长、NUMA 节点、粒度等）\n  - 转换 DMA 方向枚举值\n  - 临时设置设备的 `dma_mask`（测试完成后恢复原值）\n  - 调用 `do_map_benchmark()` 执行测试\n  - 将结果拷贝回用户空间\n\n- **`__map_benchmark_probe(struct device *dev)`**  \n  设备探测函数（代码片段未完整），负责初始化 `map_benchmark_data` 结构并关联设备。\n\n## 3. 关键实现\n\n- **高精度时间测量**  \n  使用 `ktime_get()` 获取纳秒级时间戳，计算 `dma_map_single()` 和 `dma_unmap_single()` 的实际耗时。\n\n- **统计方法**  \n  为避免浮点运算，所有时间以 **100 纳秒** 为单位存储。通过累加时间和时间平方值，在测试结束后计算：\n  - 平均值：`sum / loops`\n  - 方差：`E[X²] - (E[X])²`\n  - 标准差：使用 `int_sqrt64()` 计算整数平方根\n\n- **缓存行为模拟**  \n  对于 `DMA_BIDIRECTIONAL` 或 `DMA_TO_DEVICE`，在映射前填充缓冲区（`memset(buf, 0x66, size)`），以触发缓存写回，更真实地反映非一致性设备的开销。\n\n- **DMA 掩码隔离**  \n  测试期间临时修改设备的 `dma_mask`，测试结束后恢复原始值，避免影响设备正常驱动行为。\n\n- **调度友好性**  \n  在密集循环中调用 `cond_resched()`，防止在非抢占内核中因线程数 ≥ CPU 数而导致系统挂死。\n\n- **NUMA 感知**  \n  支持将测试线程绑定到指定 NUMA 节点，用于评估 NUMA 架构下的 DMA 性能差异。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/dma-mapping.h>`：提供 `dma_map_single`/`dma_unmap_single` 等核心 DMA API\n  - `<linux/debugfs.h>`：用于创建调试接口（虽未在片段中完整体现）\n  - `<linux/kthread.h>`：内核线程管理\n  - `<linux/math64.h>`：64 位除法和平方根计算\n  - `<linux/map_benchmark.h>`：定义用户接口结构体 `map_benchmark` 和 ioctl 命令（如 `DMA_MAP_BENCHMARK`）\n  - 其他基础内核头文件（`slab.h`, `device.h`, `timekeeping.h` 等）\n\n- **内核子系统**：\n  - **DMA 子系统**：依赖底层架构（如 ARM64、x86）或总线（PCI、平台设备）提供的 DMA 映射实现\n  - **调度子系统**：依赖 `kthread` 和 `cond_resched()` 机制\n  - **内存管理**：使用 `alloc_pages_exact()` 分配连续物理内存\n\n## 5. 使用场景\n\n- **驱动开发与调优**：评估不同 DMA 映射策略（如一致性 vs 非一致性）的性能开销。\n- **平台性能分析**：比较不同 SoC 或服务器平台的 IOMMU 或 DMA 引擎效率。\n- **内核子系统验证**：测试 DMA 子系统在高并发场景下的稳定性与延迟表现。\n- **NUMA 性能研究**：分析跨 NUMA 节点 DMA 操作的额外延迟。\n- **回归测试**：在内核版本迭代中监控 DMA 映射性能是否退化。\n\n该模块通常通过用户空间工具（如专用 benchmark 程序）打开 debugfs 或字符设备节点，传入测试参数后触发 ioctl 执行基准测试，并读取返回的统计结果。",
      "similarity": 0.6107386946678162,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/dma/map_benchmark.c",
          "start_line": 34,
          "end_line": 196,
          "content": [
            "static int map_benchmark_thread(void *data)",
            "{",
            "\tvoid *buf;",
            "\tdma_addr_t dma_addr;",
            "\tstruct map_benchmark_data *map = data;",
            "\tint npages = map->bparam.granule;",
            "\tu64 size = npages * PAGE_SIZE;",
            "\tint ret = 0;",
            "",
            "\tbuf = alloc_pages_exact(size, GFP_KERNEL);",
            "\tif (!buf)",
            "\t\treturn -ENOMEM;",
            "",
            "\twhile (!kthread_should_stop())  {",
            "\t\tu64 map_100ns, unmap_100ns, map_sq, unmap_sq;",
            "\t\tktime_t map_stime, map_etime, unmap_stime, unmap_etime;",
            "\t\tktime_t map_delta, unmap_delta;",
            "",
            "\t\t/*",
            "\t\t * for a non-coherent device, if we don't stain them in the",
            "\t\t * cache, this will give an underestimate of the real-world",
            "\t\t * overhead of BIDIRECTIONAL or TO_DEVICE mappings;",
            "\t\t * 66 means evertything goes well! 66 is lucky.",
            "\t\t */",
            "\t\tif (map->dir != DMA_FROM_DEVICE)",
            "\t\t\tmemset(buf, 0x66, size);",
            "",
            "\t\tmap_stime = ktime_get();",
            "\t\tdma_addr = dma_map_single(map->dev, buf, size, map->dir);",
            "\t\tif (unlikely(dma_mapping_error(map->dev, dma_addr))) {",
            "\t\t\tpr_err(\"dma_map_single failed on %s\\n\",",
            "\t\t\t\tdev_name(map->dev));",
            "\t\t\tret = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tmap_etime = ktime_get();",
            "\t\tmap_delta = ktime_sub(map_etime, map_stime);",
            "",
            "\t\t/* Pretend DMA is transmitting */",
            "\t\tndelay(map->bparam.dma_trans_ns);",
            "",
            "\t\tunmap_stime = ktime_get();",
            "\t\tdma_unmap_single(map->dev, dma_addr, size, map->dir);",
            "\t\tunmap_etime = ktime_get();",
            "\t\tunmap_delta = ktime_sub(unmap_etime, unmap_stime);",
            "",
            "\t\t/* calculate sum and sum of squares */",
            "",
            "\t\tmap_100ns = div64_ul(map_delta,  100);",
            "\t\tunmap_100ns = div64_ul(unmap_delta, 100);",
            "\t\tmap_sq = map_100ns * map_100ns;",
            "\t\tunmap_sq = unmap_100ns * unmap_100ns;",
            "",
            "\t\tatomic64_add(map_100ns, &map->sum_map_100ns);",
            "\t\tatomic64_add(unmap_100ns, &map->sum_unmap_100ns);",
            "\t\tatomic64_add(map_sq, &map->sum_sq_map);",
            "\t\tatomic64_add(unmap_sq, &map->sum_sq_unmap);",
            "\t\tatomic64_inc(&map->loops);",
            "",
            "\t\t/*",
            "\t\t * We may test for a long time so periodically check whether",
            "\t\t * we need to schedule to avoid starving the others. Otherwise",
            "\t\t * we may hangup the kernel in a non-preemptible kernel when",
            "\t\t * the test kthreads number >= CPU number, the test kthreads",
            "\t\t * will run endless on every CPU since the thread resposible",
            "\t\t * for notifying the kthread stop (in do_map_benchmark())",
            "\t\t * could not be scheduled.",
            "\t\t *",
            "\t\t * Note this may degrade the test concurrency since the test",
            "\t\t * threads may need to share the CPU time with other load",
            "\t\t * in the system. So it's recommended to run this benchmark",
            "\t\t * on an idle system.",
            "\t\t */",
            "\t\tcond_resched();",
            "\t}",
            "",
            "out:",
            "\tfree_pages_exact(buf, size);",
            "\treturn ret;",
            "}",
            "static int do_map_benchmark(struct map_benchmark_data *map)",
            "{",
            "\tstruct task_struct **tsk;",
            "\tint threads = map->bparam.threads;",
            "\tint node = map->bparam.node;",
            "\tu64 loops;",
            "\tint ret = 0;",
            "\tint i;",
            "",
            "\ttsk = kmalloc_array(threads, sizeof(*tsk), GFP_KERNEL);",
            "\tif (!tsk)",
            "\t\treturn -ENOMEM;",
            "",
            "\tget_device(map->dev);",
            "",
            "\tfor (i = 0; i < threads; i++) {",
            "\t\ttsk[i] = kthread_create_on_node(map_benchmark_thread, map,",
            "\t\t\t\tmap->bparam.node, \"dma-map-benchmark/%d\", i);",
            "\t\tif (IS_ERR(tsk[i])) {",
            "\t\t\tpr_err(\"create dma_map thread failed\\n\");",
            "\t\t\tret = PTR_ERR(tsk[i]);",
            "\t\t\twhile (--i >= 0)",
            "\t\t\t\tkthread_stop(tsk[i]);",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tif (node != NUMA_NO_NODE)",
            "\t\t\tkthread_bind_mask(tsk[i], cpumask_of_node(node));",
            "\t}",
            "",
            "\t/* clear the old value in the previous benchmark */",
            "\tatomic64_set(&map->sum_map_100ns, 0);",
            "\tatomic64_set(&map->sum_unmap_100ns, 0);",
            "\tatomic64_set(&map->sum_sq_map, 0);",
            "\tatomic64_set(&map->sum_sq_unmap, 0);",
            "\tatomic64_set(&map->loops, 0);",
            "",
            "\tfor (i = 0; i < threads; i++) {",
            "\t\tget_task_struct(tsk[i]);",
            "\t\twake_up_process(tsk[i]);",
            "\t}",
            "",
            "\tmsleep_interruptible(map->bparam.seconds * 1000);",
            "",
            "\t/* wait for the completion of all started benchmark threads */",
            "\tfor (i = 0; i < threads; i++) {",
            "\t\tint kthread_ret = kthread_stop_put(tsk[i]);",
            "",
            "\t\tif (kthread_ret)",
            "\t\t\tret = kthread_ret;",
            "\t}",
            "",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tloops = atomic64_read(&map->loops);",
            "\tif (likely(loops > 0)) {",
            "\t\tu64 map_variance, unmap_variance;",
            "\t\tu64 sum_map = atomic64_read(&map->sum_map_100ns);",
            "\t\tu64 sum_unmap = atomic64_read(&map->sum_unmap_100ns);",
            "\t\tu64 sum_sq_map = atomic64_read(&map->sum_sq_map);",
            "\t\tu64 sum_sq_unmap = atomic64_read(&map->sum_sq_unmap);",
            "",
            "\t\t/* average latency */",
            "\t\tmap->bparam.avg_map_100ns = div64_u64(sum_map, loops);",
            "\t\tmap->bparam.avg_unmap_100ns = div64_u64(sum_unmap, loops);",
            "",
            "\t\t/* standard deviation of latency */",
            "\t\tmap_variance = div64_u64(sum_sq_map, loops) -",
            "\t\t\t\tmap->bparam.avg_map_100ns *",
            "\t\t\t\tmap->bparam.avg_map_100ns;",
            "\t\tunmap_variance = div64_u64(sum_sq_unmap, loops) -",
            "\t\t\t\tmap->bparam.avg_unmap_100ns *",
            "\t\t\t\tmap->bparam.avg_unmap_100ns;",
            "\t\tmap->bparam.map_stddev = int_sqrt64(map_variance);",
            "\t\tmap->bparam.unmap_stddev = int_sqrt64(unmap_variance);",
            "\t}",
            "",
            "out:",
            "\tput_device(map->dev);",
            "\tkfree(tsk);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "map_benchmark_thread, do_map_benchmark",
          "description": "map_benchmark_thread执行DMA映射/解映射操作并记录时间戳，do_map_benchmark创建多线程进行基准测试，计算平均延迟和标准差，支持NUMA节点绑定和超时中断",
          "similarity": 0.5721505284309387
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/dma/map_benchmark.c",
          "start_line": 1,
          "end_line": 33,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (C) 2020 HiSilicon Limited.",
            " */",
            "",
            "#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/device.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/map_benchmark.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/pci.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/slab.h>",
            "#include <linux/timekeeping.h>",
            "",
            "struct map_benchmark_data {",
            "\tstruct map_benchmark bparam;",
            "\tstruct device *dev;",
            "\tstruct dentry  *debugfs;",
            "\tenum dma_data_direction dir;",
            "\tatomic64_t sum_map_100ns;",
            "\tatomic64_t sum_unmap_100ns;",
            "\tatomic64_t sum_sq_map;",
            "\tatomic64_t sum_sq_unmap;",
            "\tatomic64_t loops;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义DMA映射基准测试数据结构，包含基准参数、设备指针、调试文件系统入口、数据传输方向及统计原子变量，用于跟踪DMA映射/解映射性能指标",
          "similarity": 0.5516926646232605
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/dma/map_benchmark.c",
          "start_line": 199,
          "end_line": 322,
          "content": [
            "static long map_benchmark_ioctl(struct file *file, unsigned int cmd,",
            "\t\tunsigned long arg)",
            "{",
            "\tstruct map_benchmark_data *map = file->private_data;",
            "\tvoid __user *argp = (void __user *)arg;",
            "\tu64 old_dma_mask;",
            "\tint ret;",
            "",
            "\tif (copy_from_user(&map->bparam, argp, sizeof(map->bparam)))",
            "\t\treturn -EFAULT;",
            "",
            "\tswitch (cmd) {",
            "\tcase DMA_MAP_BENCHMARK:",
            "\t\tif (map->bparam.threads == 0 ||",
            "\t\t    map->bparam.threads > DMA_MAP_MAX_THREADS) {",
            "\t\t\tpr_err(\"invalid thread number\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (map->bparam.seconds == 0 ||",
            "\t\t    map->bparam.seconds > DMA_MAP_MAX_SECONDS) {",
            "\t\t\tpr_err(\"invalid duration seconds\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (map->bparam.dma_trans_ns > DMA_MAP_MAX_TRANS_DELAY) {",
            "\t\t\tpr_err(\"invalid transmission delay\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (map->bparam.node != NUMA_NO_NODE &&",
            "\t\t    (map->bparam.node < 0 || map->bparam.node >= MAX_NUMNODES ||",
            "\t\t     !node_possible(map->bparam.node))) {",
            "\t\t\tpr_err(\"invalid numa node\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (map->bparam.granule < 1 || map->bparam.granule > 1024) {",
            "\t\t\tpr_err(\"invalid granule size\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tswitch (map->bparam.dma_dir) {",
            "\t\tcase DMA_MAP_BIDIRECTIONAL:",
            "\t\t\tmap->dir = DMA_BIDIRECTIONAL;",
            "\t\t\tbreak;",
            "\t\tcase DMA_MAP_FROM_DEVICE:",
            "\t\t\tmap->dir = DMA_FROM_DEVICE;",
            "\t\t\tbreak;",
            "\t\tcase DMA_MAP_TO_DEVICE:",
            "\t\t\tmap->dir = DMA_TO_DEVICE;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tpr_err(\"invalid DMA direction\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\told_dma_mask = dma_get_mask(map->dev);",
            "",
            "\t\tret = dma_set_mask(map->dev,",
            "\t\t\t\t   DMA_BIT_MASK(map->bparam.dma_bits));",
            "\t\tif (ret) {",
            "\t\t\tpr_err(\"failed to set dma_mask on device %s\\n\",",
            "\t\t\t\tdev_name(map->dev));",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tret = do_map_benchmark(map);",
            "",
            "\t\t/*",
            "\t\t * restore the original dma_mask as many devices' dma_mask are",
            "\t\t * set by architectures, acpi, busses. When we bind them back",
            "\t\t * to their original drivers, those drivers shouldn't see",
            "\t\t * dma_mask changed by benchmark",
            "\t\t */",
            "\t\tdma_set_mask(map->dev, old_dma_mask);",
            "",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (copy_to_user(argp, &map->bparam, sizeof(map->bparam)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn ret;",
            "}",
            "static void map_benchmark_remove_debugfs(void *data)",
            "{",
            "\tstruct map_benchmark_data *map = (struct map_benchmark_data *)data;",
            "",
            "\tdebugfs_remove(map->debugfs);",
            "}",
            "static int __map_benchmark_probe(struct device *dev)",
            "{",
            "\tstruct dentry *entry;",
            "\tstruct map_benchmark_data *map;",
            "\tint ret;",
            "",
            "\tmap = devm_kzalloc(dev, sizeof(*map), GFP_KERNEL);",
            "\tif (!map)",
            "\t\treturn -ENOMEM;",
            "\tmap->dev = dev;",
            "",
            "\tret = devm_add_action(dev, map_benchmark_remove_debugfs, map);",
            "\tif (ret) {",
            "\t\tpr_err(\"Can't add debugfs remove action\\n\");",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * we only permit a device bound with this driver, 2nd probe",
            "\t * will fail",
            "\t */",
            "\tentry = debugfs_create_file(\"dma_map_benchmark\", 0600, NULL, map,",
            "\t\t\t&map_benchmark_fops);",
            "\tif (IS_ERR(entry))",
            "\t\treturn PTR_ERR(entry);",
            "\tmap->debugfs = entry;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "map_benchmark_ioctl, map_benchmark_remove_debugfs, __map_benchmark_probe",
          "description": "map_benchmark_ioctl通过ioctl接口配置并触发DMA基准测试，map_benchmark_remove_debugfs清理调试文件系统条目，__map_benchmark_probe初始化设备并注册调试文件",
          "similarity": 0.50424724817276
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/dma/map_benchmark.c",
          "start_line": 331,
          "end_line": 360,
          "content": [
            "static int map_benchmark_platform_probe(struct platform_device *pdev)",
            "{",
            "\treturn __map_benchmark_probe(&pdev->dev);",
            "}",
            "static int",
            "map_benchmark_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
            "{",
            "\treturn __map_benchmark_probe(&pdev->dev);",
            "}",
            "static int __init map_benchmark_init(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = pci_register_driver(&map_benchmark_pci_driver);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = platform_driver_register(&map_benchmark_platform_driver);",
            "\tif (ret) {",
            "\t\tpci_unregister_driver(&map_benchmark_pci_driver);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void __exit map_benchmark_cleanup(void)",
            "{",
            "\tplatform_driver_unregister(&map_benchmark_platform_driver);",
            "\tpci_unregister_driver(&map_benchmark_pci_driver);",
            "}"
          ],
          "function_name": "map_benchmark_platform_probe, map_benchmark_pci_probe, map_benchmark_init, map_benchmark_cleanup",
          "description": "map_benchmark_platform_probe和map_benchmark_pci_probe作为平台及PCI设备的探针函数，map_benchmark_init注册驱动程序，map_benchmark_cleanup卸载驱动程序并释放资源",
          "similarity": 0.38555610179901123
        }
      ]
    },
    {
      "source_file": "kernel/dma/remap.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:16:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `dma\\remap.c`\n\n---\n\n# `dma/remap.c` 技术文档\n\n## 1. 文件概述\n\n`dma/remap.c` 是 Linux 内核中用于 DMA（Direct Memory Access）一致性内存管理的辅助实现文件。该文件提供了一组通用函数，用于将物理页面（`struct page`）重新映射到内核虚拟地址空间中，并标记为 DMA 一致性映射区域（`VM_DMA_COHERENT`）。这些函数主要用于支持架构无关的 DMA 映射操作，特别是在需要将非连续物理页或连续物理内存块映射为连续虚拟地址的场景中。\n\n## 2. 核心功能\n\n### 主要函数：\n\n- **`dma_common_find_pages(void *cpu_addr)`**  \n  根据给定的内核虚拟地址 `cpu_addr`，查找其对应的 `struct page` 数组。该地址必须是由 `dma_common_*_remap` 系列函数创建的、标记为 `VM_DMA_COHERENT` 的 vmalloc 区域。\n\n- **`dma_common_pages_remap(struct page **pages, size_t size, pgprot_t prot, const void *caller)`**  \n  将一组非连续的物理页面（由 `pages` 数组指定）重新映射为一个连续的内核虚拟地址区域，并标记为 `VM_DMA_COHERENT`。该函数不可在原子上下文（如中断处理程序）中调用。\n\n- **`dma_common_contiguous_remap(struct page *page, size_t size, pgprot_t prot, const void *caller)`**  \n  将一段物理上连续的内存区域（起始于 `page`，长度为 `size`）重新映射为连续的内核虚拟地址，并标记为 `VM_DMA_COHERENT`。内部会临时分配一个 `struct page *` 数组来描述每一页。\n\n- **`dma_common_free_remap(void *cpu_addr, size_t size)`**  \n  释放由上述 `remap` 函数创建的虚拟映射区域。会验证该区域是否为有效的 `VM_DMA_COHERENT` 类型，若无效则触发警告。\n\n### 数据结构：\n- 无显式定义新数据结构，但依赖于内核已有的：\n  - `struct page`\n  - `struct vm_struct`\n  - `pgprot_t`\n\n## 3. 关键实现\n\n- **VM 区域标识**：所有通过 `dma_common_*_remap` 创建的映射区域均使用 `VM_DMA_COHERENT` 标志，以便后续可通过 `find_vm_area()` 识别其为 DMA 一致性映射区域。\n  \n- **页面数组管理**：\n  - `dma_common_pages_remap` 直接使用传入的 `pages` 数组，并在成功 `vmap` 后将其保存到 `vm_struct->pages` 字段中，供 `dma_common_find_pages` 查询。\n  - `dma_common_contiguous_remap` 针对连续物理内存，动态构建 `pages` 数组（使用 `kvmalloc_array`），调用 `vmap` 后立即释放该临时数组，但 `vmap` 内部会复制页面指针。\n\n- **内存分配与映射**：\n  - 使用 `vmap()` 将物理页面映射到 vmalloc 区域，确保返回的虚拟地址在内核空间连续。\n  - 使用 `kvmalloc_array`/`kvfree` 进行临时内存分配，兼顾大内存分配的可靠性（可回退到 vmalloc）。\n\n- **错误处理与调试**：\n  - `dma_common_free_remap` 中包含 `WARN(1, ...)`，用于检测非法释放操作，提升调试能力。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/dma-map-ops.h>`：提供 DMA 映射操作相关的类型和接口。\n  - `<linux/slab.h>`：提供 `kvmalloc_array`/`kvfree` 等内存分配接口。\n  - `<linux/vmalloc.h>`：提供 `vmap`、`vunmap`、`find_vm_area` 等 vmalloc 区域管理函数。\n\n- **内核子系统依赖**：\n  - **VMALLOC 子系统**：依赖 `vmap`/`vunmap` 实现虚拟地址映射。\n  - **内存管理子系统（MM）**：依赖 `struct page` 和页面操作函数（如 `nth_page`）。\n  - **DMA 子系统**：作为 `dma_map_ops` 的底层支持，被架构特定的 DMA 实现（如 ARM、ARM64）调用。\n\n## 5. 使用场景\n\n- **DMA 一致性内存分配**：当设备驱动需要分配大块 DMA 一致性内存，且底层无法直接提供连续虚拟地址时，可通过此模块将物理页重新映射为连续虚拟地址。\n  \n- **IOMMU 或非一致性缓存架构支持**：在缓存不一致的系统（如某些 ARM 平台）上，为保证 CPU 与设备对内存视图一致，需使用特殊页表属性（`pgprot_t`）进行映射，本模块提供通用封装。\n\n- **通用 DMA 映射框架后端**：作为 `dma_map_ops` 中 `alloc`/`free` 等操作的辅助实现，被 `dma-direct.c`、`arm_dma_alloc.c` 等架构相关代码调用。\n\n- **调试与验证**：通过 `VM_DMA_COHERENT` 标志和 `WARN` 机制，帮助检测非法的 DMA 内存释放操作，提升系统稳定性。",
      "similarity": 0.5684459209442139,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/dma/remap.c",
          "start_line": 60,
          "end_line": 70,
          "content": [
            "void dma_common_free_remap(void *cpu_addr, size_t size)",
            "{",
            "\tstruct vm_struct *area = find_vm_area(cpu_addr);",
            "",
            "\tif (!area || area->flags != VM_DMA_COHERENT) {",
            "\t\tWARN(1, \"trying to free invalid coherent area: %p\\n\", cpu_addr);",
            "\t\treturn;",
            "\t}",
            "",
            "\tvunmap(cpu_addr);",
            "}"
          ],
          "function_name": "dma_common_free_remap",
          "description": "实现dma_common_free_remap函数，验证虚拟地址所属的vm_area结构体标志后，调用vunmap释放对应DMA一致性区域的映射",
          "similarity": 0.5136096477508545
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/dma/remap.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (c) 2014 The Linux Foundation",
            " */",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "",
            "struct page **dma_common_find_pages(void *cpu_addr)",
            "{",
            "\tstruct vm_struct *area = find_vm_area(cpu_addr);",
            "",
            "\tif (!area || area->flags != VM_DMA_COHERENT)",
            "\t\treturn NULL;",
            "\treturn area->pages;",
            "}",
            "",
            "/*",
            " * Remaps an array of PAGE_SIZE pages into another vm_area.",
            " * Cannot be used in non-sleeping contexts",
            " */",
            "void *dma_common_pages_remap(struct page **pages, size_t size,",
            "\t\t\t pgprot_t prot, const void *caller)",
            "{",
            "\tvoid *vaddr;",
            "",
            "\tvaddr = vmap(pages, PAGE_ALIGN(size) >> PAGE_SHIFT,",
            "\t\t     VM_DMA_COHERENT, prot);",
            "\tif (vaddr)",
            "\t\tfind_vm_area(vaddr)->pages = pages;",
            "\treturn vaddr;",
            "}",
            "",
            "/*",
            " * Remaps an allocated contiguous region into another vm_area.",
            " * Cannot be used in non-sleeping contexts",
            " */",
            "void *dma_common_contiguous_remap(struct page *page, size_t size,",
            "\t\t\tpgprot_t prot, const void *caller)",
            "{",
            "\tint count = PAGE_ALIGN(size) >> PAGE_SHIFT;",
            "\tstruct page **pages;",
            "\tvoid *vaddr;",
            "\tint i;",
            "",
            "\tpages = kvmalloc_array(count, sizeof(struct page *), GFP_KERNEL);",
            "\tif (!pages)",
            "\t\treturn NULL;",
            "\tfor (i = 0; i < count; i++)",
            "\t\tpages[i] = nth_page(page, i);",
            "\tvaddr = vmap(pages, count, VM_DMA_COHERENT, prot);",
            "\tkvfree(pages);",
            "",
            "\treturn vaddr;",
            "}",
            "",
            "/*",
            " * Unmaps a range previously mapped by dma_common_*_remap",
            " */"
          ],
          "function_name": null,
          "description": "定义dma_common_find_pages函数，通过查找VM_DMA_COHERENT标记的vm_area结构体，返回对应页面数组指针",
          "similarity": 0.5086549520492554
        }
      ]
    },
    {
      "source_file": "kernel/dma/dummy.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:13:04\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `dma\\dummy.c`\n\n---\n\n# `dma/dummy.c` 技术文档\n\n## 1. 文件概述\n\n`dma/dummy.c` 实现了一组“虚拟”或“占位符”式的 DMA（Direct Memory Access）操作函数集合（`dma_map_ops`），这些函数在被调用时总是返回失败状态。该文件用于在系统不支持 DMA 或尚未初始化有效 DMA 操作时，提供一个安全的默认实现，防止内核因空指针调用或未定义行为而崩溃。\n\n## 2. 核心功能\n\n### 主要函数\n- `dma_dummy_mmap`：尝试将 DMA 映射区域映射到用户空间，始终返回 `-ENXIO`（无此类设备或地址）。\n- `dma_dummy_map_page`：尝试映射单个页面用于 DMA 传输，始终返回 `DMA_MAPPING_ERROR`。\n- `dma_dummy_map_sg`：尝试映射 scatterlist（分散/聚集列表）用于 DMA 传输，始终返回 `-EINVAL`（无效参数）。\n- `dma_dummy_supported`：检查设备是否支持指定的 DMA 地址掩码，始终返回 `0`（表示不支持）。\n\n### 数据结构\n- `dma_dummy_ops`：类型为 `const struct dma_map_ops` 的全局常量结构体，包含上述所有 dummy 函数的指针，作为无效 DMA 操作的默认实现。\n\n## 3. 关键实现\n\n- 所有 DMA 操作函数均不执行任何实际内存映射或硬件操作，而是直接返回代表“失败”或“不支持”的错误码：\n  - `dma_dummy_mmap` 返回 `-ENXIO`，表明设备或资源不存在。\n  - `dma_dummy_map_page` 返回 `DMA_MAPPING_ERROR`（通常定义为 `~(dma_addr_t)0`），这是内核中表示 DMA 映射失败的标准值。\n  - `dma_dummy_map_sg` 返回 `-EINVAL`，表示传入的 scatterlist 或参数无效。\n  - `dma_dummy_supported` 返回 `0`，明确表示该设备不支持任何 DMA 地址掩码。\n- 该实现确保在 DMA 子系统未正确初始化或平台不支持 DMA 时，调用者能安全地检测到失败并采取相应措施（如回退到非 DMA 路径或报错）。\n\n## 4. 依赖关系\n\n- 依赖头文件 `<linux/dma-map-ops.h>`，该头文件定义了 `struct dma_map_ops` 及相关类型（如 `dma_addr_t`、`enum dma_data_direction` 等）。\n- 该文件通常被架构特定的 DMA 初始化代码或设备驱动框架引用，作为默认或后备的 `dma_map_ops` 实现。\n- 不依赖其他内核模块的具体实现，仅使用标准内核数据结构和错误码。\n\n## 5. 使用场景\n\n- 在不支持 DMA 的平台（如某些纯软件模拟环境或早期启动阶段）中，作为默认的 DMA 操作集。\n- 在设备驱动尚未绑定有效 DMA 引擎时，防止对空或未初始化的 `dma_map_ops` 进行调用。\n- 用于调试或测试，强制使 DMA 操作失败以验证驱动的错误处理路径。\n- 在某些虚拟化或容器环境中，当物理 DMA 不可用时提供安全的占位实现。",
      "similarity": 0.566744863986969,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/dma/dummy.c",
          "start_line": 7,
          "end_line": 28,
          "content": [
            "static int dma_dummy_mmap(struct device *dev, struct vm_area_struct *vma,",
            "\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,",
            "\t\tunsigned long attrs)",
            "{",
            "\treturn -ENXIO;",
            "}",
            "static dma_addr_t dma_dummy_map_page(struct device *dev, struct page *page,",
            "\t\tunsigned long offset, size_t size, enum dma_data_direction dir,",
            "\t\tunsigned long attrs)",
            "{",
            "\treturn DMA_MAPPING_ERROR;",
            "}",
            "static int dma_dummy_map_sg(struct device *dev, struct scatterlist *sgl,",
            "\t\tint nelems, enum dma_data_direction dir,",
            "\t\tunsigned long attrs)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "static int dma_dummy_supported(struct device *hwdev, u64 mask)",
            "{",
            "\treturn 0;",
            "}"
          ],
          "function_name": "dma_dummy_mmap, dma_dummy_map_page, dma_dummy_map_sg, dma_dummy_supported",
          "description": "实现始终返回错误的DMA操作函数，用于处理不支持DMA的设备的内存映射和地址转换请求",
          "similarity": 0.5544783473014832
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/dma/dummy.c",
          "start_line": 1,
          "end_line": 6,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Dummy DMA ops that always fail.",
            " */",
            "#include <linux/dma-map-ops.h>",
            ""
          ],
          "function_name": null,
          "description": "定义一组始终失败的DMA操作函数，用于在设备不支持DMA时提供默认错误行为",
          "similarity": 0.5463125705718994
        }
      ]
    }
  ]
}