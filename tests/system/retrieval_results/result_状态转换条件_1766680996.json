{
  "query": "状态转换条件",
  "timestamp": "2025-12-26 00:43:16",
  "retrieved_files": [
    {
      "source_file": "kernel/livepatch/transition.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:34:51\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `livepatch\\transition.c`\n\n---\n\n# livepatch/transition.c 技术文档\n\n## 1. 文件概述\n\n`livepatch/transition.c` 是 Linux 内核实时补丁（Kernel Live Patching）子系统的核心组件之一，负责管理补丁状态转换过程。该文件实现了从旧代码到新补丁代码（或反向）的安全过渡机制，确保所有正在运行的任务（包括内核线程、用户态进程和 idle 线程）都能安全地切换到目标补丁状态，避免在函数栈中仍存在待替换函数时进行切换，从而防止系统崩溃或行为异常。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `klp_transition_patch`：指向当前正在进行状态转换的补丁对象。\n- `klp_target_state`：目标补丁状态（`KLP_PATCHED` 或 `KLP_UNPATCHED`），初始为 `KLP_UNDEFINED`。\n- `klp_signals_cnt`：用于统计信号处理相关计数（当前未在代码片段中完整使用）。\n- `klp_stack_entries`：每 CPU 栈追踪缓冲区，用于保存任务调用栈。\n\n### 主要函数\n- `klp_transition_work_fn()`：延迟工作队列回调，用于重试未能完成转换的“滞留”任务。\n- `klp_synchronize_transition()`：强制在所有 CPU 上执行调度同步，确保 RCU 不可见区域也能完成同步。\n- `klp_complete_transition()`：完成整个补丁状态转换，清理数据结构并调用回调。\n- `klp_cancel_transition()`：在转换开始前取消补丁操作。\n- `klp_update_patch_state()`：更新指定任务的补丁状态。\n- `klp_check_stack_func()`：检查给定函数是否出现在栈追踪中。\n- `klp_check_stack()`：检查任务栈中是否存在待替换/待移除的函数（代码片段中被截断）。\n\n### 静态键与调度集成\n- 在支持 `CONFIG_PREEMPT_DYNAMIC` 的系统上，通过 `sched_dynamic_klp_enable/disable()` 启用/禁用 cond_resched 中的栈检查。\n- 否则使用静态键 `klp_sched_try_switch_key` 控制是否在 `cond_resched()` 中进行补丁栈检查，以帮助 CPU 密集型内核线程完成补丁切换。\n\n## 3. 关键实现\n\n### 补丁状态转换流程\n1. **初始化阶段**：设置 `klp_transition_patch` 和 `klp_target_state`。\n2. **任务状态更新**：通过 `TIF_PATCH_PENDING` 标志标记需要更新状态的任务。\n3. **栈安全检查**：使用 `stack_trace_save_tsk_reliable()` 获取可靠栈追踪，检查是否存在待替换函数。\n4. **同步机制**：\n   - 使用 `klp_synchronize_transition()` 调用 `schedule_on_each_cpu(klp_sync)`，强制所有 CPU（包括 idle 和用户态）参与同步。\n   - 此机制绕过标准 RCU，适用于 RCU 不活跃的上下文（如 `user_exit()` 前）。\n5. **完成清理**：\n   - 清除所有任务的 `patch_state` 为 `KLP_UNDEFINED`。\n   - 调用对象级的 `post_patch` 或 `post_unpatch` 回调。\n   - 重置全局状态变量。\n\n### 栈检查逻辑\n- **打补丁时（KLP_PATCHED）**：检查栈中是否包含**旧函数**（原始函数或上一个补丁版本的函数）。\n- **卸补丁时（KLP_UNPATCHED）**：检查栈中是否包含**新函数**（当前补丁中的函数）。\n- 若发现相关函数在栈中，则返回 `-EAGAIN`，推迟该任务的状态切换。\n\n### 内存屏障与并发控制\n- `test_and_clear_tsk_thread_flag()` 不仅清除 `TIF_PATCH_PENDING`，还充当读屏障（`smp_rmb`），确保：\n  1. `klp_target_state` 的读取顺序正确。\n  2. 后续 `klp_ftrace_handler()` 能看到一致的 `func->transition` 状态。\n\n### 滞留任务处理\n- 通过 `DECLARE_DELAYED_WORK(klp_transition_work, ...)` 定期重试未能完成转换的任务，提高转换成功率。\n\n## 4. 依赖关系\n\n- **内部依赖**：\n  - `core.h`：提供 `klp_mutex`、`klp_for_each_object/func` 等核心宏和函数。\n  - `patch.h`：定义 `klp_func`、`klp_object`、`klp_patch` 等数据结构及操作函数（如 `klp_unpatch_objects`）。\n  - `transition.h`：声明本文件导出的接口（如 `klp_cancel_transition`）。\n- **内核子系统**：\n  - **RCU**：用于常规同步，但在 RCU 不活跃区域使用自定义同步。\n  - **调度器**：通过 `cond_resched()` 集成补丁检查，依赖 `CONFIG_PREEMPT_DYNAMIC` 或静态键。\n  - **栈追踪**：使用 `stack_trace_save_tsk_reliable()` 获取可靠调用栈。\n  - **CPU 热插拔**：通过 `for_each_possible_cpu` 处理所有可能的 CPU（包括离线 CPU 的 idle 任务）。\n\n## 5. 使用场景\n\n- **应用实时补丁**：当管理员通过 sysfs 启用一个 livepatch 模块时，内核调用此文件中的函数将所有任务从旧代码切换到新补丁代码。\n- **卸载实时补丁**：当禁用补丁时，安全地将所有任务切换回旧函数，并清理补丁数据结构。\n- **处理滞留任务**：对于因长时间运行或处于不可中断状态而未能及时切换的任务，通过延迟工作队列周期性重试。\n- **支持特殊上下文**：确保在 RCU 不活跃的上下文（如系统调用入口/出口、idle 循环）中也能安全完成补丁切换。\n- **错误恢复**：在补丁初始化后、实际切换前发生错误时，调用 `klp_cancel_transition()` 安全回滚。",
      "similarity": 0.4896705150604248,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 214,
          "end_line": 352,
          "content": [
            "static int klp_check_stack_func(struct klp_func *func, unsigned long *entries,",
            "\t\t\t\tunsigned int nr_entries)",
            "{",
            "\tunsigned long func_addr, func_size, address;",
            "\tstruct klp_ops *ops;",
            "\tint i;",
            "",
            "\tif (klp_target_state == KLP_UNPATCHED) {",
            "\t\t /*",
            "\t\t  * Check for the to-be-unpatched function",
            "\t\t  * (the func itself).",
            "\t\t  */",
            "\t\tfunc_addr = (unsigned long)func->new_func;",
            "\t\tfunc_size = func->new_size;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Check for the to-be-patched function",
            "\t\t * (the previous func).",
            "\t\t */",
            "\t\tops = klp_find_ops(func->old_func);",
            "",
            "\t\tif (list_is_singular(&ops->func_stack)) {",
            "\t\t\t/* original function */",
            "\t\t\tfunc_addr = (unsigned long)func->old_func;",
            "\t\t\tfunc_size = func->old_size;",
            "\t\t} else {",
            "\t\t\t/* previously patched function */",
            "\t\t\tstruct klp_func *prev;",
            "",
            "\t\t\tprev = list_next_entry(func, stack_node);",
            "\t\t\tfunc_addr = (unsigned long)prev->new_func;",
            "\t\t\tfunc_size = prev->new_size;",
            "\t\t}",
            "\t}",
            "",
            "\tfor (i = 0; i < nr_entries; i++) {",
            "\t\taddress = entries[i];",
            "",
            "\t\tif (address >= func_addr && address < func_addr + func_size)",
            "\t\t\treturn -EAGAIN;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int klp_check_stack(struct task_struct *task, const char **oldname)",
            "{",
            "\tunsigned long *entries = this_cpu_ptr(klp_stack_entries);",
            "\tstruct klp_object *obj;",
            "\tstruct klp_func *func;",
            "\tint ret, nr_entries;",
            "",
            "\t/* Protect 'klp_stack_entries' */",
            "\tlockdep_assert_preemption_disabled();",
            "",
            "\tret = stack_trace_save_tsk_reliable(task, entries, MAX_STACK_ENTRIES);",
            "\tif (ret < 0)",
            "\t\treturn -EINVAL;",
            "\tnr_entries = ret;",
            "",
            "\tklp_for_each_object(klp_transition_patch, obj) {",
            "\t\tif (!obj->patched)",
            "\t\t\tcontinue;",
            "\t\tklp_for_each_func(obj, func) {",
            "\t\t\tret = klp_check_stack_func(func, entries, nr_entries);",
            "\t\t\tif (ret) {",
            "\t\t\t\t*oldname = func->old_name;",
            "\t\t\t\treturn -EADDRINUSE;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int klp_check_and_switch_task(struct task_struct *task, void *arg)",
            "{",
            "\tint ret;",
            "",
            "\tif (task_curr(task) && task != current)",
            "\t\treturn -EBUSY;",
            "",
            "\tret = klp_check_stack(task, arg);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\ttask->patch_state = klp_target_state;",
            "\treturn 0;",
            "}",
            "static bool klp_try_switch_task(struct task_struct *task)",
            "{",
            "\tconst char *old_name;",
            "\tint ret;",
            "",
            "\t/* check if this task has already switched over */",
            "\tif (task->patch_state == klp_target_state)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * For arches which don't have reliable stack traces, we have to rely",
            "\t * on other methods (e.g., switching tasks at kernel exit).",
            "\t */",
            "\tif (!klp_have_reliable_stack())",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Now try to check the stack for any to-be-patched or to-be-unpatched",
            "\t * functions.  If all goes well, switch the task to the target patch",
            "\t * state.",
            "\t */",
            "\tif (task == current)",
            "\t\tret = klp_check_and_switch_task(current, &old_name);",
            "\telse",
            "\t\tret = task_call_func(task, klp_check_and_switch_task, &old_name);",
            "",
            "\tswitch (ret) {",
            "\tcase 0:\t\t/* success */",
            "\t\tbreak;",
            "",
            "\tcase -EBUSY:\t/* klp_check_and_switch_task() */",
            "\t\tpr_debug(\"%s: %s:%d is running\\n\",",
            "\t\t\t __func__, task->comm, task->pid);",
            "\t\tbreak;",
            "\tcase -EINVAL:\t/* klp_check_and_switch_task() */",
            "\t\tpr_debug(\"%s: %s:%d has an unreliable stack\\n\",",
            "\t\t\t __func__, task->comm, task->pid);",
            "\t\tbreak;",
            "\tcase -EADDRINUSE: /* klp_check_and_switch_task() */",
            "\t\tpr_debug(\"%s: %s:%d is sleeping on function %s\\n\",",
            "\t\t\t __func__, task->comm, task->pid, old_name);",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\tpr_debug(\"%s: Unknown error code (%d) when trying to switch %s:%d\\n\",",
            "\t\t\t __func__, ret, task->comm, task->pid);",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn !ret;",
            "}"
          ],
          "function_name": "klp_check_stack_func, klp_check_stack, klp_check_and_switch_task, klp_try_switch_task",
          "description": "提供堆栈检查与任务状态切换机制，验证当前线程堆栈中是否包含待修改函数地址，确保安全切换到目标补丁状态",
          "similarity": 0.5776989459991455
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 366,
          "end_line": 509,
          "content": [
            "void __klp_sched_try_switch(void)",
            "{",
            "\tif (likely(!klp_patch_pending(current)))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * This function is called from cond_resched() which is called in many",
            "\t * places throughout the kernel.  Using the klp_mutex here might",
            "\t * deadlock.",
            "\t *",
            "\t * Instead, disable preemption to prevent racing with other callers of",
            "\t * klp_try_switch_task().  Thanks to task_call_func() they won't be",
            "\t * able to switch this task while it's running.",
            "\t */",
            "\tpreempt_disable();",
            "",
            "\t/*",
            "\t * Make sure current didn't get patched between the above check and",
            "\t * preempt_disable().",
            "\t */",
            "\tif (unlikely(!klp_patch_pending(current)))",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Enforce the order of the TIF_PATCH_PENDING read above and the",
            "\t * klp_target_state read in klp_try_switch_task().  The corresponding",
            "\t * write barriers are in klp_init_transition() and",
            "\t * klp_reverse_transition().",
            "\t */",
            "\tsmp_rmb();",
            "",
            "\tklp_try_switch_task(current);",
            "",
            "out:",
            "\tpreempt_enable();",
            "}",
            "static void klp_send_signals(void)",
            "{",
            "\tstruct task_struct *g, *task;",
            "",
            "\tif (klp_signals_cnt == SIGNALS_TIMEOUT)",
            "\t\tpr_notice(\"signaling remaining tasks\\n\");",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task) {",
            "\t\tif (!klp_patch_pending(task))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * There is a small race here. We could see TIF_PATCH_PENDING",
            "\t\t * set and decide to wake up a kthread or send a fake signal.",
            "\t\t * Meanwhile the task could migrate itself and the action",
            "\t\t * would be meaningless. It is not serious though.",
            "\t\t */",
            "\t\tif (task->flags & PF_KTHREAD) {",
            "\t\t\t/*",
            "\t\t\t * Wake up a kthread which sleeps interruptedly and",
            "\t\t\t * still has not been migrated.",
            "\t\t\t */",
            "\t\t\twake_up_state(task, TASK_INTERRUPTIBLE);",
            "\t\t} else {",
            "\t\t\t/*",
            "\t\t\t * Send fake signal to all non-kthread tasks which are",
            "\t\t\t * still not migrated.",
            "\t\t\t */",
            "\t\t\tset_notify_signal(task);",
            "\t\t}",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "}",
            "void klp_try_complete_transition(void)",
            "{",
            "\tunsigned int cpu;",
            "\tstruct task_struct *g, *task;",
            "\tstruct klp_patch *patch;",
            "\tbool complete = true;",
            "",
            "\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);",
            "",
            "\t/*",
            "\t * Try to switch the tasks to the target patch state by walking their",
            "\t * stacks and looking for any to-be-patched or to-be-unpatched",
            "\t * functions.  If such functions are found on a stack, or if the stack",
            "\t * is deemed unreliable, the task can't be switched yet.",
            "\t *",
            "\t * Usually this will transition most (or all) of the tasks on a system",
            "\t * unless the patch includes changes to a very common function.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task)",
            "\t\tif (!klp_try_switch_task(task))",
            "\t\t\tcomplete = false;",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\t/*",
            "\t * Ditto for the idle \"swapper\" tasks.",
            "\t */",
            "\tcpus_read_lock();",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\ttask = idle_task(cpu);",
            "\t\tif (cpu_online(cpu)) {",
            "\t\t\tif (!klp_try_switch_task(task)) {",
            "\t\t\t\tcomplete = false;",
            "\t\t\t\t/* Make idle task go through the main loop. */",
            "\t\t\t\twake_up_if_idle(cpu);",
            "\t\t\t}",
            "\t\t} else if (task->patch_state != klp_target_state) {",
            "\t\t\t/* offline idle tasks can be switched immediately */",
            "\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\t\t\ttask->patch_state = klp_target_state;",
            "\t\t}",
            "\t}",
            "\tcpus_read_unlock();",
            "",
            "\tif (!complete) {",
            "\t\tif (klp_signals_cnt && !(klp_signals_cnt % SIGNALS_TIMEOUT))",
            "\t\t\tklp_send_signals();",
            "\t\tklp_signals_cnt++;",
            "",
            "\t\t/*",
            "\t\t * Some tasks weren't able to be switched over.  Try again",
            "\t\t * later and/or wait for other methods like kernel exit",
            "\t\t * switching.",
            "\t\t */",
            "\t\tschedule_delayed_work(&klp_transition_work,",
            "\t\t\t\t      round_jiffies_relative(HZ));",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* Done!  Now cleanup the data structures. */",
            "\tklp_cond_resched_disable();",
            "\tpatch = klp_transition_patch;",
            "\tklp_complete_transition();",
            "",
            "\t/*",
            "\t * It would make more sense to free the unused patches in",
            "\t * klp_complete_transition() but it is called also",
            "\t * from klp_cancel_transition().",
            "\t */",
            "\tif (!patch->enabled)",
            "\t\tklp_free_patch_async(patch);",
            "\telse if (patch->replace)",
            "\t\tklp_free_replaced_patches_async(patch);",
            "}"
          ],
          "function_name": "__klp_sched_try_switch, klp_send_signals, klp_try_complete_transition",
          "description": "调度器层面的过渡辅助函数，通过禁止抢占防止竞态条件，并向未迁移任务发送信号触发上下文切换以完成补丁应用",
          "similarity": 0.550653874874115
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 530,
          "end_line": 634,
          "content": [
            "void klp_start_transition(void)",
            "{",
            "\tstruct task_struct *g, *task;",
            "\tunsigned int cpu;",
            "",
            "\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);",
            "",
            "\tpr_notice(\"'%s': starting %s transition\\n\",",
            "\t\t  klp_transition_patch->mod->name,",
            "\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");",
            "",
            "\t/*",
            "\t * Mark all normal tasks as needing a patch state update.  They'll",
            "\t * switch either in klp_try_complete_transition() or as they exit the",
            "\t * kernel.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task)",
            "\t\tif (task->patch_state != klp_target_state)",
            "\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\t/*",
            "\t * Mark all idle tasks as needing a patch state update.  They'll switch",
            "\t * either in klp_try_complete_transition() or at the idle loop switch",
            "\t * point.",
            "\t */",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\ttask = idle_task(cpu);",
            "\t\tif (task->patch_state != klp_target_state)",
            "\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\t}",
            "",
            "\tklp_cond_resched_enable();",
            "",
            "\tklp_signals_cnt = 0;",
            "}",
            "void klp_init_transition(struct klp_patch *patch, int state)",
            "{",
            "\tstruct task_struct *g, *task;",
            "\tunsigned int cpu;",
            "\tstruct klp_object *obj;",
            "\tstruct klp_func *func;",
            "\tint initial_state = !state;",
            "",
            "\tWARN_ON_ONCE(klp_target_state != KLP_UNDEFINED);",
            "",
            "\tklp_transition_patch = patch;",
            "",
            "\t/*",
            "\t * Set the global target patch state which tasks will switch to.  This",
            "\t * has no effect until the TIF_PATCH_PENDING flags get set later.",
            "\t */",
            "\tklp_target_state = state;",
            "",
            "\tpr_debug(\"'%s': initializing %s transition\\n\", patch->mod->name,",
            "\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");",
            "",
            "\t/*",
            "\t * Initialize all tasks to the initial patch state to prepare them for",
            "\t * switching to the target state.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task) {",
            "\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);",
            "\t\ttask->patch_state = initial_state;",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\t/*",
            "\t * Ditto for the idle \"swapper\" tasks.",
            "\t */",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\ttask = idle_task(cpu);",
            "\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);",
            "\t\ttask->patch_state = initial_state;",
            "\t}",
            "",
            "\t/*",
            "\t * Enforce the order of the task->patch_state initializations and the",
            "\t * func->transition updates to ensure that klp_ftrace_handler() doesn't",
            "\t * see a func in transition with a task->patch_state of KLP_UNDEFINED.",
            "\t *",
            "\t * Also enforce the order of the klp_target_state write and future",
            "\t * TIF_PATCH_PENDING writes to ensure klp_update_patch_state() and",
            "\t * __klp_sched_try_switch() don't set a task->patch_state to",
            "\t * KLP_UNDEFINED.",
            "\t */",
            "\tsmp_wmb();",
            "",
            "\t/*",
            "\t * Set the func transition states so klp_ftrace_handler() will know to",
            "\t * switch to the transition logic.",
            "\t *",
            "\t * When patching, the funcs aren't yet in the func_stack and will be",
            "\t * made visible to the ftrace handler shortly by the calls to",
            "\t * klp_patch_object().",
            "\t *",
            "\t * When unpatching, the funcs are already in the func_stack and so are",
            "\t * already visible to the ftrace handler.",
            "\t */",
            "\tklp_for_each_object(patch, obj)",
            "\t\tklp_for_each_func(obj, func)",
            "\t\t\tfunc->transition = true;",
            "}"
          ],
          "function_name": "klp_start_transition, klp_init_transition",
          "description": "初始化热补丁过渡阶段，设置全局目标状态并批量标记所有任务需更新补丁状态，通过内存屏障保证状态更新顺序性",
          "similarity": 0.5463573932647705
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 648,
          "end_line": 740,
          "content": [
            "void klp_reverse_transition(void)",
            "{",
            "\tunsigned int cpu;",
            "\tstruct task_struct *g, *task;",
            "",
            "\tpr_debug(\"'%s': reversing transition from %s\\n\",",
            "\t\t klp_transition_patch->mod->name,",
            "\t\t klp_target_state == KLP_PATCHED ? \"patching to unpatching\" :",
            "\t\t\t\t\t\t   \"unpatching to patching\");",
            "",
            "\t/*",
            "\t * Clear all TIF_PATCH_PENDING flags to prevent races caused by",
            "\t * klp_update_patch_state() or __klp_sched_try_switch() running in",
            "\t * parallel with the reverse transition.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task)",
            "\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tclear_tsk_thread_flag(idle_task(cpu), TIF_PATCH_PENDING);",
            "",
            "\t/*",
            "\t * Make sure all existing invocations of klp_update_patch_state() and",
            "\t * __klp_sched_try_switch() see the cleared TIF_PATCH_PENDING before",
            "\t * starting the reverse transition.",
            "\t */",
            "\tklp_synchronize_transition();",
            "",
            "\t/*",
            "\t * All patching has stopped, now re-initialize the global variables to",
            "\t * prepare for the reverse transition.",
            "\t */",
            "\tklp_transition_patch->enabled = !klp_transition_patch->enabled;",
            "\tklp_target_state = !klp_target_state;",
            "",
            "\t/*",
            "\t * Enforce the order of the klp_target_state write and the",
            "\t * TIF_PATCH_PENDING writes in klp_start_transition() to ensure",
            "\t * klp_update_patch_state() and __klp_sched_try_switch() don't set",
            "\t * task->patch_state to the wrong value.",
            "\t */",
            "\tsmp_wmb();",
            "",
            "\tklp_start_transition();",
            "}",
            "void klp_copy_process(struct task_struct *child)",
            "{",
            "",
            "\t/*",
            "\t * The parent process may have gone through a KLP transition since",
            "\t * the thread flag was copied in setup_thread_stack earlier. Bring",
            "\t * the task flag up to date with the parent here.",
            "\t *",
            "\t * The operation is serialized against all klp_*_transition()",
            "\t * operations by the tasklist_lock. The only exceptions are",
            "\t * klp_update_patch_state(current) and __klp_sched_try_switch(), but we",
            "\t * cannot race with them because we are current.",
            "\t */",
            "\tif (test_tsk_thread_flag(current, TIF_PATCH_PENDING))",
            "\t\tset_tsk_thread_flag(child, TIF_PATCH_PENDING);",
            "\telse",
            "\t\tclear_tsk_thread_flag(child, TIF_PATCH_PENDING);",
            "",
            "\tchild->patch_state = current->patch_state;",
            "}",
            "void klp_force_transition(void)",
            "{",
            "\tstruct klp_patch *patch;",
            "\tstruct task_struct *g, *task;",
            "\tunsigned int cpu;",
            "",
            "\tpr_warn(\"forcing remaining tasks to the patched state\\n\");",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task)",
            "\t\tklp_update_patch_state(task);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tklp_update_patch_state(idle_task(cpu));",
            "",
            "\t/* Set forced flag for patches being removed. */",
            "\tif (klp_target_state == KLP_UNPATCHED)",
            "\t\tklp_transition_patch->forced = true;",
            "\telse if (klp_transition_patch->replace) {",
            "\t\tklp_for_each_patch(patch) {",
            "\t\t\tif (patch != klp_transition_patch)",
            "\t\t\t\tpatch->forced = true;",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "klp_reverse_transition, klp_copy_process, klp_force_transition",
          "description": "该代码段实现Live Patching框架中的状态转换控制逻辑。  \n`klp_reverse_transition`负责反向转换补丁状态，清除所有任务的TIF_PATCH_PENDING标志并切换全局状态后启动反向迁移；`klp_copy_process`在进程复制时同步父进程的补丁状态标志；`klp_force_transition`强制将剩余任务设为目标状态，并标记待移除补丁的强制属性。  \n\n注：代码依赖`klp_transition_patch`、`klp_target_state`等全局变量及`tasklist_lock`等上下文，此处仅展示部分实现。",
          "similarity": 0.5250946879386902
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 53,
          "end_line": 172,
          "content": [
            "static void klp_transition_work_fn(struct work_struct *work)",
            "{",
            "\tmutex_lock(&klp_mutex);",
            "",
            "\tif (klp_transition_patch)",
            "\t\tklp_try_complete_transition();",
            "",
            "\tmutex_unlock(&klp_mutex);",
            "}",
            "static void klp_sync(struct work_struct *work)",
            "{",
            "}",
            "static void klp_synchronize_transition(void)",
            "{",
            "\tschedule_on_each_cpu(klp_sync);",
            "}",
            "static void klp_complete_transition(void)",
            "{",
            "\tstruct klp_object *obj;",
            "\tstruct klp_func *func;",
            "\tstruct task_struct *g, *task;",
            "\tunsigned int cpu;",
            "",
            "\tpr_debug(\"'%s': completing %s transition\\n\",",
            "\t\t klp_transition_patch->mod->name,",
            "\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");",
            "",
            "\tif (klp_transition_patch->replace && klp_target_state == KLP_PATCHED) {",
            "\t\tklp_unpatch_replaced_patches(klp_transition_patch);",
            "\t\tklp_discard_nops(klp_transition_patch);",
            "\t}",
            "",
            "\tif (klp_target_state == KLP_UNPATCHED) {",
            "\t\t/*",
            "\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now",
            "\t\t * remove the new functions from the func_stack.",
            "\t\t */",
            "\t\tklp_unpatch_objects(klp_transition_patch);",
            "",
            "\t\t/*",
            "\t\t * Make sure klp_ftrace_handler() can no longer see functions",
            "\t\t * from this patch on the ops->func_stack.  Otherwise, after",
            "\t\t * func->transition gets cleared, the handler may choose a",
            "\t\t * removed function.",
            "\t\t */",
            "\t\tklp_synchronize_transition();",
            "\t}",
            "",
            "\tklp_for_each_object(klp_transition_patch, obj)",
            "\t\tklp_for_each_func(obj, func)",
            "\t\t\tfunc->transition = false;",
            "",
            "\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */",
            "\tif (klp_target_state == KLP_PATCHED)",
            "\t\tklp_synchronize_transition();",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task) {",
            "\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));",
            "\t\ttask->patch_state = KLP_UNDEFINED;",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\ttask = idle_task(cpu);",
            "\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));",
            "\t\ttask->patch_state = KLP_UNDEFINED;",
            "\t}",
            "",
            "\tklp_for_each_object(klp_transition_patch, obj) {",
            "\t\tif (!klp_is_object_loaded(obj))",
            "\t\t\tcontinue;",
            "\t\tif (klp_target_state == KLP_PATCHED)",
            "\t\t\tklp_post_patch_callback(obj);",
            "\t\telse if (klp_target_state == KLP_UNPATCHED)",
            "\t\t\tklp_post_unpatch_callback(obj);",
            "\t}",
            "",
            "\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,",
            "\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");",
            "",
            "\tklp_target_state = KLP_UNDEFINED;",
            "\tklp_transition_patch = NULL;",
            "}",
            "void klp_cancel_transition(void)",
            "{",
            "\tif (WARN_ON_ONCE(klp_target_state != KLP_PATCHED))",
            "\t\treturn;",
            "",
            "\tpr_debug(\"'%s': canceling patching transition, going to unpatch\\n\",",
            "\t\t klp_transition_patch->mod->name);",
            "",
            "\tklp_target_state = KLP_UNPATCHED;",
            "\tklp_complete_transition();",
            "}",
            "void klp_update_patch_state(struct task_struct *task)",
            "{",
            "\t/*",
            "\t * A variant of synchronize_rcu() is used to allow patching functions",
            "\t * where RCU is not watching, see klp_synchronize_transition().",
            "\t */",
            "\tpreempt_disable_notrace();",
            "",
            "\t/*",
            "\t * This test_and_clear_tsk_thread_flag() call also serves as a read",
            "\t * barrier (smp_rmb) for two cases:",
            "\t *",
            "\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the",
            "\t *    klp_target_state read.  The corresponding write barriers are in",
            "\t *    klp_init_transition() and klp_reverse_transition().",
            "\t *",
            "\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read",
            "\t *    of func->transition, if klp_ftrace_handler() is called later on",
            "\t *    the same CPU.  See __klp_disable_patch().",
            "\t */",
            "\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))",
            "\t\ttask->patch_state = READ_ONCE(klp_target_state);",
            "",
            "\tpreempt_enable_notrace();",
            "}"
          ],
          "function_name": "klp_transition_work_fn, klp_sync, klp_synchronize_transition, klp_complete_transition, klp_cancel_transition, klp_update_patch_state",
          "description": "实现热补丁过渡的核心协程逻辑，包含任务状态同步、补丁完成处理、取消操作及状态更新，通过循环遍历进程和空闲任务确保全部迁移",
          "similarity": 0.48597946763038635
        }
      ]
    },
    {
      "source_file": "mm/swap_state.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:27:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `swap_state.c`\n\n---\n\n# `swap_state.c` 技术文档\n\n## 1. 文件概述\n\n`swap_state.c` 是 Linux 内核内存管理子系统中负责**交换缓存（swap cache）**管理的核心文件。它实现了将匿名页（anonymous pages）换出到交换设备后，在内存中维护一个缓存层（即 swap cache），用于加速后续可能发生的 swap-in 操作，并保证数据一致性。该文件定义了交换缓存的地址空间操作、页面增删接口、预读机制以及统计信息展示等功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`swapper_spaces[MAX_SWAPFILES]`**：每个交换区（swapfile/swap partition）对应一个 `address_space`，用于组织其上的交换页。\n- **`swap_aops`**：交换缓存专用的 `address_space_operations`，包含 `writepage`、`dirty_folio` 和迁移支持。\n- **`swap_readahead_info`（通过 `vma` 原子变量存储）**：用于实现交换预读（swap read-ahead）的窗口和命中计数。\n- **预读宏定义**：\n  - `SWAP_RA_VAL()`：将地址、窗口大小、命中次数编码为一个 `long` 值。\n  - `SWAP_RA_ADDR()` / `SWAP_RA_WIN()` / `SWAP_RA_HITS()`：解码预读信息。\n\n### 主要函数\n- **`add_to_swap_cache()`**：将已分配交换项的 folio 添加到交换缓存中。\n- **`__delete_from_swap_cache()` / `delete_from_swap_cache()`**：从交换缓存中移除 folio，并释放对应的交换项。\n- **`add_to_swap()`**：为 folio 分配交换空间并加入交换缓存，是页面回收路径的关键步骤。\n- **`get_shadow_from_swap_cache()`**：查询交换缓存中是否存在指定交换项的“影子”（shadow entry），用于 workingset 检测。\n- **`clear_shadow_from_swap_cache()`**：批量清除指定交换区范围内的 shadow entries。\n- **`show_swap_cache_info()`**：打印交换缓存的全局统计信息（页数、空闲/总交换空间）。\n\n## 3. 关键实现\n\n### 交换缓存模型\n- 使用 `address_space` + `XArray`（`i_pages`）作为底层数据结构，每个交换项（`swp_entry_t`）的偏移量（`swp_offset`）作为 XArray 的索引。\n- Folio 被加入交换缓存时，设置 `PG_swapcache` 标志，并将 `folio->swap` 指向对应的交换项。\n- 与普通文件页缓存不同，交换缓存不关联 inode，而是通过虚拟的 `swapper_spaces` 管理。\n\n### 预读机制（Swap Read-Ahead）\n- 基于 VMA 的 `swap_readahead_info` 原子变量实现自适应预读。\n- 初始预读窗口较小（4 页），根据连续命中的次数动态调整窗口大小。\n- 预读信息（地址、窗口、命中数）被压缩存储在一个 `long` 中，通过位域操作高效访问。\n\n### 内存与交换一致性\n- 在 `add_to_swap()` 中，**强制标记 folio 为 dirty**，以解决 `MADV_FREE` 页面因 PTE dirty 位清除而导致的数据丢失风险。\n- 删除交换缓存项时，需持有 folio 锁并确保不在 writeback 状态，防止并发冲突。\n- 使用 `__GFP_NOMEMALLOC` 标志避免在内存紧张时耗尽紧急内存保留区。\n\n### Workingset 支持\n- 通过 `xa_is_value()` 存储和识别 **shadow entries**（非 folio 的特殊值），用于 workingset 回收算法判断页面是否近期被访问过。\n- `workingset_update_node` 回调用于在 XArray 节点变化时更新 LRU 年龄信息。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/gfp.h>`、`<linux/pagevec.h>` 等基础内存管理接口。\n- **交换子系统**：紧密集成 `<linux/swap.h>`、`<linux/swapops.h>`，使用 `swp_entry_t`、`swap_address_space()` 等交换抽象。\n- **页缓存基础设施**：复用 `address_space`、`XArray`、`folio` 等通用页缓存机制（来自 `filemap.c` 和 `xarray.c`）。\n- **LRU 与回收**：与 `vmscan`（`shrink_page_list`）交互，通过 `NR_SWAPCACHE` 统计项参与内存回收决策。\n- **迁移支持**：若启用 `CONFIG_MIGRATION`，支持 folio 在 NUMA 节点间的迁移。\n- **内部头文件**：依赖 `internal.h` 和 `swap.h` 中的内核私有交换实现细节。\n\n## 5. 使用场景\n\n- **页面回收（Page Reclaim）**：当系统内存不足时，`shrink_page_list()` 调用 `add_to_swap()` 将匿名页换出到交换设备，并加入交换缓存。\n- **缺页异常处理（Page Fault）**：当访问已换出的匿名页时，`do_swap_page()` 从交换设备读取数据前，先检查交换缓存是否已有该页，若有则直接复用。\n- **交换预读优化**：在顺序访问已换出页面时，根据历史访问模式自动扩大预读窗口，减少 I/O 次数。\n- **内存压缩与迁移**：在内存规整（compaction）或 NUMA 迁移过程中，通过 `migrate_folio` 操作移动交换缓存中的 folio。\n- **系统监控与调试**：通过 `/proc/meminfo` 或内核日志（`show_swap_cache_info()`）查看交换缓存使用情况。",
      "similarity": 0.4849572777748108,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "mm/swap_state.c",
          "start_line": 611,
          "end_line": 712,
          "content": [
            "static unsigned long swapin_nr_pages(unsigned long offset)",
            "{",
            "\tstatic unsigned long prev_offset;",
            "\tunsigned int hits, pages, max_pages;",
            "\tstatic atomic_t last_readahead_pages;",
            "",
            "\tmax_pages = 1 << READ_ONCE(page_cluster);",
            "\tif (max_pages <= 1)",
            "\t\treturn 1;",
            "",
            "\thits = atomic_xchg(&swapin_readahead_hits, 0);",
            "\tpages = __swapin_nr_pages(READ_ONCE(prev_offset), offset, hits,",
            "\t\t\t\t  max_pages,",
            "\t\t\t\t  atomic_read(&last_readahead_pages));",
            "\tif (!hits)",
            "\t\tWRITE_ONCE(prev_offset, offset);",
            "\tatomic_set(&last_readahead_pages, pages);",
            "",
            "\treturn pages;",
            "}",
            "int init_swap_address_space(unsigned int type, unsigned long nr_pages)",
            "{",
            "\tstruct address_space *spaces, *space;",
            "\tunsigned int i, nr;",
            "",
            "\tnr = DIV_ROUND_UP(nr_pages, SWAP_ADDRESS_SPACE_PAGES);",
            "\tspaces = kvcalloc(nr, sizeof(struct address_space), GFP_KERNEL);",
            "\tif (!spaces)",
            "\t\treturn -ENOMEM;",
            "\tfor (i = 0; i < nr; i++) {",
            "\t\tspace = spaces + i;",
            "\t\txa_init_flags(&space->i_pages, XA_FLAGS_LOCK_IRQ);",
            "\t\tatomic_set(&space->i_mmap_writable, 0);",
            "\t\tspace->a_ops = &swap_aops;",
            "\t\t/* swap cache doesn't use writeback related tags */",
            "\t\tmapping_set_no_writeback_tags(space);",
            "\t}",
            "\tnr_swapper_spaces[type] = nr;",
            "\tswapper_spaces[type] = spaces;",
            "",
            "\treturn 0;",
            "}",
            "void exit_swap_address_space(unsigned int type)",
            "{",
            "\tint i;",
            "\tstruct address_space *spaces = swapper_spaces[type];",
            "",
            "\tfor (i = 0; i < nr_swapper_spaces[type]; i++)",
            "\t\tVM_WARN_ON_ONCE(!mapping_empty(&spaces[i]));",
            "\tkvfree(spaces);",
            "\tnr_swapper_spaces[type] = 0;",
            "\tswapper_spaces[type] = NULL;",
            "}",
            "static void swap_ra_info(struct vm_fault *vmf,",
            "\t\t\t struct vma_swap_readahead *ra_info)",
            "{",
            "\tstruct vm_area_struct *vma = vmf->vma;",
            "\tunsigned long ra_val;",
            "\tunsigned long faddr, pfn, fpfn, lpfn, rpfn;",
            "\tunsigned long start, end;",
            "\tunsigned int max_win, hits, prev_win, win;",
            "",
            "\tmax_win = 1 << min_t(unsigned int, READ_ONCE(page_cluster),",
            "\t\t\t     SWAP_RA_ORDER_CEILING);",
            "\tif (max_win == 1) {",
            "\t\tra_info->win = 1;",
            "\t\treturn;",
            "\t}",
            "",
            "\tfaddr = vmf->address;",
            "\tfpfn = PFN_DOWN(faddr);",
            "\tra_val = GET_SWAP_RA_VAL(vma);",
            "\tpfn = PFN_DOWN(SWAP_RA_ADDR(ra_val));",
            "\tprev_win = SWAP_RA_WIN(ra_val);",
            "\thits = SWAP_RA_HITS(ra_val);",
            "\tra_info->win = win = __swapin_nr_pages(pfn, fpfn, hits,",
            "\t\t\t\t\t       max_win, prev_win);",
            "\tatomic_long_set(&vma->swap_readahead_info,",
            "\t\t\tSWAP_RA_VAL(faddr, win, 0));",
            "\tif (win == 1)",
            "\t\treturn;",
            "",
            "\tif (fpfn == pfn + 1) {",
            "\t\tlpfn = fpfn;",
            "\t\trpfn = fpfn + win;",
            "\t} else if (pfn == fpfn + 1) {",
            "\t\tlpfn = fpfn - win + 1;",
            "\t\trpfn = fpfn + 1;",
            "\t} else {",
            "\t\tunsigned int left = (win - 1) / 2;",
            "",
            "\t\tlpfn = fpfn - left;",
            "\t\trpfn = fpfn + win - left;",
            "\t}",
            "\tstart = max3(lpfn, PFN_DOWN(vma->vm_start),",
            "\t\t     PFN_DOWN(faddr & PMD_MASK));",
            "\tend = min3(rpfn, PFN_DOWN(vma->vm_end),",
            "\t\t   PFN_DOWN((faddr & PMD_MASK) + PMD_SIZE));",
            "",
            "\tra_info->nr_pte = end - start;",
            "\tra_info->offset = fpfn - start;",
            "}"
          ],
          "function_name": "swapin_nr_pages, init_swap_address_space, exit_swap_address_space, swap_ra_info",
          "description": "实现交换读取ahead算法（swapin_nr_pages）、交换地址空间初始化（init_swap_address_space）与退出（exit_swap_address_space），以及swap_ra_info用于计算并设置虚拟内存区域的读取ahead参数",
          "similarity": 0.46495676040649414
        },
        {
          "chunk_id": 4,
          "file_path": "mm/swap_state.c",
          "start_line": 913,
          "end_line": 951,
          "content": [
            "static ssize_t vma_ra_enabled_show(struct kobject *kobj,",
            "\t\t\t\t     struct kobj_attribute *attr, char *buf)",
            "{",
            "\treturn sysfs_emit(buf, \"%s\\n\",",
            "\t\t\t  enable_vma_readahead ? \"true\" : \"false\");",
            "}",
            "static ssize_t vma_ra_enabled_store(struct kobject *kobj,",
            "\t\t\t\t      struct kobj_attribute *attr,",
            "\t\t\t\t      const char *buf, size_t count)",
            "{",
            "\tssize_t ret;",
            "",
            "\tret = kstrtobool(buf, &enable_vma_readahead);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn count;",
            "}",
            "static int __init swap_init_sysfs(void)",
            "{",
            "\tint err;",
            "\tstruct kobject *swap_kobj;",
            "",
            "\tswap_kobj = kobject_create_and_add(\"swap\", mm_kobj);",
            "\tif (!swap_kobj) {",
            "\t\tpr_err(\"failed to create swap kobject\\n\");",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\terr = sysfs_create_group(swap_kobj, &swap_attr_group);",
            "\tif (err) {",
            "\t\tpr_err(\"failed to register swap group\\n\");",
            "\t\tgoto delete_obj;",
            "\t}",
            "\treturn 0;",
            "",
            "delete_obj:",
            "\tkobject_put(swap_kobj);",
            "\treturn err;",
            "}"
          ],
          "function_name": "vma_ra_enabled_show, vma_ra_enabled_store, swap_init_sysfs",
          "description": "提供sysfs接口控制VMA读取ahead功能，vma_ra_enabled_show/store用于获取/设置enable_vma_readahead标志，swap_init_sysfs初始化交换相关sysfs节点",
          "similarity": 0.4542618989944458
        },
        {
          "chunk_id": 2,
          "file_path": "mm/swap_state.c",
          "start_line": 236,
          "end_line": 357,
          "content": [
            "void delete_from_swap_cache(struct folio *folio)",
            "{",
            "\tswp_entry_t entry = folio->swap;",
            "\tstruct address_space *address_space = swap_address_space(entry);",
            "",
            "\txa_lock_irq(&address_space->i_pages);",
            "\t__delete_from_swap_cache(folio, entry, NULL);",
            "\txa_unlock_irq(&address_space->i_pages);",
            "",
            "\tput_swap_folio(folio, entry);",
            "\tfolio_ref_sub(folio, folio_nr_pages(folio));",
            "}",
            "void clear_shadow_from_swap_cache(int type, unsigned long begin,",
            "\t\t\t\tunsigned long end)",
            "{",
            "\tunsigned long curr = begin;",
            "\tvoid *old;",
            "",
            "\tfor (;;) {",
            "\t\tswp_entry_t entry = swp_entry(type, curr);",
            "\t\tstruct address_space *address_space = swap_address_space(entry);",
            "\t\tXA_STATE(xas, &address_space->i_pages, curr);",
            "",
            "\t\txas_set_update(&xas, workingset_update_node);",
            "",
            "\t\txa_lock_irq(&address_space->i_pages);",
            "\t\txas_for_each(&xas, old, end) {",
            "\t\t\tif (!xa_is_value(old))",
            "\t\t\t\tcontinue;",
            "\t\t\txas_store(&xas, NULL);",
            "\t\t}",
            "\t\txa_unlock_irq(&address_space->i_pages);",
            "",
            "\t\t/* search the next swapcache until we meet end */",
            "\t\tcurr >>= SWAP_ADDRESS_SPACE_SHIFT;",
            "\t\tcurr++;",
            "\t\tcurr <<= SWAP_ADDRESS_SPACE_SHIFT;",
            "\t\tif (curr > end)",
            "\t\t\tbreak;",
            "\t}",
            "}",
            "void free_swap_cache(struct folio *folio)",
            "{",
            "\tif (folio_test_swapcache(folio) && !folio_mapped(folio) &&",
            "\t    folio_trylock(folio)) {",
            "\t\tfolio_free_swap(folio);",
            "\t\tfolio_unlock(folio);",
            "\t}",
            "}",
            "void free_page_and_swap_cache(struct page *page)",
            "{",
            "\tstruct folio *folio = page_folio(page);",
            "",
            "\tfree_swap_cache(folio);",
            "\tif (!is_huge_zero_folio(folio))",
            "\t\tfolio_put(folio);",
            "}",
            "void free_pages_and_swap_cache(struct encoded_page **pages, int nr)",
            "{",
            "\tstruct folio_batch folios;",
            "\tunsigned int refs[PAGEVEC_SIZE];",
            "",
            "\tlru_add_drain();",
            "\tfolio_batch_init(&folios);",
            "\tfor (int i = 0; i < nr; i++) {",
            "\t\tstruct folio *folio = page_folio(encoded_page_ptr(pages[i]));",
            "",
            "\t\tfree_swap_cache(folio);",
            "\t\trefs[folios.nr] = 1;",
            "\t\tif (unlikely(encoded_page_flags(pages[i]) &",
            "\t\t\t     ENCODED_PAGE_BIT_NR_PAGES_NEXT))",
            "\t\t\trefs[folios.nr] = encoded_nr_pages(pages[++i]);",
            "",
            "\t\tif (folio_batch_add(&folios, folio) == 0)",
            "\t\t\tfolios_put_refs(&folios, refs);",
            "\t}",
            "\tif (folios.nr)",
            "\t\tfolios_put_refs(&folios, refs);",
            "}",
            "static inline bool swap_use_vma_readahead(void)",
            "{",
            "\treturn READ_ONCE(enable_vma_readahead) && !atomic_read(&nr_rotate_swap);",
            "}",
            "static unsigned int __swapin_nr_pages(unsigned long prev_offset,",
            "\t\t\t\t      unsigned long offset,",
            "\t\t\t\t      int hits,",
            "\t\t\t\t      int max_pages,",
            "\t\t\t\t      int prev_win)",
            "{",
            "\tunsigned int pages, last_ra;",
            "",
            "\t/*",
            "\t * This heuristic has been found to work well on both sequential and",
            "\t * random loads, swapping to hard disk or to SSD: please don't ask",
            "\t * what the \"+ 2\" means, it just happens to work well, that's all.",
            "\t */",
            "\tpages = hits + 2;",
            "\tif (pages == 2) {",
            "\t\t/*",
            "\t\t * We can have no readahead hits to judge by: but must not get",
            "\t\t * stuck here forever, so check for an adjacent offset instead",
            "\t\t * (and don't even bother to check whether swap type is same).",
            "\t\t */",
            "\t\tif (offset != prev_offset + 1 && offset != prev_offset - 1)",
            "\t\t\tpages = 1;",
            "\t} else {",
            "\t\tunsigned int roundup = 4;",
            "\t\twhile (roundup < pages)",
            "\t\t\troundup <<= 1;",
            "\t\tpages = roundup;",
            "\t}",
            "",
            "\tif (pages > max_pages)",
            "\t\tpages = max_pages;",
            "",
            "\t/* Don't shrink readahead too fast */",
            "\tlast_ra = prev_win / 2;",
            "\tif (pages < last_ra)",
            "\t\tpages = last_ra;",
            "",
            "\treturn pages;",
            "}"
          ],
          "function_name": "delete_from_swap_cache, clear_shadow_from_swap_cache, free_swap_cache, free_page_and_swap_cache, free_pages_and_swap_cache, swap_use_vma_readahead, __swapin_nr_pages",
          "description": "实现交换缓存清理逻辑，delete_from_swap_cache删除页帧引用，clear_shadow_from_swap_cache清除影子数据，free_swap_cache与free_page_and_swap_cache负责释放交换缓存及其关联资源",
          "similarity": 0.42811301350593567
        },
        {
          "chunk_id": 1,
          "file_path": "mm/swap_state.c",
          "start_line": 66,
          "end_line": 195,
          "content": [
            "void show_swap_cache_info(void)",
            "{",
            "\tprintk(\"%lu pages in swap cache\\n\", total_swapcache_pages());",
            "\tprintk(\"Free swap  = %ldkB\\n\", K(get_nr_swap_pages()));",
            "\tprintk(\"Total swap = %lukB\\n\", K(total_swap_pages));",
            "}",
            "int add_to_swap_cache(struct folio *folio, swp_entry_t entry,",
            "\t\t\tgfp_t gfp, void **shadowp)",
            "{",
            "\tstruct address_space *address_space = swap_address_space(entry);",
            "\tpgoff_t idx = swp_offset(entry);",
            "\tXA_STATE_ORDER(xas, &address_space->i_pages, idx, folio_order(folio));",
            "\tunsigned long i, nr = folio_nr_pages(folio);",
            "\tvoid *old;",
            "",
            "\txas_set_update(&xas, workingset_update_node);",
            "",
            "\tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);",
            "\tVM_BUG_ON_FOLIO(folio_test_swapcache(folio), folio);",
            "\tVM_BUG_ON_FOLIO(!folio_test_swapbacked(folio), folio);",
            "",
            "\tfolio_ref_add(folio, nr);",
            "\tfolio_set_swapcache(folio);",
            "\tfolio->swap = entry;",
            "",
            "\tdo {",
            "\t\txas_lock_irq(&xas);",
            "\t\txas_create_range(&xas);",
            "\t\tif (xas_error(&xas))",
            "\t\t\tgoto unlock;",
            "\t\tfor (i = 0; i < nr; i++) {",
            "\t\t\tVM_BUG_ON_FOLIO(xas.xa_index != idx + i, folio);",
            "\t\t\told = xas_load(&xas);",
            "\t\t\tif (xa_is_value(old)) {",
            "\t\t\t\tif (shadowp)",
            "\t\t\t\t\t*shadowp = old;",
            "\t\t\t}",
            "\t\t\txas_store(&xas, folio);",
            "\t\t\txas_next(&xas);",
            "\t\t}",
            "\t\taddress_space->nrpages += nr;",
            "\t\t__node_stat_mod_folio(folio, NR_FILE_PAGES, nr);",
            "\t\t__lruvec_stat_mod_folio(folio, NR_SWAPCACHE, nr);",
            "unlock:",
            "\t\txas_unlock_irq(&xas);",
            "\t} while (xas_nomem(&xas, gfp));",
            "",
            "\tif (!xas_error(&xas))",
            "\t\treturn 0;",
            "",
            "\tfolio_clear_swapcache(folio);",
            "\tfolio_ref_sub(folio, nr);",
            "\treturn xas_error(&xas);",
            "}",
            "void __delete_from_swap_cache(struct folio *folio,",
            "\t\t\tswp_entry_t entry, void *shadow)",
            "{",
            "\tstruct address_space *address_space = swap_address_space(entry);",
            "\tint i;",
            "\tlong nr = folio_nr_pages(folio);",
            "\tpgoff_t idx = swp_offset(entry);",
            "\tXA_STATE(xas, &address_space->i_pages, idx);",
            "",
            "\txas_set_update(&xas, workingset_update_node);",
            "",
            "\tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);",
            "\tVM_BUG_ON_FOLIO(!folio_test_swapcache(folio), folio);",
            "\tVM_BUG_ON_FOLIO(folio_test_writeback(folio), folio);",
            "",
            "\tfor (i = 0; i < nr; i++) {",
            "\t\tvoid *entry = xas_store(&xas, shadow);",
            "\t\tVM_BUG_ON_PAGE(entry != folio, entry);",
            "\t\txas_next(&xas);",
            "\t}",
            "\tfolio->swap.val = 0;",
            "\tfolio_clear_swapcache(folio);",
            "\taddress_space->nrpages -= nr;",
            "\t__node_stat_mod_folio(folio, NR_FILE_PAGES, -nr);",
            "\t__lruvec_stat_mod_folio(folio, NR_SWAPCACHE, -nr);",
            "}",
            "bool add_to_swap(struct folio *folio)",
            "{",
            "\tswp_entry_t entry;",
            "\tint err;",
            "",
            "\tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);",
            "\tVM_BUG_ON_FOLIO(!folio_test_uptodate(folio), folio);",
            "",
            "\tentry = folio_alloc_swap(folio);",
            "\tif (!entry.val)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * XArray node allocations from PF_MEMALLOC contexts could",
            "\t * completely exhaust the page allocator. __GFP_NOMEMALLOC",
            "\t * stops emergency reserves from being allocated.",
            "\t *",
            "\t * TODO: this could cause a theoretical memory reclaim",
            "\t * deadlock in the swap out path.",
            "\t */",
            "\t/*",
            "\t * Add it to the swap cache.",
            "\t */",
            "\terr = add_to_swap_cache(folio, entry,",
            "\t\t\t__GFP_HIGH|__GFP_NOMEMALLOC|__GFP_NOWARN, NULL);",
            "\tif (err)",
            "\t\t/*",
            "\t\t * add_to_swap_cache() doesn't return -EEXIST, so we can safely",
            "\t\t * clear SWAP_HAS_CACHE flag.",
            "\t\t */",
            "\t\tgoto fail;",
            "\t/*",
            "\t * Normally the folio will be dirtied in unmap because its",
            "\t * pte should be dirty. A special case is MADV_FREE page. The",
            "\t * page's pte could have dirty bit cleared but the folio's",
            "\t * SwapBacked flag is still set because clearing the dirty bit",
            "\t * and SwapBacked flag has no lock protected. For such folio,",
            "\t * unmap will not set dirty bit for it, so folio reclaim will",
            "\t * not write the folio out. This can cause data corruption when",
            "\t * the folio is swapped in later. Always setting the dirty flag",
            "\t * for the folio solves the problem.",
            "\t */",
            "\tfolio_mark_dirty(folio);",
            "",
            "\treturn true;",
            "",
            "fail:",
            "\tput_swap_folio(folio, entry);",
            "\treturn false;",
            "}"
          ],
          "function_name": "show_swap_cache_info, add_to_swap_cache, __delete_from_swap_cache, add_to_swap",
          "description": "提供交换缓存操作函数，add_to_swap_cache将页帧加入交换缓存并更新统计信息，__delete_from_swap_cache移除页帧并回收资源，add_to_swap负责分配交换条目并绑定至页帧",
          "similarity": 0.42577701807022095
        },
        {
          "chunk_id": 0,
          "file_path": "mm/swap_state.c",
          "start_line": 1,
          "end_line": 65,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " *  linux/mm/swap_state.c",
            " *",
            " *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds",
            " *  Swap reorganised 29.12.95, Stephen Tweedie",
            " *",
            " *  Rewritten to use page cache, (C) 1998 Stephen Tweedie",
            " */",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/swap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/etmem.h>",
            "#include \"internal.h\"",
            "#include \"swap.h\"",
            "",
            "/*",
            " * swapper_space is a fiction, retained to simplify the path through",
            " * vmscan's shrink_page_list.",
            " */",
            "static const struct address_space_operations swap_aops = {",
            "\t.writepage\t= swap_writepage,",
            "\t.dirty_folio\t= noop_dirty_folio,",
            "#ifdef CONFIG_MIGRATION",
            "\t.migrate_folio\t= migrate_folio,",
            "#endif",
            "};",
            "",
            "struct address_space *swapper_spaces[MAX_SWAPFILES] __read_mostly;",
            "static unsigned int nr_swapper_spaces[MAX_SWAPFILES] __read_mostly;",
            "static bool enable_vma_readahead __read_mostly = true;",
            "",
            "#define SWAP_RA_WIN_SHIFT\t(PAGE_SHIFT / 2)",
            "#define SWAP_RA_HITS_MASK\t((1UL << SWAP_RA_WIN_SHIFT) - 1)",
            "#define SWAP_RA_HITS_MAX\tSWAP_RA_HITS_MASK",
            "#define SWAP_RA_WIN_MASK\t(~PAGE_MASK & ~SWAP_RA_HITS_MASK)",
            "",
            "#define SWAP_RA_HITS(v)\t\t((v) & SWAP_RA_HITS_MASK)",
            "#define SWAP_RA_WIN(v)\t\t(((v) & SWAP_RA_WIN_MASK) >> SWAP_RA_WIN_SHIFT)",
            "#define SWAP_RA_ADDR(v)\t\t((v) & PAGE_MASK)",
            "",
            "#define SWAP_RA_VAL(addr, win, hits)\t\t\t\t\\",
            "\t(((addr) & PAGE_MASK) |\t\t\t\t\t\\",
            "\t (((win) << SWAP_RA_WIN_SHIFT) & SWAP_RA_WIN_MASK) |\t\\",
            "\t ((hits) & SWAP_RA_HITS_MASK))",
            "",
            "/* Initial readahead hits is 4 to start up with a small window */",
            "#define GET_SWAP_RA_VAL(vma)\t\t\t\t\t\\",
            "\t(atomic_long_read(&(vma)->swap_readahead_info) ? : 4)",
            "",
            "static atomic_t swapin_readahead_hits = ATOMIC_INIT(4);",
            ""
          ],
          "function_name": null,
          "description": "定义交换空间的地址空间操作（swap_aops），声明全局交换地址空间数组swapper_spaces及辅助宏，用于管理交换缓存的读取ahead策略和窗口计算",
          "similarity": 0.419890820980072
        }
      ]
    },
    {
      "source_file": "kernel/livepatch/state.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:33:58\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `livepatch\\state.c`\n\n---\n\n# livepatch/state.c 技术文档\n\n## 1. 文件概述\n\n`livepatch/state.c` 是 Linux 内核实时补丁（Livepatch）子系统中的一个核心组件，用于管理和查询由实时补丁修改的系统状态（system state）。该文件提供了机制，使得多个实时补丁能够安全地协同工作，尤其是在处理共享或依赖的系统状态时，确保状态版本兼容性，防止因状态不一致导致系统崩溃或行为异常。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`klp_get_state(struct klp_patch *patch, unsigned long id)`**  \n  根据指定的补丁对象和状态 ID，查找该补丁所声明的系统状态结构体。若存在则返回指向 `struct klp_state` 的指针，否则返回 `NULL`。\n\n- **`klp_get_prev_state(unsigned long id)`**  \n  在实时补丁过渡（transition）过程中，查找所有已安装（但不包括当前正在过渡的）补丁中，对指定 ID 的系统状态的最新修改记录。返回最新（即最后安装的）补丁中的对应状态结构体，若未找到则返回 `NULL`。\n\n- **`klp_is_state_compatible(struct klp_patch *patch, struct klp_state *old_state)`**  \n  判断给定补丁是否能兼容已存在的系统状态。若补丁为累积型（`replace == true`），则必须显式声明对该状态的支持；若为非累积型，则可忽略。对于声明了该状态的补丁，其状态版本号必须不小于已有状态的版本号。\n\n- **`klp_is_patch_compatible(struct klp_patch *patch)`**  \n  检查新加载的补丁是否与所有已安装补丁所修改的系统状态兼容。遍历所有已安装补丁的状态，调用 `klp_is_state_compatible` 进行验证。只要有一个状态不兼容，即返回 `false`。\n\n### 数据结构\n\n- **`struct klp_state`**（定义在 `state.h` 中）  \n  表示一个由实时补丁修改的系统状态，包含：\n  - `id`：用户自定义的唯一状态标识符（`unsigned long`）\n  - `version`：状态的版本号，用于兼容性检查\n  - 其他可能的字段（如回调函数指针等，由头文件定义）\n\n- **`struct klp_patch`**（定义在 `core.h` 中）  \n  表示一个完整的实时补丁对象，包含其修改的状态数组（`states` 字段）。\n\n## 3. 关键实现\n\n- **状态遍历宏 `klp_for_each_state`**  \n  通过 `for` 循环遍历 `patch->states` 数组，直到遇到 `id == 0` 的终止项，实现对补丁所声明状态的高效迭代。\n\n- **状态兼容性逻辑**  \n  - **累积补丁（Cumulative Patch）**：通过 `patch->replace == true` 标识，必须显式处理所有已存在的系统状态，否则视为不兼容。\n  - **非累积补丁（Non-cumulative Patch）**：可选择性忽略已有状态，但若声明了相同 `id` 的状态，则其 `version` 必须 ≥ 已有状态的 `version`，确保向后兼容。\n\n- **`klp_get_prev_state` 的上下文限制**  \n  该函数仅在补丁过渡期间有效（通过 `klp_transition_patch` 全局变量判断），且遍历已安装补丁时跳过当前正在过渡的补丁，确保返回的是“之前”安装的最新状态。\n\n- **安全断言**  \n  在 `klp_get_prev_state` 中使用 `WARN_ON_ONCE(!klp_transition_patch)` 防止在非过渡上下文中误用该函数，增强代码健壮性。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/livepatch.h>`：提供 Livepatch 子系统的公共接口和数据结构定义。\n  - `\"core.h\"`：包含 `struct klp_patch` 和补丁管理相关内部接口（如 `klp_for_each_patch` 宏）。\n  - `\"state.h\"`：定义 `struct klp_state` 及相关辅助宏。\n  - `\"transition.h\"`：提供 `klp_transition_patch` 全局变量，用于标识当前过渡中的补丁。\n\n- **模块导出**：\n  - `klp_get_state` 和 `klp_get_prev_state` 通过 `EXPORT_SYMBOL_GPL` 导出，供其他 GPL 兼容的内核模块（如具体的实时补丁模块）在 pre/post (un)patch 回调或补丁代码中调用。\n\n## 5. 使用场景\n\n- **实时补丁开发**：补丁作者在 pre/post (un)patch 回调函数中调用 `klp_get_state` 获取自身声明的状态，或调用 `klp_get_prev_state` 查询已有补丁对该状态的修改，以实现状态迁移或数据转换。\n\n- **补丁加载时的兼容性检查**：内核在启用新补丁前调用 `klp_is_patch_compatible`，确保新补丁不会破坏由先前补丁建立的系统状态，保障系统稳定性。\n\n- **多补丁协同工作**：当多个非累积补丁修改同一系统状态时，通过版本号机制确保状态演进有序；累积补丁则必须整合所有历史状态，实现“全量替换”语义。\n\n- **过渡阶段状态查询**：仅在补丁启用/回滚的过渡窗口期内，允许查询“前一个”状态，用于实现平滑的状态切换逻辑。",
      "similarity": 0.4832671880722046,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/livepatch/state.c",
          "start_line": 1,
          "end_line": 86,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * system_state.c - State of the system modified by livepatches",
            " *",
            " * Copyright (C) 2019 SUSE",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/livepatch.h>",
            "#include \"core.h\"",
            "#include \"state.h\"",
            "#include \"transition.h\"",
            "",
            "#define klp_for_each_state(patch, state)\t\t\\",
            "\tfor (state = patch->states; state && state->id; state++)",
            "",
            "/**",
            " * klp_get_state() - get information about system state modified by",
            " *\tthe given patch",
            " * @patch:\tlivepatch that modifies the given system state",
            " * @id:\t\tcustom identifier of the modified system state",
            " *",
            " * Checks whether the given patch modifies the given system state.",
            " *",
            " * The function can be called either from pre/post (un)patch",
            " * callbacks or from the kernel code added by the livepatch.",
            " *",
            " * Return: pointer to struct klp_state when found, otherwise NULL.",
            " */",
            "struct klp_state *klp_get_state(struct klp_patch *patch, unsigned long id)",
            "{",
            "\tstruct klp_state *state;",
            "",
            "\tklp_for_each_state(patch, state) {",
            "\t\tif (state->id == id)",
            "\t\t\treturn state;",
            "\t}",
            "",
            "\treturn NULL;",
            "}",
            "EXPORT_SYMBOL_GPL(klp_get_state);",
            "",
            "/**",
            " * klp_get_prev_state() - get information about system state modified by",
            " *\tthe already installed livepatches",
            " * @id:\t\tcustom identifier of the modified system state",
            " *",
            " * Checks whether already installed livepatches modify the given",
            " * system state.",
            " *",
            " * The same system state can be modified by more non-cumulative",
            " * livepatches. It is expected that the latest livepatch has",
            " * the most up-to-date information.",
            " *",
            " * The function can be called only during transition when a new",
            " * livepatch is being enabled or when such a transition is reverted.",
            " * It is typically called only from pre/post (un)patch",
            " * callbacks.",
            " *",
            " * Return: pointer to the latest struct klp_state from already",
            " *\tinstalled livepatches, NULL when not found.",
            " */",
            "struct klp_state *klp_get_prev_state(unsigned long id)",
            "{",
            "\tstruct klp_patch *patch;",
            "\tstruct klp_state *state, *last_state = NULL;",
            "",
            "\tif (WARN_ON_ONCE(!klp_transition_patch))",
            "\t\treturn NULL;",
            "",
            "\tklp_for_each_patch(patch) {",
            "\t\tif (patch == klp_transition_patch)",
            "\t\t\tgoto out;",
            "",
            "\t\tstate = klp_get_state(patch, id);",
            "\t\tif (state)",
            "\t\t\tlast_state = state;",
            "\t}",
            "",
            "out:",
            "\treturn last_state;",
            "}",
            "EXPORT_SYMBOL_GPL(klp_get_prev_state);",
            "",
            "/* Check if the patch is able to deal with the existing system state. */"
          ],
          "function_name": null,
          "description": "实现用于查询特定补丁修改的系统状态信息的函数，包含klp_get_state用于匹配指定ID的状态结构，klp_get_prev_state用于获取已安装补丁中最新的相关状态。代码末尾存在未完成的上下文提示",
          "similarity": 0.5050559043884277
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/livepatch/state.c",
          "start_line": 87,
          "end_line": 113,
          "content": [
            "static bool klp_is_state_compatible(struct klp_patch *patch,",
            "\t\t\t\t    struct klp_state *old_state)",
            "{",
            "\tstruct klp_state *state;",
            "",
            "\tstate = klp_get_state(patch, old_state->id);",
            "",
            "\t/* A cumulative livepatch must handle all already modified states. */",
            "\tif (!state)",
            "\t\treturn !patch->replace;",
            "",
            "\treturn state->version >= old_state->version;",
            "}",
            "bool klp_is_patch_compatible(struct klp_patch *patch)",
            "{",
            "\tstruct klp_patch *old_patch;",
            "\tstruct klp_state *old_state;",
            "",
            "\tklp_for_each_patch(old_patch) {",
            "\t\tklp_for_each_state(old_patch, old_state) {",
            "\t\t\tif (!klp_is_state_compatible(patch, old_state))",
            "\t\t\t\treturn false;",
            "\t\t}",
            "\t}",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "klp_is_state_compatible, klp_is_patch_compatible",
          "description": "定义用于检查补丁与现有系统状态兼容性的辅助函数，其中klp_is_state_compatible比较状态版本号确定兼容性，klp_is_patch_compatible遍历所有已有补丁验证整体兼容性。代码块存在语法不完整问题",
          "similarity": 0.4329655170440674
        }
      ]
    }
  ]
}