{
  "query": "disk space monitoring",
  "timestamp": "2025-12-26 00:21:38",
  "retrieved_files": [
    {
      "source_file": "mm/damon/vaddr.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:53:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `damon\\vaddr.c`\n\n---\n\n# `damon/vaddr.c` 技术文档\n\n## 1. 文件概述\n\n`damon/vaddr.c` 是 Linux 内核中 DAMON（Data Access MONitor）子系统的一部分，专门用于在**虚拟地址空间**（Virtual Address Space）上实现监控原语。该文件提供了针对进程虚拟内存布局的区域初始化、内存映射分析以及与页表和 VMA（Virtual Memory Area）交互的核心逻辑，旨在高效地将复杂的虚拟地址空间抽象为少量可监控的区域，从而降低监控开销并提升适应性。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`damon_get_task_struct()`**  \n  根据 `damon_target` 中保存的 `pid` 获取对应的 `task_struct`，并增加其引用计数。\n\n- **`damon_get_mm()`**  \n  获取目标进程的 `mm_struct`（内存描述符），调用者需在使用后调用 `mmput()` 释放。\n\n- **`damon_va_evenly_split_region()`**  \n  将一个 DAMON 监控区域均匀分割为指定数量的小区域，每个小区域大小对齐到 `DAMON_MIN_REGION`。\n\n- **`__damon_va_three_regions()`**  \n  在给定的 `mm_struct` 中扫描 VMA，找出两个最大的未映射间隙（unmapped gaps），并据此划分出三个覆盖所有已映射区域的地址范围。\n\n- **`damon_va_three_regions()`**  \n  封装 `__damon_va_three_regions()`，负责获取目标进程的内存上下文并加读锁后调用。\n\n- **`__damon_va_init_regions()`**  \n  为指定的监控目标（进程）初始化三个初始监控区域，并根据配置进一步细分为多个子区域。\n\n- **`damon_va_init()`**  \n  （代码截断，但意图明确）遍历 DAMON 上下文中的所有目标，为每个目标调用 `__damon_va_init_regions()` 进行初始化。\n\n### 关键数据结构\n\n- **`struct damon_target`**  \n  表示一个被监控的目标（通常是一个进程），包含 `pid` 指针等信息。\n\n- **`struct damon_region`**  \n  DAMON 监控的基本单位，表示一段连续的虚拟地址区间（`ar.start` 到 `ar.end`）。\n\n- **`struct damon_addr_range`**  \n  简单的地址范围结构，用于临时存储起止地址。\n\n## 3. 关键实现\n\n### 三区域划分算法（Three-Region Heuristic）\n\n该文件的核心思想是：**避免直接监控整个虚拟地址空间**（含大量未映射区域）。为此，采用启发式方法：\n\n1. 遍历进程的 VMA 链表（通过 `VMA_ITERATOR` 和 RCU 读锁安全访问）。\n2. 记录所有相邻 VMA 之间的间隙（`gap = vma->vm_start - prev->vm_end`）。\n3. 找出**两个最大的间隙**（`first_gap` 和 `second_gap`）。\n4. 将整个已映射地址空间划分为三个区域：\n   - 区域0：从第一个 VMA 起始地址到第一个大间隙的开始\n   - 区域1：从第一个大间隙结束到第二个大间隙开始\n   - 区域2：从第二个大间隙结束到最后一个 VMA 结束地址\n5. 所有边界对齐到 `DAMON_MIN_REGION`（通常为页大小或更大）。\n\n此方法有效跳过了堆与 mmap 区之间、mmap 区与栈之间的巨大空洞，显著减少无效监控区域。\n\n### 区域细分策略\n\n初始化的三个大区域会根据 DAMON 上下文配置的 `min_nr_regions` 进一步细分：\n- 计算平均区域大小：`总监控大小 / min_nr_regions`\n- 若计算结果小于 `DAMON_MIN_REGION`，则使用后者作为最小粒度\n- 调用 `damon_va_evenly_split_region()` 将每个大区域均匀切分为若干子区域\n\n这确保了初始监控粒度既不过粗（丢失细节），也不过细（开销过大）。\n\n### 内存安全与同步\n\n- 使用 `mmap_read_lock()`/`mmap_read_unlock()` 保护 VMA 遍历，兼容并发内存映射变更。\n- 通过 `get_task_mm()` 安全获取 `mm_struct`，防止进程退出导致悬空指针。\n- 所有 `mm_struct` 和 `task_struct` 的引用均正确配对（`get`/`put`）。\n\n## 4. 依赖关系\n\n- **内核头文件依赖**：\n  - `<linux/mm.h>` 相关：`hugetlb.h`, `highmem.h`, `page_idle.h`, `pagewalk.h`, `sched/mm.h`\n  - `<linux/mmu_notifier.h>`：用于内存映射变更通知（虽未直接使用，但为 DAMON 整体架构所需）\n  - `<asm-generic/mman-common.h>`：内存管理常量\n- **DAMON 内部依赖**：\n  - `\"ops-common.h\"`：提供 `damon_new_region()`, `damon_add_region()` 等通用操作\n  - 依赖 DAMON 核心框架的 `damon_ctx`, `damon_target`, `damon_region` 等结构定义\n- **KUnit 测试支持**：\n  - `CONFIG_DAMON_VADDR_KUNIT_TEST` 宏用于测试时调整 `DAMON_MIN_REGION` 为 1，便于验证逻辑\n\n## 5. 使用场景\n\n- **DAMON 虚拟地址监控模式初始化**：当用户通过 DAMON 接口（如 debugfs 或 tracepoint）启动对一组进程的内存访问模式监控时，DAMON 核心调用 `damon_va_init()` 为每个目标进程构建初始监控区域。\n- **内存优化工具基础**：为 `damo`（DAMON 用户空间工具）等提供底层支持，用于识别冷热内存、指导内存回收（如 `reclaim`）、透明大页（THP）优化等。\n- **低开销内存行为分析**：适用于需要长期、低性能影响地监控进程内存访问模式的场景，如云环境中的资源调度、性能剖析等。\n- **自适应内存监控起点**：所生成的初始区域将作为 DAMON 自适应区域调整机制（合并/分裂）的起点，在后续监控周期中动态优化区域划分。",
      "similarity": 0.5910128355026245,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/damon/vaddr.c",
          "start_line": 64,
          "end_line": 170,
          "content": [
            "static int damon_va_evenly_split_region(struct damon_target *t,",
            "\t\tstruct damon_region *r, unsigned int nr_pieces)",
            "{",
            "\tunsigned long sz_orig, sz_piece, orig_end;",
            "\tstruct damon_region *n = NULL, *next;",
            "\tunsigned long start;",
            "\tunsigned int i;",
            "",
            "\tif (!r || !nr_pieces)",
            "\t\treturn -EINVAL;",
            "",
            "\torig_end = r->ar.end;",
            "\tsz_orig = damon_sz_region(r);",
            "\tsz_piece = ALIGN_DOWN(sz_orig / nr_pieces, DAMON_MIN_REGION);",
            "",
            "\tif (!sz_piece)",
            "\t\treturn -EINVAL;",
            "",
            "\tr->ar.end = r->ar.start + sz_piece;",
            "\tnext = damon_next_region(r);",
            "\tfor (start = r->ar.end, i = 1; i < nr_pieces; start += sz_piece, i++) {",
            "\t\tn = damon_new_region(start, start + sz_piece);",
            "\t\tif (!n)",
            "\t\t\treturn -ENOMEM;",
            "\t\tdamon_insert_region(n, r, next, t);",
            "\t\tr = n;",
            "\t}",
            "\t/* complement last region for possible rounding error */",
            "\tif (n)",
            "\t\tn->ar.end = orig_end;",
            "",
            "\treturn 0;",
            "}",
            "static unsigned long sz_range(struct damon_addr_range *r)",
            "{",
            "\treturn r->end - r->start;",
            "}",
            "static int __damon_va_three_regions(struct mm_struct *mm,",
            "\t\t\t\t       struct damon_addr_range regions[3])",
            "{",
            "\tstruct damon_addr_range first_gap = {0}, second_gap = {0};",
            "\tVMA_ITERATOR(vmi, mm, 0);",
            "\tstruct vm_area_struct *vma, *prev = NULL;",
            "\tunsigned long start;",
            "",
            "\t/*",
            "\t * Find the two biggest gaps so that first_gap > second_gap > others.",
            "\t * If this is too slow, it can be optimised to examine the maple",
            "\t * tree gaps.",
            "\t */",
            "\trcu_read_lock();",
            "\tfor_each_vma(vmi, vma) {",
            "\t\tunsigned long gap;",
            "",
            "\t\tif (!prev) {",
            "\t\t\tstart = vma->vm_start;",
            "\t\t\tgoto next;",
            "\t\t}",
            "\t\tgap = vma->vm_start - prev->vm_end;",
            "",
            "\t\tif (gap > sz_range(&first_gap)) {",
            "\t\t\tsecond_gap = first_gap;",
            "\t\t\tfirst_gap.start = prev->vm_end;",
            "\t\t\tfirst_gap.end = vma->vm_start;",
            "\t\t} else if (gap > sz_range(&second_gap)) {",
            "\t\t\tsecond_gap.start = prev->vm_end;",
            "\t\t\tsecond_gap.end = vma->vm_start;",
            "\t\t}",
            "next:",
            "\t\tprev = vma;",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\tif (!sz_range(&second_gap) || !sz_range(&first_gap))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Sort the two biggest gaps by address */",
            "\tif (first_gap.start > second_gap.start)",
            "\t\tswap(first_gap, second_gap);",
            "",
            "\t/* Store the result */",
            "\tregions[0].start = ALIGN(start, DAMON_MIN_REGION);",
            "\tregions[0].end = ALIGN(first_gap.start, DAMON_MIN_REGION);",
            "\tregions[1].start = ALIGN(first_gap.end, DAMON_MIN_REGION);",
            "\tregions[1].end = ALIGN(second_gap.start, DAMON_MIN_REGION);",
            "\tregions[2].start = ALIGN(second_gap.end, DAMON_MIN_REGION);",
            "\tregions[2].end = ALIGN(prev->vm_end, DAMON_MIN_REGION);",
            "",
            "\treturn 0;",
            "}",
            "static int damon_va_three_regions(struct damon_target *t,",
            "\t\t\t\tstruct damon_addr_range regions[3])",
            "{",
            "\tstruct mm_struct *mm;",
            "\tint rc;",
            "",
            "\tmm = damon_get_mm(t);",
            "\tif (!mm)",
            "\t\treturn -EINVAL;",
            "",
            "\tmmap_read_lock(mm);",
            "\trc = __damon_va_three_regions(mm, regions);",
            "\tmmap_read_unlock(mm);",
            "",
            "\tmmput(mm);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "damon_va_evenly_split_region, sz_range, __damon_va_three_regions, damon_va_three_regions",
          "description": "实现将监控区域均分、计算范围大小及寻找最大空闲间隙的函数，核心功能是通过遍历VMA找到两个最大空闲区间用于后续监控区域划分。",
          "similarity": 0.5856953859329224
        },
        {
          "chunk_id": 4,
          "file_path": "mm/damon/vaddr.c",
          "start_line": 503,
          "end_line": 605,
          "content": [
            "static int damon_young_hugetlb_entry(pte_t *pte, unsigned long hmask,",
            "\t\t\t\t     unsigned long addr, unsigned long end,",
            "\t\t\t\t     struct mm_walk *walk)",
            "{",
            "\tstruct damon_young_walk_private *priv = walk->private;",
            "\tstruct hstate *h = hstate_vma(walk->vma);",
            "\tstruct folio *folio;",
            "\tspinlock_t *ptl;",
            "\tpte_t entry;",
            "",
            "\tptl = huge_pte_lock(h, walk->mm, pte);",
            "\tentry = huge_ptep_get(pte);",
            "\tif (!pte_present(entry))",
            "\t\tgoto out;",
            "",
            "\tfolio = pfn_folio(pte_pfn(entry));",
            "\tfolio_get(folio);",
            "",
            "\tif (pte_young(entry) || !folio_test_idle(folio) ||",
            "\t    mmu_notifier_test_young(walk->mm, addr))",
            "\t\tpriv->young = true;",
            "\t*priv->folio_sz = huge_page_size(h);",
            "",
            "\tfolio_put(folio);",
            "",
            "out:",
            "\tspin_unlock(ptl);",
            "\treturn 0;",
            "}",
            "static bool damon_va_young(struct mm_struct *mm, unsigned long addr,",
            "\t\tunsigned long *folio_sz)",
            "{",
            "\tstruct damon_young_walk_private arg = {",
            "\t\t.folio_sz = folio_sz,",
            "\t\t.young = false,",
            "\t};",
            "",
            "\tmmap_read_lock(mm);",
            "\twalk_page_range(mm, addr, addr + 1, &damon_young_ops, &arg);",
            "\tmmap_read_unlock(mm);",
            "\treturn arg.young;",
            "}",
            "static void __damon_va_check_access(struct mm_struct *mm,",
            "\t\t\t\tstruct damon_region *r, bool same_target)",
            "{",
            "\tstatic unsigned long last_addr;",
            "\tstatic unsigned long last_folio_sz = PAGE_SIZE;",
            "\tstatic bool last_accessed;",
            "",
            "\t/* If the region is in the last checked page, reuse the result */",
            "\tif (same_target && (ALIGN_DOWN(last_addr, last_folio_sz) ==",
            "\t\t\t\tALIGN_DOWN(r->sampling_addr, last_folio_sz))) {",
            "\t\tif (last_accessed)",
            "\t\t\tr->nr_accesses++;",
            "\t\treturn;",
            "\t}",
            "",
            "\tlast_accessed = damon_va_young(mm, r->sampling_addr, &last_folio_sz);",
            "\tif (last_accessed)",
            "\t\tr->nr_accesses++;",
            "",
            "\tlast_addr = r->sampling_addr;",
            "}",
            "static unsigned int damon_va_check_accesses(struct damon_ctx *ctx)",
            "{",
            "\tstruct damon_target *t;",
            "\tstruct mm_struct *mm;",
            "\tstruct damon_region *r;",
            "\tunsigned int max_nr_accesses = 0;",
            "\tbool same_target;",
            "",
            "\tdamon_for_each_target(t, ctx) {",
            "\t\tmm = damon_get_mm(t);",
            "\t\tif (!mm)",
            "\t\t\tcontinue;",
            "\t\tsame_target = false;",
            "\t\tdamon_for_each_region(r, t) {",
            "\t\t\t__damon_va_check_access(mm, r, same_target);",
            "\t\t\tmax_nr_accesses = max(r->nr_accesses, max_nr_accesses);",
            "\t\t\tsame_target = true;",
            "\t\t}",
            "\t\tmmput(mm);",
            "\t}",
            "",
            "\treturn max_nr_accesses;",
            "}",
            "static bool damon_va_target_valid(struct damon_target *t)",
            "{",
            "\tstruct task_struct *task;",
            "",
            "\ttask = damon_get_task_struct(t);",
            "\tif (task) {",
            "\t\tput_task_struct(task);",
            "\t\treturn true;",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static unsigned long damos_madvise(struct damon_target *target,",
            "\t\tstruct damon_region *r, int behavior)",
            "{",
            "\treturn 0;",
            "}"
          ],
          "function_name": "damon_young_hugetlb_entry, damon_va_young, __damon_va_check_access, damon_va_check_accesses, damon_va_target_valid, damos_madvise",
          "description": "检查页面访问状态及统计访问次数的函数，核心功能是通过遍历内存区域判断页面是否被访问并更新监控数据。",
          "similarity": 0.5800252556800842
        },
        {
          "chunk_id": 0,
          "file_path": "mm/damon/vaddr.c",
          "start_line": 1,
          "end_line": 63,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * DAMON Primitives for Virtual Address Spaces",
            " *",
            " * Author: SeongJae Park <sjpark@amazon.de>",
            " */",
            "",
            "#define pr_fmt(fmt) \"damon-va: \" fmt",
            "",
            "#include <asm-generic/mman-common.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/pagewalk.h>",
            "#include <linux/sched/mm.h>",
            "",
            "#include \"ops-common.h\"",
            "",
            "#ifdef CONFIG_DAMON_VADDR_KUNIT_TEST",
            "#undef DAMON_MIN_REGION",
            "#define DAMON_MIN_REGION 1",
            "#endif",
            "",
            "/*",
            " * 't->pid' should be the pointer to the relevant 'struct pid' having reference",
            " * count.  Caller must put the returned task, unless it is NULL.",
            " */",
            "static inline struct task_struct *damon_get_task_struct(struct damon_target *t)",
            "{",
            "\treturn get_pid_task(t->pid, PIDTYPE_PID);",
            "}",
            "",
            "/*",
            " * Get the mm_struct of the given target",
            " *",
            " * Caller _must_ put the mm_struct after use, unless it is NULL.",
            " *",
            " * Returns the mm_struct of the target on success, NULL on failure",
            " */",
            "static struct mm_struct *damon_get_mm(struct damon_target *t)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct mm_struct *mm;",
            "",
            "\ttask = damon_get_task_struct(t);",
            "\tif (!task)",
            "\t\treturn NULL;",
            "",
            "\tmm = get_task_mm(task);",
            "\tput_task_struct(task);",
            "\treturn mm;",
            "}",
            "",
            "/*",
            " * Functions for the initial monitoring target regions construction",
            " */",
            "",
            "/*",
            " * Size-evenly split a region into 'nr_pieces' small regions",
            " *",
            " * Returns 0 on success, or negative error code otherwise.",
            " */"
          ],
          "function_name": null,
          "description": "定义获取进程任务结构体和MM结构体的辅助函数，并声明用于初始监控区域构造的相关函数，核心功能是提供虚拟地址空间监控的基本支持。",
          "similarity": 0.526618242263794
        },
        {
          "chunk_id": 5,
          "file_path": "mm/damon/vaddr.c",
          "start_line": 632,
          "end_line": 723,
          "content": [
            "static unsigned long damos_madvise(struct damon_target *target,",
            "\t\tstruct damon_region *r, int behavior)",
            "{",
            "\tstruct mm_struct *mm;",
            "\tunsigned long start = PAGE_ALIGN(r->ar.start);",
            "\tunsigned long len = PAGE_ALIGN(damon_sz_region(r));",
            "\tunsigned long applied;",
            "",
            "\tmm = damon_get_mm(target);",
            "\tif (!mm)",
            "\t\treturn 0;",
            "",
            "\tapplied = do_madvise(mm, start, len, behavior) ? 0 : len;",
            "\tmmput(mm);",
            "",
            "\treturn applied;",
            "}",
            "static unsigned long damon_va_apply_scheme(struct damon_ctx *ctx,",
            "\t\tstruct damon_target *t, struct damon_region *r,",
            "\t\tstruct damos *scheme)",
            "{",
            "\tint madv_action;",
            "",
            "\tswitch (scheme->action) {",
            "\tcase DAMOS_WILLNEED:",
            "\t\tmadv_action = MADV_WILLNEED;",
            "\t\tbreak;",
            "\tcase DAMOS_COLD:",
            "\t\tmadv_action = MADV_COLD;",
            "\t\tbreak;",
            "\tcase DAMOS_PAGEOUT:",
            "\t\tmadv_action = MADV_PAGEOUT;",
            "\t\tbreak;",
            "\tcase DAMOS_HUGEPAGE:",
            "\t\tmadv_action = MADV_HUGEPAGE;",
            "\t\tbreak;",
            "\tcase DAMOS_NOHUGEPAGE:",
            "\t\tmadv_action = MADV_NOHUGEPAGE;",
            "\t\tbreak;",
            "\tcase DAMOS_STAT:",
            "\t\treturn 0;",
            "\tdefault:",
            "\t\t/*",
            "\t\t * DAMOS actions that are not yet supported by 'vaddr'.",
            "\t\t */",
            "\t\treturn 0;",
            "\t}",
            "",
            "\treturn damos_madvise(t, r, madv_action);",
            "}",
            "static int damon_va_scheme_score(struct damon_ctx *context,",
            "\t\tstruct damon_target *t, struct damon_region *r,",
            "\t\tstruct damos *scheme)",
            "{",
            "",
            "\tswitch (scheme->action) {",
            "\tcase DAMOS_PAGEOUT:",
            "\t\treturn damon_cold_score(context, r, scheme);",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn DAMOS_MAX_SCORE;",
            "}",
            "static int __init damon_va_initcall(void)",
            "{",
            "\tstruct damon_operations ops = {",
            "\t\t.id = DAMON_OPS_VADDR,",
            "\t\t.init = damon_va_init,",
            "\t\t.update = damon_va_update,",
            "\t\t.prepare_access_checks = damon_va_prepare_access_checks,",
            "\t\t.check_accesses = damon_va_check_accesses,",
            "\t\t.reset_aggregated = NULL,",
            "\t\t.target_valid = damon_va_target_valid,",
            "\t\t.cleanup = NULL,",
            "\t\t.apply_scheme = damon_va_apply_scheme,",
            "\t\t.get_scheme_score = damon_va_scheme_score,",
            "\t};",
            "\t/* ops for fixed virtual address ranges */",
            "\tstruct damon_operations ops_fvaddr = ops;",
            "\tint err;",
            "",
            "\t/* Don't set the monitoring target regions for the entire mapping */",
            "\tops_fvaddr.id = DAMON_OPS_FVADDR;",
            "\tops_fvaddr.init = NULL;",
            "\tops_fvaddr.update = NULL;",
            "",
            "\terr = damon_register_ops(&ops);",
            "\tif (err)",
            "\t\treturn err;",
            "\treturn damon_register_ops(&ops_fvaddr);",
            "};"
          ],
          "function_name": "damos_madvise, damon_va_apply_scheme, damon_va_scheme_score, damon_va_initcall",
          "description": "该代码实现基于虚拟地址的内存优化策略管理，主要功能包括：  \n1. `damos_madvise` 和 `damon_va_apply_scheme` 通过 `madvise` 系统调用对内存区域应用特定行为（如预读、冷页迁移等），`damon_va_scheme_score` 根据策略动态计算区域评分；  \n2. `damon_va_initcall` 注册虚拟地址范围监控操作集，支持两种模式（普通/固定范围），关联策略应用与评分逻辑；  \n3. 代码上下文不完整，依赖外部未展示的 `do_madvise`、`damon_cold_score` 等函数及 `damon_operations` 操作接口。",
          "similarity": 0.5263000130653381
        },
        {
          "chunk_id": 2,
          "file_path": "mm/damon/vaddr.c",
          "start_line": 235,
          "end_line": 358,
          "content": [
            "static void __damon_va_init_regions(struct damon_ctx *ctx,",
            "\t\t\t\t     struct damon_target *t)",
            "{",
            "\tstruct damon_target *ti;",
            "\tstruct damon_region *r;",
            "\tstruct damon_addr_range regions[3];",
            "\tunsigned long sz = 0, nr_pieces;",
            "\tint i, tidx = 0;",
            "",
            "\tif (damon_va_three_regions(t, regions)) {",
            "\t\tdamon_for_each_target(ti, ctx) {",
            "\t\t\tif (ti == t)",
            "\t\t\t\tbreak;",
            "\t\t\ttidx++;",
            "\t\t}",
            "\t\tpr_debug(\"Failed to get three regions of %dth target\\n\", tidx);",
            "\t\treturn;",
            "\t}",
            "",
            "\tfor (i = 0; i < 3; i++)",
            "\t\tsz += regions[i].end - regions[i].start;",
            "\tif (ctx->attrs.min_nr_regions)",
            "\t\tsz /= ctx->attrs.min_nr_regions;",
            "\tif (sz < DAMON_MIN_REGION)",
            "\t\tsz = DAMON_MIN_REGION;",
            "",
            "\t/* Set the initial three regions of the target */",
            "\tfor (i = 0; i < 3; i++) {",
            "\t\tr = damon_new_region(regions[i].start, regions[i].end);",
            "\t\tif (!r) {",
            "\t\t\tpr_err(\"%d'th init region creation failed\\n\", i);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tdamon_add_region(r, t);",
            "",
            "\t\tnr_pieces = (regions[i].end - regions[i].start) / sz;",
            "\t\tdamon_va_evenly_split_region(t, r, nr_pieces);",
            "\t}",
            "}",
            "static void damon_va_init(struct damon_ctx *ctx)",
            "{",
            "\tstruct damon_target *t;",
            "",
            "\tdamon_for_each_target(t, ctx) {",
            "\t\t/* the user may set the target regions as they want */",
            "\t\tif (!damon_nr_regions(t))",
            "\t\t\t__damon_va_init_regions(ctx, t);",
            "\t}",
            "}",
            "static void damon_va_update(struct damon_ctx *ctx)",
            "{",
            "\tstruct damon_addr_range three_regions[3];",
            "\tstruct damon_target *t;",
            "",
            "\tdamon_for_each_target(t, ctx) {",
            "\t\tif (damon_va_three_regions(t, three_regions))",
            "\t\t\tcontinue;",
            "\t\tdamon_set_regions(t, three_regions, 3);",
            "\t}",
            "}",
            "static int damon_mkold_pmd_entry(pmd_t *pmd, unsigned long addr,",
            "\t\tunsigned long next, struct mm_walk *walk)",
            "{",
            "\tpte_t *pte;",
            "\tpmd_t pmde;",
            "\tspinlock_t *ptl;",
            "",
            "\tif (pmd_trans_huge(pmdp_get(pmd))) {",
            "\t\tptl = pmd_lock(walk->mm, pmd);",
            "\t\tpmde = pmdp_get(pmd);",
            "",
            "\t\tif (!pmd_present(pmde)) {",
            "\t\t\tspin_unlock(ptl);",
            "\t\t\treturn 0;",
            "\t\t}",
            "",
            "\t\tif (pmd_trans_huge(pmde)) {",
            "\t\t\tdamon_pmdp_mkold(pmd, walk->vma, addr);",
            "\t\t\tspin_unlock(ptl);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tspin_unlock(ptl);",
            "\t}",
            "",
            "\tpte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);",
            "\tif (!pte) {",
            "\t\twalk->action = ACTION_AGAIN;",
            "\t\treturn 0;",
            "\t}",
            "\tif (!pte_present(ptep_get(pte)))",
            "\t\tgoto out;",
            "\tdamon_ptep_mkold(pte, walk->vma, addr);",
            "out:",
            "\tpte_unmap_unlock(pte, ptl);",
            "\treturn 0;",
            "}",
            "static void damon_hugetlb_mkold(pte_t *pte, struct mm_struct *mm,",
            "\t\t\t\tstruct vm_area_struct *vma, unsigned long addr)",
            "{",
            "\tbool referenced = false;",
            "\tpte_t entry = huge_ptep_get(pte);",
            "\tstruct folio *folio = pfn_folio(pte_pfn(entry));",
            "\tunsigned long psize = huge_page_size(hstate_vma(vma));",
            "",
            "\tfolio_get(folio);",
            "",
            "\tif (pte_young(entry)) {",
            "\t\treferenced = true;",
            "\t\tentry = pte_mkold(entry);",
            "\t\tset_huge_pte_at(mm, addr, pte, entry, psize);",
            "\t}",
            "",
            "#ifdef CONFIG_MMU_NOTIFIER",
            "\tif (mmu_notifier_clear_young(mm, addr,",
            "\t\t\t\t     addr + huge_page_size(hstate_vma(vma))))",
            "\t\treferenced = true;",
            "#endif /* CONFIG_MMU_NOTIFIER */",
            "",
            "\tif (referenced)",
            "\t\tfolio_set_young(folio);",
            "",
            "\tfolio_set_idle(folio);",
            "\tfolio_put(folio);",
            "}"
          ],
          "function_name": "__damon_va_init_regions, damon_va_init, damon_va_update, damon_mkold_pmd_entry, damon_hugetlb_mkold",
          "description": "初始化和更新监控区域的函数，以及处理大页表项的mkold操作，核心功能是构建初始监控区域并维护页面年轻状态标记。",
          "similarity": 0.5150203108787537
        }
      ]
    },
    {
      "source_file": "mm/damon/core.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:46:00\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `damon\\core.c`\n\n---\n\n# `damon/core.c` 技术文档\n\n## 1. 文件概述\n\n`damon/core.c` 是 Linux 内核中 **Data Access MONitor (DAMON)** 子系统的核心实现文件。DAMON 是一个轻量级、可扩展的内存访问监控框架，用于动态跟踪用户空间或内核空间中内存区域的访问模式。该文件提供了 DAMON 的基础数据结构管理、操作集注册机制、区域（region）生命周期控制、目标地址范围设置以及数据访问模式方案（scheme）和过滤器（filter）的创建与销毁等核心功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct damon_region`：表示被监控的连续虚拟内存区域，包含起止地址、访问次数、年龄等元数据。\n- `struct damon_target`：表示一个被监控的目标（如进程地址空间），包含区域链表。\n- `struct damon_ctx`：DAMON 上下文，持有操作集（ops）、目标列表、方案（schemes）等运行时状态。\n- `struct damos`：DAMON Scheme，定义基于访问模式触发的操作（如内存回收、迁移等）。\n- `struct damos_filter`：用于在应用 scheme 前对目标进行过滤（如按内存类型、VMA 属性等）。\n- `struct damon_operations`：抽象不同监控后端（如针对用户空间、内核空间、虚拟机等）的操作接口。\n\n### 主要函数\n- **操作集管理**：\n  - `damon_register_ops()`：注册一个 `damon_operations` 实例。\n  - `damon_select_ops()`：为指定上下文选择已注册的操作集。\n  - `damon_is_registered_ops()`：检查指定 ID 的操作集是否已注册。\n- **区域管理**：\n  - `damon_new_region()` / `damon_free_region()`：分配/释放区域对象（使用 slab 缓存优化）。\n  - `damon_add_region()` / `damon_destroy_region()`：将区域加入目标或从目标中移除并释放。\n  - `damon_set_regions()`：根据给定的地址范围数组更新目标的监控区域集合。\n- **方案与过滤器管理**：\n  - `damon_new_scheme()`：创建新的 DAMON 方案。\n  - `damos_new_filter()` / `damos_destroy_filter()`：创建/销毁方案过滤器。\n  - `damos_add_filter()`：将过滤器添加到方案中。\n- **辅助函数**：\n  - `damon_intersect()`：判断两个地址范围是否相交。\n  - `damon_fill_regions_holes()`：在相邻区域之间填充空洞以形成连续覆盖。\n\n## 3. 关键实现\n\n### 操作集注册机制\n- 使用全局数组 `damon_registered_ops[NR_DAMON_OPS]` 存储已注册的操作集。\n- 通过 `damon_ops_lock` 互斥锁保护并发访问。\n- 注册时检查 ID 是否有效且未被占用；选择操作集时验证其存在性。\n- 支持运行时动态注册不同监控后端（如 `DAMON_OPS_VADDR`, `DAMON_OPS_FVADDR` 等）。\n\n### 区域管理与对齐\n- 所有区域通过专用 slab 缓存 `damon_region_cache` 分配，提升性能。\n- 在 `damon_set_regions()` 中，新区域的边界会按 `DAMON_MIN_REGION` 对齐（通常为页大小），确保最小监控粒度。\n- 区域更新逻辑分为两步：\n  1. 移除与新范围无交集的旧区域；\n  2. 对每个新范围：\n     - 若无交集区域，则新建对齐后的区域；\n     - 若有交集区域，则扩展首尾区域边界，并调用 `damon_fill_regions_holes()` 填补中间空洞，保证连续覆盖。\n\n### 内存安全与并发控制\n- 全局 `damon_lock` 用于保护 DAMON 上下文的运行状态（如 `nr_running_ctxs` 和 `running_exclusive_ctxs`）。\n- 区域和过滤器的增删均使用标准内核链表操作，并维护计数（如 `t->nr_regions`）。\n- 所有内存分配使用 `GFP_KERNEL`，适用于进程上下文。\n\n### 可测试性支持\n- 通过 `CONFIG_DAMON_KUNIT_TEST` 宏可在测试时将 `DAMON_MIN_REGION` 设为 1，便于单元测试精确控制区域边界。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/damon.h>`：DAMON 核心数据结构和 API 定义。\n  - `<linux/kthread.h>`：用于后台监控线程（kdamond）管理。\n  - `<linux/mm.h>`：内存管理相关定义（如页对齐宏）。\n  - `<linux/slab.h>`：slab 分配器接口。\n  - `<trace/events/damon.h>`：DAMON 跟踪点定义（用于 ftrace）。\n- **模块依赖**：\n  - 依赖底层监控操作实现（如 `damon/vaddr.c` 提供用户空间虚拟地址监控 ops）。\n  - 被 DAMON 用户接口模块（如 `sysfs` 或 `debugfs` 接口）调用以配置监控上下文。\n  - 与内存管理子系统（mm）紧密集成，用于访问检测和内存操作（如 madvise）。\n\n## 5. 使用场景\n\n- **内存访问模式分析**：为内存管理优化（如 THP、内存回收、NUMA 迁移）提供实时访问热度数据。\n- **自适应内存管理策略**：通过 `damos` 方案自动执行基于访问模式的操作（如对冷内存调用 `MADV_PAGEOUT`）。\n- **性能剖析工具**：作为 eBPF、perf 等工具的数据源，分析应用内存行为。\n- **云环境资源优化**：在虚拟化或容器环境中识别低效内存使用，实现自动压缩或迁移。\n- **内核子系统集成**：其他内核组件（如 DAMOS-based memory reclaim）可复用 DAMON 的监控能力，无需重复实现访问跟踪逻辑。",
      "similarity": 0.5860790014266968,
      "chunks": [
        {
          "chunk_id": 10,
          "file_path": "mm/damon/core.c",
          "start_line": 1538,
          "end_line": 1587,
          "content": [
            "static int walk_system_ram(struct resource *res, void *arg)",
            "{",
            "\tstruct damon_system_ram_region *a = arg;",
            "",
            "\tif (a->end - a->start < resource_size(res)) {",
            "\t\ta->start = res->start;",
            "\t\ta->end = res->end;",
            "\t}",
            "\treturn 0;",
            "}",
            "static bool damon_find_biggest_system_ram(unsigned long *start,",
            "\t\t\t\t\t\tunsigned long *end)",
            "",
            "{",
            "\tstruct damon_system_ram_region arg = {};",
            "",
            "\twalk_system_ram_res(0, ULONG_MAX, &arg, walk_system_ram);",
            "\tif (arg.end <= arg.start)",
            "\t\treturn false;",
            "",
            "\t*start = arg.start;",
            "\t*end = arg.end;",
            "\treturn true;",
            "}",
            "int damon_set_region_biggest_system_ram_default(struct damon_target *t,",
            "\t\t\tunsigned long *start, unsigned long *end)",
            "{",
            "\tstruct damon_addr_range addr_range;",
            "",
            "\tif (*start > *end)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!*start && !*end &&",
            "\t\t!damon_find_biggest_system_ram(start, end))",
            "\t\treturn -EINVAL;",
            "",
            "\taddr_range.start = *start;",
            "\taddr_range.end = *end;",
            "\treturn damon_set_regions(t, &addr_range, 1);",
            "}",
            "static int __init damon_init(void)",
            "{",
            "\tdamon_region_cache = KMEM_CACHE(damon_region, 0);",
            "\tif (unlikely(!damon_region_cache)) {",
            "\t\tpr_err(\"creating damon_region_cache fails\\n\");",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "walk_system_ram, damon_find_biggest_system_ram, damon_set_region_biggest_system_ram_default, damon_init",
          "description": "该代码块核心功能是识别并设置系统中最大的连续可用内存区域作为DAMON监控目标的默认范围。`walk_system_ram`遍历内存资源以记录最大区域，`damon_find_biggest_system_ram`通过遍历发现最大内存区间，`damon_set_region_biggest_system_ram_default`负责将找到的区间设置到指定目标。由于`walk_system_ram_res`和`damon_set_regions`等关键函数未在片段中定义，上下文信息不完整。",
          "similarity": 0.5710371732711792
        },
        {
          "chunk_id": 1,
          "file_path": "mm/damon/core.c",
          "start_line": 35,
          "end_line": 186,
          "content": [
            "static bool __damon_is_registered_ops(enum damon_ops_id id)",
            "{",
            "\tstruct damon_operations empty_ops = {};",
            "",
            "\tif (!memcmp(&empty_ops, &damon_registered_ops[id], sizeof(empty_ops)))",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "bool damon_is_registered_ops(enum damon_ops_id id)",
            "{",
            "\tbool registered;",
            "",
            "\tif (id >= NR_DAMON_OPS)",
            "\t\treturn false;",
            "\tmutex_lock(&damon_ops_lock);",
            "\tregistered = __damon_is_registered_ops(id);",
            "\tmutex_unlock(&damon_ops_lock);",
            "\treturn registered;",
            "}",
            "int damon_register_ops(struct damon_operations *ops)",
            "{",
            "\tint err = 0;",
            "",
            "\tif (ops->id >= NR_DAMON_OPS)",
            "\t\treturn -EINVAL;",
            "\tmutex_lock(&damon_ops_lock);",
            "\t/* Fail for already registered ops */",
            "\tif (__damon_is_registered_ops(ops->id)) {",
            "\t\terr = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "\tdamon_registered_ops[ops->id] = *ops;",
            "out:",
            "\tmutex_unlock(&damon_ops_lock);",
            "\treturn err;",
            "}",
            "int damon_select_ops(struct damon_ctx *ctx, enum damon_ops_id id)",
            "{",
            "\tint err = 0;",
            "",
            "\tif (id >= NR_DAMON_OPS)",
            "\t\treturn -EINVAL;",
            "",
            "\tmutex_lock(&damon_ops_lock);",
            "\tif (!__damon_is_registered_ops(id))",
            "\t\terr = -EINVAL;",
            "\telse",
            "\t\tctx->ops = damon_registered_ops[id];",
            "\tmutex_unlock(&damon_ops_lock);",
            "\treturn err;",
            "}",
            "void damon_add_region(struct damon_region *r, struct damon_target *t)",
            "{",
            "\tlist_add_tail(&r->list, &t->regions_list);",
            "\tt->nr_regions++;",
            "}",
            "static void damon_del_region(struct damon_region *r, struct damon_target *t)",
            "{",
            "\tlist_del(&r->list);",
            "\tt->nr_regions--;",
            "}",
            "static void damon_free_region(struct damon_region *r)",
            "{",
            "\tkmem_cache_free(damon_region_cache, r);",
            "}",
            "void damon_destroy_region(struct damon_region *r, struct damon_target *t)",
            "{",
            "\tdamon_del_region(r, t);",
            "\tdamon_free_region(r);",
            "}",
            "static bool damon_intersect(struct damon_region *r,",
            "\t\tstruct damon_addr_range *re)",
            "{",
            "\treturn !(r->ar.end <= re->start || re->end <= r->ar.start);",
            "}",
            "static int damon_fill_regions_holes(struct damon_region *first,",
            "\t\tstruct damon_region *last, struct damon_target *t)",
            "{",
            "\tstruct damon_region *r = first;",
            "",
            "\tdamon_for_each_region_from(r, t) {",
            "\t\tstruct damon_region *next, *newr;",
            "",
            "\t\tif (r == last)",
            "\t\t\tbreak;",
            "\t\tnext = damon_next_region(r);",
            "\t\tif (r->ar.end != next->ar.start) {",
            "\t\t\tnewr = damon_new_region(r->ar.end, next->ar.start);",
            "\t\t\tif (!newr)",
            "\t\t\t\treturn -ENOMEM;",
            "\t\t\tdamon_insert_region(newr, r, next, t);",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}",
            "int damon_set_regions(struct damon_target *t, struct damon_addr_range *ranges,",
            "\t\tunsigned int nr_ranges)",
            "{",
            "\tstruct damon_region *r, *next;",
            "\tunsigned int i;",
            "\tint err;",
            "",
            "\t/* Remove regions which are not in the new ranges */",
            "\tdamon_for_each_region_safe(r, next, t) {",
            "\t\tfor (i = 0; i < nr_ranges; i++) {",
            "\t\t\tif (damon_intersect(r, &ranges[i]))",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (i == nr_ranges)",
            "\t\t\tdamon_destroy_region(r, t);",
            "\t}",
            "",
            "\tr = damon_first_region(t);",
            "\t/* Add new regions or resize existing regions to fit in the ranges */",
            "\tfor (i = 0; i < nr_ranges; i++) {",
            "\t\tstruct damon_region *first = NULL, *last, *newr;",
            "\t\tstruct damon_addr_range *range;",
            "",
            "\t\trange = &ranges[i];",
            "\t\t/* Get the first/last regions intersecting with the range */",
            "\t\tdamon_for_each_region_from(r, t) {",
            "\t\t\tif (damon_intersect(r, range)) {",
            "\t\t\t\tif (!first)",
            "\t\t\t\t\tfirst = r;",
            "\t\t\t\tlast = r;",
            "\t\t\t}",
            "\t\t\tif (r->ar.start >= range->end)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (!first) {",
            "\t\t\t/* no region intersects with this range */",
            "\t\t\tnewr = damon_new_region(",
            "\t\t\t\t\tALIGN_DOWN(range->start,",
            "\t\t\t\t\t\tDAMON_MIN_REGION),",
            "\t\t\t\t\tALIGN(range->end, DAMON_MIN_REGION));",
            "\t\t\tif (!newr)",
            "\t\t\t\treturn -ENOMEM;",
            "\t\t\tdamon_insert_region(newr, damon_prev_region(r), r, t);",
            "\t\t} else {",
            "\t\t\t/* resize intersecting regions to fit in this range */",
            "\t\t\tfirst->ar.start = ALIGN_DOWN(range->start,",
            "\t\t\t\t\tDAMON_MIN_REGION);",
            "\t\t\tlast->ar.end = ALIGN(range->end, DAMON_MIN_REGION);",
            "",
            "\t\t\t/* fill possible holes in the range */",
            "\t\t\terr = damon_fill_regions_holes(first, last, t);",
            "\t\t\tif (err)",
            "\t\t\t\treturn err;",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__damon_is_registered_ops, damon_is_registered_ops, damon_register_ops, damon_select_ops, damon_add_region, damon_del_region, damon_free_region, damon_destroy_region, damon_intersect, damon_fill_regions_holes, damon_set_regions",
          "description": "提供操作注册与验证接口，实现区域增删改逻辑，支持动态调整监控范围并填充潜在空洞，用于维护监控区域集合。",
          "similarity": 0.5631309151649475
        },
        {
          "chunk_id": 8,
          "file_path": "mm/damon/core.c",
          "start_line": 1224,
          "end_line": 1331,
          "content": [
            "static void damon_split_regions_of(struct damon_target *t, int nr_subs)",
            "{",
            "\tstruct damon_region *r, *next;",
            "\tunsigned long sz_region, sz_sub = 0;",
            "\tint i;",
            "",
            "\tdamon_for_each_region_safe(r, next, t) {",
            "\t\tsz_region = damon_sz_region(r);",
            "",
            "\t\tfor (i = 0; i < nr_subs - 1 &&",
            "\t\t\t\tsz_region > 2 * DAMON_MIN_REGION; i++) {",
            "\t\t\t/*",
            "\t\t\t * Randomly select size of left sub-region to be at",
            "\t\t\t * least 10 percent and at most 90% of original region",
            "\t\t\t */",
            "\t\t\tsz_sub = ALIGN_DOWN(damon_rand(1, 10) *",
            "\t\t\t\t\tsz_region / 10, DAMON_MIN_REGION);",
            "\t\t\t/* Do not allow blank region */",
            "\t\t\tif (sz_sub == 0 || sz_sub >= sz_region)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tdamon_split_region_at(t, r, sz_sub);",
            "\t\t\tsz_region = sz_sub;",
            "\t\t}",
            "\t}",
            "}",
            "static void kdamond_split_regions(struct damon_ctx *ctx)",
            "{",
            "\tstruct damon_target *t;",
            "\tunsigned int nr_regions = 0;",
            "\tstatic unsigned int last_nr_regions;",
            "\tint nr_subregions = 2;",
            "",
            "\tdamon_for_each_target(t, ctx)",
            "\t\tnr_regions += damon_nr_regions(t);",
            "",
            "\tif (nr_regions > ctx->attrs.max_nr_regions / 2)",
            "\t\treturn;",
            "",
            "\t/* Maybe the middle of the region has different access frequency */",
            "\tif (last_nr_regions == nr_regions &&",
            "\t\t\tnr_regions < ctx->attrs.max_nr_regions / 3)",
            "\t\tnr_subregions = 3;",
            "",
            "\tdamon_for_each_target(t, ctx)",
            "\t\tdamon_split_regions_of(t, nr_subregions);",
            "",
            "\tlast_nr_regions = nr_regions;",
            "}",
            "static bool kdamond_need_stop(struct damon_ctx *ctx)",
            "{",
            "\tstruct damon_target *t;",
            "",
            "\tif (kthread_should_stop())",
            "\t\treturn true;",
            "",
            "\tif (!ctx->ops.target_valid)",
            "\t\treturn false;",
            "",
            "\tdamon_for_each_target(t, ctx) {",
            "\t\tif (ctx->ops.target_valid(t))",
            "\t\t\treturn false;",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "static unsigned long damos_wmark_metric_value(enum damos_wmark_metric metric)",
            "{",
            "\tstruct sysinfo i;",
            "",
            "\tswitch (metric) {",
            "\tcase DAMOS_WMARK_FREE_MEM_RATE:",
            "\t\tsi_meminfo(&i);",
            "\t\treturn i.freeram * 1000 / i.totalram;",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "static unsigned long damos_wmark_wait_us(struct damos *scheme)",
            "{",
            "\tunsigned long metric;",
            "",
            "\tif (scheme->wmarks.metric == DAMOS_WMARK_NONE)",
            "\t\treturn 0;",
            "",
            "\tmetric = damos_wmark_metric_value(scheme->wmarks.metric);",
            "\t/* higher than high watermark or lower than low watermark */",
            "\tif (metric > scheme->wmarks.high || scheme->wmarks.low > metric) {",
            "\t\tif (scheme->wmarks.activated)",
            "\t\t\tpr_debug(\"deactivate a scheme (%d) for %s wmark\\n\",",
            "\t\t\t\t\tscheme->action,",
            "\t\t\t\t\tmetric > scheme->wmarks.high ?",
            "\t\t\t\t\t\"high\" : \"low\");",
            "\t\tscheme->wmarks.activated = false;",
            "\t\treturn scheme->wmarks.interval;",
            "\t}",
            "",
            "\t/* inactive and higher than middle watermark */",
            "\tif ((scheme->wmarks.high >= metric && metric >= scheme->wmarks.mid) &&",
            "\t\t\t!scheme->wmarks.activated)",
            "\t\treturn scheme->wmarks.interval;",
            "",
            "\tif (!scheme->wmarks.activated)",
            "\t\tpr_debug(\"activate a scheme (%d)\\n\", scheme->action);",
            "\tscheme->wmarks.activated = true;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "damon_split_regions_of, kdamond_split_regions, kdamond_need_stop, damos_wmark_metric_value, damos_wmark_wait_us",
          "description": "根据子区域数拆分现有区域以平衡访问频率；等待系统水位标记（如空闲内存率）达到激活条件；根据水位阈值动态启用或禁用方案",
          "similarity": 0.5451337099075317
        },
        {
          "chunk_id": 4,
          "file_path": "mm/damon/core.c",
          "start_line": 660,
          "end_line": 760,
          "content": [
            "static int __damon_start(struct damon_ctx *ctx)",
            "{",
            "\tint err = -EBUSY;",
            "",
            "\tmutex_lock(&ctx->kdamond_lock);",
            "\tif (!ctx->kdamond) {",
            "\t\terr = 0;",
            "\t\treinit_completion(&ctx->kdamond_started);",
            "\t\tctx->kdamond = kthread_run(kdamond_fn, ctx, \"kdamond.%d\",",
            "\t\t\t\tnr_running_ctxs);",
            "\t\tif (IS_ERR(ctx->kdamond)) {",
            "\t\t\terr = PTR_ERR(ctx->kdamond);",
            "\t\t\tctx->kdamond = NULL;",
            "\t\t} else {",
            "\t\t\twait_for_completion(&ctx->kdamond_started);",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&ctx->kdamond_lock);",
            "",
            "\treturn err;",
            "}",
            "int damon_start(struct damon_ctx **ctxs, int nr_ctxs, bool exclusive)",
            "{",
            "\tint i;",
            "\tint err = 0;",
            "",
            "\tmutex_lock(&damon_lock);",
            "\tif ((exclusive && nr_running_ctxs) ||",
            "\t\t\t(!exclusive && running_exclusive_ctxs)) {",
            "\t\tmutex_unlock(&damon_lock);",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\tfor (i = 0; i < nr_ctxs; i++) {",
            "\t\terr = __damon_start(ctxs[i]);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "\t\tnr_running_ctxs++;",
            "\t}",
            "\tif (exclusive && nr_running_ctxs)",
            "\t\trunning_exclusive_ctxs = true;",
            "\tmutex_unlock(&damon_lock);",
            "",
            "\treturn err;",
            "}",
            "static int __damon_stop(struct damon_ctx *ctx)",
            "{",
            "\tstruct task_struct *tsk;",
            "",
            "\tmutex_lock(&ctx->kdamond_lock);",
            "\ttsk = ctx->kdamond;",
            "\tif (tsk) {",
            "\t\tget_task_struct(tsk);",
            "\t\tmutex_unlock(&ctx->kdamond_lock);",
            "\t\tkthread_stop_put(tsk);",
            "\t\treturn 0;",
            "\t}",
            "\tmutex_unlock(&ctx->kdamond_lock);",
            "",
            "\treturn -EPERM;",
            "}",
            "int damon_stop(struct damon_ctx **ctxs, int nr_ctxs)",
            "{",
            "\tint i, err = 0;",
            "",
            "\tfor (i = 0; i < nr_ctxs; i++) {",
            "\t\t/* nr_running_ctxs is decremented in kdamond_fn */",
            "\t\terr = __damon_stop(ctxs[i]);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "\t}",
            "\treturn err;",
            "}",
            "static void kdamond_reset_aggregated(struct damon_ctx *c)",
            "{",
            "\tstruct damon_target *t;",
            "\tunsigned int ti = 0;\t/* target's index */",
            "",
            "\tdamon_for_each_target(t, c) {",
            "\t\tstruct damon_region *r;",
            "",
            "\t\tdamon_for_each_region(r, t) {",
            "\t\t\ttrace_damon_aggregated(t, ti, r, damon_nr_regions(t));",
            "\t\t\tr->last_nr_accesses = r->nr_accesses;",
            "\t\t\tr->nr_accesses = 0;",
            "\t\t}",
            "\t\tti++;",
            "\t}",
            "}",
            "static bool __damos_valid_target(struct damon_region *r, struct damos *s)",
            "{",
            "\tunsigned long sz;",
            "",
            "\tsz = damon_sz_region(r);",
            "\treturn s->pattern.min_sz_region <= sz &&",
            "\t\tsz <= s->pattern.max_sz_region &&",
            "\t\ts->pattern.min_nr_accesses <= r->nr_accesses &&",
            "\t\tr->nr_accesses <= s->pattern.max_nr_accesses &&",
            "\t\ts->pattern.min_age_region <= r->age &&",
            "\t\tr->age <= s->pattern.max_age_region;",
            "}"
          ],
          "function_name": "__damon_start, damon_start, __damon_stop, damon_stop, kdamond_reset_aggregated, __damos_valid_target",
          "description": "控制监控上下文的启动/停止流程，包含线程管理与状态同步，提供聚合数据重置方法，用于验证监控区域是否符合应用策略条件。",
          "similarity": 0.5212609767913818
        },
        {
          "chunk_id": 5,
          "file_path": "mm/damon/core.c",
          "start_line": 801,
          "end_line": 904,
          "content": [
            "static bool damos_valid_target(struct damon_ctx *c, struct damon_target *t,",
            "\t\tstruct damon_region *r, struct damos *s)",
            "{",
            "\tbool ret = __damos_valid_target(r, s);",
            "",
            "\tif (!ret || !s->quota.esz || !c->ops.get_scheme_score)",
            "\t\treturn ret;",
            "",
            "\treturn c->ops.get_scheme_score(c, t, r, s) >= s->quota.min_score;",
            "}",
            "static bool damos_skip_charged_region(struct damon_target *t,",
            "\t\tstruct damon_region **rp, struct damos *s)",
            "{",
            "\tstruct damon_region *r = *rp;",
            "\tstruct damos_quota *quota = &s->quota;",
            "\tunsigned long sz_to_skip;",
            "",
            "\t/* Skip previously charged regions */",
            "\tif (quota->charge_target_from) {",
            "\t\tif (t != quota->charge_target_from)",
            "\t\t\treturn true;",
            "\t\tif (r == damon_last_region(t)) {",
            "\t\t\tquota->charge_target_from = NULL;",
            "\t\t\tquota->charge_addr_from = 0;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tif (quota->charge_addr_from &&",
            "\t\t\t\tr->ar.end <= quota->charge_addr_from)",
            "\t\t\treturn true;",
            "",
            "\t\tif (quota->charge_addr_from && r->ar.start <",
            "\t\t\t\tquota->charge_addr_from) {",
            "\t\t\tsz_to_skip = ALIGN_DOWN(quota->charge_addr_from -",
            "\t\t\t\t\tr->ar.start, DAMON_MIN_REGION);",
            "\t\t\tif (!sz_to_skip) {",
            "\t\t\t\tif (damon_sz_region(r) <= DAMON_MIN_REGION)",
            "\t\t\t\t\treturn true;",
            "\t\t\t\tsz_to_skip = DAMON_MIN_REGION;",
            "\t\t\t}",
            "\t\t\tdamon_split_region_at(t, r, sz_to_skip);",
            "\t\t\tr = damon_next_region(r);",
            "\t\t\t*rp = r;",
            "\t\t}",
            "\t\tquota->charge_target_from = NULL;",
            "\t\tquota->charge_addr_from = 0;",
            "\t}",
            "\treturn false;",
            "}",
            "static void damos_update_stat(struct damos *s,",
            "\t\tunsigned long sz_tried, unsigned long sz_applied)",
            "{",
            "\ts->stat.nr_tried++;",
            "\ts->stat.sz_tried += sz_tried;",
            "\tif (sz_applied)",
            "\t\ts->stat.nr_applied++;",
            "\ts->stat.sz_applied += sz_applied;",
            "}",
            "static bool __damos_filter_out(struct damon_ctx *ctx, struct damon_target *t,",
            "\t\tstruct damon_region *r, struct damos_filter *filter)",
            "{",
            "\tbool matched = false;",
            "\tstruct damon_target *ti;",
            "\tint target_idx = 0;",
            "\tunsigned long start, end;",
            "",
            "\tswitch (filter->type) {",
            "\tcase DAMOS_FILTER_TYPE_TARGET:",
            "\t\tdamon_for_each_target(ti, ctx) {",
            "\t\t\tif (ti == t)",
            "\t\t\t\tbreak;",
            "\t\t\ttarget_idx++;",
            "\t\t}",
            "\t\tmatched = target_idx == filter->target_idx;",
            "\t\tbreak;",
            "\tcase DAMOS_FILTER_TYPE_ADDR:",
            "\t\tstart = ALIGN_DOWN(filter->addr_range.start, DAMON_MIN_REGION);",
            "\t\tend = ALIGN_DOWN(filter->addr_range.end, DAMON_MIN_REGION);",
            "",
            "\t\t/* inside the range */",
            "\t\tif (start <= r->ar.start && r->ar.end <= end) {",
            "\t\t\tmatched = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t/* outside of the range */",
            "\t\tif (r->ar.end <= start || end <= r->ar.start) {",
            "\t\t\tmatched = false;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t/* start before the range and overlap */",
            "\t\tif (r->ar.start < start) {",
            "\t\t\tdamon_split_region_at(t, r, start - r->ar.start);",
            "\t\t\tmatched = false;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t/* start inside the range */",
            "\t\tdamon_split_region_at(t, r, end - r->ar.start);",
            "\t\tmatched = true;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn false;",
            "\t}",
            "",
            "\treturn matched == filter->matching;",
            "}"
          ],
          "function_name": "damos_valid_target, damos_skip_charged_region, damos_update_stat, __damos_filter_out",
          "description": "判断目标区域是否满足应用条件，若满足则根据评分策略筛选；跳过已充电区域以避免重复处理；记录应用统计信息；根据地址范围或目标索引过滤区域",
          "similarity": 0.5115982890129089
        }
      ]
    },
    {
      "source_file": "mm/mapping_dirty_helpers.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:37:26\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `mapping_dirty_helpers.c`\n\n---\n\n# mapping_dirty_helpers.c 技术文档\n\n## 1. 文件概述\n\n`mapping_dirty_helpers.c` 是 Linux 内核中用于管理共享映射（shared mapping）页面脏状态和写保护的核心辅助模块。该文件提供了一组基于页表遍历（pagewalk）机制的函数，用于在指定地址空间范围内对 PTE（页表项）执行写保护（write-protect）或清理脏位（clean dirty bit）操作，并高效地记录受影响的虚拟地址范围以进行 TLB 刷新和 MMU 通知。此功能主要用于内存管理子系统中的脏页跟踪、回写控制和 COW（Copy-On-Write）优化等场景。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct wp_walk`**  \n  页表遍历回调的私有上下文结构，用于记录：\n  - `range`：MMU 通知器作用范围\n  - `tlbflush_start` / `tlbflush_end`：需要刷新 TLB 的最小/最大虚拟地址\n  - `total`：被修改的 PTE 总数\n\n- **`struct clean_walk`**  \n  继承自 `wp_walk`，专用于 `clean_record_pte` 场景，额外包含：\n  - `bitmap_pgoff`：位图对应的起始页偏移\n  - `bitmap`：记录脏页偏移的位图\n  - `start` / `end`：位图中被设置位的最小/最大偏移（相对 `bitmap_pgoff`）\n\n### 主要函数\n\n- **`wp_pte()`**  \n  对可写的 PTE 执行写保护操作，更新 TLB 刷新范围并计数。\n\n- **`clean_record_pte()`**  \n  清除 PTE 的脏位，同时将对应页偏移记录到位图中，并更新 TLB 刷新范围。\n\n- **`wp_clean_pmd_entry()` / `wp_clean_pud_entry()`**  \n  处理 PMD/PUD 级别的巨页（huge page）条目，**不拆分巨页**，仅对可写或脏的巨页发出警告。\n\n- **`wp_clean_pre_vma()` / `wp_clean_post_vma()`**  \n  VMA 遍历前/后回调：初始化 MMU 通知、缓存刷新、TLB 刷新准备与执行。\n\n- **`wp_clean_test_walk()`**  \n  过滤不适用的 VMA：仅处理具有 `VM_SHARED | VM_MAYWRITE` 且非 `VM_HUGETLB` 的共享可写映射。\n\n- **`wp_shared_mapping_range()`**（未完整展示）  \n  公共接口函数，对指定地址空间范围内的所有 PTE 执行写保护。\n\n### 操作集定义\n\n- **`clean_walk_ops`**：用于清理脏位并记录位图的页表遍历操作集。\n- **`wp_walk_ops`**：仅执行写保护的页表遍历操作集。\n\n## 3. 关键实现\n\n### 页表遍历与原子修改\n- 使用 `ptep_get()` 安全读取 PTE。\n- 通过 `ptep_modify_prot_start()` / `ptep_modify_prot_commit()` 原子地修改 PTE 的保护属性，确保 SMP 和并发访问安全。\n- 对于写保护：调用 `pte_wrprotect()`；对于清理脏位：调用 `pte_mkclean()`。\n\n### TLB 刷新优化\n- 不使用 `tlb_gather_mmu()`（因其记录整个 VMA 范围），而是动态维护实际修改的最小/最大地址 (`tlbflush_start`/`end`)。\n- 在 `post_vma` 阶段根据是否发生嵌套 TLB 刷新 (`mm_tlb_flush_nested()`) 决定刷新整个 VMA 范围还是精确子范围。\n\n### 巨页处理策略\n- **明确禁止拆分透明巨页（THP）**：在 PMD/PUD 回调中检测到可写或脏的巨页时仅发出 `WARN_ON`，依赖缺页异常处理器后续处理。\n- 此设计避免在遍历过程中因拆分巨页导致脏信息丢失。\n\n### 位图记录机制\n- `clean_record_pte` 将虚拟地址转换为地址空间页偏移（`pgoff`），再相对于位图起始偏移计算位索引。\n- 使用 `__set_bit()` 设置位图，并维护被设置位的连续范围 (`start`/`end`)，便于后续高效处理。\n\n### VMA 过滤逻辑\n- 仅处理满足 `(VM_SHARED | VM_MAYWRITE)` 且 **不包含** `VM_HUGETLB` 的 VMA，确保操作对象是普通共享可写映射。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/pagewalk.h>`：页表遍历框架\n  - `<linux/hugetlb.h>`：巨页相关宏（如 `pmd_trans_huge`）\n  - `<linux/bitops.h>`：位图操作（`__set_bit`）\n  - `<linux/mmu_notifier.h>`：MMU 通知机制\n  - `<linux/mm_inline.h>`：内联内存管理函数\n  - `<asm/cacheflush.h>` / `<asm/tlbflush.h>`：体系结构相关的缓存和 TLB 刷新\n\n- **内核子系统**：\n  - 内存管理（MM）子系统：VMA、页表、PTE 操作\n  - 虚拟内存区域（VMA）管理\n  - MMU 通知框架\n  - 透明巨页（THP）支持\n\n## 5. 使用场景\n\n- **脏页跟踪（Dirty Tracking）**：在回写（writeback）或检查点（checkpointing）前，清除 PTE 脏位并记录哪些页被修改过。\n- **写时复制（COW）优化**：对共享映射执行写保护，使得后续写入触发缺页异常，从而实现 COW。\n- **内存快照/迁移**：在创建内存快照或迁移页面前，暂停写入并捕获脏页信息。\n- **文件系统一致性**：某些文件系统（如 NFS、CIFS）可能利用此机制跟踪共享映射的修改，确保数据一致性。\n- **用户态内存监控工具**：通过内核接口对特定映射范围进行写保护，监控应用程序的写行为。",
      "similarity": 0.5829997062683105,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/mapping_dirty_helpers.c",
          "start_line": 218,
          "end_line": 267,
          "content": [
            "static int wp_clean_test_walk(unsigned long start, unsigned long end,",
            "\t\t\t      struct mm_walk *walk)",
            "{",
            "\tunsigned long vm_flags = READ_ONCE(walk->vma->vm_flags);",
            "",
            "\t/* Skip non-applicable VMAs */",
            "\tif ((vm_flags & (VM_SHARED | VM_MAYWRITE | VM_HUGETLB)) !=",
            "\t    (VM_SHARED | VM_MAYWRITE))",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "unsigned long wp_shared_mapping_range(struct address_space *mapping,",
            "\t\t\t\t      pgoff_t first_index, pgoff_t nr)",
            "{",
            "\tstruct wp_walk wpwalk = { .total = 0 };",
            "",
            "\ti_mmap_lock_read(mapping);",
            "\tWARN_ON(walk_page_mapping(mapping, first_index, nr, &wp_walk_ops,",
            "\t\t\t\t  &wpwalk));",
            "\ti_mmap_unlock_read(mapping);",
            "",
            "\treturn wpwalk.total;",
            "}",
            "unsigned long clean_record_shared_mapping_range(struct address_space *mapping,",
            "\t\t\t\t\t\tpgoff_t first_index, pgoff_t nr,",
            "\t\t\t\t\t\tpgoff_t bitmap_pgoff,",
            "\t\t\t\t\t\tunsigned long *bitmap,",
            "\t\t\t\t\t\tpgoff_t *start,",
            "\t\t\t\t\t\tpgoff_t *end)",
            "{",
            "\tbool none_set = (*start >= *end);",
            "\tstruct clean_walk cwalk = {",
            "\t\t.base = { .total = 0 },",
            "\t\t.bitmap_pgoff = bitmap_pgoff,",
            "\t\t.bitmap = bitmap,",
            "\t\t.start = none_set ? nr : *start,",
            "\t\t.end = none_set ? 0 : *end,",
            "\t};",
            "",
            "\ti_mmap_lock_read(mapping);",
            "\tWARN_ON(walk_page_mapping(mapping, first_index, nr, &clean_walk_ops,",
            "\t\t\t\t  &cwalk.base));",
            "\ti_mmap_unlock_read(mapping);",
            "",
            "\t*start = cwalk.start;",
            "\t*end = cwalk.end;",
            "",
            "\treturn cwalk.base.total;",
            "}"
          ],
          "function_name": "wp_clean_test_walk, wp_shared_mapping_range, clean_record_shared_mapping_range",
          "description": "提供共享映射范围检测函数，统计共享页面数量并记录脏页偏移至位图，通过i_mmap锁保护遍历页面映射关系，支持批量清理共享内存的脏页追踪。",
          "similarity": 0.6034440994262695
        },
        {
          "chunk_id": 1,
          "file_path": "mm/mapping_dirty_helpers.c",
          "start_line": 34,
          "end_line": 141,
          "content": [
            "static int wp_pte(pte_t *pte, unsigned long addr, unsigned long end,",
            "\t\t  struct mm_walk *walk)",
            "{",
            "\tstruct wp_walk *wpwalk = walk->private;",
            "\tpte_t ptent = ptep_get(pte);",
            "",
            "\tif (pte_write(ptent)) {",
            "\t\tpte_t old_pte = ptep_modify_prot_start(walk->vma, addr, pte);",
            "",
            "\t\tptent = pte_wrprotect(old_pte);",
            "\t\tptep_modify_prot_commit(walk->vma, addr, pte, old_pte, ptent);",
            "\t\twpwalk->total++;",
            "\t\twpwalk->tlbflush_start = min(wpwalk->tlbflush_start, addr);",
            "\t\twpwalk->tlbflush_end = max(wpwalk->tlbflush_end,",
            "\t\t\t\t\t   addr + PAGE_SIZE);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int clean_record_pte(pte_t *pte, unsigned long addr,",
            "\t\t\t    unsigned long end, struct mm_walk *walk)",
            "{",
            "\tstruct wp_walk *wpwalk = walk->private;",
            "\tstruct clean_walk *cwalk = to_clean_walk(wpwalk);",
            "\tpte_t ptent = ptep_get(pte);",
            "",
            "\tif (pte_dirty(ptent)) {",
            "\t\tpgoff_t pgoff = ((addr - walk->vma->vm_start) >> PAGE_SHIFT) +",
            "\t\t\twalk->vma->vm_pgoff - cwalk->bitmap_pgoff;",
            "\t\tpte_t old_pte = ptep_modify_prot_start(walk->vma, addr, pte);",
            "",
            "\t\tptent = pte_mkclean(old_pte);",
            "\t\tptep_modify_prot_commit(walk->vma, addr, pte, old_pte, ptent);",
            "",
            "\t\twpwalk->total++;",
            "\t\twpwalk->tlbflush_start = min(wpwalk->tlbflush_start, addr);",
            "\t\twpwalk->tlbflush_end = max(wpwalk->tlbflush_end,",
            "\t\t\t\t\t   addr + PAGE_SIZE);",
            "",
            "\t\t__set_bit(pgoff, cwalk->bitmap);",
            "\t\tcwalk->start = min(cwalk->start, pgoff);",
            "\t\tcwalk->end = max(cwalk->end, pgoff + 1);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int wp_clean_pmd_entry(pmd_t *pmd, unsigned long addr, unsigned long end,",
            "\t\t\t      struct mm_walk *walk)",
            "{",
            "\tpmd_t pmdval = pmdp_get_lockless(pmd);",
            "",
            "\t/* Do not split a huge pmd, present or migrated */",
            "\tif (pmd_trans_huge(pmdval) || pmd_devmap(pmdval)) {",
            "\t\tWARN_ON(pmd_write(pmdval) || pmd_dirty(pmdval));",
            "\t\twalk->action = ACTION_CONTINUE;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int wp_clean_pud_entry(pud_t *pud, unsigned long addr, unsigned long end,",
            "\t\t\t      struct mm_walk *walk)",
            "{",
            "#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD",
            "\tpud_t pudval = READ_ONCE(*pud);",
            "",
            "\t/* Do not split a huge pud */",
            "\tif (pud_trans_huge(pudval) || pud_devmap(pudval)) {",
            "\t\tWARN_ON(pud_write(pudval) || pud_dirty(pudval));",
            "\t\twalk->action = ACTION_CONTINUE;",
            "\t}",
            "#endif",
            "\treturn 0;",
            "}",
            "static int wp_clean_pre_vma(unsigned long start, unsigned long end,",
            "\t\t\t    struct mm_walk *walk)",
            "{",
            "\tstruct wp_walk *wpwalk = walk->private;",
            "",
            "\twpwalk->tlbflush_start = end;",
            "\twpwalk->tlbflush_end = start;",
            "",
            "\tmmu_notifier_range_init(&wpwalk->range, MMU_NOTIFY_PROTECTION_PAGE, 0,",
            "\t\t\t\twalk->mm, start, end);",
            "\tmmu_notifier_invalidate_range_start(&wpwalk->range);",
            "\tflush_cache_range(walk->vma, start, end);",
            "",
            "\t/*",
            "\t * We're not using tlb_gather_mmu() since typically",
            "\t * only a small subrange of PTEs are affected, whereas",
            "\t * tlb_gather_mmu() records the full range.",
            "\t */",
            "\tinc_tlb_flush_pending(walk->mm);",
            "",
            "\treturn 0;",
            "}",
            "static void wp_clean_post_vma(struct mm_walk *walk)",
            "{",
            "\tstruct wp_walk *wpwalk = walk->private;",
            "",
            "\tif (mm_tlb_flush_nested(walk->mm))",
            "\t\tflush_tlb_range(walk->vma, wpwalk->range.start,",
            "\t\t\t\twpwalk->range.end);",
            "\telse if (wpwalk->tlbflush_end > wpwalk->tlbflush_start)",
            "\t\tflush_tlb_range(walk->vma, wpwalk->tlbflush_start,",
            "\t\t\t\twpwalk->tlbflush_end);",
            "",
            "\tmmu_notifier_invalidate_range_end(&wpwalk->range);",
            "\tdec_tlb_flush_pending(walk->mm);",
            "}"
          ],
          "function_name": "wp_pte, clean_record_pte, wp_clean_pmd_entry, wp_clean_pud_entry, wp_clean_pre_vma, wp_clean_post_vma",
          "description": "实现页表项写保护与脏页清除逻辑，通过遍历页表修改PTE标志位，处理huge pmd/pud避免拆分，预/后处理VMA时设置TLB刷新范围并触发缓存/TLB无效操作。",
          "similarity": 0.5102123022079468
        },
        {
          "chunk_id": 0,
          "file_path": "mm/mapping_dirty_helpers.c",
          "start_line": 1,
          "end_line": 33,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/pagewalk.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/tlbflush.h>",
            "",
            "/**",
            " * struct wp_walk - Private struct for pagetable walk callbacks",
            " * @range: Range for mmu notifiers",
            " * @tlbflush_start: Address of first modified pte",
            " * @tlbflush_end: Address of last modified pte + 1",
            " * @total: Total number of modified ptes",
            " */",
            "struct wp_walk {",
            "\tstruct mmu_notifier_range range;",
            "\tunsigned long tlbflush_start;",
            "\tunsigned long tlbflush_end;",
            "\tunsigned long total;",
            "};",
            "",
            "/**",
            " * wp_pte - Write-protect a pte",
            " * @pte: Pointer to the pte",
            " * @addr: The start of protecting virtual address",
            " * @end: The end of protecting virtual address",
            " * @walk: pagetable walk callback argument",
            " *",
            " * The function write-protects a pte and records the range in",
            " * virtual address space of touched ptes for efficient range TLB flushes.",
            " */"
          ],
          "function_name": null,
          "description": "定义wp_walk结构体，用于在页表遍历回调中记录MMU通知范围、TLB刷新地址区间及修改的页表项数量，并声明wp_pte函数用于写保护页表项并记录修改范围。",
          "similarity": 0.4498184025287628
        }
      ]
    }
  ]
}