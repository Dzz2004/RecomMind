{
  "query": "页面错误处理",
  "timestamp": "2025-12-26 00:04:24",
  "retrieved_files": [
    {
      "source_file": "mm/memory-failure.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:40:57\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memory-failure.c`\n\n---\n\n# memory-failure.c 技术文档\n\n## 1. 文件概述\n\n`memory-failure.c` 是 Linux 内核中用于处理硬件报告的内存故障（如多比特 ECC 错误）的核心模块。该文件实现了对已损坏物理页的检测、隔离和恢复机制，支持两种主要操作模式：\n- **硬离线（Hard Offline）**：处理已被硬件标记为损坏的页面，通常会导致使用该页的进程被终止\n- **软离线（Soft Offline）**：主动隔离可疑但尚未损坏的页面，避免潜在故障而不杀死进程\n\n该模块需要在不违反虚拟内存子系统正常锁定规则的前提下，异步安全地处理内存错误，确保系统稳定性。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `sysctl_memory_failure_early_kill`：控制是否立即杀死使用损坏页面的进程（0=延迟处理，1=立即杀死）\n- `sysctl_memory_failure_recovery`：启用/禁用内存故障恢复功能（默认启用）\n- `num_poisoned_pages`：原子计数器，记录已标记为有毒（poisoned）的页面数量\n- `hw_memory_failure`：标识是否由硬件直接报告的内存故障\n- `mf_mutex`：保护内存故障处理操作的互斥锁\n\n### 主要函数\n- `num_poisoned_pages_inc()` / `num_poisoned_pages_sub()`：管理有毒页面计数\n- `__page_handle_poison()`：处理大页或空闲页的溶解和从伙伴系统移除\n- `page_handle_poison()`：通用页面毒化处理函数，设置 HWPoison 标志并更新计数\n- `hwpoison_filter_dev()`：基于设备号过滤硬件毒化页面（用于测试）\n- `hwpoison_filter_flags()`：基于页面标志过滤硬件毒化页面（用于测试）\n\n### Sysfs 接口\n通过 `MF_ATTR_RO` 宏定义的只读属性，提供每个 NUMA 节点的内存故障统计信息：\n- `total`：总处理的内存故障数\n- `ignored`：被忽略的故障数\n- `failed`：处理失败的故障数  \n- `delayed`：延迟处理的故障数\n- `recovered`：成功恢复的故障数\n\n## 3. 关键实现\n\n### 页面毒化处理流程\n1. **页面状态识别**：区分大页（hugepage）、空闲页（freepage）和其他类型页面\n2. **大页处理**：调用 `dissolve_free_huge_page()` 溶解大页，然后通过 `drain_all_pages()` 和 `take_page_off_buddy()` 确保页面从伙伴系统移除\n3. **标志设置**：使用 `SetPageHWPoison()` 标记页面为硬件毒化状态\n4. **引用计数管理**：增加页面引用计数并更新全局有毒页面计数器\n\n### 锁定策略\n- 避免使用 `zone_pcp_disable()` 以防止与 CPU 热插拔锁产生死锁\n- 采用标准 VM 锁定规则，即使这意味着错误处理可能耗时较长\n- 使用 `mf_mutex` 保护关键的内存故障处理路径\n\n### 复杂度考量\n- 由于 VM 数据结构的限制，某些操作（如通过 RMAP 反向映射查找进程）具有非线性时间复杂度\n- 基于内存故障的稀有性，接受这种性能开销以避免影响核心 VM 性能\n\n### 开发约束\n新增处理逻辑必须满足：\n- 具备可测试性\n- 能够集成到 mce-test 测试套件\n- 在真实工作负载中属于常见页面状态（page-types 工具 top 10）\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n- **内存管理**：`<linux/mm.h>`, `<linux/page-flags.h>`, `<linux/pagemap.h>`, `<linux/swap.h>`\n- **进程管理**：`<linux/sched/signal.h>`, `<linux/sched/task.h>`\n- **特殊内存类型**：`<linux/hugetlb.h>`, `<linux/dax.h>`, `<linux/ksm.h>`, `<linux/shmem_fs.h>`\n- **系统架构**：`<linux/ras/ras_event.h>`, `<linux/memremap.h>`\n- **内核内部**：`\"swap.h\"`, `\"internal.h\"`\n\n### 功能依赖\n- **RAS（Reliability, Availability, Serviceability）**：通过 ras_event 提供事件通知\n- **内存热插拔**：`memblk_nr_poison_inc/sub` 用于内存块级统计\n- **cgroup 内存控制**：CONFIG_MEMCG 支持基于 memcg 的故障页面过滤\n- **硬件毒化注入**：CONFIG_HWPOISON_INJECT 提供测试框架\n\n## 5. 使用场景\n\n### 硬件内存故障处理\n- 当硬件检测到多比特 ECC 内存错误时，通过 Machine Check Exception (MCE) 机制调用此模块\n- 自动隔离损坏页面，防止数据损坏扩散\n\n### 主动内存维护\n- 系统管理员可通过 `/sys` 接口触发软离线操作，主动替换可疑内存页\n- 用于内存压力测试和预防性维护\n\n### 故障注入测试\n- 通过 `hwpoison_inject` 模块模拟硬件内存故障\n- 支持基于设备号、页面标志和 memcg 的精细过滤，用于针对性测试\n\n### 系统监控和诊断\n- 通过 sysfs 接口提供详细的内存故障统计信息\n- 便于系统管理员监控内存健康状况和故障恢复效果\n\n### 企业级可靠性保障\n- 在高可用服务器环境中，确保单个内存故障不会导致整个系统崩溃\n- 通过可配置的策略（early_kill, recovery）平衡服务连续性和数据完整性",
      "similarity": 0.6100431680679321,
      "chunks": [
        {
          "chunk_id": 7,
          "file_path": "mm/memory-failure.c",
          "start_line": 1088,
          "end_line": 1202,
          "content": [
            "static int me_pagecache_dirty(struct page_state *ps, struct page *p)",
            "{",
            "\tstruct address_space *mapping = page_mapping(p);",
            "",
            "\tSetPageError(p);",
            "\t/* TBD: print more information about the file. */",
            "\tif (mapping) {",
            "\t\t/*",
            "\t\t * IO error will be reported by write(), fsync(), etc.",
            "\t\t * who check the mapping.",
            "\t\t * This way the application knows that something went",
            "\t\t * wrong with its dirty file data.",
            "\t\t *",
            "\t\t * There's one open issue:",
            "\t\t *",
            "\t\t * The EIO will be only reported on the next IO",
            "\t\t * operation and then cleared through the IO map.",
            "\t\t * Normally Linux has two mechanisms to pass IO error",
            "\t\t * first through the AS_EIO flag in the address space",
            "\t\t * and then through the PageError flag in the page.",
            "\t\t * Since we drop pages on memory failure handling the",
            "\t\t * only mechanism open to use is through AS_AIO.",
            "\t\t *",
            "\t\t * This has the disadvantage that it gets cleared on",
            "\t\t * the first operation that returns an error, while",
            "\t\t * the PageError bit is more sticky and only cleared",
            "\t\t * when the page is reread or dropped.  If an",
            "\t\t * application assumes it will always get error on",
            "\t\t * fsync, but does other operations on the fd before",
            "\t\t * and the page is dropped between then the error",
            "\t\t * will not be properly reported.",
            "\t\t *",
            "\t\t * This can already happen even without hwpoisoned",
            "\t\t * pages: first on metadata IO errors (which only",
            "\t\t * report through AS_EIO) or when the page is dropped",
            "\t\t * at the wrong time.",
            "\t\t *",
            "\t\t * So right now we assume that the application DTRT on",
            "\t\t * the first EIO, but we're not worse than other parts",
            "\t\t * of the kernel.",
            "\t\t */",
            "\t\tmapping_set_error(mapping, -EIO);",
            "\t}",
            "",
            "\treturn me_pagecache_clean(ps, p);",
            "}",
            "static int me_swapcache_dirty(struct page_state *ps, struct page *p)",
            "{",
            "\tint ret;",
            "\tbool extra_pins = false;",
            "",
            "\tClearPageDirty(p);",
            "\t/* Trigger EIO in shmem: */",
            "\tClearPageUptodate(p);",
            "",
            "\tret = delete_from_lru_cache(p) ? MF_FAILED : MF_DELAYED;",
            "\tunlock_page(p);",
            "",
            "\tif (ret == MF_DELAYED)",
            "\t\textra_pins = true;",
            "",
            "\tif (has_extra_refcount(ps, p, extra_pins))",
            "\t\tret = MF_FAILED;",
            "",
            "\treturn ret;",
            "}",
            "static int me_swapcache_clean(struct page_state *ps, struct page *p)",
            "{",
            "\tstruct folio *folio = page_folio(p);",
            "\tint ret;",
            "",
            "\tdelete_from_swap_cache(folio);",
            "",
            "\tret = delete_from_lru_cache(p) ? MF_FAILED : MF_RECOVERED;",
            "\tfolio_unlock(folio);",
            "",
            "\tif (has_extra_refcount(ps, p, false))",
            "\t\tret = MF_FAILED;",
            "",
            "\treturn ret;",
            "}",
            "static int me_huge_page(struct page_state *ps, struct page *p)",
            "{",
            "\tstruct folio *folio = page_folio(p);",
            "\tint res;",
            "\tstruct address_space *mapping;",
            "\tbool extra_pins = false;",
            "",
            "\tmapping = folio_mapping(folio);",
            "\tif (mapping) {",
            "\t\tres = truncate_error_page(&folio->page, page_to_pfn(p), mapping);",
            "\t\t/* The page is kept in page cache. */",
            "\t\textra_pins = true;",
            "\t\tfolio_unlock(folio);",
            "\t} else {",
            "\t\tfolio_unlock(folio);",
            "\t\t/*",
            "\t\t * migration entry prevents later access on error hugepage,",
            "\t\t * so we can free and dissolve it into buddy to save healthy",
            "\t\t * subpages.",
            "\t\t */",
            "\t\tfolio_put(folio);",
            "\t\tif (__page_handle_poison(p) > 0) {",
            "\t\t\tpage_ref_inc(p);",
            "\t\t\tres = MF_RECOVERED;",
            "\t\t} else {",
            "\t\t\tres = MF_FAILED;",
            "\t\t}",
            "\t}",
            "",
            "\tif (has_extra_refcount(ps, p, extra_pins))",
            "\t\tres = MF_FAILED;",
            "",
            "\treturn res;",
            "}"
          ],
          "function_name": "me_pagecache_dirty, me_swapcache_dirty, me_swapcache_clean, me_huge_page",
          "description": "针对不同页面状态（脏页/交换缓存/大页）实施差异化处理，设置错误标志并触发生效I/O错误",
          "similarity": 0.7213050127029419
        },
        {
          "chunk_id": 14,
          "file_path": "mm/memory-failure.c",
          "start_line": 2186,
          "end_line": 2390,
          "content": [
            "int memory_failure(unsigned long pfn, int flags)",
            "{",
            "\tstruct page *p;",
            "\tstruct folio *folio;",
            "\tstruct dev_pagemap *pgmap;",
            "\tint res = 0;",
            "\tunsigned long page_flags;",
            "\tbool retry = true;",
            "\tint hugetlb = 0;",
            "",
            "\tif (!sysctl_memory_failure_recovery)",
            "\t\tpanic(\"Memory failure on page %lx\", pfn);",
            "",
            "\tmutex_lock(&mf_mutex);",
            "",
            "\tif (!(flags & MF_SW_SIMULATED))",
            "\t\thw_memory_failure = true;",
            "",
            "\tp = pfn_to_online_page(pfn);",
            "\tif (!p) {",
            "\t\tres = arch_memory_failure(pfn, flags);",
            "\t\tif (res == 0)",
            "\t\t\tgoto unlock_mutex;",
            "",
            "\t\tif (pfn_valid(pfn)) {",
            "\t\t\tpgmap = get_dev_pagemap(pfn, NULL);",
            "\t\t\tput_ref_page(pfn, flags);",
            "\t\t\tif (pgmap) {",
            "\t\t\t\tres = memory_failure_dev_pagemap(pfn, flags,",
            "\t\t\t\t\t\t\t\t pgmap);",
            "\t\t\t\tgoto unlock_mutex;",
            "\t\t\t}",
            "\t\t}",
            "\t\tpr_err(\"%#lx: memory outside kernel control\\n\", pfn);",
            "\t\tres = -ENXIO;",
            "\t\tgoto unlock_mutex;",
            "\t}",
            "",
            "try_again:",
            "\tres = try_memory_failure_hugetlb(pfn, flags, &hugetlb);",
            "\tif (hugetlb)",
            "\t\tgoto unlock_mutex;",
            "",
            "\tif (TestSetPageHWPoison(p)) {",
            "\t\tpr_err(\"%#lx: already hardware poisoned\\n\", pfn);",
            "\t\tres = -EHWPOISON;",
            "\t\tif (flags & MF_ACTION_REQUIRED)",
            "\t\t\tres = kill_accessing_process(current, pfn, flags);",
            "\t\tif (flags & MF_COUNT_INCREASED)",
            "\t\t\tput_page(p);",
            "\t\tgoto unlock_mutex;",
            "\t}",
            "",
            "\t/*",
            "\t * We need/can do nothing about count=0 pages.",
            "\t * 1) it's a free page, and therefore in safe hand:",
            "\t *    check_new_page() will be the gate keeper.",
            "\t * 2) it's part of a non-compound high order page.",
            "\t *    Implies some kernel user: cannot stop them from",
            "\t *    R/W the page; let's pray that the page has been",
            "\t *    used and will be freed some time later.",
            "\t * In fact it's dangerous to directly bump up page count from 0,",
            "\t * that may make page_ref_freeze()/page_ref_unfreeze() mismatch.",
            "\t */",
            "\tif (!(flags & MF_COUNT_INCREASED)) {",
            "\t\tres = get_hwpoison_page(p, flags);",
            "\t\tif (!res) {",
            "\t\t\tif (is_free_buddy_page(p)) {",
            "\t\t\t\tif (take_page_off_buddy(p)) {",
            "\t\t\t\t\tpage_ref_inc(p);",
            "\t\t\t\t\tres = MF_RECOVERED;",
            "\t\t\t\t} else {",
            "\t\t\t\t\t/* We lost the race, try again */",
            "\t\t\t\t\tif (retry) {",
            "\t\t\t\t\t\tClearPageHWPoison(p);",
            "\t\t\t\t\t\tretry = false;",
            "\t\t\t\t\t\tgoto try_again;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tres = MF_FAILED;",
            "\t\t\t\t}",
            "\t\t\t\tres = action_result(pfn, MF_MSG_BUDDY, res);",
            "\t\t\t} else {",
            "\t\t\t\tres = action_result(pfn, MF_MSG_KERNEL_HIGH_ORDER, MF_IGNORED);",
            "\t\t\t}",
            "\t\t\tgoto unlock_mutex;",
            "\t\t} else if (res < 0) {",
            "\t\t\tres = action_result(pfn, MF_MSG_UNKNOWN, MF_IGNORED);",
            "\t\t\tgoto unlock_mutex;",
            "\t\t}",
            "\t}",
            "",
            "\tfolio = page_folio(p);",
            "\tif (folio_test_large(folio)) {",
            "\t\t/*",
            "\t\t * The flag must be set after the refcount is bumped",
            "\t\t * otherwise it may race with THP split.",
            "\t\t * And the flag can't be set in get_hwpoison_page() since",
            "\t\t * it is called by soft offline too and it is just called",
            "\t\t * for !MF_COUNT_INCREASED.  So here seems to be the best",
            "\t\t * place.",
            "\t\t *",
            "\t\t * Don't need care about the above error handling paths for",
            "\t\t * get_hwpoison_page() since they handle either free page",
            "\t\t * or unhandlable page.  The refcount is bumped iff the",
            "\t\t * page is a valid handlable page.",
            "\t\t */",
            "\t\tfolio_set_has_hwpoisoned(folio);",
            "\t\tif (try_to_split_thp_page(p) < 0) {",
            "\t\t\tres = action_result(pfn, MF_MSG_UNSPLIT_THP, MF_IGNORED);",
            "\t\t\tgoto unlock_mutex;",
            "\t\t}",
            "\t\tVM_BUG_ON_PAGE(!page_count(p), p);",
            "\t\tfolio = page_folio(p);",
            "\t}",
            "",
            "\t/*",
            "\t * We ignore non-LRU pages for good reasons.",
            "\t * - PG_locked is only well defined for LRU pages and a few others",
            "\t * - to avoid races with __SetPageLocked()",
            "\t * - to avoid races with __SetPageSlab*() (and more non-atomic ops)",
            "\t * The check (unnecessarily) ignores LRU pages being isolated and",
            "\t * walked by the page reclaim code, however that's not a big loss.",
            "\t */",
            "\tshake_folio(folio);",
            "",
            "\tfolio_lock(folio);",
            "",
            "\t/*",
            "\t * We're only intended to deal with the non-Compound page here.",
            "\t * However, the page could have changed compound pages due to",
            "\t * race window. If this happens, we could try again to hopefully",
            "\t * handle the page next round.",
            "\t */",
            "\tif (folio_test_large(folio)) {",
            "\t\tif (retry) {",
            "\t\t\tClearPageHWPoison(p);",
            "\t\t\tfolio_unlock(folio);",
            "\t\t\tfolio_put(folio);",
            "\t\t\tflags &= ~MF_COUNT_INCREASED;",
            "\t\t\tretry = false;",
            "\t\t\tgoto try_again;",
            "\t\t}",
            "\t\tres = action_result(pfn, MF_MSG_DIFFERENT_COMPOUND, MF_IGNORED);",
            "\t\tgoto unlock_page;",
            "\t}",
            "",
            "\t/*",
            "\t * We use page flags to determine what action should be taken, but",
            "\t * the flags can be modified by the error containment action.  One",
            "\t * example is an mlocked page, where PG_mlocked is cleared by",
            "\t * folio_remove_rmap_*() in try_to_unmap_one(). So to determine page",
            "\t * status correctly, we save a copy of the page flags at this time.",
            "\t */",
            "\tpage_flags = folio->flags;",
            "",
            "\tif (hwpoison_filter(p)) {",
            "\t\tClearPageHWPoison(p);",
            "\t\tfolio_unlock(folio);",
            "\t\tfolio_put(folio);",
            "\t\tres = -EOPNOTSUPP;",
            "\t\tgoto unlock_mutex;",
            "\t}",
            "",
            "\t/*",
            "\t * __munlock_folio() may clear a writeback folio's LRU flag without",
            "\t * the folio lock. We need to wait for writeback completion for this",
            "\t * folio or it may trigger a vfs BUG while evicting inode.",
            "\t */",
            "\tif (!folio_test_lru(folio) && !folio_test_writeback(folio))",
            "\t\tgoto identify_page_state;",
            "",
            "\t/*",
            "\t * It's very difficult to mess with pages currently under IO",
            "\t * and in many cases impossible, so we just avoid it here.",
            "\t */",
            "\tfolio_wait_writeback(folio);",
            "",
            "\t/*",
            "\t * Now take care of user space mappings.",
            "\t * Abort on fail: __filemap_remove_folio() assumes unmapped page.",
            "\t */",
            "\tif (!hwpoison_user_mappings(folio, p, pfn, flags)) {",
            "\t\tres = action_result(pfn, MF_MSG_UNMAP_FAILED, MF_IGNORED);",
            "\t\tgoto unlock_page;",
            "\t}",
            "",
            "\t/*",
            "\t * Torn down by someone else?",
            "\t */",
            "\tif (folio_test_lru(folio) && !folio_test_swapcache(folio) &&",
            "\t    folio->mapping == NULL) {",
            "\t\tres = action_result(pfn, MF_MSG_TRUNCATED_LRU, MF_IGNORED);",
            "\t\tgoto unlock_page;",
            "\t}",
            "",
            "identify_page_state:",
            "\tres = identify_page_state(pfn, p, page_flags);",
            "\tmutex_unlock(&mf_mutex);",
            "\treturn res;",
            "unlock_page:",
            "\tfolio_unlock(folio);",
            "unlock_mutex:",
            "\tmutex_unlock(&mf_mutex);",
            "\treturn res;",
            "}"
          ],
          "function_name": "memory_failure",
          "description": "memory_failure主函数处理内存故障，检查页面有效性，通过不同路径处理普通页、大页和设备页，调用相应处理函数并返回结果",
          "similarity": 0.6814780831336975
        },
        {
          "chunk_id": 6,
          "file_path": "mm/memory-failure.c",
          "start_line": 919,
          "end_line": 1050,
          "content": [
            "static int delete_from_lru_cache(struct page *p)",
            "{",
            "\tif (isolate_lru_page(p)) {",
            "\t\t/*",
            "\t\t * Clear sensible page flags, so that the buddy system won't",
            "\t\t * complain when the page is unpoison-and-freed.",
            "\t\t */",
            "\t\tClearPageActive(p);",
            "\t\tClearPageUnevictable(p);",
            "",
            "\t\t/*",
            "\t\t * Poisoned page might never drop its ref count to 0 so we have",
            "\t\t * to uncharge it manually from its memcg.",
            "\t\t */",
            "\t\tmem_cgroup_uncharge(page_folio(p));",
            "",
            "\t\t/*",
            "\t\t * drop the page count elevated by isolate_lru_page()",
            "\t\t */",
            "\t\tput_page(p);",
            "\t\treturn 0;",
            "\t}",
            "\treturn -EIO;",
            "}",
            "static int truncate_error_page(struct page *p, unsigned long pfn,",
            "\t\t\t\tstruct address_space *mapping)",
            "{",
            "\tstruct folio *folio = page_folio(p);",
            "\tint ret = MF_FAILED;",
            "",
            "\tif (mapping->a_ops->error_remove_page) {",
            "\t\tint err = mapping->a_ops->error_remove_page(mapping, p);",
            "",
            "\t\tif (err != 0)",
            "\t\t\tpr_info(\"%#lx: Failed to punch page: %d\\n\", pfn, err);",
            "\t\telse if (!filemap_release_folio(folio, GFP_NOIO))",
            "\t\t\tpr_info(\"%#lx: failed to release buffers\\n\", pfn);",
            "\t\telse",
            "\t\t\tret = MF_RECOVERED;",
            "\t} else {",
            "\t\t/*",
            "\t\t * If the file system doesn't support it just invalidate",
            "\t\t * This fails on dirty or anything with private pages",
            "\t\t */",
            "\t\tif (mapping_evict_folio(mapping, folio))",
            "\t\t\tret = MF_RECOVERED;",
            "\t\telse",
            "\t\t\tpr_info(\"%#lx: Failed to invalidate\\n\",\tpfn);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static bool has_extra_refcount(struct page_state *ps, struct page *p,",
            "\t\t\t       bool extra_pins)",
            "{",
            "\tint count = page_count(p) - 1;",
            "",
            "\tif (extra_pins)",
            "\t\tcount -= folio_nr_pages(page_folio(p));",
            "",
            "\tif (count > 0) {",
            "\t\tpr_err(\"%#lx: %s still referenced by %d users\\n\",",
            "\t\t       page_to_pfn(p), action_page_types[ps->type], count);",
            "\t\treturn true;",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static int me_kernel(struct page_state *ps, struct page *p)",
            "{",
            "\tunlock_page(p);",
            "\treturn MF_IGNORED;",
            "}",
            "static int me_unknown(struct page_state *ps, struct page *p)",
            "{",
            "\tpr_err(\"%#lx: Unknown page state\\n\", page_to_pfn(p));",
            "\tunlock_page(p);",
            "\treturn MF_FAILED;",
            "}",
            "static int me_pagecache_clean(struct page_state *ps, struct page *p)",
            "{",
            "\tint ret;",
            "\tstruct address_space *mapping;",
            "\tbool extra_pins;",
            "",
            "\tdelete_from_lru_cache(p);",
            "",
            "\t/*",
            "\t * For anonymous pages we're done the only reference left",
            "\t * should be the one m_f() holds.",
            "\t */",
            "\tif (PageAnon(p)) {",
            "\t\tret = MF_RECOVERED;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * Now truncate the page in the page cache. This is really",
            "\t * more like a \"temporary hole punch\"",
            "\t * Don't do this for block devices when someone else",
            "\t * has a reference, because it could be file system metadata",
            "\t * and that's not safe to truncate.",
            "\t */",
            "\tmapping = page_mapping(p);",
            "\tif (!mapping) {",
            "\t\t/*",
            "\t\t * Page has been teared down in the meanwhile",
            "\t\t */",
            "\t\tret = MF_FAILED;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * The shmem page is kept in page cache instead of truncating",
            "\t * so is expected to have an extra refcount after error-handling.",
            "\t */",
            "\textra_pins = shmem_mapping(mapping);",
            "",
            "\t/*",
            "\t * Truncation is a bit tricky. Enable it per file system for now.",
            "\t *",
            "\t * Open: to take i_rwsem or not for this? Right now we don't.",
            "\t */",
            "\tret = truncate_error_page(p, page_to_pfn(p), mapping);",
            "\tif (has_extra_refcount(ps, p, extra_pins))",
            "\t\tret = MF_FAILED;",
            "",
            "out:",
            "\tunlock_page(p);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "delete_from_lru_cache, truncate_error_page, has_extra_refcount, me_kernel, me_unknown, me_pagecache_clean",
          "description": "提供内存故障页面清理流程，包括从LRU列表移除、截断页面缓存及检查引用计数的辅助函数",
          "similarity": 0.6800090074539185
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memory-failure.c",
          "start_line": 77,
          "end_line": 181,
          "content": [
            "void num_poisoned_pages_inc(unsigned long pfn)",
            "{",
            "\tatomic_long_inc(&num_poisoned_pages);",
            "\tmemblk_nr_poison_inc(pfn);",
            "}",
            "void num_poisoned_pages_sub(unsigned long pfn, long i)",
            "{",
            "\tatomic_long_sub(i, &num_poisoned_pages);",
            "\tif (pfn != -1UL)",
            "\t\tmemblk_nr_poison_sub(pfn, i);",
            "}",
            "static int __page_handle_poison(struct page *page)",
            "{",
            "\tint ret;",
            "",
            "\t/*",
            "\t * zone_pcp_disable() can't be used here. It will",
            "\t * hold pcp_batch_high_lock and dissolve_free_huge_page() might hold",
            "\t * cpu_hotplug_lock via static_key_slow_dec() when hugetlb vmemmap",
            "\t * optimization is enabled. This will break current lock dependency",
            "\t * chain and leads to deadlock.",
            "\t * Disabling pcp before dissolving the page was a deterministic",
            "\t * approach because we made sure that those pages cannot end up in any",
            "\t * PCP list. Draining PCP lists expels those pages to the buddy system,",
            "\t * but nothing guarantees that those pages do not get back to a PCP",
            "\t * queue if we need to refill those.",
            "\t */",
            "\tret = dissolve_free_huge_page(page);",
            "\tif (!ret) {",
            "\t\tdrain_all_pages(page_zone(page));",
            "\t\tret = take_page_off_buddy(page);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static bool page_handle_poison(struct page *page, bool hugepage_or_freepage, bool release)",
            "{",
            "\tif (hugepage_or_freepage) {",
            "\t\t/*",
            "\t\t * Doing this check for free pages is also fine since dissolve_free_huge_page",
            "\t\t * returns 0 for non-hugetlb pages as well.",
            "\t\t */",
            "\t\tif (__page_handle_poison(page) <= 0)",
            "\t\t\t/*",
            "\t\t\t * We could fail to take off the target page from buddy",
            "\t\t\t * for example due to racy page allocation, but that's",
            "\t\t\t * acceptable because soft-offlined page is not broken",
            "\t\t\t * and if someone really want to use it, they should",
            "\t\t\t * take it.",
            "\t\t\t */",
            "\t\t\treturn false;",
            "\t}",
            "",
            "\tSetPageHWPoison(page);",
            "\tif (release)",
            "\t\tput_page(page);",
            "\tpage_ref_inc(page);",
            "\tnum_poisoned_pages_inc(page_to_pfn(page));",
            "",
            "\treturn true;",
            "}",
            "static int hwpoison_filter_dev(struct page *p)",
            "{",
            "\tstruct address_space *mapping;",
            "\tdev_t dev;",
            "",
            "\tif (hwpoison_filter_dev_major == ~0U &&",
            "\t    hwpoison_filter_dev_minor == ~0U)",
            "\t\treturn 0;",
            "",
            "\tmapping = page_mapping(p);",
            "\tif (mapping == NULL || mapping->host == NULL)",
            "\t\treturn -EINVAL;",
            "",
            "\tdev = mapping->host->i_sb->s_dev;",
            "\tif (hwpoison_filter_dev_major != ~0U &&",
            "\t    hwpoison_filter_dev_major != MAJOR(dev))",
            "\t\treturn -EINVAL;",
            "\tif (hwpoison_filter_dev_minor != ~0U &&",
            "\t    hwpoison_filter_dev_minor != MINOR(dev))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static int hwpoison_filter_flags(struct page *p)",
            "{",
            "\tif (!hwpoison_filter_flags_mask)",
            "\t\treturn 0;",
            "",
            "\tif ((stable_page_flags(p) & hwpoison_filter_flags_mask) ==",
            "\t\t\t\t    hwpoison_filter_flags_value)",
            "\t\treturn 0;",
            "\telse",
            "\t\treturn -EINVAL;",
            "}",
            "static int hwpoison_filter_task(struct page *p)",
            "{",
            "\tif (!hwpoison_filter_memcg)",
            "\t\treturn 0;",
            "",
            "\tif (page_cgroup_ino(p) != hwpoison_filter_memcg)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "num_poisoned_pages_inc, num_poisoned_pages_sub, __page_handle_poison, page_handle_poison, hwpoison_filter_dev, hwpoison_filter_flags, hwpoison_filter_task",
          "description": "提供页面中毒处理函数，用于统计和管理被污染页面计数，处理页面分离操作，并实现基于设备、页标志和任务的过滤规则以确定是否对受影响页面采取行动。",
          "similarity": 0.6432225704193115
        },
        {
          "chunk_id": 8,
          "file_path": "mm/memory-failure.c",
          "start_line": 1288,
          "end_line": 1404,
          "content": [
            "static void update_per_node_mf_stats(unsigned long pfn,",
            "\t\t\t\t     enum mf_result result)",
            "{",
            "\tint nid = MAX_NUMNODES;",
            "\tstruct memory_failure_stats *mf_stats = NULL;",
            "",
            "\tnid = pfn_to_nid(pfn);",
            "\tif (unlikely(nid < 0 || nid >= MAX_NUMNODES)) {",
            "\t\tWARN_ONCE(1, \"Memory failure: pfn=%#lx, invalid nid=%d\", pfn, nid);",
            "\t\treturn;",
            "\t}",
            "",
            "\tmf_stats = &NODE_DATA(nid)->mf_stats;",
            "\tswitch (result) {",
            "\tcase MF_IGNORED:",
            "\t\t++mf_stats->ignored;",
            "\t\tbreak;",
            "\tcase MF_FAILED:",
            "\t\t++mf_stats->failed;",
            "\t\tbreak;",
            "\tcase MF_DELAYED:",
            "\t\t++mf_stats->delayed;",
            "\t\tbreak;",
            "\tcase MF_RECOVERED:",
            "\t\t++mf_stats->recovered;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tWARN_ONCE(1, \"Memory failure: mf_result=%d is not properly handled\", result);",
            "\t\tbreak;",
            "\t}",
            "\t++mf_stats->total;",
            "}",
            "static int action_result(unsigned long pfn, enum mf_action_page_type type,",
            "\t\t\t enum mf_result result)",
            "{",
            "\ttrace_memory_failure_event(pfn, type, result);",
            "",
            "\tnum_poisoned_pages_inc(pfn);",
            "",
            "\tupdate_per_node_mf_stats(pfn, result);",
            "",
            "\tpr_err(\"%#lx: recovery action for %s: %s\\n\",",
            "\t\tpfn, action_page_types[type], action_name[result]);",
            "",
            "\treturn (result == MF_RECOVERED || result == MF_DELAYED) ? 0 : -EBUSY;",
            "}",
            "static int page_action(struct page_state *ps, struct page *p,",
            "\t\t\tunsigned long pfn)",
            "{",
            "\tint result;",
            "",
            "\t/* page p should be unlocked after returning from ps->action().  */",
            "\tresult = ps->action(ps, p);",
            "",
            "\t/* Could do more checks here if page looks ok */",
            "\t/*",
            "\t * Could adjust zone counters here to correct for the missing page.",
            "\t */",
            "",
            "\treturn action_result(pfn, ps->type, result);",
            "}",
            "static inline bool PageHWPoisonTakenOff(struct page *page)",
            "{",
            "\treturn PageHWPoison(page) && page_private(page) == MAGIC_HWPOISON;",
            "}",
            "void SetPageHWPoisonTakenOff(struct page *page)",
            "{",
            "\tset_page_private(page, MAGIC_HWPOISON);",
            "}",
            "void ClearPageHWPoisonTakenOff(struct page *page)",
            "{",
            "\tif (PageHWPoison(page))",
            "\t\tset_page_private(page, 0);",
            "}",
            "static inline bool HWPoisonHandlable(struct page *page, unsigned long flags)",
            "{",
            "\t/* Soft offline could migrate non-LRU movable pages */",
            "\tif ((flags & MF_SOFT_OFFLINE) && __PageMovable(page))",
            "\t\treturn true;",
            "",
            "\treturn PageLRU(page) || is_free_buddy_page(page);",
            "}",
            "static int __get_hwpoison_page(struct page *page, unsigned long flags)",
            "{",
            "\tstruct folio *folio = page_folio(page);",
            "\tint ret = 0;",
            "\tbool hugetlb = false;",
            "",
            "\tret = get_hwpoison_hugetlb_folio(folio, &hugetlb, false);",
            "\tif (hugetlb) {",
            "\t\t/* Make sure hugetlb demotion did not happen from under us. */",
            "\t\tif (folio == page_folio(page))",
            "\t\t\treturn ret;",
            "\t\tif (ret > 0) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\tfolio = page_folio(page);",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * This check prevents from calling folio_try_get() for any",
            "\t * unsupported type of folio in order to reduce the risk of unexpected",
            "\t * races caused by taking a folio refcount.",
            "\t */",
            "\tif (!HWPoisonHandlable(&folio->page, flags))",
            "\t\treturn -EBUSY;",
            "",
            "\tif (folio_try_get(folio)) {",
            "\t\tif (folio == page_folio(page))",
            "\t\t\treturn 1;",
            "",
            "\t\tpr_info(\"%#lx cannot catch tail\\n\", page_to_pfn(page));",
            "\t\tfolio_put(folio);",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "update_per_node_mf_stats, action_result, page_action, PageHWPoisonTakenOff, SetPageHWPoisonTakenOff, ClearPageHWPoisonTakenOff, HWPoisonHandlable, __get_hwpoison_page",
          "description": "维护内存故障统计信息并处理页面操作结果，包含状态转换控制与硬件中毒标记管理",
          "similarity": 0.6431445479393005
        }
      ]
    },
    {
      "source_file": "mm/fail_page_alloc.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:59:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `fail_page_alloc.c`\n\n---\n\n# `fail_page_alloc.c` 技术文档\n\n## 1. 文件概述\n\n`fail_page_alloc.c` 是 Linux 内核中用于实现内存页分配故障注入（fault injection）机制的模块。该文件通过模拟 `alloc_pages()` 等内存分配函数失败的情形，帮助开发者测试内核在内存分配失败时的错误处理路径和健壮性。它基于通用的故障注入框架（`fault-inject.h`），并提供了运行时可配置的控制参数。\n\n## 2. 核心功能\n\n### 数据结构\n- **`fail_page_alloc`**：全局静态结构体，包含：\n  - `attr`：标准的 `fault_attr` 故障属性，用于控制故障注入的概率、间隔等行为。\n  - `ignore_gfp_highmem`：布尔值，若为 `true`，则忽略带有 `__GFP_HIGHMEM` 标志的分配请求。\n  - `ignore_gfp_reclaim`：布尔值，若为 `true`，则忽略带有 `__GFP_DIRECT_RECLAIM` 标志的分配请求。\n  - `min_order`：无符号 32 位整数，指定只对大于等于此阶数（order）的页分配进行故障注入。\n\n### 主要函数\n- **`setup_fail_page_alloc(char *str)`**：内核启动参数解析函数，用于通过 `fail_page_alloc=` 内核命令行参数初始化故障属性。\n- **`should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)`**：核心判断函数，根据当前分配请求的 `gfp_mask` 和 `order` 决定是否注入分配失败。\n- **`fail_page_alloc_debugfs(void)`**（条件编译）：在启用了 `CONFIG_FAULT_INJECTION_DEBUG_FS` 时，创建 debugfs 接口以动态调整故障注入参数。\n\n### 宏与注解\n- **`__setup(\"fail_page_alloc=\", setup_fail_page_alloc)`**：注册内核启动参数处理函数。\n- **`ALLOW_ERROR_INJECTION(should_fail_alloc_page, TRUE)`**：声明该函数可被错误注入框架拦截，支持动态启用/禁用。\n\n## 3. 关键实现\n\n- **故障注入条件判断**：\n  - 仅当请求的 `order >= min_order` 时才考虑注入失败。\n  - 若分配标志包含 `__GFP_NOFAIL`（表示分配必须成功），则跳过注入。\n  - 可选择性忽略高内存（`__GFP_HIGHMEM`）或直接回收（`__GFP_DIRECT_RECLAIM`）类型的分配请求。\n  - 若分配请求设置了 `__GFP_NOWARN`，则传递 `FAULT_NOWARN` 标志给底层故障注入逻辑，避免打印警告信息。\n\n- **debugfs 接口**（当 `CONFIG_FAULT_INJECTION_DEBUG_FS` 启用时）：\n  - 在 `/sys/kernel/debug/fail_page_alloc/` 目录下创建以下可调参数：\n    - `ignore-gfp-wait`：对应 `ignore_gfp_reclaim`（注：变量名与 debugfs 名称存在历史命名差异，实际控制 `__GFP_DIRECT_RECLAIM`）。\n    - `ignore-gfp-highmem`：控制是否忽略高内存分配。\n    - `min-order`：设置最小注入阶数。\n\n- **故障决策**：最终调用 `should_fail_ex()`，传入按 `order` 缩放的权重（`1 << order`），使得大块内存分配更容易被注入失败，更贴近真实场景。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/fault-inject.h>`：提供通用故障注入框架（如 `fault_attr`, `should_fail_ex`, `setup_fault_attr` 等）。\n  - `<linux/error-injection.h>`：提供 `ALLOW_ERROR_INJECTION` 宏，用于支持动态错误注入。\n  - `<linux/mm.h>`：提供内存管理相关定义，如 `gfp_t`、`__GFP_*` 标志等。\n\n- **内核配置依赖**：\n  - 必须启用 `CONFIG_FAULT_INJECTION` 才能使用基础故障注入功能。\n  - `CONFIG_FAULT_INJECTION_DEBUG_FS` 控制是否生成 debugfs 接口。\n\n- **调用关系**：\n  - `should_fail_alloc_page()` 被内存分配路径（如 `__alloc_pages()`）调用，通常通过 `__alloc_pages_nodemask()` 中的 `should_fail_alloc_page()` 检查点触发。\n\n## 5. 使用场景\n\n- **内核开发与测试**：\n  - 开发者可通过内核启动参数（如 `fail_page_alloc=10`）或 debugfs 接口动态开启页分配失败模拟，验证内核路径在内存不足时的行为。\n  - 用于测试文件系统、网络子系统、设备驱动等模块在 `kmalloc`/`alloc_pages` 失败时的错误恢复能力。\n\n- **压力测试与稳定性验证**：\n  - 结合 `failslab` 等其他故障注入模块，构建全面的内存压力测试环境。\n  - 验证 `__GFP_NOFAIL` 等关键分配是否被正确处理，防止死锁或崩溃。\n\n- **调试特定问题**：\n  - 当怀疑某段代码未正确处理内存分配失败时，可针对性地启用该模块，复现并定位问题。",
      "similarity": 0.602609395980835,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/fail_page_alloc.c",
          "start_line": 19,
          "end_line": 58,
          "content": [
            "static int __init setup_fail_page_alloc(char *str)",
            "{",
            "\treturn setup_fault_attr(&fail_page_alloc.attr, str);",
            "}",
            "bool should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)",
            "{",
            "\tint flags = 0;",
            "",
            "\tif (order < fail_page_alloc.min_order)",
            "\t\treturn false;",
            "\tif (gfp_mask & __GFP_NOFAIL)",
            "\t\treturn false;",
            "\tif (fail_page_alloc.ignore_gfp_highmem && (gfp_mask & __GFP_HIGHMEM))",
            "\t\treturn false;",
            "\tif (fail_page_alloc.ignore_gfp_reclaim &&",
            "\t\t\t(gfp_mask & __GFP_DIRECT_RECLAIM))",
            "\t\treturn false;",
            "",
            "\t/* See comment in __should_failslab() */",
            "\tif (gfp_mask & __GFP_NOWARN)",
            "\t\tflags |= FAULT_NOWARN;",
            "",
            "\treturn should_fail_ex(&fail_page_alloc.attr, 1 << order, flags);",
            "}",
            "static int __init fail_page_alloc_debugfs(void)",
            "{",
            "\tumode_t mode = S_IFREG | 0600;",
            "\tstruct dentry *dir;",
            "",
            "\tdir = fault_create_debugfs_attr(\"fail_page_alloc\", NULL,",
            "\t\t\t\t\t&fail_page_alloc.attr);",
            "",
            "\tdebugfs_create_bool(\"ignore-gfp-wait\", mode, dir,",
            "\t\t\t    &fail_page_alloc.ignore_gfp_reclaim);",
            "\tdebugfs_create_bool(\"ignore-gfp-highmem\", mode, dir,",
            "\t\t\t    &fail_page_alloc.ignore_gfp_highmem);",
            "\tdebugfs_create_u32(\"min-order\", mode, dir, &fail_page_alloc.min_order);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "setup_fail_page_alloc, should_fail_alloc_page, fail_page_alloc_debugfs",
          "description": "实现了页面分配错误注入的初始化、判定逻辑和调试接口，通过解析命令行参数、检查GFP标志位及订单大小，决定是否模拟页面分配失败，并提供调试文件系统配置接口。",
          "similarity": 0.6584603786468506
        },
        {
          "chunk_id": 0,
          "file_path": "mm/fail_page_alloc.c",
          "start_line": 1,
          "end_line": 18,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/fault-inject.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/mm.h>",
            "",
            "static struct {",
            "\tstruct fault_attr attr;",
            "",
            "\tbool ignore_gfp_highmem;",
            "\tbool ignore_gfp_reclaim;",
            "\tu32 min_order;",
            "} fail_page_alloc = {",
            "\t.attr = FAULT_ATTR_INITIALIZER,",
            "\t.ignore_gfp_reclaim = true,",
            "\t.ignore_gfp_highmem = true,",
            "\t.min_order = 1,",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义了一个用于配置页面分配错误注入的结构体fail_page_alloc，包含故障属性、忽略GFP标志位和最小订单等参数，用于控制内存分配失败测试场景。",
          "similarity": 0.5977910161018372
        }
      ]
    },
    {
      "source_file": "mm/page_isolation.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:03:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page_isolation.c`\n\n---\n\n# page_isolation.c 技术文档\n\n## 1. 文件概述\n\n`page_isolation.c` 是 Linux 内核内存管理子系统中的关键组件，主要负责**页面隔离（Page Isolation）**功能。该文件实现了将指定物理内存范围内的页面块（pageblock）标记为 `MIGRATE_ISOLATE` 迁移类型的能力，从而阻止分配器从此区域分配新页面。此机制主要用于**连续内存分配（CMA）**和**内存热插拔（Memory Hotplug）**场景，确保在执行内存迁移或离线操作前，目标区域不再被普通分配器使用。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`has_unmovable_pages()`**  \n  检查指定 PFN 范围 `[start_pfn, end_pfn)` 内是否存在不可移动页面。返回首个不可移动页面的指针（不持有引用），若全部可移动则返回 `NULL`。\n\n- **`set_migratetype_isolate()`**  \n  将包含指定页面的 pageblock 的迁移类型设置为 `MIGRATE_ISOLATE`。前提是该范围内无不可移动页面。成功时返回 0，否则返回 `-EBUSY`。\n\n- **`unset_migratetype_isolate()`**  \n  恢复 pageblock 的原始迁移类型，取消隔离状态，并将隔离期间产生的空闲页面归还到对应迁移类型的空闲链表中。\n\n- **`__first_valid_page()`**（代码片段未完整）  \n  辅助函数，用于在给定 PFN 范围内查找第一个有效的 struct page 实例。\n\n### 关键数据结构与宏\n\n- **`MIGRATE_ISOLATE`**: 特殊的迁移类型，表示该 pageblock 已被隔离，分配器应跳过。\n- **`pageblock_flags`**: 存储每个 pageblock 的迁移类型信息。\n- **`zone->nr_isolate_pageblock`**: 记录当前内存区域（zone）中被隔离的 pageblock 数量。\n\n## 3. 关键实现\n\n### 不可移动页面检测逻辑 (`has_unmovable_pages`)\n- **保留页面处理**: 所有 `PG_reserved` 页面（如 bootmem 分配、内存空洞）被视为不可移动。\n- **ZONE_MOVABLE 优化**: 若页面属于 `ZONE_MOVABLE`，则跳过详细检查（假设其内容可移动）。\n- **大页（Huge Page/THP）处理**: \n  - HugeTLB 页面需支持迁移才视为可移动。\n  - 透明大页（THP）若非 LRU 且非 `__PageMovable` 则视为不可移动。\n  - 跳过大页的尾页以避免重复检查。\n- **空闲页面处理**: Buddy 系统中的空闲页面（`PageBuddy`）可安全跳过。\n- **特殊标志处理**:\n  - 内存离线（`MEMORY_OFFLINE`）时，`PageHWPoison` 和 `PageOffline` 页面被临时视为可移动，允许驱动在离线回调中释放引用。\n- **可移动性判断**: 仅当页面属于 LRU 链表或具有 `__PageMovable` 属性时才视为可移动。\n\n### 隔离与取消隔离机制\n- **原子性保障**: 所有操作在 `zone->lock` 自旋锁保护下进行，确保并发安全。\n- **空闲页面迁移**: \n  - 隔离时调用 `move_freepages_block_isolate()` 将 pageblock 内空闲页面迁移到 `MIGRATE_ISOLATE` 链表。\n  - 取消隔离时，若存在高阶空闲页（≥ `pageblock_order`），先尝试隔离再归还，以触发 buddy 合并。\n- **错误报告**: 隔离失败时可通过 `REPORT_FAILURE` 标志触发 `dump_page()` 输出调试信息。\n\n### 限制与注意事项\n- **竞态条件**: 函数注释明确指出检测结果非精确（\"you can't expect this function should be exact\"），因未持有页面锁或 LRU 锁。\n- **范围约束**: 输入范围必须位于同一 pageblock 和同一内存区域（zone）内。\n- **CMA 特殊处理**: CMA 分配即使遇到实际不可移动页面，也强制视为可移动以支持隔离。\n\n## 4. 依赖关系\n\n- **内存管理核心**: 依赖 `<linux/mm.h>`、`internal.h` 提供的页面、区域（zone）、buddy 系统等基础功能。\n- **迁移框架**: 与 `<linux/migrate.h>` 协同工作，为页面迁移提供前置隔离能力。\n- **大页支持**: 通过 `<linux/hugetlb.h>` 处理 HugeTLB 页面的迁移属性。\n- **内存热插拔**: 服务于 `<linux/memory.h>` 中的内存离线（offline）流程。\n- **调试设施**: 使用 `<linux/page_owner.h>` 和 tracepoint（`<trace/events/page_isolation.h>`）辅助调试。\n\n## 5. 使用场景\n\n1. **连续内存分配（CMA）**  \n   在 `alloc_contig_range()` 中调用 `set_migratetype_isolate()` 隔离目标区域，确保后续迁移操作不受新分配干扰。\n\n2. **内存热插拔（Memory Hotplug）**  \n   - **内存离线**: 在 `offline_pages()` 流程中隔离待移除内存，确保无活跃分配后再迁移页面。\n   - **内存上线**: 通过 `unset_migratetype_isolate()` 恢复隔离区域，使其重新参与分配。\n\n3. **内存碎片整理（Compaction）**  \n   作为迁移前的准备步骤，隔离特定区域以进行定向碎片整理。\n\n4. **硬件错误处理**  \n   结合 `PageHWPoison` 机制，在隔离含错误页面的区域时提供特殊处理路径。",
      "similarity": 0.5821321606636047,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/page_isolation.c",
          "start_line": 305,
          "end_line": 447,
          "content": [
            "static int isolate_single_pageblock(unsigned long boundary_pfn, int flags,",
            "\t\t\tgfp_t gfp_flags, bool isolate_before, bool skip_isolation,",
            "\t\t\tint migratetype)",
            "{",
            "\tunsigned long start_pfn;",
            "\tunsigned long isolate_pageblock;",
            "\tunsigned long pfn;",
            "\tstruct zone *zone;",
            "\tint ret;",
            "",
            "\tVM_BUG_ON(!pageblock_aligned(boundary_pfn));",
            "",
            "\tif (isolate_before)",
            "\t\tisolate_pageblock = boundary_pfn - pageblock_nr_pages;",
            "\telse",
            "\t\tisolate_pageblock = boundary_pfn;",
            "",
            "\t/*",
            "\t * scan at the beginning of MAX_ORDER_NR_PAGES aligned range to avoid",
            "\t * only isolating a subset of pageblocks from a bigger than pageblock",
            "\t * free or in-use page. Also make sure all to-be-isolated pageblocks",
            "\t * are within the same zone.",
            "\t */",
            "\tzone  = page_zone(pfn_to_page(isolate_pageblock));",
            "\tstart_pfn  = max(ALIGN_DOWN(isolate_pageblock, MAX_ORDER_NR_PAGES),",
            "\t\t\t\t      zone->zone_start_pfn);",
            "",
            "\tif (skip_isolation) {",
            "\t\tint mt __maybe_unused = get_pageblock_migratetype(pfn_to_page(isolate_pageblock));",
            "",
            "\t\tVM_BUG_ON(!is_migrate_isolate(mt));",
            "\t} else {",
            "\t\tret = set_migratetype_isolate(pfn_to_page(isolate_pageblock), migratetype,",
            "\t\t\t\tflags, isolate_pageblock, isolate_pageblock + pageblock_nr_pages);",
            "",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * Bail out early when the to-be-isolated pageblock does not form",
            "\t * a free or in-use page across boundary_pfn:",
            "\t *",
            "\t * 1. isolate before boundary_pfn: the page after is not online",
            "\t * 2. isolate after boundary_pfn: the page before is not online",
            "\t *",
            "\t * This also ensures correctness. Without it, when isolate after",
            "\t * boundary_pfn and [start_pfn, boundary_pfn) are not online,",
            "\t * __first_valid_page() will return unexpected NULL in the for loop",
            "\t * below.",
            "\t */",
            "\tif (isolate_before) {",
            "\t\tif (!pfn_to_online_page(boundary_pfn))",
            "\t\t\treturn 0;",
            "\t} else {",
            "\t\tif (!pfn_to_online_page(boundary_pfn - 1))",
            "\t\t\treturn 0;",
            "\t}",
            "",
            "\tfor (pfn = start_pfn; pfn < boundary_pfn;) {",
            "\t\tstruct page *page = __first_valid_page(pfn, boundary_pfn - pfn);",
            "",
            "\t\tVM_BUG_ON(!page);",
            "\t\tpfn = page_to_pfn(page);",
            "",
            "\t\tif (PageBuddy(page)) {",
            "\t\t\tint order = buddy_order(page);",
            "",
            "\t\t\t/* move_freepages_block_isolate() handled this */",
            "\t\t\tVM_WARN_ON_ONCE(pfn + (1 << order) > boundary_pfn);",
            "",
            "\t\t\tpfn += 1UL << order;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * If a compound page is straddling our block, attempt",
            "\t\t * to migrate it out of the way.",
            "\t\t *",
            "\t\t * We don't have to worry about this creating a large",
            "\t\t * free page that straddles into our block: gigantic",
            "\t\t * pages are freed as order-0 chunks, and LRU pages",
            "\t\t * (currently) do not exceed pageblock_order.",
            "\t\t *",
            "\t\t * The block of interest has already been marked",
            "\t\t * MIGRATE_ISOLATE above, so when migration is done it",
            "\t\t * will free its pages onto the correct freelists.",
            "\t\t */",
            "\t\tif (PageCompound(page)) {",
            "\t\t\tstruct page *head = compound_head(page);",
            "\t\t\tunsigned long head_pfn = page_to_pfn(head);",
            "\t\t\tunsigned long nr_pages = compound_nr(head);",
            "",
            "\t\t\tif (head_pfn + nr_pages <= boundary_pfn) {",
            "\t\t\t\tpfn = head_pfn + nr_pages;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "#if defined CONFIG_COMPACTION || defined CONFIG_CMA",
            "\t\t\tif (PageHuge(page)) {",
            "\t\t\t\tint page_mt = get_pageblock_migratetype(page);",
            "\t\t\t\tstruct compact_control cc = {",
            "\t\t\t\t\t.nr_migratepages = 0,",
            "\t\t\t\t\t.order = -1,",
            "\t\t\t\t\t.zone = page_zone(pfn_to_page(head_pfn)),",
            "\t\t\t\t\t.mode = MIGRATE_SYNC,",
            "\t\t\t\t\t.ignore_skip_hint = true,",
            "\t\t\t\t\t.no_set_skip_hint = true,",
            "\t\t\t\t\t.gfp_mask = gfp_flags,",
            "\t\t\t\t\t.alloc_contig = true,",
            "\t\t\t\t};",
            "\t\t\t\tINIT_LIST_HEAD(&cc.migratepages);",
            "",
            "\t\t\t\tret = __alloc_contig_migrate_range(&cc, head_pfn,",
            "\t\t\t\t\t\t\thead_pfn + nr_pages, page_mt);",
            "\t\t\t\tif (ret)",
            "\t\t\t\t\tgoto failed;",
            "\t\t\t\tpfn = head_pfn + nr_pages;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\t/*",
            "\t\t\t * These pages are movable too, but they're",
            "\t\t\t * not expected to exceed pageblock_order.",
            "\t\t\t *",
            "\t\t\t * Let us know when they do, so we can add",
            "\t\t\t * proper free and split handling for them.",
            "\t\t\t */",
            "\t\t\tVM_WARN_ON_ONCE_PAGE(PageLRU(page), page);",
            "\t\t\tVM_WARN_ON_ONCE_PAGE(__PageMovable(page), page);",
            "#endif",
            "\t\t\tgoto failed;",
            "\t\t}",
            "",
            "\t\tpfn++;",
            "\t}",
            "\treturn 0;",
            "failed:",
            "\t/* restore the original migratetype */",
            "\tif (!skip_isolation)",
            "\t\tunset_migratetype_isolate(pfn_to_page(isolate_pageblock), migratetype);",
            "\treturn -EBUSY;",
            "}"
          ],
          "function_name": "isolate_single_pageblock",
          "description": "`isolate_single_pageblock`隔离单个页面块，跳过自由页面并迁移复合/巨型页面，若失败则恢复原迁移类型，确保隔离区域不含不可移动页。",
          "similarity": 0.5763403177261353
        },
        {
          "chunk_id": 1,
          "file_path": "mm/page_isolation.c",
          "start_line": 147,
          "end_line": 262,
          "content": [
            "static int set_migratetype_isolate(struct page *page, int migratetype, int isol_flags,",
            "\t\t\tunsigned long start_pfn, unsigned long end_pfn)",
            "{",
            "\tstruct zone *zone = page_zone(page);",
            "\tstruct page *unmovable;",
            "\tunsigned long flags;",
            "\tunsigned long check_unmovable_start, check_unmovable_end;",
            "",
            "\tspin_lock_irqsave(&zone->lock, flags);",
            "",
            "\t/*",
            "\t * We assume the caller intended to SET migrate type to isolate.",
            "\t * If it is already set, then someone else must have raced and",
            "\t * set it before us.",
            "\t */",
            "\tif (is_migrate_isolate_page(page)) {",
            "\t\tspin_unlock_irqrestore(&zone->lock, flags);",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\t/*",
            "\t * FIXME: Now, memory hotplug doesn't call shrink_slab() by itself.",
            "\t * We just check MOVABLE pages.",
            "\t *",
            "\t * Pass the intersection of [start_pfn, end_pfn) and the page's pageblock",
            "\t * to avoid redundant checks.",
            "\t */",
            "\tcheck_unmovable_start = max(page_to_pfn(page), start_pfn);",
            "\tcheck_unmovable_end = min(pageblock_end_pfn(page_to_pfn(page)),",
            "\t\t\t\t  end_pfn);",
            "",
            "\tunmovable = has_unmovable_pages(check_unmovable_start, check_unmovable_end,",
            "\t\t\tmigratetype, isol_flags);",
            "\tif (!unmovable) {",
            "\t\tif (!move_freepages_block_isolate(zone, page, MIGRATE_ISOLATE)) {",
            "\t\t\tspin_unlock_irqrestore(&zone->lock, flags);",
            "\t\t\treturn -EBUSY;",
            "\t\t}",
            "\t\tzone->nr_isolate_pageblock++;",
            "\t\tspin_unlock_irqrestore(&zone->lock, flags);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tspin_unlock_irqrestore(&zone->lock, flags);",
            "\tif (isol_flags & REPORT_FAILURE) {",
            "\t\t/*",
            "\t\t * printk() with zone->lock held will likely trigger a",
            "\t\t * lockdep splat, so defer it here.",
            "\t\t */",
            "\t\tdump_page(unmovable, \"unmovable page\");",
            "\t}",
            "",
            "\treturn -EBUSY;",
            "}",
            "static void unset_migratetype_isolate(struct page *page, int migratetype)",
            "{",
            "\tstruct zone *zone;",
            "\tunsigned long flags;",
            "\tbool isolated_page = false;",
            "\tunsigned int order;",
            "\tstruct page *buddy;",
            "",
            "\tzone = page_zone(page);",
            "\tspin_lock_irqsave(&zone->lock, flags);",
            "\tif (!is_migrate_isolate_page(page))",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Because freepage with more than pageblock_order on isolated",
            "\t * pageblock is restricted to merge due to freepage counting problem,",
            "\t * it is possible that there is free buddy page.",
            "\t * move_freepages_block() doesn't care of merge so we need other",
            "\t * approach in order to merge them. Isolation and free will make",
            "\t * these pages to be merged.",
            "\t */",
            "\tif (PageBuddy(page)) {",
            "\t\torder = buddy_order(page);",
            "\t\tif (order >= pageblock_order && order < MAX_PAGE_ORDER) {",
            "\t\t\tbuddy = find_buddy_page_pfn(page, page_to_pfn(page),",
            "\t\t\t\t\t\t    order, NULL);",
            "\t\t\tif (buddy && !is_migrate_isolate_page(buddy)) {",
            "\t\t\t\tisolated_page = !!__isolate_free_page(page, order);",
            "\t\t\t\t/*",
            "\t\t\t\t * Isolating a free page in an isolated pageblock",
            "\t\t\t\t * is expected to always work as watermarks don't",
            "\t\t\t\t * apply here.",
            "\t\t\t\t */",
            "\t\t\t\tVM_WARN_ON(!isolated_page);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * If we isolate freepage with more than pageblock_order, there",
            "\t * should be no freepage in the range, so we could avoid costly",
            "\t * pageblock scanning for freepage moving.",
            "\t *",
            "\t * We didn't actually touch any of the isolated pages, so place them",
            "\t * to the tail of the freelist. This is an optimization for memory",
            "\t * onlining - just onlined memory won't immediately be considered for",
            "\t * allocation.",
            "\t */",
            "\tif (!isolated_page) {",
            "\t\t/*",
            "\t\t * Isolating this block already succeeded, so this",
            "\t\t * should not fail on zone boundaries.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(!move_freepages_block_isolate(zone, page, migratetype));",
            "\t} else {",
            "\t\tset_pageblock_migratetype(page, migratetype);",
            "\t\t__putback_isolated_page(page, order, migratetype);",
            "\t}",
            "\tzone->nr_isolate_pageblock--;",
            "out:",
            "\tspin_unlock_irqrestore(&zone->lock, flags);",
            "}"
          ],
          "function_name": "set_migratetype_isolate, unset_migratetype_isolate",
          "description": "`set_migratetype_isolate`尝试设置页面块为隔离类型需先确认无不可移动页，成功则增加隔离计数；`unset_migratetype_isolate`移除隔离状态，处理自由页面合并与迁移异常情况。",
          "similarity": 0.5747390985488892
        },
        {
          "chunk_id": 3,
          "file_path": "mm/page_isolation.c",
          "start_line": 494,
          "end_line": 623,
          "content": [
            "int start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,",
            "\t\t\t     int migratetype, int flags, gfp_t gfp_flags)",
            "{",
            "\tunsigned long pfn;",
            "\tstruct page *page;",
            "\t/* isolation is done at page block granularity */",
            "\tunsigned long isolate_start = pageblock_start_pfn(start_pfn);",
            "\tunsigned long isolate_end = pageblock_align(end_pfn);",
            "\tint ret;",
            "\tbool skip_isolation = false;",
            "",
            "\t/* isolate [isolate_start, isolate_start + pageblock_nr_pages) pageblock */",
            "\tret = isolate_single_pageblock(isolate_start, flags, gfp_flags, false,",
            "\t\t\tskip_isolation, migratetype);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (isolate_start == isolate_end - pageblock_nr_pages)",
            "\t\tskip_isolation = true;",
            "",
            "\t/* isolate [isolate_end - pageblock_nr_pages, isolate_end) pageblock */",
            "\tret = isolate_single_pageblock(isolate_end, flags, gfp_flags, true,",
            "\t\t\tskip_isolation, migratetype);",
            "\tif (ret) {",
            "\t\tunset_migratetype_isolate(pfn_to_page(isolate_start), migratetype);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/* skip isolated pageblocks at the beginning and end */",
            "\tfor (pfn = isolate_start + pageblock_nr_pages;",
            "\t     pfn < isolate_end - pageblock_nr_pages;",
            "\t     pfn += pageblock_nr_pages) {",
            "\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);",
            "\t\tif (page && set_migratetype_isolate(page, migratetype, flags,",
            "\t\t\t\t\tstart_pfn, end_pfn)) {",
            "\t\t\tundo_isolate_page_range(isolate_start, pfn, migratetype);",
            "\t\t\tunset_migratetype_isolate(",
            "\t\t\t\tpfn_to_page(isolate_end - pageblock_nr_pages),",
            "\t\t\t\tmigratetype);",
            "\t\t\treturn -EBUSY;",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}",
            "void undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,",
            "\t\t\t    int migratetype)",
            "{",
            "\tunsigned long pfn;",
            "\tstruct page *page;",
            "\tunsigned long isolate_start = pageblock_start_pfn(start_pfn);",
            "\tunsigned long isolate_end = pageblock_align(end_pfn);",
            "",
            "\tfor (pfn = isolate_start;",
            "\t     pfn < isolate_end;",
            "\t     pfn += pageblock_nr_pages) {",
            "\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);",
            "\t\tif (!page || !is_migrate_isolate_page(page))",
            "\t\t\tcontinue;",
            "\t\tunset_migratetype_isolate(page, migratetype);",
            "\t}",
            "}",
            "static unsigned long",
            "__test_page_isolated_in_pageblock(unsigned long pfn, unsigned long end_pfn,",
            "\t\t\t\t  int flags)",
            "{",
            "\tstruct page *page;",
            "",
            "\twhile (pfn < end_pfn) {",
            "\t\tpage = pfn_to_page(pfn);",
            "\t\tif (PageBuddy(page))",
            "\t\t\t/*",
            "\t\t\t * If the page is on a free list, it has to be on",
            "\t\t\t * the correct MIGRATE_ISOLATE freelist. There is no",
            "\t\t\t * simple way to verify that as VM_BUG_ON(), though.",
            "\t\t\t */",
            "\t\t\tpfn += 1 << buddy_order(page);",
            "\t\telse if ((flags & MEMORY_OFFLINE) && PageHWPoison(page))",
            "\t\t\t/* A HWPoisoned page cannot be also PageBuddy */",
            "\t\t\tpfn++;",
            "\t\telse if ((flags & MEMORY_OFFLINE) && PageOffline(page) &&",
            "\t\t\t !page_count(page))",
            "\t\t\t/*",
            "\t\t\t * The responsible driver agreed to skip PageOffline()",
            "\t\t\t * pages when offlining memory by dropping its",
            "\t\t\t * reference in MEM_GOING_OFFLINE.",
            "\t\t\t */",
            "\t\t\tpfn++;",
            "\t\telse",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn pfn;",
            "}",
            "int test_pages_isolated(unsigned long start_pfn, unsigned long end_pfn,",
            "\t\t\tint isol_flags)",
            "{",
            "\tunsigned long pfn, flags;",
            "\tstruct page *page;",
            "\tstruct zone *zone;",
            "\tint ret;",
            "",
            "\t/*",
            "\t * Note: pageblock_nr_pages != MAX_PAGE_ORDER. Then, chunks of free",
            "\t * pages are not aligned to pageblock_nr_pages.",
            "\t * Then we just check migratetype first.",
            "\t */",
            "\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {",
            "\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);",
            "\t\tif (page && !is_migrate_isolate_page(page))",
            "\t\t\tbreak;",
            "\t}",
            "\tpage = __first_valid_page(start_pfn, end_pfn - start_pfn);",
            "\tif ((pfn < end_pfn) || !page) {",
            "\t\tret = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* Check all pages are free or marked as ISOLATED */",
            "\tzone = page_zone(page);",
            "\tspin_lock_irqsave(&zone->lock, flags);",
            "\tpfn = __test_page_isolated_in_pageblock(start_pfn, end_pfn, isol_flags);",
            "\tspin_unlock_irqrestore(&zone->lock, flags);",
            "",
            "\tret = pfn < end_pfn ? -EBUSY : 0;",
            "",
            "out:",
            "\ttrace_test_pages_isolated(start_pfn, end_pfn, pfn);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "start_isolate_page_range, undo_isolate_page_range, __test_page_isolated_in_pageblock, test_pages_isolated",
          "description": "`start_isolate_page_range`分步隔离连续页面块范围，`undo_isolate_page_range`撤销隔离；`test_pages_isolated`验证隔离完整性，确保所有页面处于隔离或自由状态。",
          "similarity": 0.5656768083572388
        },
        {
          "chunk_id": 0,
          "file_path": "mm/page_isolation.c",
          "start_line": 1,
          "end_line": 146,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * linux/mm/page_isolation.c",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/memory.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/migrate.h>",
            "#include \"internal.h\"",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/page_isolation.h>",
            "",
            "/*",
            " * This function checks whether the range [start_pfn, end_pfn) includes",
            " * unmovable pages or not. The range must fall into a single pageblock and",
            " * consequently belong to a single zone.",
            " *",
            " * PageLRU check without isolation or lru_lock could race so that",
            " * MIGRATE_MOVABLE block might include unmovable pages. And __PageMovable",
            " * check without lock_page also may miss some movable non-lru pages at",
            " * race condition. So you can't expect this function should be exact.",
            " *",
            " * Returns a page without holding a reference. If the caller wants to",
            " * dereference that page (e.g., dumping), it has to make sure that it",
            " * cannot get removed (e.g., via memory unplug) concurrently.",
            " *",
            " */",
            "static struct page *has_unmovable_pages(unsigned long start_pfn, unsigned long end_pfn,",
            "\t\t\t\tint migratetype, int flags)",
            "{",
            "\tstruct page *page = pfn_to_page(start_pfn);",
            "\tstruct zone *zone = page_zone(page);",
            "\tunsigned long pfn;",
            "",
            "\tVM_BUG_ON(pageblock_start_pfn(start_pfn) !=",
            "\t\t  pageblock_start_pfn(end_pfn - 1));",
            "",
            "\tif (is_migrate_cma_page(page)) {",
            "\t\t/*",
            "\t\t * CMA allocations (alloc_contig_range) really need to mark",
            "\t\t * isolate CMA pageblocks even when they are not movable in fact",
            "\t\t * so consider them movable here.",
            "\t\t */",
            "\t\tif (is_migrate_cma(migratetype))",
            "\t\t\treturn NULL;",
            "",
            "\t\treturn page;",
            "\t}",
            "",
            "\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {",
            "\t\tpage = pfn_to_page(pfn);",
            "",
            "\t\t/*",
            "\t\t * Both, bootmem allocations and memory holes are marked",
            "\t\t * PG_reserved and are unmovable. We can even have unmovable",
            "\t\t * allocations inside ZONE_MOVABLE, for example when",
            "\t\t * specifying \"movablecore\".",
            "\t\t */",
            "\t\tif (PageReserved(page))",
            "\t\t\treturn page;",
            "",
            "\t\t/*",
            "\t\t * If the zone is movable and we have ruled out all reserved",
            "\t\t * pages then it should be reasonably safe to assume the rest",
            "\t\t * is movable.",
            "\t\t */",
            "\t\tif (zone_idx(zone) == ZONE_MOVABLE)",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Hugepages are not in LRU lists, but they're movable.",
            "\t\t * THPs are on the LRU, but need to be counted as #small pages.",
            "\t\t * We need not scan over tail pages because we don't",
            "\t\t * handle each tail page individually in migration.",
            "\t\t */",
            "\t\tif (PageHuge(page) || PageTransCompound(page)) {",
            "\t\t\tstruct folio *folio = page_folio(page);",
            "\t\t\tunsigned int skip_pages;",
            "",
            "\t\t\tif (PageHuge(page)) {",
            "\t\t\t\tif (!hugepage_migration_supported(folio_hstate(folio)))",
            "\t\t\t\t\treturn page;",
            "\t\t\t} else if (!folio_test_lru(folio) && !__folio_test_movable(folio)) {",
            "\t\t\t\treturn page;",
            "\t\t\t}",
            "",
            "\t\t\tskip_pages = folio_nr_pages(folio) - folio_page_idx(folio, page);",
            "\t\t\tpfn += skip_pages - 1;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * We can't use page_count without pin a page",
            "\t\t * because another CPU can free compound page.",
            "\t\t * This check already skips compound tails of THP",
            "\t\t * because their page->_refcount is zero at all time.",
            "\t\t */",
            "\t\tif (!page_ref_count(page)) {",
            "\t\t\tif (PageBuddy(page))",
            "\t\t\t\tpfn += (1 << buddy_order(page)) - 1;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * The HWPoisoned page may be not in buddy system, and",
            "\t\t * page_count() is not 0.",
            "\t\t */",
            "\t\tif ((flags & MEMORY_OFFLINE) && PageHWPoison(page))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * We treat all PageOffline() pages as movable when offlining",
            "\t\t * to give drivers a chance to decrement their reference count",
            "\t\t * in MEM_GOING_OFFLINE in order to indicate that these pages",
            "\t\t * can be offlined as there are no direct references anymore.",
            "\t\t * For actually unmovable PageOffline() where the driver does",
            "\t\t * not support this, we will fail later when trying to actually",
            "\t\t * move these pages that still have a reference count > 0.",
            "\t\t * (false negatives in this function only)",
            "\t\t */",
            "\t\tif ((flags & MEMORY_OFFLINE) && PageOffline(page))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (__PageMovable(page) || PageLRU(page))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * If there are RECLAIMABLE pages, we need to check",
            "\t\t * it.  But now, memory offline itself doesn't call",
            "\t\t * shrink_node_slabs() and it still to be fixed.",
            "\t\t */",
            "\t\treturn page;",
            "\t}",
            "\treturn NULL;",
            "}",
            "",
            "/*",
            " * This function set pageblock migratetype to isolate if no unmovable page is",
            " * present in [start_pfn, end_pfn). The pageblock must intersect with",
            " * [start_pfn, end_pfn).",
            " */"
          ],
          "function_name": null,
          "description": "函数`has_unmovable_pages`检查指定PFN范围是否存在不可移动页面，通过遍历并判断页面是否为保留、非MOVABLE或特殊类型（如HugeTLB），返回首个不可移动页面指针。结果可能因竞态存在误差。",
          "similarity": 0.5309889316558838
        }
      ]
    }
  ]
}