{
  "query": "Linux内核retpoline机制实现原理",
  "timestamp": "2025-12-26 01:28:21",
  "retrieved_files": [
    {
      "source_file": "kernel/trace/rethook.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:06:37\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\rethook.c`\n\n---\n\n# `trace/rethook.c` 技术文档\n\n## 1. 文件概述\n\n`rethook.c` 实现了 Linux 内核中的 **rethook（Return Hook）** 机制，这是一种通用的函数返回拦截框架，用于在函数返回时执行回调处理。该机制为 kretprobes、ftrace 等动态追踪工具提供底层支持，允许在函数返回点安全地插入处理逻辑，同时管理返回地址的重写与恢复。rethook 使用 per-task 的无锁链表（LLIST）作为“影子栈”来跟踪活跃的 hook 节点，并结合 RCU 和引用计数实现内存安全的生命周期管理。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct rethook`：rethook 实例，包含回调函数指针、私有数据、节点池（freelist）和引用计数。\n- `struct rethook_node`：单个 hook 节点，嵌入在用户数据结构中，包含返回地址、帧指针、所属 rethook 指针及链表/空闲链表节点。\n\n### 主要函数\n| 函数 | 功能描述 |\n|------|--------|\n| `rethook_alloc()` | 分配并初始化一个新的 `rethook` 实例 |\n| `rethook_free()` / `rethook_stop()` | 停止并异步释放 `rethook` 实例 |\n| `rethook_add_node()` | 向 rethook 添加预分配的节点 |\n| `rethook_try_get()` | 从 rethook 的空闲池中获取一个未使用的节点（需禁用抢占） |\n| `rethook_hook()` | 在函数入口处注册返回 hook，将节点加入当前任务的 rethook 链表 |\n| `rethook_recycle()` | 回收 hook 节点：若 rethook 有效则归还到空闲池，否则异步释放 |\n| `rethook_find_ret_addr()` | 在指定任务的 rethook 链表中查找与给定帧指针对应的真实返回地址 |\n| `rethook_flush_task()` | 在任务退出时清理其所有未返回的 rethook 节点 |\n\n## 3. 关键实现\n\n### 影子栈与任务绑定\n- 每个 `task_struct` 包含一个 `rethooks` 字段（`struct llist_head`），用于存储该任务当前活跃的所有 `rethook_node`。\n- 使用无锁链表（LLIST）实现高效、并发安全的插入（`__llist_add`）和批量删除（`__llist_del_all`）。\n\n### 内存与生命周期管理\n- **引用计数**：`rethook` 的 `ref` 字段初始为 1，每添加一个节点加 1；节点回收时减 1。当引用归零且节点池清空后，`rethook` 本体被释放。\n- **RCU 安全**：通过 `rcu_assign_pointer()` 和 `rcu_dereference_check()` 管理 `handler` 指针的读写，确保在 RCU 读侧临界区内安全访问。\n- **延迟释放**：`rethook_free()` 和无效节点的回收均通过 `call_rcu()` 异步执行，避免在中断或原子上下文中释放内存。\n\n### 上下文感知的 Hook 注入\n- `rethook_hook()` 接收 `mcount` 参数区分调用上下文（ftrace vs kprobe），由架构相关代码（`arch_rethook_prepare()`）决定如何修改返回地址（例如插入 trampoline）。\n- 要求调用者处于 RCU 可用上下文（`rcu_is_watching()`），确保后续的 RCU 回调能正确执行。\n\n### 返回地址恢复\n- `rethook_find_ret_addr()` 遍历任务的 rethook 链表，跳过 trampoline 地址，返回与指定栈帧匹配的真实返回地址，用于栈回溯修正。\n\n## 4. 依赖关系\n\n- **架构依赖**：依赖 `arch_rethook_prepare()` 和 `arch_rethook_trampoline`（由各架构实现），用于实际修改返回地址和提供 trampoline 函数。\n- **内核子系统**：\n  - `<linux/rcu.h>`：RCU 同步机制\n  - `<linux/slab.h>`：动态内存分配\n  - `<linux/preempt.h>`：抢占控制\n  - `<linux/kprobes.h>`：与 kretprobes 集成\n  - `<linux/freelist.h>`：无锁空闲链表实现\n- **任务管理**：依赖 `task_struct::rethooks` 字段和 `delayed_put_task_struct()` 回调。\n\n## 5. 使用场景\n\n- **kretprobes 实现**：作为 kretprobe 的底层机制，拦截函数返回并执行用户定义的处理函数。\n- **ftrace 动态追踪**：在 function graph tracer 等场景中，用于捕获函数返回事件。\n- **内核栈回溯修正**：当函数返回地址被 trampoline 覆盖时，通过 `rethook_find_ret_addr()` 恢复原始调用栈。\n- **安全监控与性能分析**：第三方模块可基于 rethook 框架实现函数级的返回行为监控或统计。",
      "similarity": 0.5906348824501038,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/rethook.c",
          "start_line": 267,
          "end_line": 334,
          "content": [
            "void __weak arch_rethook_fixup_return(struct pt_regs *regs,",
            "\t\t\t\t      unsigned long correct_ret_addr)",
            "{",
            "\t/*",
            "\t * Do nothing by default. If the architecture which uses a",
            "\t * frame pointer to record real return address on the stack,",
            "\t * it should fill this function to fixup the return address",
            "\t * so that stacktrace works from the rethook handler.",
            "\t */",
            "}",
            "unsigned long rethook_trampoline_handler(struct pt_regs *regs,",
            "\t\t\t\t\t unsigned long frame)",
            "{",
            "\tstruct llist_node *first, *node = NULL;",
            "\tunsigned long correct_ret_addr;",
            "\trethook_handler_t handler;",
            "\tstruct rethook_node *rhn;",
            "",
            "\tcorrect_ret_addr = __rethook_find_ret_addr(current, &node);",
            "\tif (!correct_ret_addr) {",
            "\t\tpr_err(\"rethook: Return address not found! Maybe there is a bug in the kernel\\n\");",
            "\t\tBUG_ON(1);",
            "\t}",
            "",
            "\tinstruction_pointer_set(regs, correct_ret_addr);",
            "",
            "\t/*",
            "\t * These loops must be protected from rethook_free_rcu() because those",
            "\t * are accessing 'rhn->rethook'.",
            "\t */",
            "\tpreempt_disable_notrace();",
            "",
            "\t/*",
            "\t * Run the handler on the shadow stack. Do not unlink the list here because",
            "\t * stackdump inside the handlers needs to decode it.",
            "\t */",
            "\tfirst = current->rethooks.first;",
            "\twhile (first) {",
            "\t\trhn = container_of(first, struct rethook_node, llist);",
            "\t\tif (WARN_ON_ONCE(rhn->frame != frame))",
            "\t\t\tbreak;",
            "\t\thandler = rethook_get_handler(rhn->rethook);",
            "\t\tif (handler)",
            "\t\t\thandler(rhn, rhn->rethook->data,",
            "\t\t\t\tcorrect_ret_addr, regs);",
            "",
            "\t\tif (first == node)",
            "\t\t\tbreak;",
            "\t\tfirst = first->next;",
            "\t}",
            "",
            "\t/* Fixup registers for returning to correct address. */",
            "\tarch_rethook_fixup_return(regs, correct_ret_addr);",
            "",
            "\t/* Unlink used shadow stack */",
            "\tfirst = current->rethooks.first;",
            "\tcurrent->rethooks.first = node->next;",
            "\tnode->next = NULL;",
            "",
            "\twhile (first) {",
            "\t\trhn = container_of(first, struct rethook_node, llist);",
            "\t\tfirst = first->next;",
            "\t\trethook_recycle(rhn);",
            "\t}",
            "\tpreempt_enable_notrace();",
            "",
            "\treturn correct_ret_addr;",
            "}"
          ],
          "function_name": "arch_rethook_fixup_return, rethook_trampoline_handler",
          "description": "提供架构无关的返回地址修复接口与trampoline处理函数，协调影子堆栈遍历、处理程序执行及寄存器状态恢复流程",
          "similarity": 0.5858244299888611
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/rethook.c",
          "start_line": 1,
          "end_line": 21,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "#define pr_fmt(fmt) \"rethook: \" fmt",
            "",
            "#include <linux/bug.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/preempt.h>",
            "#include <linux/rethook.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "",
            "/* Return hook list (shadow stack by list) */",
            "",
            "/*",
            " * This function is called from delayed_put_task_struct() when a task is",
            " * dead and cleaned up to recycle any kretprobe instances associated with",
            " * this task. These left over instances represent probed functions that",
            " * have been called but will never return.",
            " */"
          ],
          "function_name": null,
          "description": "定义rethook模块的基础结构及函数声明，用于在任务终止时回收关联的kretprobe实例，防止僵尸探针残留",
          "similarity": 0.5666119456291199
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/rethook.c",
          "start_line": 22,
          "end_line": 131,
          "content": [
            "void rethook_flush_task(struct task_struct *tk)",
            "{",
            "\tstruct rethook_node *rhn;",
            "\tstruct llist_node *node;",
            "",
            "\tnode = __llist_del_all(&tk->rethooks);",
            "\twhile (node) {",
            "\t\trhn = container_of(node, struct rethook_node, llist);",
            "\t\tnode = node->next;",
            "\t\tpreempt_disable();",
            "\t\trethook_recycle(rhn);",
            "\t\tpreempt_enable();",
            "\t}",
            "}",
            "static void rethook_free_rcu(struct rcu_head *head)",
            "{",
            "\tstruct rethook *rh = container_of(head, struct rethook, rcu);",
            "\tobjpool_fini(&rh->pool);",
            "}",
            "void rethook_stop(struct rethook *rh)",
            "{",
            "\trcu_assign_pointer(rh->handler, NULL);",
            "}",
            "void rethook_free(struct rethook *rh)",
            "{",
            "\trethook_stop(rh);",
            "",
            "\tcall_rcu(&rh->rcu, rethook_free_rcu);",
            "}",
            "static int rethook_init_node(void *nod, void *context)",
            "{",
            "\tstruct rethook_node *node = nod;",
            "",
            "\tnode->rethook = context;",
            "\treturn 0;",
            "}",
            "static int rethook_fini_pool(struct objpool_head *head, void *context)",
            "{",
            "\tkfree(context);",
            "\treturn 0;",
            "}",
            "static inline rethook_handler_t rethook_get_handler(struct rethook *rh)",
            "{",
            "\treturn (rethook_handler_t)rcu_dereference_check(rh->handler,",
            "\t\t\t\t\t\t\trcu_read_lock_any_held());",
            "}",
            "static void free_rethook_node_rcu(struct rcu_head *head)",
            "{",
            "\tstruct rethook_node *node = container_of(head, struct rethook_node, rcu);",
            "\tstruct rethook *rh = node->rethook;",
            "",
            "\tobjpool_drop(node, &rh->pool);",
            "}",
            "void rethook_recycle(struct rethook_node *node)",
            "{",
            "\trethook_handler_t handler;",
            "",
            "\thandler = rethook_get_handler(node->rethook);",
            "\tif (likely(handler))",
            "\t\tobjpool_push(node, &node->rethook->pool);",
            "\telse",
            "\t\tcall_rcu(&node->rcu, free_rethook_node_rcu);",
            "}",
            "void rethook_hook(struct rethook_node *node, struct pt_regs *regs, bool mcount)",
            "{",
            "\tarch_rethook_prepare(node, regs, mcount);",
            "\t__llist_add(&node->llist, &current->rethooks);",
            "}",
            "static unsigned long __rethook_find_ret_addr(struct task_struct *tsk,",
            "\t\t\t\t\t     struct llist_node **cur)",
            "{",
            "\tstruct rethook_node *rh = NULL;",
            "\tstruct llist_node *node = *cur;",
            "",
            "\tif (!node)",
            "\t\tnode = tsk->rethooks.first;",
            "\telse",
            "\t\tnode = node->next;",
            "",
            "\twhile (node) {",
            "\t\trh = container_of(node, struct rethook_node, llist);",
            "\t\tif (rh->ret_addr != (unsigned long)arch_rethook_trampoline) {",
            "\t\t\t*cur = node;",
            "\t\t\treturn rh->ret_addr;",
            "\t\t}",
            "\t\tnode = node->next;",
            "\t}",
            "\treturn 0;",
            "}",
            "unsigned long rethook_find_ret_addr(struct task_struct *tsk, unsigned long frame,",
            "\t\t\t\t    struct llist_node **cur)",
            "{",
            "\tstruct rethook_node *rhn = NULL;",
            "\tunsigned long ret;",
            "",
            "\tif (WARN_ON_ONCE(!cur))",
            "\t\treturn 0;",
            "",
            "\tif (WARN_ON_ONCE(tsk != current && task_is_running(tsk)))",
            "\t\treturn 0;",
            "",
            "\tdo {",
            "\t\tret = __rethook_find_ret_addr(tsk, cur);",
            "\t\tif (!ret)",
            "\t\t\tbreak;",
            "\t\trhn = container_of(*cur, struct rethook_node, llist);",
            "\t} while (rhn->frame != frame);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "rethook_flush_task, rethook_free_rcu, rethook_stop, rethook_free, rethook_init_node, rethook_fini_pool, rethook_get_handler, free_rethook_node_rcu, rethook_recycle, rethook_hook, __rethook_find_ret_addr, rethook_find_ret_addr",
          "description": "实现rethook节点的生命周期管理，包含RCU安全释放、池化内存管理、影子堆栈操作及异常返回地址查找逻辑",
          "similarity": 0.566056489944458
        }
      ]
    },
    {
      "source_file": "kernel/bpf/trampoline.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:36:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\trampoline.c`\n\n---\n\n# bpf/trampoline.c 技术文档\n\n## 1. 文件概述\n\n`bpf/trampoline.c` 是 Linux 内核 BPF（Berkeley Packet Filter）子系统中用于实现 **BPF Trampoline（跳板）机制** 的核心文件。该机制主要用于支持 **FENTRY/FEXIT**、**MODIFY_RETURN** 以及 **LSM（Linux Security Module）** 类型的 BPF 程序，通过动态生成或修改内核函数入口处的跳转代码（trampoline），实现对目标函数的无侵入式拦截与增强。该文件负责管理 trampoline 的生命周期、哈希表存储、与 ftrace 的集成、以及 JIT 生成的 trampoline 镜像的内存管理。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct bpf_trampoline`：表示一个 trampoline 实例，包含目标函数地址、程序链表、引用计数、互斥锁等。\n- `struct bpf_tramp_image`：表示 JIT 生成的 trampoline 机器码镜像，包含代码指针、大小、ksym 信息及引用计数。\n- `bpf_trampoline_table[]`：全局哈希表，用于根据函数地址（key）快速查找或创建对应的 trampoline。\n\n### 主要函数\n- `bpf_trampoline_lookup(u64 key)`：根据目标函数地址查找或创建 trampoline 实例。\n- `bpf_trampoline_update(struct bpf_trampoline *tr, bool lock_direct_mutex)`：更新 trampoline 的机器码以反映附加的 BPF 程序变更（声明但未在片段中定义）。\n- `register_fentry()` / `unregister_fentry()` / `modify_fentry()`：封装对 ftrace direct 或 `bpf_arch_text_poke` 的调用，用于安装/卸载/修改跳转指令。\n- `bpf_trampoline_get_progs()`：收集附加到 trampoline 上的所有 BPF 程序链接（按类型分类）。\n- `bpf_tramp_image_free()` 及相关 RCU/工作队列回调：安全释放 JIT 生成的 trampoline 镜像内存。\n- `bpf_prog_has_trampoline()`：判断给定 BPF 程序是否需要 trampoline 机制。\n- `bpf_image_ksym_*()`：管理 trampoline 镜像的内核符号（ksym）注册与 perf 事件通知。\n\n### 静态变量与常量\n- `TRAMPOLINE_HASH_BITS` / `TRAMPOLINE_TABLE_SIZE`：定义 trampoline 哈希表大小（1024 项）。\n- `trampoline_mutex`：保护全局 trampoline 哈希表的互斥锁。\n- `bpf_extension_verifier_ops` / `bpf_extension_prog_ops`：占位符操作结构体。\n\n### ftrace 集成回调（条件编译）\n- `bpf_tramp_ftrace_ops_func()`：处理 ftrace direct 模式下与 IP 修改共享相关的命令（`FTRACE_OPS_CMD_*`），协调 trampoline 更新。\n\n## 3. 关键实现\n\n### Trampoline 哈希表管理\n- 使用 `hash_64(key, TRAMPOLINE_HASH_BITS)` 将目标函数地址映射到 `trampoline_table` 的桶中。\n- `trampoline_mutex` 保护整个哈希表的查找、创建和插入操作，确保线程安全。\n- 每个 `bpf_trampoline` 实例通过 `refcount_t refcnt` 管理生命周期。\n\n### 与 ftrace/direct calls 集成\n- 在支持 `CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS` 的架构上，优先使用 ftrace 的 direct call 机制安装跳转。\n- `bpf_tramp_ftrace_ops_func()` 处理 ftrace 框架在启用 IP 修改共享时的特殊交互，通过返回 `-EAGAIN` 触发重试以协调 trampoline 更新。\n- 锁定顺序：`tr->mutex` → ftrace 的 `direct_mutex` → `ftrace_lock`，使用 `mutex_trylock` 避免死锁。\n\n### Trampoline 镜像生命周期管理\n- 使用 **三层延迟释放机制** 确保安全回收 JIT 生成的代码页：\n  1. **Per-CPU 引用计数 (`percpu_ref`)**：跟踪运行中的 trampoline 使用。\n  2. **RCU (`call_rcu_tasks`)**：等待所有可能执行该代码的 CPU 上下文完成。\n  3. **工作队列 (`schedule_work`)**：在进程上下文中执行最终的内存释放（包括 `arch_free_bpf_trampoline` 和 ksym 注销）。\n- 通过 `perf_event_ksymbol` 向用户态 perf 工具通知 BPF trampoline 镜像的加载/卸载。\n\n### 程序分类与收集\n- BPF 程序按类型（`BPF_TRAMP_FENTRY`, `BPF_TRAMP_FEXIT`, `BPF_TRAMP_MODIFY_RETURN`, `BPF_TRAMP_FENTRY_OPS`）存储在 `tr->progs_hlist[4]` 中。\n- `bpf_trampoline_get_progs()` 遍历这些链表，构建 `bpf_tramp_links` 结构供 JIT 编译器使用，并检查是否需要传递函数 IP 参数。\n\n## 4. 依赖关系\n\n- **BPF 核心**：依赖 `bpf.h`, `filter.h`, `bpf_verifier.h` 提供程序模型、验证器和通用操作。\n- **ftrace 子系统**：依赖 `ftrace.h` 实现函数跟踪和 direct call 注册（`register_ftrace_direct` 等）。\n- **BTF (BPF Type Format)**：依赖 `btf.h` 获取内核函数签名信息（虽未直接使用，但 trampoline 机制依赖 BTF 信息）。\n- **内存管理**：依赖 `rcupdate_trace.h`, `rcupdate_wait.h` 实现安全的延迟释放。\n- **架构相关代码**：依赖 `bpf_arch_text_poke()`（在 `arch/` 目录下实现）进行非 ftrace 路径的代码修补。\n- **性能事件**：依赖 `perf_event.h` 发送 KSYMBOL 事件。\n- **LSM 框架**：依赖 `bpf_lsm.h` 支持 LSM 类型的 BPF 程序。\n- **静态调用优化**：依赖 `static_call.h`（虽未直接使用，但相关机制可能被优化）。\n\n## 5. 使用场景\n\n- **FENTRY/FEXIT 程序**：当用户附加 `BPF_TRACE_FENTRY` 或 `BPF_TRACE_FEXIT` 类型的 BPF 程序到内核函数时，内核为该函数创建或复用一个 trampoline，动态生成包含调用 BPF 程序逻辑的入口/出口桩代码。\n- **MODIFY_RETURN 程序**：用于拦截并修改目标函数的返回值，同样通过 trampoline 机制实现。\n- **LSM 程序**：`BPF_LSM_MAC` 类型的程序通过 trampoline 挂接到 LSM hooks。\n- **动态更新**：当附加到同一函数的 BPF 程序集合发生变化（添加/删除）时，触发 `bpf_trampoline_update()` 重新生成 trampoline 代码。\n- **资源回收**：当所有引用 trampoline 的 BPF 程序被 detach 且无执行实例后，通过 RCU 和工作队列安全释放其 JIT 代码和相关资源。",
      "similarity": 0.5746780037879944,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/trampoline.c",
          "start_line": 191,
          "end_line": 317,
          "content": [
            "static int modify_fentry(struct bpf_trampoline *tr, void *old_addr, void *new_addr,",
            "\t\t\t bool lock_direct_mutex)",
            "{",
            "\tvoid *ip = tr->func.addr;",
            "\tint ret;",
            "",
            "\tif (tr->func.ftrace_managed) {",
            "\t\tif (lock_direct_mutex)",
            "\t\t\tret = modify_ftrace_direct(tr->fops, (long)new_addr);",
            "\t\telse",
            "\t\t\tret = modify_ftrace_direct_nolock(tr->fops, (long)new_addr);",
            "\t} else {",
            "\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, old_addr, new_addr);",
            "\t}",
            "\treturn ret;",
            "}",
            "static int register_fentry(struct bpf_trampoline *tr, void *new_addr)",
            "{",
            "\tvoid *ip = tr->func.addr;",
            "\tunsigned long faddr;",
            "\tint ret;",
            "",
            "\tfaddr = ftrace_location((unsigned long)ip);",
            "\tif (faddr) {",
            "\t\tif (!tr->fops)",
            "\t\t\treturn -ENOTSUPP;",
            "\t\ttr->func.ftrace_managed = true;",
            "\t}",
            "",
            "\tif (tr->func.ftrace_managed) {",
            "\t\tftrace_set_filter_ip(tr->fops, (unsigned long)ip, 0, 1);",
            "\t\tret = register_ftrace_direct(tr->fops, (long)new_addr);",
            "\t} else {",
            "\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, NULL, new_addr);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static void bpf_tramp_image_free(struct bpf_tramp_image *im)",
            "{",
            "\tbpf_image_ksym_del(&im->ksym);",
            "\tarch_free_bpf_trampoline(im->image, im->size);",
            "\tbpf_jit_uncharge_modmem(im->size);",
            "\tpercpu_ref_exit(&im->pcref);",
            "\tkfree_rcu(im, rcu);",
            "}",
            "static void __bpf_tramp_image_put_deferred(struct work_struct *work)",
            "{",
            "\tstruct bpf_tramp_image *im;",
            "",
            "\tim = container_of(work, struct bpf_tramp_image, work);",
            "\tbpf_tramp_image_free(im);",
            "}",
            "static void __bpf_tramp_image_put_rcu(struct rcu_head *rcu)",
            "{",
            "\tstruct bpf_tramp_image *im;",
            "",
            "\tim = container_of(rcu, struct bpf_tramp_image, rcu);",
            "\tINIT_WORK(&im->work, __bpf_tramp_image_put_deferred);",
            "\tschedule_work(&im->work);",
            "}",
            "static void __bpf_tramp_image_release(struct percpu_ref *pcref)",
            "{",
            "\tstruct bpf_tramp_image *im;",
            "",
            "\tim = container_of(pcref, struct bpf_tramp_image, pcref);",
            "\tcall_rcu_tasks(&im->rcu, __bpf_tramp_image_put_rcu);",
            "}",
            "static void __bpf_tramp_image_put_rcu_tasks(struct rcu_head *rcu)",
            "{",
            "\tstruct bpf_tramp_image *im;",
            "",
            "\tim = container_of(rcu, struct bpf_tramp_image, rcu);",
            "\tif (im->ip_after_call)",
            "\t\t/* the case of fmod_ret/fexit trampoline and CONFIG_PREEMPTION=y */",
            "\t\tpercpu_ref_kill(&im->pcref);",
            "\telse",
            "\t\t/* the case of fentry trampoline */",
            "\t\tcall_rcu_tasks(&im->rcu, __bpf_tramp_image_put_rcu);",
            "}",
            "static void bpf_tramp_image_put(struct bpf_tramp_image *im)",
            "{",
            "\t/* The trampoline image that calls original function is using:",
            "\t * rcu_read_lock_trace to protect sleepable bpf progs",
            "\t * rcu_read_lock to protect normal bpf progs",
            "\t * percpu_ref to protect trampoline itself",
            "\t * rcu tasks to protect trampoline asm not covered by percpu_ref",
            "\t * (which are few asm insns before __bpf_tramp_enter and",
            "\t *  after __bpf_tramp_exit)",
            "\t *",
            "\t * The trampoline is unreachable before bpf_tramp_image_put().",
            "\t *",
            "\t * First, patch the trampoline to avoid calling into fexit progs.",
            "\t * The progs will be freed even if the original function is still",
            "\t * executing or sleeping.",
            "\t * In case of CONFIG_PREEMPT=y use call_rcu_tasks() to wait on",
            "\t * first few asm instructions to execute and call into",
            "\t * __bpf_tramp_enter->percpu_ref_get.",
            "\t * Then use percpu_ref_kill to wait for the trampoline and the original",
            "\t * function to finish.",
            "\t * Then use call_rcu_tasks() to make sure few asm insns in",
            "\t * the trampoline epilogue are done as well.",
            "\t *",
            "\t * In !PREEMPT case the task that got interrupted in the first asm",
            "\t * insns won't go through an RCU quiescent state which the",
            "\t * percpu_ref_kill will be waiting for. Hence the first",
            "\t * call_rcu_tasks() is not necessary.",
            "\t */",
            "\tif (im->ip_after_call) {",
            "\t\tint err = bpf_arch_text_poke(im->ip_after_call, BPF_MOD_JUMP,",
            "\t\t\t\t\t     NULL, im->ip_epilogue);",
            "\t\tWARN_ON(err);",
            "\t\tif (IS_ENABLED(CONFIG_PREEMPTION))",
            "\t\t\tcall_rcu_tasks(&im->rcu, __bpf_tramp_image_put_rcu_tasks);",
            "\t\telse",
            "\t\t\tpercpu_ref_kill(&im->pcref);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* The trampoline without fexit and fmod_ret progs doesn't call original",
            "\t * function and doesn't use percpu_ref.",
            "\t * Use call_rcu_tasks_trace() to wait for sleepable progs to finish.",
            "\t * Then use call_rcu_tasks() to wait for the rest of trampoline asm",
            "\t * and normal progs.",
            "\t */",
            "\tcall_rcu_tasks_trace(&im->rcu, __bpf_tramp_image_put_rcu_tasks);",
            "}"
          ],
          "function_name": "modify_fentry, register_fentry, bpf_tramp_image_free, __bpf_tramp_image_put_deferred, __bpf_tramp_image_put_rcu, __bpf_tramp_image_release, __bpf_tramp_image_put_rcu_tasks, bpf_tramp_image_put",
          "description": "实现trampoline图像的释放流程，通过RCU和延迟工作队列安全释放资源，处理不同内核配置下的引用计数和内存回收路径。",
          "similarity": 0.627475380897522
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/trampoline.c",
          "start_line": 398,
          "end_line": 505,
          "content": [
            "static int bpf_trampoline_update(struct bpf_trampoline *tr, bool lock_direct_mutex)",
            "{",
            "\tstruct bpf_tramp_image *im;",
            "\tstruct bpf_tramp_links *tlinks;",
            "\tu32 orig_flags = tr->flags;",
            "\tbool ip_arg = false;",
            "\tint err, total, size;",
            "",
            "\ttlinks = bpf_trampoline_get_progs(tr, &total, &ip_arg);",
            "\tif (IS_ERR(tlinks))",
            "\t\treturn PTR_ERR(tlinks);",
            "",
            "\tif (total == 0) {",
            "\t\terr = unregister_fentry(tr, tr->cur_image->image);",
            "\t\tbpf_tramp_image_put(tr->cur_image);",
            "\t\ttr->cur_image = NULL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* clear all bits except SHARE_IPMODIFY and TAIL_CALL_CTX */",
            "\ttr->flags &= (BPF_TRAMP_F_SHARE_IPMODIFY | BPF_TRAMP_F_TAIL_CALL_CTX);",
            "",
            "\tif (tlinks[BPF_TRAMP_FEXIT].nr_links ||",
            "\t    tlinks[BPF_TRAMP_MODIFY_RETURN].nr_links) {",
            "\t\t/* NOTE: BPF_TRAMP_F_RESTORE_REGS and BPF_TRAMP_F_SKIP_FRAME",
            "\t\t * should not be set together.",
            "\t\t */",
            "\t\ttr->flags |= BPF_TRAMP_F_CALL_ORIG | BPF_TRAMP_F_SKIP_FRAME;",
            "\t} else {",
            "\t\ttr->flags |= BPF_TRAMP_F_RESTORE_REGS;",
            "\t}",
            "",
            "\tif (ip_arg)",
            "\t\ttr->flags |= BPF_TRAMP_F_IP_ARG;",
            "",
            "#ifdef CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS",
            "again:",
            "\tif ((tr->flags & BPF_TRAMP_F_SHARE_IPMODIFY) &&",
            "\t    (tr->flags & BPF_TRAMP_F_CALL_ORIG))",
            "\t\ttr->flags |= BPF_TRAMP_F_ORIG_STACK;",
            "#endif",
            "",
            "\tsize = arch_bpf_trampoline_size(&tr->func.model, tr->flags,",
            "\t\t\t\t\ttlinks, tr->func.addr);",
            "\tif (size < 0) {",
            "\t\terr = size;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (size > PAGE_SIZE) {",
            "\t\terr = -E2BIG;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tim = bpf_tramp_image_alloc(tr->key, size);",
            "\tif (IS_ERR(im)) {",
            "\t\terr = PTR_ERR(im);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\terr = arch_prepare_bpf_trampoline(im, im->image, im->image + size,",
            "\t\t\t\t\t  &tr->func.model, tr->flags, tlinks,",
            "\t\t\t\t\t  tr->func.addr);",
            "\tif (err < 0)",
            "\t\tgoto out_free;",
            "",
            "\tarch_protect_bpf_trampoline(im->image, im->size);",
            "",
            "\tWARN_ON(tr->cur_image && total == 0);",
            "\tif (tr->cur_image)",
            "\t\t/* progs already running at this address */",
            "\t\terr = modify_fentry(tr, tr->cur_image->image, im->image, lock_direct_mutex);",
            "\telse",
            "\t\t/* first time registering */",
            "\t\terr = register_fentry(tr, im->image);",
            "",
            "#ifdef CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS",
            "\tif (err == -EAGAIN) {",
            "\t\t/* -EAGAIN from bpf_tramp_ftrace_ops_func. Now",
            "\t\t * BPF_TRAMP_F_SHARE_IPMODIFY is set, we can generate the",
            "\t\t * trampoline again, and retry register.",
            "\t\t */",
            "\t\t/* reset fops->func and fops->trampoline for re-register */",
            "\t\ttr->fops->func = NULL;",
            "\t\ttr->fops->trampoline = 0;",
            "",
            "\t\t/* free im memory and reallocate later */",
            "\t\tbpf_tramp_image_free(im);",
            "\t\tgoto again;",
            "\t}",
            "#endif",
            "\tif (err)",
            "\t\tgoto out_free;",
            "",
            "\tif (tr->cur_image)",
            "\t\tbpf_tramp_image_put(tr->cur_image);",
            "\ttr->cur_image = im;",
            "out:",
            "\t/* If any error happens, restore previous flags */",
            "\tif (err)",
            "\t\ttr->flags = orig_flags;",
            "\tkfree(tlinks);",
            "\treturn err;",
            "",
            "out_free:",
            "\tbpf_tramp_image_free(im);",
            "\tgoto out;",
            "}"
          ],
          "function_name": "bpf_trampoline_update",
          "description": "执行trampoline更新核心逻辑，根据当前挂载的程序链表重新生成并安装新trampoline，处理共享IP修改场景下的重试机制和错误恢复。",
          "similarity": 0.5756515264511108
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/trampoline.c",
          "start_line": 35,
          "end_line": 143,
          "content": [
            "static int bpf_tramp_ftrace_ops_func(struct ftrace_ops *ops, enum ftrace_ops_cmd cmd)",
            "{",
            "\tstruct bpf_trampoline *tr = ops->private;",
            "\tint ret = 0;",
            "",
            "\tif (cmd == FTRACE_OPS_CMD_ENABLE_SHARE_IPMODIFY_SELF) {",
            "\t\t/* This is called inside register_ftrace_direct_multi(), so",
            "\t\t * tr->mutex is already locked.",
            "\t\t */",
            "\t\tlockdep_assert_held_once(&tr->mutex);",
            "",
            "\t\t/* Instead of updating the trampoline here, we propagate",
            "\t\t * -EAGAIN to register_ftrace_direct(). Then we can",
            "\t\t * retry register_ftrace_direct() after updating the",
            "\t\t * trampoline.",
            "\t\t */",
            "\t\tif ((tr->flags & BPF_TRAMP_F_CALL_ORIG) &&",
            "\t\t    !(tr->flags & BPF_TRAMP_F_ORIG_STACK)) {",
            "\t\t\tif (WARN_ON_ONCE(tr->flags & BPF_TRAMP_F_SHARE_IPMODIFY))",
            "\t\t\t\treturn -EBUSY;",
            "",
            "\t\t\ttr->flags |= BPF_TRAMP_F_SHARE_IPMODIFY;",
            "\t\t\treturn -EAGAIN;",
            "\t\t}",
            "",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/* The normal locking order is",
            "\t *    tr->mutex => direct_mutex (ftrace.c) => ftrace_lock (ftrace.c)",
            "\t *",
            "\t * The following two commands are called from",
            "\t *",
            "\t *   prepare_direct_functions_for_ipmodify",
            "\t *   cleanup_direct_functions_after_ipmodify",
            "\t *",
            "\t * In both cases, direct_mutex is already locked. Use",
            "\t * mutex_trylock(&tr->mutex) to avoid deadlock in race condition",
            "\t * (something else is making changes to this same trampoline).",
            "\t */",
            "\tif (!mutex_trylock(&tr->mutex)) {",
            "\t\t/* sleep 1 ms to make sure whatever holding tr->mutex makes",
            "\t\t * some progress.",
            "\t\t */",
            "\t\tmsleep(1);",
            "\t\treturn -EAGAIN;",
            "\t}",
            "",
            "\tswitch (cmd) {",
            "\tcase FTRACE_OPS_CMD_ENABLE_SHARE_IPMODIFY_PEER:",
            "\t\ttr->flags |= BPF_TRAMP_F_SHARE_IPMODIFY;",
            "",
            "\t\tif ((tr->flags & BPF_TRAMP_F_CALL_ORIG) &&",
            "\t\t    !(tr->flags & BPF_TRAMP_F_ORIG_STACK))",
            "\t\t\tret = bpf_trampoline_update(tr, false /* lock_direct_mutex */);",
            "\t\tbreak;",
            "\tcase FTRACE_OPS_CMD_DISABLE_SHARE_IPMODIFY_PEER:",
            "\t\ttr->flags &= ~BPF_TRAMP_F_SHARE_IPMODIFY;",
            "",
            "\t\tif (tr->flags & BPF_TRAMP_F_ORIG_STACK)",
            "\t\t\tret = bpf_trampoline_update(tr, false /* lock_direct_mutex */);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tret = -EINVAL;",
            "\t\tbreak;",
            "\t}",
            "",
            "\tmutex_unlock(&tr->mutex);",
            "\treturn ret;",
            "}",
            "bool bpf_prog_has_trampoline(const struct bpf_prog *prog)",
            "{",
            "\tenum bpf_attach_type eatype = prog->expected_attach_type;",
            "\tenum bpf_prog_type ptype = prog->type;",
            "",
            "\treturn (ptype == BPF_PROG_TYPE_TRACING &&",
            "\t\t(eatype == BPF_TRACE_FENTRY || eatype == BPF_TRACE_FEXIT ||",
            "\t\t eatype == BPF_MODIFY_RETURN)) ||",
            "\t\t(ptype == BPF_PROG_TYPE_LSM && eatype == BPF_LSM_MAC);",
            "}",
            "void bpf_image_ksym_init(void *data, unsigned int size, struct bpf_ksym *ksym)",
            "{",
            "\tksym->start = (unsigned long) data;",
            "\tksym->end = ksym->start + size;",
            "}",
            "void bpf_image_ksym_add(struct bpf_ksym *ksym)",
            "{",
            "\tbpf_ksym_add(ksym);",
            "\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_BPF, ksym->start,",
            "\t\t\t   PAGE_SIZE, false, ksym->name);",
            "}",
            "void bpf_image_ksym_del(struct bpf_ksym *ksym)",
            "{",
            "\tbpf_ksym_del(ksym);",
            "\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_BPF, ksym->start,",
            "\t\t\t   PAGE_SIZE, true, ksym->name);",
            "}",
            "static int unregister_fentry(struct bpf_trampoline *tr, void *old_addr)",
            "{",
            "\tvoid *ip = tr->func.addr;",
            "\tint ret;",
            "",
            "\tif (tr->func.ftrace_managed)",
            "\t\tret = unregister_ftrace_direct(tr->fops, (long)old_addr, false);",
            "\telse",
            "\t\tret = bpf_arch_text_poke(ip, BPF_MOD_CALL, old_addr, NULL);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpf_tramp_ftrace_ops_func, bpf_prog_has_trampoline, bpf_image_ksym_init, bpf_image_ksym_add, bpf_image_ksym_del, unregister_fentry",
          "description": "实现FTRACE操作回调处理逻辑，控制共享IP修改标志位，提供BPF程序是否支持trampoline检测，管理KSYM符号注册与注销，实现卸载fentry的辅助函数。",
          "similarity": 0.5201511383056641
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/bpf/trampoline.c",
          "start_line": 1085,
          "end_line": 1118,
          "content": [
            "int __weak",
            "arch_prepare_bpf_trampoline(struct bpf_tramp_image *im, void *image, void *image_end,",
            "\t\t\t    const struct btf_func_model *m, u32 flags,",
            "\t\t\t    struct bpf_tramp_links *tlinks,",
            "\t\t\t    void *func_addr)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "void __weak arch_free_bpf_trampoline(void *image, unsigned int size)",
            "{",
            "\tWARN_ON_ONCE(size > PAGE_SIZE);",
            "\t/* bpf_jit_free_exec doesn't need \"size\", but",
            "\t * bpf_prog_pack_free() needs it.",
            "\t */",
            "\tbpf_jit_free_exec(image);",
            "}",
            "void __weak arch_protect_bpf_trampoline(void *image, unsigned int size)",
            "{",
            "\tWARN_ON_ONCE(size > PAGE_SIZE);",
            "\tset_memory_rox((long)image, 1);",
            "}",
            "int __weak arch_bpf_trampoline_size(const struct btf_func_model *m, u32 flags,",
            "\t\t\t\t    struct bpf_tramp_links *tlinks, void *func_addr)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "static int __init init_trampolines(void)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < TRAMPOLINE_TABLE_SIZE; i++)",
            "\t\tINIT_HLIST_HEAD(&trampoline_table[i]);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "arch_prepare_bpf_trampoline, arch_free_bpf_trampoline, arch_protect_bpf_trampoline, arch_bpf_trampoline_size, init_trampolines",
          "description": "提供架构无关的BPF陷阱图像操作接口，包含大小计算、内存保护及初始化trampoline表头的弱函数定义。",
          "similarity": 0.517524003982544
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/trampoline.c",
          "start_line": 507,
          "end_line": 627,
          "content": [
            "static enum bpf_tramp_prog_type bpf_attach_type_to_tramp(struct bpf_prog *prog)",
            "{",
            "\tswitch (prog->expected_attach_type) {",
            "\tcase BPF_TRACE_FENTRY:",
            "\t\treturn BPF_TRAMP_FENTRY;",
            "\tcase BPF_MODIFY_RETURN:",
            "\t\treturn BPF_TRAMP_MODIFY_RETURN;",
            "\tcase BPF_TRACE_FEXIT:",
            "\t\treturn BPF_TRAMP_FEXIT;",
            "\tcase BPF_LSM_MAC:",
            "\t\tif (!prog->aux->attach_func_proto->type)",
            "\t\t\t/* The function returns void, we cannot modify its",
            "\t\t\t * return value.",
            "\t\t\t */",
            "\t\t\treturn BPF_TRAMP_FEXIT;",
            "\t\telse",
            "\t\t\treturn BPF_TRAMP_MODIFY_RETURN;",
            "\tdefault:",
            "\t\treturn BPF_TRAMP_REPLACE;",
            "\t}",
            "}",
            "static int bpf_freplace_check_tgt_prog(struct bpf_prog *tgt_prog)",
            "{",
            "\tstruct bpf_prog_aux *aux = tgt_prog->aux;",
            "",
            "\tguard(mutex)(&aux->ext_mutex);",
            "\tif (aux->prog_array_member_cnt)",
            "\t\t/* Program extensions can not extend target prog when the target",
            "\t\t * prog has been updated to any prog_array map as tail callee.",
            "\t\t * It's to prevent a potential infinite loop like:",
            "\t\t * tgt prog entry -> tgt prog subprog -> freplace prog entry",
            "\t\t * --tailcall-> tgt prog entry.",
            "\t\t */",
            "\t\treturn -EBUSY;",
            "",
            "\taux->is_extended = true;",
            "\treturn 0;",
            "}",
            "static int __bpf_trampoline_link_prog(struct bpf_tramp_link *link,",
            "\t\t\t\t      struct bpf_trampoline *tr,",
            "\t\t\t\t      struct bpf_prog *tgt_prog)",
            "{",
            "\tenum bpf_tramp_prog_type kind;",
            "\tstruct bpf_tramp_link *link_exiting;",
            "\tint err = 0;",
            "\tint cnt = 0, i;",
            "",
            "\tkind = bpf_attach_type_to_tramp(link->link.prog);",
            "\tif (tr->extension_prog)",
            "\t\t/* cannot attach fentry/fexit if extension prog is attached.",
            "\t\t * cannot overwrite extension prog either.",
            "\t\t */",
            "\t\treturn -EBUSY;",
            "",
            "\tfor (i = 0; i < BPF_TRAMP_MAX; i++)",
            "\t\tcnt += tr->progs_cnt[i];",
            "",
            "\tif (kind == BPF_TRAMP_REPLACE) {",
            "\t\t/* Cannot attach extension if fentry/fexit are in use. */",
            "\t\tif (cnt)",
            "\t\t\treturn -EBUSY;",
            "\t\terr = bpf_freplace_check_tgt_prog(tgt_prog);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t\ttr->extension_prog = link->link.prog;",
            "\t\treturn bpf_arch_text_poke(tr->func.addr, BPF_MOD_JUMP, NULL,",
            "\t\t\t\t\t  link->link.prog->bpf_func);",
            "\t}",
            "\tif (cnt >= BPF_MAX_TRAMP_LINKS)",
            "\t\treturn -E2BIG;",
            "\tif (!hlist_unhashed(&link->tramp_hlist))",
            "\t\t/* prog already linked */",
            "\t\treturn -EBUSY;",
            "\thlist_for_each_entry(link_exiting, &tr->progs_hlist[kind], tramp_hlist) {",
            "\t\tif (link_exiting->link.prog != link->link.prog)",
            "\t\t\tcontinue;",
            "\t\t/* prog already linked */",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\thlist_add_head(&link->tramp_hlist, &tr->progs_hlist[kind]);",
            "\ttr->progs_cnt[kind]++;",
            "\terr = bpf_trampoline_update(tr, true /* lock_direct_mutex */);",
            "\tif (err) {",
            "\t\thlist_del_init(&link->tramp_hlist);",
            "\t\ttr->progs_cnt[kind]--;",
            "\t}",
            "\treturn err;",
            "}",
            "int bpf_trampoline_link_prog(struct bpf_tramp_link *link,",
            "\t\t\t     struct bpf_trampoline *tr,",
            "\t\t\t     struct bpf_prog *tgt_prog)",
            "{",
            "\tint err;",
            "",
            "\tmutex_lock(&tr->mutex);",
            "\terr = __bpf_trampoline_link_prog(link, tr, tgt_prog);",
            "\tmutex_unlock(&tr->mutex);",
            "\treturn err;",
            "}",
            "static int __bpf_trampoline_unlink_prog(struct bpf_tramp_link *link,",
            "\t\t\t\t\tstruct bpf_trampoline *tr,",
            "\t\t\t\t\tstruct bpf_prog *tgt_prog)",
            "{",
            "\tenum bpf_tramp_prog_type kind;",
            "\tint err;",
            "",
            "\tkind = bpf_attach_type_to_tramp(link->link.prog);",
            "\tif (kind == BPF_TRAMP_REPLACE) {",
            "\t\tWARN_ON_ONCE(!tr->extension_prog);",
            "\t\terr = bpf_arch_text_poke(tr->func.addr, BPF_MOD_JUMP,",
            "\t\t\t\t\t tr->extension_prog->bpf_func, NULL);",
            "\t\ttr->extension_prog = NULL;",
            "\t\tguard(mutex)(&tgt_prog->aux->ext_mutex);",
            "\t\ttgt_prog->aux->is_extended = false;",
            "\t\treturn err;",
            "\t}",
            "\thlist_del_init(&link->tramp_hlist);",
            "\ttr->progs_cnt[kind]--;",
            "\treturn bpf_trampoline_update(tr, true /* lock_direct_mutex */);",
            "}"
          ],
          "function_name": "bpf_attach_type_to_tramp, bpf_freplace_check_tgt_prog, __bpf_trampoline_link_prog, bpf_trampoline_link_prog, __bpf_trampoline_unlink_prog",
          "description": "实现BPF程序与trampoline的绑定/解绑操作，转换附件类型到trampoline类型，校验目标程序扩展状态，维护程序链接列表并触发trampoline更新。",
          "similarity": 0.4970698356628418
        }
      ]
    },
    {
      "source_file": "kernel/rcu/refscale.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:42:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `rcu\\refscale.c`\n\n---\n\n# `rcu/refscale.c` 技术文档\n\n## 1. 文件概述\n\n`rcu/refscale.c` 是 Linux 内核中用于**可扩展性基准测试**的模块，旨在比较不同同步机制（如 RCU、SRCU、引用计数、读写信号量、读写自旋锁等）在高并发读取场景下获取对象引用的性能表现。该模块通过模拟大量并发读取操作，测量不同机制在吞吐量、延迟和可扩展性方面的差异，为 RCU 及其他同步原语的优化提供数据支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct ref_scale_ops`**  \n  定义不同同步机制的操作接口，包含初始化、清理、读取段执行和延迟段执行等函数指针。\n  ```c\n  struct ref_scale_ops {\n      bool (*init)(void);\n      void (*cleanup)(void);\n      void (*readsection)(const int nloops);\n      void (*delaysection)(const int nloops, const int udl, const int ndl);\n      const char *name;\n  };\n  ```\n\n- **`struct reader_task`**  \n  表示每个读者线程的状态，包括任务结构、启动标志、等待队列和上次执行耗时。\n  ```c\n  struct reader_task {\n      struct task_struct *task;\n      int start_reader;\n      wait_queue_head_t wq;\n      u64 last_duration_ns;\n  };\n  ```\n\n### 主要函数\n\n- **`ref_rcu_read_section()` / `ref_rcu_delay_section()`**  \n  执行指定次数的 RCU 读临界区操作，后者在临界区内插入延迟。\n\n- **`srcu_ref_scale_read_section()` / `srcu_ref_scale_delay_section()`**  \n  针对 SRCU 的读操作测试函数。\n\n- **`ref_refcnt_section()` / `ref_refcnt_delay_section()`**  \n  使用原子引用计数（`atomic_inc/dec`）模拟引用获取/释放。\n\n- **`ref_rwlock_section()` / `ref_rwlock_delay_section()`**  \n  使用读写自旋锁（`rwlock_t`）进行读操作测试。\n\n- **`un_delay()`**  \n  根据参数执行微秒（`udelay`）或纳秒（`ndelay`）级延迟。\n\n- **`rcu_sync_scale_init()`**  \n  空初始化函数，适用于无需特殊初始化的机制（如 RCU、SRCU）。\n\n## 3. 关键实现\n\n### 测试机制选择\n通过 `scale_type` 模块参数动态选择测试的同步机制，支持：\n- `rcu`：经典 RCU\n- `srcu`：Sleepable RCU\n- `rcu-tasks`：基于任务的 RCU（需 `CONFIG_TASKS_RCU`）\n- `rcu-trace`：跟踪 RCU（需 `CONFIG_TASKS_TRACE_RCU`）\n- `refcnt`：原子引用计数\n- `rwlock`：读写自旋锁（代码片段未完整显示，但已定义）\n\n### 并发控制\n- 使用 `atomic_t` 变量（如 `nreaders_exp`, `n_init`）协调读者线程的启动、预热和冷却阶段。\n- 通过等待队列（`main_wq`, `shutdown_wq`）实现主线程与读者/关机线程的同步。\n\n### 日志输出控制\n- `VERBOSE_SCALEOUT`：条件性输出调试信息。\n- `VERBOSE_SCALEOUT_BATCH`：批量输出日志，避免高频打印影响性能测试结果。\n- `SCALEOUT_ERRSTRING`：高亮错误信息。\n\n### 延迟模拟\n通过 `readdelay` 参数在读临界区内插入纳秒级延迟（`udelay`/`ndelay`），模拟真实场景中的读操作耗时。\n\n### 实验配置\n- `nreaders`：读者线程数（默认为 CPU 数的 75%）。\n- `loops`：每轮实验的循环次数。\n- `nruns`：实验重复次数。\n- `holdoff`：启动前等待多 CPU 环境就绪的延迟时间。\n\n## 4. 依赖关系\n\n- **RCU 子系统**：依赖 `rcupdate.h`、`rcupdate_trace.h` 提供 RCU 及变体（SRCU、Tasks RCU）的 API。\n- **内核基础组件**：\n  - 原子操作（`atomic.h`）\n  - 内核线程（`kthread.h`）\n  - 等待队列（`wait.h`）\n  - 自旋锁/读写锁（`spinlock.h`）\n  - 内存管理（`slab.h`）\n- **测试框架**：使用 `torture.h` 提供的参数解析和测试基础设施。\n- **条件编译**：根据内核配置（如 `CONFIG_TASKS_RCU`）动态包含特定 RCU 变体的测试代码。\n\n## 5. 使用场景\n\n- **RCU 性能调优**：在开发新 RCU 变体或优化现有实现时，量化其可扩展性优势。\n- **同步原语选型**：为内核开发者提供不同同步机制在高并发读场景下的性能对比数据。\n- **回归测试**：确保内核修改不会降低 RCU 或其他机制的可扩展性。\n- **学术研究**：作为操作系统课程或并发算法研究的基准测试工具。\n\n> **注**：该模块通常作为内核测试模块（`CONFIG_RCU_REF_SCALE_TEST`）编译，不用于生产环境。",
      "similarity": 0.5686742067337036,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 477,
          "end_line": 607,
          "content": [
            "static void ref_acqrel_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tunsigned long x;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tx = smp_load_acquire(this_cpu_ptr(&test_acqrel));",
            "\t\tun_delay(udl, ndl);",
            "\t\tsmp_store_release(this_cpu_ptr(&test_acqrel), x + 1);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_clock_section(const int nloops)",
            "{",
            "\tu64 x = 0;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--)",
            "\t\tx += ktime_get_real_fast_ns();",
            "\tpreempt_enable();",
            "\tstopopts = x;",
            "}",
            "static void ref_clock_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tu64 x = 0;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tx += ktime_get_real_fast_ns();",
            "\t\tun_delay(udl, ndl);",
            "\t}",
            "\tpreempt_enable();",
            "\tstopopts = x;",
            "}",
            "static void ref_jiffies_section(const int nloops)",
            "{",
            "\tu64 x = 0;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--)",
            "\t\tx += jiffies;",
            "\tpreempt_enable();",
            "\tstopopts = x;",
            "}",
            "static void ref_jiffies_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tu64 x = 0;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tx += jiffies;",
            "\t\tun_delay(udl, ndl);",
            "\t}",
            "\tpreempt_enable();",
            "\tstopopts = x;",
            "}",
            "static bool typesafe_ref_acquire(struct refscale_typesafe *rtsp, unsigned int *start)",
            "{",
            "\treturn atomic_inc_not_zero(&rtsp->rts_refctr);",
            "}",
            "static bool typesafe_ref_release(struct refscale_typesafe *rtsp, unsigned int start)",
            "{",
            "\tif (!atomic_dec_return(&rtsp->rts_refctr)) {",
            "\t\tWRITE_ONCE(rtsp->a, rtsp->a + 1);",
            "\t\tkmem_cache_free(typesafe_kmem_cachep, rtsp);",
            "\t}",
            "\treturn true;",
            "}",
            "static bool typesafe_lock_acquire(struct refscale_typesafe *rtsp, unsigned int *start)",
            "{",
            "\tspin_lock(&rtsp->rts_lock);",
            "\treturn true;",
            "}",
            "static bool typesafe_lock_release(struct refscale_typesafe *rtsp, unsigned int start)",
            "{",
            "\tspin_unlock(&rtsp->rts_lock);",
            "\treturn true;",
            "}",
            "static bool typesafe_seqlock_acquire(struct refscale_typesafe *rtsp, unsigned int *start)",
            "{",
            "\t*start = read_seqbegin(&rtsp->rts_seqlock);",
            "\treturn true;",
            "}",
            "static bool typesafe_seqlock_release(struct refscale_typesafe *rtsp, unsigned int start)",
            "{",
            "\treturn !read_seqretry(&rtsp->rts_seqlock, start);",
            "}",
            "static void typesafe_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tunsigned int a;",
            "\tunsigned int b;",
            "\tint i;",
            "\tlong idx;",
            "\tstruct refscale_typesafe *rtsp;",
            "\tunsigned int start;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tpreempt_disable();",
            "\t\tidx = torture_random(this_cpu_ptr(&refscale_rand)) % rtsarray_size;",
            "\t\tpreempt_enable();",
            "retry:",
            "\t\trcu_read_lock();",
            "\t\trtsp = rcu_dereference(rtsarray[idx]);",
            "\t\ta = READ_ONCE(rtsp->a);",
            "\t\tif (!rts_acquire(rtsp, &start)) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\tif (a != READ_ONCE(rtsp->a)) {",
            "\t\t\t(void)rts_release(rtsp, start);",
            "\t\t\trcu_read_unlock();",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\tun_delay(udl, ndl);",
            "\t\t// Remember, seqlock read-side release can fail.",
            "\t\tif (!rts_release(rtsp, start)) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\tgoto retry;",
            "\t\t}",
            "\t\tb = READ_ONCE(rtsp->a);",
            "\t\tWARN_ONCE(a != b, \"Re-read of ->a changed from %u to %u.\\n\", a, b);",
            "\t\tb = rtsp->b;",
            "\t\trcu_read_unlock();",
            "\t\tWARN_ON_ONCE(a * a != b);",
            "\t}",
            "}"
          ],
          "function_name": "ref_acqrel_delay_section, ref_clock_section, ref_clock_delay_section, ref_jiffies_section, ref_jiffies_delay_section, typesafe_ref_acquire, typesafe_ref_release, typesafe_lock_acquire, typesafe_lock_release, typesafe_seqlock_acquire, typesafe_seqlock_release, typesafe_delay_section",
          "description": "实现原子操作、时钟读取、Jiffies计数及类型安全引用的获取/释放逻辑，包含序列化锁和SeqLock的读操作验证流程。",
          "similarity": 0.48350486159324646
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 138,
          "end_line": 240,
          "content": [
            "static void un_delay(const int udl, const int ndl)",
            "{",
            "\tif (udl)",
            "\t\tudelay(udl);",
            "\tif (ndl)",
            "\t\tndelay(ndl);",
            "}",
            "static void ref_rcu_read_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\trcu_read_lock();",
            "\t\trcu_read_unlock();",
            "\t}",
            "}",
            "static void ref_rcu_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\trcu_read_lock();",
            "\t\tun_delay(udl, ndl);",
            "\t\trcu_read_unlock();",
            "\t}",
            "}",
            "static bool rcu_sync_scale_init(void)",
            "{",
            "\treturn true;",
            "}",
            "static void srcu_ref_scale_read_section(const int nloops)",
            "{",
            "\tint i;",
            "\tint idx;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tidx = srcu_read_lock(srcu_ctlp);",
            "\t\tsrcu_read_unlock(srcu_ctlp, idx);",
            "\t}",
            "}",
            "static void srcu_ref_scale_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "\tint idx;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tidx = srcu_read_lock(srcu_ctlp);",
            "\t\tun_delay(udl, ndl);",
            "\t\tsrcu_read_unlock(srcu_ctlp, idx);",
            "\t}",
            "}",
            "static void rcu_tasks_ref_scale_read_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--)",
            "\t\tcontinue;",
            "}",
            "static void rcu_tasks_ref_scale_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--)",
            "\t\tun_delay(udl, ndl);",
            "}",
            "static void rcu_trace_ref_scale_read_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\trcu_read_lock_trace();",
            "\t\trcu_read_unlock_trace();",
            "\t}",
            "}",
            "static void rcu_trace_ref_scale_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\trcu_read_lock_trace();",
            "\t\tun_delay(udl, ndl);",
            "\t\trcu_read_unlock_trace();",
            "\t}",
            "}",
            "static void ref_refcnt_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tatomic_inc(&refcnt);",
            "\t\tatomic_dec(&refcnt);",
            "\t}",
            "}",
            "static void ref_refcnt_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tatomic_inc(&refcnt);",
            "\t\tun_delay(udl, ndl);",
            "\t\tatomic_dec(&refcnt);",
            "\t}",
            "}"
          ],
          "function_name": "un_delay, ref_rcu_read_section, ref_rcu_delay_section, rcu_sync_scale_init, srcu_ref_scale_read_section, srcu_ref_scale_delay_section, rcu_tasks_ref_scale_read_section, rcu_tasks_ref_scale_delay_section, rcu_trace_ref_scale_read_section, rcu_trace_ref_scale_delay_section, ref_refcnt_section, ref_refcnt_delay_section",
          "description": "实现多种同步机制的读操作与延迟逻辑，通过RCU、SRCU、自旋锁、读写锁等机制进行并发访问测试，包含延迟注入和基础读操作循环。",
          "similarity": 0.4629533886909485
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 675,
          "end_line": 820,
          "content": [
            "static void typesafe_read_section(const int nloops)",
            "{",
            "\ttypesafe_delay_section(nloops, 0, 0);",
            "}",
            "static void refscale_typesafe_ctor(void *rtsp_in)",
            "{",
            "\tstruct refscale_typesafe *rtsp = rtsp_in;",
            "",
            "\tspin_lock_init(&rtsp->rts_lock);",
            "\tseqlock_init(&rtsp->rts_seqlock);",
            "\tpreempt_disable();",
            "\trtsp->a = torture_random(this_cpu_ptr(&refscale_rand));",
            "\tpreempt_enable();",
            "}",
            "static bool typesafe_init(void)",
            "{",
            "\tlong idx;",
            "\tlong si = lookup_instances;",
            "",
            "\ttypesafe_kmem_cachep = kmem_cache_create(\"refscale_typesafe\",",
            "\t\t\t\t\t\t sizeof(struct refscale_typesafe), sizeof(void *),",
            "\t\t\t\t\t\t SLAB_TYPESAFE_BY_RCU, refscale_typesafe_ctor);",
            "\tif (!typesafe_kmem_cachep)",
            "\t\treturn false;",
            "\tif (si < 0)",
            "\t\tsi = -si * nr_cpu_ids;",
            "\telse if (si == 0)",
            "\t\tsi = nr_cpu_ids;",
            "\trtsarray_size = si;",
            "\trtsarray = kcalloc(si, sizeof(*rtsarray), GFP_KERNEL);",
            "\tif (!rtsarray)",
            "\t\treturn false;",
            "\tfor (idx = 0; idx < rtsarray_size; idx++) {",
            "\t\trtsarray[idx] = typesafe_alloc_one();",
            "\t\tif (!rtsarray[idx])",
            "\t\t\treturn false;",
            "\t}",
            "\tif (cur_ops == &typesafe_ref_ops) {",
            "\t\trts_acquire = typesafe_ref_acquire;",
            "\t\trts_release = typesafe_ref_release;",
            "\t} else if (cur_ops == &typesafe_lock_ops) {",
            "\t\trts_acquire = typesafe_lock_acquire;",
            "\t\trts_release = typesafe_lock_release;",
            "\t} else if (cur_ops == &typesafe_seqlock_ops) {",
            "\t\trts_acquire = typesafe_seqlock_acquire;",
            "\t\trts_release = typesafe_seqlock_release;",
            "\t} else {",
            "\t\tWARN_ON_ONCE(1);",
            "\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static void typesafe_cleanup(void)",
            "{",
            "\tlong idx;",
            "",
            "\tif (rtsarray) {",
            "\t\tfor (idx = 0; idx < rtsarray_size; idx++)",
            "\t\t\tkmem_cache_free(typesafe_kmem_cachep, rtsarray[idx]);",
            "\t\tkfree(rtsarray);",
            "\t\trtsarray = NULL;",
            "\t\trtsarray_size = 0;",
            "\t}",
            "\tkmem_cache_destroy(typesafe_kmem_cachep);",
            "\ttypesafe_kmem_cachep = NULL;",
            "\trts_acquire = NULL;",
            "\trts_release = NULL;",
            "}",
            "static void rcu_scale_one_reader(void)",
            "{",
            "\tif (readdelay <= 0)",
            "\t\tcur_ops->readsection(loops);",
            "\telse",
            "\t\tcur_ops->delaysection(loops, readdelay / 1000, readdelay % 1000);",
            "}",
            "static int",
            "ref_scale_reader(void *arg)",
            "{",
            "\tunsigned long flags;",
            "\tlong me = (long)arg;",
            "\tstruct reader_task *rt = &(reader_tasks[me]);",
            "\tu64 start;",
            "\ts64 duration;",
            "",
            "\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: task started\", me);",
            "\tWARN_ON_ONCE(set_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids)));",
            "\tset_user_nice(current, MAX_NICE);",
            "\tatomic_inc(&n_init);",
            "\tif (holdoff)",
            "\t\tschedule_timeout_interruptible(holdoff * HZ);",
            "repeat:",
            "\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: waiting to start next experiment on cpu %d\", me, raw_smp_processor_id());",
            "",
            "\t// Wait for signal that this reader can start.",
            "\twait_event(rt->wq, (atomic_read(&nreaders_exp) && smp_load_acquire(&rt->start_reader)) ||",
            "\t\t\t   torture_must_stop());",
            "",
            "\tif (torture_must_stop())",
            "\t\tgoto end;",
            "",
            "\t// Make sure that the CPU is affinitized appropriately during testing.",
            "\tWARN_ON_ONCE(raw_smp_processor_id() != me);",
            "",
            "\tWRITE_ONCE(rt->start_reader, 0);",
            "\tif (!atomic_dec_return(&n_started))",
            "\t\twhile (atomic_read_acquire(&n_started))",
            "\t\t\tcpu_relax();",
            "",
            "\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: experiment %d started\", me, exp_idx);",
            "",
            "",
            "\t// To reduce noise, do an initial cache-warming invocation, check",
            "\t// in, and then keep warming until everyone has checked in.",
            "\trcu_scale_one_reader();",
            "\tif (!atomic_dec_return(&n_warmedup))",
            "\t\twhile (atomic_read_acquire(&n_warmedup))",
            "\t\t\trcu_scale_one_reader();",
            "\t// Also keep interrupts disabled.  This also has the effect",
            "\t// of preventing entries into slow path for rcu_read_unlock().",
            "\tlocal_irq_save(flags);",
            "\tstart = ktime_get_mono_fast_ns();",
            "",
            "\trcu_scale_one_reader();",
            "",
            "\tduration = ktime_get_mono_fast_ns() - start;",
            "\tlocal_irq_restore(flags);",
            "",
            "\trt->last_duration_ns = WARN_ON_ONCE(duration < 0) ? 0 : duration;",
            "\t// To reduce runtime-skew noise, do maintain-load invocations until",
            "\t// everyone is done.",
            "\tif (!atomic_dec_return(&n_cooleddown))",
            "\t\twhile (atomic_read_acquire(&n_cooleddown))",
            "\t\t\trcu_scale_one_reader();",
            "",
            "\tif (atomic_dec_and_test(&nreaders_exp))",
            "\t\twake_up(&main_wq);",
            "",
            "\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: experiment %d ended, (readers remaining=%d)\",",
            "\t\t\t\tme, exp_idx, atomic_read(&nreaders_exp));",
            "",
            "\tif (!torture_must_stop())",
            "\t\tgoto repeat;",
            "end:",
            "\ttorture_kthread_stopping(\"ref_scale_reader\");",
            "\treturn 0;",
            "}"
          ],
          "function_name": "typesafe_read_section, refscale_typesafe_ctor, typesafe_init, typesafe_cleanup, rcu_scale_one_reader, ref_scale_reader",
          "description": "定义类型安全引用的读操作入口，初始化和清理类型安全对象池，实现多线程测试任务的启动与执行控制逻辑。",
          "similarity": 0.44556260108947754
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 321,
          "end_line": 428,
          "content": [
            "static bool ref_rwlock_init(void)",
            "{",
            "\trwlock_init(&test_rwlock);",
            "\treturn true;",
            "}",
            "static void ref_rwlock_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tread_lock(&test_rwlock);",
            "\t\tread_unlock(&test_rwlock);",
            "\t}",
            "}",
            "static void ref_rwlock_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tread_lock(&test_rwlock);",
            "\t\tun_delay(udl, ndl);",
            "\t\tread_unlock(&test_rwlock);",
            "\t}",
            "}",
            "static bool ref_rwsem_init(void)",
            "{",
            "\tinit_rwsem(&test_rwsem);",
            "\treturn true;",
            "}",
            "static void ref_rwsem_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tdown_read(&test_rwsem);",
            "\t\tup_read(&test_rwsem);",
            "\t}",
            "}",
            "static void ref_rwsem_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tdown_read(&test_rwsem);",
            "\t\tun_delay(udl, ndl);",
            "\t\tup_read(&test_rwsem);",
            "\t}",
            "}",
            "static void ref_lock_section(const int nloops)",
            "{",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\traw_spin_lock(&test_lock);",
            "\t\traw_spin_unlock(&test_lock);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_lock_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\traw_spin_lock(&test_lock);",
            "\t\tun_delay(udl, ndl);",
            "\t\traw_spin_unlock(&test_lock);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_lock_irq_section(const int nloops)",
            "{",
            "\tunsigned long flags;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\traw_spin_lock_irqsave(&test_lock, flags);",
            "\t\traw_spin_unlock_irqrestore(&test_lock, flags);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_lock_irq_delay_section(const int nloops, const int udl, const int ndl)",
            "{",
            "\tunsigned long flags;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\traw_spin_lock_irqsave(&test_lock, flags);",
            "\t\tun_delay(udl, ndl);",
            "\t\traw_spin_unlock_irqrestore(&test_lock, flags);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "static void ref_acqrel_section(const int nloops)",
            "{",
            "\tunsigned long x;",
            "\tint i;",
            "",
            "\tpreempt_disable();",
            "\tfor (i = nloops; i >= 0; i--) {",
            "\t\tx = smp_load_acquire(this_cpu_ptr(&test_acqrel));",
            "\t\tsmp_store_release(this_cpu_ptr(&test_acqrel), x + 1);",
            "\t}",
            "\tpreempt_enable();",
            "}"
          ],
          "function_name": "ref_rwlock_init, ref_rwlock_section, ref_rwlock_delay_section, ref_rwsem_init, ref_rwsem_section, ref_rwsem_delay_section, ref_lock_section, ref_lock_delay_section, ref_lock_irq_section, ref_lock_irq_delay_section, ref_acqrel_section",
          "description": "提供基于读写锁、读写信号量、自旋锁等同步原语的测试函数，展示不同锁机制在高并发场景下的行为特征。",
          "similarity": 0.4315439462661743
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/rcu/refscale.c",
          "start_line": 1,
          "end_line": 137,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "//",
            "// Scalability test comparing RCU vs other mechanisms",
            "// for acquiring references on objects.",
            "//",
            "// Copyright (C) Google, 2020.",
            "//",
            "// Author: Joel Fernandes <joel@joelfernandes.org>",
            "",
            "#define pr_fmt(fmt) fmt",
            "",
            "#include <linux/atomic.h>",
            "#include <linux/bitops.h>",
            "#include <linux/completion.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/err.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/smp.h>",
            "#include <linux/stat.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/torture.h>",
            "#include <linux/types.h>",
            "",
            "#include \"rcu.h\"",
            "",
            "#define SCALE_FLAG \"-ref-scale: \"",
            "",
            "#define SCALEOUT(s, x...) \\",
            "\tpr_alert(\"%s\" SCALE_FLAG s, scale_type, ## x)",
            "",
            "#define VERBOSE_SCALEOUT(s, x...) \\",
            "\tdo { \\",
            "\t\tif (verbose) \\",
            "\t\t\tpr_alert(\"%s\" SCALE_FLAG s \"\\n\", scale_type, ## x); \\",
            "\t} while (0)",
            "",
            "static atomic_t verbose_batch_ctr;",
            "",
            "#define VERBOSE_SCALEOUT_BATCH(s, x...)\t\t\t\t\t\t\t\\",
            "do {\t\t\t\t\t\t\t\t\t\t\t\\",
            "\tif (verbose &&\t\t\t\t\t\t\t\t\t\\",
            "\t    (verbose_batched <= 0 ||\t\t\t\t\t\t\t\\",
            "\t     !(atomic_inc_return(&verbose_batch_ctr) % verbose_batched))) {\t\t\\",
            "\t\tschedule_timeout_uninterruptible(1);\t\t\t\t\t\\",
            "\t\tpr_alert(\"%s\" SCALE_FLAG s \"\\n\", scale_type, ## x);\t\t\t\\",
            "\t}\t\t\t\t\t\t\t\t\t\t\\",
            "} while (0)",
            "",
            "#define SCALEOUT_ERRSTRING(s, x...) pr_alert(\"%s\" SCALE_FLAG \"!!! \" s \"\\n\", scale_type, ## x)",
            "",
            "MODULE_LICENSE(\"GPL\");",
            "MODULE_AUTHOR(\"Joel Fernandes (Google) <joel@joelfernandes.org>\");",
            "",
            "static char *scale_type = \"rcu\";",
            "module_param(scale_type, charp, 0444);",
            "MODULE_PARM_DESC(scale_type, \"Type of test (rcu, srcu, refcnt, rwsem, rwlock.\");",
            "",
            "torture_param(int, verbose, 0, \"Enable verbose debugging printk()s\");",
            "torture_param(int, verbose_batched, 0, \"Batch verbose debugging printk()s\");",
            "",
            "// Wait until there are multiple CPUs before starting test.",
            "torture_param(int, holdoff, IS_BUILTIN(CONFIG_RCU_REF_SCALE_TEST) ? 10 : 0,",
            "\t      \"Holdoff time before test start (s)\");",
            "// Number of typesafe_lookup structures, that is, the degree of concurrency.",
            "torture_param(long, lookup_instances, 0, \"Number of typesafe_lookup structures.\");",
            "// Number of loops per experiment, all readers execute operations concurrently.",
            "torture_param(long, loops, 10000, \"Number of loops per experiment.\");",
            "// Number of readers, with -1 defaulting to about 75% of the CPUs.",
            "torture_param(int, nreaders, -1, \"Number of readers, -1 for 75% of CPUs.\");",
            "// Number of runs.",
            "torture_param(int, nruns, 30, \"Number of experiments to run.\");",
            "// Reader delay in nanoseconds, 0 for no delay.",
            "torture_param(int, readdelay, 0, \"Read-side delay in nanoseconds.\");",
            "",
            "#ifdef MODULE",
            "# define REFSCALE_SHUTDOWN 0",
            "#else",
            "# define REFSCALE_SHUTDOWN 1",
            "#endif",
            "",
            "torture_param(bool, shutdown, REFSCALE_SHUTDOWN,",
            "\t      \"Shutdown at end of scalability tests.\");",
            "",
            "struct reader_task {",
            "\tstruct task_struct *task;",
            "\tint start_reader;",
            "\twait_queue_head_t wq;",
            "\tu64 last_duration_ns;",
            "};",
            "",
            "static struct task_struct *shutdown_task;",
            "static wait_queue_head_t shutdown_wq;",
            "",
            "static struct task_struct *main_task;",
            "static wait_queue_head_t main_wq;",
            "static int shutdown_start;",
            "",
            "static struct reader_task *reader_tasks;",
            "",
            "// Number of readers that are part of the current experiment.",
            "static atomic_t nreaders_exp;",
            "",
            "// Use to wait for all threads to start.",
            "static atomic_t n_init;",
            "static atomic_t n_started;",
            "static atomic_t n_warmedup;",
            "static atomic_t n_cooleddown;",
            "",
            "// Track which experiment is currently running.",
            "static int exp_idx;",
            "",
            "// Operations vector for selecting different types of tests.",
            "struct ref_scale_ops {",
            "\tbool (*init)(void);",
            "\tvoid (*cleanup)(void);",
            "\tvoid (*readsection)(const int nloops);",
            "\tvoid (*delaysection)(const int nloops, const int udl, const int ndl);",
            "\tconst char *name;",
            "};",
            "",
            "static struct ref_scale_ops *cur_ops;",
            ""
          ],
          "function_name": null,
          "description": "定义RCU可扩展性测试框架的基础结构，包含模块参数、日志宏、测试类型选择及各同步机制的操作接口声明。",
          "similarity": 0.4074692130088806
        }
      ]
    }
  ]
}