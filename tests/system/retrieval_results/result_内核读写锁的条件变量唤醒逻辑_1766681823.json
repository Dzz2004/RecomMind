{
  "query": "内核读写锁的条件变量唤醒逻辑",
  "timestamp": "2025-12-26 00:57:03",
  "retrieved_files": [
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.5809935927391052,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.5552423596382141
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.5273150205612183
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.46582427620887756
        }
      ]
    },
    {
      "source_file": "kernel/locking/spinlock.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:53:30\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\spinlock.c`\n\n---\n\n# `locking/spinlock.c` 技术文档\n\n## 1. 文件概述\n\n`locking/spinlock.c` 是 Linux 内核中实现自旋锁（spinlock）和读写锁（rwlock）通用逻辑的核心源文件。该文件主要为对称多处理器（SMP）系统以及启用了锁调试（如 `DEBUG_SPINLOCK` 或 `DEBUG_LOCK_ALLOC`）的配置提供锁操作的通用实现。在单处理器（UP）且未启用调试的配置下，相关操作通常以内联函数形式直接展开，不依赖此文件。\n\n该文件通过宏生成机制构建了多种锁操作函数，包括普通加锁、中断屏蔽加锁、软中断屏蔽加锁等变体，并支持可抢占内核（`CONFIG_PREEMPT`）下的友好调度行为。此外，文件还处理了与内存映射 I/O 写屏障（`CONFIG_MMIOWB`）相关的每 CPU 状态管理。\n\n## 2. 核心功能\n\n### 数据结构\n- `struct mmiowb_state`（条件定义）：用于跟踪每 CPU 的内存映射 I/O 写屏障状态，仅在 `CONFIG_MMIOWB` 启用且架构未提供自有实现时定义。\n  - 全局符号：`DEFINE_PER_CPU(struct mmiowb_state, __mmiowb_state)`，并通过 `EXPORT_PER_CPU_SYMBOL` 导出。\n\n### 主要函数（通过宏生成或显式定义）\n- **自旋锁（spinlock）操作**：\n  - `_raw_spin_lock` / `__raw_spin_lock`\n  - `_raw_spin_lock_irq` / `__raw_spin_lock_irq`\n  - `_raw_spin_lock_irqsave` / `__raw_spin_lock_irqsave`\n  - `_raw_spin_lock_bh` / `__raw_spin_lock_bh`\n  - `_raw_spin_trylock` / `__raw_spin_trylock`\n  - 对应的解锁函数（如 `_raw_spin_unlock` 等）\n\n- **读写锁（rwlock）操作**（非 `PREEMPT_RT` 配置下）：\n  - `_raw_read_lock` / `__raw_read_lock` 等读操作\n  - `_raw_write_lock` / `__raw_write_lock` 等写操作\n  - `_raw_write_lock_nested`：支持锁类嵌套的写锁获取\n\n- **架构相关松弛函数（默认回退）**：\n  - `arch_read_relax`, `arch_write_relax`, `arch_spin_relax`：默认定义为 `cpu_relax()`，允许架构提供特定优化。\n\n## 3. 关键实现\n\n### 锁操作的通用构建机制\n- 使用 `BUILD_LOCK_OPS(op, locktype)` 宏统一生成加锁函数族（`_lock`, `_lock_irqsave`, `_lock_irq`, `_lock_bh`）。\n- 每个加锁函数采用 **“尝试-失败-松弛-重试”** 循环：\n  1. 禁用抢占（`preempt_disable()`）\n  2. 尝试原子获取锁（调用 `do_raw_##op##_trylock`）\n  3. 若成功则退出；否则恢复抢占（`preempt_enable()`）\n  4. 调用架构特定的 `arch_##op##_relax()`（默认为 `cpu_relax()`）以降低 CPU 占用\n- 在 `_irqsave` 和 `_bh` 变体中，正确处理中断和软中断的屏蔽与恢复。\n\n### 可抢占性与调试兼容性\n- 当启用 `CONFIG_DEBUG_LOCK_ALLOC` 或未定义 `CONFIG_GENERIC_LOCKBREAK` 时，**不使用**上述通用构建逻辑，而是依赖头文件（`spinlock_api_smp.h` / `rwlock_api_smp.h`）中的内联实现，以满足锁依赖验证器（lockdep）对中断状态的假设。\n- 在通用构建路径中，循环内显式启用/禁用抢占，使得长时间自旋时当前 CPU 可被抢占，提升系统响应性。\n\n### 函数导出与内联控制\n- 所有 `_raw_*` 函数均通过条件编译（如 `#ifndef CONFIG_INLINE_SPIN_LOCK`）决定是否以内联或 `noinline` 形式定义。\n- 非内联版本使用 `EXPORT_SYMBOL` 导出，供模块或其他编译单元调用。\n- 解锁函数同样受 `CONFIG_UNINLINE_SPIN_UNLOCK` 等配置项控制。\n\n### 嵌套写锁支持\n- `_raw_write_lock_nested` 函数在非调试模式下退化为普通写锁；在调试模式下保留子类参数以支持锁类验证。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/spinlock.h>`：核心锁类型和 API 声明\n  - `<linux/preempt.h>`：抢占控制原语（`preempt_disable/enable`）\n  - `<linux/interrupt.h>`：中断控制（`local_irq_save/restore`, `local_bh_disable`）\n  - `<linux/debug_locks.h>`：调试锁相关宏\n  - `<linux/export.h>`：符号导出宏\n  - `<linux/linkage.h>`：链接属性定义\n\n- **架构依赖**：\n  - 依赖架构层提供底层原子操作（如 `do_raw_spin_trylock` 的实际实现通常在 `arch/*/include/asm/spinlock.h` 中）\n  - 架构可覆盖 `arch_*_relax` 宏以优化自旋行为\n  - 某些架构的性能分析工具（如 `profile_pc`）依赖此文件中函数的栈帧结构稳定性\n\n- **配置依赖**：\n  - `CONFIG_SMP`：SMP 支持是此文件生效的前提\n  - `CONFIG_PREEMPT` / `CONFIG_PREEMPT_RT`：影响锁实现路径选择\n  - `CONFIG_DEBUG_LOCK_ALLOC`：决定是否使用通用构建逻辑\n  - `CONFIG_MMIOWB`：控制每 CPU `mmiowb_state` 的定义\n\n## 5. 使用场景\n\n- **内核同步原语实现**：作为自旋锁和读写锁的通用后端，被内核各子系统（如内存管理、文件系统、设备驱动、网络栈等）广泛用于保护临界区。\n- **中断上下文同步**：通过 `_irq` / `_irqsave` 变体，在中断处理程序与进程上下文之间提供同步。\n- **软中断同步**：通过 `_bh` 变体，防止软中断与进程上下文同时访问共享数据。\n- **实时内核适配**：在 `PREEMPT_RT` 补丁集下，读写锁实现被替换，但自旋锁仍由此文件提供（部分路径被绕过）。\n- **锁调试与验证**：配合 `lockdep` 子系统，在开发和调试阶段检测死锁、锁顺序违规等问题。\n- **性能关键路径**：通过可配置的内联/非内联策略，在代码大小与性能之间取得平衡。",
      "similarity": 0.5731551051139832,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/spinlock.c",
          "start_line": 136,
          "end_line": 239,
          "content": [
            "noinline int __lockfunc _raw_spin_trylock(raw_spinlock_t *lock)",
            "{",
            "\treturn __raw_spin_trylock(lock);",
            "}",
            "noinline int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)",
            "{",
            "\treturn __raw_spin_trylock_bh(lock);",
            "}",
            "noinline void __lockfunc _raw_spin_lock(raw_spinlock_t *lock)",
            "{",
            "\t__raw_spin_lock(lock);",
            "}",
            "noinline unsigned long __lockfunc _raw_spin_lock_irqsave(raw_spinlock_t *lock)",
            "{",
            "\treturn __raw_spin_lock_irqsave(lock);",
            "}",
            "noinline void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)",
            "{",
            "\t__raw_spin_lock_irq(lock);",
            "}",
            "noinline void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)",
            "{",
            "\t__raw_spin_lock_bh(lock);",
            "}",
            "noinline void __lockfunc _raw_spin_unlock(raw_spinlock_t *lock)",
            "{",
            "\t__raw_spin_unlock(lock);",
            "}",
            "noinline void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)",
            "{",
            "\t__raw_spin_unlock_irqrestore(lock, flags);",
            "}",
            "noinline void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)",
            "{",
            "\t__raw_spin_unlock_irq(lock);",
            "}",
            "noinline void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)",
            "{",
            "\t__raw_spin_unlock_bh(lock);",
            "}",
            "noinline int __lockfunc _raw_read_trylock(rwlock_t *lock)",
            "{",
            "\treturn __raw_read_trylock(lock);",
            "}",
            "noinline void __lockfunc _raw_read_lock(rwlock_t *lock)",
            "{",
            "\t__raw_read_lock(lock);",
            "}",
            "noinline unsigned long __lockfunc _raw_read_lock_irqsave(rwlock_t *lock)",
            "{",
            "\treturn __raw_read_lock_irqsave(lock);",
            "}",
            "noinline void __lockfunc _raw_read_lock_irq(rwlock_t *lock)",
            "{",
            "\t__raw_read_lock_irq(lock);",
            "}",
            "noinline void __lockfunc _raw_read_lock_bh(rwlock_t *lock)",
            "{",
            "\t__raw_read_lock_bh(lock);",
            "}",
            "noinline void __lockfunc _raw_read_unlock(rwlock_t *lock)",
            "{",
            "\t__raw_read_unlock(lock);",
            "}",
            "noinline void __lockfunc _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)",
            "{",
            "\t__raw_read_unlock_irqrestore(lock, flags);",
            "}",
            "noinline void __lockfunc _raw_read_unlock_irq(rwlock_t *lock)",
            "{",
            "\t__raw_read_unlock_irq(lock);",
            "}",
            "noinline void __lockfunc _raw_read_unlock_bh(rwlock_t *lock)",
            "{",
            "\t__raw_read_unlock_bh(lock);",
            "}",
            "noinline int __lockfunc _raw_write_trylock(rwlock_t *lock)",
            "{",
            "\treturn __raw_write_trylock(lock);",
            "}",
            "noinline void __lockfunc _raw_write_lock(rwlock_t *lock)",
            "{",
            "\t__raw_write_lock(lock);",
            "}",
            "void __lockfunc _raw_write_lock_nested(rwlock_t *lock, int subclass)",
            "{",
            "\t__raw_write_lock_nested(lock, subclass);",
            "}",
            "noinline unsigned long __lockfunc _raw_write_lock_irqsave(rwlock_t *lock)",
            "{",
            "\treturn __raw_write_lock_irqsave(lock);",
            "}",
            "noinline void __lockfunc _raw_write_lock_irq(rwlock_t *lock)",
            "{",
            "\t__raw_write_lock_irq(lock);",
            "}",
            "noinline void __lockfunc _raw_write_lock_bh(rwlock_t *lock)",
            "{",
            "\t__raw_write_lock_bh(lock);",
            "}",
            "noinline void __lockfunc _raw_write_unlock(rwlock_t *lock)",
            "{",
            "\t__raw_write_unlock(lock);",
            "}"
          ],
          "function_name": "_raw_spin_trylock, _raw_spin_trylock_bh, _raw_spin_lock, _raw_spin_lock_irqsave, _raw_spin_lock_irq, _raw_spin_lock_bh, _raw_spin_unlock, _raw_spin_unlock_irqrestore, _raw_spin_unlock_irq, _raw_spin_unlock_bh, _raw_read_trylock, _raw_read_lock, _raw_read_lock_irqsave, _raw_read_lock_irq, _raw_read_lock_bh, _raw_read_unlock, _raw_read_unlock_irqrestore, _raw_read_unlock_irq, _raw_read_unlock_bh, _raw_write_trylock, _raw_write_lock, _raw_write_lock_nested, _raw_write_lock_irqsave, _raw_write_lock_irq, _raw_write_lock_bh, _raw_write_unlock",
          "description": "实现底层自旋锁和读写锁的具体操作函数，包括尝试加锁、加锁、解锁及其中断/软中断变种，所有函数均调用相应的__raw_*系列内核函数执行实际锁状态变更。",
          "similarity": 0.5790166854858398
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/spinlock.c",
          "start_line": 1,
          "end_line": 135,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (2004) Linus Torvalds",
            " *",
            " * Author: Zwane Mwaikambo <zwane@fsmlabs.com>",
            " *",
            " * Copyright (2004, 2005) Ingo Molnar",
            " *",
            " * This file contains the spinlock/rwlock implementations for the",
            " * SMP and the DEBUG_SPINLOCK cases. (UP-nondebug inlines them)",
            " *",
            " * Note that some architectures have special knowledge about the",
            " * stack frames of these functions in their profile_pc. If you",
            " * change anything significant here that could change the stack",
            " * frame contact the architecture maintainers.",
            " */",
            "",
            "#include <linux/linkage.h>",
            "#include <linux/preempt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/export.h>",
            "",
            "#ifdef CONFIG_MMIOWB",
            "#ifndef arch_mmiowb_state",
            "DEFINE_PER_CPU(struct mmiowb_state, __mmiowb_state);",
            "EXPORT_PER_CPU_SYMBOL(__mmiowb_state);",
            "#endif",
            "#endif",
            "",
            "/*",
            " * If lockdep is enabled then we use the non-preemption spin-ops",
            " * even on CONFIG_PREEMPT, because lockdep assumes that interrupts are",
            " * not re-enabled during lock-acquire (which the preempt-spin-ops do):",
            " */",
            "#if !defined(CONFIG_GENERIC_LOCKBREAK) || defined(CONFIG_DEBUG_LOCK_ALLOC)",
            "/*",
            " * The __lock_function inlines are taken from",
            " * spinlock : include/linux/spinlock_api_smp.h",
            " * rwlock   : include/linux/rwlock_api_smp.h",
            " */",
            "#else",
            "",
            "/*",
            " * Some architectures can relax in favour of the CPU owning the lock.",
            " */",
            "#ifndef arch_read_relax",
            "# define arch_read_relax(l)\tcpu_relax()",
            "#endif",
            "#ifndef arch_write_relax",
            "# define arch_write_relax(l)\tcpu_relax()",
            "#endif",
            "#ifndef arch_spin_relax",
            "# define arch_spin_relax(l)\tcpu_relax()",
            "#endif",
            "",
            "/*",
            " * We build the __lock_function inlines here. They are too large for",
            " * inlining all over the place, but here is only one user per function",
            " * which embeds them into the calling _lock_function below.",
            " *",
            " * This could be a long-held lock. We both prepare to spin for a long",
            " * time (making _this_ CPU preemptible if possible), and we also signal",
            " * towards that other CPU that it should break the lock ASAP.",
            " */",
            "#define BUILD_LOCK_OPS(op, locktype)\t\t\t\t\t\\",
            "void __lockfunc __raw_##op##_lock(locktype##_t *lock)\t\t\t\\",
            "{\t\t\t\t\t\t\t\t\t\\",
            "\tfor (;;) {\t\t\t\t\t\t\t\\",
            "\t\tpreempt_disable();\t\t\t\t\t\\",
            "\t\tif (likely(do_raw_##op##_trylock(lock)))\t\t\\",
            "\t\t\tbreak;\t\t\t\t\t\t\\",
            "\t\tpreempt_enable();\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "\t\tarch_##op##_relax(&lock->raw_lock);\t\t\t\\",
            "\t}\t\t\t\t\t\t\t\t\\",
            "}\t\t\t\t\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "unsigned long __lockfunc __raw_##op##_lock_irqsave(locktype##_t *lock)\t\\",
            "{\t\t\t\t\t\t\t\t\t\\",
            "\tunsigned long flags;\t\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "\tfor (;;) {\t\t\t\t\t\t\t\\",
            "\t\tpreempt_disable();\t\t\t\t\t\\",
            "\t\tlocal_irq_save(flags);\t\t\t\t\t\\",
            "\t\tif (likely(do_raw_##op##_trylock(lock)))\t\t\\",
            "\t\t\tbreak;\t\t\t\t\t\t\\",
            "\t\tlocal_irq_restore(flags);\t\t\t\t\\",
            "\t\tpreempt_enable();\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "\t\tarch_##op##_relax(&lock->raw_lock);\t\t\t\\",
            "\t}\t\t\t\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "\treturn flags;\t\t\t\t\t\t\t\\",
            "}\t\t\t\t\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "void __lockfunc __raw_##op##_lock_irq(locktype##_t *lock)\t\t\\",
            "{\t\t\t\t\t\t\t\t\t\\",
            "\t_raw_##op##_lock_irqsave(lock);\t\t\t\t\t\\",
            "}\t\t\t\t\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "void __lockfunc __raw_##op##_lock_bh(locktype##_t *lock)\t\t\\",
            "{\t\t\t\t\t\t\t\t\t\\",
            "\tunsigned long flags;\t\t\t\t\t\t\\",
            "\t\t\t\t\t\t\t\t\t\\",
            "\t/*\t\t\t\t\t\t\t*/\t\\",
            "\t/* Careful: we must exclude softirqs too, hence the\t*/\t\\",
            "\t/* irq-disabling. We use the generic preemption-aware\t*/\t\\",
            "\t/* function:\t\t\t\t\t\t*/\t\\",
            "\t/**/\t\t\t\t\t\t\t\t\\",
            "\tflags = _raw_##op##_lock_irqsave(lock);\t\t\t\t\\",
            "\tlocal_bh_disable();\t\t\t\t\t\t\\",
            "\tlocal_irq_restore(flags);\t\t\t\t\t\\",
            "}\t\t\t\t\t\t\t\t\t\\",
            "",
            "/*",
            " * Build preemption-friendly versions of the following",
            " * lock-spinning functions:",
            " *",
            " *         __[spin|read|write]_lock()",
            " *         __[spin|read|write]_lock_irq()",
            " *         __[spin|read|write]_lock_irqsave()",
            " *         __[spin|read|write]_lock_bh()",
            " */",
            "BUILD_LOCK_OPS(spin, raw_spinlock);",
            "",
            "#ifndef CONFIG_PREEMPT_RT",
            "BUILD_LOCK_OPS(read, rwlock);",
            "BUILD_LOCK_OPS(write, rwlock);",
            "#endif",
            "",
            "#endif",
            "",
            "#ifndef CONFIG_INLINE_SPIN_TRYLOCK"
          ],
          "function_name": null,
          "description": "定义并生成针对SMP和DEBUG_SPINLOCK的自旋锁及读写锁操作函数，通过宏展开创建多种锁操作接口，支持中断和软中断处理，包含架构特定的放松函数（如cpu_relax）和MMIOWB状态定义。",
          "similarity": 0.5334511995315552
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/spinlock.c",
          "start_line": 348,
          "end_line": 395,
          "content": [
            "noinline void __lockfunc _raw_write_unlock_irqrestore(rwlock_t *lock, unsigned long flags)",
            "{",
            "\t__raw_write_unlock_irqrestore(lock, flags);",
            "}",
            "noinline void __lockfunc _raw_write_unlock_irq(rwlock_t *lock)",
            "{",
            "\t__raw_write_unlock_irq(lock);",
            "}",
            "noinline void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)",
            "{",
            "\t__raw_write_unlock_bh(lock);",
            "}",
            "void __lockfunc _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)",
            "{",
            "\tpreempt_disable();",
            "\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);",
            "\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);",
            "}",
            "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,",
            "\t\t\t\t\t\t   int subclass)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "\tpreempt_disable();",
            "\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);",
            "\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);",
            "\treturn flags;",
            "}",
            "void __lockfunc _raw_spin_lock_nest_lock(raw_spinlock_t *lock,",
            "\t\t\t\t     struct lockdep_map *nest_lock)",
            "{",
            "\tpreempt_disable();",
            "\tspin_acquire_nest(&lock->dep_map, 0, 0, nest_lock, _RET_IP_);",
            "\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);",
            "}",
            "notrace int in_lock_functions(unsigned long addr)",
            "{",
            "\t/* Linker adds these: start and end of __lockfunc functions */",
            "\textern char __lock_text_start[], __lock_text_end[];",
            "",
            "\treturn addr >= (unsigned long)__lock_text_start",
            "\t&& addr < (unsigned long)__lock_text_end;",
            "}",
            "void notrace lockdep_assert_in_softirq_func(void)",
            "{",
            "\tlockdep_assert_in_softirq();",
            "}"
          ],
          "function_name": "_raw_write_unlock_irqrestore, _raw_write_unlock_irq, _raw_write_unlock_bh, _raw_spin_lock_nested, _raw_spin_lock_irqsave_nested, _raw_spin_lock_nest_lock, in_lock_functions, lockdep_assert_in_softirq_func",
          "description": "提供嵌套锁操作和锁跟踪辅助函数，包含带子类别的锁获取、锁范围检测函数in_lock_functions，以及确保在软中断上下文的安全性检查函数lockdep_assert_in_softirq_func。",
          "similarity": 0.5003641843795776
        }
      ]
    },
    {
      "source_file": "kernel/bpf/mmap_unlock_work.h",
      "md_summary": "> 自动生成时间: 2025-10-25 12:20:10\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\mmap_unlock_work.h`\n\n---\n\n# `bpf/mmap_unlock_work.h` 技术文档\n\n## 文件概述\n\n`bpf/mmap_unlock_work.h` 是 Linux 内核中用于在中断上下文（特别是中断关闭状态下）安全释放 `mmap_read_lock` 的辅助机制。该文件定义了一个基于 `irq_work` 的延迟解锁机制，以避免在中断禁用时直接调用 `mmap_read_unlock()` 可能导致的死锁问题（尤其是与调度器 `rq_lock` 的竞争）。此机制主要用于 BPF 子系统在遍历 VMA（虚拟内存区域）时的安全内存映射读锁管理。\n\n## 核心功能\n\n### 数据结构\n\n- **`struct mmap_unlock_irq_work`**  \n  封装了 `irq_work` 和目标 `mm_struct`，用于在中断工作队列中异步执行 `mmap_read_unlock()`。\n  - `struct irq_work irq_work`：内核通用的中断工作结构。\n  - `struct mm_struct *mm`：需要释放读锁的内存描述符。\n\n- **`DECLARE_PER_CPU(struct mmap_unlock_irq_work, mmap_unlock_work)`**  \n  声明一个 per-CPU 变量 `mmap_unlock_work`，每个 CPU 核心拥有一个独立实例，避免并发冲突。\n\n### 主要函数\n\n- **`bpf_mmap_unlock_get_irq_work()`**  \n  检查当前是否处于中断禁用上下文，并尝试获取可用的 per-CPU `mmap_unlock_irq_work` 实例。  \n  - 若中断已禁用且非 `PREEMPT_RT` 内核，则尝试使用本 CPU 的 `irq_work`。\n  - 若 `irq_work` 正在被使用（`irq_work_is_busy()` 返回 true），则返回 `true` 表示无法使用延迟解锁，需回退到其他处理路径。\n  - 在 `PREEMPT_RT` 内核中，由于实时性要求禁止在中断禁用上下文中尝试获取 mmap 信号量，直接强制回退。\n  - 返回值：`true` 表示 `irq_work` 不可用（需回退），`false` 表示可用；通过 `work_ptr` 输出获取到的 `work` 指针（可能为 `NULL`）。\n\n- **`bpf_mmap_unlock_mm()`**  \n  根据传入的 `work` 指针决定解锁方式：\n  - 若 `work == NULL`，直接调用 `mmap_read_unlock(mm)`。\n  - 否则，将 `mm` 保存到 `work` 中，通过 `rwsem_release()` 通知 Lockdep 锁已逻辑释放（避免误报锁泄漏），然后将 `irq_work` 加入中断工作队列，由中断上下文稍后执行实际解锁。\n\n## 关键实现\n\n1. **中断上下文安全解锁**  \n   在中断关闭（`irqs_disabled()`）时，直接调用 `mmap_read_unlock()` 可能因内部调度或锁竞争导致死锁（如与 runqueue 锁冲突）。因此，采用 `irq_work` 机制将解锁操作延迟到中断使能的上下文执行。\n\n2. **Per-CPU 单实例设计**  \n   每个 CPU 仅有一个 `mmap_unlock_work` 实例。若该实例已被占用（`irq_work_is_busy()`），则无法排队新的解锁请求，调用方必须采用回退策略（如放弃 VMA 查找或使用其他路径）。这种设计简化了同步，但限制了并发能力。\n\n3. **Lockdep 兼容性处理**  \n   在排队 `irq_work` 前，显式调用 `rwsem_release(&mm->mmap_lock.dep_map, _RET_IP_)`，告知 Lockdep 子系统“逻辑上”已释放锁，防止 Lockdep 误判为锁泄漏。\n\n4. **PREEMPT_RT 特殊处理**  \n   在实时内核（`CONFIG_PREEMPT_RT`）中，即使在中断禁用上下文也不允许尝试获取 mmap 信号量，因此直接跳过 `irq_work` 机制，强制使用回退路径，确保实时性约束。\n\n## 依赖关系\n\n- **`<linux/irq_work.h>`**：提供 `irq_work` 基础设施，包括 `irq_work_queue()`、`irq_work_is_busy()` 等接口。\n- **内存管理子系统**：依赖 `mm_struct` 和 `mmap_lock`（读写信号量）的定义及 `mmap_read_unlock()` 实现。\n- **Lockdep 子系统**：通过 `rwsem_release()` 与 Lockdep 交互，确保锁状态跟踪正确。\n- **BPF 子系统**：该头文件主要服务于 BPF 程序在内核态访问用户内存时的安全 VMA 查找逻辑。\n\n## 使用场景\n\n该文件主要用于 **BPF 程序在内核态执行期间需要安全访问用户空间内存映射** 的场景，典型流程如下：\n\n1. BPF 程序（如 kprobe、tracepoint 等）在中断或软中断上下文中执行。\n2. 需要通过 `mm->mmap_lock` 读锁保护来查找目标 VMA（例如 `bpf_probe_read_user()`）。\n3. 若当前处于 `irqs_disabled()` 状态：\n   - 调用 `bpf_mmap_unlock_get_irq_work()` 获取延迟解锁工作项。\n   - 若获取成功，则在完成 VMA 操作后调用 `bpf_mmap_unlock_mm()`，将解锁操作排队到 `irq_work`。\n   - 若获取失败（`irq_work` 忙或 `PREEMPT_RT`），则必须放弃操作或采用不依赖 mmap 锁的替代方案。\n4. 当中断上下文退出、中断重新使能后，`irq_work` 回调自动执行 `mmap_read_unlock()`，完成实际解锁。\n\n此机制确保了在高优先级上下文（如中断处理）中对内存映射的只读访问既安全又不会破坏内核锁的正确性。",
      "similarity": 0.5692007541656494,
      "chunks": []
    }
  ]
}