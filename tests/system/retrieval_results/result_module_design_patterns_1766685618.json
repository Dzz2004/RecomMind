{
  "query": "module design patterns",
  "timestamp": "2025-12-26 02:00:18",
  "retrieved_files": [
    {
      "source_file": "kernel/module/dups.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:00:29\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\dups.c`\n\n---\n\n# `module/dups.c` 技术文档\n\n## 1. 文件概述\n\n`module/dups.c` 实现了 Linux 内核模块自动加载（`request_module()`）过程中的**重复请求抑制机制**。该机制旨在防止多个并发线程对同一模块发起重复的自动加载请求，从而避免不必要的用户空间 `modprobe` 调用、减少 `vmalloc()` 内存碎片，并优化系统启动或模块加载期间的性能。\n\n该功能通过维护一个受互斥锁保护的重复请求跟踪列表，对首次请求进行记录，并让后续重复请求等待首个请求的结果，最终共享其返回值，从而实现去重与同步。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct kmod_dup_req`**  \n  表示一个模块加载请求的跟踪条目，包含：\n  - `list`：链表节点，用于加入全局 `dup_kmod_reqs` 列表\n  - `name[MODULE_NAME_LEN]`：模块名称\n  - `first_req_done`：完成量（`completion`），用于通知等待者首个请求已完成\n  - `complete_work`：工作队列项，用于异步完成所有等待者的通知\n  - `delete_work`：延迟工作队列项，用于在请求完成后一段时间（60秒）自动清理条目\n  - `dup_ret`：首个请求的返回值，供后续重复请求复用\n\n### 主要函数\n\n- **`kmod_dup_request_lookup(char *module_name)`**  \n  在 `dup_kmod_reqs` 列表中查找是否存在指定模块名的请求条目（需持有 `kmod_dup_mutex` 锁）。\n\n- **`kmod_dup_request_delete(struct work_struct *work)`**  \n  延迟工作回调函数，从列表中安全删除请求条目并释放内存（使用 RCU 同步）。\n\n- **`kmod_dup_request_complete(struct work_struct *work)`**  \n  工作队列回调函数，调用 `complete_all()` 唤醒所有等待该模块加载完成的线程，并调度延迟删除。\n\n- **`kmod_dup_request_exists_wait(char *module_name, bool wait, int *dup_ret)`**  \n  **核心入口函数**。检查是否存在对 `module_name` 的重复请求：\n  - 若不存在且当前为 `request_module()`（`wait == true`），则创建新条目并返回 `false`（表示非重复）。\n  - 若为 `request_module_nowait()`（`wait == false`）且无现有条目，则不跟踪，返回 `false`。\n  - 若存在重复请求：\n    - 对 `nowait` 请求，直接返回成功（`*dup_ret = 0`）。\n    - 对 `wait` 请求，等待首个请求完成并复用其返回值。\n  - 若启用 `enable_dups_trace`，对重复请求触发 `WARN()` 警告。\n\n- **`kmod_dup_request_announce(char *module_name, int ret)`**  \n  由首个请求的调用者在 `request_module()` 返回后调用，用于记录返回值 `ret` 并触发完成通知（通过工作队列异步执行）。\n\n### 模块参数\n\n- **`module.enable_dups_trace`**（布尔型，只读写 `true`）  \n  控制是否对重复请求使用 `WARN()`（否则仅 `pr_warn`）。默认值由 `CONFIG_MODULE_DEBUG_AUTOLOAD_DUPS_TRACE` 决定。\n\n## 3. 关键实现\n\n### 重复请求检测与同步机制\n\n1. **首次请求处理**：\n   - `request_module()`（`wait=true`）调用 `kmod_dup_request_exists_wait()`。\n   - 若无重复条目，则分配 `kmod_dup_req` 并加入全局列表，返回 `false`，继续执行用户空间加载。\n   - `request_module_nowait()`（`wait=false`）若为首个请求，则不创建条目，直接返回 `false`（不参与去重）。\n\n2. **重复请求处理**：\n   - 后续相同模块名的请求命中已有条目。\n   - `nowait` 请求立即返回成功（`0`）。\n   - `wait` 请求调用 `wait_for_completion_state()` 等待首个请求完成。\n\n3. **结果广播与清理**：\n   - 首个请求完成后调用 `kmod_dup_request_announce()`，记录返回值并调度 `complete_work`。\n   - `complete_work` 调用 `complete_all()` 唤醒所有等待者。\n   - 随后调度 `delete_work`，60 秒后自动清理条目（避免内存泄漏，同时容忍短暂窗口内的新请求）。\n\n### 并发与内存安全\n\n- **互斥锁保护**：`kmod_dup_mutex` 保护列表的增删操作。\n- **RCU 读取**：`kmod_dup_request_lookup()` 使用 `list_for_each_entry_rcu()`，允许无锁读取（需持有锁或处于 RCU 读侧临界区）。\n- **延迟删除**：通过 `synchronize_rcu()` 确保所有读者完成后再释放内存。\n- **预分配优化**：在获取锁前预分配 `new_kmod_req`，减少锁持有时间。\n\n### 设计权衡\n\n- **不跟踪 `nowait` 首请求**：因无法提供有效返回值给后续 `wait` 请求。\n- **容忍短暂重复窗口**：删除条目前允许新请求直接调用 `modprobe`（仅返回 0），认为这是用户空间的责任。\n- **异步完成通知**：避免在 `kmod_dup_request_announce()` 中阻塞首个请求的调用路径。\n\n## 4. 依赖关系\n\n- **内部头文件**：`#include \"internal.h\"`（模块子系统内部接口）\n- **内核核心组件**：\n  - `linux/kmod.h`：`request_module()` 相关接口\n  - `linux/completion.h`：完成量同步原语\n  - `linux/workqueue.h`：工作队列机制\n  - `linux/rcupdate.h`（隐式）：RCU 同步\n  - `linux/mutex.h`：互斥锁\n  - `linux/slab.h`：内存分配\n- **配置依赖**：`CONFIG_MODULE_DEBUG_AUTOLOAD_DUPS_TRACE` 控制调试行为\n\n## 5. 使用场景\n\n- **内核模块自动加载**：当多个子系统（如设备驱动、文件系统、网络协议）几乎同时尝试通过 `request_module()` 加载同一模块时，避免多次调用用户空间 `modprobe`。\n- **系统启动优化**：在初始化阶段减少因模块重复加载导致的 `vmalloc()` 内存碎片和不必要的上下文切换。\n- **防止滥用**：检测并警告开发人员对 `request_module()` 的低效重复调用，鼓励使用 `try_then_request_module()` 或集中加载策略。\n- **异步加载兼容**：支持 `request_module_nowait()` 与 `request_module()` 混合调用场景下的合理去重。",
      "similarity": 0.5385256409645081,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/module/dups.c",
          "start_line": 1,
          "end_line": 71,
          "content": [
            "/* SPDX-License-Identifier: GPL-2.0-or-later */",
            "/*",
            " * kmod dups - the kernel module autoloader duplicate suppressor",
            " *",
            " * Copyright (C) 2023 Luis Chamberlain <mcgrof@kernel.org>",
            " */",
            "",
            "#define pr_fmt(fmt)     \"module: \" fmt",
            "",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/unistd.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/cred.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/resource.h>",
            "#include <linux/notifier.h>",
            "#include <linux/suspend.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/async.h>",
            "#include <linux/uaccess.h>",
            "",
            "#include \"internal.h\"",
            "",
            "#undef MODULE_PARAM_PREFIX",
            "#define MODULE_PARAM_PREFIX \"module.\"",
            "static bool enable_dups_trace = IS_ENABLED(CONFIG_MODULE_DEBUG_AUTOLOAD_DUPS_TRACE);",
            "module_param(enable_dups_trace, bool_enable_only, 0644);",
            "",
            "/*",
            " * Protects dup_kmod_reqs list, adds / removals with RCU.",
            " */",
            "static DEFINE_MUTEX(kmod_dup_mutex);",
            "static LIST_HEAD(dup_kmod_reqs);",
            "",
            "struct kmod_dup_req {",
            "\tstruct list_head list;",
            "\tchar name[MODULE_NAME_LEN];",
            "\tstruct completion first_req_done;",
            "\tstruct work_struct complete_work;",
            "\tstruct delayed_work delete_work;",
            "\tint dup_ret;",
            "};",
            "",
            "static struct kmod_dup_req *kmod_dup_request_lookup(char *module_name)",
            "{",
            "\tstruct kmod_dup_req *kmod_req;",
            "",
            "\tlist_for_each_entry_rcu(kmod_req, &dup_kmod_reqs, list,",
            "\t\t\t\tlockdep_is_held(&kmod_dup_mutex)) {",
            "\t\tif (strlen(kmod_req->name) == strlen(module_name) &&",
            "\t\t    !memcmp(kmod_req->name, module_name, strlen(module_name))) {",
            "\t\t\treturn kmod_req;",
            "                }",
            "        }",
            "",
            "\treturn NULL;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义内核模块自动加载重复抑制器的基础设施，包括互斥锁保护的链表结构、模块请求记录结构体kmod_dup_req及其成员变量，提供基于RCU的查找接口",
          "similarity": 0.5078006982803345
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/dups.c",
          "start_line": 72,
          "end_line": 218,
          "content": [
            "static void kmod_dup_request_delete(struct work_struct *work)",
            "{",
            "\tstruct kmod_dup_req *kmod_req;",
            "\tkmod_req = container_of(to_delayed_work(work), struct kmod_dup_req, delete_work);",
            "",
            "\t/*",
            "\t * The typical situation is a module successully loaded. In that",
            "\t * situation the module will be present already in userspace. If",
            "\t * new requests come in after that, userspace will already know the",
            "\t * module is loaded so will just return 0 right away. There is still",
            "\t * a small chance right after we delete this entry new request_module()",
            "\t * calls may happen after that, they can happen. These heuristics",
            "\t * are to protect finit_module() abuse for auto-loading, if modules",
            "\t * are still tryign to auto-load even if a module is already loaded,",
            "\t * that's on them, and those inneficiencies should not be fixed by",
            "\t * kmod. The inneficies there are a call to modprobe and modprobe",
            "\t * just returning 0.",
            "\t */",
            "\tmutex_lock(&kmod_dup_mutex);",
            "\tlist_del_rcu(&kmod_req->list);",
            "\tsynchronize_rcu();",
            "\tmutex_unlock(&kmod_dup_mutex);",
            "\tkfree(kmod_req);",
            "}",
            "static void kmod_dup_request_complete(struct work_struct *work)",
            "{",
            "\tstruct kmod_dup_req *kmod_req;",
            "",
            "\tkmod_req = container_of(work, struct kmod_dup_req, complete_work);",
            "",
            "\t/*",
            "\t * This will ensure that the kernel will let all the waiters get",
            "\t * informed its time to check the return value. It's time to",
            "\t * go home.",
            "\t */",
            "\tcomplete_all(&kmod_req->first_req_done);",
            "",
            "\t/*",
            "\t * Now that we have allowed prior request_module() calls to go on",
            "\t * with life, let's schedule deleting this entry. We don't have",
            "\t * to do it right away, but we *eventually* want to do it so to not",
            "\t * let this linger forever as this is just a boot optimization for",
            "\t * possible abuses of vmalloc() incurred by finit_module() thrashing.",
            "\t */",
            "\tqueue_delayed_work(system_wq, &kmod_req->delete_work, 60 * HZ);",
            "}",
            "bool kmod_dup_request_exists_wait(char *module_name, bool wait, int *dup_ret)",
            "{",
            "\tstruct kmod_dup_req *kmod_req, *new_kmod_req;",
            "\tint ret;",
            "",
            "\t/*",
            "\t * Pre-allocate the entry in case we have to use it later",
            "\t * to avoid contention with the mutex.",
            "\t */",
            "\tnew_kmod_req = kzalloc(sizeof(*new_kmod_req), GFP_KERNEL);",
            "\tif (!new_kmod_req)",
            "\t\treturn false;",
            "",
            "\tmemcpy(new_kmod_req->name, module_name, strlen(module_name));",
            "\tINIT_WORK(&new_kmod_req->complete_work, kmod_dup_request_complete);",
            "\tINIT_DELAYED_WORK(&new_kmod_req->delete_work, kmod_dup_request_delete);",
            "\tinit_completion(&new_kmod_req->first_req_done);",
            "",
            "\tmutex_lock(&kmod_dup_mutex);",
            "",
            "\tkmod_req = kmod_dup_request_lookup(module_name);",
            "\tif (!kmod_req) {",
            "\t\t/*",
            "\t\t * If the first request that came through for a module",
            "\t\t * was with request_module_nowait() we cannot wait for it",
            "\t\t * and share its return value with other users which may",
            "\t\t * have used request_module() and need a proper return value",
            "\t\t * so just skip using them as an anchor.",
            "\t\t *",
            "\t\t * If a prior request to this one came through with",
            "\t\t * request_module() though, then a request_module_nowait()",
            "\t\t * would benefit from duplicate detection.",
            "\t\t */",
            "\t\tif (!wait) {",
            "\t\t\tkfree(new_kmod_req);",
            "\t\t\tpr_debug(\"New request_module_nowait() for %s -- cannot track duplicates for this request\\n\", module_name);",
            "\t\t\tmutex_unlock(&kmod_dup_mutex);",
            "\t\t\treturn false;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * There was no duplicate, just add the request so we can",
            "\t\t * keep tab on duplicates later.",
            "\t\t */",
            "\t\tpr_debug(\"New request_module() for %s\\n\", module_name);",
            "\t\tlist_add_rcu(&new_kmod_req->list, &dup_kmod_reqs);",
            "\t\tmutex_unlock(&kmod_dup_mutex);",
            "\t\treturn false;",
            "\t}",
            "\tmutex_unlock(&kmod_dup_mutex);",
            "",
            "\t/* We are dealing with a duplicate request now */",
            "\tkfree(new_kmod_req);",
            "",
            "\t/*",
            "\t * To fix these try to use try_then_request_module() instead as that",
            "\t * will check if the component you are looking for is present or not.",
            "\t * You could also just queue a single request to load the module once,",
            "\t * instead of having each and everything you need try to request for",
            "\t * the module.",
            "\t *",
            "\t * Duplicate request_module() calls  can cause quite a bit of wasted",
            "\t * vmalloc() space when racing with userspace.",
            "\t */",
            "\tif (enable_dups_trace)",
            "\t\tWARN(1, \"module-autoload: duplicate request for module %s\\n\", module_name);",
            "\telse",
            "\t\tpr_warn(\"module-autoload: duplicate request for module %s\\n\", module_name);",
            "",
            "\tif (!wait) {",
            "\t\t/*",
            "\t\t * If request_module_nowait() was used then the user just",
            "\t\t * wanted to issue the request and if another module request",
            "\t\t * was already its way with the same name we don't care for",
            "\t\t * the return value either. Let duplicate request_module_nowait()",
            "\t\t * calls bail out right away.",
            "\t\t */",
            "\t\t*dup_ret = 0;",
            "\t\treturn true;",
            "\t}",
            "",
            "\t/*",
            "\t * If a duplicate request_module() was used they *may* care for",
            "\t * the return value, so we have no other option but to wait for",
            "\t * the first caller to complete. If the first caller used",
            "\t * the request_module_nowait() call, subsquent callers will",
            "\t * deal with the comprmise of getting a successful call with this",
            "\t * optimization enabled ...",
            "\t */",
            "\tret = wait_for_completion_state(&kmod_req->first_req_done,",
            "\t\t\t\t\tTASK_UNINTERRUPTIBLE | TASK_KILLABLE);",
            "\tif (ret) {",
            "\t\t*dup_ret = ret;",
            "\t\treturn true;",
            "\t}",
            "",
            "\t/* Now the duplicate request has the same exact return value as the first request */",
            "\t*dup_ret = kmod_req->dup_ret;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "kmod_dup_request_delete, kmod_dup_request_complete, kmod_dup_request_exists_wait",
          "description": "实现重复模块请求的处理逻辑，通过工作队列延迟清理冗余请求，支持等待首次请求结果并传递给后续请求，防止因重复加载导致的资源浪费",
          "similarity": 0.495583176612854
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/module/dups.c",
          "start_line": 222,
          "end_line": 248,
          "content": [
            "void kmod_dup_request_announce(char *module_name, int ret)",
            "{",
            "\tstruct kmod_dup_req *kmod_req;",
            "",
            "\tmutex_lock(&kmod_dup_mutex);",
            "",
            "\tkmod_req = kmod_dup_request_lookup(module_name);",
            "\tif (!kmod_req)",
            "\t\tgoto out;",
            "",
            "\tkmod_req->dup_ret = ret;",
            "",
            "\t/*",
            "\t * If we complete() here we may allow duplicate threads",
            "\t * to continue before the first one that submitted the",
            "\t * request. We're in no rush also, given that each and",
            "\t * every bounce back to userspace is slow we avoid that",
            "\t * with a slight delay here. So queueue up the completion",
            "\t * and let duplicates suffer, just wait a tad bit longer.",
            "\t * There is no rush. But we also don't want to hold the",
            "\t * caller up forever or introduce any boot delays.",
            "\t */",
            "\tqueue_work(system_wq, &kmod_req->complete_work);",
            "",
            "out:",
            "\tmutex_unlock(&kmod_dup_mutex);",
            "}"
          ],
          "function_name": "kmod_dup_request_announce",
          "description": "通告模块加载结果的接口函数，通过唤醒等待队列通知后续请求获取首次加载的返回状态，避免重复发起不必要的模块加载请求",
          "similarity": 0.43782949447631836
        }
      ]
    },
    {
      "source_file": "kernel/module/stats.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:06:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\stats.c`\n\n---\n\n# `module/stats.c` 技术文档\n\n## 1. 文件概述\n\n`module/stats.c` 是 Linux 内核模块子系统中用于收集和跟踪模块加载失败相关调试统计信息的实现文件。当启用 `CONFIG_MODULE_STATS` 配置选项时，该文件提供对模块加载过程中因各种原因失败所导致的虚拟内存浪费情况的监控能力。其主要目标是帮助开发者和系统维护人员识别和优化模块加载过程中的资源浪费问题，特别是在系统启动阶段因重复加载或竞争条件导致的无效内存分配。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`dup_failed_modules`**  \n  全局静态链表（`LIST_HEAD`），用于记录因模块名称重复（已加载或正在处理）而加载失败的模块实例。该链表帮助追踪因用户空间竞争或内核并发加载导致的无效加载尝试。\n\n### 调试统计计数器（通过 debugfs 暴露）\n\n- **`total_mod_size`**：系统处理过的所有模块占用的总字节数。\n- **`total_text_size`**：所有模块的 `.text` 和 `.init.text` ELF 节区大小总和。\n- **`invalid_kread_bytes`**：因 `kernel_read_file_from_fd()` 阶段失败而浪费的 `vmalloc()` 分配字节数。\n- **`invalid_decompress_bytes`**：模块解压过程中因失败而浪费的 `vmap()` 分配字节数。\n- **`invalid_becoming_bytes`**：在 `early_mod_check()` 之后、`layout_and_allocate()` 之前失败所浪费的内存总量（含解压和读取阶段）。\n- **`invalid_mod_bytes`**：在 `layout_and_allocate()` 之后（即模块已分配最终内存布局）因失败而释放的内存总量。\n\n> 注：文档片段在 `invalid_mod_bytes` 处截断，但根据上下文可推断其用于统计最晚阶段（模块结构体已分配）的失败内存开销。\n\n## 3. 关键实现\n\n### 模块加载失败的三阶段内存模型\n\n模块加载过程中的内存分配分为三个关键阶段，每个阶段失败对应不同的统计计数器：\n\n1. **阶段 a**：`kernel_read_file_from_fd()` 使用 `vmalloc()` 读取模块文件。\n2. **阶段 b**（可选）：若模块为压缩格式，解压后通过 `vmap()` 映射解压内容，原始读取缓冲区随即释放。\n3. **阶段 c**：`layout_and_allocate()` 为模块分配最终运行时内存布局（可能使用 `vzalloc()` 或架构特定的 `vmalloc` 变体）。\n\n失败统计遵循“最晚失败点”原则：仅在导致失败的最晚阶段对应的计数器中累加**该次加载尝试中所有已分配并最终释放的内存总量**。\n\n### 重复模块加载失败分类\n\n针对因模块名重复导致的失败，细分为两类：\n\n- **`FAIL_DUP_MOD_BECOMING`**：在 `early_mod_check()` 末尾检测到重复（尚未调用 `layout_and_allocate()`）。\n  - 有解压：浪费 2 次分配（`kread` + `vmap`）\n  - 无解压：浪费 1 次分配（`kread`）\n- **`FAIL_DUP_MOD_LOAD`**：在 `add_unformed_module()` 阶段检测到重复（已执行 `layout_and_allocate()`）。\n  - 有解压：浪费 3 次分配\n  - 无解压：浪费 2 次分配\n\n### 原子计数与性能考量\n\n所有统计计数器均使用**原子操作**更新，以避免锁竞争、死锁及性能开销，确保在高并发模块加载场景下的低延迟。\n\n### debugfs 集成\n\n统计信息通过 **debugfs** 文件系统暴露，便于用户空间工具（如 `cat /sys/kernel/debug/...`）实时监控模块加载效率和内存浪费情况。\n\n## 4. 依赖关系\n\n- **内核头文件依赖**：\n  - `<linux/module.h>`：模块核心接口\n  - `<linux/debugfs.h>`：调试文件系统支持\n  - `<linux/vmalloc.h>` 相关（通过 `slab.h`, `math.h` 等间接依赖）：虚拟内存分配\n  - `<linux/rculist.h>`：RCU 安全链表操作\n- **内部依赖**：\n  - `\"internal.h\"`：模块子系统内部头文件，包含未公开的模块管理结构和函数\n- **配置依赖**：\n  - 仅在 `CONFIG_MODULE_STATS=y` 时编译生效\n\n## 5. 使用场景\n\n- **系统启动优化**：分析启动过程中因用户空间并发调用 `modprobe` 或 `request_module()` 导致的重复模块加载，减少不必要的 `vmalloc` 压力。\n- **内存压力诊断**：在虚拟地址空间受限的架构（如 x86 默认 128 MiB vmalloc 空间）上，定位模块加载失败是否加剧内存碎片或耗尽问题。\n- **内核/用户空间协同改进**：通过 `dup_failed_modules` 链表识别用户空间加载逻辑缺陷（如未检查 `/sys/module` 即重复加载），推动工具链优化。\n- **安全与验证调试**：监控因签名验证（`module_sig_check`）、ELF 格式错误或黑名单策略导致的早期失败，评估安全机制开销。",
      "similarity": 0.5370522737503052,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/stats.c",
          "start_line": 220,
          "end_line": 385,
          "content": [
            "void mod_stat_bump_invalid(struct load_info *info, int flags)",
            "{",
            "\tatomic_long_add(info->len * 2, &invalid_mod_bytes);",
            "\tatomic_inc(&failed_load_modules);",
            "#if defined(CONFIG_MODULE_DECOMPRESS)",
            "\tif (flags & MODULE_INIT_COMPRESSED_FILE)",
            "\t\tatomic_long_add(info->compressed_len, &invalid_mod_bytes);",
            "#endif",
            "}",
            "void mod_stat_bump_becoming(struct load_info *info, int flags)",
            "{",
            "\tatomic_inc(&failed_becoming);",
            "\tatomic_long_add(info->len, &invalid_becoming_bytes);",
            "#if defined(CONFIG_MODULE_DECOMPRESS)",
            "\tif (flags & MODULE_INIT_COMPRESSED_FILE)",
            "\t\tatomic_long_add(info->compressed_len, &invalid_becoming_bytes);",
            "#endif",
            "}",
            "int try_add_failed_module(const char *name, enum fail_dup_mod_reason reason)",
            "{",
            "\tstruct mod_fail_load *mod_fail;",
            "",
            "\tlist_for_each_entry_rcu(mod_fail, &dup_failed_modules, list,",
            "\t\t\t\tlockdep_is_held(&module_mutex)) {",
            "\t\tif (!strcmp(mod_fail->name, name)) {",
            "\t\t\tatomic_long_inc(&mod_fail->count);",
            "\t\t\t__set_bit(reason, &mod_fail->dup_fail_mask);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tmod_fail = kzalloc(sizeof(*mod_fail), GFP_KERNEL);",
            "\tif (!mod_fail)",
            "\t\treturn -ENOMEM;",
            "\tmemcpy(mod_fail->name, name, strlen(name));",
            "\t__set_bit(reason, &mod_fail->dup_fail_mask);",
            "\tatomic_long_inc(&mod_fail->count);",
            "\tlist_add_rcu(&mod_fail->list, &dup_failed_modules);",
            "out:",
            "\treturn 0;",
            "}",
            "static ssize_t read_file_mod_stats(struct file *file, char __user *user_buf,",
            "\t\t\t\t   size_t count, loff_t *ppos)",
            "{",
            "\tstruct mod_fail_load *mod_fail;",
            "\tunsigned int len, size, count_failed = 0;",
            "\tchar *buf;",
            "\tint ret;",
            "\tu32 live_mod_count, fkreads, fdecompress, fbecoming, floads;",
            "\tunsigned long total_size, text_size, ikread_bytes, ibecoming_bytes,",
            "\t\tidecompress_bytes, imod_bytes, total_virtual_lost;",
            "",
            "\tlive_mod_count = atomic_read(&modcount);",
            "\tfkreads = atomic_read(&failed_kreads);",
            "\tfdecompress = atomic_read(&failed_decompress);",
            "\tfbecoming = atomic_read(&failed_becoming);",
            "\tfloads = atomic_read(&failed_load_modules);",
            "",
            "\ttotal_size = atomic_long_read(&total_mod_size);",
            "\ttext_size = atomic_long_read(&total_text_size);",
            "\tikread_bytes = atomic_long_read(&invalid_kread_bytes);",
            "\tidecompress_bytes = atomic_long_read(&invalid_decompress_bytes);",
            "\tibecoming_bytes = atomic_long_read(&invalid_becoming_bytes);",
            "\timod_bytes = atomic_long_read(&invalid_mod_bytes);",
            "",
            "\ttotal_virtual_lost = ikread_bytes + idecompress_bytes + ibecoming_bytes + imod_bytes;",
            "",
            "\tsize = MAX_PREAMBLE + min((unsigned int)(floads + fbecoming),",
            "\t\t\t\t  (unsigned int)MAX_FAILED_MOD_PRINT) * MAX_BYTES_PER_MOD;",
            "\tbuf = kzalloc(size, GFP_KERNEL);",
            "\tif (buf == NULL)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/* The beginning of our debug preamble */",
            "\tlen = scnprintf(buf, size, \"%25s\\t%u\\n\", \"Mods ever loaded\", live_mod_count);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%u\\n\", \"Mods failed on kread\", fkreads);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%u\\n\", \"Mods failed on decompress\",",
            "\t\t\t fdecompress);",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%u\\n\", \"Mods failed on becoming\", fbecoming);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%u\\n\", \"Mods failed on load\", floads);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Total module size\", total_size);",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Total mod text size\", text_size);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Failed kread bytes\", ikread_bytes);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Failed decompress bytes\",",
            "\t\t\t idecompress_bytes);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Failed becoming bytes\", ibecoming_bytes);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Failed kmod bytes\", imod_bytes);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Virtual mem wasted bytes\", total_virtual_lost);",
            "",
            "\tif (live_mod_count && total_size) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Average mod size\",",
            "\t\t\t\t DIV_ROUND_UP(total_size, live_mod_count));",
            "\t}",
            "",
            "\tif (live_mod_count && text_size) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Average mod text size\",",
            "\t\t\t\t DIV_ROUND_UP(text_size, live_mod_count));",
            "\t}",
            "",
            "\t/*",
            "\t * We use WARN_ON_ONCE() for the counters to ensure we always have parity",
            "\t * for keeping tabs on a type of failure with one type of byte counter.",
            "\t * The counters for imod_bytes does not increase for fkreads failures",
            "\t * for example, and so on.",
            "\t */",
            "",
            "\tWARN_ON_ONCE(ikread_bytes && !fkreads);",
            "\tif (fkreads && ikread_bytes) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Avg fail kread bytes\",",
            "\t\t\t\t DIV_ROUND_UP(ikread_bytes, fkreads));",
            "\t}",
            "",
            "\tWARN_ON_ONCE(ibecoming_bytes && !fbecoming);",
            "\tif (fbecoming && ibecoming_bytes) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Avg fail becoming bytes\",",
            "\t\t\t\t DIV_ROUND_UP(ibecoming_bytes, fbecoming));",
            "\t}",
            "",
            "\tWARN_ON_ONCE(idecompress_bytes && !fdecompress);",
            "\tif (fdecompress && idecompress_bytes) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Avg fail decomp bytes\",",
            "\t\t\t\t DIV_ROUND_UP(idecompress_bytes, fdecompress));",
            "\t}",
            "",
            "\tWARN_ON_ONCE(imod_bytes && !floads);",
            "\tif (floads && imod_bytes) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Average fail load bytes\",",
            "\t\t\t\t DIV_ROUND_UP(imod_bytes, floads));",
            "\t}",
            "",
            "\t/* End of our debug preamble header. */",
            "",
            "\t/* Catch when we've gone beyond our expected preamble */",
            "\tWARN_ON_ONCE(len >= MAX_PREAMBLE);",
            "",
            "\tif (list_empty(&dup_failed_modules))",
            "\t\tgoto out;",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"Duplicate failed modules:\\n\");",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%15s\\t%25s\\n\",",
            "\t\t\t \"Module-name\", \"How-many-times\", \"Reason\");",
            "\tmutex_lock(&module_mutex);",
            "",
            "",
            "\tlist_for_each_entry_rcu(mod_fail, &dup_failed_modules, list) {",
            "\t\tif (WARN_ON_ONCE(++count_failed >= MAX_FAILED_MOD_PRINT))",
            "\t\t\tgoto out_unlock;",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%15lu\\t%25s\\n\", mod_fail->name,",
            "\t\t\t\t atomic_long_read(&mod_fail->count), mod_fail_to_str(mod_fail));",
            "\t}",
            "out_unlock:",
            "\tmutex_unlock(&module_mutex);",
            "out:",
            "\tret = simple_read_from_buffer(user_buf, count, ppos, buf, len);",
            "\tkfree(buf);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "mod_stat_bump_invalid, mod_stat_bump_becoming, try_add_failed_module, read_file_mod_stats",
          "description": "实现模块加载失败统计的更新逻辑与导出接口，包含失败计数器递增、失败模块记录及调试信息格式化输出功能",
          "similarity": 0.5025300979614258
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/stats.c",
          "start_line": 1,
          "end_line": 219,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Debugging module statistics.",
            " *",
            " * Copyright (C) 2023 Luis Chamberlain <mcgrof@kernel.org>",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <uapi/linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/math.h>",
            "",
            "#include \"internal.h\"",
            "",
            "/**",
            " * DOC: module debugging statistics overview",
            " *",
            " * Enabling CONFIG_MODULE_STATS enables module debugging statistics which",
            " * are useful to monitor and root cause memory pressure issues with module",
            " * loading. These statistics are useful to allow us to improve production",
            " * workloads.",
            " *",
            " * The current module debugging statistics supported help keep track of module",
            " * loading failures to enable improvements either for kernel module auto-loading",
            " * usage (request_module()) or interactions with userspace. Statistics are",
            " * provided to track all possible failures in the finit_module() path and memory",
            " * wasted in this process space.  Each of the failure counters are associated",
            " * to a type of module loading failure which is known to incur a certain amount",
            " * of memory allocation loss. In the worst case loading a module will fail after",
            " * a 3 step memory allocation process:",
            " *",
            " *   a) memory allocated with kernel_read_file_from_fd()",
            " *   b) module decompression processes the file read from",
            " *      kernel_read_file_from_fd(), and vmap() is used to map",
            " *      the decompressed module to a new local buffer which represents",
            " *      a copy of the decompressed module passed from userspace. The buffer",
            " *      from kernel_read_file_from_fd() is freed right away.",
            " *   c) layout_and_allocate() allocates space for the final resting",
            " *      place where we would keep the module if it were to be processed",
            " *      successfully.",
            " *",
            " * If a failure occurs after these three different allocations only one",
            " * counter will be incremented with the summation of the allocated bytes freed",
            " * incurred during this failure. Likewise, if module loading failed only after",
            " * step b) a separate counter is used and incremented for the bytes freed and",
            " * not used during both of those allocations.",
            " *",
            " * Virtual memory space can be limited, for example on x86 virtual memory size",
            " * defaults to 128 MiB. We should strive to limit and avoid wasting virtual",
            " * memory allocations when possible. These module debugging statistics help",
            " * to evaluate how much memory is being wasted on bootup due to module loading",
            " * failures.",
            " *",
            " * All counters are designed to be incremental. Atomic counters are used so to",
            " * remain simple and avoid delays and deadlocks.",
            " */",
            "",
            "/**",
            " * DOC: dup_failed_modules - tracks duplicate failed modules",
            " *",
            " * Linked list of modules which failed to be loaded because an already existing",
            " * module with the same name was already being processed or already loaded.",
            " * The finit_module() system call incurs heavy virtual memory allocations. In",
            " * the worst case an finit_module() system call can end up allocating virtual",
            " * memory 3 times:",
            " *",
            " *   1) kernel_read_file_from_fd() call uses vmalloc()",
            " *   2) optional module decompression uses vmap()",
            " *   3) layout_and allocate() can use vzalloc() or an arch specific variation of",
            " *      vmalloc to deal with ELF sections requiring special permissions",
            " *",
            " * In practice on a typical boot today most finit_module() calls fail due to",
            " * the module with the same name already being loaded or about to be processed.",
            " * All virtual memory allocated to these failed modules will be freed with",
            " * no functional use.",
            " *",
            " * To help with this the dup_failed_modules allows us to track modules which",
            " * failed to load due to the fact that a module was already loaded or being",
            " * processed.  There are only two points at which we can fail such calls,",
            " * we list them below along with the number of virtual memory allocation",
            " * calls:",
            " *",
            " *   a) FAIL_DUP_MOD_BECOMING: at the end of early_mod_check() before",
            " *\tlayout_and_allocate().",
            " *\t- with module decompression: 2 virtual memory allocation calls",
            " *\t- without module decompression: 1 virtual memory allocation calls",
            " *   b) FAIL_DUP_MOD_LOAD: after layout_and_allocate() on add_unformed_module()",
            " *   \t- with module decompression 3 virtual memory allocation calls",
            " *   \t- without module decompression 2 virtual memory allocation calls",
            " *",
            " * We should strive to get this list to be as small as possible. If this list",
            " * is not empty it is a reflection of possible work or optimizations possible",
            " * either in-kernel or in userspace.",
            " */",
            "static LIST_HEAD(dup_failed_modules);",
            "",
            "/**",
            " * DOC: module statistics debugfs counters",
            " *",
            " * The total amount of wasted virtual memory allocation space during module",
            " * loading can be computed by adding the total from the summation:",
            " *",
            " *   * @invalid_kread_bytes +",
            " *     @invalid_decompress_bytes +",
            " *     @invalid_becoming_bytes +",
            " *     @invalid_mod_bytes",
            " *",
            " * The following debugfs counters are available to inspect module loading",
            " * failures:",
            " *",
            " *   * total_mod_size: total bytes ever used by all modules we've dealt with on",
            " *     this system",
            " *   * total_text_size: total bytes of the .text and .init.text ELF section",
            " *     sizes we've dealt with on this system",
            " *   * invalid_kread_bytes: bytes allocated and then freed on failures which",
            " *     happen due to the initial kernel_read_file_from_fd(). kernel_read_file_from_fd()",
            " *     uses vmalloc(). These should typically not happen unless your system is",
            " *     under memory pressure.",
            " *   * invalid_decompress_bytes: number of bytes allocated and freed due to",
            " *     memory allocations in the module decompression path that use vmap().",
            " *     These typically should not happen unless your system is under memory",
            " *     pressure.",
            " *   * invalid_becoming_bytes: total number of bytes allocated and freed used",
            " *     used to read the kernel module userspace wants us to read before we",
            " *     promote it to be processed to be added to our @modules linked list. These",
            " *     failures can happen if we had a check in between a successful kernel_read_file_from_fd()",
            " *     call and right before we allocate the our private memory for the module",
            " *     which would be kept if the module is successfully loaded. The most common",
            " *     reason for this failure is when userspace is racing to load a module",
            " *     which it does not yet see loaded. The first module to succeed in",
            " *     add_unformed_module() will add a module to our &modules list and",
            " *     subsequent loads of modules with the same name will error out at the",
            " *     end of early_mod_check(). The check for module_patient_check_exists()",
            " *     at the end of early_mod_check() prevents duplicate allocations",
            " *     on layout_and_allocate() for modules already being processed. These",
            " *     duplicate failed modules are non-fatal, however they typically are",
            " *     indicative of userspace not seeing a module in userspace loaded yet and",
            " *     unnecessarily trying to load a module before the kernel even has a chance",
            " *     to begin to process prior requests. Although duplicate failures can be",
            " *     non-fatal, we should try to reduce vmalloc() pressure proactively, so",
            " *     ideally after boot this will be close to as 0 as possible.  If module",
            " *     decompression was used we also add to this counter the cost of the",
            " *     initial kernel_read_file_from_fd() of the compressed module. If module",
            " *     decompression was not used the value represents the total allocated and",
            " *     freed bytes in kernel_read_file_from_fd() calls for these type of",
            " *     failures. These failures can occur because:",
            " *",
            " *    * module_sig_check() - module signature checks",
            " *    * elf_validity_cache_copy() - some ELF validation issue",
            " *    * early_mod_check():",
            " *",
            " *      * blacklisting",
            " *      * failed to rewrite section headers",
            " *      * version magic",
            " *      * live patch requirements didn't check out",
            " *      * the module was detected as being already present",
            " *",
            " *   * invalid_mod_bytes: these are the total number of bytes allocated and",
            " *     freed due to failures after we did all the sanity checks of the module",
            " *     which userspace passed to us and after our first check that the module",
            " *     is unique.  A module can still fail to load if we detect the module is",
            " *     loaded after we allocate space for it with layout_and_allocate(), we do",
            " *     this check right before processing the module as live and run its",
            " *     initialization routines. Note that you have a failure of this type it",
            " *     also means the respective kernel_read_file_from_fd() memory space was",
            " *     also freed and not used, and so we increment this counter with twice",
            " *     the size of the module. Additionally if you used module decompression",
            " *     the size of the compressed module is also added to this counter.",
            " *",
            " *  * modcount: how many modules we've loaded in our kernel life time",
            " *  * failed_kreads: how many modules failed due to failed kernel_read_file_from_fd()",
            " *  * failed_decompress: how many failed module decompression attempts we've had.",
            " *    These really should not happen unless your compression / decompression",
            " *    might be broken.",
            " *  * failed_becoming: how many modules failed after we kernel_read_file_from_fd()",
            " *    it and before we allocate memory for it with layout_and_allocate(). This",
            " *    counter is never incremented if you manage to validate the module and",
            " *    call layout_and_allocate() for it.",
            " *  * failed_load_modules: how many modules failed once we've allocated our",
            " *    private space for our module using layout_and_allocate(). These failures",
            " *    should hopefully mostly be dealt with already. Races in theory could",
            " *    still exist here, but it would just mean the kernel had started processing",
            " *    two threads concurrently up to early_mod_check() and one thread won.",
            " *    These failures are good signs the kernel or userspace is doing something",
            " *    seriously stupid or that could be improved. We should strive to fix these,",
            " *    but it is perhaps not easy to fix them. A recent example are the modules",
            " *    requests incurred for frequency modules, a separate module request was",
            " *    being issued for each CPU on a system.",
            " */",
            "",
            "atomic_long_t total_mod_size;",
            "atomic_long_t total_text_size;",
            "atomic_long_t invalid_kread_bytes;",
            "atomic_long_t invalid_decompress_bytes;",
            "static atomic_long_t invalid_becoming_bytes;",
            "static atomic_long_t invalid_mod_bytes;",
            "atomic_t modcount;",
            "atomic_t failed_kreads;",
            "atomic_t failed_decompress;",
            "static atomic_t failed_becoming;",
            "static atomic_t failed_load_modules;",
            "",
            "static const char *mod_fail_to_str(struct mod_fail_load *mod_fail)",
            "{",
            "\tif (test_bit(FAIL_DUP_MOD_BECOMING, &mod_fail->dup_fail_mask) &&",
            "\t    test_bit(FAIL_DUP_MOD_LOAD, &mod_fail->dup_fail_mask))",
            "\t\treturn \"Becoming & Load\";",
            "\tif (test_bit(FAIL_DUP_MOD_BECOMING, &mod_fail->dup_fail_mask))",
            "\t\treturn \"Becoming\";",
            "\tif (test_bit(FAIL_DUP_MOD_LOAD, &mod_fail->dup_fail_mask))",
            "\t\treturn \"Load\";",
            "\treturn \"Bug-on-stats\";",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义模块调试统计相关的原子计数器和链表结构，用于追踪模块加载失败导致的虚拟内存浪费情况，包括不同阶段的内存分配失败统计及重复模块列表管理",
          "similarity": 0.501831591129303
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/module/stats.c",
          "start_line": 411,
          "end_line": 429,
          "content": [
            "static int __init module_stats_init(void)",
            "{",
            "\tmod_debug_add_ulong(total_mod_size);",
            "\tmod_debug_add_ulong(total_text_size);",
            "\tmod_debug_add_ulong(invalid_kread_bytes);",
            "\tmod_debug_add_ulong(invalid_decompress_bytes);",
            "\tmod_debug_add_ulong(invalid_becoming_bytes);",
            "\tmod_debug_add_ulong(invalid_mod_bytes);",
            "",
            "\tmod_debug_add_atomic(modcount);",
            "\tmod_debug_add_atomic(failed_kreads);",
            "\tmod_debug_add_atomic(failed_decompress);",
            "\tmod_debug_add_atomic(failed_becoming);",
            "\tmod_debug_add_atomic(failed_load_modules);",
            "",
            "\tdebugfs_create_file(\"stats\", 0400, mod_debugfs_root, mod_debugfs_root, &fops_mod_stats);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "module_stats_init",
          "description": "初始化模块统计信息到debugfs系统，注册统计文件节点以支持通过/proc/self/debugfs接口访问模块加载统计数据",
          "similarity": 0.46219563484191895
        }
      ]
    },
    {
      "source_file": "kernel/module/main.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:04:44\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\main.c`\n\n---\n\n# `module/main.c` 技术文档\n\n## 1. 文件概述\n\n`module/main.c` 是 Linux 内核模块子系统的核心实现文件，负责模块的加载、卸载、符号解析、内存管理、状态跟踪以及模块间依赖关系的维护。该文件实现了内核模块机制的基础框架，包括模块列表管理、模块内存布局控制、符号查找、模块通知机制、模块引用计数等关键功能，是内核动态加载模块能力的核心支撑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct mod_tree_root mod_tree`**：用于加速地址到模块映射的全局模块地址范围树，包含 `addr_min`/`addr_max`（及可选的 `data_addr_min`/`data_addr_max`）。\n- **`LIST_HEAD(modules)`**：全局模块链表，存储所有已加载模块。\n- **`DEFINE_MUTEX(module_mutex)`**：保护模块列表、模块使用关系及地址边界的关键互斥锁。\n- **`struct symsearch`**：用于描述符号搜索范围，包含符号起止位置、CRC 校验数组及许可证类型。\n- **`struct find_symbol_arg`**：符号查找的参数结构体，用于传递查找目标及接收结果（所有者、符号指针、CRC、许可证等）。\n\n### 主要函数与接口\n\n- **模块注册/注销通知**：\n  - `register_module_notifier()` / `unregister_module_notifier()`：注册/注销模块生命周期事件通知回调。\n- **模块引用管理**：\n  - `strong_try_module_get()`：强引用获取，拒绝处于 `COMING` 状态的模块。\n  - `__module_put_and_kthread_exit()`：专用于内核线程在退出前释放模块引用。\n- **模块内存边界管理**：\n  - `__mod_update_bounds()` / `mod_update_bounds()`：更新全局模块地址范围，用于加速 `__module_address()`。\n- **ELF 节区辅助函数**：\n  - `find_sec()` / `find_any_sec()`：根据名称查找 ELF 节区索引。\n  - `section_addr()` / `section_objs()`：获取节区地址及对象数量。\n- **符号查找**：\n  - `find_symbol()`：在内核及已加载模块中查找导出符号。\n  - `find_exported_symbol_in_section()`：在指定符号段中二分查找符号。\n- **模块状态与安全**：\n  - `add_taint_module()`：为模块添加污点标记（taint flag）。\n- **全局控制**：\n  - `modules_disabled`：通过 `nomodule` 内核参数控制是否禁用模块加载。\n\n### 全局变量与工作队列\n\n- **`init_free_wq`**：用于异步释放模块初始化段（`.init`）内存的工作队列。\n- **`init_free_list`**：待释放初始化内存的无锁链表。\n- **`module_wq`**：等待模块初始化完成的等待队列。\n\n## 3. 关键实现\n\n### 模块地址范围加速\n\n通过 `mod_tree` 全局结构维护所有模块（或核心数据）的最小/最大虚拟地址。`__module_address()` 可先检查目标地址是否落在 `[addr_min, addr_max]` 范围内，若不在则直接返回 `NULL`，避免遍历整个模块链表，显著提升性能。\n\n### 符号查找机制\n\n- 使用 `bsearch()` 在已排序的导出符号表中进行二分查找，时间复杂度为 O(log n)。\n- 支持符号命名空间（namespace）和 GPL 许可证检查：非 GPL 模块无法使用 `GPL_ONLY` 符号。\n- 通过 `symsearch` 数组统一管理内核及各模块的符号段，实现统一查找接口。\n\n### 模块内存管理\n\n- 模块内存按 `mod_mem_type`（如代码、只读数据、可写数据、初始化段等）分类管理。\n- 初始化段（`.init`）在模块初始化成功后通过工作队列异步释放，节省内存。\n- 支持 `CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC` 架构选项，将模块数据段单独纳入地址范围管理。\n\n### 模块状态与引用安全\n\n- `strong_try_module_get()` 确保不会对处于 `MODULE_STATE_COMING`（正在初始化）或 `MODULE_STATE_UNFORMED`（未形成）状态的模块增加引用，防止竞态。\n- `__module_put_and_kthread_exit()` 为内核线程提供安全退出路径，在释放模块引用后终止线程。\n\n### 模块通知机制\n\n基于 `blocking_notifier_chain` 实现模块生命周期事件（如加载、卸载、初始化完成等）的通知，允许其他子系统（如 livepatch、ftrace）监听并响应模块状态变化。\n\n### 构建标识与版本校验\n\n- 通过 `INCLUDE_VERMAGIC` 宏包含模块魔数（vermagic）信息，用于加载时内核版本兼容性检查。\n- 支持 `CONFIG_MODVERSIONS`，在符号查找时返回 CRC 校验值，确保符号 ABI 兼容性。\n\n## 4. 依赖关系\n\n- **架构相关**：\n  - 依赖 `asm/cacheflush.h`、`asm/mmu_context.h`、`asm/sections.h` 等架构头文件，处理指令缓存刷新、内存映射等。\n  - 使用 `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 优化符号字符串存储。\n- **内核子系统**：\n  - **内存管理**：`vmalloc`、`slab` 用于模块内存分配。\n  - **安全机制**：`capability`、`audit`、`module_signature` 用于模块加载权限和签名验证。\n  - **调试与追踪**：`kallsyms`、`trace_events`、`ftrace`、`dynamic_debug`、`debugfs` 提供模块调试支持。\n  - **并发控制**：`RCU`、`mutex`、`percpu` 用于同步。\n  - **文件系统**：`fs.h`、`kernel_read_file.h` 用于从文件加载模块。\n- **内部依赖**：\n  - 依赖同目录下的 `internal.h`，包含模块子系统内部数据结构和函数声明。\n  - 使用 `uapi/linux/module.h` 定义用户空间接口常量。\n\n## 5. 使用场景\n\n- **动态加载内核模块**：通过 `init_module()` 或 `finit_module()` 系统调用加载 `.ko` 文件时，该文件中的函数负责解析 ELF、重定位、符号解析、执行初始化函数。\n- **模块卸载**：通过 `delete_module()` 系统调用卸载模块时，管理模块引用计数、执行清理函数、释放内存。\n- **内核符号解析**：当模块或内核其他部分调用 `symbol_get()` 或通过 `EXPORT_SYMBOL` 机制访问符号时，`find_symbol()` 被调用。\n- **运行时模块查询**：`/proc/modules`、`/sys/module/` 等接口依赖此文件维护的模块列表和状态信息。\n- **内核热补丁（Livepatch）**：依赖模块通知机制和符号查找功能实现函数替换。\n- **内核调试与性能分析**：ftrace、kprobes 等工具依赖模块地址范围和符号信息进行函数跟踪。",
      "similarity": 0.5341050028800964,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/module/main.c",
          "start_line": 460,
          "end_line": 567,
          "content": [
            "bool is_module_percpu_address(unsigned long addr)",
            "{",
            "\treturn __is_module_percpu_address(addr, NULL);",
            "}",
            "static int percpu_modalloc(struct module *mod, struct load_info *info)",
            "{",
            "\t/* UP modules shouldn't have this section: ENOMEM isn't quite right */",
            "\tif (info->sechdrs[info->index.pcpu].sh_size != 0)",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "static inline void percpu_modfree(struct module *mod)",
            "{",
            "}",
            "static unsigned int find_pcpusec(struct load_info *info)",
            "{",
            "\treturn 0;",
            "}",
            "static inline void percpu_modcopy(struct module *mod,",
            "\t\t\t\t  const void *from, unsigned long size)",
            "{",
            "\t/* pcpusec should be 0, and size of that section should be 0. */",
            "\tBUG_ON(size != 0);",
            "}",
            "bool is_module_percpu_address(unsigned long addr)",
            "{",
            "\treturn false;",
            "}",
            "bool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)",
            "{",
            "\treturn false;",
            "}",
            "static int module_unload_init(struct module *mod)",
            "{",
            "\t/*",
            "\t * Initialize reference counter to MODULE_REF_BASE.",
            "\t * refcnt == 0 means module is going.",
            "\t */",
            "\tatomic_set(&mod->refcnt, MODULE_REF_BASE);",
            "",
            "\tINIT_LIST_HEAD(&mod->source_list);",
            "\tINIT_LIST_HEAD(&mod->target_list);",
            "",
            "\t/* Hold reference count during initialization. */",
            "\tatomic_inc(&mod->refcnt);",
            "",
            "\treturn 0;",
            "}",
            "static int already_uses(struct module *a, struct module *b)",
            "{",
            "\tstruct module_use *use;",
            "",
            "\tlist_for_each_entry(use, &b->source_list, source_list) {",
            "\t\tif (use->source == a)",
            "\t\t\treturn 1;",
            "\t}",
            "\tpr_debug(\"%s does not use %s!\\n\", a->name, b->name);",
            "\treturn 0;",
            "}",
            "static int add_module_usage(struct module *a, struct module *b)",
            "{",
            "\tstruct module_use *use;",
            "",
            "\tpr_debug(\"Allocating new usage for %s.\\n\", a->name);",
            "\tuse = kmalloc(sizeof(*use), GFP_ATOMIC);",
            "\tif (!use)",
            "\t\treturn -ENOMEM;",
            "",
            "\tuse->source = a;",
            "\tuse->target = b;",
            "\tlist_add(&use->source_list, &b->source_list);",
            "\tlist_add(&use->target_list, &a->target_list);",
            "\treturn 0;",
            "}",
            "static int ref_module(struct module *a, struct module *b)",
            "{",
            "\tint err;",
            "",
            "\tif (b == NULL || already_uses(a, b))",
            "\t\treturn 0;",
            "",
            "\t/* If module isn't available, we fail. */",
            "\terr = strong_try_module_get(b);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = add_module_usage(a, b);",
            "\tif (err) {",
            "\t\tmodule_put(b);",
            "\t\treturn err;",
            "\t}",
            "\treturn 0;",
            "}",
            "static void module_unload_free(struct module *mod)",
            "{",
            "\tstruct module_use *use, *tmp;",
            "",
            "\tmutex_lock(&module_mutex);",
            "\tlist_for_each_entry_safe(use, tmp, &mod->target_list, target_list) {",
            "\t\tstruct module *i = use->target;",
            "\t\tpr_debug(\"%s unusing %s\\n\", mod->name, i->name);",
            "\t\tmodule_put(i);",
            "\t\tlist_del(&use->source_list);",
            "\t\tlist_del(&use->target_list);",
            "\t\tkfree(use);",
            "\t}",
            "\tmutex_unlock(&module_mutex);",
            "}"
          ],
          "function_name": "is_module_percpu_address, percpu_modalloc, percpu_modfree, find_pcpusec, percpu_modcopy, is_module_percpu_address, __is_module_percpu_address, module_unload_init, already_uses, add_module_usage, ref_module, module_unload_free",
          "description": "包含模块卸载初始化逻辑，管理模块间依赖关系（通过module_use结构），实现模块引用计数调整及依赖链清理，在模块卸载时安全解除其他模块对其的依赖。",
          "similarity": 0.5516014099121094
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/module/main.c",
          "start_line": 1071,
          "end_line": 1218,
          "content": [
            "static int verify_namespace_is_imported(const struct load_info *info,",
            "\t\t\t\t\tconst struct kernel_symbol *sym,",
            "\t\t\t\t\tstruct module *mod)",
            "{",
            "\tconst char *namespace;",
            "\tchar *imported_namespace;",
            "",
            "\tnamespace = kernel_symbol_namespace(sym);",
            "\tif (namespace && namespace[0]) {",
            "\t\tfor_each_modinfo_entry(imported_namespace, info, \"import_ns\") {",
            "\t\t\tif (strcmp(namespace, imported_namespace) == 0)",
            "\t\t\t\treturn 0;",
            "\t\t}",
            "#ifdef CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS",
            "\t\tpr_warn(",
            "#else",
            "\t\tpr_err(",
            "#endif",
            "\t\t\t\"%s: module uses symbol (%s) from namespace %s, but does not import it.\\n\",",
            "\t\t\tmod->name, kernel_symbol_name(sym), namespace);",
            "#ifndef CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS",
            "\t\treturn -EINVAL;",
            "#endif",
            "\t}",
            "\treturn 0;",
            "}",
            "static bool inherit_taint(struct module *mod, struct module *owner, const char *name)",
            "{",
            "\tif (!owner || !test_bit(TAINT_PROPRIETARY_MODULE, &owner->taints))",
            "\t\treturn true;",
            "",
            "\tif (mod->using_gplonly_symbols) {",
            "\t\tpr_err(\"%s: module using GPL-only symbols uses symbols %s from proprietary module %s.\\n\",",
            "\t\t\tmod->name, name, owner->name);",
            "\t\treturn false;",
            "\t}",
            "",
            "\tif (!test_bit(TAINT_PROPRIETARY_MODULE, &mod->taints)) {",
            "\t\tpr_warn(\"%s: module uses symbols %s from proprietary module %s, inheriting taint.\\n\",",
            "\t\t\tmod->name, name, owner->name);",
            "\t\tset_bit(TAINT_PROPRIETARY_MODULE, &mod->taints);",
            "\t}",
            "\treturn true;",
            "}",
            "void __weak module_memfree(void *module_region)",
            "{",
            "\t/*",
            "\t * This memory may be RO, and freeing RO memory in an interrupt is not",
            "\t * supported by vmalloc.",
            "\t */",
            "\tWARN_ON(in_interrupt());",
            "\tvfree(module_region);",
            "}",
            "void __weak module_arch_cleanup(struct module *mod)",
            "{",
            "}",
            "void __weak module_arch_freeing_init(struct module *mod)",
            "{",
            "}",
            "static bool mod_mem_use_vmalloc(enum mod_mem_type type)",
            "{",
            "\treturn IS_ENABLED(CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC) &&",
            "\t\tmod_mem_type_is_core_data(type);",
            "}",
            "static void module_memory_free(void *ptr, enum mod_mem_type type,",
            "\t\t\t       bool unload_codetags)",
            "{",
            "\tif (!unload_codetags && mod_mem_type_is_core_data(type))",
            "\t\treturn;",
            "",
            "\tif (mod_mem_use_vmalloc(type))",
            "\t\tvfree(ptr);",
            "\telse",
            "\t\tmodule_memfree(ptr);",
            "}",
            "static void free_mod_mem(struct module *mod, bool unload_codetags)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tstruct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (type == MOD_DATA)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Free lock-classes; relies on the preceding sync_rcu(). */",
            "\t\tlockdep_free_key_range(mod_mem->base, mod_mem->size);",
            "\t\tif (mod_mem->size)",
            "\t\t\tmodule_memory_free(mod_mem->base, type,",
            "\t\t\t\t\t   unload_codetags);",
            "\t}",
            "",
            "\t/* MOD_DATA hosts mod, so free it at last */",
            "\tlockdep_free_key_range(mod->mem[MOD_DATA].base, mod->mem[MOD_DATA].size);",
            "\tmodule_memory_free(mod->mem[MOD_DATA].base, MOD_DATA, unload_codetags);",
            "}",
            "static void free_module(struct module *mod)",
            "{",
            "\tbool unload_codetags;",
            "",
            "\ttrace_module_free(mod);",
            "",
            "\tunload_codetags = codetag_unload_module(mod);",
            "\tif (!unload_codetags)",
            "\t\tpr_warn(\"%s: memory allocation(s) from the module still alive, cannot unload cleanly\\n\",",
            "\t\t\tmod->name);",
            "",
            "\tmod_sysfs_teardown(mod);",
            "",
            "\t/*",
            "\t * We leave it in list to prevent duplicate loads, but make sure",
            "\t * that noone uses it while it's being deconstructed.",
            "\t */",
            "\tmutex_lock(&module_mutex);",
            "\tmod->state = MODULE_STATE_UNFORMED;",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\t/* Arch-specific cleanup. */",
            "\tmodule_arch_cleanup(mod);",
            "",
            "\t/* Module unload stuff */",
            "\tmodule_unload_free(mod);",
            "",
            "\t/* Free any allocated parameters. */",
            "\tdestroy_params(mod->kp, mod->num_kp);",
            "",
            "\tif (is_livepatch_module(mod))",
            "\t\tfree_module_elf(mod);",
            "",
            "\t/* Now we can delete it from the lists */",
            "\tmutex_lock(&module_mutex);",
            "\t/* Unlink carefully: kallsyms could be walking list. */",
            "\tlist_del_rcu(&mod->list);",
            "\tmod_tree_remove(mod);",
            "\t/* Remove this module from bug list, this uses list_del_rcu */",
            "\tmodule_bug_cleanup(mod);",
            "\t/* Wait for RCU-sched synchronizing before releasing mod->list and buglist. */",
            "\tsynchronize_rcu();",
            "\tif (try_add_tainted_module(mod))",
            "\t\tpr_err(\"%s: adding tainted module to the unloaded tainted modules list failed.\\n\",",
            "\t\t       mod->name);",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\t/* This may be empty, but that's OK */",
            "\tmodule_arch_freeing_init(mod);",
            "\tkfree(mod->args);",
            "\tpercpu_modfree(mod);",
            "",
            "\tfree_mod_mem(mod, unload_codetags);",
            "}"
          ],
          "function_name": "verify_namespace_is_imported, inherit_taint, module_memfree, module_arch_cleanup, module_arch_freeing_init, mod_mem_use_vmalloc, module_memory_free, free_mod_mem, free_module",
          "description": "实现模块符号命名空间验证(verify_namespace_is_imported)、污点继承逻辑(herit_taint)、内存释放(module_memory_free/free_mod_mem)及架构特定清理(module_arch_cleanup/module_arch_freeing_init)，包含弱符号声明供架构扩展。",
          "similarity": 0.5482421517372131
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/main.c",
          "start_line": 1,
          "end_line": 95,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Copyright (C) 2002 Richard Henderson",
            " * Copyright (C) 2001 Rusty Russell, 2002, 2010 Rusty Russell IBM.",
            " * Copyright (C) 2023 Luis Chamberlain <mcgrof@kernel.org>",
            " */",
            "",
            "#define INCLUDE_VERMAGIC",
            "",
            "#include <linux/export.h>",
            "#include <linux/extable.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buildid.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kstrtox.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/elf.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/cpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/notifier.h>",
            "#include <linux/sched.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/license.h>",
            "#include <asm/sections.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/async.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/pfn.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/audit.h>",
            "#include <linux/cfi.h>",
            "#include <linux/codetag.h>",
            "#include <linux/debugfs.h>",
            "#include <uapi/linux/module.h>",
            "#include \"internal.h\"",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/module.h>",
            "",
            "/*",
            " * Mutex protects:",
            " * 1) List of modules (also safely readable with preempt_disable),",
            " * 2) module_use links,",
            " * 3) mod_tree.addr_min/mod_tree.addr_max.",
            " * (delete and add uses RCU list operations).",
            " */",
            "DEFINE_MUTEX(module_mutex);",
            "LIST_HEAD(modules);",
            "",
            "/* Work queue for freeing init sections in success case */",
            "static void do_free_init(struct work_struct *w);",
            "static DECLARE_WORK(init_free_wq, do_free_init);",
            "static LLIST_HEAD(init_free_list);",
            "",
            "struct mod_tree_root mod_tree __cacheline_aligned = {",
            "\t.addr_min = -1UL,",
            "};",
            "",
            "struct symsearch {",
            "\tconst struct kernel_symbol *start, *stop;",
            "\tconst s32 *crcs;",
            "\tenum mod_license license;",
            "};",
            "",
            "/*",
            " * Bounds of module memory, for speeding up __module_address.",
            " * Protected by module_mutex.",
            " */"
          ],
          "function_name": null,
          "description": "定义模块加载器的基础结构，包括模块互斥锁（module_mutex）、模块链表（modules）及用于记录模块内存范围的mod_tree结构体，为后续模块管理和地址查询提供数据支撑。",
          "similarity": 0.5472000241279602
        },
        {
          "chunk_id": 16,
          "file_path": "kernel/module/main.c",
          "start_line": 3116,
          "end_line": 3223,
          "content": [
            "static bool idempotent(struct idempotent *u, const void *cookie)",
            "{",
            "\tint hash = hash_ptr(cookie, IDEM_HASH_BITS);",
            "\tstruct hlist_head *head = idem_hash + hash;",
            "\tstruct idempotent *existing;",
            "\tbool first;",
            "",
            "\tu->ret = -EINTR;",
            "\tu->cookie = cookie;",
            "\tinit_completion(&u->complete);",
            "",
            "\tspin_lock(&idem_lock);",
            "\tfirst = true;",
            "\thlist_for_each_entry(existing, head, entry) {",
            "\t\tif (existing->cookie != cookie)",
            "\t\t\tcontinue;",
            "\t\tfirst = false;",
            "\t\tbreak;",
            "\t}",
            "\thlist_add_head(&u->entry, idem_hash + hash);",
            "\tspin_unlock(&idem_lock);",
            "",
            "\treturn !first;",
            "}",
            "static int idempotent_complete(struct idempotent *u, int ret)",
            "{",
            "\tconst void *cookie = u->cookie;",
            "\tint hash = hash_ptr(cookie, IDEM_HASH_BITS);",
            "\tstruct hlist_head *head = idem_hash + hash;",
            "\tstruct hlist_node *next;",
            "\tstruct idempotent *pos;",
            "",
            "\tspin_lock(&idem_lock);",
            "\thlist_for_each_entry_safe(pos, next, head, entry) {",
            "\t\tif (pos->cookie != cookie)",
            "\t\t\tcontinue;",
            "\t\thlist_del_init(&pos->entry);",
            "\t\tpos->ret = ret;",
            "\t\tcomplete(&pos->complete);",
            "\t}",
            "\tspin_unlock(&idem_lock);",
            "\treturn ret;",
            "}",
            "static int idempotent_wait_for_completion(struct idempotent *u)",
            "{",
            "\tif (wait_for_completion_interruptible(&u->complete)) {",
            "\t\tspin_lock(&idem_lock);",
            "\t\tif (!hlist_unhashed(&u->entry))",
            "\t\t\thlist_del(&u->entry);",
            "\t\tspin_unlock(&idem_lock);",
            "\t}",
            "\treturn u->ret;",
            "}",
            "static int init_module_from_file(struct file *f, const char __user * uargs, int flags)",
            "{",
            "\tstruct load_info info = { };",
            "\tvoid *buf = NULL;",
            "\tint len;",
            "",
            "\tlen = kernel_read_file(f, 0, &buf, INT_MAX, NULL, READING_MODULE);",
            "\tif (len < 0) {",
            "\t\tmod_stat_inc(&failed_kreads);",
            "\t\treturn len;",
            "\t}",
            "",
            "\tif (flags & MODULE_INIT_COMPRESSED_FILE) {",
            "\t\tint err = module_decompress(&info, buf, len);",
            "\t\tvfree(buf); /* compressed data is no longer needed */",
            "\t\tif (err) {",
            "\t\t\tmod_stat_inc(&failed_decompress);",
            "\t\t\tmod_stat_add_long(len, &invalid_decompress_bytes);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t} else {",
            "\t\tinfo.hdr = buf;",
            "\t\tinfo.len = len;",
            "\t}",
            "",
            "\treturn load_module(&info, uargs, flags);",
            "}",
            "static int idempotent_init_module(struct file *f, const char __user * uargs, int flags)",
            "{",
            "\tstruct idempotent idem;",
            "",
            "\tif (!(f->f_mode & FMODE_READ))",
            "\t\treturn -EBADF;",
            "",
            "\t/* Are we the winners of the race and get to do this? */",
            "\tif (!idempotent(&idem, file_inode(f))) {",
            "\t\tint ret = init_module_from_file(f, uargs, flags);",
            "\t\treturn idempotent_complete(&idem, ret);",
            "\t}",
            "",
            "\t/*",
            "\t * Somebody else won the race and is loading the module.",
            "\t */",
            "\treturn idempotent_wait_for_completion(&idem);",
            "}",
            "bool is_module_address(unsigned long addr)",
            "{",
            "\tbool ret;",
            "",
            "\tpreempt_disable();",
            "\tret = __module_address(addr) != NULL;",
            "\tpreempt_enable();",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "idempotent, idempotent_complete, idempotent_wait_for_completion, init_module_from_file, idempotent_init_module, is_module_address",
          "description": "idempotent 系列函数实现幂等性控制，通过哈希表防止重复模块加载；init_module_from_file 解析模块文件并调用load_module加载",
          "similarity": 0.5342093110084534
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/module/main.c",
          "start_line": 1459,
          "end_line": 1571,
          "content": [
            "static int apply_relocations(struct module *mod, const struct load_info *info)",
            "{",
            "\tunsigned int i;",
            "\tint err = 0;",
            "",
            "\t/* Now do relocations. */",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tunsigned int infosec = info->sechdrs[i].sh_info;",
            "",
            "\t\t/* Not a valid relocation section? */",
            "\t\tif (infosec >= info->hdr->e_shnum)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Don't bother with non-allocated sections */",
            "\t\tif (!(info->sechdrs[infosec].sh_flags & SHF_ALLOC))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (info->sechdrs[i].sh_flags & SHF_RELA_LIVEPATCH)",
            "\t\t\terr = klp_apply_section_relocs(mod, info->sechdrs,",
            "\t\t\t\t\t\t       info->secstrings,",
            "\t\t\t\t\t\t       info->strtab,",
            "\t\t\t\t\t\t       info->index.sym, i,",
            "\t\t\t\t\t\t       NULL);",
            "\t\telse if (info->sechdrs[i].sh_type == SHT_REL)",
            "\t\t\terr = apply_relocate(info->sechdrs, info->strtab,",
            "\t\t\t\t\t     info->index.sym, i, mod);",
            "\t\telse if (info->sechdrs[i].sh_type == SHT_RELA)",
            "\t\t\terr = apply_relocate_add(info->sechdrs, info->strtab,",
            "\t\t\t\t\t\t info->index.sym, i, mod);",
            "\t\tif (err < 0)",
            "\t\t\tbreak;",
            "\t}",
            "\treturn err;",
            "}",
            "unsigned int __weak arch_mod_section_prepend(struct module *mod,",
            "\t\t\t\t\t     unsigned int section)",
            "{",
            "\t/* default implementation just returns zero */",
            "\treturn 0;",
            "}",
            "long module_get_offset_and_type(struct module *mod, enum mod_mem_type type,",
            "\t\t\t\tElf_Shdr *sechdr, unsigned int section)",
            "{",
            "\tlong offset;",
            "\tlong mask = ((unsigned long)(type) & SH_ENTSIZE_TYPE_MASK) << SH_ENTSIZE_TYPE_SHIFT;",
            "",
            "\tmod->mem[type].size += arch_mod_section_prepend(mod, section);",
            "\toffset = ALIGN(mod->mem[type].size, sechdr->sh_addralign ?: 1);",
            "\tmod->mem[type].size = offset + sechdr->sh_size;",
            "",
            "\tWARN_ON_ONCE(offset & mask);",
            "\treturn offset | mask;",
            "}",
            "bool module_init_layout_section(const char *sname)",
            "{",
            "#ifndef CONFIG_MODULE_UNLOAD",
            "\tif (module_exit_section(sname))",
            "\t\treturn true;",
            "#endif",
            "\treturn module_init_section(sname);",
            "}",
            "static void __layout_sections(struct module *mod, struct load_info *info, bool is_init)",
            "{",
            "\tunsigned int m, i;",
            "",
            "\tstatic const unsigned long masks[][2] = {",
            "\t\t/*",
            "\t\t * NOTE: all executable code must be the first section",
            "\t\t * in this array; otherwise modify the text_size",
            "\t\t * finder in the two loops below",
            "\t\t */",
            "\t\t{ SHF_EXECINSTR | SHF_ALLOC, ARCH_SHF_SMALL },",
            "\t\t{ SHF_ALLOC, SHF_WRITE | ARCH_SHF_SMALL },",
            "\t\t{ SHF_RO_AFTER_INIT | SHF_ALLOC, ARCH_SHF_SMALL },",
            "\t\t{ SHF_WRITE | SHF_ALLOC, ARCH_SHF_SMALL },",
            "\t\t{ ARCH_SHF_SMALL | SHF_ALLOC, 0 }",
            "\t};",
            "\tstatic const int core_m_to_mem_type[] = {",
            "\t\tMOD_TEXT,",
            "\t\tMOD_RODATA,",
            "\t\tMOD_RO_AFTER_INIT,",
            "\t\tMOD_DATA,",
            "\t\tMOD_DATA,",
            "\t};",
            "\tstatic const int init_m_to_mem_type[] = {",
            "\t\tMOD_INIT_TEXT,",
            "\t\tMOD_INIT_RODATA,",
            "\t\tMOD_INVALID,",
            "\t\tMOD_INIT_DATA,",
            "\t\tMOD_INIT_DATA,",
            "\t};",
            "",
            "\tfor (m = 0; m < ARRAY_SIZE(masks); ++m) {",
            "\t\tenum mod_mem_type type = is_init ? init_m_to_mem_type[m] : core_m_to_mem_type[m];",
            "",
            "\t\tfor (i = 0; i < info->hdr->e_shnum; ++i) {",
            "\t\t\tElf_Shdr *s = &info->sechdrs[i];",
            "\t\t\tconst char *sname = info->secstrings + s->sh_name;",
            "",
            "\t\t\tif ((s->sh_flags & masks[m][0]) != masks[m][0]",
            "\t\t\t    || (s->sh_flags & masks[m][1])",
            "\t\t\t    || s->sh_entsize != ~0UL",
            "\t\t\t    || is_init != module_init_layout_section(sname))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tif (WARN_ON_ONCE(type == MOD_INVALID))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\ts->sh_entsize = module_get_offset_and_type(mod, type, s, i);",
            "\t\t\tpr_debug(\"\\t%s\\n\", sname);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "apply_relocations, arch_mod_section_prepend, module_get_offset_and_type, module_init_layout_section, __layout_sections",
          "description": "应用重定位信息(apply_relocations)、节偏移计算(module_get_offset_and_type)及内存布局(__layout_sections)，通过预置的节类型掩码(masks)将ELF节头按执行代码/可写数据等类型分组，建立模块内存区域映射关系。",
          "similarity": 0.5199905633926392
        }
      ]
    }
  ]
}