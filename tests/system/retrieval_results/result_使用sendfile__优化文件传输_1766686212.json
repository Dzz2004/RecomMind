{
  "query": "使用sendfile()优化文件传输",
  "timestamp": "2025-12-26 02:10:12",
  "retrieved_files": [
    {
      "source_file": "mm/swapfile.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:28:37\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `swapfile.c`\n\n---\n\n# swapfile.c 技术文档\n\n## 1. 文件概述\n\n`swapfile.c` 是 Linux 内核内存管理子系统中负责交换（swap）功能的核心实现文件之一。该文件主要实现了对交换文件（swap file）和交换分区（swap partition）的管理，包括交换空间的分配、释放、回收、状态跟踪以及与页缓存（page cache）和反向映射（rmap）系统的集成。它为虚拟内存子系统提供底层支持，使得在物理内存不足时可以将不活跃的内存页换出到磁盘上的交换区域，并在需要时换入。\n\n## 2. 核心功能\n\n### 主要全局数据结构\n- `swap_info[MAX_SWAPFILES]`：存储所有已激活交换设备/文件的元数据（`struct swap_info_struct`）。\n- `swap_active_head`：按优先级排序的活跃交换设备链表（受 `swap_lock` 保护）。\n- `swap_avail_heads`：按优先级排序的**可用**（未满）交换设备链表（受 `swap_avail_lock` 保护），用于高效分配交换槽。\n- `nr_swap_pages` / `total_swap_pages`：全局交换页计数器，分别表示当前可用和总交换页数。\n- `swapon_mutex`：用于序列化 `swapon`/`swapoff` 系统调用的互斥锁。\n\n### 关键函数\n- `__try_to_reclaim_swap()`：尝试回收指定交换槽对应的内存页，支持多种回收策略（强制回收、无映射回收、内存压力回收等）。\n- `swap_count_continued()` / `free_swap_count_continuations()`：处理交换引用计数溢出的延续机制。\n- `swap_entry_range_free()` / `swap_range_alloc()`：批量释放或分配交换槽。\n- `folio_swapcache_freeable()`：判断一个 folio 是否可以从交换缓存中安全移除。\n- `lock_cluster_or_swap_info()` / `unlock_cluster_or_swap_info()`：用于在交换位图操作时获取适当的锁（集群锁或整个交换设备锁）。\n- `discard_swap()`：通知底层块设备丢弃旧的交换内容，用于 SSD 等设备的 TRIM/DISCARD 优化。\n\n### 辅助函数与宏\n- `swap_type_to_swap_info()`：根据交换类型索引获取对应的 `swap_info_struct`。\n- `swap_count()`：从交换位图项中提取实际的引用计数值。\n- `TTRS_*` 宏：定义交换回收的不同触发条件标志。\n\n## 3. 关键实现\n\n### 交换槽分配与回收\n- 使用位图（`swap_map`）跟踪每个交换槽的使用状态和引用计数。\n- 引用计数超过 254 时，使用 `COUNT_CONTINUED` 标志和额外的数据结构记录溢出部分。\n- 通过 `swap_avail_heads` 链表优化分配路径，仅遍历未满的交换设备，避免检查已满设备。\n\n### 交换缓存（Swap Cache）集成\n- 换出的页会保留在交换缓存（基于 `address_space` 的 radix tree）中，避免重复 I/O。\n- `__try_to_reclaim_swap()` 在满足条件时（如无页表映射、内存压力大）可主动删除缓存项并释放交换槽。\n- 支持直接回收模式（`TTRS_DIRECT`），绕过交换槽缓存，立即释放底层交换槽。\n\n### 并发控制\n- 全局 `swap_lock` 保护交换设备列表和全局计数器。\n- 每个交换设备有独立的自旋锁（`si->lock`）保护其位图和状态。\n- 引入 `swap_avail_lock` 解决交换设备“满/不满”状态切换时的锁序问题。\n- 使用 RCU 机制安全读取 `swap_info[]` 数组。\n\n### 大页（Huge Page）支持\n- 函数如 `folio_nr_pages()` 和 `swap_entry_range_free()` 支持跨多个连续交换槽的大页操作。\n- 交换槽分配和释放以 folio 为单位处理，确保大页的原子性。\n\n### 设备优化\n- `discard_swap()` 在激活交换设备时调用，向 SSD 发送 DISCARD 命令，提升性能和寿命。\n- 支持 zswap（压缩交换缓存），在直接释放交换槽时调用 `zswap_invalidate()`。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`, `<linux/vmalloc.h>`, `<linux/pagemap.h>` 等提供的页分配、地址空间管理功能。\n- **虚拟内存子系统**：与 `vmscan.c`（页面回收）、`rmap.c`（反向映射）、`memory.c` 紧密协作。\n- **文件系统层**：通过 `shmem_fs.h` 和 `namei.h` 支持基于文件的交换（而非仅分区）。\n- **块设备层**：通过 `blkdev.h` 与底层存储交互，支持 DISCARD 操作。\n- **资源控制**：集成 `memcontrol.h`（cgroup 内存控制器）和 `blk-cgroup.h`（块设备 cgroup）。\n- **安全模块**：通过 `security.h` 钩子进行权限检查。\n- **其他子系统**：依赖 `ksm`（内存合并）、`oom`（内存耗尽处理）、`suspend`（休眠）等。\n\n## 5. 使用场景\n\n- **内存压力下的页面回收**：当系统内存不足时，`kswapd` 或直接回收路径调用 `__try_to_reclaim_swap()` 释放交换槽。\n- **交换空间激活/停用**：`sys_swapon()` / `sys_swapoff()` 系统调用通过此文件初始化或清理交换设备。\n- **交换槽分配**：`folio_alloc_swap()` 在需要换出页面时从此文件获取空闲交换槽。\n- **交换缓存管理**：当页面被换入或显式释放时，更新交换缓存和位图状态。\n- **系统休眠（Suspend-to-Disk）**：休眠过程大量使用交换机制保存内存镜像。\n- **性能监控与调优**：`/proc/swaps` 和 `/proc/vmstat` 通过此文件暴露交换统计信息。\n- **容器内存隔离**：配合 memcg 实现 per-cgroup 的交换限制和统计。",
      "similarity": 0.561151921749115,
      "chunks": [
        {
          "chunk_id": 17,
          "file_path": "mm/swapfile.c",
          "start_line": 2916,
          "end_line": 3075,
          "content": [
            "static void swap_stop(struct seq_file *swap, void *v)",
            "{",
            "\tmutex_unlock(&swapon_mutex);",
            "}",
            "static int swap_show(struct seq_file *swap, void *v)",
            "{",
            "\tstruct swap_info_struct *si = v;",
            "\tstruct file *file;",
            "\tint len;",
            "\tunsigned long bytes, inuse;",
            "",
            "\tif (si == SEQ_START_TOKEN) {",
            "\t\tseq_puts(swap, \"Filename\\t\\t\\t\\tType\\t\\tSize\\t\\tUsed\\t\\tPriority\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tbytes = K(si->pages);",
            "\tinuse = K(READ_ONCE(si->inuse_pages));",
            "",
            "\tfile = si->swap_file;",
            "\tlen = seq_file_path(swap, file, \" \\t\\n\\\\\");",
            "\tseq_printf(swap, \"%*s%s\\t%lu\\t%s%lu\\t%s%d\\n\",",
            "\t\t\tlen < 40 ? 40 - len : 1, \" \",",
            "\t\t\tS_ISBLK(file_inode(file)->i_mode) ?",
            "\t\t\t\t\"partition\" : \"file\\t\",",
            "\t\t\tbytes, bytes < 10000000 ? \"\\t\" : \"\",",
            "\t\t\tinuse, inuse < 10000000 ? \"\\t\" : \"\",",
            "\t\t\tsi->prio);",
            "\treturn 0;",
            "}",
            "static int swaps_open(struct inode *inode, struct file *file)",
            "{",
            "\tstruct seq_file *seq;",
            "\tint ret;",
            "",
            "\tret = seq_open(file, &swaps_op);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tseq = file->private_data;",
            "\tseq->poll_event = atomic_read(&proc_poll_event);",
            "\treturn 0;",
            "}",
            "static int __init procswaps_init(void)",
            "{",
            "\tproc_create(\"swaps\", 0, NULL, &swaps_proc_ops);",
            "\treturn 0;",
            "}",
            "static int __init max_swapfiles_check(void)",
            "{",
            "\tMAX_SWAPFILES_CHECK();",
            "\treturn 0;",
            "}",
            "static int claim_swapfile(struct swap_info_struct *p, struct inode *inode)",
            "{",
            "\tint error;",
            "",
            "\tif (S_ISBLK(inode->i_mode)) {",
            "\t\tp->bdev_handle = bdev_open_by_dev(inode->i_rdev,",
            "\t\t\t\tBLK_OPEN_READ | BLK_OPEN_WRITE, p, NULL);",
            "\t\tif (IS_ERR(p->bdev_handle)) {",
            "\t\t\terror = PTR_ERR(p->bdev_handle);",
            "\t\t\tp->bdev_handle = NULL;",
            "\t\t\treturn error;",
            "\t\t}",
            "\t\tp->bdev = p->bdev_handle->bdev;",
            "\t\tp->old_block_size = block_size(p->bdev);",
            "\t\terror = set_blocksize(p->bdev, PAGE_SIZE);",
            "\t\tif (error < 0)",
            "\t\t\treturn error;",
            "\t\t/*",
            "\t\t * Zoned block devices contain zones that have a sequential",
            "\t\t * write only restriction.  Hence zoned block devices are not",
            "\t\t * suitable for swapping.  Disallow them here.",
            "\t\t */",
            "\t\tif (bdev_is_zoned(p->bdev))",
            "\t\t\treturn -EINVAL;",
            "\t\tp->flags |= SWP_BLKDEV;",
            "\t} else if (S_ISREG(inode->i_mode)) {",
            "\t\tp->bdev = inode->i_sb->s_bdev;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "unsigned long generic_max_swapfile_size(void)",
            "{",
            "\treturn swp_offset(pte_to_swp_entry(",
            "\t\t\tswp_entry_to_pte(swp_entry(0, ~0UL)))) + 1;",
            "}",
            "__weak unsigned long arch_max_swapfile_size(void)",
            "{",
            "\treturn generic_max_swapfile_size();",
            "}",
            "static unsigned long read_swap_header(struct swap_info_struct *p,",
            "\t\t\t\t\tunion swap_header *swap_header,",
            "\t\t\t\t\tstruct inode *inode)",
            "{",
            "\tint i;",
            "\tunsigned long maxpages;",
            "\tunsigned long swapfilepages;",
            "\tunsigned long last_page;",
            "",
            "\tif (memcmp(\"SWAPSPACE2\", swap_header->magic.magic, 10)) {",
            "\t\tpr_err(\"Unable to find swap-space signature\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/* swap partition endianness hack... */",
            "\tif (swab32(swap_header->info.version) == 1) {",
            "\t\tswab32s(&swap_header->info.version);",
            "\t\tswab32s(&swap_header->info.last_page);",
            "\t\tswab32s(&swap_header->info.nr_badpages);",
            "\t\tif (swap_header->info.nr_badpages > MAX_SWAP_BADPAGES)",
            "\t\t\treturn 0;",
            "\t\tfor (i = 0; i < swap_header->info.nr_badpages; i++)",
            "\t\t\tswab32s(&swap_header->info.badpages[i]);",
            "\t}",
            "\t/* Check the swap header's sub-version */",
            "\tif (swap_header->info.version != 1) {",
            "\t\tpr_warn(\"Unable to handle swap header version %d\\n\",",
            "\t\t\tswap_header->info.version);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tp->lowest_bit  = 1;",
            "\tp->cluster_next = 1;",
            "\tp->cluster_nr = 0;",
            "",
            "\tmaxpages = swapfile_maximum_size;",
            "\tlast_page = swap_header->info.last_page;",
            "\tif (!last_page) {",
            "\t\tpr_warn(\"Empty swap-file\\n\");",
            "\t\treturn 0;",
            "\t}",
            "\tif (last_page > maxpages) {",
            "\t\tpr_warn(\"Truncating oversized swap area, only using %luk out of %luk\\n\",",
            "\t\t\tK(maxpages), K(last_page));",
            "\t}",
            "\tif (maxpages > last_page) {",
            "\t\tmaxpages = last_page + 1;",
            "\t\t/* p->max is an unsigned int: don't overflow it */",
            "\t\tif ((unsigned int)maxpages == 0)",
            "\t\t\tmaxpages = UINT_MAX;",
            "\t}",
            "\tp->highest_bit = maxpages - 1;",
            "",
            "\tif (!maxpages)",
            "\t\treturn 0;",
            "\tswapfilepages = i_size_read(inode) >> PAGE_SHIFT;",
            "\tif (swapfilepages && maxpages > swapfilepages) {",
            "\t\tpr_warn(\"Swap area shorter than signature indicates\\n\");",
            "\t\treturn 0;",
            "\t}",
            "\tif (swap_header->info.nr_badpages && S_ISREG(inode->i_mode))",
            "\t\treturn 0;",
            "\tif (swap_header->info.nr_badpages > MAX_SWAP_BADPAGES)",
            "\t\treturn 0;",
            "",
            "\treturn maxpages;",
            "}"
          ],
          "function_name": "swap_stop, swap_show, swaps_open, procswaps_init, max_swapfiles_check, claim_swapfile, generic_max_swapfile_size, arch_max_swapfile_size, read_swap_header",
          "description": "该代码块实现了交换设备的控制接口，包含停止交换设备显示、展示交换设备信息、打开交换设备查看接口、初始化proc文件系统以及处理交换文件验证等逻辑。claim_swapfile函数用于绑定交换文件并进行有效性检查，read_swap_header解析交换分区头部信息。",
          "similarity": 0.54539954662323
        },
        {
          "chunk_id": 3,
          "file_path": "mm/swapfile.c",
          "start_line": 489,
          "end_line": 603,
          "content": [
            "static void swap_discard_work(struct work_struct *work)",
            "{",
            "\tstruct swap_info_struct *si;",
            "",
            "\tsi = container_of(work, struct swap_info_struct, discard_work);",
            "",
            "\tspin_lock(&si->lock);",
            "\tswap_do_scheduled_discard(si);",
            "\tspin_unlock(&si->lock);",
            "}",
            "static void swap_users_ref_free(struct percpu_ref *ref)",
            "{",
            "\tstruct swap_info_struct *si;",
            "",
            "\tsi = container_of(ref, struct swap_info_struct, users);",
            "\tcomplete(&si->comp);",
            "}",
            "static void free_cluster(struct swap_info_struct *si, struct swap_cluster_info *ci)",
            "{",
            "\tVM_BUG_ON(ci->count != 0);",
            "\tlockdep_assert_held(&si->lock);",
            "\tlockdep_assert_held(&ci->lock);",
            "",
            "\tif (ci->flags & CLUSTER_FLAG_FRAG)",
            "\t\tsi->frag_cluster_nr[ci->order]--;",
            "",
            "\t/*",
            "\t * If the swap is discardable, prepare discard the cluster",
            "\t * instead of free it immediately. The cluster will be freed",
            "\t * after discard.",
            "\t */",
            "\tif ((si->flags & (SWP_WRITEOK | SWP_PAGE_DISCARD)) ==",
            "\t    (SWP_WRITEOK | SWP_PAGE_DISCARD)) {",
            "\t\tswap_cluster_schedule_discard(si, ci);",
            "\t\treturn;",
            "\t}",
            "",
            "\t__free_cluster(si, ci);",
            "}",
            "static void inc_cluster_info_page(struct swap_info_struct *p,",
            "\tstruct swap_cluster_info *cluster_info, unsigned long page_nr)",
            "{",
            "\tunsigned long idx = page_nr / SWAPFILE_CLUSTER;",
            "\tstruct swap_cluster_info *ci;",
            "",
            "\tif (!cluster_info)",
            "\t\treturn;",
            "",
            "\tci = cluster_info + idx;",
            "\tci->count++;",
            "",
            "\tVM_BUG_ON(ci->count > SWAPFILE_CLUSTER);",
            "\tVM_BUG_ON(ci->flags);",
            "}",
            "static void dec_cluster_info_page(struct swap_info_struct *p,",
            "\t\t\t\t  struct swap_cluster_info *ci, int nr_pages)",
            "{",
            "\tif (!p->cluster_info)",
            "\t\treturn;",
            "",
            "\tVM_BUG_ON(ci->count < nr_pages);",
            "\tVM_BUG_ON(cluster_is_free(ci));",
            "\tlockdep_assert_held(&p->lock);",
            "\tlockdep_assert_held(&ci->lock);",
            "\tci->count -= nr_pages;",
            "",
            "\tif (!ci->count) {",
            "\t\tfree_cluster(p, ci);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (!(ci->flags & CLUSTER_FLAG_NONFULL)) {",
            "\t\tVM_BUG_ON(ci->flags & CLUSTER_FLAG_FREE);",
            "\t\tif (ci->flags & CLUSTER_FLAG_FRAG)",
            "\t\t\tp->frag_cluster_nr[ci->order]--;",
            "\t\tlist_move_tail(&ci->list, &p->nonfull_clusters[ci->order]);",
            "\t\tci->flags = CLUSTER_FLAG_NONFULL;",
            "\t}",
            "}",
            "static bool cluster_reclaim_range(struct swap_info_struct *si,",
            "\t\t\t\t  struct swap_cluster_info *ci,",
            "\t\t\t\t  unsigned long start, unsigned long end)",
            "{",
            "\tunsigned char *map = si->swap_map;",
            "\tunsigned long offset;",
            "",
            "\tspin_unlock(&ci->lock);",
            "\tspin_unlock(&si->lock);",
            "",
            "\tfor (offset = start; offset < end; offset++) {",
            "\t\tswitch (READ_ONCE(map[offset])) {",
            "\t\tcase 0:",
            "\t\t\tcontinue;",
            "\t\tcase SWAP_HAS_CACHE:",
            "\t\t\tif (__try_to_reclaim_swap(si, offset, TTRS_ANYWAY | TTRS_DIRECT) > 0)",
            "\t\t\t\tcontinue;",
            "\t\t\tgoto out;",
            "\t\tdefault:",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "out:",
            "\tspin_lock(&si->lock);",
            "\tspin_lock(&ci->lock);",
            "",
            "\t/*",
            "\t * Recheck the range no matter reclaim succeeded or not, the slot",
            "\t * could have been be freed while we are not holding the lock.",
            "\t */",
            "\tfor (offset = start; offset < end; offset++)",
            "\t\tif (READ_ONCE(map[offset]))",
            "\t\t\treturn false;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "swap_discard_work, swap_users_ref_free, free_cluster, inc_cluster_info_page, dec_cluster_info_page, cluster_reclaim_range",
          "description": "处理交换簇的引用计数更新、碎片化管理及延迟丢弃工作，确保簇在适当时机被释放或清理，平衡性能与存储效率。",
          "similarity": 0.5368188619613647
        },
        {
          "chunk_id": 1,
          "file_path": "mm/swapfile.c",
          "start_line": 127,
          "end_line": 251,
          "content": [
            "static inline unsigned char swap_count(unsigned char ent)",
            "{",
            "\treturn ent & ~SWAP_HAS_CACHE;\t/* may include COUNT_CONTINUED flag */",
            "}",
            "static bool swap_is_has_cache(struct swap_info_struct *si,",
            "\t\t\t      unsigned long offset, int nr_pages)",
            "{",
            "\tunsigned char *map = si->swap_map + offset;",
            "\tunsigned char *map_end = map + nr_pages;",
            "",
            "\tdo {",
            "\t\tVM_BUG_ON(!(*map & SWAP_HAS_CACHE));",
            "\t\tif (*map != SWAP_HAS_CACHE)",
            "\t\t\treturn false;",
            "\t} while (++map < map_end);",
            "",
            "\treturn true;",
            "}",
            "static int __try_to_reclaim_swap(struct swap_info_struct *si,",
            "\t\t\t\t unsigned long offset, unsigned long flags)",
            "{",
            "\tswp_entry_t entry = swp_entry(si->type, offset);",
            "\tstruct address_space *address_space = swap_address_space(entry);",
            "\tstruct swap_cluster_info *ci;",
            "\tstruct folio *folio;",
            "\tint ret, nr_pages;",
            "\tbool need_reclaim;",
            "",
            "\tfolio = filemap_get_folio(address_space, offset);",
            "\tif (IS_ERR(folio))",
            "\t\treturn 0;",
            "",
            "\tnr_pages = folio_nr_pages(folio);",
            "\tret = -nr_pages;",
            "",
            "\t/*",
            "\t * When this function is called from scan_swap_map_slots() and it's",
            "\t * called by vmscan.c at reclaiming folios. So we hold a folio lock",
            "\t * here. We have to use trylock for avoiding deadlock. This is a special",
            "\t * case and you should use folio_free_swap() with explicit folio_lock()",
            "\t * in usual operations.",
            "\t */",
            "\tif (!folio_trylock(folio))",
            "\t\tgoto out;",
            "",
            "\t/* offset could point to the middle of a large folio */",
            "\tentry = folio->swap;",
            "\toffset = swp_offset(entry);",
            "",
            "\tneed_reclaim = ((flags & TTRS_ANYWAY) ||",
            "\t\t\t((flags & TTRS_UNMAPPED) && !folio_mapped(folio)) ||",
            "\t\t\t((flags & TTRS_FULL) && mem_cgroup_swap_full(folio)));",
            "\tif (!need_reclaim || !folio_swapcache_freeable(folio))",
            "\t\tgoto out_unlock;",
            "",
            "\t/*",
            "\t * It's safe to delete the folio from swap cache only if the folio's",
            "\t * swap_map is HAS_CACHE only, which means the slots have no page table",
            "\t * reference or pending writeback, and can't be allocated to others.",
            "\t */",
            "\tci = lock_cluster_or_swap_info(si, offset);",
            "\tneed_reclaim = swap_is_has_cache(si, offset, nr_pages);",
            "\tunlock_cluster_or_swap_info(si, ci);",
            "\tif (!need_reclaim)",
            "\t\tgoto out_unlock;",
            "",
            "\tif (!(flags & TTRS_DIRECT)) {",
            "\t\t/* Free through slot cache */",
            "\t\tdelete_from_swap_cache(folio);",
            "\t\tfolio_set_dirty(folio);",
            "\t\tret = nr_pages;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\txa_lock_irq(&address_space->i_pages);",
            "\t__delete_from_swap_cache(folio, entry, NULL);",
            "\txa_unlock_irq(&address_space->i_pages);",
            "\tfolio_ref_sub(folio, nr_pages);",
            "\tfolio_set_dirty(folio);",
            "",
            "\tspin_lock(&si->lock);",
            "\t/* Only sinple page folio can be backed by zswap */",
            "\tif (nr_pages == 1)",
            "\t\tzswap_invalidate(entry);",
            "\tswap_entry_range_free(si, entry, nr_pages);",
            "\tspin_unlock(&si->lock);",
            "\tret = nr_pages;",
            "out_unlock:",
            "\tfolio_unlock(folio);",
            "out:",
            "\tfolio_put(folio);",
            "\treturn ret;",
            "}",
            "static int discard_swap(struct swap_info_struct *si)",
            "{",
            "\tstruct swap_extent *se;",
            "\tsector_t start_block;",
            "\tsector_t nr_blocks;",
            "\tint err = 0;",
            "",
            "\t/* Do not discard the swap header page! */",
            "\tse = first_se(si);",
            "\tstart_block = (se->start_block + 1) << (PAGE_SHIFT - 9);",
            "\tnr_blocks = ((sector_t)se->nr_pages - 1) << (PAGE_SHIFT - 9);",
            "\tif (nr_blocks) {",
            "\t\terr = blkdev_issue_discard(si->bdev, start_block,",
            "\t\t\t\tnr_blocks, GFP_KERNEL);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t\tcond_resched();",
            "\t}",
            "",
            "\tfor (se = next_se(se); se; se = next_se(se)) {",
            "\t\tstart_block = se->start_block << (PAGE_SHIFT - 9);",
            "\t\tnr_blocks = (sector_t)se->nr_pages << (PAGE_SHIFT - 9);",
            "",
            "\t\terr = blkdev_issue_discard(si->bdev, start_block,",
            "\t\t\t\tnr_blocks, GFP_KERNEL);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "",
            "\t\tcond_resched();",
            "\t}",
            "\treturn err;\t\t/* That will often be -EOPNOTSUPP */",
            "}"
          ],
          "function_name": "swap_count, swap_is_has_cache, __try_to_reclaim_swap, discard_swap",
          "description": "提供交换条目计数、缓存状态检查及回收逻辑，支持通过直接方式回收交换页并丢弃无效交换区域，优化内存回收过程。",
          "similarity": 0.5306359529495239
        },
        {
          "chunk_id": 0,
          "file_path": "mm/swapfile.c",
          "start_line": 1,
          "end_line": 126,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/mm/swapfile.c",
            " *",
            " *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds",
            " *  Swap reorganised 29.12.95, Stephen Tweedie",
            " */",
            "",
            "#include <linux/blkdev.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/random.h>",
            "#include <linux/writeback.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/security.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/poll.h>",
            "#include <linux/oom.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/export.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/sort.h>",
            "#include <linux/completion.h>",
            "#include <linux/suspend.h>",
            "#include <linux/zswap.h>",
            "#include <linux/plist.h>",
            "",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap_cgroup.h>",
            "#include \"internal.h\"",
            "#include \"swap.h\"",
            "",
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,",
            "\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static void swap_entry_range_free(struct swap_info_struct *si, swp_entry_t entry,",
            "\t\t\t\t  unsigned int nr_pages);",
            "static void swap_range_alloc(struct swap_info_struct *si, unsigned long offset,",
            "\t\t\t     unsigned int nr_entries);",
            "static bool folio_swapcache_freeable(struct folio *folio);",
            "static struct swap_cluster_info *lock_cluster_or_swap_info(",
            "\t\tstruct swap_info_struct *si, unsigned long offset);",
            "static void unlock_cluster_or_swap_info(struct swap_info_struct *si,",
            "\t\t\t\t\tstruct swap_cluster_info *ci);",
            "",
            "static DEFINE_SPINLOCK(swap_lock);",
            "static unsigned int nr_swapfiles;",
            "atomic_long_t nr_swap_pages;",
            "/*",
            " * Some modules use swappable objects and may try to swap them out under",
            " * memory pressure (via the shrinker). Before doing so, they may wish to",
            " * check to see if any swap space is available.",
            " */",
            "EXPORT_SYMBOL_GPL(nr_swap_pages);",
            "/* protected with swap_lock. reading in vm_swap_full() doesn't need lock */",
            "long total_swap_pages;",
            "static int least_priority = -1;",
            "unsigned long swapfile_maximum_size;",
            "#ifdef CONFIG_MIGRATION",
            "bool swap_migration_ad_supported;",
            "#endif\t/* CONFIG_MIGRATION */",
            "",
            "static const char Bad_file[] = \"Bad swap file entry \";",
            "static const char Unused_file[] = \"Unused swap file entry \";",
            "static const char Bad_offset[] = \"Bad swap offset entry \";",
            "static const char Unused_offset[] = \"Unused swap offset entry \";",
            "",
            "/*",
            " * all active swap_info_structs",
            " * protected with swap_lock, and ordered by priority.",
            " */",
            "static PLIST_HEAD(swap_active_head);",
            "",
            "/*",
            " * all available (active, not full) swap_info_structs",
            " * protected with swap_avail_lock, ordered by priority.",
            " * This is used by folio_alloc_swap() instead of swap_active_head",
            " * because swap_active_head includes all swap_info_structs,",
            " * but folio_alloc_swap() doesn't need to look at full ones.",
            " * This uses its own lock instead of swap_lock because when a",
            " * swap_info_struct changes between not-full/full, it needs to",
            " * add/remove itself to/from this list, but the swap_info_struct->lock",
            " * is held and the locking order requires swap_lock to be taken",
            " * before any swap_info_struct->lock.",
            " */",
            "static struct plist_head *swap_avail_heads;",
            "static DEFINE_SPINLOCK(swap_avail_lock);",
            "",
            "static struct swap_info_struct *swap_info[MAX_SWAPFILES];",
            "",
            "static DEFINE_MUTEX(swapon_mutex);",
            "",
            "static DECLARE_WAIT_QUEUE_HEAD(proc_poll_wait);",
            "/* Activity counter to indicate that a swapon or swapoff has occurred */",
            "static atomic_t proc_poll_event = ATOMIC_INIT(0);",
            "",
            "atomic_t nr_rotate_swap = ATOMIC_INIT(0);",
            "",
            "static struct swap_info_struct *swap_type_to_swap_info(int type)",
            "{",
            "\tif (type >= MAX_SWAPFILES)",
            "\t\treturn NULL;",
            "",
            "\treturn READ_ONCE(swap_info[type]); /* rcu_dereference() */",
            "}",
            ""
          ],
          "function_name": null,
          "description": "声明并初始化与交换文件管理相关的全局变量和数据结构，包括交换信息表、锁、统计计数器及辅助函数，用于跟踪和管理系统中所有交换文件的状态和资源。",
          "similarity": 0.5149747133255005
        },
        {
          "chunk_id": 4,
          "file_path": "mm/swapfile.c",
          "start_line": 620,
          "end_line": 755,
          "content": [
            "static bool cluster_scan_range(struct swap_info_struct *si,",
            "\t\t\t       struct swap_cluster_info *ci,",
            "\t\t\t       unsigned long start, unsigned int nr_pages)",
            "{",
            "\tunsigned long offset, end = start + nr_pages;",
            "\tunsigned char *map = si->swap_map;",
            "\tbool need_reclaim = false;",
            "",
            "\tfor (offset = start; offset < end; offset++) {",
            "\t\tswitch (READ_ONCE(map[offset])) {",
            "\t\tcase 0:",
            "\t\t\tcontinue;",
            "\t\tcase SWAP_HAS_CACHE:",
            "\t\t\tif (!vm_swap_full())",
            "\t\t\t\treturn false;",
            "\t\t\tneed_reclaim = true;",
            "\t\t\tcontinue;",
            "\t\tdefault:",
            "\t\t\treturn false;",
            "\t\t}",
            "\t}",
            "",
            "\tif (need_reclaim)",
            "\t\treturn cluster_reclaim_range(si, ci, start, end);",
            "",
            "\treturn true;",
            "}",
            "static bool cluster_alloc_range(struct swap_info_struct *si, struct swap_cluster_info *ci,",
            "\t\t\t\tunsigned int start, unsigned char usage,",
            "\t\t\t\tunsigned int order)",
            "{",
            "\tunsigned int nr_pages = 1 << order;",
            "",
            "\tif (!(si->flags & SWP_WRITEOK))",
            "\t\treturn false;",
            "",
            "\tif (cluster_is_free(ci)) {",
            "\t\tif (nr_pages < SWAPFILE_CLUSTER) {",
            "\t\t\tlist_move_tail(&ci->list, &si->nonfull_clusters[order]);",
            "\t\t\tci->flags = CLUSTER_FLAG_NONFULL;",
            "\t\t}",
            "\t\tci->order = order;",
            "\t}",
            "",
            "\tmemset(si->swap_map + start, usage, nr_pages);",
            "\tswap_range_alloc(si, start, nr_pages);",
            "\tci->count += nr_pages;",
            "",
            "\tif (ci->count == SWAPFILE_CLUSTER) {",
            "\t\tVM_BUG_ON(!(ci->flags &",
            "\t\t\t  (CLUSTER_FLAG_FREE | CLUSTER_FLAG_NONFULL | CLUSTER_FLAG_FRAG)));",
            "\t\tif (ci->flags & CLUSTER_FLAG_FRAG)",
            "\t\t\tsi->frag_cluster_nr[ci->order]--;",
            "\t\tlist_move_tail(&ci->list, &si->full_clusters);",
            "\t\tci->flags = CLUSTER_FLAG_FULL;",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "static unsigned int alloc_swap_scan_cluster(struct swap_info_struct *si, unsigned long offset,",
            "\t\t\t\t\t    unsigned int *foundp, unsigned int order,",
            "\t\t\t\t\t    unsigned char usage)",
            "{",
            "\tunsigned long start = offset & ~(SWAPFILE_CLUSTER - 1);",
            "\tunsigned long end = min(start + SWAPFILE_CLUSTER, si->max);",
            "\tunsigned int nr_pages = 1 << order;",
            "\tstruct swap_cluster_info *ci;",
            "",
            "\tif (end < nr_pages)",
            "\t\treturn SWAP_NEXT_INVALID;",
            "\tend -= nr_pages;",
            "",
            "\tci = lock_cluster(si, offset);",
            "\tif (ci->count + nr_pages > SWAPFILE_CLUSTER) {",
            "\t\toffset = SWAP_NEXT_INVALID;",
            "\t\tgoto done;",
            "\t}",
            "",
            "\twhile (offset <= end) {",
            "\t\tif (cluster_scan_range(si, ci, offset, nr_pages)) {",
            "\t\t\tif (!cluster_alloc_range(si, ci, offset, usage, order)) {",
            "\t\t\t\toffset = SWAP_NEXT_INVALID;",
            "\t\t\t\tgoto done;",
            "\t\t\t}",
            "\t\t\t*foundp = offset;",
            "\t\t\tif (ci->count == SWAPFILE_CLUSTER) {",
            "\t\t\t\toffset = SWAP_NEXT_INVALID;",
            "\t\t\t\tgoto done;",
            "\t\t\t}",
            "\t\t\toffset += nr_pages;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\toffset += nr_pages;",
            "\t}",
            "\tif (offset > end)",
            "\t\toffset = SWAP_NEXT_INVALID;",
            "done:",
            "\tunlock_cluster(ci);",
            "\treturn offset;",
            "}",
            "static void swap_reclaim_full_clusters(struct swap_info_struct *si, bool force)",
            "{",
            "\tlong to_scan = 1;",
            "\tunsigned long offset, end;",
            "\tstruct swap_cluster_info *ci;",
            "\tunsigned char *map = si->swap_map;",
            "\tint nr_reclaim;",
            "",
            "\tif (force)",
            "\t\tto_scan = si->inuse_pages / SWAPFILE_CLUSTER;",
            "",
            "\twhile (!list_empty(&si->full_clusters)) {",
            "\t\tci = list_first_entry(&si->full_clusters, struct swap_cluster_info, list);",
            "\t\tlist_move_tail(&ci->list, &si->full_clusters);",
            "\t\toffset = cluster_offset(si, ci);",
            "\t\tend = min(si->max, offset + SWAPFILE_CLUSTER);",
            "\t\tto_scan--;",
            "",
            "\t\tspin_unlock(&si->lock);",
            "\t\twhile (offset < end) {",
            "\t\t\tif (READ_ONCE(map[offset]) == SWAP_HAS_CACHE) {",
            "\t\t\t\tnr_reclaim = __try_to_reclaim_swap(si, offset,",
            "\t\t\t\t\t\t\t\t   TTRS_ANYWAY | TTRS_DIRECT);",
            "\t\t\t\tif (nr_reclaim) {",
            "\t\t\t\t\toffset += abs(nr_reclaim);",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\toffset++;",
            "\t\t}",
            "\t\tspin_lock(&si->lock);",
            "",
            "\t\tif (to_scan <= 0)",
            "\t\t\tbreak;",
            "\t}",
            "}"
          ],
          "function_name": "cluster_scan_range, cluster_alloc_range, alloc_swap_scan_cluster, swap_reclaim_full_clusters",
          "description": "负责交换簇的扫描分配与全簇回收逻辑，动态调整簇状态并在必要时触发回收操作，维护交换空间的有效利用。",
          "similarity": 0.5095652341842651
        }
      ]
    },
    {
      "source_file": "mm/shuffle.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:21:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `shuffle.c`\n\n---\n\n# shuffle.c 技术文档\n\n## 1. 文件概述\n\n`shuffle.c` 实现了 Linux 内核内存管理子系统中的**页面分配随机化（Page Allocation Shuffling）**功能。该机制通过在内存初始化阶段对空闲页面链表进行 Fisher-Yates 洗牌操作，降低物理页帧分配的可预测性，从而增强系统安全性，抵御基于内存布局预测的攻击（如堆喷射、地址泄露等）。该功能默认关闭，可通过内核启动参数 `shuffle=1` 启用。\n\n## 2. 核心功能\n\n### 数据结构与全局变量\n- `page_alloc_shuffle_key`：静态分支键（static key），用于运行时启用/禁用洗牌逻辑，减少未启用时的性能开销。\n- `shuffle_param`：模块参数布尔值，控制是否启用洗牌功能。\n- `shuffle_param_ops`：自定义模块参数操作集，用于处理 `shuffle` 参数的设置和读取。\n\n### 主要函数\n- `shuffle_param_set()`：解析并设置 `shuffle` 内核参数，若启用则激活 `page_alloc_shuffle_key`。\n- `shuffle_valid_page()`：验证指定 PFN 的页面是否满足洗牌条件（属于 buddy 系统、同 zone、空闲、相同 order 和 migratetype）。\n- `__shuffle_zone()`：对指定内存区域（zone）执行 Fisher-Yates 洗牌算法，随机交换同阶空闲页面。\n- `__shuffle_free_memory()`：遍历节点（pgdat）中所有 zone，依次调用 `shuffle_zone()` 进行洗牌。\n- `shuffle_pick_tail()`：提供轻量级随机位生成器，用于在分配时决定从链表头部还是尾部取页（增强运行时随机性）。\n\n## 3. 关键实现\n\n### 洗牌算法（Fisher-Yates）\n- **粒度**：以 `SHUFFLE_ORDER`（通常为 0，即单页）为单位进行洗牌。\n- **范围**：遍历 zone 内所有按 order 对齐的 PFN，对每个有效页面 `page_i` 随机选择另一个有效页面 `page_j` 进行交换。\n- **有效性校验**：通过 `shuffle_valid_page()` 确保交换双方均为 buddy 系统管理的空闲页，且具有相同的迁移类型（migratetype）。\n- **重试机制**：最多尝试 `SHUFFLE_RETRY`（10 次）寻找有效的随机目标页，避免因内存空洞导致失败。\n- **锁优化**：每处理 100 个页面后释放 zone 自旋锁并调度，防止长时间持锁影响系统响应。\n\n### 随机性来源\n- 使用 `get_random_long()` 获取高质量伪随机数作为洗牌索引。\n- `shuffle_pick_tail()` 使用无锁的 64 位随机状态生成器，每次返回最低位并右移，用于运行时分配策略的微调。\n\n### 安全性权衡\n- 明确承认不消除模运算偏差（modulo bias）或 PRNG 偏差，目标是“提高攻击门槛”而非完美随机。\n- 仅在内存初始化阶段（`__meminit`）执行一次洗牌，不影响运行时分配性能。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/mm.h>`、`<linux/mmzone.h>`：内存管理核心数据结构（`struct zone`, `struct page`）。\n  - `<linux/random.h>`：提供 `get_random_long()` 和 `get_random_u64()`。\n  - `\"internal.h\"`、`\"shuffle.h\"`：内核 MM 子系统内部接口及洗牌功能声明。\n- **功能依赖**：\n  - Buddy 分配器：依赖 `PageBuddy()`、`buddy_order()` 等接口判断页面状态。\n  - 页面迁移类型（Migratetype）：确保洗牌不破坏不同迁移类型页面的隔离。\n  - 静态分支（Static Keys）：通过 `static_branch_enable()` 动态启用洗牌路径。\n\n## 5. 使用场景\n\n- **安全加固**：在需要防范物理地址预测攻击的场景（如虚拟化宿主机、安全敏感设备）中启用，增加攻击者利用内存布局漏洞的难度。\n- **内核初始化**：在 `free_area_init_core()` 等内存子系统初始化流程中调用 `__shuffle_free_memory()`，对初始空闲内存进行一次性洗牌。\n- **运行时分配辅助**：`shuffle_pick_tail()` 被页面分配器调用，决定从空闲链表头/尾取页，进一步增加分配时序的不可预测性。\n- **调试支持**：通过 `pr_debug()` 输出洗牌失败或迁移类型不匹配的日志，便于问题诊断（需开启 `DEBUG_SHUFFLE`）。",
      "similarity": 0.5606149435043335,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/shuffle.c",
          "start_line": 16,
          "end_line": 121,
          "content": [
            "static __meminit int shuffle_param_set(const char *val,",
            "\t\tconst struct kernel_param *kp)",
            "{",
            "\tif (param_set_bool(val, kp))",
            "\t\treturn -EINVAL;",
            "\tif (*(bool *)kp->arg)",
            "\t\tstatic_branch_enable(&page_alloc_shuffle_key);",
            "\treturn 0;",
            "}",
            "void __meminit __shuffle_zone(struct zone *z)",
            "{",
            "\tunsigned long i, flags;",
            "\tunsigned long start_pfn = z->zone_start_pfn;",
            "\tunsigned long end_pfn = zone_end_pfn(z);",
            "\tconst int order = SHUFFLE_ORDER;",
            "\tconst int order_pages = 1 << order;",
            "",
            "\tspin_lock_irqsave(&z->lock, flags);",
            "\tstart_pfn = ALIGN(start_pfn, order_pages);",
            "\tfor (i = start_pfn; i < end_pfn; i += order_pages) {",
            "\t\tunsigned long j;",
            "\t\tint migratetype, retry;",
            "\t\tstruct page *page_i, *page_j;",
            "",
            "\t\t/*",
            "\t\t * We expect page_i, in the sub-range of a zone being added",
            "\t\t * (@start_pfn to @end_pfn), to more likely be valid compared to",
            "\t\t * page_j randomly selected in the span @zone_start_pfn to",
            "\t\t * @spanned_pages.",
            "\t\t */",
            "\t\tpage_i = shuffle_valid_page(z, i, order);",
            "\t\tif (!page_i)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (retry = 0; retry < SHUFFLE_RETRY; retry++) {",
            "\t\t\t/*",
            "\t\t\t * Pick a random order aligned page in the zone span as",
            "\t\t\t * a swap target. If the selected pfn is a hole, retry",
            "\t\t\t * up to SHUFFLE_RETRY attempts find a random valid pfn",
            "\t\t\t * in the zone.",
            "\t\t\t */",
            "\t\t\tj = z->zone_start_pfn +",
            "\t\t\t\tALIGN_DOWN(get_random_long() % z->spanned_pages,",
            "\t\t\t\t\t\torder_pages);",
            "\t\t\tpage_j = shuffle_valid_page(z, j, order);",
            "\t\t\tif (page_j && page_j != page_i)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (retry >= SHUFFLE_RETRY) {",
            "\t\t\tpr_debug(\"%s: failed to swap %#lx\\n\", __func__, i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Each migratetype corresponds to its own list, make sure the",
            "\t\t * types match otherwise we're moving pages to lists where they",
            "\t\t * do not belong.",
            "\t\t */",
            "\t\tmigratetype = get_pageblock_migratetype(page_i);",
            "\t\tif (get_pageblock_migratetype(page_j) != migratetype) {",
            "\t\t\tpr_debug(\"%s: migratetype mismatch %#lx\\n\", __func__, i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tlist_swap(&page_i->lru, &page_j->lru);",
            "",
            "\t\tpr_debug(\"%s: swap: %#lx -> %#lx\\n\", __func__, i, j);",
            "",
            "\t\t/* take it easy on the zone lock */",
            "\t\tif ((i % (100 * order_pages)) == 0) {",
            "\t\t\tspin_unlock_irqrestore(&z->lock, flags);",
            "\t\t\tcond_resched();",
            "\t\t\tspin_lock_irqsave(&z->lock, flags);",
            "\t\t}",
            "\t}",
            "\tspin_unlock_irqrestore(&z->lock, flags);",
            "}",
            "void __meminit __shuffle_free_memory(pg_data_t *pgdat)",
            "{",
            "\tstruct zone *z;",
            "",
            "\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)",
            "\t\tshuffle_zone(z);",
            "}",
            "bool shuffle_pick_tail(void)",
            "{",
            "\tstatic u64 rand;",
            "\tstatic u8 rand_bits;",
            "\tbool ret;",
            "",
            "\t/*",
            "\t * The lack of locking is deliberate. If 2 threads race to",
            "\t * update the rand state it just adds to the entropy.",
            "\t */",
            "\tif (rand_bits == 0) {",
            "\t\trand_bits = 64;",
            "\t\trand = get_random_u64();",
            "\t}",
            "",
            "\tret = rand & 1;",
            "",
            "\trand_bits--;",
            "\trand >>= 1;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "shuffle_param_set, __shuffle_zone, __shuffle_free_memory, shuffle_pick_tail",
          "description": "shuffle_param_set设置参数并启用/禁用静态键；__shuffle_zone在内存区随机交换页面以打乱物理顺序；__shuffle_free_memory初始化时调用__shuffle_zone；shuffle_pick_tail生成随机布尔值用于选择尾部页",
          "similarity": 0.4697130024433136
        },
        {
          "chunk_id": 0,
          "file_path": "mm/shuffle.c",
          "start_line": 1,
          "end_line": 15,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright(c) 2018 Intel Corporation. All rights reserved.",
            "",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/random.h>",
            "#include <linux/moduleparam.h>",
            "#include \"internal.h\"",
            "#include \"shuffle.h\"",
            "",
            "DEFINE_STATIC_KEY_FALSE(page_alloc_shuffle_key);",
            "",
            "static bool shuffle_param;",
            ""
          ],
          "function_name": null,
          "description": "定义静态键用于控制页面分配随机化功能，并声明参数变量shuffle_param，用于启用或禁用相关机制",
          "similarity": 0.3392459452152252
        }
      ]
    },
    {
      "source_file": "kernel/signal.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:24:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `signal.c`\n\n---\n\n# signal.c 技术文档\n\n## 1. 文件概述\n\n`signal.c` 是 Linux 内核中信号子系统的核心实现文件，负责管理进程间信号的发送、接收、排队、处理以及相关状态的维护。该文件实现了 POSIX 信号语义，包括标准信号和实时信号（通过 sigqueue），并处理信号的阻塞、忽略、默认行为及用户自定义处理函数的调用逻辑。它还集成了对 ptrace 调试、作业控制（job control）、冻结（freezer）和 cgroup 等子系统的支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `sigqueue_cachep`：用于分配 `sigqueue` 结构的 slab 缓存，支持可靠信号排队。\n- `task_struct::pending`：每个任务私有的挂起信号队列。\n- `signal_struct::shared_pending`：线程组共享的挂起信号队列。\n- `task_struct::blocked` / `real_blocked`：信号阻塞掩码。\n- `task_struct::jobctl`：作业控制相关状态位（如停止、陷阱等）。\n\n### 主要函数\n- `sig_handler()`：获取指定信号的处理函数指针。\n- `sig_handler_ignored()`：判断信号是否被显式或隐式忽略。\n- `sig_task_ignored()` / `sig_ignored()`：判断任务是否忽略某信号（考虑 init、kthread、ptrace 等特殊情况）。\n- `has_pending_signals()`：检查在给定阻塞掩码下是否存在可投递的挂起信号。\n- `recalc_sigpending_tsk()` / `recalc_sigpending()` / `recalc_sigpending_and_wake()`：重新计算并设置 `TIF_SIGPENDING` 线程标志。\n- `next_signal()`：从挂起信号中选择下一个应被处理的信号，优先处理同步信号（如 SIGSEGV、SIGILL 等）。\n- `task_set_jobctl_pending()`：设置任务的作业控制挂起状态（如停止请求）。\n- `task_clear_jobctl_trapping()`：清除作业控制陷阱状态并唤醒跟踪者（ptracer）。\n- `print_dropped_signal()`：当日志开启且达到 `RLIMIT_SIGPENDING` 限制时，记录被丢弃的信号。\n\n## 3. 关键实现\n\n### 信号忽略逻辑\n信号是否被忽略不仅取决于处理函数是否为 `SIG_IGN` 或默认且内核定义为可忽略（`sig_kernel_ignore()`），还需考虑：\n- 全局 init 进程不能接收 `SIGKILL`/`SIGSTOP`。\n- `SIGNAL_UNKILLABLE` 任务对默认处理的内核信号有特殊豁免。\n- 内核线程（`PF_KTHREAD`）仅响应强制（`force=true`）的内核信号。\n- 若任务被 ptrace 跟踪，除 `SIGKILL` 外，即使信号被忽略也需通知调试器。\n\n### 挂起信号检测优化\n`has_pending_signals()` 使用位运算高效检查 `signal & ~blocked` 是否非零，并针对 `_NSIG_WORDS` 的常见值（1、2、4）进行展开优化，避免循环开销。\n\n### 信号选择策略\n`next_signal()` 优先处理同步信号（定义在 `SYNCHRONOUS_MASK` 中），确保如段错误、非法指令等异常能被及时响应，符合 POSIX 对同步信号“立即投递”的要求。\n\n### TIF_SIGPENDING 标志管理\n- `recalc_sigpending_tsk()` 综合检查私有/共享挂起信号、作业控制状态和 cgroup 冻结状态，决定是否设置 `TIF_SIGPENDING`。\n- 为避免竞态，**不清除**该标志，仅由明确知道安全的调用者（如 `recalc_sigpending()`）在适当上下文中清除。\n- `recalc_sigpending_and_wake()` 在设置标志后主动唤醒任务，确保其能及时处理信号。\n\n### 作业控制集成\n通过 `jobctl` 字段和 `JOBCTL_*` 位掩码，支持 ptrace 和作业控制的复杂状态机（如停止、陷阱、信号消费），并在 `siglock` 保护下安全更新。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `task_struct`、`thread_info` 标志（如 `TIF_SIGPENDING`）、`PF_EXITING` 等。\n- **内存管理**：使用 slab 分配器（`kmem_cache`）管理 `sigqueue`。\n- **进程管理**：与 `fork`/`exec`/`exit` 流程交互（如 `calculate_sigpending` 在 fork 后调用）。\n- **ptrace**：通过 `ptrace` 字段和 `JOBCTL_TRAPPING` 支持调试器信号拦截。\n- **cgroup/freezer**：检查 `cgroup_task_frozen()` 状态影响信号挂起判断。\n- **安全模块**：通过 `security_task_kill()` 等钩子（虽未在片段中体现，但完整文件包含）。\n- **tracepoint**：定义 `trace/events/signal.h` 中的跟踪点用于调试。\n- **架构相关代码**：依赖 `asm/siginfo.h`、`uaccess.h` 等处理用户空间信号帧。\n\n## 5. 使用场景\n\n- **系统调用处理**：`kill()`、`tkill()`、`rt_sigqueueinfo()` 等信号发送系统调用最终调用本文件逻辑。\n- **异常处理**：CPU 异常（如页错误、除零）触发同步信号（SIGSEGV、SIGFPE），由本文件选择并准备投递。\n- **进程生命周期管理**：在 `do_exit()`、`flush_old_exec()` 等路径中清理或重置信号状态。\n- **调试器支持**：ptrace 在注入信号或单步执行时依赖作业控制状态和信号忽略逻辑。\n- **资源限制**：当信号队列达到 `RLIMIT_SIGPENDING` 限制时，调用 `print_dropped_signal()` 记录丢弃事件。\n- **冻结/恢复**：cgroup freezer 或 suspend 流程通过 `cgroup_task_frozen()` 影响信号挂起状态，确保任务在冻结期间不处理信号。",
      "similarity": 0.5495101809501648,
      "chunks": [
        {
          "chunk_id": 10,
          "file_path": "kernel/signal.c",
          "start_line": 1511,
          "end_line": 1620,
          "content": [
            "int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)",
            "{",
            "\treturn kill_pid_info_type(sig, info, pid, PIDTYPE_TGID);",
            "}",
            "static int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid)",
            "{",
            "\tint error;",
            "\trcu_read_lock();",
            "\terror = kill_pid_info(sig, info, find_vpid(pid));",
            "\trcu_read_unlock();",
            "\treturn error;",
            "}",
            "static inline bool kill_as_cred_perm(const struct cred *cred,",
            "\t\t\t\t     struct task_struct *target)",
            "{",
            "\tconst struct cred *pcred = __task_cred(target);",
            "",
            "\treturn uid_eq(cred->euid, pcred->suid) ||",
            "\t       uid_eq(cred->euid, pcred->uid) ||",
            "\t       uid_eq(cred->uid, pcred->suid) ||",
            "\t       uid_eq(cred->uid, pcred->uid);",
            "}",
            "int kill_pid_usb_asyncio(int sig, int errno, sigval_t addr,",
            "\t\t\t struct pid *pid, const struct cred *cred)",
            "{",
            "\tstruct kernel_siginfo info;",
            "\tstruct task_struct *p;",
            "\tunsigned long flags;",
            "\tint ret = -EINVAL;",
            "",
            "\tif (!valid_signal(sig))",
            "\t\treturn ret;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = sig;",
            "\tinfo.si_errno = errno;",
            "\tinfo.si_code = SI_ASYNCIO;",
            "\t*((sigval_t *)&info.si_pid) = addr;",
            "",
            "\trcu_read_lock();",
            "\tp = pid_task(pid, PIDTYPE_PID);",
            "\tif (!p) {",
            "\t\tret = -ESRCH;",
            "\t\tgoto out_unlock;",
            "\t}",
            "\tif (!kill_as_cred_perm(cred, p)) {",
            "\t\tret = -EPERM;",
            "\t\tgoto out_unlock;",
            "\t}",
            "\tret = security_task_kill(p, &info, sig, cred);",
            "\tif (ret)",
            "\t\tgoto out_unlock;",
            "",
            "\tif (sig) {",
            "\t\tif (lock_task_sighand(p, &flags)) {",
            "\t\t\tret = __send_signal_locked(sig, &info, p, PIDTYPE_TGID, false);",
            "\t\t\tunlock_task_sighand(p, &flags);",
            "\t\t} else",
            "\t\t\tret = -ESRCH;",
            "\t}",
            "out_unlock:",
            "\trcu_read_unlock();",
            "\treturn ret;",
            "}",
            "static int kill_something_info(int sig, struct kernel_siginfo *info, pid_t pid)",
            "{",
            "\tint ret;",
            "",
            "\tif (pid > 0)",
            "\t\treturn kill_proc_info(sig, info, pid);",
            "",
            "\t/* -INT_MIN is undefined.  Exclude this case to avoid a UBSAN warning */",
            "\tif (pid == INT_MIN)",
            "\t\treturn -ESRCH;",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tif (pid != -1) {",
            "\t\tret = __kill_pgrp_info(sig, info,",
            "\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));",
            "\t} else {",
            "\t\tint retval = 0, count = 0;",
            "\t\tstruct task_struct * p;",
            "",
            "\t\tfor_each_process(p) {",
            "\t\t\tif (task_pid_vnr(p) > 1 &&",
            "\t\t\t\t\t!same_thread_group(p, current)) {",
            "\t\t\t\tint err = group_send_sig_info(sig, info, p,",
            "\t\t\t\t\t\t\t      PIDTYPE_MAX);",
            "\t\t\t\t++count;",
            "\t\t\t\tif (err != -EPERM)",
            "\t\t\t\t\tretval = err;",
            "\t\t\t}",
            "\t\t}",
            "\t\tret = count ? retval : -ESRCH;",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\treturn ret;",
            "}",
            "int send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)",
            "{",
            "\t/*",
            "\t * Make sure legacy kernel users don't send in bad values",
            "\t * (normal paths check this in check_kill_permission).",
            "\t */",
            "\tif (!valid_signal(sig))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);",
            "}"
          ],
          "function_name": "kill_pid_info, kill_proc_info, kill_as_cred_perm, kill_pid_usb_asyncio, kill_something_info, send_sig_info",
          "description": "定义了多个用于向进程/线程组发送信号的辅助函数，其中kill_pid_usb_asyncio处理异步I/O错误信号，kill_something_info根据PID值选择发送目标，send_sig_info负责实际发送信号信息。所有函数最终通过do_send_sig_info完成信号分发。",
          "similarity": 0.5648252964019775
        },
        {
          "chunk_id": 27,
          "file_path": "kernel/signal.c",
          "start_line": 4872,
          "end_line": 4907,
          "content": [
            "void __init signals_init(void)",
            "{",
            "\tsiginfo_buildtime_checks();",
            "",
            "\tsigqueue_cachep = KMEM_CACHE(sigqueue, SLAB_PANIC | SLAB_ACCOUNT);",
            "}",
            "void kdb_send_sig(struct task_struct *t, int sig)",
            "{",
            "\tstatic struct task_struct *kdb_prev_t;",
            "\tint new_t, ret;",
            "\tif (!spin_trylock(&t->sighand->siglock)) {",
            "\t\tkdb_printf(\"Can't do kill command now.\\n\"",
            "\t\t\t   \"The sigmask lock is held somewhere else in \"",
            "\t\t\t   \"kernel, try again later\\n\");",
            "\t\treturn;",
            "\t}",
            "\tnew_t = kdb_prev_t != t;",
            "\tkdb_prev_t = t;",
            "\tif (!task_is_running(t) && new_t) {",
            "\t\tspin_unlock(&t->sighand->siglock);",
            "\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"",
            "\t\t\t   \"kdb risks deadlock\\n\"",
            "\t\t\t   \"on the run queue locks. \"",
            "\t\t\t   \"The signal has _not_ been sent.\\n\"",
            "\t\t\t   \"Reissue the kill command if you want to risk \"",
            "\t\t\t   \"the deadlock.\\n\");",
            "\t\treturn;",
            "\t}",
            "\tret = send_signal_locked(sig, SEND_SIG_PRIV, t, PIDTYPE_PID);",
            "\tspin_unlock(&t->sighand->siglock);",
            "\tif (ret)",
            "\t\tkdb_printf(\"Fail to deliver Signal %d to process %d.\\n\",",
            "\t\t\t   sig, t->pid);",
            "\telse",
            "\t\tkdb_printf(\"Signal %d is sent to process %d.\\n\", sig, t->pid);",
            "}"
          ],
          "function_name": "signals_init, kdb_send_sig",
          "description": "完成信号系统初始化并注册信号队列缓存，实现kdb_send_sig向指定进程发送信号的接口，包含并发控制检查和进程运行态验证以避免死锁风险",
          "similarity": 0.560550332069397
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/signal.c",
          "start_line": 1788,
          "end_line": 1900,
          "content": [
            "int send_sig_mceerr(int code, void __user *addr, short lsb, struct task_struct *t)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tWARN_ON((code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR));",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGBUS;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code = code;",
            "\tinfo.si_addr = addr;",
            "\tinfo.si_addr_lsb = lsb;",
            "\treturn send_sig_info(info.si_signo, &info, t);",
            "}",
            "int force_sig_bnderr(void __user *addr, void __user *lower, void __user *upper)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGSEGV;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code  = SEGV_BNDERR;",
            "\tinfo.si_addr  = addr;",
            "\tinfo.si_lower = lower;",
            "\tinfo.si_upper = upper;",
            "\treturn force_sig_info(&info);",
            "}",
            "int force_sig_pkuerr(void __user *addr, u32 pkey)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGSEGV;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code  = SEGV_PKUERR;",
            "\tinfo.si_addr  = addr;",
            "\tinfo.si_pkey  = pkey;",
            "\treturn force_sig_info(&info);",
            "}",
            "int send_sig_perf(void __user *addr, u32 type, u64 sig_data)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo     = SIGTRAP;",
            "\tinfo.si_errno     = 0;",
            "\tinfo.si_code      = TRAP_PERF;",
            "\tinfo.si_addr      = addr;",
            "\tinfo.si_perf_data = sig_data;",
            "\tinfo.si_perf_type = type;",
            "",
            "\t/*",
            "\t * Signals generated by perf events should not terminate the whole",
            "\t * process if SIGTRAP is blocked, however, delivering the signal",
            "\t * asynchronously is better than not delivering at all. But tell user",
            "\t * space if the signal was asynchronous, so it can clearly be",
            "\t * distinguished from normal synchronous ones.",
            "\t */",
            "\tinfo.si_perf_flags = sigismember(&current->blocked, info.si_signo) ?",
            "\t\t\t\t     TRAP_PERF_FLAG_ASYNC :",
            "\t\t\t\t     0;",
            "",
            "\treturn send_sig_info(info.si_signo, &info, current);",
            "}",
            "int force_sig_seccomp(int syscall, int reason, bool force_coredump)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGSYS;",
            "\tinfo.si_code = SYS_SECCOMP;",
            "\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);",
            "\tinfo.si_errno = reason;",
            "\tinfo.si_arch = syscall_get_arch(current);",
            "\tinfo.si_syscall = syscall;",
            "\treturn force_sig_info_to_task(&info, current,",
            "\t\tforce_coredump ? HANDLER_EXIT : HANDLER_CURRENT);",
            "}",
            "int force_sig_ptrace_errno_trap(int errno, void __user *addr)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGTRAP;",
            "\tinfo.si_errno = errno;",
            "\tinfo.si_code  = TRAP_HWBKPT;",
            "\tinfo.si_addr  = addr;",
            "\treturn force_sig_info(&info);",
            "}",
            "int force_sig_fault_trapno(int sig, int code, void __user *addr, int trapno)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = sig;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code  = code;",
            "\tinfo.si_addr  = addr;",
            "\tinfo.si_trapno = trapno;",
            "\treturn force_sig_info(&info);",
            "}",
            "int send_sig_fault_trapno(int sig, int code, void __user *addr, int trapno,",
            "\t\t\t  struct task_struct *t)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = sig;",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_code  = code;",
            "\tinfo.si_addr  = addr;",
            "\tinfo.si_trapno = trapno;",
            "\treturn send_sig_info(info.si_signo, &info, t);",
            "}"
          ],
          "function_name": "send_sig_mceerr, force_sig_bnderr, force_sig_pkuerr, send_sig_perf, force_sig_seccomp, force_sig_ptrace_errno_trap, force_sig_fault_trapno, send_sig_fault_trapno",
          "description": "专门处理架构相关的信号错误场景，如内存绑定错误(SEGV_BNDERR)、PKU保护错误(SEGV_PKUERR)、性能监控陷阱(TRAP_PERF)等，通过构造特定信号信息调用通用发送接口。包含处理seccomp过滤器、ptrace跟踪等特殊情况的信号生成逻辑。",
          "similarity": 0.5450211763381958
        },
        {
          "chunk_id": 13,
          "file_path": "kernel/signal.c",
          "start_line": 1929,
          "end_line": 2032,
          "content": [
            "static int kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)",
            "{",
            "\tint ret;",
            "\tread_lock(&tasklist_lock);",
            "\tret = __kill_pgrp_info(sig, info, pgrp);",
            "\tread_unlock(&tasklist_lock);",
            "\treturn ret;",
            "}",
            "int kill_pgrp(struct pid *pid, int sig, int priv)",
            "{",
            "\treturn kill_pgrp_info(sig, __si_special(priv), pid);",
            "}",
            "int kill_pid(struct pid *pid, int sig, int priv)",
            "{",
            "\treturn kill_pid_info(sig, __si_special(priv), pid);",
            "}",
            "void sigqueue_free(struct sigqueue *q)",
            "{",
            "\tunsigned long flags;",
            "\tspinlock_t *lock = &current->sighand->siglock;",
            "",
            "\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));",
            "\t/*",
            "\t * We must hold ->siglock while testing q->list",
            "\t * to serialize with collect_signal() or with",
            "\t * __exit_signal()->flush_sigqueue().",
            "\t */",
            "\tspin_lock_irqsave(lock, flags);",
            "\tq->flags &= ~SIGQUEUE_PREALLOC;",
            "\t/*",
            "\t * If it is queued it will be freed when dequeued,",
            "\t * like the \"regular\" sigqueue.",
            "\t */",
            "\tif (!list_empty(&q->list))",
            "\t\tq = NULL;",
            "\tspin_unlock_irqrestore(lock, flags);",
            "",
            "\tif (q)",
            "\t\t__sigqueue_free(q);",
            "}",
            "int send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)",
            "{",
            "\tint sig = q->info.si_signo;",
            "\tstruct sigpending *pending;",
            "\tstruct task_struct *t;",
            "\tunsigned long flags;",
            "\tint ret, result;",
            "",
            "\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));",
            "",
            "\tret = -1;",
            "\trcu_read_lock();",
            "",
            "\t/*",
            "\t * This function is used by POSIX timers to deliver a timer signal.",
            "\t * Where type is PIDTYPE_PID (such as for timers with SIGEV_THREAD_ID",
            "\t * set), the signal must be delivered to the specific thread (queues",
            "\t * into t->pending).",
            "\t *",
            "\t * Where type is not PIDTYPE_PID, signals must be delivered to the",
            "\t * process. In this case, prefer to deliver to current if it is in the",
            "\t * same thread group as the target process and its sighand is stable,",
            "\t * which avoids unnecessarily waking up a potentially idle task.",
            "\t */",
            "\tt = pid_task(pid, type);",
            "\tif (!t)",
            "\t\tgoto ret;",
            "\tif (type != PIDTYPE_PID &&",
            "\t    same_thread_group(t, current) && !current->exit_state)",
            "\t\tt = current;",
            "\tif (!likely(lock_task_sighand(t, &flags)))",
            "\t\tgoto ret;",
            "",
            "\tret = 1; /* the signal is ignored */",
            "\tresult = TRACE_SIGNAL_IGNORED;",
            "\tif (!prepare_signal(sig, t, false))",
            "\t\tgoto out;",
            "",
            "\tret = 0;",
            "\tif (unlikely(!list_empty(&q->list))) {",
            "\t\t/*",
            "\t\t * If an SI_TIMER entry is already queue just increment",
            "\t\t * the overrun count.",
            "\t\t */",
            "\t\tBUG_ON(q->info.si_code != SI_TIMER);",
            "\t\tq->info.si_overrun++;",
            "\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;",
            "\t\tgoto out;",
            "\t}",
            "\tq->info.si_overrun = 0;",
            "",
            "\tsignalfd_notify(t, sig);",
            "\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;",
            "\tlist_add_tail(&q->list, &pending->list);",
            "\tsigaddset(&pending->signal, sig);",
            "\tcomplete_signal(sig, t, type);",
            "\tresult = TRACE_SIGNAL_DELIVERED;",
            "out:",
            "\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);",
            "\tunlock_task_sighand(t, &flags);",
            "ret:",
            "\trcu_read_unlock();",
            "\treturn ret;",
            "}"
          ],
          "function_name": "kill_pgrp_info, kill_pgrp, kill_pid, sigqueue_free, send_sigqueue",
          "description": "实现进程组信号发送和信号队列管理，kill_pgrp_info向进程组发送信号，sigqueue_free释放预分配的信号队列结构。send_sigqueue处理POSIX定时器信号的精确投递，支持不同PID类型的目标选择和信号重放控制。",
          "similarity": 0.5415436029434204
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/signal.c",
          "start_line": 1337,
          "end_line": 1457,
          "content": [
            "static int",
            "force_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t,",
            "\tenum sig_handler handler)",
            "{",
            "\tunsigned long int flags;",
            "\tint ret, blocked, ignored;",
            "\tstruct k_sigaction *action;",
            "\tint sig = info->si_signo;",
            "",
            "\tspin_lock_irqsave(&t->sighand->siglock, flags);",
            "\taction = &t->sighand->action[sig-1];",
            "\tignored = action->sa.sa_handler == SIG_IGN;",
            "\tblocked = sigismember(&t->blocked, sig);",
            "\tif (blocked || ignored || (handler != HANDLER_CURRENT)) {",
            "\t\taction->sa.sa_handler = SIG_DFL;",
            "\t\tif (handler == HANDLER_EXIT)",
            "\t\t\taction->sa.sa_flags |= SA_IMMUTABLE;",
            "\t\tif (blocked) {",
            "\t\t\tsigdelset(&t->blocked, sig);",
            "\t\t\trecalc_sigpending_and_wake(t);",
            "\t\t}",
            "\t}",
            "\t/*",
            "\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect",
            "\t * debugging to leave init killable. But HANDLER_EXIT is always fatal.",
            "\t */",
            "\tif (action->sa.sa_handler == SIG_DFL &&",
            "\t    (!t->ptrace || (handler == HANDLER_EXIT)))",
            "\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;",
            "\tret = send_signal_locked(sig, info, t, PIDTYPE_PID);",
            "\tspin_unlock_irqrestore(&t->sighand->siglock, flags);",
            "",
            "\treturn ret;",
            "}",
            "int force_sig_info(struct kernel_siginfo *info)",
            "{",
            "\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);",
            "}",
            "int zap_other_threads(struct task_struct *p)",
            "{",
            "\tstruct task_struct *t = p;",
            "\tint count = 0;",
            "",
            "\tp->signal->group_stop_count = 0;",
            "",
            "\twhile_each_thread(p, t) {",
            "\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);",
            "\t\t/* Don't require de_thread to wait for the vhost_worker */",
            "\t\tif ((t->flags & (PF_IO_WORKER | PF_USER_WORKER)) != PF_USER_WORKER)",
            "\t\t\tcount++;",
            "",
            "\t\t/* Don't bother with already dead threads */",
            "\t\tif (t->exit_state)",
            "\t\t\tcontinue;",
            "\t\tsigaddset(&t->pending.signal, SIGKILL);",
            "\t\tsignal_wake_up(t, 1);",
            "\t}",
            "",
            "\treturn count;",
            "}",
            "void lockdep_assert_task_sighand_held(struct task_struct *task)",
            "{",
            "\tstruct sighand_struct *sighand;",
            "",
            "\trcu_read_lock();",
            "\tsighand = rcu_dereference(task->sighand);",
            "\tif (sighand)",
            "\t\tlockdep_assert_held(&sighand->siglock);",
            "\telse",
            "\t\tWARN_ON_ONCE(1);",
            "\trcu_read_unlock();",
            "}",
            "int group_send_sig_info(int sig, struct kernel_siginfo *info,",
            "\t\t\tstruct task_struct *p, enum pid_type type)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = check_kill_permission(sig, info, p);",
            "\trcu_read_unlock();",
            "",
            "\tif (!ret && sig)",
            "\t\tret = do_send_sig_info(sig, info, p, type);",
            "",
            "\treturn ret;",
            "}",
            "int __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)",
            "{",
            "\tstruct task_struct *p = NULL;",
            "\tint retval, success;",
            "",
            "\tsuccess = 0;",
            "\tretval = -ESRCH;",
            "\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {",
            "\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);",
            "\t\tsuccess |= !err;",
            "\t\tretval = err;",
            "\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);",
            "\treturn success ? 0 : retval;",
            "}",
            "static int kill_pid_info_type(int sig, struct kernel_siginfo *info,",
            "\t\t\t\tstruct pid *pid, enum pid_type type)",
            "{",
            "\tint error = -ESRCH;",
            "\tstruct task_struct *p;",
            "",
            "\tfor (;;) {",
            "\t\trcu_read_lock();",
            "\t\tp = pid_task(pid, PIDTYPE_PID);",
            "\t\tif (p)",
            "\t\t\terror = group_send_sig_info(sig, info, p, type);",
            "\t\trcu_read_unlock();",
            "\t\tif (likely(!p || error != -ESRCH))",
            "\t\t\treturn error;",
            "\t\t/*",
            "\t\t * The task was unhashed in between, try again.  If it",
            "\t\t * is dead, pid_task() will return NULL, if we race with",
            "\t\t * de_thread() it will find the new leader.",
            "\t\t */",
            "\t}",
            "}"
          ],
          "function_name": "force_sig_info_to_task, force_sig_info, zap_other_threads, lockdep_assert_task_sighand_held, group_send_sig_info, __kill_pgrp_info, kill_pid_info_type",
          "description": "force_sig_info_to_task 强制将信号发送到指定任务，修改信号处理动作。zap_other_threads 向进程组所有线程发送 SIGKILL。lockdep_assert_task_sighand_held 断言持有信号处理锁。group_send_sig_info 和 __kill_pgrp_info 等函数实现向进程组或会话发送信号的通用接口。",
          "similarity": 0.5413998961448669
        }
      ]
    }
  ]
}