{
  "query": "security/目录下的访问控制代码",
  "timestamp": "2025-12-26 00:17:48",
  "retrieved_files": [
    {
      "source_file": "mm/maccess.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:36:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `maccess.c`\n\n---\n\n# maccess.c 技术文档\n\n## 1. 文件概述\n\n`maccess.c` 是 Linux 内核中用于安全访问内核或用户空间内存的关键模块。该文件提供了一系列“无故障”（nofault）内存访问函数，能够在不触发页错误（page fault）异常的前提下尝试读写指定地址的内存。这些函数主要用于调试、崩溃转储、性能分析等敏感上下文（如 NMI、IRQ 处理程序或禁用页错误的场景），确保即使访问非法或不可用内存也不会导致系统崩溃。\n\n## 2. 核心功能\n\n### 主要函数列表：\n\n- `copy_from_kernel_nofault(void *dst, const void *src, size_t size)`  \n  从内核地址安全复制数据到内核缓冲区，失败返回 `-EFAULT`。\n\n- `copy_to_kernel_nofault(void *dst, const void *src, size_t size)`  \n  向内核地址安全写入数据，失败返回 `-EFAULT`。\n\n- `strncpy_from_kernel_nofault(char *dst, const void *unsafe_addr, long count)`  \n  从内核地址安全复制以 NUL 结尾的字符串，最多 `count` 字节。\n\n- `copy_from_user_nofault(void *dst, const void __user *src, size_t size)`  \n  从用户空间地址安全复制数据到内核，失败返回 `-EFAULT`。\n\n- `copy_to_user_nofault(void __user *dst, const void *src, size_t size)`  \n  向用户空间地址安全写入数据，失败返回 `-EFAULT`。\n\n- `strncpy_from_user_nofault(char *dst, const void __user *unsafe_addr, long count)`  \n  从用户空间安全复制 NUL 结尾字符串到内核缓冲区。\n\n- `strnlen_user_nofault(const void __user *unsafe_addr, long count)`  \n  安全获取用户空间字符串长度（含终止符 NUL）。\n\n- `__copy_overflow(int size, unsigned long count)`  \n  检测缓冲区溢出并发出警告（通常由编译器内置检查调用）。\n\n### 可重载钩子函数：\n\n- `copy_from_kernel_nofault_allowed(const void *unsafe_src, size_t size)`  \n  弱符号函数，允许架构或安全模块限制哪些内核地址可被安全访问，默认返回 `true`。\n\n## 3. 关键实现\n\n### 3.1 无故障内存访问机制\n所有 `_nofault` 函数通过 `pagefault_disable()` / `pagefault_enable()` 对禁用内核页错误处理。在此期间，若发生缺页异常，内核不会进行常规的页分配或调度，而是直接跳转到错误标签（如 `Efault`），返回 `-EFAULT`。\n\n### 3.2 对齐优化复制策略\n`copy_from/to_kernel_nofault` 使用宏 `copy_from/to_kernel_nofault_loop` 实现按数据类型对齐的高效复制：\n- 首先尝试 8 字节（`u64`）对齐复制；\n- 若地址非 8 字节对齐但 4 字节对齐，则用 `u32`；\n- 依此类推至 `u16` 和 `u8`。\n此策略在支持高效非对齐访问的架构（如 x86）上可简化为字节复制；否则利用对齐提升性能。\n\n### 3.3 用户空间访问的安全封装\n用户空间访问函数（如 `copy_from_user_nofault`）在调用前执行双重检查：\n- `__access_ok()`：验证用户地址范围是否合法；\n- `nmi_uaccess_okay()`：确保当前上下文允许用户空间访问（如非 NMI 禁止状态）。\n随后使用原子版本的 `__copy_from/to_user_inatomic` 进行实际复制。\n\n### 3.4 字符串操作的边界处理\n`strncpy_*_nofault` 函数在复制过程中逐字节检查 NUL 终止符，并严格限制最大复制长度。若提前遇到 NUL，则返回实际长度（含 NUL）；若达到 `count` 限制，则强制在末尾添加 NUL 并返回 `count`。\n\n### 3.5 缓冲区溢出检测\n`__copy_overflow` 由 GCC 的 `-Wstringop-overflow` 等安全特性在检测到潜在溢出时调用，通过 `WARN()` 输出内核警告。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/uaccess.h>`：提供用户/内核空间访问原语（如 `__get_kernel_nofault`、`access_ok`）。\n  - `<linux/mm.h>`：内存管理相关定义。\n  - `<asm/tlb.h>`：部分架构相关的 TLB 操作（间接依赖）。\n  - `<linux/export.h>`：导出符号供其他模块使用。\n\n- **架构依赖**：\n  - `CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS`：决定是否启用对齐优化逻辑。\n  - `__get_kernel_nofault` / `__put_kernel_nofault`：由各架构在 `uaccess.h` 中实现，通常基于 `__builtin_expect` 和异常处理表。\n\n- **导出符号**：\n  - `copy_from_kernel_nofault`\n  - `copy_from_user_nofault`\n  - `copy_to_user_nofault`\n  - `__copy_overflow`\n\n## 5. 使用场景\n\n- **内核调试与崩溃分析**：  \n  在 Oops 或 Kdump 上下文中安全读取可疑内存地址，避免二次崩溃。\n\n- **性能监控与跟踪**：  \n  在 ftrace、perf 等子系统中，从任意内核地址提取数据而不干扰正常执行流。\n\n- **安全模块检查**：  \n  LSM（Linux Security Module）可通过重载 `copy_from_kernel_nofault_allowed` 限制对敏感内核数据的访问。\n\n- **中断/NMI 上下文操作**：  \n  在不能睡眠或处理页错误的高优先级上下文中（如 NMI watchdog），安全访问用户或内核内存。\n\n- **用户态辅助工具支持**：  \n  为 `/proc/kcore`、`/dev/mem` 等接口提供安全的内存读取后端，防止恶意用户地址导致内核 panic。",
      "similarity": 0.6131458878517151,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/maccess.c",
          "start_line": 177,
          "end_line": 211,
          "content": [
            "long strncpy_from_user_nofault(char *dst, const void __user *unsafe_addr,",
            "\t\t\t      long count)",
            "{",
            "\tlong ret;",
            "",
            "\tif (unlikely(count <= 0))",
            "\t\treturn 0;",
            "",
            "\tpagefault_disable();",
            "\tret = strncpy_from_user(dst, unsafe_addr, count);",
            "\tpagefault_enable();",
            "",
            "\tif (ret >= count) {",
            "\t\tret = count;",
            "\t\tdst[ret - 1] = '\\0';",
            "\t} else if (ret > 0) {",
            "\t\tret++;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "long strnlen_user_nofault(const void __user *unsafe_addr, long count)",
            "{",
            "\tint ret;",
            "",
            "\tpagefault_disable();",
            "\tret = strnlen_user(unsafe_addr, count);",
            "\tpagefault_enable();",
            "",
            "\treturn ret;",
            "}",
            "void __copy_overflow(int size, unsigned long count)",
            "{",
            "\tWARN(1, \"Buffer overflow detected (%d < %lu)!\\n\", size, count);",
            "}"
          ],
          "function_name": "strncpy_from_user_nofault, strnlen_user_nofault, __copy_overflow",
          "description": "提供用户空间字符串安全复制与长度查询接口，并包含缓冲区溢出检测警告函数，确保用户态内存访问可靠性。",
          "similarity": 0.5674288272857666
        },
        {
          "chunk_id": 0,
          "file_path": "mm/maccess.c",
          "start_line": 1,
          "end_line": 9,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Access kernel or user memory without faulting.",
            " */",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/tlb.h>",
            ""
          ],
          "function_name": null,
          "description": "定义内核和用户内存无故障访问相关头文件及导出符号，为后续函数实现提供基础支持。",
          "similarity": 0.5521895885467529
        },
        {
          "chunk_id": 1,
          "file_path": "mm/maccess.c",
          "start_line": 10,
          "end_line": 115,
          "content": [
            "bool __weak copy_from_kernel_nofault_allowed(const void *unsafe_src,",
            "\t\tsize_t size)",
            "{",
            "\treturn true;",
            "}",
            "long copy_from_kernel_nofault(void *dst, const void *src, size_t size)",
            "{",
            "\tunsigned long align = 0;",
            "",
            "\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS))",
            "\t\talign = (unsigned long)dst | (unsigned long)src;",
            "",
            "\tif (!copy_from_kernel_nofault_allowed(src, size))",
            "\t\treturn -ERANGE;",
            "",
            "\tpagefault_disable();",
            "\tif (!(align & 7))",
            "\t\tcopy_from_kernel_nofault_loop(dst, src, size, u64, Efault);",
            "\tif (!(align & 3))",
            "\t\tcopy_from_kernel_nofault_loop(dst, src, size, u32, Efault);",
            "\tif (!(align & 1))",
            "\t\tcopy_from_kernel_nofault_loop(dst, src, size, u16, Efault);",
            "\tcopy_from_kernel_nofault_loop(dst, src, size, u8, Efault);",
            "\tpagefault_enable();",
            "\treturn 0;",
            "Efault:",
            "\tpagefault_enable();",
            "\treturn -EFAULT;",
            "}",
            "long copy_to_kernel_nofault(void *dst, const void *src, size_t size)",
            "{",
            "\tunsigned long align = 0;",
            "",
            "\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS))",
            "\t\talign = (unsigned long)dst | (unsigned long)src;",
            "",
            "\tpagefault_disable();",
            "\tif (!(align & 7))",
            "\t\tcopy_to_kernel_nofault_loop(dst, src, size, u64, Efault);",
            "\tif (!(align & 3))",
            "\t\tcopy_to_kernel_nofault_loop(dst, src, size, u32, Efault);",
            "\tif (!(align & 1))",
            "\t\tcopy_to_kernel_nofault_loop(dst, src, size, u16, Efault);",
            "\tcopy_to_kernel_nofault_loop(dst, src, size, u8, Efault);",
            "\tpagefault_enable();",
            "\treturn 0;",
            "Efault:",
            "\tpagefault_enable();",
            "\treturn -EFAULT;",
            "}",
            "long strncpy_from_kernel_nofault(char *dst, const void *unsafe_addr, long count)",
            "{",
            "\tconst void *src = unsafe_addr;",
            "",
            "\tif (unlikely(count <= 0))",
            "\t\treturn 0;",
            "\tif (!copy_from_kernel_nofault_allowed(unsafe_addr, count))",
            "\t\treturn -ERANGE;",
            "",
            "\tpagefault_disable();",
            "\tdo {",
            "\t\t__get_kernel_nofault(dst, src, u8, Efault);",
            "\t\tdst++;",
            "\t\tsrc++;",
            "\t} while (dst[-1] && src - unsafe_addr < count);",
            "\tpagefault_enable();",
            "",
            "\tdst[-1] = '\\0';",
            "\treturn src - unsafe_addr;",
            "Efault:",
            "\tpagefault_enable();",
            "\tdst[0] = '\\0';",
            "\treturn -EFAULT;",
            "}",
            "long copy_from_user_nofault(void *dst, const void __user *src, size_t size)",
            "{",
            "\tlong ret = -EFAULT;",
            "",
            "\tif (!__access_ok(src, size))",
            "\t\treturn ret;",
            "",
            "\tif (!nmi_uaccess_okay())",
            "\t\treturn ret;",
            "",
            "\tpagefault_disable();",
            "\tret = __copy_from_user_inatomic(dst, src, size);",
            "\tpagefault_enable();",
            "",
            "\tif (ret)",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "}",
            "long copy_to_user_nofault(void __user *dst, const void *src, size_t size)",
            "{",
            "\tlong ret = -EFAULT;",
            "",
            "\tif (access_ok(dst, size)) {",
            "\t\tpagefault_disable();",
            "\t\tret = __copy_to_user_inatomic(dst, src, size);",
            "\t\tpagefault_enable();",
            "\t}",
            "",
            "\tif (ret)",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "copy_from_kernel_nofault_allowed, copy_from_kernel_nofault, copy_to_kernel_nofault, strncpy_from_kernel_nofault, copy_from_user_nofault, copy_to_user_nofault",
          "description": "实现内核与用户空间内存安全复制函数，通过分对齐类型处理和页面故障控制，在不触发缺页异常情况下完成数据拷贝。",
          "similarity": 0.5429829359054565
        }
      ]
    },
    {
      "source_file": "kernel/pid_sysctl.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:17:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid_sysctl.h`\n\n---\n\n# `pid_sysctl.h` 技术文档\n\n## 1. 文件概述\n\n`pid_sysctl.h` 是 Linux 内核中用于定义与 PID 命名空间（`pid_namespace`）相关的系统控制（sysctl）接口的头文件。其核心功能是提供对 `memfd_noexec` 系统策略的运行时配置支持，该策略用于控制通过 `memfd_create()` 创建的内存文件是否允许执行代码。该配置具有层级继承语义：子 PID 命名空间的策略不能比其父命名空间更宽松，以确保安全策略的向下兼容性和强制性。\n\n## 2. 核心功能\n\n### 函数\n\n- **`pid_mfd_noexec_dointvec_minmax`**  \n  自定义的 sysctl 处理函数，用于读写 `memfd_noexec` 策略值。在写入时执行权限检查和策略继承约束验证。\n\n- **`register_pid_ns_sysctl_table_vm`**  \n  内联函数，用于向内核 sysctl 子系统注册 `vm.memfd_noexec` 控制项（仅在 `CONFIG_SYSCTL` 和 `CONFIG_MEMFD_CREATE` 同时启用时有效）。\n\n### 数据结构\n\n- **`pid_ns_ctl_table_vm`**  \n  `ctl_table` 类型的静态数组，定义了 `vm.memfd_noexec` sysctl 条目，包括其名称、数据指针、访问权限、处理函数及取值范围（0 到 2）。\n\n## 3. 关键实现\n\n- **权限控制**：  \n  在写入 `memfd_noexec` 值时，调用 `ns_capable(ns->user_ns, CAP_SYS_ADMIN)` 检查当前任务是否在对应用户命名空间中拥有 `CAP_SYS_ADMIN` 能力，防止非特权用户修改安全策略。\n\n- **策略继承约束**：  \n  通过 `pidns_memfd_noexec_scope(ns->parent)` 获取父 PID 命名空间的策略值 `parent_scope`，并确保当前命名空间的策略值 `scope` 不小于父策略（即不能更宽松）。实际写入前使用 `max(READ_ONCE(ns->memfd_noexec_scope), parent_scope)` 保证该约束。\n\n- **原子读写**：  \n  使用 `READ_ONCE()` 和 `WRITE_ONCE()` 对 `ns->memfd_noexec_scope` 进行访问，确保在并发环境下内存访问的可见性和顺序性。\n\n- **sysctl 注册**：  \n  通过 `register_sysctl(\"vm\", pid_ns_ctl_table_vm)` 将控制项注册到 `/proc/sys/vm/memfd_noexec` 路径下，供用户空间通过标准 sysctl 接口访问。\n\n- **条件编译**：  \n  整个功能仅在 `CONFIG_SYSCTL`（启用 sysctl 支持）和 `CONFIG_MEMFD_CREATE`（启用 memfd_create 系统调用）同时配置时编译，否则 `register_pid_ns_sysctl_table_vm` 为空内联函数，避免代码膨胀。\n\n## 4. 依赖关系\n\n- **`<linux/pid_namespace.h>`**：  \n  提供 `struct pid_namespace` 定义及辅助函数如 `task_active_pid_ns()` 和 `pidns_memfd_noexec_scope()`。\n\n- **`CONFIG_SYSCTL`**：  \n  内核配置选项，启用 sysctl 框架支持，提供 `register_sysctl`、`proc_dointvec_minmax` 等接口。\n\n- **`CONFIG_MEMFD_CREATE`**：  \n  内核配置选项，启用 `memfd_create()` 系统调用及相关功能（如 `memfd_noexec_scope` 字段）。\n\n- **能力子系统（Capabilities）**：  \n  依赖 `ns_capable()` 进行命名空间感知的权限检查。\n\n## 5. 使用场景\n\n- **安全策略配置**：  \n  系统管理员或容器运行时可通过写入 `/proc/sys/vm/memfd_noexec` 设置当前 PID 命名空间中 `memfd` 文件的执行限制级别（0=允许执行，1=禁止执行但可覆盖，2=严格禁止执行），用于防御基于内存文件的代码注入攻击。\n\n- **容器隔离**：  \n  在容器化环境中，不同容器运行在独立的 PID 命名空间中。父命名空间（如宿主机）可设置较严格的 `memfd_noexec` 策略，子容器无法降低该策略级别，从而实现自上而下的安全策略强制。\n\n- **运行时动态调整**：  \n  允许在系统运行期间动态调整 `memfd` 执行策略，无需重启或重新加载内核模块，提升系统灵活性与安全性。",
      "similarity": 0.6081253290176392,
      "chunks": []
    },
    {
      "source_file": "kernel/sched/core_sched.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:00:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\core_sched.c`\n\n---\n\n# `sched/core_sched.c` 技术文档\n\n## 1. 文件概述\n\n`sched/core_sched.c` 是 Linux 内核调度器中用于实现 **核心调度（Core Scheduling）** 功能的核心文件之一。核心调度是一种安全机制，旨在防止来自不同安全上下文的任务在同一个物理 CPU 核心（特别是超线程/SMT 共享核心）上并发执行，从而缓解侧信道攻击（如 Spectre、MDS 等）。\n\n该文件主要负责管理任务的 **调度 cookie**（`core_cookie`），通过引用计数的 cookie 对象将具有相同安全上下文的任务分组，确保只有拥有相同 cookie 的任务才能在同一个 CPU 核心上并发运行。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct sched_core_cookie`**  \n  表示一个调度 cookie，仅包含一个引用计数器 `refcnt`。其内存地址本身即作为 cookie 值使用。\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `sched_core_alloc_cookie()` | 分配一个新的 `sched_core_cookie` 对象，初始化引用计数为 1，并启用核心调度全局状态。返回 cookie 地址（转换为 `unsigned long`）。 |\n| `sched_core_put_cookie(unsigned long cookie)` | 释放 cookie 引用；若引用计数归零，则释放内存并关闭核心调度全局状态。 |\n| `sched_core_get_cookie(unsigned long cookie)` | 增加 cookie 引用计数，返回原 cookie 值。 |\n| `sched_core_update_cookie(struct task_struct *p, unsigned long cookie)` | 原子地更新任务 `p` 的 `core_cookie`，处理任务在运行队列中的入队/出队，并在必要时触发重调度。 |\n| `sched_core_clone_cookie(struct task_struct *p)` | 安全地复制任务 `p` 的当前 cookie（带锁保护），用于 fork 或共享操作。 |\n| `sched_core_fork(struct task_struct *p)` | 在 `fork()` 时初始化子任务的核心调度状态，继承父进程的 cookie。 |\n| `sched_core_free(struct task_struct *p)` | 在任务退出时释放其持有的 cookie 引用。 |\n| `__sched_core_set(struct task_struct *p, unsigned long cookie)` | 设置任务 `p` 的 cookie，自动处理引用计数的获取与释放。 |\n| `sched_core_share_pid(...)` | 用户空间通过 `prctl(PR_SCHED_CORE, ...)` 调用的核心接口，支持创建、查询、共享 cookie。 |\n| `__sched_core_account_forceidle(struct rq *rq)` | （仅当 `CONFIG_SCHEDSTATS` 启用）统计核心强制空闲（force-idle）时间，并分摊到相关任务。 |\n| `__sched_core_tick(struct rq *rq)` | 在调度 tick 中调用，用于更新强制空闲时间统计。 |\n\n## 3. 关键实现\n\n### Cookie 生命周期管理\n- Cookie 通过 `kmalloc` 动态分配，其地址作为唯一标识。\n- 使用 `refcount_t` 实现线程安全的引用计数。\n- `sched_core_get()` / `sched_core_put()` 控制全局核心调度使能状态。\n\n### 任务 Cookie 更新\n- 在 `task_rq_lock()` 保护下更新 `p->core_cookie`，确保调度器一致性。\n- 若任务已在运行队列中，先出队再根据新 cookie 决定是否重新入队。\n- 若任务正在 CPU 上运行，调用 `resched_curr()` 触发重调度，以确保新 cookie 策略立即生效。\n\n### 安全访问控制\n- 通过 `ptrace_may_access()` 检查调用者是否有权限操作目标进程的 cookie。\n- 仅当系统存在 SMT（超线程）时（`sched_smt_present` 为真），才允许使用核心调度功能。\n\n### prctl 接口支持\n- 支持四种命令：\n  - `PR_SCHED_CORE_CREATE`：创建新 cookie。\n  - `PR_SCHED_CORE_SHARE_TO`：将当前进程的 cookie 应用于目标进程（或进程组）。\n  - `PR_SCHED_CORE_SHARE_FROM`：将目标进程的 cookie 应用于当前进程。\n  - `PR_SCHED_CORE_GET`：获取目标进程的 cookie 哈希值（用于用户空间识别）。\n- 支持作用域：线程（`PIDTYPE_PID`）、线程组（`PIDTYPE_TGID`）、进程组（`PIDTYPE_PGID`）。\n\n### 强制空闲时间统计（`CONFIG_SCHEDSTATS`）\n- 当核心因 cookie 不兼容而进入强制空闲状态时，记录空闲时间。\n- 时间按 `core_forceidle_count / core_forceidle_occupation` 比例分摊到所有相关 CPU 上的非 idle 任务。\n- 通过 `__account_forceidle_time()` 更新任务的调度统计信息。\n\n## 4. 依赖关系\n\n- **调度器核心**：依赖 `kernel/sched/` 下的通用调度器基础设施，如 `task_rq_lock()`、`resched_curr()`、`rq` 结构等。\n- **SMT 检测**：依赖 `sched_smt_present` 静态分支判断系统是否支持超线程。\n- **内存管理**：使用 `kmalloc`/`kfree` 进行动态内存分配。\n- **进程管理**：依赖 `find_task_by_vpid()`、`tasklist_lock`、`do_each_pid_thread` 等进程遍历机制。\n- **安全机制**：依赖 `ptrace_may_access()` 进行权限检查。\n- **调度统计**：`__sched_core_account_forceidle` 依赖 `CONFIG_SCHEDSTATS` 和 `__account_forceidle_time`。\n\n## 5. 使用场景\n\n- **安全敏感应用**：如浏览器、虚拟机监控器（VMM）、加密服务等，需防止跨任务的侧信道攻击。\n- **用户空间控制**：通过 `prctl(PR_SCHED_CORE, ...)` 接口，应用程序可显式创建和共享调度 cookie，将信任的任务分组。\n- **进程 fork 行为**：子进程自动继承父进程的 cookie，确保同源任务保持调度兼容性。\n- **系统资源隔离**：在多租户或容器环境中，确保不同租户的任务不会在同一个物理核心上并发执行。\n- **性能调优与监控**：通过 `CONFIG_SCHEDSTATS` 收集核心强制空闲开销，评估安全策略对性能的影响。",
      "similarity": 0.6041845679283142,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/core_sched.c",
          "start_line": 11,
          "end_line": 216,
          "content": [
            "static unsigned long sched_core_alloc_cookie(void)",
            "{",
            "\tstruct sched_core_cookie *ck = kmalloc(sizeof(*ck), GFP_KERNEL);",
            "\tif (!ck)",
            "\t\treturn 0;",
            "",
            "\trefcount_set(&ck->refcnt, 1);",
            "\tsched_core_get();",
            "",
            "\treturn (unsigned long)ck;",
            "}",
            "static void sched_core_put_cookie(unsigned long cookie)",
            "{",
            "\tstruct sched_core_cookie *ptr = (void *)cookie;",
            "",
            "\tif (ptr && refcount_dec_and_test(&ptr->refcnt)) {",
            "\t\tkfree(ptr);",
            "\t\tsched_core_put();",
            "\t}",
            "}",
            "static unsigned long sched_core_get_cookie(unsigned long cookie)",
            "{",
            "\tstruct sched_core_cookie *ptr = (void *)cookie;",
            "",
            "\tif (ptr)",
            "\t\trefcount_inc(&ptr->refcnt);",
            "",
            "\treturn cookie;",
            "}",
            "static unsigned long sched_core_update_cookie(struct task_struct *p,",
            "\t\t\t\t\t      unsigned long cookie)",
            "{",
            "\tunsigned long old_cookie;",
            "\tstruct rq_flags rf;",
            "\tstruct rq *rq;",
            "",
            "\trq = task_rq_lock(p, &rf);",
            "",
            "\t/*",
            "\t * Since creating a cookie implies sched_core_get(), and we cannot set",
            "\t * a cookie until after we've created it, similarly, we cannot destroy",
            "\t * a cookie until after we've removed it, we must have core scheduling",
            "\t * enabled here.",
            "\t */",
            "\tSCHED_WARN_ON((p->core_cookie || cookie) && !sched_core_enabled(rq));",
            "",
            "\tif (sched_core_enqueued(p))",
            "\t\tsched_core_dequeue(rq, p, DEQUEUE_SAVE);",
            "",
            "\told_cookie = p->core_cookie;",
            "\tp->core_cookie = cookie;",
            "",
            "\t/*",
            "\t * Consider the cases: !prev_cookie and !cookie.",
            "\t */",
            "\tif (cookie && task_on_rq_queued(p))",
            "\t\tsched_core_enqueue(rq, p);",
            "",
            "\t/*",
            "\t * If task is currently running, it may not be compatible anymore after",
            "\t * the cookie change, so enter the scheduler on its CPU to schedule it",
            "\t * away.",
            "\t *",
            "\t * Note that it is possible that as a result of this cookie change, the",
            "\t * core has now entered/left forced idle state. Defer accounting to the",
            "\t * next scheduling edge, rather than always forcing a reschedule here.",
            "\t */",
            "\tif (task_on_cpu(rq, p))",
            "\t\tresched_curr(rq);",
            "",
            "\ttask_rq_unlock(rq, p, &rf);",
            "",
            "\treturn old_cookie;",
            "}",
            "static unsigned long sched_core_clone_cookie(struct task_struct *p)",
            "{",
            "\tunsigned long cookie, flags;",
            "",
            "\traw_spin_lock_irqsave(&p->pi_lock, flags);",
            "\tcookie = sched_core_get_cookie(p->core_cookie);",
            "\traw_spin_unlock_irqrestore(&p->pi_lock, flags);",
            "",
            "\treturn cookie;",
            "}",
            "void sched_core_fork(struct task_struct *p)",
            "{",
            "\tRB_CLEAR_NODE(&p->core_node);",
            "\tp->core_cookie = sched_core_clone_cookie(current);",
            "}",
            "void sched_core_free(struct task_struct *p)",
            "{",
            "\tsched_core_put_cookie(p->core_cookie);",
            "}",
            "static void __sched_core_set(struct task_struct *p, unsigned long cookie)",
            "{",
            "\tcookie = sched_core_get_cookie(cookie);",
            "\tcookie = sched_core_update_cookie(p, cookie);",
            "\tsched_core_put_cookie(cookie);",
            "}",
            "int sched_core_share_pid(unsigned int cmd, pid_t pid, enum pid_type type,",
            "\t\t\t unsigned long uaddr)",
            "{",
            "\tunsigned long cookie = 0, id = 0;",
            "\tstruct task_struct *task, *p;",
            "\tstruct pid *grp;",
            "\tint err = 0;",
            "",
            "\tif (!static_branch_likely(&sched_smt_present))",
            "\t\treturn -ENODEV;",
            "",
            "\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_THREAD != PIDTYPE_PID);",
            "\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_THREAD_GROUP != PIDTYPE_TGID);",
            "\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_PROCESS_GROUP != PIDTYPE_PGID);",
            "",
            "\tif (type > PIDTYPE_PGID || cmd >= PR_SCHED_CORE_MAX || pid < 0 ||",
            "\t    (cmd != PR_SCHED_CORE_GET && uaddr))",
            "\t\treturn -EINVAL;",
            "",
            "\trcu_read_lock();",
            "\tif (pid == 0) {",
            "\t\ttask = current;",
            "\t} else {",
            "\t\ttask = find_task_by_vpid(pid);",
            "\t\tif (!task) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\treturn -ESRCH;",
            "\t\t}",
            "\t}",
            "\tget_task_struct(task);",
            "\trcu_read_unlock();",
            "",
            "\t/*",
            "\t * Check if this process has the right to modify the specified",
            "\t * process. Use the regular \"ptrace_may_access()\" checks.",
            "\t */",
            "\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\terr = -EPERM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tswitch (cmd) {",
            "\tcase PR_SCHED_CORE_GET:",
            "\t\tif (type != PIDTYPE_PID || uaddr & 7) {",
            "\t\t\terr = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tcookie = sched_core_clone_cookie(task);",
            "\t\tif (cookie) {",
            "\t\t\t/* XXX improve ? */",
            "\t\t\tptr_to_hashval((void *)cookie, &id);",
            "\t\t}",
            "\t\terr = put_user(id, (u64 __user *)uaddr);",
            "\t\tgoto out;",
            "",
            "\tcase PR_SCHED_CORE_CREATE:",
            "\t\tcookie = sched_core_alloc_cookie();",
            "\t\tif (!cookie) {",
            "\t\t\terr = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tbreak;",
            "",
            "\tcase PR_SCHED_CORE_SHARE_TO:",
            "\t\tcookie = sched_core_clone_cookie(current);",
            "\t\tbreak;",
            "",
            "\tcase PR_SCHED_CORE_SHARE_FROM:",
            "\t\tif (type != PIDTYPE_PID) {",
            "\t\t\terr = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tcookie = sched_core_clone_cookie(task);",
            "\t\t__sched_core_set(current, cookie);",
            "\t\tgoto out;",
            "",
            "\tdefault:",
            "\t\terr = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (type == PIDTYPE_PID) {",
            "\t\t__sched_core_set(task, cookie);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tgrp = task_pid_type(task, type);",
            "",
            "\tdo_each_pid_thread(grp, type, p) {",
            "\t\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS)) {",
            "\t\t\terr = -EPERM;",
            "\t\t\tgoto out_tasklist;",
            "\t\t}",
            "\t} while_each_pid_thread(grp, type, p);",
            "",
            "\tdo_each_pid_thread(grp, type, p) {",
            "\t\t__sched_core_set(p, cookie);",
            "\t} while_each_pid_thread(grp, type, p);",
            "out_tasklist:",
            "\tread_unlock(&tasklist_lock);",
            "",
            "out:",
            "\tsched_core_put_cookie(cookie);",
            "\tput_task_struct(task);",
            "\treturn err;",
            "}"
          ],
          "function_name": "sched_core_alloc_cookie, sched_core_put_cookie, sched_core_get_cookie, sched_core_update_cookie, sched_core_clone_cookie, sched_core_fork, sched_core_free, __sched_core_set, sched_core_share_pid",
          "description": "实现了核心调度 cookie 的分配、释放、获取和更新机制，包含 cookie 分配/回收、任务核心绑定变更、进程克隆共享及核心调度策略控制等功能",
          "similarity": 0.5055655241012573
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/core_sched.c",
          "start_line": 1,
          "end_line": 10,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "/*",
            " * A simple wrapper around refcount. An allocated sched_core_cookie's",
            " * address is used to compute the cookie of the task.",
            " */",
            "struct sched_core_cookie {",
            "\trefcount_t refcnt;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义了 sched_core_cookie 结构体，用于核心调度系统中管理任务的 cookie 引用计数，通过结构体地址计算 cookie 值",
          "similarity": 0.4881480932235718
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/core_sched.c",
          "start_line": 240,
          "end_line": 297,
          "content": [
            "void __sched_core_account_forceidle(struct rq *rq)",
            "{",
            "\tconst struct cpumask *smt_mask = cpu_smt_mask(cpu_of(rq));",
            "\tu64 delta, now = rq_clock(rq->core);",
            "\tstruct rq *rq_i;",
            "\tstruct task_struct *p;",
            "\tint i;",
            "",
            "\tlockdep_assert_rq_held(rq);",
            "",
            "\tWARN_ON_ONCE(!rq->core->core_forceidle_count);",
            "",
            "\tif (rq->core->core_forceidle_start == 0)",
            "\t\treturn;",
            "",
            "\tdelta = now - rq->core->core_forceidle_start;",
            "\tif (unlikely((s64)delta <= 0))",
            "\t\treturn;",
            "",
            "\trq->core->core_forceidle_start = now;",
            "",
            "\tif (WARN_ON_ONCE(!rq->core->core_forceidle_occupation)) {",
            "\t\t/* can't be forced idle without a running task */",
            "\t} else if (rq->core->core_forceidle_count > 1 ||",
            "\t\t   rq->core->core_forceidle_occupation > 1) {",
            "\t\t/*",
            "\t\t * For larger SMT configurations, we need to scale the charged",
            "\t\t * forced idle amount since there can be more than one forced",
            "\t\t * idle sibling and more than one running cookied task.",
            "\t\t */",
            "\t\tdelta *= rq->core->core_forceidle_count;",
            "\t\tdelta = div_u64(delta, rq->core->core_forceidle_occupation);",
            "\t}",
            "",
            "\tfor_each_cpu(i, smt_mask) {",
            "\t\trq_i = cpu_rq(i);",
            "\t\tp = rq_i->core_pick ?: rq_i->curr;",
            "",
            "\t\tif (p == rq_i->idle)",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Note: this will account forceidle to the current cpu, even",
            "\t\t * if it comes from our SMT sibling.",
            "\t\t */",
            "\t\t__account_forceidle_time(p, delta);",
            "\t}",
            "}",
            "void __sched_core_tick(struct rq *rq)",
            "{",
            "\tif (!rq->core->core_forceidle_count)",
            "\t\treturn;",
            "",
            "\tif (rq != rq->core)",
            "\t\tupdate_rq_clock(rq->core);",
            "",
            "\t__sched_core_account_forceidle(rq);",
            "}"
          ],
          "function_name": "__sched_core_account_forceidle, __sched_core_tick",
          "description": "提供强制空闲时间统计功能，通过遍历 SMT 核心计算并分摊强制空闲时间消耗，tick 中断触发强制空闲会计入逻辑",
          "similarity": 0.4355126917362213
        }
      ]
    }
  ]
}