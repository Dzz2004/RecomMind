{
  "query": "等待队列在互斥锁中的实现",
  "timestamp": "2025-12-26 00:54:18",
  "retrieved_files": [
    {
      "source_file": "kernel/sched/wait.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:20:46\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\wait.c`\n\n---\n\n# `sched/wait.c` 技术文档\n\n## 1. 文件概述\n\n`sched/wait.c` 是 Linux 内核中实现通用等待队列（wait queue）机制的核心文件。该机制用于线程在特定条件满足前进入睡眠状态，并在条件就绪时被唤醒。文件提供了等待队列的初始化、添加/移除等待项、以及多种唤醒策略（包括普通唤醒、独占唤醒、优先级唤醒、同步唤醒等）的实现，是内核同步与调度子系统的重要组成部分。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`__init_waitqueue_head`**  \n  初始化一个等待队列头，设置自旋锁、锁类信息和空链表。\n\n- **`add_wait_queue`**  \n  将一个非独占等待项添加到等待队列头部。\n\n- **`add_wait_queue_exclusive`**  \n  将一个独占等待项添加到等待队列尾部（用于避免“惊群”问题）。\n\n- **`add_wait_queue_priority`**  \n  添加具有独占性和优先级标志的等待项，插入到队列头部。\n\n- **`remove_wait_queue`**  \n  从等待队列中安全移除指定的等待项。\n\n- **`__wake_up` / `__wake_up_common`**  \n  核心唤醒函数，支持唤醒非独占任务和指定数量的独占任务。\n\n- **`__wake_up_sync_key` / `__wake_up_locked_sync_key`**  \n  同步唤醒函数，避免目标任务被迁移到其他 CPU，减少缓存颠簸。\n\n- **`__wake_up_on_current_cpu`**  \n  仅在当前 CPU 上唤醒一个任务。\n\n- **`__wake_up_pollfree`**  \n  专用于 poll 机制的唤醒，发送 `POLLFREE` 事件并验证队列已清空。\n\n- **`prepare_to_wait` / `prepare_to_wait_exclusive`**  \n  将当前任务加入等待队列并设置其睡眠状态，后者返回是否为队列中首个等待者。\n\n### 关键数据结构\n\n- **`struct wait_queue_head`**  \n  等待队列头，包含自旋锁 `lock` 和双向链表 `head`。\n\n- **`struct wait_queue_entry`**  \n  等待队列项，包含回调函数 `func`、任务指针、标志位（如 `WQ_FLAG_EXCLUSIVE`、`WQ_FLAG_PRIORITY`）及链表节点。\n\n## 3. 关键实现\n\n### 等待队列组织策略\n\n- **非独占任务**：通过 `add_wait_queue` 添加至队列**头部**，唤醒时优先处理。\n- **独占任务**：通过 `add_wait_queue_exclusive` 添加至队列**尾部**，确保在非独占任务之后唤醒，避免多个独占任务同时被唤醒（解决“惊群”问题）。\n- **优先级任务**：通过 `add_wait_queue_priority` 添加至**头部**，并标记为独占+优先级，可在唤醒时优先消费事件。\n\n### 唤醒逻辑（`__wake_up_common`）\n\n1. 遍历等待队列中的每个等待项。\n2. 调用其回调函数 `func`（通常为 `default_wake_function`），尝试唤醒对应任务。\n3. 若回调返回正值且该项为独占任务，则减少 `nr_exclusive` 计数；当计数归零时停止唤醒。\n4. 非独占任务始终被唤醒（除非回调返回负值中断流程）。\n\n### 内存屏障与 SMP 安全\n\n- 在 `prepare_to_wait` 中，**先加锁添加等待项，再调用 `set_current_state()`**，确保 SMP 系统下唤醒者能看到完整的等待状态，避免竞态。\n- 所有对外接口均使用 `spin_lock_irqsave`/`restore` 保证中断上下文安全。\n\n### 同步唤醒优化\n\n- `WF_SYNC` 标志告知调度器：唤醒者即将主动调度（如调用 `schedule()`），因此被唤醒任务应尽量留在当前 CPU，减少迁移开销。\n- 在单处理器（UP）系统上可避免不必要的抢占。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `try_to_wake_up()` 等底层唤醒函数（定义于 `kernel/sched/core.c`）。\n- **锁调试机制**：使用 `lockdep_set_class_and_name` 进行锁类跟踪（`kernel/locking/lockdep.c`）。\n- **内存屏障原语**：依赖架构相关的内存屏障实现（如 `smp_mb()`）。\n- **poll 机制**：`__wake_up_pollfree` 与 `fs/select.c` 中的 poll 实现紧密耦合。\n- **EXPORT_SYMBOL**：向内核其他模块（如驱动、文件系统）导出通用等待/唤醒接口。\n\n## 5. 使用场景\n\n- **设备驱动**：驱动程序在无数据可读/写时将进程加入等待队列，硬件就绪时唤醒。\n- **文件系统**：如 inode 锁、页缓存 I/O 等待。\n- **IPC 机制**：信号量、互斥锁、完成量（completion）等同步原语的底层实现。\n- **网络子系统**：socket 接收/发送缓冲区满或空时的阻塞等待。\n- **内核线程同步**：工作者线程等待工作项到达。\n- **poll/epoll**：通过 `poll_wait()` 注册等待队列，事件触发时唤醒用户进程。",
      "similarity": 0.5968567728996277,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/wait.c",
          "start_line": 8,
          "end_line": 111,
          "content": [
            "void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *key)",
            "{",
            "\tspin_lock_init(&wq_head->lock);",
            "\tlockdep_set_class_and_name(&wq_head->lock, key, name);",
            "\tINIT_LIST_HEAD(&wq_head->head);",
            "}",
            "void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)",
            "{",
            "\tunsigned long flags;",
            "",
            "\twq_entry->flags &= ~WQ_FLAG_EXCLUSIVE;",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\t__add_wait_queue(wq_head, wq_entry);",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "}",
            "void add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)",
            "{",
            "\tunsigned long flags;",
            "",
            "\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\t__add_wait_queue_entry_tail(wq_head, wq_entry);",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "}",
            "void add_wait_queue_priority(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)",
            "{",
            "\tunsigned long flags;",
            "",
            "\twq_entry->flags |= WQ_FLAG_EXCLUSIVE | WQ_FLAG_PRIORITY;",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\t__add_wait_queue(wq_head, wq_entry);",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "}",
            "void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\t__remove_wait_queue(wq_head, wq_entry);",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "}",
            "static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,",
            "\t\t\tint nr_exclusive, int wake_flags, void *key)",
            "{",
            "\twait_queue_entry_t *curr, *next;",
            "",
            "\tlockdep_assert_held(&wq_head->lock);",
            "",
            "\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);",
            "",
            "\tif (&curr->entry == &wq_head->head)",
            "\t\treturn nr_exclusive;",
            "",
            "\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {",
            "\t\tunsigned flags = curr->flags;",
            "\t\tint ret;",
            "",
            "\t\tret = curr->func(curr, mode, wake_flags, key);",
            "\t\tif (ret < 0)",
            "\t\t\tbreak;",
            "\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn nr_exclusive;",
            "}",
            "static int __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,",
            "\t\t\tint nr_exclusive, int wake_flags, void *key)",
            "{",
            "\tunsigned long flags;",
            "\tint remaining;",
            "",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\tremaining = __wake_up_common(wq_head, mode, nr_exclusive, wake_flags,",
            "\t\t\tkey);",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "",
            "\treturn nr_exclusive - remaining;",
            "}",
            "int __wake_up(struct wait_queue_head *wq_head, unsigned int mode,",
            "\t      int nr_exclusive, void *key)",
            "{",
            "\treturn __wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);",
            "}",
            "void __wake_up_on_current_cpu(struct wait_queue_head *wq_head, unsigned int mode, void *key)",
            "{",
            "\t__wake_up_common_lock(wq_head, mode, 1, WF_CURRENT_CPU, key);",
            "}",
            "void __wake_up_locked(struct wait_queue_head *wq_head, unsigned int mode, int nr)",
            "{",
            "\t__wake_up_common(wq_head, mode, nr, 0, NULL);",
            "}",
            "void __wake_up_locked_key(struct wait_queue_head *wq_head, unsigned int mode, void *key)",
            "{",
            "\t__wake_up_common(wq_head, mode, 1, 0, key);",
            "}",
            "void __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,",
            "\t\t\tvoid *key)",
            "{",
            "\tif (unlikely(!wq_head))",
            "\t\treturn;",
            "",
            "\t__wake_up_common_lock(wq_head, mode, 1, WF_SYNC, key);",
            "}"
          ],
          "function_name": "__init_waitqueue_head, add_wait_queue, add_wait_queue_exclusive, add_wait_queue_priority, remove_wait_queue, __wake_up_common, __wake_up_common_lock, __wake_up, __wake_up_on_current_cpu, __wake_up_locked, __wake_up_locked_key, __wake_up_sync_key",
          "description": "实现等待队列核心管理函数，包含初始化头结构、添加/移除等待项、唤醒逻辑及多种唤醒变体，通过自旋锁保护并发访问",
          "similarity": 0.689075767993927
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sched/wait.c",
          "start_line": 193,
          "end_line": 306,
          "content": [
            "void __wake_up_locked_sync_key(struct wait_queue_head *wq_head,",
            "\t\t\t       unsigned int mode, void *key)",
            "{",
            "        __wake_up_common(wq_head, mode, 1, WF_SYNC, key);",
            "}",
            "void __wake_up_sync(struct wait_queue_head *wq_head, unsigned int mode)",
            "{",
            "\t__wake_up_sync_key(wq_head, mode, NULL);",
            "}",
            "void __wake_up_pollfree(struct wait_queue_head *wq_head)",
            "{",
            "\t__wake_up(wq_head, TASK_NORMAL, 0, poll_to_key(EPOLLHUP | POLLFREE));",
            "\t/* POLLFREE must have cleared the queue. */",
            "\tWARN_ON_ONCE(waitqueue_active(wq_head));",
            "}",
            "void",
            "prepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)",
            "{",
            "\tunsigned long flags;",
            "",
            "\twq_entry->flags &= ~WQ_FLAG_EXCLUSIVE;",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\tif (list_empty(&wq_entry->entry))",
            "\t\t__add_wait_queue(wq_head, wq_entry);",
            "\tset_current_state(state);",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "}",
            "bool",
            "prepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)",
            "{",
            "\tunsigned long flags;",
            "\tbool was_empty = false;",
            "",
            "\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\tif (list_empty(&wq_entry->entry)) {",
            "\t\twas_empty = list_empty(&wq_head->head);",
            "\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);",
            "\t}",
            "\tset_current_state(state);",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "\treturn was_empty;",
            "}",
            "void init_wait_entry(struct wait_queue_entry *wq_entry, int flags)",
            "{",
            "\twq_entry->flags = flags;",
            "\twq_entry->private = current;",
            "\twq_entry->func = autoremove_wake_function;",
            "\tINIT_LIST_HEAD(&wq_entry->entry);",
            "}",
            "long prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)",
            "{",
            "\tunsigned long flags;",
            "\tlong ret = 0;",
            "",
            "\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\tif (signal_pending_state(state, current)) {",
            "\t\t/*",
            "\t\t * Exclusive waiter must not fail if it was selected by wakeup,",
            "\t\t * it should \"consume\" the condition we were waiting for.",
            "\t\t *",
            "\t\t * The caller will recheck the condition and return success if",
            "\t\t * we were already woken up, we can not miss the event because",
            "\t\t * wakeup locks/unlocks the same wq_head->lock.",
            "\t\t *",
            "\t\t * But we need to ensure that set-condition + wakeup after that",
            "\t\t * can't see us, it should wake up another exclusive waiter if",
            "\t\t * we fail.",
            "\t\t */",
            "\t\tlist_del_init(&wq_entry->entry);",
            "\t\tret = -ERESTARTSYS;",
            "\t} else {",
            "\t\tif (list_empty(&wq_entry->entry)) {",
            "\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)",
            "\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);",
            "\t\t\telse",
            "\t\t\t\t__add_wait_queue(wq_head, wq_entry);",
            "\t\t}",
            "\t\tset_current_state(state);",
            "\t}",
            "\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "",
            "\treturn ret;",
            "}",
            "int do_wait_intr(wait_queue_head_t *wq, wait_queue_entry_t *wait)",
            "{",
            "\tif (likely(list_empty(&wait->entry)))",
            "\t\t__add_wait_queue_entry_tail(wq, wait);",
            "",
            "\tset_current_state(TASK_INTERRUPTIBLE);",
            "\tif (signal_pending(current))",
            "\t\treturn -ERESTARTSYS;",
            "",
            "\tspin_unlock(&wq->lock);",
            "\tschedule();",
            "\tspin_lock(&wq->lock);",
            "",
            "\treturn 0;",
            "}",
            "int do_wait_intr_irq(wait_queue_head_t *wq, wait_queue_entry_t *wait)",
            "{",
            "\tif (likely(list_empty(&wait->entry)))",
            "\t\t__add_wait_queue_entry_tail(wq, wait);",
            "",
            "\tset_current_state(TASK_INTERRUPTIBLE);",
            "\tif (signal_pending(current))",
            "\t\treturn -ERESTARTSYS;",
            "",
            "\tspin_unlock_irq(&wq->lock);",
            "\tschedule();",
            "\tspin_lock_irq(&wq->lock);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__wake_up_locked_sync_key, __wake_up_sync, __wake_up_pollfree, prepare_to_wait, prepare_to_wait_exclusive, init_wait_entry, prepare_to_wait_event, do_wait_intr, do_wait_intr_irq",
          "description": "提供等待状态准备、事件等待及中断处理辅助函数，支持独占等待、信号检测和任务调度，处理等待队列插入与状态切换",
          "similarity": 0.6422626972198486
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/wait.c",
          "start_line": 1,
          "end_line": 7,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Generic waiting primitives.",
            " *",
            " * (C) 2004 Nadia Yvette Chambers, Oracle",
            " */",
            ""
          ],
          "function_name": null,
          "description": "定义等待队列通用原语的头部注释，声明GPL许可及原始作者信息",
          "similarity": 0.6362916827201843
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/sched/wait.c",
          "start_line": 356,
          "end_line": 419,
          "content": [
            "void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)",
            "{",
            "\tunsigned long flags;",
            "",
            "\t__set_current_state(TASK_RUNNING);",
            "\t/*",
            "\t * We can check for list emptiness outside the lock",
            "\t * IFF:",
            "\t *  - we use the \"careful\" check that verifies both",
            "\t *    the next and prev pointers, so that there cannot",
            "\t *    be any half-pending updates in progress on other",
            "\t *    CPU's that we haven't seen yet (and that might",
            "\t *    still change the stack area.",
            "\t * and",
            "\t *  - all other users take the lock (ie we can only",
            "\t *    have _one_ other CPU that looks at or modifies",
            "\t *    the list).",
            "\t */",
            "\tif (!list_empty_careful(&wq_entry->entry)) {",
            "\t\tspin_lock_irqsave(&wq_head->lock, flags);",
            "\t\tlist_del_init(&wq_entry->entry);",
            "\t\tspin_unlock_irqrestore(&wq_head->lock, flags);",
            "\t}",
            "}",
            "int autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)",
            "{",
            "\tint ret = default_wake_function(wq_entry, mode, sync, key);",
            "",
            "\tif (ret)",
            "\t\tlist_del_init_careful(&wq_entry->entry);",
            "",
            "\treturn ret;",
            "}",
            "long wait_woken(struct wait_queue_entry *wq_entry, unsigned mode, long timeout)",
            "{",
            "\t/*",
            "\t * The below executes an smp_mb(), which matches with the full barrier",
            "\t * executed by the try_to_wake_up() in woken_wake_function() such that",
            "\t * either we see the store to wq_entry->flags in woken_wake_function()",
            "\t * or woken_wake_function() sees our store to current->state.",
            "\t */",
            "\tset_current_state(mode); /* A */",
            "\tif (!(wq_entry->flags & WQ_FLAG_WOKEN) && !kthread_should_stop_or_park())",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t__set_current_state(TASK_RUNNING);",
            "",
            "\t/*",
            "\t * The below executes an smp_mb(), which matches with the smp_mb() (C)",
            "\t * in woken_wake_function() such that either we see the wait condition",
            "\t * being true or the store to wq_entry->flags in woken_wake_function()",
            "\t * follows ours in the coherence order.",
            "\t */",
            "\tsmp_store_mb(wq_entry->flags, wq_entry->flags & ~WQ_FLAG_WOKEN); /* B */",
            "",
            "\treturn timeout;",
            "}",
            "int woken_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)",
            "{",
            "\t/* Pairs with the smp_store_mb() in wait_woken(). */",
            "\tsmp_mb(); /* C */",
            "\twq_entry->flags |= WQ_FLAG_WOKEN;",
            "",
            "\treturn default_wake_function(wq_entry, mode, sync, key);",
            "}"
          ],
          "function_name": "finish_wait, autoremove_wake_function, wait_woken, woken_wake_function",
          "description": "实现等待结束清理与自动移除唤醒回调，包含状态转换屏障、唤醒标记更新及条件判断逻辑，确保内存顺序一致性",
          "similarity": 0.5777442455291748
        }
      ]
    },
    {
      "source_file": "kernel/locking/ww_mutex.h",
      "md_summary": "> 自动生成时间: 2025-10-25 14:56:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\ww_mutex.h`\n\n---\n\n# `locking/ww_mutex.h` 技术文档\n\n## 1. 文件概述\n\n`ww_mutex.h` 是 Linux 内核中用于实现 **Wound-Wait (WW) 互斥锁**（`ww_mutex`）的头文件。该机制主要用于解决 **死锁问题**，特别是在图形子系统（如 DRM/KMS）和资源管理场景中，多个事务（transactions）需要以特定顺序获取多个锁时。  \nWW 互斥锁通过为每个锁请求关联一个 **获取上下文**（`ww_acquire_ctx`），并基于事务的优先级或时间戳实现 **Wait-Die** 或 **Wound-Wait** 死锁避免策略。\n\n该文件通过条件编译（`WW_RT` 宏）支持两种底层锁实现：\n- **普通互斥锁**（`mutex`）：用于非实时（non-RT）内核配置。\n- **实时互斥锁**（`rt_mutex`）：用于实时（RT）内核补丁配置，支持优先级继承。\n\n## 2. 核心功能\n\n### 2.1 主要宏定义\n- `MUTEX` / `MUTEX_WAITER`：根据 `WW_RT` 宏分别映射到 `mutex`/`rt_mutex` 及其等待者结构。\n\n### 2.2 等待者链表/红黑树操作函数（抽象接口）\n- `__ww_waiter_first()`：获取等待队列中的第一个等待者。\n- `__ww_waiter_next()` / `__ww_waiter_prev()`：获取下一个/上一个等待者。\n- `__ww_waiter_last()`：获取等待队列中的最后一个等待者。\n- `__ww_waiter_add()`：将等待者插入到指定位置（普通 mutex 使用链表，RT 使用红黑树）。\n\n### 2.3 锁状态查询函数\n- `__ww_mutex_owner()`：获取当前锁的持有者任务。\n- `__ww_mutex_has_waiters()`：检查锁是否有等待者。\n- `lock_wait_lock()` / `unlock_wait_lock()`：获取/释放锁的等待队列自旋锁（`wait_lock`）。\n- `lockdep_assert_wait_lock_held()`：调试时断言 `wait_lock` 已被持有。\n\n### 2.4 WW 互斥锁核心逻辑函数\n- `ww_mutex_lock_acquired()`：在成功获取 `ww_mutex` 后，将其与获取上下文（`ww_ctx`）关联，并执行调试检查。\n- `__ww_ctx_less()`：比较两个获取上下文的优先级（用于决定谁应“等待”或“死亡/被抢占”）。\n- `__ww_mutex_die()`：**Wait-Die 策略**实现：若当前请求者（新事务）发现等待队列中有更老的事务持有其他锁，则唤醒该老事务使其“死亡”（回滚）。\n- `__ww_mutex_wound()`：**Wound-Wait 策略**实现：若当前请求者（老事务）发现锁持有者是更年轻的事务，则“刺伤”（标记 `wounded=1`）该年轻事务，迫使其回滚。\n\n## 3. 关键实现\n\n### 3.1 死锁避免策略\n- **Wait-Die**（`is_wait_die=1`）：\n  - **新事务**请求**老事务**持有的锁 → **新事务等待**。\n  - **新事务**请求**老事务**等待的锁 → **新事务死亡**（回滚）。\n- **Wound-Wait**（`is_wait_die=0`）：\n  - **老事务**请求**新事务**持有的锁 → **新事务被刺伤**（回滚）。\n  - **老事务**请求**新事务**等待的锁 → **老事务等待**。\n\n### 3.2 上下文比较 (`__ww_ctx_less`)\n- **非 RT 模式**：仅基于时间戳（`stamp`），值越大表示事务越新。\n- **RT 模式**：\n  1. 优先比较 **实时优先级**（`prio`），数值越小优先级越高。\n  2. 若均为 **Deadline 调度类**，比较 **截止时间**（`deadline`），越早截止优先级越高。\n  3. 若优先级相同，回退到时间戳比较。\n\n### 3.3 RT 与非 RT 差异\n- **数据结构**：\n  - 非 RT：等待者使用 **双向链表**（`list_head`）。\n  - RT：等待者使用 **红黑树**（`rb_root`），按优先级排序。\n- **插入逻辑**：\n  - 非 RT：`__ww_waiter_add` 显式插入到指定位置。\n  - RT：`__ww_waiter_add` 为空（RT 互斥锁内部自动处理插入）。\n\n### 3.4 调试支持 (`DEBUG_WW_MUTEXES`)\n- 检查 `ww_mutex` 是否被错误地用普通 `mutex_unlock` 释放。\n- 验证上下文一致性（如 `ww_class` 匹配、`contending_lock` 状态等）。\n\n## 4. 依赖关系\n\n- **基础锁机制**：\n  - 非 RT 模式依赖 `<linux/mutex.h>`。\n  - RT 模式依赖 `<linux/rtmutex.h>`。\n- **调度器**：依赖任务结构（`task_struct`）、优先级（`prio`）、调度类（如 `dl_prio`）。\n- **调试框架**：依赖 `lockdep`（`lockdep_assert_held`）和 `DEBUG_LOCKS_WARN_ON`。\n- **原子操作**：使用 `atomic_long_read` 检查锁状态标志（`MUTEX_FLAG_WAITERS`）。\n\n## 5. 使用场景\n\n- **图形子系统**（DRM/KMS）：  \n  多个 GPU 作业（如渲染、合成）需按顺序获取多个缓冲区（buffer）或 CRTC 锁，避免死锁。\n- **资源分配器**：  \n  当多个客户端竞争一组有限资源（如内存区域、I/O 端口）时，通过 WW 互斥锁确保无死锁的分配顺序。\n- **实时系统**（RT 补丁）：  \n  在需要确定性延迟的场景中，结合优先级继承（PI）避免优先级反转，同时通过 WW 策略解决多锁死锁。\n- **文件系统**：  \n  某些文件系统（如 Btrfs）在元数据操作中使用 WW 互斥锁管理多个 extent 锁。",
      "similarity": 0.589059591293335,
      "chunks": []
    },
    {
      "source_file": "kernel/locking/mutex.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:42:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\mutex.c`\n\n---\n\n# Linux 内核互斥锁（mutex）实现文档\n\n## 1. 文件概述\n\n`locking/mutex.c` 是 Linux 内核中互斥锁（mutex）的核心实现文件，提供了基于阻塞的互斥同步原语。该文件实现了高效、可睡眠的互斥锁机制，支持自旋优化、锁移交（handoff）、调试功能以及与调度器、死锁检测等子系统的深度集成。互斥锁用于保护临界区，确保同一时间只有一个任务可以持有锁，适用于需要长时间持有锁或可能睡眠的场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `__mutex_init()`：初始化互斥锁对象\n- `mutex_is_locked()`：检查互斥锁是否已被持有\n- `mutex_get_owner()`：获取当前锁持有者的任务指针（仅用于调试）\n- `__mutex_trylock()`：尝试获取互斥锁（非阻塞）\n- `__mutex_trylock_fast()`：快速路径尝试获取未竞争的锁\n- `__mutex_unlock_fast()`：快速路径释放锁\n- `__mutex_lock_slowpath()`：慢速路径获取锁（包含睡眠和等待逻辑）\n- `__mutex_handoff()`：将锁所有权移交给指定任务\n- `__mutex_add_waiter()` / `__mutex_remove_waiter()`：管理等待队列\n\n### 关键数据结构\n\n- `struct mutex`：互斥锁核心结构体\n  - `atomic_long_t owner`：原子存储锁持有者指针和状态标志\n  - `raw_spinlock_t wait_lock`：保护等待队列的自旋锁\n  - `struct list_head wait_list`：等待获取锁的任务队列\n  - `struct optimistic_spin_queue osq`：用于自旋优化的队列（CONFIG_MUTEX_SPIN_ON_OWNER）\n\n### 状态标志位\n\n- `MUTEX_FLAG_WAITERS (0x01)`：表示存在等待者，解锁时需唤醒\n- `MUTEX_FLAG_HANDOFF (0x02)`：表示需要将锁移交给队首等待者\n- `MUTEX_FLAG_PICKUP (0x04)`：表示锁已被移交给特定任务，等待其获取\n\n## 3. 关键实现\n\n### 锁状态编码\n互斥锁的 `owner` 字段采用指针-标志位混合编码：利用 `task_struct` 指针的低 3 位（因内存对齐保证为 0）存储状态标志。这种设计避免了额外的内存访问，提高了原子操作效率。\n\n### 快慢路径分离\n- **快速路径**：针对无竞争场景，直接通过原子比较交换（cmpxchg）获取/释放锁，避免函数调用开销\n- **慢速路径**：处理竞争情况，包含自旋等待、任务阻塞、唤醒等复杂逻辑\n\n### 自适应自旋（Adaptive Spinning）\n在 `CONFIG_MUTEX_SPIN_ON_OWNER` 配置下，当检测到锁持有者正在运行时，当前任务会先自旋等待而非立即睡眠，减少上下文切换开销。使用 OSQ（Optimistic Spin Queue）机制协调多个自旋任务。\n\n### 锁移交机制（Handoff）\n通过 `MUTEX_FLAG_HANDOFF` 和 `MUTEX_FLAG_PICKUP` 标志实现高效的锁移交：\n1. 解锁者设置 `HANDOFF` 标志并唤醒队首等待者\n2. 被唤醒任务在获取锁时检测到 `HANDOFF`，设置 `PICKUP` 标志\n3. 解锁者通过 `__mutex_handoff()` 直接将所有权转移给指定任务\n避免了唤醒后再次竞争的问题，提高实时性。\n\n### 调试支持\n- `CONFIG_DEBUG_MUTEXES`：提供锁状态验证、死锁检测\n- `CONFIG_DETECT_HUNG_TASK_BLOCKER`：集成 hung task 检测，记录阻塞源\n- `lockdep`：通过 `debug_mutex_*` 函数集成锁依赖验证\n\n## 4. 依赖关系\n\n### 头文件依赖\n- `<linux/mutex.h>` / `<linux/ww_mutex.h>`：互斥锁接口定义\n- `<linux/sched/*.h>`：调度器相关功能（睡眠、唤醒、实时任务）\n- `<linux/spinlock.h>`：底层自旋锁实现\n- `<linux/osq_lock.h>`：乐观自旋队列支持\n- `<linux/hung_task.h>`：hung task 检测集成\n- `<trace/events/lock.h>`：锁事件跟踪点\n\n### 子系统交互\n- **调度器**：通过 `schedule()` 实现任务阻塞，`wake_q` 机制批量唤醒\n- **内存管理**：依赖 `task_struct` 的内存对齐特性\n- **实时补丁（PREEMPT_RT）**：非 RT 配置下编译此文件（`#ifndef CONFIG_PREEMPT_RT`）\n- **调试子系统**：与 lockdep、hung task detector 深度集成\n\n## 5. 使用场景\n\n### 典型应用场景\n- **长临界区保护**：当临界区执行时间较长或包含可能睡眠的操作（如内存分配、I/O）\n- **驱动程序同步**：设备驱动中保护硬件寄存器访问或共享数据结构\n- **文件系统操作**：保护 inode、dentry 等元数据结构\n- **内核子系统互斥**：如网络协议栈、块设备层等需要互斥访问的场景\n\n### 使用约束\n- **不可递归**：同一任务重复获取会导致死锁\n- **必须配对使用**：获取锁的任务必须负责释放\n- **禁止中断上下文使用**：因可能睡眠，只能在进程上下文使用\n- **内存生命周期**：锁对象内存不能在持有锁时释放\n\n### 性能考量\n- 无竞争场景：纳秒级延迟（快速路径原子操作）\n- 有竞争场景：微秒级延迟（自旋优化）或毫秒级（任务切换）\n- 适用于中低频竞争场景，高频竞争建议使用读写锁或 RCU",
      "similarity": 0.5853020548820496,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/mutex.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * kernel/locking/mutex.c",
            " *",
            " * Mutexes: blocking mutual exclusion locks",
            " *",
            " * Started by Ingo Molnar:",
            " *",
            " *  Copyright (C) 2004, 2005, 2006 Red Hat, Inc., Ingo Molnar <mingo@redhat.com>",
            " *",
            " * Many thanks to Arjan van de Ven, Thomas Gleixner, Steven Rostedt and",
            " * David Howells for suggestions and improvements.",
            " *",
            " *  - Adaptive spinning for mutexes by Peter Zijlstra. (Ported to mainline",
            " *    from the -rt tree, where it was originally implemented for rtmutexes",
            " *    by Steven Rostedt, based on work by Gregory Haskins, Peter Morreale",
            " *    and Sven Dietrich.",
            " *",
            " * Also see Documentation/locking/mutex-design.rst.",
            " */",
            "#include <linux/mutex.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/osq_lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/lock.h>",
            "",
            "#ifndef CONFIG_PREEMPT_RT",
            "#include \"mutex.h\"",
            "",
            "#ifdef CONFIG_DEBUG_MUTEXES",
            "# define MUTEX_WARN_ON(cond) DEBUG_LOCKS_WARN_ON(cond)",
            "#else",
            "# define MUTEX_WARN_ON(cond)",
            "#endif",
            ""
          ],
          "function_name": null,
          "description": "声明互斥锁模块的头文件和基本配置，初始化互斥锁结构体并设置等待队列及调试信息。",
          "similarity": 0.7359992861747742
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/mutex.c",
          "start_line": 46,
          "end_line": 151,
          "content": [
            "void",
            "__mutex_init(struct mutex *lock, const char *name, struct lock_class_key *key)",
            "{",
            "\tatomic_long_set(&lock->owner, 0);",
            "\traw_spin_lock_init(&lock->wait_lock);",
            "\tINIT_LIST_HEAD(&lock->wait_list);",
            "#ifdef CONFIG_MUTEX_SPIN_ON_OWNER",
            "\tosq_lock_init(&lock->osq);",
            "#endif",
            "",
            "\tdebug_mutex_init(lock, name, key);",
            "}",
            "bool mutex_is_locked(struct mutex *lock)",
            "{",
            "\treturn __mutex_owner(lock) != NULL;",
            "}",
            "static inline unsigned long __owner_flags(unsigned long owner)",
            "{",
            "\treturn owner & MUTEX_FLAGS;",
            "}",
            "unsigned long mutex_get_owner(struct mutex *lock)",
            "{",
            "\tunsigned long owner = atomic_long_read(&lock->owner);",
            "",
            "\treturn (unsigned long)__owner_task(owner);",
            "}",
            "static inline bool __mutex_trylock_or_handoff(struct mutex *lock, bool handoff)",
            "{",
            "\treturn !__mutex_trylock_common(lock, handoff);",
            "}",
            "static inline bool __mutex_trylock(struct mutex *lock)",
            "{",
            "\treturn !__mutex_trylock_common(lock, false);",
            "}",
            "static __always_inline bool __mutex_trylock_fast(struct mutex *lock)",
            "{",
            "\tunsigned long curr = (unsigned long)current;",
            "\tunsigned long zero = 0UL;",
            "",
            "\tif (atomic_long_try_cmpxchg_acquire(&lock->owner, &zero, curr))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "static __always_inline bool __mutex_unlock_fast(struct mutex *lock)",
            "{",
            "\tunsigned long curr = (unsigned long)current;",
            "",
            "\treturn atomic_long_try_cmpxchg_release(&lock->owner, &curr, 0UL);",
            "}",
            "static inline void __mutex_set_flag(struct mutex *lock, unsigned long flag)",
            "{",
            "\tatomic_long_or(flag, &lock->owner);",
            "}",
            "static inline void __mutex_clear_flag(struct mutex *lock, unsigned long flag)",
            "{",
            "\tatomic_long_andnot(flag, &lock->owner);",
            "}",
            "static inline bool __mutex_waiter_is_first(struct mutex *lock, struct mutex_waiter *waiter)",
            "{",
            "\treturn list_first_entry(&lock->wait_list, struct mutex_waiter, list) == waiter;",
            "}",
            "static void",
            "__mutex_add_waiter(struct mutex *lock, struct mutex_waiter *waiter,",
            "\t\t   struct list_head *list)",
            "{",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER",
            "\thung_task_set_blocker(lock, BLOCKER_TYPE_MUTEX);",
            "#endif",
            "\tdebug_mutex_add_waiter(lock, waiter, current);",
            "",
            "\tlist_add_tail(&waiter->list, list);",
            "\tif (__mutex_waiter_is_first(lock, waiter))",
            "\t\t__mutex_set_flag(lock, MUTEX_FLAG_WAITERS);",
            "}",
            "static void",
            "__mutex_remove_waiter(struct mutex *lock, struct mutex_waiter *waiter)",
            "{",
            "\tlist_del(&waiter->list);",
            "\tif (likely(list_empty(&lock->wait_list)))",
            "\t\t__mutex_clear_flag(lock, MUTEX_FLAGS);",
            "",
            "\tdebug_mutex_remove_waiter(lock, waiter, current);",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER",
            "\thung_task_clear_blocker();",
            "#endif",
            "}",
            "static void __mutex_handoff(struct mutex *lock, struct task_struct *task)",
            "{",
            "\tunsigned long owner = atomic_long_read(&lock->owner);",
            "",
            "\tfor (;;) {",
            "\t\tunsigned long new;",
            "",
            "\t\tMUTEX_WARN_ON(__owner_task(owner) != current);",
            "\t\tMUTEX_WARN_ON(owner & MUTEX_FLAG_PICKUP);",
            "",
            "\t\tnew = (owner & MUTEX_FLAG_WAITERS);",
            "\t\tnew |= (unsigned long)task;",
            "\t\tif (task)",
            "\t\t\tnew |= MUTEX_FLAG_PICKUP;",
            "",
            "\t\tif (atomic_long_try_cmpxchg_release(&lock->owner, &owner, new))",
            "\t\t\tbreak;",
            "\t}",
            "}"
          ],
          "function_name": "__mutex_init, mutex_is_locked, __owner_flags, mutex_get_owner, __mutex_trylock_or_handoff, __mutex_trylock, __mutex_trylock_fast, __mutex_unlock_fast, __mutex_set_flag, __mutex_clear_flag, __mutex_waiter_is_first, __mutex_add_waiter, __mutex_remove_waiter, __mutex_handoff",
          "description": "实现互斥锁核心操作，包括初始化、状态检查、快速尝试加锁、标志位操作及等待者链表管理。",
          "similarity": 0.7192835211753845
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/locking/mutex.c",
          "start_line": 895,
          "end_line": 996,
          "content": [
            "int __sched",
            "ww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)",
            "{",
            "\tint ret;",
            "",
            "\tmight_sleep();",
            "\tret = __ww_mutex_lock(&lock->base, TASK_INTERRUPTIBLE,",
            "\t\t\t      0, _RET_IP_, ctx);",
            "",
            "\tif (!ret && ctx && ctx->acquired > 1)",
            "\t\treturn ww_mutex_deadlock_injection(lock, ctx);",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __mutex_unlock_slowpath(struct mutex *lock, unsigned long ip)",
            "{",
            "\tstruct task_struct *next = NULL;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "\tunsigned long owner;",
            "",
            "\tmutex_release(&lock->dep_map, ip);",
            "",
            "\t/*",
            "\t * Release the lock before (potentially) taking the spinlock such that",
            "\t * other contenders can get on with things ASAP.",
            "\t *",
            "\t * Except when HANDOFF, in that case we must not clear the owner field,",
            "\t * but instead set it to the top waiter.",
            "\t */",
            "\towner = atomic_long_read(&lock->owner);",
            "\tfor (;;) {",
            "\t\tMUTEX_WARN_ON(__owner_task(owner) != current);",
            "\t\tMUTEX_WARN_ON(owner & MUTEX_FLAG_PICKUP);",
            "",
            "\t\tif (owner & MUTEX_FLAG_HANDOFF)",
            "\t\t\tbreak;",
            "",
            "\t\tif (atomic_long_try_cmpxchg_release(&lock->owner, &owner, __owner_flags(owner))) {",
            "\t\t\tif (owner & MUTEX_FLAG_WAITERS)",
            "\t\t\t\tbreak;",
            "",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "",
            "\traw_spin_lock(&lock->wait_lock);",
            "\tdebug_mutex_unlock(lock);",
            "\tif (!list_empty(&lock->wait_list)) {",
            "\t\t/* get the first entry from the wait-list: */",
            "\t\tstruct mutex_waiter *waiter =",
            "\t\t\tlist_first_entry(&lock->wait_list,",
            "\t\t\t\t\t struct mutex_waiter, list);",
            "",
            "\t\tnext = waiter->task;",
            "",
            "\t\tdebug_mutex_wake_waiter(lock, waiter);",
            "\t\twake_q_add(&wake_q, next);",
            "\t}",
            "",
            "\tif (owner & MUTEX_FLAG_HANDOFF)",
            "\t\t__mutex_handoff(lock, next);",
            "",
            "\traw_spin_unlock(&lock->wait_lock);",
            "",
            "\twake_up_q(&wake_q);",
            "}",
            "int __sched mutex_lock_interruptible(struct mutex *lock)",
            "{",
            "\tmight_sleep();",
            "",
            "\tif (__mutex_trylock_fast(lock))",
            "\t\treturn 0;",
            "",
            "\treturn __mutex_lock_interruptible_slowpath(lock);",
            "}",
            "int __sched mutex_lock_killable(struct mutex *lock)",
            "{",
            "\tmight_sleep();",
            "",
            "\tif (__mutex_trylock_fast(lock))",
            "\t\treturn 0;",
            "",
            "\treturn __mutex_lock_killable_slowpath(lock);",
            "}",
            "void __sched mutex_lock_io(struct mutex *lock)",
            "{",
            "\tint token;",
            "",
            "\ttoken = io_schedule_prepare();",
            "\tmutex_lock(lock);",
            "\tio_schedule_finish(token);",
            "}",
            "static noinline void __sched",
            "__mutex_lock_slowpath(struct mutex *lock)",
            "{",
            "\t__mutex_lock(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);",
            "}",
            "static noinline int __sched",
            "__mutex_lock_killable_slowpath(struct mutex *lock)",
            "{",
            "\treturn __mutex_lock(lock, TASK_KILLABLE, 0, NULL, _RET_IP_);",
            "}"
          ],
          "function_name": "ww_mutex_lock_interruptible, __mutex_unlock_slowpath, mutex_lock_interruptible, mutex_lock_killable, mutex_lock_io, __mutex_lock_slowpath, __mutex_lock_killable_slowpath",
          "description": "实现带死锁检测的递归互斥锁中断获取逻辑，处理锁状态转换、唤醒等待线程及异常注入场景",
          "similarity": 0.6853380799293518
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/locking/mutex.c",
          "start_line": 1059,
          "end_line": 1129,
          "content": [
            "static noinline int __sched",
            "__mutex_lock_interruptible_slowpath(struct mutex *lock)",
            "{",
            "\treturn __mutex_lock(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);",
            "}",
            "static noinline int __sched",
            "__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)",
            "{",
            "\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0,",
            "\t\t\t       _RET_IP_, ctx);",
            "}",
            "static noinline int __sched",
            "__ww_mutex_lock_interruptible_slowpath(struct ww_mutex *lock,",
            "\t\t\t\t\t    struct ww_acquire_ctx *ctx)",
            "{",
            "\treturn __ww_mutex_lock(&lock->base, TASK_INTERRUPTIBLE, 0,",
            "\t\t\t       _RET_IP_, ctx);",
            "}",
            "int __sched mutex_trylock(struct mutex *lock)",
            "{",
            "\tbool locked;",
            "",
            "\tMUTEX_WARN_ON(lock->magic != lock);",
            "",
            "\tlocked = __mutex_trylock(lock);",
            "\tif (locked)",
            "\t\tmutex_acquire(&lock->dep_map, 0, 1, _RET_IP_);",
            "",
            "\treturn locked;",
            "}",
            "int __sched",
            "ww_mutex_lock(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)",
            "{",
            "\tmight_sleep();",
            "",
            "\tif (__mutex_trylock_fast(&lock->base)) {",
            "\t\tif (ctx)",
            "\t\t\tww_mutex_set_context_fastpath(lock, ctx);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\treturn __ww_mutex_lock_slowpath(lock, ctx);",
            "}",
            "int __sched",
            "ww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)",
            "{",
            "\tmight_sleep();",
            "",
            "\tif (__mutex_trylock_fast(&lock->base)) {",
            "\t\tif (ctx)",
            "\t\t\tww_mutex_set_context_fastpath(lock, ctx);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);",
            "}",
            "int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock)",
            "{",
            "\t/* dec if we can't possibly hit 0 */",
            "\tif (atomic_add_unless(cnt, -1, 1))",
            "\t\treturn 0;",
            "\t/* we might hit 0, so take the lock */",
            "\tmutex_lock(lock);",
            "\tif (!atomic_dec_and_test(cnt)) {",
            "\t\t/* when we actually did the dec, we didn't hit 0 */",
            "\t\tmutex_unlock(lock);",
            "\t\treturn 0;",
            "\t}",
            "\t/* we hit 0, and we hold the lock */",
            "\treturn 1;",
            "}"
          ],
          "function_name": "__mutex_lock_interruptible_slowpath, __ww_mutex_lock_slowpath, __ww_mutex_lock_interruptible_slowpath, mutex_trylock, ww_mutex_lock, ww_mutex_lock_interruptible, atomic_dec_and_mutex_lock",
          "description": "提供互斥锁快速路径与慢速路径切换支持，包含原子计数器递减与锁获取协同机制",
          "similarity": 0.6603105068206787
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/locking/mutex.c",
          "start_line": 758,
          "end_line": 862,
          "content": [
            "static int __sched",
            "__mutex_lock(struct mutex *lock, unsigned int state, unsigned int subclass,",
            "\t     struct lockdep_map *nest_lock, unsigned long ip)",
            "{",
            "\treturn __mutex_lock_common(lock, state, subclass, nest_lock, ip, NULL, false);",
            "}",
            "static int __sched",
            "__ww_mutex_lock(struct mutex *lock, unsigned int state, unsigned int subclass,",
            "\t\tunsigned long ip, struct ww_acquire_ctx *ww_ctx)",
            "{",
            "\treturn __mutex_lock_common(lock, state, subclass, NULL, ip, ww_ctx, true);",
            "}",
            "int ww_mutex_trylock(struct ww_mutex *ww, struct ww_acquire_ctx *ww_ctx)",
            "{",
            "\tif (!ww_ctx)",
            "\t\treturn mutex_trylock(&ww->base);",
            "",
            "\tMUTEX_WARN_ON(ww->base.magic != &ww->base);",
            "",
            "\t/*",
            "\t * Reset the wounded flag after a kill. No other process can",
            "\t * race and wound us here, since they can't have a valid owner",
            "\t * pointer if we don't have any locks held.",
            "\t */",
            "\tif (ww_ctx->acquired == 0)",
            "\t\tww_ctx->wounded = 0;",
            "",
            "\tif (__mutex_trylock(&ww->base)) {",
            "\t\tww_mutex_set_context_fastpath(ww, ww_ctx);",
            "\t\tmutex_acquire_nest(&ww->base.dep_map, 0, 1, &ww_ctx->dep_map, _RET_IP_);",
            "\t\treturn 1;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void __sched",
            "mutex_lock_nested(struct mutex *lock, unsigned int subclass)",
            "{",
            "\t__mutex_lock(lock, TASK_UNINTERRUPTIBLE, subclass, NULL, _RET_IP_);",
            "}",
            "void __sched",
            "_mutex_lock_nest_lock(struct mutex *lock, struct lockdep_map *nest)",
            "{",
            "\t__mutex_lock(lock, TASK_UNINTERRUPTIBLE, 0, nest, _RET_IP_);",
            "}",
            "int __sched",
            "mutex_lock_killable_nested(struct mutex *lock, unsigned int subclass)",
            "{",
            "\treturn __mutex_lock(lock, TASK_KILLABLE, subclass, NULL, _RET_IP_);",
            "}",
            "int __sched",
            "mutex_lock_interruptible_nested(struct mutex *lock, unsigned int subclass)",
            "{",
            "\treturn __mutex_lock(lock, TASK_INTERRUPTIBLE, subclass, NULL, _RET_IP_);",
            "}",
            "void __sched",
            "mutex_lock_io_nested(struct mutex *lock, unsigned int subclass)",
            "{",
            "\tint token;",
            "",
            "\tmight_sleep();",
            "",
            "\ttoken = io_schedule_prepare();",
            "\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE,",
            "\t\t\t    subclass, NULL, _RET_IP_, NULL, 0);",
            "\tio_schedule_finish(token);",
            "}",
            "static inline int",
            "ww_mutex_deadlock_injection(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)",
            "{",
            "#ifdef CONFIG_DEBUG_WW_MUTEX_SLOWPATH",
            "\tunsigned tmp;",
            "",
            "\tif (ctx->deadlock_inject_countdown-- == 0) {",
            "\t\ttmp = ctx->deadlock_inject_interval;",
            "\t\tif (tmp > UINT_MAX/4)",
            "\t\t\ttmp = UINT_MAX;",
            "\t\telse",
            "\t\t\ttmp = tmp*2 + tmp + tmp/2;",
            "",
            "\t\tctx->deadlock_inject_interval = tmp;",
            "\t\tctx->deadlock_inject_countdown = tmp;",
            "\t\tctx->contending_lock = lock;",
            "",
            "\t\tww_mutex_unlock(lock);",
            "",
            "\t\treturn -EDEADLK;",
            "\t}",
            "#endif",
            "",
            "\treturn 0;",
            "}",
            "int __sched",
            "ww_mutex_lock(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)",
            "{",
            "\tint ret;",
            "",
            "\tmight_sleep();",
            "\tret =  __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE,",
            "\t\t\t       0, _RET_IP_, ctx);",
            "\tif (!ret && ctx && ctx->acquired > 1)",
            "\t\treturn ww_mutex_deadlock_injection(lock, ctx);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__mutex_lock, __ww_mutex_lock, ww_mutex_trylock, mutex_lock_nested, _mutex_lock_nest_lock, mutex_lock_killable_nested, mutex_lock_interruptible_nested, mutex_lock_io_nested, ww_mutex_deadlock_injection, ww_mutex_lock",
          "description": "封装多种锁获取接口，处理嵌套锁、可中断锁及死锁注入逻辑，协调锁持有者与等待者的交互关系。",
          "similarity": 0.5978111028671265
        }
      ]
    }
  ]
}