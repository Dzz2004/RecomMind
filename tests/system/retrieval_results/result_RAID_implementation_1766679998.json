{
  "query": "RAID implementation",
  "timestamp": "2025-12-26 00:26:38",
  "retrieved_files": [
    {
      "source_file": "kernel/pid.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:16:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid.c`\n\n---\n\n# `pid.c` 技术文档\n\n## 1. 文件概述\n\n`pid.c` 是 Linux 内核中实现进程标识符（PID）管理和分配机制的核心文件。它提供了可扩展、时间有界的 PID 分配器，支持 PID 哈希表（pidhash）以及 PID 命名空间（pid namespace）功能。该文件负责 PID 的分配、释放、引用计数管理，并确保在多处理器（SMP）环境下的线程安全性。其设计目标是在高并发场景下高效、无锁地分配和回收 PID，同时支持容器化环境中的 PID 隔离。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct pid`**  \n  表示一个 PID 实例，包含：\n  - 引用计数（`count`）\n  - 多种任务类型链表（`tasks[PIDTYPE_MAX]`），用于关联不同类型的进程（如线程组、会话等）\n  - PID 层级（`level`），用于命名空间嵌套\n  - `numbers[]` 数组：每个命名空间层级对应的 `struct upid`（包含实际 PID 编号 `nr` 和所属命名空间 `ns`）\n  - `rcu` 字段：用于 RCU 安全释放\n  - `wait_pidfd`：用于 pidfd 机制的等待队列\n  - `inodes`：关联的 pidfs inode 列表\n\n- **`struct pid_namespace`**  \n  PID 命名空间结构，包含：\n  - IDR（整数 ID 映射）结构 `idr`，用于高效 PID 分配\n  - `pid_allocated`：当前已分配 PID 数量（含特殊状态如 `PIDNS_ADDING`）\n  - `child_reaper`：命名空间中的 init 进程（子进程回收者）\n  - `level`：命名空间嵌套层级\n  - `pid_cachep`：用于分配 `struct pid` 的 slab 缓存\n\n- **全局变量**\n  - `init_struct_pid`：初始 PID 结构（PID 0，用于 idle 进程）\n  - `init_pid_ns`：初始 PID 命名空间\n  - `pid_max` / `pid_max_min` / `pid_max_max`：PID 分配上限控制\n  - `pidfs_ino`：pidfs 文件系统的 inode 编号起始值\n  - `pidmap_lock`：保护 IDR 和 `pid_allocated` 的自旋锁（SMP 对齐）\n\n### 主要函数\n\n- **`alloc_pid(struct pid_namespace *ns, pid_t *set_tid, size_t set_tid_size)`**  \n  在指定 PID 命名空间中分配一个新的 PID。支持通过 `set_tid` 数组在嵌套命名空间中预设 PID（用于容器恢复等场景）。\n\n- **`free_pid(struct pid *pid)`**  \n  释放 PID 资源，从所有嵌套命名空间的 IDR 中移除，并减少 `pid_allocated` 计数。若命名空间中仅剩 reaper 进程，则唤醒它。\n\n- **`put_pid(struct pid *pid)`**  \n  减少 PID 引用计数，若引用归零则释放内存并减少命名空间引用。\n\n- **`delayed_put_pid(struct rcu_head *rhp)`**  \n  RCU 回调函数，用于安全释放 PID 结构。\n\n## 3. 关键实现\n\n### PID 分配机制\n- 使用 **IDR（Integer ID Allocator）** 替代传统的位图（bitmap），实现 O(1) 分配与释放。\n- 默认采用**循环分配策略**（`idr_alloc_cyclic`），从 `RESERVED_PIDS`（通常为 300）开始，避免低编号 PID 被耗尽。\n- 支持**预设 PID 分配**：通过 `set_tid` 参数在创建进程时指定特定 PID（需具备 `CAP_CHECKPOINT_RESTORE` 权限），用于容器快照恢复。\n\n### 命名空间支持\n- 每个 PID 在嵌套的命名空间中拥有不同的编号（`upid->nr`），通过 `pid->numbers[]` 数组维护层级关系。\n- `pid->level` 表示该 PID 所属的最深命名空间层级。\n- 分配时从最深层命名空间向上遍历至根命名空间，逐层分配 PID。\n\n### 并发与同步\n- **`pidmap_lock`**：保护 IDR 操作和 `pid_allocated` 计数器，使用 `spin_lock_irqsave` 禁用本地中断，防止与 `tasklist_lock` 的死锁。\n- **RCU 释放**：`free_pid` 通过 `call_rcu` 延迟释放 PID 结构，避免在持有锁时执行内存释放。\n- **引用计数**：`struct pid` 使用 `refcount_t` 管理生命周期，确保多任务共享 PID 时的安全释放。\n\n### 特殊状态处理\n- **`PIDNS_ADDING`**：标记命名空间正在添加新进程，防止在 fork 失败时错误减少计数。\n- **Reaper 唤醒**：当命名空间中 PID 数量降至 1 或 2 时，唤醒 `child_reaper`（通常为 init 进程），用于处理命名空间退出（`zap_pid_ns_processes`）。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/pid_namespace.h>`：PID 命名空间定义\n  - `<linux/idr.h>`：IDR 分配器实现\n  - `<linux/rculist.h>`：RCU 安全链表操作\n  - `<linux/sched/task.h>`、`<linux/sched/signal.h>`：任务调度与信号处理\n  - `<linux/pidfs.h>`、`<uapi/linux/pidfd.h>`：pidfd 和 pidfs 支持\n  - `<linux/refcount.h>`：引用计数机制\n\n- **内核模块交互**：\n  - **进程管理子系统**：与 `fork`/`clone` 系统调用集成，分配 PID 并关联到 `task_struct`\n  - **命名空间子系统**：与 `pidns_operations` 协同实现 PID 隔离\n  - **VFS 子系统**：通过 `pidfs_ino` 为 `/proc/[pid]` 提供 inode 编号\n  - **内存管理**：使用 slab 分配器（`kmem_cache_alloc`）管理 `struct pid` 内存\n\n## 5. 使用场景\n\n- **进程创建**：在 `copy_process` 中调用 `alloc_pid` 为新进程分配唯一 PID。\n- **容器运行时**：通过 `clone(CLONE_NEWPID)` 创建 PID 命名空间，实现容器内 PID 隔离。\n- **检查点/恢复（CRIU）**：使用 `set_tid` 参数在恢复进程时精确还原原始 PID。\n- **pidfd 机制**：`pid->wait_pidfd` 支持通过文件描述符等待进程退出（`pidfd_send_signal` 等系统调用）。\n- **命名空间清理**：当容器退出时，`free_pid` 触发 reaper 唤醒，确保孤儿进程被正确回收。",
      "similarity": 0.559826672077179,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/pid.c",
          "start_line": 109,
          "end_line": 221,
          "content": [
            "void put_pid(struct pid *pid)",
            "{",
            "\tstruct pid_namespace *ns;",
            "",
            "\tif (!pid)",
            "\t\treturn;",
            "",
            "\tns = pid->numbers[pid->level].ns;",
            "\tif (refcount_dec_and_test(&pid->count)) {",
            "\t\tkmem_cache_free(ns->pid_cachep, pid);",
            "\t\tput_pid_ns(ns);",
            "\t}",
            "}",
            "static void delayed_put_pid(struct rcu_head *rhp)",
            "{",
            "\tstruct pid *pid = container_of(rhp, struct pid, rcu);",
            "\tput_pid(pid);",
            "}",
            "void free_pid(struct pid *pid)",
            "{",
            "\t/* We can be called with write_lock_irq(&tasklist_lock) held */",
            "\tint i;",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&pidmap_lock, flags);",
            "\tfor (i = 0; i <= pid->level; i++) {",
            "\t\tstruct upid *upid = pid->numbers + i;",
            "\t\tstruct pid_namespace *ns = upid->ns;",
            "\t\tswitch (--ns->pid_allocated) {",
            "\t\tcase 2:",
            "\t\tcase 1:",
            "\t\t\t/* When all that is left in the pid namespace",
            "\t\t\t * is the reaper wake up the reaper.  The reaper",
            "\t\t\t * may be sleeping in zap_pid_ns_processes().",
            "\t\t\t */",
            "\t\t\twake_up_process(ns->child_reaper);",
            "\t\t\tbreak;",
            "\t\tcase PIDNS_ADDING:",
            "\t\t\t/* Handle a fork failure of the first process */",
            "\t\t\tWARN_ON(ns->child_reaper);",
            "\t\t\tns->pid_allocated = 0;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tidr_remove(&ns->idr, upid->nr);",
            "\t}",
            "\tpidfs_remove_pid(pid);",
            "\tspin_unlock_irqrestore(&pidmap_lock, flags);",
            "",
            "\tcall_rcu(&pid->rcu, delayed_put_pid);",
            "}",
            "void disable_pid_allocation(struct pid_namespace *ns)",
            "{",
            "\tspin_lock_irq(&pidmap_lock);",
            "\tns->pid_allocated &= ~PIDNS_ADDING;",
            "\tspin_unlock_irq(&pidmap_lock);",
            "}",
            "void attach_pid(struct task_struct *task, enum pid_type type)",
            "{",
            "\tstruct pid *pid = *task_pid_ptr(task, type);",
            "\thlist_add_head_rcu(&task->pid_links[type], &pid->tasks[type]);",
            "}",
            "static void __change_pid(struct task_struct *task, enum pid_type type,",
            "\t\t\tstruct pid *new)",
            "{",
            "\tstruct pid **pid_ptr = task_pid_ptr(task, type);",
            "\tstruct pid *pid;",
            "\tint tmp;",
            "",
            "\tpid = *pid_ptr;",
            "",
            "\thlist_del_rcu(&task->pid_links[type]);",
            "\t*pid_ptr = new;",
            "",
            "\tif (type == PIDTYPE_PID) {",
            "\t\tWARN_ON_ONCE(pid_has_task(pid, PIDTYPE_PID));",
            "\t\twake_up_all(&pid->wait_pidfd);",
            "\t}",
            "",
            "\tfor (tmp = PIDTYPE_MAX; --tmp >= 0; )",
            "\t\tif (pid_has_task(pid, tmp))",
            "\t\t\treturn;",
            "",
            "\tfree_pid(pid);",
            "}",
            "void detach_pid(struct task_struct *task, enum pid_type type)",
            "{",
            "\t__change_pid(task, type, NULL);",
            "}",
            "void change_pid(struct task_struct *task, enum pid_type type,",
            "\t\tstruct pid *pid)",
            "{",
            "\t__change_pid(task, type, pid);",
            "\tattach_pid(task, type);",
            "}",
            "void exchange_tids(struct task_struct *left, struct task_struct *right)",
            "{",
            "\tstruct pid *pid1 = left->thread_pid;",
            "\tstruct pid *pid2 = right->thread_pid;",
            "\tstruct hlist_head *head1 = &pid1->tasks[PIDTYPE_PID];",
            "\tstruct hlist_head *head2 = &pid2->tasks[PIDTYPE_PID];",
            "",
            "\t/* Swap the single entry tid lists */",
            "\thlists_swap_heads_rcu(head1, head2);",
            "",
            "\t/* Swap the per task_struct pid */",
            "\trcu_assign_pointer(left->thread_pid, pid2);",
            "\trcu_assign_pointer(right->thread_pid, pid1);",
            "",
            "\t/* Swap the cached value */",
            "\tWRITE_ONCE(left->pid, pid_nr(pid2));",
            "\tWRITE_ONCE(right->pid, pid_nr(pid1));",
            "}"
          ],
          "function_name": "put_pid, delayed_put_pid, free_pid, disable_pid_allocation, attach_pid, __change_pid, detach_pid, change_pid, exchange_tids",
          "description": "实现PID引用计数管理、释放逻辑及任务PID绑定操作，通过锁保护PID分配状态变更，利用RCU机制延迟释放内存，并处理进程ID类型切换和线程ID交换。",
          "similarity": 0.6091936826705933
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/pid.c",
          "start_line": 1,
          "end_line": 108,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Generic pidhash and scalable, time-bounded PID allocator",
            " *",
            " * (C) 2002-2003 Nadia Yvette Chambers, IBM",
            " * (C) 2004 Nadia Yvette Chambers, Oracle",
            " * (C) 2002-2004 Ingo Molnar, Red Hat",
            " *",
            " * pid-structures are backing objects for tasks sharing a given ID to chain",
            " * against. There is very little to them aside from hashing them and",
            " * parking tasks using given ID's on a list.",
            " *",
            " * The hash is always changed with the tasklist_lock write-acquired,",
            " * and the hash is only accessed with the tasklist_lock at least",
            " * read-acquired, so there's no additional SMP locking needed here.",
            " *",
            " * We have a list of bitmap pages, which bitmaps represent the PID space.",
            " * Allocating and freeing PIDs is completely lockless. The worst-case",
            " * allocation scenario when all but one out of 1 million PIDs possible are",
            " * allocated already: the scanning of 32 list entries and at most PAGE_SIZE",
            " * bytes. The typical fastpath is a single successful setbit. Freeing is O(1).",
            " *",
            " * Pid namespaces:",
            " *    (C) 2007 Pavel Emelyanov <xemul@openvz.org>, OpenVZ, SWsoft Inc.",
            " *    (C) 2007 Sukadev Bhattiprolu <sukadev@us.ibm.com>, IBM",
            " *     Many thanks to Oleg Nesterov for comments and help",
            " *",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/rculist.h>",
            "#include <linux/memblock.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/refcount.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/idr.h>",
            "#include <linux/pidfs.h>",
            "#include <linux/seqlock.h>",
            "#include <net/sock.h>",
            "#include <uapi/linux/pidfd.h>",
            "",
            "struct pid init_struct_pid = {",
            "\t.count\t\t= REFCOUNT_INIT(1),",
            "\t.tasks\t\t= {",
            "\t\t{ .first = NULL },",
            "\t\t{ .first = NULL },",
            "\t\t{ .first = NULL },",
            "\t},",
            "\t.level\t\t= 0,",
            "\t.numbers\t= { {",
            "\t\t.nr\t\t= 0,",
            "\t\t.ns\t\t= &init_pid_ns,",
            "\t}, }",
            "};",
            "",
            "int pid_max = PID_MAX_DEFAULT;",
            "",
            "int pid_max_min = RESERVED_PIDS + 1;",
            "int pid_max_max = PID_MAX_LIMIT;",
            "",
            "/*",
            " * PID-map pages start out as NULL, they get allocated upon",
            " * first use and are never deallocated. This way a low pid_max",
            " * value does not cause lots of bitmaps to be allocated, but",
            " * the scheme scales to up to 4 million PIDs, runtime.",
            " */",
            "struct pid_namespace init_pid_ns = {",
            "\t.ns.count = REFCOUNT_INIT(2),",
            "\t.idr = IDR_INIT(init_pid_ns.idr),",
            "\t.pid_allocated = PIDNS_ADDING,",
            "\t.level = 0,",
            "\t.child_reaper = &init_task,",
            "\t.user_ns = &init_user_ns,",
            "\t.ns.inum = PROC_PID_INIT_INO,",
            "#ifdef CONFIG_PID_NS",
            "\t.ns.ops = &pidns_operations,",
            "#endif",
            "#if defined(CONFIG_SYSCTL) && defined(CONFIG_MEMFD_CREATE)",
            "\t.memfd_noexec_scope = MEMFD_NOEXEC_SCOPE_EXEC,",
            "#endif",
            "};",
            "EXPORT_SYMBOL_GPL(init_pid_ns);",
            "",
            "/*",
            " * Note: disable interrupts while the pidmap_lock is held as an",
            " * interrupt might come in and do read_lock(&tasklist_lock).",
            " *",
            " * If we don't disable interrupts there is a nasty deadlock between",
            " * detach_pid()->free_pid() and another cpu that does",
            " * spin_lock(&pidmap_lock) followed by an interrupt routine that does",
            " * read_lock(&tasklist_lock);",
            " *",
            " * After we clean up the tasklist_lock and know there are no",
            " * irq handlers that take it we can leave the interrupts enabled.",
            " * For now it is easier to be safe than to prove it can't happen.",
            " */",
            "",
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);",
            "seqcount_spinlock_t pidmap_lock_seq = SEQCNT_SPINLOCK_ZERO(pidmap_lock_seq, &pidmap_lock);",
            ""
          ],
          "function_name": null,
          "description": "定义了PID命名空间和PID结构体的初始状态，包括全局PID最大值限制、PID映射锁及序列化机制，用于支持多层级PID分配和命名空间隔离。",
          "similarity": 0.5216336250305176
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/pid.c",
          "start_line": 402,
          "end_line": 488,
          "content": [
            "void transfer_pid(struct task_struct *old, struct task_struct *new,",
            "\t\t\t   enum pid_type type)",
            "{",
            "\tWARN_ON_ONCE(type == PIDTYPE_PID);",
            "\thlist_replace_rcu(&old->pid_links[type], &new->pid_links[type]);",
            "}",
            "pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)",
            "{",
            "\tstruct upid *upid;",
            "\tpid_t nr = 0;",
            "",
            "\tif (pid && ns->level <= pid->level) {",
            "\t\tupid = &pid->numbers[ns->level];",
            "\t\tif (upid->ns == ns)",
            "\t\t\tnr = upid->nr;",
            "\t}",
            "\treturn nr;",
            "}",
            "pid_t pid_vnr(struct pid *pid)",
            "{",
            "\treturn pid_nr_ns(pid, task_active_pid_ns(current));",
            "}",
            "pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type,",
            "\t\t\tstruct pid_namespace *ns)",
            "{",
            "\tpid_t nr = 0;",
            "",
            "\trcu_read_lock();",
            "\tif (!ns)",
            "\t\tns = task_active_pid_ns(current);",
            "\tnr = pid_nr_ns(rcu_dereference(*task_pid_ptr(task, type)), ns);",
            "\trcu_read_unlock();",
            "",
            "\treturn nr;",
            "}",
            "static int pidfd_create(struct pid *pid, unsigned int flags)",
            "{",
            "\tint pidfd;",
            "\tstruct file *pidfd_file;",
            "",
            "\tpidfd = pidfd_prepare(pid, flags, &pidfd_file);",
            "\tif (pidfd < 0)",
            "\t\treturn pidfd;",
            "",
            "\tfd_install(pidfd, pidfd_file);",
            "\treturn pidfd;",
            "}",
            "void __init pid_idr_init(void)",
            "{",
            "\t/* Verify no one has done anything silly: */",
            "\tBUILD_BUG_ON(PID_MAX_LIMIT >= PIDNS_ADDING);",
            "",
            "\t/* bump default and minimum pid_max based on number of cpus */",
            "\tpid_max = min(pid_max_max, max_t(int, pid_max,",
            "\t\t\t\tPIDS_PER_CPU_DEFAULT * num_possible_cpus()));",
            "\tpid_max_min = max_t(int, pid_max_min,",
            "\t\t\t\tPIDS_PER_CPU_MIN * num_possible_cpus());",
            "\tpr_info(\"pid_max: default: %u minimum: %u\\n\", pid_max, pid_max_min);",
            "",
            "\tidr_init(&init_pid_ns.idr);",
            "",
            "\tinit_pid_ns.pid_cachep = kmem_cache_create(\"pid\",",
            "\t\t\tstruct_size_t(struct pid, numbers, 1),",
            "\t\t\t__alignof__(struct pid),",
            "\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT,",
            "\t\t\tNULL);",
            "}",
            "static int pidfd_getfd(struct pid *pid, int fd)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct file *file;",
            "\tint ret;",
            "",
            "\ttask = get_pid_task(pid, PIDTYPE_PID);",
            "\tif (!task)",
            "\t\treturn -ESRCH;",
            "",
            "\tfile = __pidfd_fget(task, fd);",
            "\tput_task_struct(task);",
            "\tif (IS_ERR(file))",
            "\t\treturn PTR_ERR(file);",
            "",
            "\tret = receive_fd(file, O_CLOEXEC);",
            "\tfput(file);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "transfer_pid, pid_nr_ns, pid_vnr, __task_pid_nr_ns, pidfd_create, pid_idr_init, pidfd_getfd",
          "description": "提供跨命名空间PID查询接口及文件描述符创建功能，初始化ID分配器并配置PID命名空间层级关系，支持基于IDR的高效PID索引管理。",
          "similarity": 0.5030149817466736
        }
      ]
    },
    {
      "source_file": "kernel/trace/pid_list.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:04:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\pid_list.c`\n\n---\n\n# `trace/pid_list.c` 技术文档\n\n## 1. 文件概述\n\n`trace/pid_list.c` 实现了一个高效、可扩展的 PID（进程标识符）集合管理机制，用于 Linux 内核跟踪子系统（ftrace）中对特定进程的过滤控制。该文件通过三级位图结构（upper1 → upper2 → lower）将 PID 空间分层组织，支持快速的 PID 设置、清除、查询及遍历操作，同时兼顾内存使用效率和并发安全性。该实现特别适用于需要动态跟踪大量进程但又不能占用过多连续内存的场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `trace_pid_list_is_set()`：检查指定 PID 是否在列表中（用于调度时快速判断是否应跟踪该任务）。\n- `trace_pid_list_set()`：将指定 PID 加入跟踪列表。\n- `trace_pid_list_clear()`：从跟踪列表中移除指定 PID，并在对应位图块为空时自动释放内存。\n- `trace_pid_list_next()`：从给定 PID 开始查找下一个存在于列表中的 PID（用于遍历所有被跟踪的 PID）。\n\n### 辅助内联函数\n\n- `get_lower_chunk()` / `put_lower_chunk()`：从空闲链表中分配或归还底层位图块（`lower_chunk`）。\n- `get_upper_chunk()` / `put_upper_chunk()`：从空闲链表中分配或归还上层索引块（`upper_chunk`）。\n- `upper_empty()`：判断一个 `upper_chunk` 是否完全为空（所有 `lower_chunk` 均为 NULL）。\n- `pid_split()` / `pid_join()`：将 PID 拆分为三级索引（upper1, upper2, lower）或将三级索引合并为 PID。\n\n### 关键数据结构（定义于 `pid_list.h`）\n\n- `struct trace_pid_list`：PID 列表的主结构体，包含：\n  - 两级指针数组：`upper[UPPER_MAX]` 指向 `upper_chunk`。\n  - 空闲块链表：`lower_list` 和 `upper_list` 用于缓存未使用的块。\n  - 计数器：`free_lower_chunks` 和 `free_upper_chunks`。\n  - 自旋锁：`lock` 保证并发安全。\n  - 中断工作队列：`refill_irqwork` 用于异步补充空闲块。\n- `union upper_chunk`：包含一个指针数组 `data[UPPER_MAX]`，每个元素指向一个 `lower_chunk`。\n- `union lower_chunk`：包含一个位图数组 `data[LOWER_SIZE]`，用于存储 `LOWER_MAX` 个 PID 的存在状态。\n\n## 3. 关键实现\n\n### 三级分层位图结构\n- **设计目的**：避免为整个 PID 空间（最大 `PID_MAX_LIMIT`，通常为 4194304）分配连续大内存。\n- **层级划分**：\n  - **Upper1**：最高位，索引 `trace_pid_list->upper[]` 数组（大小 `UPPER_MAX`）。\n  - **Upper2**：中间位，索引 `upper_chunk->data[]` 数组（大小 `UPPER_MAX`）。\n  - **Lower**：最低位，索引 `lower_chunk->data` 位图中的具体位（范围 `0` 到 `LOWER_MAX-1`）。\n- **内存效率**：仅当某 PID 范围被使用时才动态分配对应的 `upper_chunk` 和 `lower_chunk`。\n\n### 并发与内存管理\n- **自旋锁保护**：所有操作均在 `pid_list->lock` 保护下进行，使用 `raw_spin_lock_irqsave()` 禁用本地中断以确保在硬中断上下文（如调度器）中的安全性。\n- **空闲块缓存**：通过 `lower_list` 和 `upper_list` 链表缓存已释放的块，避免频繁的内存分配/释放。\n- **异步补充机制**：当空闲块数量低于阈值 `CHUNK_REALLOC` 时，通过 `irq_work_queue()` 触发中断上下文工作（`refill_irqwork`）来补充空闲块，避免在持有调度器锁时执行耗时的内存分配。\n\n### 动态释放\n- 在 `trace_pid_list_clear()` 中，清除位后检查 `lower_chunk` 是否全零：\n  - 若是，则将其归还到 `lower_list` 并置空 `upper_chunk->data[upper2]`。\n  - 进一步检查 `upper_chunk` 是否完全为空（所有 `data[]` 为 NULL），若是则归还到 `upper_list` 并置空 `pid_list->upper[upper1]`。\n\n### PID 遍历算法\n- `trace_pid_list_next()` 从给定 PID 的拆分索引开始，按 `upper1 → upper2 → lower` 顺序遍历：\n  - 外层循环遍历 `upper1`（从起始值到 `UPPER_MASK`）。\n  - 内层循环遍历 `upper2`（从起始值或 0 到 `UPPER_MASK`）。\n  - 在有效的 `lower_chunk` 中使用 `find_next_bit()` 查找下一个置位的 PID。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/spinlock.h>`：提供自旋锁原语。\n  - `<linux/irq_work.h>`：提供中断上下文工作队列机制。\n  - `<linux/slab.h>`：提供内存分配接口（由 `pid_list.h` 或其他文件间接使用）。\n  - `\"trace.h\"`：包含跟踪子系统通用定义及 `pid_list.h`。\n- **数据结构依赖**：依赖 `pid_list.h` 中定义的 `struct trace_pid_list`、`union upper_chunk`、`union lower_chunk` 及相关常量（如 `UPPER_MASK`、`LOWER_MASK`、`CHUNK_REALLOC` 等）。\n- **内核子系统**：作为 ftrace 跟踪过滤机制的核心组件，被调度器（`kernel/sched/`）和 tracefs 接口（`kernel/trace/`）调用。\n\n## 5. 使用场景\n\n- **动态进程跟踪**：用户通过 tracefs 接口（如 `set_ftrace_pid`）指定要跟踪的进程 PID，内核调用 `trace_pid_list_set()` 将其加入列表。\n- **调度器过滤**：在任务切换时（`__schedule()`），调度器调用 `trace_pid_list_is_set()` 快速判断当前任务是否应被跟踪，决定是否触发跟踪事件。\n- **进程生命周期管理**：\n  - **Fork**：若父进程在跟踪列表中且配置了跟踪子进程，则新进程 PID 通过 `trace_pid_list_set()` 加入列表。\n  - **Exit**：任务退出时，若其 PID 在列表中，则通过 `trace_pid_list_clear()` 移除。\n- **PID 列表遍历**：调试工具或内核接口需要枚举所有被跟踪的 PID 时，调用 `trace_pid_list_next()` 进行迭代。\n- **内存压力处理**：在高并发设置/清除 PID 时，通过异步 `irq_work` 补充空闲块，避免在关键路径（如调度器）中阻塞。",
      "similarity": 0.5292006731033325,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 221,
          "end_line": 377,
          "content": [
            "int trace_pid_list_clear(struct trace_pid_list *pid_list, unsigned int pid)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "",
            "\tif (!pid_list)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tupper_chunk = pid_list->upper[upper1];",
            "\tif (!upper_chunk)",
            "\t\tgoto out;",
            "",
            "\tlower_chunk = upper_chunk->data[upper2];",
            "\tif (!lower_chunk)",
            "\t\tgoto out;",
            "",
            "\tclear_bit(lower, lower_chunk->data);",
            "",
            "\t/* if there's no more bits set, add it to the free list */",
            "\tif (find_first_bit(lower_chunk->data, LOWER_MAX) >= LOWER_MAX) {",
            "\t\tput_lower_chunk(pid_list, lower_chunk);",
            "\t\tupper_chunk->data[upper2] = NULL;",
            "\t\tif (upper_empty(upper_chunk)) {",
            "\t\t\tput_upper_chunk(pid_list, upper_chunk);",
            "\t\t\tpid_list->upper[upper1] = NULL;",
            "\t\t}",
            "\t}",
            " out:",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "\treturn 0;",
            "}",
            "int trace_pid_list_next(struct trace_pid_list *pid_list, unsigned int pid,",
            "\t\t\tunsigned int *next)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "",
            "\tif (!pid_list)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tfor (; upper1 <= UPPER_MASK; upper1++, upper2 = 0) {",
            "\t\tupper_chunk = pid_list->upper[upper1];",
            "",
            "\t\tif (!upper_chunk)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (; upper2 <= UPPER_MASK; upper2++, lower = 0) {",
            "\t\t\tlower_chunk = upper_chunk->data[upper2];",
            "\t\t\tif (!lower_chunk)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tlower = find_next_bit(lower_chunk->data, LOWER_MAX,",
            "\t\t\t\t\t    lower);",
            "\t\t\tif (lower < LOWER_MAX)",
            "\t\t\t\tgoto found;",
            "\t\t}",
            "\t}",
            "",
            " found:",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "\tif (upper1 > UPPER_MASK)",
            "\t\treturn -1;",
            "",
            "\t*next = pid_join(upper1, upper2, lower);",
            "\treturn 0;",
            "}",
            "int trace_pid_list_first(struct trace_pid_list *pid_list, unsigned int *pid)",
            "{",
            "\treturn trace_pid_list_next(pid_list, 0, pid);",
            "}",
            "static void pid_list_refill_irq(struct irq_work *iwork)",
            "{",
            "\tstruct trace_pid_list *pid_list = container_of(iwork, struct trace_pid_list,",
            "\t\t\t\t\t\t       refill_irqwork);",
            "\tunion upper_chunk *upper = NULL;",
            "\tunion lower_chunk *lower = NULL;",
            "\tunion upper_chunk **upper_next = &upper;",
            "\tunion lower_chunk **lower_next = &lower;",
            "\tint upper_count;",
            "\tint lower_count;",
            "\tint ucnt = 0;",
            "\tint lcnt = 0;",
            "",
            " again:",
            "\traw_spin_lock(&pid_list->lock);",
            "\tupper_count = CHUNK_ALLOC - pid_list->free_upper_chunks;",
            "\tlower_count = CHUNK_ALLOC - pid_list->free_lower_chunks;",
            "\traw_spin_unlock(&pid_list->lock);",
            "",
            "\tif (upper_count <= 0 && lower_count <= 0)",
            "\t\treturn;",
            "",
            "\twhile (upper_count-- > 0) {",
            "\t\tunion upper_chunk *chunk;",
            "",
            "\t\tchunk = kzalloc(sizeof(*chunk), GFP_NOWAIT);",
            "\t\tif (!chunk)",
            "\t\t\tbreak;",
            "\t\t*upper_next = chunk;",
            "\t\tupper_next = &chunk->next;",
            "\t\tucnt++;",
            "\t}",
            "",
            "\twhile (lower_count-- > 0) {",
            "\t\tunion lower_chunk *chunk;",
            "",
            "\t\tchunk = kzalloc(sizeof(*chunk), GFP_NOWAIT);",
            "\t\tif (!chunk)",
            "\t\t\tbreak;",
            "\t\t*lower_next = chunk;",
            "\t\tlower_next = &chunk->next;",
            "\t\tlcnt++;",
            "\t}",
            "",
            "\traw_spin_lock(&pid_list->lock);",
            "\tif (upper) {",
            "\t\t*upper_next = pid_list->upper_list;",
            "\t\tpid_list->upper_list = upper;",
            "\t\tpid_list->free_upper_chunks += ucnt;",
            "\t}",
            "\tif (lower) {",
            "\t\t*lower_next = pid_list->lower_list;",
            "\t\tpid_list->lower_list = lower;",
            "\t\tpid_list->free_lower_chunks += lcnt;",
            "\t}",
            "\traw_spin_unlock(&pid_list->lock);",
            "",
            "\t/*",
            "\t * On success of allocating all the chunks, both counters",
            "\t * will be less than zero. If they are not, then an allocation",
            "\t * failed, and we should not try again.",
            "\t */",
            "\tif (upper_count >= 0 || lower_count >= 0)",
            "\t\treturn;",
            "\t/*",
            "\t * When the locks were released, free chunks could have",
            "\t * been used and allocation needs to be done again. Might as",
            "\t * well allocate it now.",
            "\t */",
            "\tgoto again;",
            "}"
          ],
          "function_name": "trace_pid_list_clear, trace_pid_list_next, trace_pid_list_first, pid_list_refill_irq",
          "description": "实现PID集合的遍历与清理功能，包含按序查找下一个PID、首次PID查询及异步内存补充分配逻辑，支持动态扩展存储结构以避免内存耗尽。",
          "similarity": 0.5578218102455139
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 60,
          "end_line": 180,
          "content": [
            "static inline void put_lower_chunk(struct trace_pid_list *pid_list,",
            "\t\t\t\t   union lower_chunk *chunk)",
            "{",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tchunk->next = pid_list->lower_list;",
            "\tpid_list->lower_list = chunk;",
            "\tpid_list->free_lower_chunks++;",
            "}",
            "static inline void put_upper_chunk(struct trace_pid_list *pid_list,",
            "\t\t\t\t   union upper_chunk *chunk)",
            "{",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tchunk->next = pid_list->upper_list;",
            "\tpid_list->upper_list = chunk;",
            "\tpid_list->free_upper_chunks++;",
            "}",
            "static inline bool upper_empty(union upper_chunk *chunk)",
            "{",
            "\t/*",
            "\t * If chunk->data has no lower chunks, it will be the same",
            "\t * as a zeroed bitmask. Use find_first_bit() to test it",
            "\t * and if it doesn't find any bits set, then the array",
            "\t * is empty.",
            "\t */",
            "\tint bit = find_first_bit((unsigned long *)chunk->data,",
            "\t\t\t\t sizeof(chunk->data) * 8);",
            "\treturn bit >= sizeof(chunk->data) * 8;",
            "}",
            "static inline int pid_split(unsigned int pid, unsigned int *upper1,",
            "\t\t\t     unsigned int *upper2, unsigned int *lower)",
            "{",
            "\t/* MAX_PID should cover all pids */",
            "\tBUILD_BUG_ON(MAX_PID < PID_MAX_LIMIT);",
            "",
            "\t/* In case a bad pid is passed in, then fail */",
            "\tif (unlikely(pid >= MAX_PID))",
            "\t\treturn -1;",
            "",
            "\t*upper1 = (pid >> UPPER1_SHIFT) & UPPER_MASK;",
            "\t*upper2 = (pid >> UPPER2_SHIFT) & UPPER_MASK;",
            "\t*lower = pid & LOWER_MASK;",
            "",
            "\treturn 0;",
            "}",
            "static inline unsigned int pid_join(unsigned int upper1,",
            "\t\t\t\t    unsigned int upper2, unsigned int lower)",
            "{",
            "\treturn ((upper1 & UPPER_MASK) << UPPER1_SHIFT) |",
            "\t\t((upper2 & UPPER_MASK) << UPPER2_SHIFT) |",
            "\t\t(lower & LOWER_MASK);",
            "}",
            "bool trace_pid_list_is_set(struct trace_pid_list *pid_list, unsigned int pid)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "\tbool ret = false;",
            "",
            "\tif (!pid_list)",
            "\t\treturn false;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn false;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tupper_chunk = pid_list->upper[upper1];",
            "\tif (upper_chunk) {",
            "\t\tlower_chunk = upper_chunk->data[upper2];",
            "\t\tif (lower_chunk)",
            "\t\t\tret = test_bit(lower, lower_chunk->data);",
            "\t}",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "",
            "\treturn ret;",
            "}",
            "int trace_pid_list_set(struct trace_pid_list *pid_list, unsigned int pid)",
            "{",
            "\tunion upper_chunk *upper_chunk;",
            "\tunion lower_chunk *lower_chunk;",
            "\tunsigned long flags;",
            "\tunsigned int upper1;",
            "\tunsigned int upper2;",
            "\tunsigned int lower;",
            "\tint ret;",
            "",
            "\tif (!pid_list)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\traw_spin_lock_irqsave(&pid_list->lock, flags);",
            "\tupper_chunk = pid_list->upper[upper1];",
            "\tif (!upper_chunk) {",
            "\t\tupper_chunk = get_upper_chunk(pid_list);",
            "\t\tif (!upper_chunk) {",
            "\t\t\tret = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tpid_list->upper[upper1] = upper_chunk;",
            "\t}",
            "\tlower_chunk = upper_chunk->data[upper2];",
            "\tif (!lower_chunk) {",
            "\t\tlower_chunk = get_lower_chunk(pid_list);",
            "\t\tif (!lower_chunk) {",
            "\t\t\tret = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tupper_chunk->data[upper2] = lower_chunk;",
            "\t}",
            "\tset_bit(lower, lower_chunk->data);",
            "\tret = 0;",
            " out:",
            "\traw_spin_unlock_irqrestore(&pid_list->lock, flags);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "put_lower_chunk, put_upper_chunk, upper_empty, pid_split, pid_join, trace_pid_list_is_set, trace_pid_list_set",
          "description": "提供PID存储结构的辅助操作，包括块回收、位掩码操作、PID地址转换及集合状态查询与更新，实现基于多级位图的高效PID追踪。",
          "similarity": 0.5566830635070801
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2021 VMware Inc, Steven Rostedt <rostedt@goodmis.org>",
            " */",
            "#include <linux/spinlock.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include \"trace.h\"",
            "",
            "/* See pid_list.h for details */",
            "",
            "static inline union lower_chunk *get_lower_chunk(struct trace_pid_list *pid_list)",
            "{",
            "\tunion lower_chunk *chunk;",
            "",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tif (!pid_list->lower_list)",
            "\t\treturn NULL;",
            "",
            "\tchunk = pid_list->lower_list;",
            "\tpid_list->lower_list = chunk->next;",
            "\tpid_list->free_lower_chunks--;",
            "\tWARN_ON_ONCE(pid_list->free_lower_chunks < 0);",
            "\tchunk->next = NULL;",
            "\t/*",
            "\t * If a refill needs to happen, it can not happen here",
            "\t * as the scheduler run queue locks are held.",
            "\t */",
            "\tif (pid_list->free_lower_chunks <= CHUNK_REALLOC)",
            "\t\tirq_work_queue(&pid_list->refill_irqwork);",
            "",
            "\treturn chunk;",
            "}",
            "",
            "static inline union upper_chunk *get_upper_chunk(struct trace_pid_list *pid_list)",
            "{",
            "\tunion upper_chunk *chunk;",
            "",
            "\tlockdep_assert_held(&pid_list->lock);",
            "",
            "\tif (!pid_list->upper_list)",
            "\t\treturn NULL;",
            "",
            "\tchunk = pid_list->upper_list;",
            "\tpid_list->upper_list = chunk->next;",
            "\tpid_list->free_upper_chunks--;",
            "\tWARN_ON_ONCE(pid_list->free_upper_chunks < 0);",
            "\tchunk->next = NULL;",
            "\t/*",
            "\t * If a refill needs to happen, it can not happen here",
            "\t * as the scheduler run queue locks are held.",
            "\t */",
            "\tif (pid_list->free_upper_chunks <= CHUNK_REALLOC)",
            "\t\tirq_work_queue(&pid_list->refill_irqwork);",
            "",
            "\treturn chunk;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "实现从trace_pid_list结构中获取下层和上层块的函数，通过原子操作减少空闲块计数并可能触发异步补充分配，用于动态管理PID跟踪的内存块。",
          "similarity": 0.5388943552970886
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/pid_list.c",
          "start_line": 457,
          "end_line": 495,
          "content": [
            "void trace_pid_list_free(struct trace_pid_list *pid_list)",
            "{",
            "\tunion upper_chunk *upper;",
            "\tunion lower_chunk *lower;",
            "\tint i, j;",
            "",
            "\tif (!pid_list)",
            "\t\treturn;",
            "",
            "\tirq_work_sync(&pid_list->refill_irqwork);",
            "",
            "\twhile (pid_list->lower_list) {",
            "\t\tunion lower_chunk *chunk;",
            "",
            "\t\tchunk = pid_list->lower_list;",
            "\t\tpid_list->lower_list = pid_list->lower_list->next;",
            "\t\tkfree(chunk);",
            "\t}",
            "",
            "\twhile (pid_list->upper_list) {",
            "\t\tunion upper_chunk *chunk;",
            "",
            "\t\tchunk = pid_list->upper_list;",
            "\t\tpid_list->upper_list = pid_list->upper_list->next;",
            "\t\tkfree(chunk);",
            "\t}",
            "",
            "\tfor (i = 0; i < UPPER1_SIZE; i++) {",
            "\t\tupper = pid_list->upper[i];",
            "\t\tif (upper) {",
            "\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {",
            "\t\t\t\tlower = upper->data[j];",
            "\t\t\t\tkfree(lower);",
            "\t\t\t}",
            "\t\t\tkfree(upper);",
            "\t\t}",
            "\t}",
            "\tkfree(pid_list);",
            "}"
          ],
          "function_name": "trace_pid_list_free",
          "description": "释放trace_pid_list及其关联的所有内存资源，递归回收上层块和下层块链表，彻底清理PID跟踪结构体占用的内存量。",
          "similarity": 0.5202809572219849
        }
      ]
    },
    {
      "source_file": "kernel/cgroup/pids.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:50:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\pids.c`\n\n---\n\n# cgroup/pids.c 技术文档\n\n## 1. 文件概述\n\n`cgroup/pids.c` 实现了 Linux 内核中 cgroup 的 **PID 控制器（pids controller）**，用于限制指定 cgroup 及其子层级中可创建的最大进程（任务）数量。该控制器通过监控 `fork()` 系统调用，在进程数量即将超过设定阈值时拒绝创建新进程（返回 `-EAGAIN`），从而防止 PID 资源耗尽。该控制器支持层级继承语义，即子 cgroup 的有效限制为其自身与所有祖先中**最严格**的限制。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct pids_cgroup`**  \n  表示一个 cgroup 的 PID 控制状态，包含：\n  - `counter`：当前 cgroup 中的进程数量（64 位原子计数器）\n  - `limit`：允许的最大进程数（64 位原子值，`PIDS_MAX` 表示无限制）\n  - `watermark`：历史最高进程数（用于监控）\n  - `events` / `events_local`：事件计数器（如 `PIDCG_MAX`、`PIDCG_FORKFAIL`）\n  - `events_file` / `events_local_file`：用于通知用户空间事件发生的 cgroup 文件句柄\n\n- **`enum pidcg_event`**  \n  定义两类事件：\n  - `PIDCG_MAX`：因本 cgroup 或祖先限制被触发而导致 fork 失败\n  - `PIDCG_FORKFAIL`：在本 cgroup 中 fork 失败（用于本地事件通知）\n\n### 主要函数\n\n- **资源分配与释放**\n  - `pids_css_alloc()`：为新 cgroup 分配 `pids_cgroup` 结构，初始限制设为 `PIDS_MAX`（无限制）\n  - `pids_css_free()`：释放 `pids_cgroup` 结构\n\n- **计数操作**\n  - `pids_charge()`：**无条件**增加指定 cgroup 及其所有祖先的进程计数（用于回滚）\n  - `pids_uncharge()`：减少指定 cgroup 及其所有祖先的进程计数\n  - `pids_cancel()`：内部辅助函数，执行实际的原子减操作，并检查负值（视为 bug）\n  - `pids_try_charge()`：**有条件**增加计数，若任一祖先层级超过限制则回滚并返回 `-EAGAIN`\n\n- **cgroup 钩子函数**\n  - `pids_can_attach()`：在任务迁移到新 cgroup 时，更新源/目标 cgroup 的计数\n  - `pids_cancel_attach()`：回滚 `pids_can_attach()` 的操作\n  - `pids_can_fork()`：在 `fork()` 前检查是否允许创建新进程（未在提供的代码片段中完整显示）\n  - `pids_cancel_fork()`：回滚 fork 失败时的计数（未在提供的代码片段中完整显示）\n\n- **事件通知**\n  - `pids_event()`：当 fork 因 PID 限制失败时，记录事件并通知用户空间（通过 `cgroup_file_notify`）\n\n- **辅助函数**\n  - `css_pids()`：从 `cgroup_subsys_state` 转换为 `pids_cgroup`\n  - `parent_pids()`：获取父 cgroup 的 `pids_cgroup`\n  - `pids_update_watermark()`：更新历史最高进程数（非原子，容忍竞态）\n\n## 3. 关键实现\n\n### 层级限制语义\nPID 限制遵循 cgroup 的层级继承规则：一个进程的实际限制由其所在 cgroup 路径上**所有祖先中最小的 `limit` 值**决定。`pids_try_charge()` 在从当前 cgroup 向根方向遍历时，一旦发现任一祖先的 `counter + num > limit`，即判定为违反策略。\n\n### 原子计数与回滚机制\n- 所有计数操作均使用 `atomic64_t` 保证并发安全。\n- `pids_try_charge()` 采用“先增加后检查+回滚”策略：先原子增加所有祖先计数，再逐级检查是否超限。若超限，则从当前节点回滚到起始节点的所有增量。\n- `pids_charge()` 用于必须成功的场景（如 attach 回滚），**不检查限制**，允许临时超限。\n\n### 事件通知机制\n- 当 fork 因限制失败时，调用 `pids_event()`：\n  - 在 fork 发生的 cgroup 中记录 `PIDCG_FORKFAIL` 事件（仅首次触发时打印内核日志）\n  - 若启用了本地事件（通过 `cgroup v2` 的 `pids.local_events` 选项），则仅通知本地事件文件\n  - 否则，在**触发限制的祖先 cgroup** 中记录 `PIDCG_MAX` 事件，并向上传播通知\n\n### 无限制表示\n使用 `PIDS_MAX = PID_MAX_LIMIT + 1` 表示“无限制”，因为实际 PID 数量不可能超过 `PID_MAX_LIMIT`，因此该值可安全用于比较（`new > limit` 永远为假）。\n\n## 4. 依赖关系\n\n- **`<linux/cgroup.h>`**：cgroup 核心框架，提供 `cgroup_subsys_state`、`cgroup_taskset` 等基础结构和钩子函数接口\n- **`<linux/atomic.h>`**：提供 64 位原子操作（`atomic64_t`）\n- **`<linux/sched/task.h>`**：提供 `task_css()` 等任务与 cgroup 关联的接口\n- **`<linux/slab.h>`**：内存分配（`kzalloc`/`kfree`）\n- **`pids_cgrp_id`**：全局子系统 ID，用于从 `css_set` 或 `task_struct` 中获取 PID 控制器状态\n- **`cgroup_threadgroup_change_begin()`**：确保在 `fork` 过程中 cgroup 关联稳定（`pids_can_fork` 依赖此锁）\n\n## 5. 使用场景\n\n1. **容器资源隔离**  \n   在容器运行时（如 Docker、Podman）中限制单个容器或 Pod 可创建的最大进程数，防止 fork bomb 耗尽系统 PID 资源。\n\n2. **多租户系统防护**  \n   在共享主机环境中，为不同用户或服务分配独立的 cgroup，并设置 PID 限制，避免某一用户进程泛滥影响其他用户。\n\n3. **系统稳定性保障**  \n   通过全局或关键服务 cgroup 设置 PID 上限，确保即使某个子系统异常，也不会导致整个系统因 PID 耗尽而无法创建新进程。\n\n4. **监控与告警**  \n   通过读取 `pids.current`、`pids.max` 和 `pids.events` 文件，监控进程使用情况并在接近或达到限制时触发告警。",
      "similarity": 0.5272923111915588,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 91,
          "end_line": 202,
          "content": [
            "static void pids_css_free(struct cgroup_subsys_state *css)",
            "{",
            "\tkfree(css_pids(css));",
            "}",
            "static void pids_update_watermark(struct pids_cgroup *p, int64_t nr_pids)",
            "{",
            "\t/*",
            "\t * This is racy, but we don't need perfectly accurate tallying of",
            "\t * the watermark, and this lets us avoid extra atomic overhead.",
            "\t */",
            "\tif (nr_pids > READ_ONCE(p->watermark))",
            "\t\tWRITE_ONCE(p->watermark, nr_pids);",
            "}",
            "static void pids_cancel(struct pids_cgroup *pids, int num)",
            "{",
            "\t/*",
            "\t * A negative count (or overflow for that matter) is invalid,",
            "\t * and indicates a bug in the `pids` controller proper.",
            "\t */",
            "\tWARN_ON_ONCE(atomic64_add_negative(-num, &pids->counter));",
            "}",
            "static void pids_uncharge(struct pids_cgroup *pids, int num)",
            "{",
            "\tstruct pids_cgroup *p;",
            "",
            "\tfor (p = pids; parent_pids(p); p = parent_pids(p))",
            "\t\tpids_cancel(p, num);",
            "}",
            "static void pids_charge(struct pids_cgroup *pids, int num)",
            "{",
            "\tstruct pids_cgroup *p;",
            "",
            "\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {",
            "\t\tint64_t new = atomic64_add_return(num, &p->counter);",
            "",
            "\t\tpids_update_watermark(p, new);",
            "\t}",
            "}",
            "static int pids_try_charge(struct pids_cgroup *pids, int num, struct pids_cgroup **fail)",
            "{",
            "\tstruct pids_cgroup *p, *q;",
            "",
            "\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {",
            "\t\tint64_t new = atomic64_add_return(num, &p->counter);",
            "\t\tint64_t limit = atomic64_read(&p->limit);",
            "",
            "\t\t/*",
            "\t\t * Since new is capped to the maximum number of pid_t, if",
            "\t\t * p->limit is %PIDS_MAX then we know that this test will never",
            "\t\t * fail.",
            "\t\t */",
            "\t\tif (new > limit) {",
            "\t\t\t*fail = p;",
            "\t\t\tgoto revert;",
            "\t\t}",
            "\t\t/*",
            "\t\t * Not technically accurate if we go over limit somewhere up",
            "\t\t * the hierarchy, but that's tolerable for the watermark.",
            "\t\t */",
            "\t\tpids_update_watermark(p, new);",
            "\t}",
            "",
            "\treturn 0;",
            "",
            "revert:",
            "\tfor (q = pids; q != p; q = parent_pids(q))",
            "\t\tpids_cancel(q, num);",
            "\tpids_cancel(p, num);",
            "",
            "\treturn -EAGAIN;",
            "}",
            "static int pids_can_attach(struct cgroup_taskset *tset)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct cgroup_subsys_state *dst_css;",
            "",
            "\tcgroup_taskset_for_each(task, dst_css, tset) {",
            "\t\tstruct pids_cgroup *pids = css_pids(dst_css);",
            "\t\tstruct cgroup_subsys_state *old_css;",
            "\t\tstruct pids_cgroup *old_pids;",
            "",
            "\t\t/*",
            "\t\t * No need to pin @old_css between here and cancel_attach()",
            "\t\t * because cgroup core protects it from being freed before",
            "\t\t * the migration completes or fails.",
            "\t\t */",
            "\t\told_css = task_css(task, pids_cgrp_id);",
            "\t\told_pids = css_pids(old_css);",
            "",
            "\t\tpids_charge(pids, 1);",
            "\t\tpids_uncharge(old_pids, 1);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void pids_cancel_attach(struct cgroup_taskset *tset)",
            "{",
            "\tstruct task_struct *task;",
            "\tstruct cgroup_subsys_state *dst_css;",
            "",
            "\tcgroup_taskset_for_each(task, dst_css, tset) {",
            "\t\tstruct pids_cgroup *pids = css_pids(dst_css);",
            "\t\tstruct cgroup_subsys_state *old_css;",
            "\t\tstruct pids_cgroup *old_pids;",
            "",
            "\t\told_css = task_css(task, pids_cgrp_id);",
            "\t\told_pids = css_pids(old_css);",
            "",
            "\t\tpids_charge(old_pids, 1);",
            "\t\tpids_uncharge(pids, 1);",
            "\t}",
            "}"
          ],
          "function_name": "pids_css_free, pids_update_watermark, pids_cancel, pids_uncharge, pids_charge, pids_try_charge, pids_can_attach, pids_cancel_attach",
          "description": "实现了pids控制器的资源充放电逻辑，包含分配/释放CSS结构、更新水位线、充放电操作及附件检查等功能。通过遍历祖先cgroup进行全局资源追踪，确保层级间限制一致性。",
          "similarity": 0.4961290955543518
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 243,
          "end_line": 344,
          "content": [
            "static void pids_event(struct pids_cgroup *pids_forking,",
            "\t\t       struct pids_cgroup *pids_over_limit)",
            "{",
            "\tstruct pids_cgroup *p = pids_forking;",
            "",
            "\t/* Only log the first time limit is hit. */",
            "\tif (atomic64_inc_return(&p->events_local[PIDCG_FORKFAIL]) == 1) {",
            "\t\tpr_info(\"cgroup: fork rejected by pids controller in \");",
            "\t\tpr_cont_cgroup_path(p->css.cgroup);",
            "\t\tpr_cont(\"\\n\");",
            "\t}",
            "\tif (!cgroup_subsys_on_dfl(pids_cgrp_subsys) ||",
            "\t    cgrp_dfl_root.flags & CGRP_ROOT_PIDS_LOCAL_EVENTS) {",
            "\t\tcgroup_file_notify(&p->events_local_file);",
            "\t\treturn;",
            "\t}",
            "",
            "\tatomic64_inc(&pids_over_limit->events_local[PIDCG_MAX]);",
            "\tcgroup_file_notify(&pids_over_limit->events_local_file);",
            "",
            "\tfor (p = pids_over_limit; parent_pids(p); p = parent_pids(p)) {",
            "\t\tatomic64_inc(&p->events[PIDCG_MAX]);",
            "\t\tcgroup_file_notify(&p->events_file);",
            "\t}",
            "}",
            "static int pids_can_fork(struct task_struct *task, struct css_set *cset)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct pids_cgroup *pids, *pids_over_limit;",
            "\tint err;",
            "",
            "\tif (cset)",
            "\t\tcss = cset->subsys[pids_cgrp_id];",
            "\telse",
            "\t\tcss = task_css_check(current, pids_cgrp_id, true);",
            "\tpids = css_pids(css);",
            "\terr = pids_try_charge(pids, 1, &pids_over_limit);",
            "\tif (err)",
            "\t\tpids_event(pids, pids_over_limit);",
            "",
            "\treturn err;",
            "}",
            "static void pids_cancel_fork(struct task_struct *task, struct css_set *cset)",
            "{",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct pids_cgroup *pids;",
            "",
            "\tif (cset)",
            "\t\tcss = cset->subsys[pids_cgrp_id];",
            "\telse",
            "\t\tcss = task_css_check(current, pids_cgrp_id, true);",
            "\tpids = css_pids(css);",
            "\tpids_uncharge(pids, 1);",
            "}",
            "static void pids_release(struct task_struct *task)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(task_css(task, pids_cgrp_id));",
            "",
            "\tpids_uncharge(pids, 1);",
            "}",
            "static ssize_t pids_max_write(struct kernfs_open_file *of, char *buf,",
            "\t\t\t      size_t nbytes, loff_t off)",
            "{",
            "\tstruct cgroup_subsys_state *css = of_css(of);",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "\tint64_t limit;",
            "\tint err;",
            "",
            "\tbuf = strstrip(buf);",
            "\tif (!strcmp(buf, PIDS_MAX_STR)) {",
            "\t\tlimit = PIDS_MAX;",
            "\t\tgoto set_limit;",
            "\t}",
            "",
            "\terr = kstrtoll(buf, 0, &limit);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif (limit < 0 || limit >= PIDS_MAX)",
            "\t\treturn -EINVAL;",
            "",
            "set_limit:",
            "\t/*",
            "\t * Limit updates don't need to be mutex'd, since it isn't",
            "\t * critical that any racing fork()s follow the new limit.",
            "\t */",
            "\tatomic64_set(&pids->limit, limit);",
            "\treturn nbytes;",
            "}",
            "static int pids_max_show(struct seq_file *sf, void *v)",
            "{",
            "\tstruct cgroup_subsys_state *css = seq_css(sf);",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "\tint64_t limit = atomic64_read(&pids->limit);",
            "",
            "\tif (limit >= PIDS_MAX)",
            "\t\tseq_printf(sf, \"%s\\n\", PIDS_MAX_STR);",
            "\telse",
            "\t\tseq_printf(sf, \"%lld\\n\", limit);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "pids_event, pids_can_fork, pids_cancel_fork, pids_release, pids_max_write, pids_max_show",
          "description": "处理进程创建时的配额检查与事件记录，包含can_fork检查、取消fork操作、任务释放及最大进程数配置接口。当达到硬限制时触发事件通知并拒绝fork请求。",
          "similarity": 0.4587516784667969
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 355,
          "end_line": 394,
          "content": [
            "static s64 pids_current_read(struct cgroup_subsys_state *css,",
            "\t\t\t     struct cftype *cft)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "",
            "\treturn atomic64_read(&pids->counter);",
            "}",
            "static s64 pids_peak_read(struct cgroup_subsys_state *css,",
            "\t\t\t  struct cftype *cft)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(css);",
            "",
            "\treturn READ_ONCE(pids->watermark);",
            "}",
            "static int __pids_events_show(struct seq_file *sf, bool local)",
            "{",
            "\tstruct pids_cgroup *pids = css_pids(seq_css(sf));",
            "\tenum pidcg_event pe = PIDCG_MAX;",
            "\tatomic64_t *events;",
            "",
            "\tif (!cgroup_subsys_on_dfl(pids_cgrp_subsys) ||",
            "\t    cgrp_dfl_root.flags & CGRP_ROOT_PIDS_LOCAL_EVENTS) {",
            "\t\tpe = PIDCG_FORKFAIL;",
            "\t\tlocal = true;",
            "\t}",
            "\tevents = local ? pids->events_local : pids->events;",
            "",
            "\tseq_printf(sf, \"max %lld\\n\", (s64)atomic64_read(&events[pe]));",
            "\treturn 0;",
            "}",
            "static int pids_events_show(struct seq_file *sf, void *v)",
            "{",
            "\t__pids_events_show(sf, false);",
            "\treturn 0;",
            "}",
            "static int pids_events_local_show(struct seq_file *sf, void *v)",
            "{",
            "\t__pids_events_show(sf, true);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "pids_current_read, pids_peak_read, __pids_events_show, pids_events_show, pids_events_local_show",
          "description": "暴露pids控制器的监控接口，包括当前任务数读取、历史峰值查询及事件统计展示。通过seq_file接口向用户空间导出运行时统计数据。",
          "similarity": 0.4573432505130768
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/cgroup/pids.c",
          "start_line": 1,
          "end_line": 90,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Process number limiting controller for cgroups.",
            " *",
            " * Used to allow a cgroup hierarchy to stop any new processes from fork()ing",
            " * after a certain limit is reached.",
            " *",
            " * Since it is trivial to hit the task limit without hitting any kmemcg limits",
            " * in place, PIDs are a fundamental resource. As such, PID exhaustion must be",
            " * preventable in the scope of a cgroup hierarchy by allowing resource limiting",
            " * of the number of tasks in a cgroup.",
            " *",
            " * In order to use the `pids` controller, set the maximum number of tasks in",
            " * pids.max (this is not available in the root cgroup for obvious reasons). The",
            " * number of processes currently in the cgroup is given by pids.current.",
            " * Organisational operations are not blocked by cgroup policies, so it is",
            " * possible to have pids.current > pids.max. However, it is not possible to",
            " * violate a cgroup policy through fork(). fork() will return -EAGAIN if forking",
            " * would cause a cgroup policy to be violated.",
            " *",
            " * To set a cgroup to have no limit, set pids.max to \"max\". This is the default",
            " * for all new cgroups (N.B. that PID limits are hierarchical, so the most",
            " * stringent limit in the hierarchy is followed).",
            " *",
            " * pids.current tracks all child cgroup hierarchies, so parent/pids.current is",
            " * a superset of parent/child/pids.current.",
            " *",
            " * Copyright (C) 2015 Aleksa Sarai <cyphar@cyphar.com>",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/threads.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "",
            "#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)",
            "#define PIDS_MAX_STR \"max\"",
            "",
            "enum pidcg_event {",
            "\t/* Fork failed in subtree because this pids_cgroup limit was hit. */",
            "\tPIDCG_MAX,",
            "\t/* Fork failed in this pids_cgroup because ancestor limit was hit. */",
            "\tPIDCG_FORKFAIL,",
            "\tNR_PIDCG_EVENTS,",
            "};",
            "",
            "struct pids_cgroup {",
            "\tstruct cgroup_subsys_state\tcss;",
            "",
            "\t/*",
            "\t * Use 64-bit types so that we can safely represent \"max\" as",
            "\t * %PIDS_MAX = (%PID_MAX_LIMIT + 1).",
            "\t */",
            "\tatomic64_t\t\t\tcounter;",
            "\tatomic64_t\t\t\tlimit;",
            "\tint64_t\t\t\t\twatermark;",
            "",
            "\t/* Handles for pids.events[.local] */",
            "\tstruct cgroup_file\t\tevents_file;",
            "\tstruct cgroup_file\t\tevents_local_file;",
            "",
            "\tatomic64_t\t\t\tevents[NR_PIDCG_EVENTS];",
            "\tatomic64_t\t\t\tevents_local[NR_PIDCG_EVENTS];",
            "};",
            "",
            "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)",
            "{",
            "\treturn container_of(css, struct pids_cgroup, css);",
            "}",
            "",
            "static struct pids_cgroup *parent_pids(struct pids_cgroup *pids)",
            "{",
            "\treturn css_pids(pids->css.parent);",
            "}",
            "",
            "static struct cgroup_subsys_state *",
            "pids_css_alloc(struct cgroup_subsys_state *parent)",
            "{",
            "\tstruct pids_cgroup *pids;",
            "",
            "\tpids = kzalloc(sizeof(struct pids_cgroup), GFP_KERNEL);",
            "\tif (!pids)",
            "\t\treturn ERR_PTR(-ENOMEM);",
            "",
            "\tatomic64_set(&pids->limit, PIDS_MAX);",
            "\treturn &pids->css;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了cgroup的pids控制器核心结构体pids_cgroup，包含原子计数器、限制值和事件统计字段，用于跟踪任务数量以防止进程爆炸。通过CSS子系统状态关联到cgroup层级，支持基于层级的资源限制。",
          "similarity": 0.44095128774642944
        }
      ]
    }
  ]
}