{
  "query": "socket缓冲区管理机制",
  "timestamp": "2025-12-26 01:19:33",
  "retrieved_files": [
    {
      "source_file": "kernel/seccomp.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:23:11\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `seccomp.c`\n\n---\n\n# seccomp.c 技术文档\n\n## 文件概述\n\n`seccomp.c` 是 Linux 内核中实现安全计算（Secure Computing，简称 seccomp）机制的核心文件。该机制用于限制进程可执行的系统调用，从而提升系统安全性。文件支持两种主要模式：\n\n- **Mode 1（严格模式）**：仅允许 `read`、`write`、`exit` 和 `sigreturn` 四个系统调用。\n- **Mode 2（过滤器模式）**：允许用户通过 Berkeley Packet Filter（BPF）形式定义自定义的系统调用过滤规则。\n\n此外，该文件还实现了 **用户空间通知（user-space notification）** 功能，允许内核在遇到特定系统调用时暂停执行并通知用户态监听器进行处理。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct seccomp_filter`**  \n  表示一个 seccomp BPF 过滤器实例，包含：\n  - 引用计数（`refs` 和 `users`）\n  - BPF 程序指针（`prog`）\n  - 通知相关结构（`notif`、`notify_lock`、`wqh`）\n  - 动作缓存（`cache`）\n  - 指向前一个过滤器的指针（`prev`），构成过滤器链\n\n- **`struct notification`**  \n  管理用户空间通知的容器，包含请求计数器、标志位、下一个通知 ID 和通知链表。\n\n- **`struct seccomp_knotif`**  \n  表示一个待处理的用户通知请求，记录触发通知的任务、系统调用数据、状态（INIT/SENT/REPLIED）、返回值及完成信号量。\n\n- **`struct seccomp_kaddfd`**  \n  用于 `SECCOMP_IOCTL_NOTIF_ADDFD` 操作，允许监听器向目标进程注入文件描述符。\n\n- **`struct action_cache`**（条件编译）  \n  针对原生和兼容架构的系统调用动作缓存，用于快速判断是否允许某系统调用，避免重复执行 BPF 程序。\n\n### 关键枚举与常量\n\n- **`enum notify_state`**：通知状态机（INIT → SENT → REPLIED）\n- **`SECCOMP_MODE_DEAD`**：内部使用的特殊模式，表示进程已进入不可恢复的 seccomp 状态\n- **`MAX_INSNS_PER_PATH`**：限制 BPF 指令路径总长度不超过 256KB，防止资源耗尽\n\n### 特殊兼容性处理\n\n- **`SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR`**：为兼容早期错误的 ioctl 命令方向而保留的旧定义\n\n## 关键实现\n\n### 过滤器生命周期管理\n\n- 使用双重引用计数机制：\n  - `refs`：控制对象内存释放（包括任务引用、依赖过滤器、通知监听器）\n  - `users`：跟踪直接或间接使用该过滤器的任务数量，用于判断是否还能被新任务继承\n- 过滤器一旦附加到任务，除引用计数外不可修改，确保并发安全\n\n### 用户空间通知机制\n\n- 当 BPF 程序返回 `SECCOMP_RET_USER_NOTIF` 时，内核创建 `seccomp_knotif` 并加入通知队列\n- 用户态通过文件描述符读取通知，内核将状态置为 `SENT`\n- 监听器通过 `ioctl` 回复结果，状态转为 `REPLIED`，触发 `completion` 使原任务继续执行\n- 支持通过 `SECCOMP_IOCTL_NOTIF_ADDFD` 向目标进程注入文件描述符\n\n### 动作缓存优化（`action_cache`）\n\n- 在支持 `SECCOMP_ARCH_NATIVE` 的架构上，为每个系统调用编号维护一个“始终允许”位图\n- 若缓存命中（即该系统调用在所有路径下均返回 `ALLOW`），可跳过 BPF 执行，提升性能\n- 分别处理原生（native）和兼容（compat）系统调用空间\n\n### 安全与资源限制\n\n- 限制 BPF 指令总路径长度，防止深度嵌套或循环导致 DoS\n- 通知机制使用互斥锁（`notify_lock`）和完成量（`completion`）保证状态一致性\n- 支持 `wait_killable_recv` 选项，使等待通知回复的进程可被信号中断\n\n## 依赖关系\n\n- **BPF 子系统**：依赖 `linux/filter.h` 提供的 socket filter/BPF 执行引擎\n- **进程管理**：与 `sched.h`、`task_struct` 紧密集成，管理 per-task seccomp 状态\n- **文件系统与 fd 管理**：通过 `file.h`、`uaccess.h` 实现跨进程 fd 注入\n- **审计与日志**：集成 `audit.h` 支持 seccomp 事件审计\n- **架构相关代码**：通过 `asm/syscall.h` 获取系统调用号和参数\n- **能力机制**：依赖 `capability.h` 检查特权操作权限\n- **内存管理**：使用 `slab.h` 分配过滤器和通知结构\n\n## 使用场景\n\n1. **容器安全**：Docker、LXC 等容器运行时使用 seccomp 过滤器限制容器内进程的系统调用，防止逃逸\n2. **沙箱应用**：Chromium、Firefox 等浏览器使用 seccomp 构建渲染进程沙箱\n3. **最小权限原则**：特权服务（如 systemd、sshd）在初始化后启用 seccomp 以减少攻击面\n4. **动态策略执行**：通过 `SECCOMP_RET_USER_NOTIF` 实现用户态代理系统调用（如 ptrace 替代方案）\n5. **安全审计**：结合 `SECCOMP_RET_LOG` 记录所有被拦截或允许的系统调用行为\n6. **系统加固**：在不可信环境中运行程序时，强制限制其系统调用能力",
      "similarity": 0.6195331811904907,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/seccomp.c",
          "start_line": 811,
          "end_line": 914,
          "content": [
            "static void seccomp_cache_prepare_bitmap(struct seccomp_filter *sfilter,",
            "\t\t\t\t\t void *bitmap, const void *bitmap_prev,",
            "\t\t\t\t\t size_t bitmap_size, int arch)",
            "{",
            "\tstruct sock_fprog_kern *fprog = sfilter->prog->orig_prog;",
            "\tstruct seccomp_data sd;",
            "\tint nr;",
            "",
            "\tif (bitmap_prev) {",
            "\t\t/* The new filter must be as restrictive as the last. */",
            "\t\tbitmap_copy(bitmap, bitmap_prev, bitmap_size);",
            "\t} else {",
            "\t\t/* Before any filters, all syscalls are always allowed. */",
            "\t\tbitmap_fill(bitmap, bitmap_size);",
            "\t}",
            "",
            "\tfor (nr = 0; nr < bitmap_size; nr++) {",
            "\t\t/* No bitmap change: not a cacheable action. */",
            "\t\tif (!test_bit(nr, bitmap))",
            "\t\t\tcontinue;",
            "",
            "\t\tsd.nr = nr;",
            "\t\tsd.arch = arch;",
            "",
            "\t\t/* No bitmap change: continue to always allow. */",
            "\t\tif (seccomp_is_const_allow(fprog, &sd))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Not a cacheable action: always run filters.",
            "\t\t * atomic clear_bit() not needed, filter not visible yet.",
            "\t\t */",
            "\t\t__clear_bit(nr, bitmap);",
            "\t}",
            "}",
            "static void seccomp_cache_prepare(struct seccomp_filter *sfilter)",
            "{",
            "\tstruct action_cache *cache = &sfilter->cache;",
            "\tconst struct action_cache *cache_prev =",
            "\t\tsfilter->prev ? &sfilter->prev->cache : NULL;",
            "",
            "\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_native,",
            "\t\t\t\t     cache_prev ? cache_prev->allow_native : NULL,",
            "\t\t\t\t     SECCOMP_ARCH_NATIVE_NR,",
            "\t\t\t\t     SECCOMP_ARCH_NATIVE);",
            "",
            "#ifdef SECCOMP_ARCH_COMPAT",
            "\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_compat,",
            "\t\t\t\t     cache_prev ? cache_prev->allow_compat : NULL,",
            "\t\t\t\t     SECCOMP_ARCH_COMPAT_NR,",
            "\t\t\t\t     SECCOMP_ARCH_COMPAT);",
            "#endif /* SECCOMP_ARCH_COMPAT */",
            "}",
            "static long seccomp_attach_filter(unsigned int flags,",
            "\t\t\t\t  struct seccomp_filter *filter)",
            "{",
            "\tunsigned long total_insns;",
            "\tstruct seccomp_filter *walker;",
            "",
            "\tassert_spin_locked(&current->sighand->siglock);",
            "",
            "\t/* Validate resulting filter length. */",
            "\ttotal_insns = filter->prog->len;",
            "\tfor (walker = current->seccomp.filter; walker; walker = walker->prev)",
            "\t\ttotal_insns += walker->prog->len + 4;  /* 4 instr penalty */",
            "\tif (total_insns > MAX_INSNS_PER_PATH)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/* If thread sync has been requested, check that it is possible. */",
            "\tif (flags & SECCOMP_FILTER_FLAG_TSYNC) {",
            "\t\tint ret;",
            "",
            "\t\tret = seccomp_can_sync_threads();",
            "\t\tif (ret) {",
            "\t\t\tif (flags & SECCOMP_FILTER_FLAG_TSYNC_ESRCH)",
            "\t\t\t\treturn -ESRCH;",
            "\t\t\telse",
            "\t\t\t\treturn ret;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Set log flag, if present. */",
            "\tif (flags & SECCOMP_FILTER_FLAG_LOG)",
            "\t\tfilter->log = true;",
            "",
            "\t/* Set wait killable flag, if present. */",
            "\tif (flags & SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV)",
            "\t\tfilter->wait_killable_recv = true;",
            "",
            "\t/*",
            "\t * If there is an existing filter, make it the prev and don't drop its",
            "\t * task reference.",
            "\t */",
            "\tfilter->prev = current->seccomp.filter;",
            "\tseccomp_cache_prepare(filter);",
            "\tcurrent->seccomp.filter = filter;",
            "\tatomic_inc(&current->seccomp.filter_count);",
            "",
            "\t/* Now that the new filter is in place, synchronize to all threads. */",
            "\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)",
            "\t\tseccomp_sync_threads(flags);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "seccomp_cache_prepare_bitmap, seccomp_cache_prepare, seccomp_attach_filter",
          "description": "实现过滤器预处理逻辑，seccomp_cache_prepare_bitmap构建允许位图，seccomp_cache_prepare初始化缓存，seccomp_attach_filter附加新过滤器并进行参数验证及线程同步。",
          "similarity": 0.579908013343811
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/seccomp.c",
          "start_line": 1340,
          "end_line": 1443,
          "content": [
            "static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,",
            "\t\t\t    const bool recheck_after_trace)",
            "{",
            "\tBUG();",
            "",
            "\treturn -1;",
            "}",
            "int __secure_computing(const struct seccomp_data *sd)",
            "{",
            "\tint mode = current->seccomp.mode;",
            "\tint this_syscall;",
            "",
            "\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&",
            "\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))",
            "\t\treturn 0;",
            "",
            "\tthis_syscall = sd ? sd->nr :",
            "\t\tsyscall_get_nr(current, current_pt_regs());",
            "",
            "\tswitch (mode) {",
            "\tcase SECCOMP_MODE_STRICT:",
            "\t\t__secure_computing_strict(this_syscall);  /* may call do_exit */",
            "\t\treturn 0;",
            "\tcase SECCOMP_MODE_FILTER:",
            "\t\treturn __seccomp_filter(this_syscall, sd, false);",
            "\t/* Surviving SECCOMP_RET_KILL_* must be proactively impossible. */",
            "\tcase SECCOMP_MODE_DEAD:",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tdo_exit(SIGKILL);",
            "\t\treturn -1;",
            "\tdefault:",
            "\t\tBUG();",
            "\t}",
            "}",
            "long prctl_get_seccomp(void)",
            "{",
            "\treturn current->seccomp.mode;",
            "}",
            "static long seccomp_set_mode_strict(void)",
            "{",
            "\tconst unsigned long seccomp_mode = SECCOMP_MODE_STRICT;",
            "\tlong ret = -EINVAL;",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "",
            "\tif (!seccomp_may_assign_mode(seccomp_mode))",
            "\t\tgoto out;",
            "",
            "#ifdef TIF_NOTSC",
            "\tdisable_TSC();",
            "#endif",
            "\tseccomp_assign_mode(current, seccomp_mode, 0);",
            "\tret = 0;",
            "",
            "out:",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "",
            "\treturn ret;",
            "}",
            "static void seccomp_notify_free(struct seccomp_filter *filter)",
            "{",
            "\tkfree(filter->notif);",
            "\tfilter->notif = NULL;",
            "}",
            "static void seccomp_notify_detach(struct seccomp_filter *filter)",
            "{",
            "\tstruct seccomp_knotif *knotif;",
            "",
            "\tif (!filter)",
            "\t\treturn;",
            "",
            "\tmutex_lock(&filter->notify_lock);",
            "",
            "\t/*",
            "\t * If this file is being closed because e.g. the task who owned it",
            "\t * died, let's wake everyone up who was waiting on us.",
            "\t */",
            "\tlist_for_each_entry(knotif, &filter->notif->notifications, list) {",
            "\t\tif (knotif->state == SECCOMP_NOTIFY_REPLIED)",
            "\t\t\tcontinue;",
            "",
            "\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;",
            "\t\tknotif->error = -ENOSYS;",
            "\t\tknotif->val = 0;",
            "",
            "\t\t/*",
            "\t\t * We do not need to wake up any pending addfd messages, as",
            "\t\t * the notifier will do that for us, as this just looks",
            "\t\t * like a standard reply.",
            "\t\t */",
            "\t\tcomplete(&knotif->ready);",
            "\t}",
            "",
            "\tseccomp_notify_free(filter);",
            "\tmutex_unlock(&filter->notify_lock);",
            "}",
            "static int seccomp_notify_release(struct inode *inode, struct file *file)",
            "{",
            "\tstruct seccomp_filter *filter = file->private_data;",
            "",
            "\tseccomp_notify_detach(filter);",
            "\t__put_seccomp_filter(filter);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__seccomp_filter, __secure_computing, prctl_get_seccomp, seccomp_set_mode_strict, seccomp_notify_free, seccomp_notify_detach, seccomp_notify_release",
          "description": "提供seccomp模式切换接口(prctl_get_seccomp/seccomp_set_mode_strict)，实现通知资源释放(detach/release)机制",
          "similarity": 0.562053918838501
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/seccomp.c",
          "start_line": 1477,
          "end_line": 1578,
          "content": [
            "static int recv_wake_function(wait_queue_entry_t *wait, unsigned int mode, int sync,",
            "\t\t\t\t  void *key)",
            "{",
            "\t/* Avoid a wakeup if event not interesting for us. */",
            "\tif (key && !(key_to_poll(key) & (EPOLLIN | EPOLLERR)))",
            "\t\treturn 0;",
            "\treturn autoremove_wake_function(wait, mode, sync, key);",
            "}",
            "static int recv_wait_event(struct seccomp_filter *filter)",
            "{",
            "\tDEFINE_WAIT_FUNC(wait, recv_wake_function);",
            "\tint ret;",
            "",
            "\tif (atomic_dec_if_positive(&filter->notif->requests) >= 0)",
            "\t\treturn 0;",
            "",
            "\tfor (;;) {",
            "\t\tret = prepare_to_wait_event(&filter->wqh, &wait, TASK_INTERRUPTIBLE);",
            "",
            "\t\tif (atomic_dec_if_positive(&filter->notif->requests) >= 0)",
            "\t\t\tbreak;",
            "",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "",
            "\t\tschedule();",
            "\t}",
            "\tfinish_wait(&filter->wqh, &wait);",
            "\treturn 0;",
            "}",
            "static long seccomp_notify_recv(struct seccomp_filter *filter,",
            "\t\t\t\tvoid __user *buf)",
            "{",
            "\tstruct seccomp_knotif *knotif = NULL, *cur;",
            "\tstruct seccomp_notif unotif;",
            "\tssize_t ret;",
            "",
            "\t/* Verify that we're not given garbage to keep struct extensible. */",
            "\tret = check_zeroed_user(buf, sizeof(unotif));",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "\tif (!ret)",
            "\t\treturn -EINVAL;",
            "",
            "\tmemset(&unotif, 0, sizeof(unotif));",
            "",
            "\tret = recv_wait_event(filter);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tmutex_lock(&filter->notify_lock);",
            "\tlist_for_each_entry(cur, &filter->notif->notifications, list) {",
            "\t\tif (cur->state == SECCOMP_NOTIFY_INIT) {",
            "\t\t\tknotif = cur;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * If we didn't find a notification, it could be that the task was",
            "\t * interrupted by a fatal signal between the time we were woken and",
            "\t * when we were able to acquire the rw lock.",
            "\t */",
            "\tif (!knotif) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tunotif.id = knotif->id;",
            "\tunotif.pid = task_pid_vnr(knotif->task);",
            "\tunotif.data = *(knotif->data);",
            "",
            "\tknotif->state = SECCOMP_NOTIFY_SENT;",
            "\twake_up_poll(&filter->wqh, EPOLLOUT | EPOLLWRNORM);",
            "\tret = 0;",
            "out:",
            "\tmutex_unlock(&filter->notify_lock);",
            "",
            "\tif (ret == 0 && copy_to_user(buf, &unotif, sizeof(unotif))) {",
            "\t\tret = -EFAULT;",
            "",
            "\t\t/*",
            "\t\t * Userspace screwed up. To make sure that we keep this",
            "\t\t * notification alive, let's reset it back to INIT. It",
            "\t\t * may have died when we released the lock, so we need to make",
            "\t\t * sure it's still around.",
            "\t\t */",
            "\t\tmutex_lock(&filter->notify_lock);",
            "\t\tknotif = find_notification(filter, unotif.id);",
            "\t\tif (knotif) {",
            "\t\t\t/* Reset the process to make sure it's not stuck */",
            "\t\t\tif (should_sleep_killable(filter, knotif))",
            "\t\t\t\tcomplete(&knotif->ready);",
            "\t\t\tknotif->state = SECCOMP_NOTIFY_INIT;",
            "\t\t\tatomic_inc(&filter->notif->requests);",
            "\t\t\twake_up_poll(&filter->wqh, EPOLLIN | EPOLLRDNORM);",
            "\t\t}",
            "\t\tmutex_unlock(&filter->notify_lock);",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "recv_wake_function, recv_wait_event, seccomp_notify_recv",
          "description": "实现通知接收等待队列管理(recv_wait_event)和用户态数据接收(seccomp_notify_recv)的同步控制",
          "similarity": 0.5564194321632385
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/seccomp.c",
          "start_line": 1582,
          "end_line": 1778,
          "content": [
            "static long seccomp_notify_send(struct seccomp_filter *filter,",
            "\t\t\t\tvoid __user *buf)",
            "{",
            "\tstruct seccomp_notif_resp resp = {};",
            "\tstruct seccomp_knotif *knotif;",
            "\tlong ret;",
            "",
            "\tif (copy_from_user(&resp, buf, sizeof(resp)))",
            "\t\treturn -EFAULT;",
            "",
            "\tif (resp.flags & ~SECCOMP_USER_NOTIF_FLAG_CONTINUE)",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((resp.flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE) &&",
            "\t    (resp.error || resp.val))",
            "\t\treturn -EINVAL;",
            "",
            "\tret = mutex_lock_interruptible(&filter->notify_lock);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tknotif = find_notification(filter, resp.id);",
            "\tif (!knotif) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* Allow exactly one reply. */",
            "\tif (knotif->state != SECCOMP_NOTIFY_SENT) {",
            "\t\tret = -EINPROGRESS;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = 0;",
            "\tknotif->state = SECCOMP_NOTIFY_REPLIED;",
            "\tknotif->error = resp.error;",
            "\tknotif->val = resp.val;",
            "\tknotif->flags = resp.flags;",
            "\tif (filter->notif->flags & SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP)",
            "\t\tcomplete_on_current_cpu(&knotif->ready);",
            "\telse",
            "\t\tcomplete(&knotif->ready);",
            "out:",
            "\tmutex_unlock(&filter->notify_lock);",
            "\treturn ret;",
            "}",
            "static long seccomp_notify_id_valid(struct seccomp_filter *filter,",
            "\t\t\t\t    void __user *buf)",
            "{",
            "\tstruct seccomp_knotif *knotif;",
            "\tu64 id;",
            "\tlong ret;",
            "",
            "\tif (copy_from_user(&id, buf, sizeof(id)))",
            "\t\treturn -EFAULT;",
            "",
            "\tret = mutex_lock_interruptible(&filter->notify_lock);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\tknotif = find_notification(filter, id);",
            "\tif (knotif && knotif->state == SECCOMP_NOTIFY_SENT)",
            "\t\tret = 0;",
            "\telse",
            "\t\tret = -ENOENT;",
            "",
            "\tmutex_unlock(&filter->notify_lock);",
            "\treturn ret;",
            "}",
            "static long seccomp_notify_set_flags(struct seccomp_filter *filter,",
            "\t\t\t\t    unsigned long flags)",
            "{",
            "\tlong ret;",
            "",
            "\tif (flags & ~SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP)",
            "\t\treturn -EINVAL;",
            "",
            "\tret = mutex_lock_interruptible(&filter->notify_lock);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "\tfilter->notif->flags = flags;",
            "\tmutex_unlock(&filter->notify_lock);",
            "\treturn 0;",
            "}",
            "static long seccomp_notify_addfd(struct seccomp_filter *filter,",
            "\t\t\t\t struct seccomp_notif_addfd __user *uaddfd,",
            "\t\t\t\t unsigned int size)",
            "{",
            "\tstruct seccomp_notif_addfd addfd;",
            "\tstruct seccomp_knotif *knotif;",
            "\tstruct seccomp_kaddfd kaddfd;",
            "\tint ret;",
            "",
            "\tBUILD_BUG_ON(sizeof(addfd) < SECCOMP_NOTIFY_ADDFD_SIZE_VER0);",
            "\tBUILD_BUG_ON(sizeof(addfd) != SECCOMP_NOTIFY_ADDFD_SIZE_LATEST);",
            "",
            "\tif (size < SECCOMP_NOTIFY_ADDFD_SIZE_VER0 || size >= PAGE_SIZE)",
            "\t\treturn -EINVAL;",
            "",
            "\tret = copy_struct_from_user(&addfd, sizeof(addfd), uaddfd, size);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (addfd.newfd_flags & ~O_CLOEXEC)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (addfd.flags & ~(SECCOMP_ADDFD_FLAG_SETFD | SECCOMP_ADDFD_FLAG_SEND))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (addfd.newfd && !(addfd.flags & SECCOMP_ADDFD_FLAG_SETFD))",
            "\t\treturn -EINVAL;",
            "",
            "\tkaddfd.file = fget(addfd.srcfd);",
            "\tif (!kaddfd.file)",
            "\t\treturn -EBADF;",
            "",
            "\tkaddfd.ioctl_flags = addfd.flags;",
            "\tkaddfd.flags = addfd.newfd_flags;",
            "\tkaddfd.setfd = addfd.flags & SECCOMP_ADDFD_FLAG_SETFD;",
            "\tkaddfd.fd = addfd.newfd;",
            "\tinit_completion(&kaddfd.completion);",
            "",
            "\tret = mutex_lock_interruptible(&filter->notify_lock);",
            "\tif (ret < 0)",
            "\t\tgoto out;",
            "",
            "\tknotif = find_notification(filter, addfd.id);",
            "\tif (!knotif) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\t/*",
            "\t * We do not want to allow for FD injection to occur before the",
            "\t * notification has been picked up by a userspace handler, or after",
            "\t * the notification has been replied to.",
            "\t */",
            "\tif (knotif->state != SECCOMP_NOTIFY_SENT) {",
            "\t\tret = -EINPROGRESS;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tif (addfd.flags & SECCOMP_ADDFD_FLAG_SEND) {",
            "\t\t/*",
            "\t\t * Disallow queuing an atomic addfd + send reply while there are",
            "\t\t * some addfd requests still to process.",
            "\t\t *",
            "\t\t * There is no clear reason to support it and allows us to keep",
            "\t\t * the loop on the other side straight-forward.",
            "\t\t */",
            "\t\tif (!list_empty(&knotif->addfd)) {",
            "\t\t\tret = -EBUSY;",
            "\t\t\tgoto out_unlock;",
            "\t\t}",
            "",
            "\t\t/* Allow exactly only one reply */",
            "\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;",
            "\t}",
            "",
            "\tlist_add(&kaddfd.list, &knotif->addfd);",
            "\tcomplete(&knotif->ready);",
            "\tmutex_unlock(&filter->notify_lock);",
            "",
            "\t/* Now we wait for it to be processed or be interrupted */",
            "\tret = wait_for_completion_interruptible(&kaddfd.completion);",
            "\tif (ret == 0) {",
            "\t\t/*",
            "\t\t * We had a successful completion. The other side has already",
            "\t\t * removed us from the addfd queue, and",
            "\t\t * wait_for_completion_interruptible has a memory barrier upon",
            "\t\t * success that lets us read this value directly without",
            "\t\t * locking.",
            "\t\t */",
            "\t\tret = kaddfd.ret;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tmutex_lock(&filter->notify_lock);",
            "\t/*",
            "\t * Even though we were woken up by a signal and not a successful",
            "\t * completion, a completion may have happened in the mean time.",
            "\t *",
            "\t * We need to check again if the addfd request has been handled,",
            "\t * and if not, we will remove it from the queue.",
            "\t */",
            "\tif (list_empty(&kaddfd.list))",
            "\t\tret = kaddfd.ret;",
            "\telse",
            "\t\tlist_del(&kaddfd.list);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&filter->notify_lock);",
            "out:",
            "\tfput(kaddfd.file);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "seccomp_notify_send, seccomp_notify_id_valid, seccomp_notify_set_flags, seccomp_notify_addfd",
          "description": "该代码段实现了seccomp过滤器中用户空间通知机制的相关功能，核心作用是处理通知响应、验证通知ID、配置通知标志及管理文件描述符注入。  \n`seccomp_notify_send`接收并处理用户空间的响应数据，校验合法性后更新通知状态；`seccomp_notify_id_valid`验证指定ID的通知是否存在；`seccomp_notify_set_flags`和`seccomp_notify_addfd`分别用于设置通知标志和安全地注入文件描述符，均通过互斥锁保护关键操作。  \n代码片段完整，未引入额外API，所有行为均基于现有内核seccomp通知框架实现。",
          "similarity": 0.5553302764892578
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/seccomp.c",
          "start_line": 1783,
          "end_line": 1952,
          "content": [
            "static long seccomp_notify_ioctl(struct file *file, unsigned int cmd,",
            "\t\t\t\t unsigned long arg)",
            "{",
            "\tstruct seccomp_filter *filter = file->private_data;",
            "\tvoid __user *buf = (void __user *)arg;",
            "",
            "\t/* Fixed-size ioctls */",
            "\tswitch (cmd) {",
            "\tcase SECCOMP_IOCTL_NOTIF_RECV:",
            "\t\treturn seccomp_notify_recv(filter, buf);",
            "\tcase SECCOMP_IOCTL_NOTIF_SEND:",
            "\t\treturn seccomp_notify_send(filter, buf);",
            "\tcase SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR:",
            "\tcase SECCOMP_IOCTL_NOTIF_ID_VALID:",
            "\t\treturn seccomp_notify_id_valid(filter, buf);",
            "\tcase SECCOMP_IOCTL_NOTIF_SET_FLAGS:",
            "\t\treturn seccomp_notify_set_flags(filter, arg);",
            "\t}",
            "",
            "\t/* Extensible Argument ioctls */",
            "#define EA_IOCTL(cmd)\t((cmd) & ~(IOC_INOUT | IOCSIZE_MASK))",
            "\tswitch (EA_IOCTL(cmd)) {",
            "\tcase EA_IOCTL(SECCOMP_IOCTL_NOTIF_ADDFD):",
            "\t\treturn seccomp_notify_addfd(filter, buf, _IOC_SIZE(cmd));",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "}",
            "static __poll_t seccomp_notify_poll(struct file *file,",
            "\t\t\t\t    struct poll_table_struct *poll_tab)",
            "{",
            "\tstruct seccomp_filter *filter = file->private_data;",
            "\t__poll_t ret = 0;",
            "\tstruct seccomp_knotif *cur;",
            "",
            "\tpoll_wait(file, &filter->wqh, poll_tab);",
            "",
            "\tif (mutex_lock_interruptible(&filter->notify_lock) < 0)",
            "\t\treturn EPOLLERR;",
            "",
            "\tlist_for_each_entry(cur, &filter->notif->notifications, list) {",
            "\t\tif (cur->state == SECCOMP_NOTIFY_INIT)",
            "\t\t\tret |= EPOLLIN | EPOLLRDNORM;",
            "\t\tif (cur->state == SECCOMP_NOTIFY_SENT)",
            "\t\t\tret |= EPOLLOUT | EPOLLWRNORM;",
            "\t\tif ((ret & EPOLLIN) && (ret & EPOLLOUT))",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\tmutex_unlock(&filter->notify_lock);",
            "",
            "\tif (refcount_read(&filter->users) == 0)",
            "\t\tret |= EPOLLHUP;",
            "",
            "\treturn ret;",
            "}",
            "static bool has_duplicate_listener(struct seccomp_filter *new_child)",
            "{",
            "\tstruct seccomp_filter *cur;",
            "",
            "\t/* must be protected against concurrent TSYNC */",
            "\tlockdep_assert_held(&current->sighand->siglock);",
            "",
            "\tif (!new_child->notif)",
            "\t\treturn false;",
            "\tfor (cur = current->seccomp.filter; cur; cur = cur->prev) {",
            "\t\tif (cur->notif)",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static long seccomp_set_mode_filter(unsigned int flags,",
            "\t\t\t\t    const char __user *filter)",
            "{",
            "\tconst unsigned long seccomp_mode = SECCOMP_MODE_FILTER;",
            "\tstruct seccomp_filter *prepared = NULL;",
            "\tlong ret = -EINVAL;",
            "\tint listener = -1;",
            "\tstruct file *listener_f = NULL;",
            "",
            "\t/* Validate flags. */",
            "\tif (flags & ~SECCOMP_FILTER_FLAG_MASK)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * In the successful case, NEW_LISTENER returns the new listener fd.",
            "\t * But in the failure case, TSYNC returns the thread that died. If you",
            "\t * combine these two flags, there's no way to tell whether something",
            "\t * succeeded or failed. So, let's disallow this combination if the user",
            "\t * has not explicitly requested no errors from TSYNC.",
            "\t */",
            "\tif ((flags & SECCOMP_FILTER_FLAG_TSYNC) &&",
            "\t    (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) &&",
            "\t    ((flags & SECCOMP_FILTER_FLAG_TSYNC_ESRCH) == 0))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * The SECCOMP_FILTER_FLAG_WAIT_KILLABLE_SENT flag doesn't make sense",
            "\t * without the SECCOMP_FILTER_FLAG_NEW_LISTENER flag.",
            "\t */",
            "\tif ((flags & SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV) &&",
            "\t    ((flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) == 0))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Prepare the new filter before holding any locks. */",
            "\tprepared = seccomp_prepare_user_filter(filter);",
            "\tif (IS_ERR(prepared))",
            "\t\treturn PTR_ERR(prepared);",
            "",
            "\tif (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) {",
            "\t\tlistener = get_unused_fd_flags(O_CLOEXEC);",
            "\t\tif (listener < 0) {",
            "\t\t\tret = listener;",
            "\t\t\tgoto out_free;",
            "\t\t}",
            "",
            "\t\tlistener_f = init_listener(prepared);",
            "\t\tif (IS_ERR(listener_f)) {",
            "\t\t\tput_unused_fd(listener);",
            "\t\t\tret = PTR_ERR(listener_f);",
            "\t\t\tgoto out_free;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * Make sure we cannot change seccomp or nnp state via TSYNC",
            "\t * while another thread is in the middle of calling exec.",
            "\t */",
            "\tif (flags & SECCOMP_FILTER_FLAG_TSYNC &&",
            "\t    mutex_lock_killable(&current->signal->cred_guard_mutex))",
            "\t\tgoto out_put_fd;",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "",
            "\tif (!seccomp_may_assign_mode(seccomp_mode))",
            "\t\tgoto out;",
            "",
            "\tif (has_duplicate_listener(prepared)) {",
            "\t\tret = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = seccomp_attach_filter(flags, prepared);",
            "\tif (ret)",
            "\t\tgoto out;",
            "\t/* Do not free the successfully attached filter. */",
            "\tprepared = NULL;",
            "",
            "\tseccomp_assign_mode(current, seccomp_mode, flags);",
            "out:",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)",
            "\t\tmutex_unlock(&current->signal->cred_guard_mutex);",
            "out_put_fd:",
            "\tif (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) {",
            "\t\tif (ret) {",
            "\t\t\tlistener_f->private_data = NULL;",
            "\t\t\tfput(listener_f);",
            "\t\t\tput_unused_fd(listener);",
            "\t\t\tseccomp_notify_detach(prepared);",
            "\t\t} else {",
            "\t\t\tfd_install(listener, listener_f);",
            "\t\t\tret = listener;",
            "\t\t}",
            "\t}",
            "out_free:",
            "\tseccomp_filter_free(prepared);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "seccomp_notify_ioctl, seccomp_notify_poll, has_duplicate_listener, seccomp_set_mode_filter",
          "description": "该代码段实现seccomp过滤器的通知机制与模式配置功能。  \n`seccomp_notify_ioctl`处理通知相关的IOCTL命令，支持接收/发送通知及扩展参数操作；`seccomp_notify_poll`通过轮询检测过滤器状态变化并设置对应epoll掩码；`has_duplicate_listener`检查是否存在重复监听器以避免资源冲突，`seccomp_set_mode_filter`负责设置过滤模式并管理监听器创建与同步。  \n注：代码未展示全部上下文，如`seccomp_prepare_user_filter`等辅助函数的具体实现。",
          "similarity": 0.5541046857833862
        }
      ]
    },
    {
      "source_file": "kernel/watch_queue.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:50:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `watch_queue.c`\n\n---\n\n# watch_queue.c 技术文档\n\n## 文件概述\n\n`watch_queue.c` 实现了 Linux 内核中的**监视队列**（Watch Queue）机制，这是一种基于管道（pipe）构建的通用事件通知系统。该机制允许内核子系统（如文件系统、密钥管理、设备驱动等）向用户空间异步发送结构化通知。用户空间通过创建特殊类型的管道并关联监视队列，即可接收来自内核的各类事件通知。该文件定义了通知的投递、过滤、缓冲管理及与管道集成的核心逻辑。\n\n## 核心功能\n\n### 主要函数\n\n- **`__post_watch_notification()`**  \n  核心通知投递函数。遍历指定 `watch_list` 中所有匹配 `id` 的监视器（`watch`），对每个关联的 `watch_queue` 应用过滤规则、安全检查，并将通知写入底层管道。\n\n- **`post_one_notification()`**  \n  将单个通知写入指定 `watch_queue` 的底层管道缓冲区。负责从预分配的通知页中获取空闲槽位、填充数据、更新管道头指针并唤醒等待读取的进程。\n\n- **`filter_watch_notification()`**  \n  根据 `watch_filter` 中的类型、子类型和信息掩码规则，判断是否允许特定通知通过。\n\n- **`watch_queue_set_size()`**  \n  为监视队列分配预分配的通知缓冲区（页数组和位图），并调整底层管道的环形缓冲区大小。\n\n- **`watch_queue_pipe_buf_release()`**  \n  管道缓冲区释放回调。当用户空间读取完通知后，将对应的通知槽位在位图中标记为空闲，供后续复用。\n\n### 关键数据结构\n\n- **`struct watch_queue`**  \n  表示一个监视队列，包含：\n  - 指向底层 `pipe_inode_info` 的指针\n  - 预分配的通知页数组（`notes`）\n  - 通知槽位空闲位图（`notes_bitmap`）\n  - 通知过滤器（`filter`）\n  - 保护锁（`lock`）\n\n- **`struct watch_notification`**  \n  通用通知记录格式，包含类型（`type`）、子类型（`subtype`）、信息字段（`info`，含长度和ID）及可变负载。\n\n- **`struct watch_filter` / `struct watch_type_filter`**  \n  定义通知过滤规则，支持按类型、子类型及信息字段的位掩码进行精确过滤。\n\n- **`watch_queue_pipe_buf_ops`**  \n  自定义的 `pipe_buf_operations`，用于管理监视队列专用管道缓冲区的生命周期。\n\n## 关键实现\n\n### 基于管道的通知传输\n- 监视队列复用内核管道（`pipe_inode_info`）作为通知传输通道，利用其成熟的读写、轮询、异步通知机制。\n- 通过自定义 `pipe_buf_operations`（`watch_queue_pipe_buf_ops`）实现通知槽位的回收：当用户读取通知后，`release` 回调将对应槽位在 `notes_bitmap` 中置位，标记为空闲。\n\n### 预分配通知缓冲区\n- 通知数据存储在预分配的内核页（`notes`）中，每页划分为多个固定大小（128字节）的槽位（`WATCH_QUEUE_NOTE_SIZE`）。\n- 使用位图（`notes_bitmap`）跟踪槽位使用状态，1 表示空闲。投递通知时通过 `find_first_bit()` 快速查找空闲槽位。\n- 缓冲区大小由用户通过 `watch_queue_set_size()` 设置（1-512个通知），并受管道缓冲区配额限制。\n\n### 通知投递流程\n1. **匹配监视器**：遍历 `watch_list`，查找 `id` 匹配的 `watch`。\n2. **应用过滤**：若队列配置了过滤器，调用 `filter_watch_notification()` 决定是否丢弃。\n3. **安全检查**：调用 LSM 钩子 `security_post_notification()` 进行权限验证。\n4. **写入管道**：\n   - 获取空闲通知槽位，复制通知数据。\n   - 构造 `pipe_buffer` 指向该槽位，设置自定义操作集。\n   - 更新管道 `head` 指针，唤醒等待读取的进程。\n   - 若缓冲区满，标记前一个缓冲区为 `PIPE_BUF_FLAG_LOSS` 表示丢包。\n\n### 并发与同步\n- **RCU 保护**：`watch_list` 和 `watch_queue` 的访问通过 RCU 机制保护，确保遍历时结构体不被释放。\n- **自旋锁**：\n  - `wqueue->lock`：保护 `wqueue` 状态（如 `pipe` 指针有效性）。\n  - `pipe->rd_wait.lock`：保护管道环形缓冲区的读写操作。\n- **原子操作**：管道 `head` 指针使用 `smp_store_release()` 更新，确保与 `pipe_read()` 的同步。\n\n## 依赖关系\n\n- **管道子系统**（`fs/pipe.c`）  \n  依赖管道的核心数据结构（`pipe_inode_info`、`pipe_buffer`）和操作接口（`pipe_buf()`、`pipe_full()`、`generic_pipe_buf_*`）。\n\n- **内存管理**  \n  使用 `alloc_page()`、`kmap_atomic()` 管理通知缓冲区页，`bitmap_alloc()` 管理槽位位图。\n\n- **安全模块**（LSM）  \n  通过 `security_post_notification()` 钩子集成安全策略。\n\n- **用户空间接口**  \n  与 `fs/watch_queue.c` 中的系统调用（如 `watch_queue_set_size()`）协同工作，后者负责创建监视队列并与管道关联。\n\n- **头文件依赖**  \n  `linux/watch_queue.h`（核心数据结构定义）、`linux/pipe_fs_i.h`（管道内部接口）。\n\n## 使用场景\n\n- **文件系统事件监控**  \n  如 `fsnotify` 子系统可通过监视队列向用户空间报告文件访问、修改等事件。\n\n- **密钥管理通知**  \n  内核密钥环（`KEYS`）子系统使用该机制通知密钥状态变更（如过期、撤销）。\n\n- **设备事件上报**  \n  设备驱动可利用监视队列异步上报硬件状态变化或错误事件。\n\n- **通用内核事件分发**  \n  任何需要向特权用户空间守护进程（如 `systemd`）发送结构化事件的内核子系统均可集成此机制。\n\n- **用户空间消费**  \n  应用程序通过 `open(\"/dev/watch_queue\")` 获取监视队列文件描述符，调用 `ioctl()` 设置缓冲区大小和过滤器，然后像读取普通管道一样接收通知。",
      "similarity": 0.6080842018127441,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/watch_queue.c",
          "start_line": 42,
          "end_line": 154,
          "content": [
            "static inline bool lock_wqueue(struct watch_queue *wqueue)",
            "{",
            "\tspin_lock_bh(&wqueue->lock);",
            "\tif (unlikely(!wqueue->pipe)) {",
            "\t\tspin_unlock_bh(&wqueue->lock);",
            "\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static inline void unlock_wqueue(struct watch_queue *wqueue)",
            "{",
            "\tspin_unlock_bh(&wqueue->lock);",
            "}",
            "static void watch_queue_pipe_buf_release(struct pipe_inode_info *pipe,",
            "\t\t\t\t\t struct pipe_buffer *buf)",
            "{",
            "\tstruct watch_queue *wqueue = (struct watch_queue *)buf->private;",
            "\tstruct page *page;",
            "\tunsigned int bit;",
            "",
            "\t/* We need to work out which note within the page this refers to, but",
            "\t * the note might have been maximum size, so merely ANDing the offset",
            "\t * off doesn't work.  OTOH, the note must've been more than zero size.",
            "\t */",
            "\tbit = buf->offset + buf->len;",
            "\tif ((bit & (WATCH_QUEUE_NOTE_SIZE - 1)) == 0)",
            "\t\tbit -= WATCH_QUEUE_NOTE_SIZE;",
            "\tbit /= WATCH_QUEUE_NOTE_SIZE;",
            "",
            "\tpage = buf->page;",
            "\tbit += page->index;",
            "",
            "\tset_bit(bit, wqueue->notes_bitmap);",
            "\tgeneric_pipe_buf_release(pipe, buf);",
            "}",
            "static bool post_one_notification(struct watch_queue *wqueue,",
            "\t\t\t\t  struct watch_notification *n)",
            "{",
            "\tvoid *p;",
            "\tstruct pipe_inode_info *pipe = wqueue->pipe;",
            "\tstruct pipe_buffer *buf;",
            "\tstruct page *page;",
            "\tunsigned int head, tail, note, offset, len;",
            "\tbool done = false;",
            "",
            "\tspin_lock_irq(&pipe->rd_wait.lock);",
            "",
            "\thead = pipe->head;",
            "\ttail = pipe->tail;",
            "\tif (pipe_full(head, tail, pipe->ring_size))",
            "\t\tgoto lost;",
            "",
            "\tnote = find_first_bit(wqueue->notes_bitmap, wqueue->nr_notes);",
            "\tif (note >= wqueue->nr_notes)",
            "\t\tgoto lost;",
            "",
            "\tpage = wqueue->notes[note / WATCH_QUEUE_NOTES_PER_PAGE];",
            "\toffset = note % WATCH_QUEUE_NOTES_PER_PAGE * WATCH_QUEUE_NOTE_SIZE;",
            "\tget_page(page);",
            "\tlen = n->info & WATCH_INFO_LENGTH;",
            "\tp = kmap_atomic(page);",
            "\tmemcpy(p + offset, n, len);",
            "\tkunmap_atomic(p);",
            "",
            "\tbuf = pipe_buf(pipe, head);",
            "\tbuf->page = page;",
            "\tbuf->private = (unsigned long)wqueue;",
            "\tbuf->ops = &watch_queue_pipe_buf_ops;",
            "\tbuf->offset = offset;",
            "\tbuf->len = len;",
            "\tbuf->flags = PIPE_BUF_FLAG_WHOLE;",
            "\tsmp_store_release(&pipe->head, head + 1); /* vs pipe_read() */",
            "",
            "\tif (!test_and_clear_bit(note, wqueue->notes_bitmap)) {",
            "\t\tspin_unlock_irq(&pipe->rd_wait.lock);",
            "\t\tBUG();",
            "\t}",
            "\twake_up_interruptible_sync_poll_locked(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);",
            "\tdone = true;",
            "",
            "out:",
            "\tspin_unlock_irq(&pipe->rd_wait.lock);",
            "\tif (done)",
            "\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);",
            "\treturn done;",
            "",
            "lost:",
            "\tbuf = pipe_buf(pipe, head - 1);",
            "\tbuf->flags |= PIPE_BUF_FLAG_LOSS;",
            "\tgoto out;",
            "}",
            "static bool filter_watch_notification(const struct watch_filter *wf,",
            "\t\t\t\t      const struct watch_notification *n)",
            "{",
            "\tconst struct watch_type_filter *wt;",
            "\tunsigned int st_bits = sizeof(wt->subtype_filter[0]) * 8;",
            "\tunsigned int st_index = n->subtype / st_bits;",
            "\tunsigned int st_bit = 1U << (n->subtype % st_bits);",
            "\tint i;",
            "",
            "\tif (!test_bit(n->type, wf->type_filter))",
            "\t\treturn false;",
            "",
            "\tfor (i = 0; i < wf->nr_filters; i++) {",
            "\t\twt = &wf->filters[i];",
            "\t\tif (n->type == wt->type &&",
            "\t\t    (wt->subtype_filter[st_index] & st_bit) &&",
            "\t\t    (n->info & wt->info_mask) == wt->info_filter)",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\treturn false; /* If there is a filter, the default is to reject. */",
            "}"
          ],
          "function_name": "lock_wqueue, unlock_wqueue, watch_queue_pipe_buf_release, post_one_notification, filter_watch_notification",
          "description": "实现了watch_queue的锁操作、缓冲区释放、通知提交及过滤逻辑。lock_wqueue/unlock_wqueue用于保护队列访问，watch_queue_pipe_buf_release处理缓冲区回收并更新位图，post_one_notification将通知数据写入管道，filter_watch_notification进行类型和子类型的匹配判断。",
          "similarity": 0.582815945148468
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/watch_queue.c",
          "start_line": 315,
          "end_line": 422,
          "content": [
            "long watch_queue_set_filter(struct pipe_inode_info *pipe,",
            "\t\t\t    struct watch_notification_filter __user *_filter)",
            "{",
            "\tstruct watch_notification_type_filter *tf;",
            "\tstruct watch_notification_filter filter;",
            "\tstruct watch_type_filter *q;",
            "\tstruct watch_filter *wfilter;",
            "\tstruct watch_queue *wqueue = pipe->watch_queue;",
            "\tint ret, nr_filter = 0, i;",
            "",
            "\tif (!wqueue)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (!_filter) {",
            "\t\t/* Remove the old filter */",
            "\t\twfilter = NULL;",
            "\t\tgoto set;",
            "\t}",
            "",
            "\t/* Grab the user's filter specification */",
            "\tif (copy_from_user(&filter, _filter, sizeof(filter)) != 0)",
            "\t\treturn -EFAULT;",
            "\tif (filter.nr_filters == 0 ||",
            "\t    filter.nr_filters > 16 ||",
            "\t    filter.__reserved != 0)",
            "\t\treturn -EINVAL;",
            "",
            "\ttf = memdup_array_user(_filter->filters, filter.nr_filters, sizeof(*tf));",
            "\tif (IS_ERR(tf))",
            "\t\treturn PTR_ERR(tf);",
            "",
            "\tret = -EINVAL;",
            "\tfor (i = 0; i < filter.nr_filters; i++) {",
            "\t\tif ((tf[i].info_filter & ~tf[i].info_mask) ||",
            "\t\t    tf[i].info_mask & WATCH_INFO_LENGTH)",
            "\t\t\tgoto err_filter;",
            "\t\t/* Ignore any unknown types */",
            "\t\tif (tf[i].type >= WATCH_TYPE__NR)",
            "\t\t\tcontinue;",
            "\t\tnr_filter++;",
            "\t}",
            "",
            "\t/* Now we need to build the internal filter from only the relevant",
            "\t * user-specified filters.",
            "\t */",
            "\tret = -ENOMEM;",
            "\twfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);",
            "\tif (!wfilter)",
            "\t\tgoto err_filter;",
            "\twfilter->nr_filters = nr_filter;",
            "",
            "\tq = wfilter->filters;",
            "\tfor (i = 0; i < filter.nr_filters; i++) {",
            "\t\tif (tf[i].type >= WATCH_TYPE__NR)",
            "\t\t\tcontinue;",
            "",
            "\t\tq->type\t\t\t= tf[i].type;",
            "\t\tq->info_filter\t\t= tf[i].info_filter;",
            "\t\tq->info_mask\t\t= tf[i].info_mask;",
            "\t\tq->subtype_filter[0]\t= tf[i].subtype_filter[0];",
            "\t\t__set_bit(q->type, wfilter->type_filter);",
            "\t\tq++;",
            "\t}",
            "",
            "\tkfree(tf);",
            "set:",
            "\tpipe_lock(pipe);",
            "\twfilter = rcu_replace_pointer(wqueue->filter, wfilter,",
            "\t\t\t\t      lockdep_is_held(&pipe->mutex));",
            "\tpipe_unlock(pipe);",
            "\tif (wfilter)",
            "\t\tkfree_rcu(wfilter, rcu);",
            "\treturn 0;",
            "",
            "err_filter:",
            "\tkfree(tf);",
            "\treturn ret;",
            "}",
            "static void __put_watch_queue(struct kref *kref)",
            "{",
            "\tstruct watch_queue *wqueue =",
            "\t\tcontainer_of(kref, struct watch_queue, usage);",
            "\tstruct watch_filter *wfilter;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < wqueue->nr_pages; i++)",
            "\t\t__free_page(wqueue->notes[i]);",
            "\tkfree(wqueue->notes);",
            "\tbitmap_free(wqueue->notes_bitmap);",
            "",
            "\twfilter = rcu_access_pointer(wqueue->filter);",
            "\tif (wfilter)",
            "\t\tkfree_rcu(wfilter, rcu);",
            "\tkfree_rcu(wqueue, rcu);",
            "}",
            "void put_watch_queue(struct watch_queue *wqueue)",
            "{",
            "\tkref_put(&wqueue->usage, __put_watch_queue);",
            "}",
            "static void free_watch(struct rcu_head *rcu)",
            "{",
            "\tstruct watch *watch = container_of(rcu, struct watch, rcu);",
            "",
            "\tput_watch_queue(rcu_access_pointer(watch->queue));",
            "\tatomic_dec(&watch->cred->user->nr_watches);",
            "\tput_cred(watch->cred);",
            "\tkfree(watch);",
            "}"
          ],
          "function_name": "watch_queue_set_filter, __put_watch_queue, put_watch_queue, free_watch",
          "description": "watch_queue_set_filter设置过滤规则并转换为内核内部结构，__put_watch_queue释放watch_queue相关资源包括页面、位图和过滤器，put_watch_queue通过引用计数管理watch_queue生命周期，free_watch执行RCU回调完成最终释放。",
          "similarity": 0.5046862959861755
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/watch_queue.c",
          "start_line": 602,
          "end_line": 680,
          "content": [
            "void watch_queue_clear(struct watch_queue *wqueue)",
            "{",
            "\tstruct watch_list *wlist;",
            "\tstruct watch *watch;",
            "\tbool release;",
            "",
            "\trcu_read_lock();",
            "\tspin_lock_bh(&wqueue->lock);",
            "",
            "\t/*",
            "\t * This pipe can be freed by callers like free_pipe_info().",
            "\t * Removing this reference also prevents new notifications.",
            "\t */",
            "\twqueue->pipe = NULL;",
            "",
            "\twhile (!hlist_empty(&wqueue->watches)) {",
            "\t\twatch = hlist_entry(wqueue->watches.first, struct watch, queue_node);",
            "\t\thlist_del_init_rcu(&watch->queue_node);",
            "\t\t/* We now own a ref on the watch. */",
            "\t\tspin_unlock_bh(&wqueue->lock);",
            "",
            "\t\t/* We can't do the next bit under the queue lock as we need to",
            "\t\t * get the list lock - which would cause a deadlock if someone",
            "\t\t * was removing from the opposite direction at the same time or",
            "\t\t * posting a notification.",
            "\t\t */",
            "\t\twlist = rcu_dereference(watch->watch_list);",
            "\t\tif (wlist) {",
            "\t\t\tvoid (*release_watch)(struct watch *);",
            "",
            "\t\t\tspin_lock(&wlist->lock);",
            "",
            "\t\t\trelease = !hlist_unhashed(&watch->list_node);",
            "\t\t\tif (release) {",
            "\t\t\t\thlist_del_init_rcu(&watch->list_node);",
            "\t\t\t\trcu_assign_pointer(watch->watch_list, NULL);",
            "",
            "\t\t\t\t/* We now own a second ref on the watch. */",
            "\t\t\t}",
            "",
            "\t\t\trelease_watch = wlist->release_watch;",
            "\t\t\tspin_unlock(&wlist->lock);",
            "",
            "\t\t\tif (release) {",
            "\t\t\t\tif (release_watch) {",
            "\t\t\t\t\trcu_read_unlock();",
            "\t\t\t\t\t/* This might need to call dput(), so",
            "\t\t\t\t\t * we have to drop all the locks.",
            "\t\t\t\t\t */",
            "\t\t\t\t\t(*release_watch)(watch);",
            "\t\t\t\t\trcu_read_lock();",
            "\t\t\t\t}",
            "\t\t\t\tput_watch(watch);",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tput_watch(watch);",
            "\t\tspin_lock_bh(&wqueue->lock);",
            "\t}",
            "",
            "\tspin_unlock_bh(&wqueue->lock);",
            "\trcu_read_unlock();",
            "}",
            "int watch_queue_init(struct pipe_inode_info *pipe)",
            "{",
            "\tstruct watch_queue *wqueue;",
            "",
            "\twqueue = kzalloc(sizeof(*wqueue), GFP_KERNEL);",
            "\tif (!wqueue)",
            "\t\treturn -ENOMEM;",
            "",
            "\twqueue->pipe = pipe;",
            "\tkref_init(&wqueue->usage);",
            "\tspin_lock_init(&wqueue->lock);",
            "\tINIT_HLIST_HEAD(&wqueue->watches);",
            "",
            "\tpipe->watch_queue = wqueue;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "watch_queue_clear, watch_queue_init",
          "description": "该代码实现了监视队列的初始化与清理功能。  \n`watch_queue_clear`通过RCU和自旋锁机制安全地移除所有监视项并释放资源，`watch_queue_init`初始化监视队列结构并绑定至管道对象。  \n上下文不完整：`release_watch`等关键函数依赖外部定义，部分RCU回调逻辑未完全展示。",
          "similarity": 0.47880828380584717
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/watch_queue.c",
          "start_line": 193,
          "end_line": 304,
          "content": [
            "void __post_watch_notification(struct watch_list *wlist,",
            "\t\t\t       struct watch_notification *n,",
            "\t\t\t       const struct cred *cred,",
            "\t\t\t       u64 id)",
            "{",
            "\tconst struct watch_filter *wf;",
            "\tstruct watch_queue *wqueue;",
            "\tstruct watch *watch;",
            "",
            "\tif (((n->info & WATCH_INFO_LENGTH) >> WATCH_INFO_LENGTH__SHIFT) == 0) {",
            "\t\tWARN_ON(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\trcu_read_lock();",
            "",
            "\thlist_for_each_entry_rcu(watch, &wlist->watchers, list_node) {",
            "\t\tif (watch->id != id)",
            "\t\t\tcontinue;",
            "\t\tn->info &= ~WATCH_INFO_ID;",
            "\t\tn->info |= watch->info_id;",
            "",
            "\t\twqueue = rcu_dereference(watch->queue);",
            "\t\twf = rcu_dereference(wqueue->filter);",
            "\t\tif (wf && !filter_watch_notification(wf, n))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (security_post_notification(watch->cred, cred, n) < 0)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (lock_wqueue(wqueue)) {",
            "\t\t\tpost_one_notification(wqueue, n);",
            "\t\t\tunlock_wqueue(wqueue);",
            "\t\t}",
            "\t}",
            "",
            "\trcu_read_unlock();",
            "}",
            "long watch_queue_set_size(struct pipe_inode_info *pipe, unsigned int nr_notes)",
            "{",
            "\tstruct watch_queue *wqueue = pipe->watch_queue;",
            "\tstruct page **pages;",
            "\tunsigned long *bitmap;",
            "\tunsigned long user_bufs;",
            "\tint ret, i, nr_pages;",
            "",
            "\tif (!wqueue)",
            "\t\treturn -ENODEV;",
            "\tif (wqueue->notes)",
            "\t\treturn -EBUSY;",
            "",
            "\tif (nr_notes < 1 ||",
            "\t    nr_notes > 512) /* TODO: choose a better hard limit */",
            "\t\treturn -EINVAL;",
            "",
            "\tnr_pages = (nr_notes + WATCH_QUEUE_NOTES_PER_PAGE - 1);",
            "\tnr_pages /= WATCH_QUEUE_NOTES_PER_PAGE;",
            "\tuser_bufs = account_pipe_buffers(pipe->user, pipe->nr_accounted, nr_pages);",
            "",
            "\tif (nr_pages > pipe->max_usage &&",
            "\t    (too_many_pipe_buffers_hard(user_bufs) ||",
            "\t     too_many_pipe_buffers_soft(user_bufs)) &&",
            "\t    pipe_is_unprivileged_user()) {",
            "\t\tret = -EPERM;",
            "\t\tgoto error;",
            "\t}",
            "",
            "\tnr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;",
            "\tret = pipe_resize_ring(pipe, roundup_pow_of_two(nr_notes));",
            "\tif (ret < 0)",
            "\t\tgoto error;",
            "",
            "\t/*",
            "\t * pipe_resize_ring() does not update nr_accounted for watch_queue",
            "\t * pipes, because the above vastly overprovisions. Set nr_accounted on",
            "\t * and max_usage this pipe to the number that was actually charged to",
            "\t * the user above via account_pipe_buffers.",
            "\t */",
            "\tpipe->max_usage = nr_pages;",
            "\tpipe->nr_accounted = nr_pages;",
            "",
            "\tret = -ENOMEM;",
            "\tpages = kcalloc(sizeof(struct page *), nr_pages, GFP_KERNEL);",
            "\tif (!pages)",
            "\t\tgoto error;",
            "",
            "\tfor (i = 0; i < nr_pages; i++) {",
            "\t\tpages[i] = alloc_page(GFP_KERNEL);",
            "\t\tif (!pages[i])",
            "\t\t\tgoto error_p;",
            "\t\tpages[i]->index = i * WATCH_QUEUE_NOTES_PER_PAGE;",
            "\t}",
            "",
            "\tbitmap = bitmap_alloc(nr_notes, GFP_KERNEL);",
            "\tif (!bitmap)",
            "\t\tgoto error_p;",
            "",
            "\tbitmap_fill(bitmap, nr_notes);",
            "\twqueue->notes = pages;",
            "\twqueue->notes_bitmap = bitmap;",
            "\twqueue->nr_pages = nr_pages;",
            "\twqueue->nr_notes = nr_notes;",
            "\treturn 0;",
            "",
            "error_p:",
            "\twhile (--i >= 0)",
            "\t\t__free_page(pages[i]);",
            "\tkfree(pages);",
            "error:",
            "\t(void) account_pipe_buffers(pipe->user, nr_pages, pipe->nr_accounted);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__post_watch_notification, watch_queue_set_size",
          "description": "__post_watch_notification遍历watch列表并应用过滤器后提交通知，watch_queue_set_size动态调整管道容量，通过计算所需页数和位图分配，限制最大容量为512个笔记，支持扩展性需求。",
          "similarity": 0.47021520137786865
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/watch_queue.c",
          "start_line": 1,
          "end_line": 41,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Watch queue and general notification mechanism, built on pipes",
            " *",
            " * Copyright (C) 2020 Red Hat, Inc. All Rights Reserved.",
            " * Written by David Howells (dhowells@redhat.com)",
            " *",
            " * See Documentation/core-api/watch_queue.rst",
            " */",
            "",
            "#define pr_fmt(fmt) \"watchq: \" fmt",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <linux/security.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/watch_queue.h>",
            "#include <linux/pipe_fs_i.h>",
            "",
            "MODULE_DESCRIPTION(\"Watch queue\");",
            "MODULE_AUTHOR(\"Red Hat, Inc.\");",
            "",
            "#define WATCH_QUEUE_NOTE_SIZE 128",
            "#define WATCH_QUEUE_NOTES_PER_PAGE (PAGE_SIZE / WATCH_QUEUE_NOTE_SIZE)",
            "",
            "/*",
            " * This must be called under the RCU read-lock, which makes",
            " * sure that the wqueue still exists. It can then take the lock,",
            " * and check that the wqueue hasn't been destroyed, which in",
            " * turn makes sure that the notification pipe still exists.",
            " */"
          ],
          "function_name": null,
          "description": "定义了watch_queue模块的头部信息，包含常量WATCH_QUEUE_NOTE_SIZE和NOTES_PER_PAGE，声明模块许可证及作者信息，并引入相关内核头文件，为后续实现提供基础框架。",
          "similarity": 0.4622325599193573
        }
      ]
    },
    {
      "source_file": "kernel/scs.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:22:19\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `scs.c`\n\n---\n\n# scs.c 技术文档\n\n## 文件概述\n\n`scs.c` 是 Linux 内核中实现 **Shadow Call Stack（SCS，影子调用栈）** 功能的核心文件。SCS 是一种安全机制，用于在支持的架构（如 ARM64）上防止函数返回地址被栈溢出等攻击篡改。该机制通过将函数返回地址存储在独立于常规内核栈的“影子栈”中，从而增强控制流完整性（CFI）。本文件负责 SCS 内存的分配、释放、初始化及资源管理。\n\n## 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `scs_alloc(int node)` | 为任务分配一个 SCS 区域，优先从每 CPU 缓存中获取，否则通过 `vmalloc` 分配 |\n| `scs_free(void *s)` | 释放 SCS 区域，尝试缓存到每 CPU 缓存，否则异步释放 |\n| `scs_init(void)` | 初始化 SCS 子系统，注册 CPU 热插拔清理回调 |\n| `scs_prepare(struct task_struct *tsk, int node)` | 为新任务准备 SCS，调用 `scs_alloc` 并设置任务结构体中的 SCS 指针 |\n| `scs_release(struct task_struct *tsk)` | 释放任务的 SCS，检查栈末尾魔数是否被破坏，并记录最大使用量（调试模式） |\n| `scs_check_usage(struct task_struct *tsk)` | （仅在 `CONFIG_DEBUG_STACK_USAGE` 启用时）统计并报告 SCS 使用峰值 |\n\n### 主要数据结构与宏\n\n- `NR_CACHED_SCS`：每 CPU 缓存的 SCS 数量，设为 2，与 `VMAP_STACK` 的 `NR_CACHED_STACKS` 一致\n- `scs_cache[NR_CACHED_SCS]`：每 CPU 的 SCS 缓存数组，用于快速重用已分配的 SCS\n- `dynamic_scs_enabled`：静态键（static key），用于动态启用/禁用 SCS（仅当 `CONFIG_DYNAMIC_SCS` 启用）\n- `SCS_SIZE`：单个 SCS 的大小（定义在头文件中）\n- `SCS_END_MAGIC`：写入 SCS 末尾的魔数，用于检测栈溢出破坏\n\n## 关键实现\n\n### 1. 内存分配策略\n- **缓存优先**：`__scs_alloc` 首先尝试从当前 CPU 的 `scs_cache` 中获取空闲 SCS，避免频繁调用 `vmalloc`。\n- **非阻塞释放**：`scs_free` 在中断上下文也可安全调用，使用 `this_cpu_cmpxchg` 原子更新缓存；若缓存满，则调用 `vfree_atomic` 异步释放。\n- **KASAN 集成**：分配时通过 `kasan_unpoison_vmalloc` 解毒，使用后通过 `kasan_poison_vmalloc` 毒化，防止非法访问。\n\n### 2. 资源统计\n- `__scs_account` 函数通过 `mod_node_page_state` 更新 `NR_KERNEL_SCS_KB` 统计项，跟踪每个 NUMA 节点上 SCS 内存使用量（以 KB 为单位）。\n\n### 3. 安全校验\n- **魔数保护**：每个 SCS 末尾写入 `SCS_END_MAGIC`，`scs_release` 时检查该值是否被覆盖，若损坏则触发 `WARN`。\n- **使用量监控**：在 `CONFIG_DEBUG_STACK_USAGE` 模式下，`scs_check_usage` 扫描 SCS 中非零区域，估算实际使用深度，并全局记录历史最大值。\n\n### 4. CPU 热插拔支持\n- 通过 `cpuhp_setup_state` 注册 `scs_cleanup` 回调，在 CPU offline 时释放该 CPU 缓存中的 SCS，防止内存泄漏。\n\n## 依赖关系\n\n- **内存管理**：依赖 `vmalloc` 子系统进行非连续内存分配（`__vmalloc_node_range`、`vfree_atomic`）。\n- **KASAN**：与内核地址消毒器（KASAN）深度集成，使用 `kasan_poison_vmalloc` / `kasan_unpoison_vmalloc` 管理虚拟内存毒化状态。\n- **Per-CPU 机制**：使用 `DEFINE_PER_CPU` 和 `this_cpu_xchg`/`this_cpu_cmpxchg` 实现每 CPU 缓存。\n- **CPU 热插拔**：依赖 `cpuhotplug.h` 提供的 CPU 状态管理接口。\n- **配置选项**：\n  - `CONFIG_SHADOW_CALL_STACK`：启用 SCS 功能\n  - `CONFIG_DYNAMIC_SCS`：支持运行时动态开关 SCS\n  - `CONFIG_DEBUG_STACK_USAGE`：启用 SCS 使用量调试统计\n\n## 使用场景\n\n- **任务创建/销毁**：在 `copy_process` 流程中调用 `scs_prepare` 为新内核线程或进程分配 SCS；在任务退出时通过 `scs_release` 释放。\n- **中断与软中断上下文**：由于 `scs_free` 使用 `vfree_atomic`，可在中断上下文安全释放 SCS。\n- **安全加固系统**：在启用 SCS 的 ARM64 系统中，编译器（如 Clang）会将函数返回地址写入 SCS 而非常规栈，内核需为此提供运行时支持。\n- **内存调试**：配合 KASAN 和 `CONFIG_DEBUG_STACK_USAGE`，帮助开发者检测 SCS 溢出和内存使用异常。",
      "similarity": 0.6030246019363403,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/scs.c",
          "start_line": 19,
          "end_line": 116,
          "content": [
            "static void __scs_account(void *s, int account)",
            "{",
            "\tstruct page *scs_page = vmalloc_to_page(s);",
            "",
            "\tmod_node_page_state(page_pgdat(scs_page), NR_KERNEL_SCS_KB,",
            "\t\t\t    account * (SCS_SIZE / SZ_1K));",
            "}",
            "void scs_free(void *s)",
            "{",
            "\tint i;",
            "",
            "\t__scs_account(s, -1);",
            "",
            "\t/*",
            "\t * We cannot sleep as this can be called in interrupt context,",
            "\t * so use this_cpu_cmpxchg to update the cache, and vfree_atomic",
            "\t * to free the stack.",
            "\t */",
            "",
            "\tfor (i = 0; i < NR_CACHED_SCS; i++)",
            "\t\tif (this_cpu_cmpxchg(scs_cache[i], 0, s) == NULL)",
            "\t\t\treturn;",
            "",
            "\tkasan_unpoison_vmalloc(s, SCS_SIZE, KASAN_VMALLOC_PROT_NORMAL);",
            "\tvfree_atomic(s);",
            "}",
            "static int scs_cleanup(unsigned int cpu)",
            "{",
            "\tint i;",
            "\tvoid **cache = per_cpu_ptr(scs_cache, cpu);",
            "",
            "\tfor (i = 0; i < NR_CACHED_SCS; i++) {",
            "\t\tvfree(cache[i]);",
            "\t\tcache[i] = NULL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void __init scs_init(void)",
            "{",
            "\tif (!scs_is_enabled())",
            "\t\treturn;",
            "\tcpuhp_setup_state(CPUHP_BP_PREPARE_DYN, \"scs:scs_cache\", NULL,",
            "\t\t\t  scs_cleanup);",
            "}",
            "int scs_prepare(struct task_struct *tsk, int node)",
            "{",
            "\tvoid *s;",
            "",
            "\tif (!scs_is_enabled())",
            "\t\treturn 0;",
            "",
            "\ts = scs_alloc(node);",
            "\tif (!s)",
            "\t\treturn -ENOMEM;",
            "",
            "\ttask_scs(tsk) = task_scs_sp(tsk) = s;",
            "\treturn 0;",
            "}",
            "static void scs_check_usage(struct task_struct *tsk)",
            "{",
            "\tstatic unsigned long highest;",
            "",
            "\tunsigned long *p, prev, curr = highest, used = 0;",
            "",
            "\tif (!IS_ENABLED(CONFIG_DEBUG_STACK_USAGE))",
            "\t\treturn;",
            "",
            "\tfor (p = task_scs(tsk); p < __scs_magic(tsk); ++p) {",
            "\t\tif (!READ_ONCE_NOCHECK(*p))",
            "\t\t\tbreak;",
            "\t\tused += sizeof(*p);",
            "\t}",
            "",
            "\twhile (used > curr) {",
            "\t\tprev = cmpxchg_relaxed(&highest, curr, used);",
            "",
            "\t\tif (prev == curr) {",
            "\t\t\tpr_info(\"%s (%d): highest shadow stack usage: %lu bytes\\n\",",
            "\t\t\t\ttsk->comm, task_pid_nr(tsk), used);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tcurr = prev;",
            "\t}",
            "}",
            "void scs_release(struct task_struct *tsk)",
            "{",
            "\tvoid *s = task_scs(tsk);",
            "",
            "\tif (!scs_is_enabled() || !s)",
            "\t\treturn;",
            "",
            "\tWARN(task_scs_end_corrupted(tsk),",
            "\t     \"corrupted shadow stack detected when freeing task\\n\");",
            "\tscs_check_usage(tsk);",
            "\tscs_free(s);",
            "}"
          ],
          "function_name": "__scs_account, scs_free, scs_cleanup, scs_init, scs_prepare, scs_check_usage, scs_release",
          "description": "实现SCS内存管理逻辑，包含分配/释放影子调用栈、缓存维护、CPU热插拔清理及任务栈使用量监控功能",
          "similarity": 0.6180446147918701
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/scs.c",
          "start_line": 1,
          "end_line": 18,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Shadow Call Stack support.",
            " *",
            " * Copyright (C) 2019 Google LLC",
            " */",
            "",
            "#include <linux/cpuhotplug.h>",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/scs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vmstat.h>",
            "",
            "#ifdef CONFIG_DYNAMIC_SCS",
            "DEFINE_STATIC_KEY_FALSE(dynamic_scs_enabled);",
            "#endif",
            ""
          ],
          "function_name": null,
          "description": "定义动态SCS功能的静态键，用于控制是否启用运行时扩展的影子调用栈机制",
          "similarity": 0.4753286838531494
        }
      ]
    }
  ]
}