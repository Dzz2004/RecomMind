{
  "query": "内核态切换用户态的上下文保存",
  "timestamp": "2025-12-26 00:00:40",
  "retrieved_files": [
    {
      "source_file": "kernel/user-return-notifier.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:45:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user-return-notifier.c`\n\n---\n\n# user-return-notifier.c 技术文档\n\n## 1. 文件概述\n\n`user-return-notifier.c` 实现了用户态返回通知机制（User Return Notifier），允许内核子系统在当前 CPU 即将从内核态返回用户态时注册回调函数。该机制用于在特定内核事件（如安全策略更新、性能监控等）发生后，延迟执行某些操作，直到进程真正返回用户空间，从而避免在关键内核路径中引入额外开销或竞态条件。\n\n## 2. 核心功能\n\n### 数据结构\n- `return_notifier_list`：每 CPU 变量（per-CPU variable），类型为 `struct hlist_head`，用于存储当前 CPU 上注册的所有用户返回通知器链表。\n\n### 主要函数\n- `user_return_notifier_register(struct user_return_notifier *urn)`  \n  注册一个用户返回通知器，将其加入当前 CPU 的通知链表，并设置当前任务的 `TIF_USER_RETURN_NOTIFY` 标志位。\n\n- `user_return_notifier_unregister(struct user_return_notifier *urn)`  \n  从当前 CPU 的通知链表中移除指定的通知器；若链表变为空，则清除当前任务的 `TIF_USER_RETURN_NOTIFY` 标志位。\n\n- `fire_user_return_notifiers(void)`  \n  遍历并调用当前 CPU 上所有已注册的通知器的回调函数 `on_user_return`，通常在内核即将返回用户态前由调度或系统调用退出路径调用。\n\n## 3. 关键实现\n\n- **每 CPU 链表设计**：使用 `DEFINE_PER_CPU` 定义 per-CPU 的哈希链表头，确保每个 CPU 维护独立的通知器列表，避免跨 CPU 同步开销。\n  \n- **原子上下文要求**：注册和注销操作必须在原子上下文中执行（不可睡眠），因为它们操作 per-CPU 数据且可能在中断或调度关键路径中被调用。\n\n- **线程标志位控制**：通过设置/清除任务结构体中的 `TIF_USER_RETURN_NOTIFY` 标志位（`TIF_` 表示 Thread Info Flag），通知内核在返回用户态前需调用 `fire_user_return_notifiers()`。\n\n- **安全遍历与调用**：`fire_user_return_notifiers()` 使用 `hlist_for_each_entry_safe` 安全遍历链表，允许回调函数在执行过程中注销自身或其他通知器。\n\n- **CPU 变量访问**：使用 `get_cpu_var()` 和 `put_cpu_var()` 保证在访问 per-CPU 变量期间禁止内核抢占，确保操作的 CPU 一致性。\n\n## 4. 依赖关系\n\n- `<linux/user-return-notifier.h>`：定义 `struct user_return_notifier` 及相关 API。\n- `<linux/percpu.h>`：提供 per-CPU 变量支持。\n- `<linux/sched.h>`：提供任务结构体（`current`）和线程标志位操作函数（如 `set_tsk_thread_flag`）。\n- `<linux/export.h>`：导出符号供其他内核模块使用（`EXPORT_SYMBOL_GPL`）。\n- 依赖架构相关的线程信息标志（`TIF_USER_RETURN_NOTIFY`）在 `thread_info` 中的定义。\n\n## 5. 使用场景\n\n- **安全模块**：如 SELinux 或 LSM 框架在策略更新后，需通知用户态进程重新评估权限，可延迟到返回用户态时触发。\n- **性能监控与跟踪**：在系统调用或中断处理完成后，于返回用户态前收集上下文切换或延迟信息。\n- **延迟工作调度**：某些不适合在中断或原子上下文中执行的操作，可注册为用户返回通知，在安全的用户态切换点执行。\n- **虚拟化与容器**：在客户机或容器退出内核时同步状态或注入事件。\n\n该机制是内核“延迟通知”模式的典型实现，确保高优先级内核路径不受回调逻辑影响，同时保证通知在正确的执行上下文中触发。",
      "similarity": 0.6279467344284058,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/user-return-notifier.c",
          "start_line": 15,
          "end_line": 36,
          "content": [
            "void user_return_notifier_register(struct user_return_notifier *urn)",
            "{",
            "\tset_tsk_thread_flag(current, TIF_USER_RETURN_NOTIFY);",
            "\thlist_add_head(&urn->link, this_cpu_ptr(&return_notifier_list));",
            "}",
            "void user_return_notifier_unregister(struct user_return_notifier *urn)",
            "{",
            "\thlist_del(&urn->link);",
            "\tif (hlist_empty(this_cpu_ptr(&return_notifier_list)))",
            "\t\tclear_tsk_thread_flag(current, TIF_USER_RETURN_NOTIFY);",
            "}",
            "void fire_user_return_notifiers(void)",
            "{",
            "\tstruct user_return_notifier *urn;",
            "\tstruct hlist_node *tmp2;",
            "\tstruct hlist_head *head;",
            "",
            "\thead = &get_cpu_var(return_notifier_list);",
            "\thlist_for_each_entry_safe(urn, tmp2, head, link)",
            "\t\turn->on_user_return(urn);",
            "\tput_cpu_var(return_notifier_list);",
            "}"
          ],
          "function_name": "user_return_notifier_register, user_return_notifier_unregister, fire_user_return_notifiers",
          "description": "实现用户态返回通知器的注册/注销与触发机制。register 函数将通知器链接到当前 CPU 的链表并设置 TIF_USER_RETURN_NOTIFY 标志；unregister 函数移除节点并清理标志；fire 函数遍历当前 CPU 链表执行所有注册的 on_user_return 回调函数。",
          "similarity": 0.5625731348991394
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/user-return-notifier.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "",
            "static DEFINE_PER_CPU(struct hlist_head, return_notifier_list);",
            "",
            "/*",
            " * Request a notification when the current cpu returns to userspace.  Must be",
            " * called in atomic context.  The notifier will also be called in atomic",
            " * context.",
            " */"
          ],
          "function_name": null,
          "description": "定义了一个 per-CPU 的哈希列表头结构 return_notifier_list，用于存储用户态返回通知器注册项。该结构通过 DEFINE_PER_CPU 宏为每个 CPU 创建独立的链表头，支持多 CPU 环境下的并发访问。",
          "similarity": 0.4893076419830322
        }
      ]
    },
    {
      "source_file": "kernel/usermode_driver.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:47:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `usermode_driver.c`\n\n---\n\n# usermode_driver.c 技术文档\n\n## 文件概述\n\n`usermode_driver.c` 实现了 Linux 内核中用户态驱动（User Mode Driver, UMD）的支持机制。该文件提供了一套 API，允许内核模块将一段可执行的二进制数据（blob）加载为临时文件系统中的可执行文件，并以此为基础 fork 出一个用户态进程作为驱动程序运行。该机制常用于需要在用户空间执行复杂逻辑但又需与内核紧密协作的驱动场景（如某些固件加载器、安全模块或虚拟设备驱动）。\n\n## 核心功能\n\n### 主要函数\n\n- `blob_to_mnt(const void *data, size_t len, const char *name)`  \n  将二进制数据写入 tmpfs 文件系统中，返回挂载点（vfsmount）。\n\n- `umd_load_blob(struct umd_info *info, const void *data, size_t len)`  \n  将给定的二进制 blob 加载为可执行文件，并关联到 `umd_info` 结构中。\n\n- `umd_unload_blob(struct umd_info *info)`  \n  卸载之前加载的 blob，释放相关文件系统资源。\n\n- `fork_usermode_driver(struct umd_info *info)`  \n  基于已加载的 blob fork 并执行一个用户态驱动进程。\n\n- `umd_setup(struct subprocess_info *info, struct cred *new)`  \n  在子进程中设置执行环境，包括创建通信管道、设置工作目录等。\n\n- `umd_cleanup(struct subprocess_info *info)`  \n  子进程执行失败时的清理回调。\n\n- `umd_cleanup_helper(struct umd_info *info)`  \n  释放 `umd_setup` 中分配的资源（管道、PID 等）。\n\n### 关键数据结构\n\n- `struct umd_info`  \n  描述用户态驱动的上下文信息，包含：\n  - `wd`：工作目录（`struct path`），指向 tmpfs 中的可执行文件所在目录\n  - `driver_name`：驱动程序在 tmpfs 中的文件名\n  - `pipe_to_umh` / `pipe_from_umh`：与用户态进程通信的双向管道\n  - `tgid`：用户态驱动进程的线程组 ID（用于后续管理）\n\n## 关键实现\n\n### Blob 到可执行文件的转换\n\n`blob_to_mnt()` 函数通过以下步骤将内存中的二进制数据转换为可执行文件：\n\n1. 挂载 `tmpfs` 文件系统（使用 `kern_mount()`）\n2. 在挂载点根目录下以指定名称创建文件（权限 `0700`）\n3. 使用 `kernel_write()` 将数据写入文件\n4. 调用 `flush_delayed_fput()` 和 `task_work_run()` 确保文件描述符延迟释放完成，以便后续 `exec` 能以只读方式打开该文件\n\n此机制避免了将驱动二进制写入磁盘，提高了安全性和灵活性。\n\n### 用户态驱动进程的启动\n\n`fork_usermode_driver()` 利用内核的 `call_usermodehelper` 机制：\n\n- 使用 `call_usermodehelper_setup()` 注册 `umd_setup` 作为子进程初始化回调\n- 在 `umd_setup` 中：\n  - 创建两个匿名管道：一个用于内核向用户态发送数据（stdin 重定向），一个用于用户态向内核返回数据（stdout 重定向）\n  - 使用 `replace_fd()` 将标准输入/输出重定向到管道端点\n  - 设置当前进程的 pwd（工作目录）为 tmpfs 挂载点，使 `exec` 能直接以相对路径执行驱动文件\n  - 保存管道文件指针和子进程 TGID 到 `umd_info`\n- 执行 `call_usermodehelper_exec()` 启动进程\n\n### 资源管理与错误处理\n\n- `umd_load_blob()` 和 `umd_unload_blob()` 通过 `WARN_ON_ONCE` 确保状态一致性（避免重复加载/卸载）\n- 若 `exec` 失败，`umd_cleanup` 回调会调用 `umd_cleanup_helper` 释放管道和 PID\n- 所有资源（vfsmount、file、pipe、pid）均通过内核标准接口分配和释放，确保无泄漏\n\n## 依赖关系\n\n- **文件系统**：依赖 `tmpfs`（通过 `get_fs_type(\"tmpfs\")`），用于临时存储可执行 blob\n- **进程管理**：依赖 `call_usermodehelper` 子系统（`linux/kmod.h` 隐式包含），用于 fork/exec 用户态进程\n- **VFS 层**：使用 `kern_mount`/`kern_unmount`、`file_open_root_mnt`、`kernel_write` 等 VFS 接口\n- **IPC 机制**：依赖管道（`create_pipe_files`）实现内核与用户态驱动的双向通信\n- **内存管理**：依赖 `shmem_fs.h`（tmpfs 底层基于共享内存）\n- **任务工作队列**：调用 `task_work_run()` 确保文件描述符及时释放\n\n## 使用场景\n\n1. **动态用户态驱动加载**  \n   内核模块可将嵌入的 ELF 二进制或脚本作为 blob 加载，无需预先安装到文件系统。\n\n2. **安全隔离驱动**  \n   将可能含漏洞的驱动逻辑移至用户空间运行，通过管道与内核通信，降低内核攻击面。\n\n3. **固件或微码加载器**  \n   某些设备需要复杂的固件初始化逻辑，可通过 UMD 在用户态执行，避免内核复杂性。\n\n4. **虚拟设备后端**  \n   如 virtio-user、vhost-user 等场景，内核前端通过 UMD 与用户态后端进程协作。\n\n5. **测试与原型开发**  \n   快速验证驱动逻辑，无需频繁编译内核模块，提高开发效率。\n\n> **注意**：调用者需负责用户态进程的生命周期管理（健康检查、信号终止、管道关闭等）。",
      "similarity": 0.6124743223190308,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 60,
          "end_line": 161,
          "content": [
            "int umd_load_blob(struct umd_info *info, const void *data, size_t len)",
            "{",
            "\tstruct vfsmount *mnt;",
            "",
            "\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))",
            "\t\treturn -EBUSY;",
            "",
            "\tmnt = blob_to_mnt(data, len, info->driver_name);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn PTR_ERR(mnt);",
            "",
            "\tinfo->wd.mnt = mnt;",
            "\tinfo->wd.dentry = mnt->mnt_root;",
            "\treturn 0;",
            "}",
            "int umd_unload_blob(struct umd_info *info)",
            "{",
            "\tif (WARN_ON_ONCE(!info->wd.mnt ||",
            "\t\t\t !info->wd.dentry ||",
            "\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))",
            "\t\treturn -EINVAL;",
            "",
            "\tkern_unmount(info->wd.mnt);",
            "\tinfo->wd.mnt = NULL;",
            "\tinfo->wd.dentry = NULL;",
            "\treturn 0;",
            "}",
            "static int umd_setup(struct subprocess_info *info, struct cred *new)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "\tstruct file *from_umh[2];",
            "\tstruct file *to_umh[2];",
            "\tint err;",
            "",
            "\t/* create pipe to send data to umh */",
            "\terr = create_pipe_files(to_umh, 0);",
            "\tif (err)",
            "\t\treturn err;",
            "\terr = replace_fd(0, to_umh[0], 0);",
            "\tfput(to_umh[0]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\t/* create pipe to receive data from umh */",
            "\terr = create_pipe_files(from_umh, 0);",
            "\tif (err) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\treturn err;",
            "\t}",
            "\terr = replace_fd(1, from_umh[1], 0);",
            "\tfput(from_umh[1]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\tfput(from_umh[0]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tset_fs_pwd(current->fs, &umd_info->wd);",
            "\tumd_info->pipe_to_umh = to_umh[1];",
            "\tumd_info->pipe_from_umh = from_umh[0];",
            "\tumd_info->tgid = get_pid(task_tgid(current));",
            "\treturn 0;",
            "}",
            "static void umd_cleanup(struct subprocess_info *info)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "",
            "\t/* cleanup if umh_setup() was successful but exec failed */",
            "\tif (info->retval)",
            "\t\tumd_cleanup_helper(umd_info);",
            "}",
            "void umd_cleanup_helper(struct umd_info *info)",
            "{",
            "\tfput(info->pipe_to_umh);",
            "\tfput(info->pipe_from_umh);",
            "\tput_pid(info->tgid);",
            "\tinfo->tgid = NULL;",
            "}",
            "int fork_usermode_driver(struct umd_info *info)",
            "{",
            "\tstruct subprocess_info *sub_info;",
            "\tconst char *argv[] = { info->driver_name, NULL };",
            "\tint err;",
            "",
            "\tif (WARN_ON_ONCE(info->tgid))",
            "\t\treturn -EBUSY;",
            "",
            "\terr = -ENOMEM;",
            "\tsub_info = call_usermodehelper_setup(info->driver_name,",
            "\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,",
            "\t\t\t\t\t     umd_setup, umd_cleanup, info);",
            "\tif (!sub_info)",
            "\t\tgoto out;",
            "",
            "\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);",
            "out:",
            "\treturn err;",
            "}"
          ],
          "function_name": "umd_load_blob, umd_unload_blob, umd_setup, umd_cleanup, umd_cleanup_helper, fork_usermode_driver",
          "description": "提供用户模式驱动程序的数据加载/卸载及子进程管理功能，包括挂载tmpfs、建立进程间管道通信、设置工作目录及清理资源，最终通过call_usermodehelper启动用户态驱动程序",
          "similarity": 0.5536816716194153
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * umd - User mode driver support",
            " */",
            "#include <linux/shmem_fs.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/usermode_driver.h>",
            "",
            "static struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)",
            "{",
            "\tstruct file_system_type *type;",
            "\tstruct vfsmount *mnt;",
            "\tstruct file *file;",
            "\tssize_t written;",
            "\tloff_t pos = 0;",
            "",
            "\ttype = get_fs_type(\"tmpfs\");",
            "\tif (!type)",
            "\t\treturn ERR_PTR(-ENODEV);",
            "",
            "\tmnt = kern_mount(type);",
            "\tput_filesystem(type);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn mnt;",
            "",
            "\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);",
            "\tif (IS_ERR(file)) {",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_CAST(file);",
            "\t}",
            "",
            "\twritten = kernel_write(file, data, len, &pos);",
            "\tif (written != len) {",
            "\t\tint err = written;",
            "\t\tif (err >= 0)",
            "\t\t\terr = -ENOMEM;",
            "\t\tfilp_close(file, NULL);",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_PTR(err);",
            "\t}",
            "",
            "\tfput(file);",
            "",
            "\t/* Flush delayed fput so exec can open the file read-only */",
            "\tflush_delayed_fput();",
            "\ttask_work_run();",
            "\treturn mnt;",
            "}",
            "",
            "/**",
            " * umd_load_blob - Remember a blob of bytes for fork_usermode_driver",
            " * @info: information about usermode driver",
            " * @data: a blob of bytes that can be executed as a file",
            " * @len:  The lentgh of the blob",
            " *",
            " */"
          ],
          "function_name": null,
          "description": "创建并挂载tmpfs文件系统以存储二进制数据，通过文件操作将输入数据写入新挂载点的指定名称文件，返回对应的vfsmount结构指针",
          "similarity": 0.4616352915763855
        }
      ]
    },
    {
      "source_file": "kernel/power/user.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:28:21\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `power\\user.c`\n\n---\n\n# power/user.c 技术文档\n\n## 1. 文件概述\n\n`power/user.c` 是 Linux 内核中实现用户空间与休眠（Hibernate）/恢复（Resume）功能交互的核心接口文件。该文件通过字符设备 `/dev/snapshot` 向用户空间提供对系统内存快照的读写能力，支持创建休眠镜像（保存系统状态）和从镜像恢复系统状态。它实现了软件休眠机制的用户态控制路径，是 hibernation 子系统的关键组成部分。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`struct snapshot_data`**：保存当前快照操作的上下文状态，包括：\n  - `handle`：快照操作句柄（`struct snapshot_handle`）\n  - `swap`：使用的交换分区类型索引\n  - `mode`：打开模式（`O_RDONLY` 表示休眠，`O_WRONLY` 表示恢复）\n  - `frozen`：是否已冻结用户进程\n  - `ready`：快照是否准备就绪\n  - `platform_support`：是否启用平台特定的休眠支持（如 ACPI S4）\n  - `free_bitmaps`：是否需要释放内存位图\n  - `dev`：恢复所用的设备号\n\n- **`static bool need_wait`**：标志是否需要等待设备探测完成（用于恢复流程）\n\n### 主要函数\n- **`snapshot_open()`**：设备打开函数，初始化快照上下文，根据打开模式（读/写）执行休眠或恢复的前期准备。\n- **`snapshot_release()`**：设备关闭函数，清理资源，释放内存位图，解冻进程，发送 PM 通知。\n- **`snapshot_read()`**：从内存快照中读取数据到用户空间（用于休眠时保存镜像）。\n- **`snapshot_write()`**：从用户空间写入数据到内存快照（用于恢复时加载镜像）。\n- **`snapshot_ioctl()`**：设备控制接口，支持多种休眠/恢复控制命令。\n- **`snapshot_set_swap_area()`**：设置恢复时使用的交换区域（兼容 32/64 位系统调用）。\n- **`is_hibernate_resume_dev()`**：判断指定设备是否为当前休眠恢复设备。\n\n### 关键 ioctl 命令\n- `SNAPSHOT_FREEZE`：冻结用户空间进程。\n- `SNAPSHOT_UNFREEZE`：解冻用户空间进程。\n- `SNAPSHOT_CREATE_IMAGE`：创建内存快照镜像（休眠）。\n- `SNAPSHOT_ATOMIC_RESTORE`：原子性地从镜像恢复系统。\n- `SNAPSHOT_FREE`：释放快照相关内存。\n- `SNAPSHOT_PREF_IMAGE_SIZE` / `SNAPSHOT_GET_IMAGE_SIZE`：设置/获取镜像大小。\n- `SNAPSHOT_AVAIL_SWAP_SIZE` / `SNAPSHOT_ALLOC_SWAP_PAGE`：管理交换空间分配。\n\n## 3. 关键实现\n\n### 休眠（Suspend-to-Disk）流程\n1. 用户空间以 `O_RDONLY` 打开 `/dev/snapshot`。\n2. 调用 `SNAPSHOT_FREEZE` 冻结所有用户进程。\n3. 调用 `SNAPSHOT_CREATE_IMAGE` 创建内存快照，内核将可恢复的内存页信息组织成镜像。\n4. 用户空间通过 `read()` 系统调用从设备读取镜像数据，并写入交换分区。\n5. 系统关机。\n\n### 恢复（Resume）流程\n1. 启动时内核检测到休眠镜像，但用户空间需主动参与恢复。\n2. 用户空间以 `O_WRONLY` 打开 `/dev/snapshot`。\n3. 通过 `ioctl(SNAPSHOT_SET_SWAP_AREA)` 指定镜像所在的交换设备。\n4. 用户空间从交换分区读取镜像数据，通过 `write()` 写入 `/dev/snapshot`。\n5. 调用 `SNAPSHOT_FREEZE` 冻结当前进程（为恢复做准备）。\n6. 调用 `SNAPSHOT_ATOMIC_RESTORE` 触发内核原子恢复，跳转回休眠时的执行上下文。\n\n### 内存管理\n- 使用 `create_basic_memory_bitmaps()` / `free_basic_memory_bitmaps()` 管理内存页的位图，标记哪些页需要保存/恢复。\n- 通过 `swsusp_free()` 释放休眠专用的内存缓冲区。\n- `alloc_swapdev_block()` 用于在休眠过程中分配交换页。\n\n### 同步与锁机制\n- 使用 `lock_system_sleep()` / `unlock_system_sleep()` 确保休眠操作的原子性。\n- 通过 `mutex_trylock(&system_transition_mutex)` 防止并发的系统状态转换。\n- `lock_device_hotplug()` 防止设备热插拔干扰休眠过程。\n\n### 兼容性处理\n- 通过 `in_compat_syscall()` 区分 32 位和 64 位系统调用，使用 `compat_resume_swap_area` 结构保证 ABI 兼容。\n\n## 4. 依赖关系\n\n- **`<linux/suspend.h>` / `power.h`**：休眠核心逻辑和数据结构定义。\n- **`<linux/swap.h>` / `<linux/swapops.h>`**：交换子系统接口，用于管理休眠镜像的存储。\n- **`<linux/freezer.h>`**：进程冻结/解冻机制。\n- **`<linux/pm.h>`**：电源管理通知链（`pm_notifier_call_chain`）。\n- **`<linux/miscdevice.h>`**：注册 `/dev/snapshot` 字符设备。\n- **`<linux/uaccess.h>`**：用户空间内存访问（`copy_from_user` 等）。\n- **`<linux/compat.h>`**：32/64 位系统调用兼容层。\n- **`hibernate.c`**：依赖 `hibernate_acquire()` / `hibernate_release()` 管理休眠资源。\n\n## 5. 使用场景\n\n- **系统休眠（Hibernation）**：当用户执行 `systemctl hibernate` 或类似命令时，用户空间工具（如 `uswsusp` 或 `systemd-hibernate`) 通过此接口保存系统状态到交换分区。\n- **系统恢复（Resume）**：在内核启动早期，initramfs 中的恢复工具（如 `resume` 脚本）通过此接口从交换分区加载镜像并触发恢复。\n- **调试与测试**：开发人员可通过直接操作 `/dev/snapshot` 设备测试休眠/恢复逻辑。\n- **定制休眠方案**：嵌入式或特殊用途系统可基于此接口实现自定义的休眠存储后端（如存储到文件而非交换分区）。",
      "similarity": 0.611685574054718,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/power/user.c",
          "start_line": 424,
          "end_line": 444,
          "content": [
            "static long",
            "snapshot_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)",
            "{",
            "\tBUILD_BUG_ON(sizeof(loff_t) != sizeof(compat_loff_t));",
            "",
            "\tswitch (cmd) {",
            "\tcase SNAPSHOT_GET_IMAGE_SIZE:",
            "\tcase SNAPSHOT_AVAIL_SWAP_SIZE:",
            "\tcase SNAPSHOT_ALLOC_SWAP_PAGE:",
            "\tcase SNAPSHOT_CREATE_IMAGE:",
            "\tcase SNAPSHOT_SET_SWAP_AREA:",
            "\t\treturn snapshot_ioctl(file, cmd,",
            "\t\t\t\t      (unsigned long) compat_ptr(arg));",
            "\tdefault:",
            "\t\treturn snapshot_ioctl(file, cmd, arg);",
            "\t}",
            "}",
            "static int __init snapshot_device_init(void)",
            "{",
            "\treturn misc_register(&snapshot_device);",
            "};"
          ],
          "function_name": "snapshot_compat_ioctl, snapshot_device_init",
          "description": "提供32位兼容性的ioctl处理函数和设备初始化函数，注册快照字符设备驱动以实现用户空间与内核电源管理子系统的交互。",
          "similarity": 0.5396702885627747
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/power/user.c",
          "start_line": 1,
          "end_line": 41,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * linux/kernel/power/user.c",
            " *",
            " * This file provides the user space interface for software suspend/resume.",
            " *",
            " * Copyright (C) 2006 Rafael J. Wysocki <rjw@sisk.pl>",
            " */",
            "",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/swap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pm.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/console.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "#include \"power.h\"",
            "",
            "static bool need_wait;",
            "",
            "static struct snapshot_data {",
            "\tstruct snapshot_handle handle;",
            "\tint swap;",
            "\tint mode;",
            "\tbool frozen;",
            "\tbool ready;",
            "\tbool platform_support;",
            "\tbool free_bitmaps;",
            "\tdev_t dev;",
            "} snapshot_state;",
            ""
          ],
          "function_name": null,
          "description": "定义了支持软件挂起/恢复的用户空间接口所需的全局变量和辅助结构体，包括用于跟踪快照状态的snapshot_state结构体及need_wait标志位。",
          "similarity": 0.5185016393661499
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/power/user.c",
          "start_line": 168,
          "end_line": 414,
          "content": [
            "static ssize_t snapshot_write(struct file *filp, const char __user *buf,",
            "                              size_t count, loff_t *offp)",
            "{",
            "\tloff_t pg_offp = *offp & ~PAGE_MASK;",
            "\tstruct snapshot_data *data;",
            "\tunsigned long sleep_flags;",
            "\tssize_t res;",
            "",
            "\tif (need_wait) {",
            "\t\twait_for_device_probe();",
            "\t\tneed_wait = false;",
            "\t}",
            "",
            "\tsleep_flags = lock_system_sleep();",
            "",
            "\tdata = filp->private_data;",
            "",
            "\tif (!pg_offp) {",
            "\t\tres = snapshot_write_next(&data->handle);",
            "\t\tif (res <= 0)",
            "\t\t\tgoto unlock;",
            "\t} else {",
            "\t\tres = PAGE_SIZE;",
            "\t}",
            "",
            "\tif (!data_of(data->handle)) {",
            "\t\tres = -EINVAL;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\tres = simple_write_to_buffer(data_of(data->handle), res, &pg_offp,",
            "\t\t\tbuf, count);",
            "\tif (res > 0)",
            "\t\t*offp += res;",
            "unlock:",
            "\tunlock_system_sleep(sleep_flags);",
            "",
            "\treturn res;",
            "}",
            "static int snapshot_set_swap_area(struct snapshot_data *data,",
            "\t\tvoid __user *argp)",
            "{",
            "\tsector_t offset;",
            "\tdev_t swdev;",
            "",
            "\tif (swsusp_swap_in_use())",
            "\t\treturn -EPERM;",
            "",
            "\tif (in_compat_syscall()) {",
            "\t\tstruct compat_resume_swap_area swap_area;",
            "",
            "\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))",
            "\t\t\treturn -EFAULT;",
            "\t\tswdev = new_decode_dev(swap_area.dev);",
            "\t\toffset = swap_area.offset;",
            "\t} else {",
            "\t\tstruct resume_swap_area swap_area;",
            "",
            "\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))",
            "\t\t\treturn -EFAULT;",
            "\t\tswdev = new_decode_dev(swap_area.dev);",
            "\t\toffset = swap_area.offset;",
            "\t}",
            "",
            "\t/*",
            "\t * User space encodes device types as two-byte values,",
            "\t * so we need to recode them",
            "\t */",
            "\tdata->swap = swap_type_of(swdev, offset);",
            "\tif (data->swap < 0)",
            "\t\treturn swdev ? -ENODEV : -EINVAL;",
            "\tdata->dev = swdev;",
            "\treturn 0;",
            "}",
            "static long snapshot_ioctl(struct file *filp, unsigned int cmd,",
            "\t\t\t\t\t\t\tunsigned long arg)",
            "{",
            "\tint error = 0;",
            "\tstruct snapshot_data *data;",
            "\tloff_t size;",
            "\tsector_t offset;",
            "",
            "\tif (need_wait) {",
            "\t\twait_for_device_probe();",
            "\t\tneed_wait = false;",
            "\t}",
            "",
            "\tif (_IOC_TYPE(cmd) != SNAPSHOT_IOC_MAGIC)",
            "\t\treturn -ENOTTY;",
            "\tif (_IOC_NR(cmd) > SNAPSHOT_IOC_MAXNR)",
            "\t\treturn -ENOTTY;",
            "\tif (!capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tif (!mutex_trylock(&system_transition_mutex))",
            "\t\treturn -EBUSY;",
            "",
            "\tlock_device_hotplug();",
            "\tdata = filp->private_data;",
            "",
            "\tswitch (cmd) {",
            "",
            "\tcase SNAPSHOT_FREEZE:",
            "\t\tif (data->frozen)",
            "\t\t\tbreak;",
            "",
            "\t\tksys_sync_helper();",
            "",
            "\t\terror = freeze_processes();",
            "\t\tif (error)",
            "\t\t\tbreak;",
            "",
            "\t\terror = create_basic_memory_bitmaps();",
            "\t\tif (error)",
            "\t\t\tthaw_processes();",
            "\t\telse",
            "\t\t\tdata->frozen = true;",
            "",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_UNFREEZE:",
            "\t\tif (!data->frozen || data->ready)",
            "\t\t\tbreak;",
            "\t\tpm_restore_gfp_mask();",
            "\t\tfree_basic_memory_bitmaps();",
            "\t\tdata->free_bitmaps = false;",
            "\t\tthaw_processes();",
            "\t\tdata->frozen = false;",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_CREATE_IMAGE:",
            "\t\tif (data->mode != O_RDONLY || !data->frozen  || data->ready) {",
            "\t\t\terror = -EPERM;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tpm_restore_gfp_mask();",
            "\t\terror = hibernation_snapshot(data->platform_support);",
            "\t\tif (!error) {",
            "\t\t\terror = put_user(in_suspend, (int __user *)arg);",
            "\t\t\tdata->ready = !freezer_test_done && !error;",
            "\t\t\tfreezer_test_done = false;",
            "\t\t}",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_ATOMIC_RESTORE:",
            "\t\tsnapshot_write_finalize(&data->handle);",
            "\t\tif (data->mode != O_WRONLY || !data->frozen ||",
            "\t\t    !snapshot_image_loaded(&data->handle)) {",
            "\t\t\terror = -EPERM;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\terror = hibernation_restore(data->platform_support);",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_FREE:",
            "\t\tswsusp_free();",
            "\t\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));",
            "\t\tdata->ready = false;",
            "\t\t/*",
            "\t\t * It is necessary to thaw kernel threads here, because",
            "\t\t * SNAPSHOT_CREATE_IMAGE may be invoked directly after",
            "\t\t * SNAPSHOT_FREE.  In that case, if kernel threads were not",
            "\t\t * thawed, the preallocation of memory carried out by",
            "\t\t * hibernation_snapshot() might run into problems (i.e. it",
            "\t\t * might fail or even deadlock).",
            "\t\t */",
            "\t\tthaw_kernel_threads();",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_PREF_IMAGE_SIZE:",
            "\t\timage_size = arg;",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_GET_IMAGE_SIZE:",
            "\t\tif (!data->ready) {",
            "\t\t\terror = -ENODATA;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tsize = snapshot_get_image_size();",
            "\t\tsize <<= PAGE_SHIFT;",
            "\t\terror = put_user(size, (loff_t __user *)arg);",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_AVAIL_SWAP_SIZE:",
            "\t\tsize = count_swap_pages(data->swap, 1);",
            "\t\tsize <<= PAGE_SHIFT;",
            "\t\terror = put_user(size, (loff_t __user *)arg);",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_ALLOC_SWAP_PAGE:",
            "\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {",
            "\t\t\terror = -ENODEV;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\toffset = alloc_swapdev_block(data->swap);",
            "\t\tif (offset) {",
            "\t\t\toffset <<= PAGE_SHIFT;",
            "\t\t\terror = put_user(offset, (loff_t __user *)arg);",
            "\t\t} else {",
            "\t\t\terror = -ENOSPC;",
            "\t\t}",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_FREE_SWAP_PAGES:",
            "\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {",
            "\t\t\terror = -ENODEV;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tfree_all_swap_pages(data->swap);",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_S2RAM:",
            "\t\tif (!data->frozen) {",
            "\t\t\terror = -EPERM;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t/*",
            "\t\t * Tasks are frozen and the notifiers have been called with",
            "\t\t * PM_HIBERNATION_PREPARE",
            "\t\t */",
            "\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);",
            "\t\tdata->ready = false;",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_PLATFORM_SUPPORT:",
            "\t\tdata->platform_support = !!arg;",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_POWER_OFF:",
            "\t\tif (data->platform_support)",
            "\t\t\terror = hibernation_platform_enter();",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_SET_SWAP_AREA:",
            "\t\terror = snapshot_set_swap_area(data, (void __user *)arg);",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\terror = -ENOTTY;",
            "",
            "\t}",
            "",
            "\tunlock_device_hotplug();",
            "\tmutex_unlock(&system_transition_mutex);",
            "",
            "\treturn error;",
            "}"
          ],
          "function_name": "snapshot_write, snapshot_set_swap_area, snapshot_ioctl",
          "description": "实现快照设备的写入、交换区设置和通用控制命令处理，包含对内存镜像创建、恢复、页面分配等关键操作的支持，并通过ioctl接口暴露多种系统控制功能。",
          "similarity": 0.5095921754837036
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/power/user.c",
          "start_line": 42,
          "end_line": 163,
          "content": [
            "int is_hibernate_resume_dev(dev_t dev)",
            "{",
            "\treturn hibernation_available() && snapshot_state.dev == dev;",
            "}",
            "static int snapshot_open(struct inode *inode, struct file *filp)",
            "{",
            "\tstruct snapshot_data *data;",
            "\tunsigned int sleep_flags;",
            "\tint error;",
            "",
            "\tif (!hibernation_available())",
            "\t\treturn -EPERM;",
            "",
            "\tsleep_flags = lock_system_sleep();",
            "",
            "\tif (!hibernate_acquire()) {",
            "\t\terror = -EBUSY;",
            "\t\tgoto Unlock;",
            "\t}",
            "",
            "\tif ((filp->f_flags & O_ACCMODE) == O_RDWR) {",
            "\t\thibernate_release();",
            "\t\terror = -ENOSYS;",
            "\t\tgoto Unlock;",
            "\t}",
            "\tnonseekable_open(inode, filp);",
            "\tdata = &snapshot_state;",
            "\tfilp->private_data = data;",
            "\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));",
            "\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY) {",
            "\t\t/* Hibernating.  The image device should be accessible. */",
            "\t\tdata->swap = swap_type_of(swsusp_resume_device, 0);",
            "\t\tdata->mode = O_RDONLY;",
            "\t\tdata->free_bitmaps = false;",
            "\t\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);",
            "\t} else {",
            "\t\t/*",
            "\t\t * Resuming.  We may need to wait for the image device to",
            "\t\t * appear.",
            "\t\t */",
            "\t\tneed_wait = true;",
            "",
            "\t\tdata->swap = -1;",
            "\t\tdata->mode = O_WRONLY;",
            "\t\terror = pm_notifier_call_chain_robust(PM_RESTORE_PREPARE, PM_POST_RESTORE);",
            "\t\tif (!error) {",
            "\t\t\terror = create_basic_memory_bitmaps();",
            "\t\t\tdata->free_bitmaps = !error;",
            "\t\t}",
            "\t}",
            "\tif (error)",
            "\t\thibernate_release();",
            "",
            "\tdata->frozen = false;",
            "\tdata->ready = false;",
            "\tdata->platform_support = false;",
            "\tdata->dev = 0;",
            "",
            " Unlock:",
            "\tunlock_system_sleep(sleep_flags);",
            "",
            "\treturn error;",
            "}",
            "static int snapshot_release(struct inode *inode, struct file *filp)",
            "{",
            "\tstruct snapshot_data *data;",
            "\tunsigned int sleep_flags;",
            "",
            "\tsleep_flags = lock_system_sleep();",
            "",
            "\tswsusp_free();",
            "\tdata = filp->private_data;",
            "\tdata->dev = 0;",
            "\tfree_all_swap_pages(data->swap);",
            "\tif (data->frozen) {",
            "\t\tpm_restore_gfp_mask();",
            "\t\tfree_basic_memory_bitmaps();",
            "\t\tthaw_processes();",
            "\t} else if (data->free_bitmaps) {",
            "\t\tfree_basic_memory_bitmaps();",
            "\t}",
            "\tpm_notifier_call_chain(data->mode == O_RDONLY ?",
            "\t\t\tPM_POST_HIBERNATION : PM_POST_RESTORE);",
            "\thibernate_release();",
            "",
            "\tunlock_system_sleep(sleep_flags);",
            "",
            "\treturn 0;",
            "}",
            "static ssize_t snapshot_read(struct file *filp, char __user *buf,",
            "                             size_t count, loff_t *offp)",
            "{",
            "\tloff_t pg_offp = *offp & ~PAGE_MASK;",
            "\tstruct snapshot_data *data;",
            "\tunsigned int sleep_flags;",
            "\tssize_t res;",
            "",
            "\tsleep_flags = lock_system_sleep();",
            "",
            "\tdata = filp->private_data;",
            "\tif (!data->ready) {",
            "\t\tres = -ENODATA;",
            "\t\tgoto Unlock;",
            "\t}",
            "\tif (!pg_offp) { /* on page boundary? */",
            "\t\tres = snapshot_read_next(&data->handle);",
            "\t\tif (res <= 0)",
            "\t\t\tgoto Unlock;",
            "\t} else {",
            "\t\tres = PAGE_SIZE - pg_offp;",
            "\t}",
            "",
            "\tres = simple_read_from_buffer(buf, count, &pg_offp,",
            "\t\t\tdata_of(data->handle), res);",
            "\tif (res > 0)",
            "\t\t*offp += res;",
            "",
            " Unlock:",
            "\tunlock_system_sleep(sleep_flags);",
            "",
            "\treturn res;",
            "}"
          ],
          "function_name": "is_hibernate_resume_dev, snapshot_open, snapshot_release, snapshot_read",
          "description": "实现快照设备的打开、释放和读取操作，其中snapshot_open初始化快照状态并配置设备参数，snapshot_read从快照设备中分页读取数据。",
          "similarity": 0.5028509497642517
        }
      ]
    }
  ]
}