{
  "query": "缓冲区溢出解决方案",
  "timestamp": "2025-12-25 23:48:56",
  "retrieved_files": [
    {
      "source_file": "kernel/scs.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:22:19\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `scs.c`\n\n---\n\n# scs.c 技术文档\n\n## 文件概述\n\n`scs.c` 是 Linux 内核中实现 **Shadow Call Stack（SCS，影子调用栈）** 功能的核心文件。SCS 是一种安全机制，用于在支持的架构（如 ARM64）上防止函数返回地址被栈溢出等攻击篡改。该机制通过将函数返回地址存储在独立于常规内核栈的“影子栈”中，从而增强控制流完整性（CFI）。本文件负责 SCS 内存的分配、释放、初始化及资源管理。\n\n## 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `scs_alloc(int node)` | 为任务分配一个 SCS 区域，优先从每 CPU 缓存中获取，否则通过 `vmalloc` 分配 |\n| `scs_free(void *s)` | 释放 SCS 区域，尝试缓存到每 CPU 缓存，否则异步释放 |\n| `scs_init(void)` | 初始化 SCS 子系统，注册 CPU 热插拔清理回调 |\n| `scs_prepare(struct task_struct *tsk, int node)` | 为新任务准备 SCS，调用 `scs_alloc` 并设置任务结构体中的 SCS 指针 |\n| `scs_release(struct task_struct *tsk)` | 释放任务的 SCS，检查栈末尾魔数是否被破坏，并记录最大使用量（调试模式） |\n| `scs_check_usage(struct task_struct *tsk)` | （仅在 `CONFIG_DEBUG_STACK_USAGE` 启用时）统计并报告 SCS 使用峰值 |\n\n### 主要数据结构与宏\n\n- `NR_CACHED_SCS`：每 CPU 缓存的 SCS 数量，设为 2，与 `VMAP_STACK` 的 `NR_CACHED_STACKS` 一致\n- `scs_cache[NR_CACHED_SCS]`：每 CPU 的 SCS 缓存数组，用于快速重用已分配的 SCS\n- `dynamic_scs_enabled`：静态键（static key），用于动态启用/禁用 SCS（仅当 `CONFIG_DYNAMIC_SCS` 启用）\n- `SCS_SIZE`：单个 SCS 的大小（定义在头文件中）\n- `SCS_END_MAGIC`：写入 SCS 末尾的魔数，用于检测栈溢出破坏\n\n## 关键实现\n\n### 1. 内存分配策略\n- **缓存优先**：`__scs_alloc` 首先尝试从当前 CPU 的 `scs_cache` 中获取空闲 SCS，避免频繁调用 `vmalloc`。\n- **非阻塞释放**：`scs_free` 在中断上下文也可安全调用，使用 `this_cpu_cmpxchg` 原子更新缓存；若缓存满，则调用 `vfree_atomic` 异步释放。\n- **KASAN 集成**：分配时通过 `kasan_unpoison_vmalloc` 解毒，使用后通过 `kasan_poison_vmalloc` 毒化，防止非法访问。\n\n### 2. 资源统计\n- `__scs_account` 函数通过 `mod_node_page_state` 更新 `NR_KERNEL_SCS_KB` 统计项，跟踪每个 NUMA 节点上 SCS 内存使用量（以 KB 为单位）。\n\n### 3. 安全校验\n- **魔数保护**：每个 SCS 末尾写入 `SCS_END_MAGIC`，`scs_release` 时检查该值是否被覆盖，若损坏则触发 `WARN`。\n- **使用量监控**：在 `CONFIG_DEBUG_STACK_USAGE` 模式下，`scs_check_usage` 扫描 SCS 中非零区域，估算实际使用深度，并全局记录历史最大值。\n\n### 4. CPU 热插拔支持\n- 通过 `cpuhp_setup_state` 注册 `scs_cleanup` 回调，在 CPU offline 时释放该 CPU 缓存中的 SCS，防止内存泄漏。\n\n## 依赖关系\n\n- **内存管理**：依赖 `vmalloc` 子系统进行非连续内存分配（`__vmalloc_node_range`、`vfree_atomic`）。\n- **KASAN**：与内核地址消毒器（KASAN）深度集成，使用 `kasan_poison_vmalloc` / `kasan_unpoison_vmalloc` 管理虚拟内存毒化状态。\n- **Per-CPU 机制**：使用 `DEFINE_PER_CPU` 和 `this_cpu_xchg`/`this_cpu_cmpxchg` 实现每 CPU 缓存。\n- **CPU 热插拔**：依赖 `cpuhotplug.h` 提供的 CPU 状态管理接口。\n- **配置选项**：\n  - `CONFIG_SHADOW_CALL_STACK`：启用 SCS 功能\n  - `CONFIG_DYNAMIC_SCS`：支持运行时动态开关 SCS\n  - `CONFIG_DEBUG_STACK_USAGE`：启用 SCS 使用量调试统计\n\n## 使用场景\n\n- **任务创建/销毁**：在 `copy_process` 流程中调用 `scs_prepare` 为新内核线程或进程分配 SCS；在任务退出时通过 `scs_release` 释放。\n- **中断与软中断上下文**：由于 `scs_free` 使用 `vfree_atomic`，可在中断上下文安全释放 SCS。\n- **安全加固系统**：在启用 SCS 的 ARM64 系统中，编译器（如 Clang）会将函数返回地址写入 SCS 而非常规栈，内核需为此提供运行时支持。\n- **内存调试**：配合 KASAN 和 `CONFIG_DEBUG_STACK_USAGE`，帮助开发者检测 SCS 溢出和内存使用异常。",
      "similarity": 0.5781988501548767,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/scs.c",
          "start_line": 19,
          "end_line": 116,
          "content": [
            "static void __scs_account(void *s, int account)",
            "{",
            "\tstruct page *scs_page = vmalloc_to_page(s);",
            "",
            "\tmod_node_page_state(page_pgdat(scs_page), NR_KERNEL_SCS_KB,",
            "\t\t\t    account * (SCS_SIZE / SZ_1K));",
            "}",
            "void scs_free(void *s)",
            "{",
            "\tint i;",
            "",
            "\t__scs_account(s, -1);",
            "",
            "\t/*",
            "\t * We cannot sleep as this can be called in interrupt context,",
            "\t * so use this_cpu_cmpxchg to update the cache, and vfree_atomic",
            "\t * to free the stack.",
            "\t */",
            "",
            "\tfor (i = 0; i < NR_CACHED_SCS; i++)",
            "\t\tif (this_cpu_cmpxchg(scs_cache[i], 0, s) == NULL)",
            "\t\t\treturn;",
            "",
            "\tkasan_unpoison_vmalloc(s, SCS_SIZE, KASAN_VMALLOC_PROT_NORMAL);",
            "\tvfree_atomic(s);",
            "}",
            "static int scs_cleanup(unsigned int cpu)",
            "{",
            "\tint i;",
            "\tvoid **cache = per_cpu_ptr(scs_cache, cpu);",
            "",
            "\tfor (i = 0; i < NR_CACHED_SCS; i++) {",
            "\t\tvfree(cache[i]);",
            "\t\tcache[i] = NULL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void __init scs_init(void)",
            "{",
            "\tif (!scs_is_enabled())",
            "\t\treturn;",
            "\tcpuhp_setup_state(CPUHP_BP_PREPARE_DYN, \"scs:scs_cache\", NULL,",
            "\t\t\t  scs_cleanup);",
            "}",
            "int scs_prepare(struct task_struct *tsk, int node)",
            "{",
            "\tvoid *s;",
            "",
            "\tif (!scs_is_enabled())",
            "\t\treturn 0;",
            "",
            "\ts = scs_alloc(node);",
            "\tif (!s)",
            "\t\treturn -ENOMEM;",
            "",
            "\ttask_scs(tsk) = task_scs_sp(tsk) = s;",
            "\treturn 0;",
            "}",
            "static void scs_check_usage(struct task_struct *tsk)",
            "{",
            "\tstatic unsigned long highest;",
            "",
            "\tunsigned long *p, prev, curr = highest, used = 0;",
            "",
            "\tif (!IS_ENABLED(CONFIG_DEBUG_STACK_USAGE))",
            "\t\treturn;",
            "",
            "\tfor (p = task_scs(tsk); p < __scs_magic(tsk); ++p) {",
            "\t\tif (!READ_ONCE_NOCHECK(*p))",
            "\t\t\tbreak;",
            "\t\tused += sizeof(*p);",
            "\t}",
            "",
            "\twhile (used > curr) {",
            "\t\tprev = cmpxchg_relaxed(&highest, curr, used);",
            "",
            "\t\tif (prev == curr) {",
            "\t\t\tpr_info(\"%s (%d): highest shadow stack usage: %lu bytes\\n\",",
            "\t\t\t\ttsk->comm, task_pid_nr(tsk), used);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tcurr = prev;",
            "\t}",
            "}",
            "void scs_release(struct task_struct *tsk)",
            "{",
            "\tvoid *s = task_scs(tsk);",
            "",
            "\tif (!scs_is_enabled() || !s)",
            "\t\treturn;",
            "",
            "\tWARN(task_scs_end_corrupted(tsk),",
            "\t     \"corrupted shadow stack detected when freeing task\\n\");",
            "\tscs_check_usage(tsk);",
            "\tscs_free(s);",
            "}"
          ],
          "function_name": "__scs_account, scs_free, scs_cleanup, scs_init, scs_prepare, scs_check_usage, scs_release",
          "description": "实现SCS内存管理逻辑，包含分配/释放影子调用栈、缓存维护、CPU热插拔清理及任务栈使用量监控功能",
          "similarity": 0.5798945426940918
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/scs.c",
          "start_line": 1,
          "end_line": 18,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Shadow Call Stack support.",
            " *",
            " * Copyright (C) 2019 Google LLC",
            " */",
            "",
            "#include <linux/cpuhotplug.h>",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/scs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vmstat.h>",
            "",
            "#ifdef CONFIG_DYNAMIC_SCS",
            "DEFINE_STATIC_KEY_FALSE(dynamic_scs_enabled);",
            "#endif",
            ""
          ],
          "function_name": null,
          "description": "定义动态SCS功能的静态键，用于控制是否启用运行时扩展的影子调用栈机制",
          "similarity": 0.3910491466522217
        }
      ]
    },
    {
      "source_file": "mm/kasan/quarantine.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:17:26\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kasan\\quarantine.c`\n\n---\n\n# kasan/quarantine.c 技术文档\n\n## 1. 文件概述\n\n`kasan/quarantine.c` 实现了 KASAN（Kernel Address Sanitizer）的隔离区（Quarantine）机制。该机制用于延迟释放已释放但可能仍被非法访问的内存对象，从而提高检测 Use-After-Free（UAF）错误的能力。通过将释放的对象暂时放入隔离队列而非立即归还给内存分配器，KASAN 能在后续访问这些“已释放”内存时捕获违规行为。\n\n隔离区由每个 CPU 的本地队列和一个全局循环批次队列组成，并支持动态调整大小以适应系统内存压力，防止因隔离区过大导致 OOM（Out-Of-Memory）。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct qlist_head`**  \n  表示一个单向链表队列，包含头指针、尾指针、总字节数和离线标志。\n  \n- **`cpu_quarantine`**（per-CPU）  \n  每个 CPU 的本地隔离队列，用于暂存刚释放的对象。\n\n- **`global_quarantine[QUARANTINE_BATCHES]`**  \n  全局隔离批次数组，采用循环 FIFO 结构，存储从各 CPU 队列转移过来的批量对象。\n\n- **`shrink_qlist`**（per-CPU）  \n  用于内存回收路径的辅助队列，带自旋锁保护。\n\n- **`remove_cache_srcu`**  \n  SRCU（Sleepable RCU）同步机制，用于安全地移除特定 slab 缓存的所有隔离对象。\n\n### 主要函数\n\n- **`kasan_quarantine_put()`**  \n  将指定对象放入当前 CPU 的隔离队列；若队列超过阈值，则批量转移到全局隔离区。\n\n- **`kasan_quarantine_reduce()`**  \n  当全局隔离区总大小超过限制时，释放最早一批对象以回收内存。\n\n- **`qlist_free_all()`**  \n  遍历并实际释放队列中所有对象回 slab 分配器。\n\n- **`qlink_free()`**  \n  执行单个隔离对象的实际释放操作，包括清除 KASAN 元数据和 shadow 内存标记。\n\n- **`qlist_move_cache()`**（未完成）  \n  （代码截断）预期用于将特定缓存类型的所有对象从一个队列迁移到另一个队列，通常用于缓存销毁时清理隔离对象。\n\n## 3. 关键实现\n\n### 隔离队列结构\n- 使用轻量级单向链表 `qlist_head` 管理对象，每个节点为 `struct qlist_node`（嵌入在 `kasan_free_meta` 中）。\n- 每个 CPU 维护一个本地队列（`cpu_quarantine`），避免锁竞争，提升性能。\n- 全局隔离区由 `QUARANTINE_BATCHES` 个批次组成环形缓冲区，通过 `quarantine_head` 和 `quarantine_tail` 实现 FIFO。\n\n### 内存管理策略\n- 单个 CPU 队列最大为 `QUARANTINE_PERCPU_SIZE`（1MB）。\n- 全局隔离区最大容量为系统物理内存的 `1/QUARANTINE_FRACTION`（即 1/32），再减去所有 CPU 队列的上限总和。\n- 批次大小 `quarantine_batch_size` 动态计算，至少为 `QUARANTINE_PERCPU_SIZE`，确保高效批量处理。\n\n### 并发与同步\n- CPU 本地操作使用 `local_irq_save/restore` 禁用中断，保证原子性。\n- 全局队列操作受 `quarantine_lock`（raw spinlock）保护。\n- 使用 `SRCU`（`remove_cache_srcu`）协调 `kasan_quarantine_remove_cache()` 与隔离对象释放之间的同步，确保在缓存销毁时不会遗漏隔离中的对象。\n\n### 安全释放机制\n- 对象释放前会将对应的 KASAN shadow 字节设为 `KASAN_SLAB_FREE`，使后续访问触发 KASAN 报告。\n- 若启用了 `init_on_free` 且 free metadata 存储在对象内部，则在释放前显式清零元数据，避免残留敏感信息。\n\n## 4. 依赖关系\n\n- **KASAN 核心模块**：依赖 `kasan.h` 中定义的元数据结构（如 `kasan_free_meta`）、shadow 内存操作和 `kasan_get_free_meta()` 等接口。\n- **Slab 分配器**：通过 `___cache_free()` 将对象归还给底层 slab（SLAB/SLUB）；使用 `virt_to_slab()` 和 `slab_want_init_on_free()` 等 slab 内部接口。\n- **内存管理子系统**：调用 `totalram_pages()` 获取系统内存总量，用于动态调整隔离区大小。\n- **CPU 热插拔**：通过 `num_online_cpus()` 适配 CPU 数量变化。\n- **同步原语**：使用 `percpu`、`raw_spinlock`、`SRCU` 和 `local_irq_*` 实现并发控制。\n- **内存回收**：虽未直接注册 shrinker（注释提及 SLAB 不支持），但 `kasan_quarantine_reduce()` 可被外部调用以响应内存压力。\n\n## 5. 使用场景\n\n- **Use-After-Free 检测增强**：当内核启用 KASAN（特别是 `CONFIG_KASAN_GENERIC` 或 `CONFIG_KASAN_SW_TAGS`）时，`kfree()` 或 `kmem_cache_free()` 调用会先将对象放入隔离区而非立即释放，延长 UAF 检测窗口。\n- **内存压力下的自动回收**：当系统内存紧张或隔离区超过阈值时，调用 `kasan_quarantine_reduce()` 释放最早隔离的一批对象，防止内存耗尽。\n- **Slab 缓存销毁**：当某个 `kmem_cache` 被销毁时，需调用未在本文件中完整实现的 `kasan_quarantine_remove_cache()`（依赖 `qlist_move_cache`），将该缓存的所有隔离对象立即释放，避免悬空引用。\n- **调试与测试**：在内核开发和测试阶段，隔离机制显著提升内存错误的可复现性和诊断能力。",
      "similarity": 0.5692483186721802,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/kasan/quarantine.c",
          "start_line": 238,
          "end_line": 375,
          "content": [
            "void kasan_quarantine_reduce(void)",
            "{",
            "\tsize_t total_size, new_quarantine_size, percpu_quarantines;",
            "\tunsigned long flags;",
            "\tint srcu_idx;",
            "\tstruct qlist_head to_free = QLIST_INIT;",
            "",
            "\tif (likely(READ_ONCE(quarantine_size) <=",
            "\t\t   READ_ONCE(quarantine_max_size)))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * srcu critical section ensures that kasan_quarantine_remove_cache()",
            "\t * will not miss objects belonging to the cache while they are in our",
            "\t * local to_free list. srcu is chosen because (1) it gives us private",
            "\t * grace period domain that does not interfere with anything else,",
            "\t * and (2) it allows synchronize_srcu() to return without waiting",
            "\t * if there are no pending read critical sections (which is the",
            "\t * expected case).",
            "\t */",
            "\tsrcu_idx = srcu_read_lock(&remove_cache_srcu);",
            "\traw_spin_lock_irqsave(&quarantine_lock, flags);",
            "",
            "\t/*",
            "\t * Update quarantine size in case of hotplug. Allocate a fraction of",
            "\t * the installed memory to quarantine minus per-cpu queue limits.",
            "\t */",
            "\ttotal_size = (totalram_pages() << PAGE_SHIFT) /",
            "\t\tQUARANTINE_FRACTION;",
            "\tpercpu_quarantines = QUARANTINE_PERCPU_SIZE * num_online_cpus();",
            "\tnew_quarantine_size = (total_size < percpu_quarantines) ?",
            "\t\t0 : total_size - percpu_quarantines;",
            "\tWRITE_ONCE(quarantine_max_size, new_quarantine_size);",
            "\t/* Aim at consuming at most 1/2 of slots in quarantine. */",
            "\tWRITE_ONCE(quarantine_batch_size, max((size_t)QUARANTINE_PERCPU_SIZE,",
            "\t\t2 * total_size / QUARANTINE_BATCHES));",
            "",
            "\tif (likely(quarantine_size > quarantine_max_size)) {",
            "\t\tqlist_move_all(&global_quarantine[quarantine_head], &to_free);",
            "\t\tWRITE_ONCE(quarantine_size, quarantine_size - to_free.bytes);",
            "\t\tquarantine_head++;",
            "\t\tif (quarantine_head == QUARANTINE_BATCHES)",
            "\t\t\tquarantine_head = 0;",
            "\t}",
            "",
            "\traw_spin_unlock_irqrestore(&quarantine_lock, flags);",
            "",
            "\tqlist_free_all(&to_free, NULL);",
            "\tsrcu_read_unlock(&remove_cache_srcu, srcu_idx);",
            "}",
            "static void qlist_move_cache(struct qlist_head *from,",
            "\t\t\t\t   struct qlist_head *to,",
            "\t\t\t\t   struct kmem_cache *cache)",
            "{",
            "\tstruct qlist_node *curr;",
            "",
            "\tif (unlikely(qlist_empty(from)))",
            "\t\treturn;",
            "",
            "\tcurr = from->head;",
            "\tqlist_init(from);",
            "\twhile (curr) {",
            "\t\tstruct qlist_node *next = curr->next;",
            "\t\tstruct kmem_cache *obj_cache = qlink_to_cache(curr);",
            "",
            "\t\tif (obj_cache == cache)",
            "\t\t\tqlist_put(to, curr, obj_cache->size);",
            "\t\telse",
            "\t\t\tqlist_put(from, curr, obj_cache->size);",
            "",
            "\t\tcurr = next;",
            "\t}",
            "}",
            "static void __per_cpu_remove_cache(struct qlist_head *q, void *arg)",
            "{",
            "\tstruct kmem_cache *cache = arg;",
            "\tunsigned long flags;",
            "\tstruct cpu_shrink_qlist *sq;",
            "",
            "\tsq = this_cpu_ptr(&shrink_qlist);",
            "\traw_spin_lock_irqsave(&sq->lock, flags);",
            "\tqlist_move_cache(q, &sq->qlist, cache);",
            "\traw_spin_unlock_irqrestore(&sq->lock, flags);",
            "}",
            "static void per_cpu_remove_cache(void *arg)",
            "{",
            "\tstruct qlist_head *q;",
            "",
            "\tq = this_cpu_ptr(&cpu_quarantine);",
            "\t/*",
            "\t * Ensure the ordering between the writing to q->offline and",
            "\t * per_cpu_remove_cache.  Prevent cpu_quarantine from being corrupted",
            "\t * by interrupt.",
            "\t */",
            "\tif (READ_ONCE(q->offline))",
            "\t\treturn;",
            "\t__per_cpu_remove_cache(q, arg);",
            "}",
            "void kasan_quarantine_remove_cache(struct kmem_cache *cache)",
            "{",
            "\tunsigned long flags, i;",
            "\tstruct qlist_head to_free = QLIST_INIT;",
            "\tint cpu;",
            "\tstruct cpu_shrink_qlist *sq;",
            "",
            "\t/*",
            "\t * Must be careful to not miss any objects that are being moved from",
            "\t * per-cpu list to the global quarantine in kasan_quarantine_put(),",
            "\t * nor objects being freed in kasan_quarantine_reduce(). on_each_cpu()",
            "\t * achieves the first goal, while synchronize_srcu() achieves the",
            "\t * second.",
            "\t */",
            "\ton_each_cpu(per_cpu_remove_cache, cache, 1);",
            "",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tsq = per_cpu_ptr(&shrink_qlist, cpu);",
            "\t\traw_spin_lock_irqsave(&sq->lock, flags);",
            "\t\tqlist_move_cache(&sq->qlist, &to_free, cache);",
            "\t\traw_spin_unlock_irqrestore(&sq->lock, flags);",
            "\t}",
            "\tqlist_free_all(&to_free, cache);",
            "",
            "\traw_spin_lock_irqsave(&quarantine_lock, flags);",
            "\tfor (i = 0; i < QUARANTINE_BATCHES; i++) {",
            "\t\tif (qlist_empty(&global_quarantine[i]))",
            "\t\t\tcontinue;",
            "\t\tqlist_move_cache(&global_quarantine[i], &to_free, cache);",
            "\t\t/* Scanning whole quarantine can take a while. */",
            "\t\traw_spin_unlock_irqrestore(&quarantine_lock, flags);",
            "\t\tcond_resched();",
            "\t\traw_spin_lock_irqsave(&quarantine_lock, flags);",
            "\t}",
            "\traw_spin_unlock_irqrestore(&quarantine_lock, flags);",
            "",
            "\tqlist_free_all(&to_free, cache);",
            "",
            "\tsynchronize_srcu(&remove_cache_srcu);",
            "}"
          ],
          "function_name": "kasan_quarantine_reduce, qlist_move_cache, __per_cpu_remove_cache, per_cpu_remove_cache, kasan_quarantine_remove_cache",
          "description": "提供隔离区缩减机制(kasan_quarantine_reduce)，通过srcu同步和跨CPU遍历清除指定缓存对象，利用qlist_move_cache实现基于缓存类型的对象转移与释放。",
          "similarity": 0.6264500617980957
        },
        {
          "chunk_id": 3,
          "file_path": "mm/kasan/quarantine.c",
          "start_line": 382,
          "end_line": 410,
          "content": [
            "static int kasan_cpu_online(unsigned int cpu)",
            "{",
            "\tthis_cpu_ptr(&cpu_quarantine)->offline = false;",
            "\treturn 0;",
            "}",
            "static int kasan_cpu_offline(unsigned int cpu)",
            "{",
            "\tstruct qlist_head *q;",
            "",
            "\tq = this_cpu_ptr(&cpu_quarantine);",
            "\t/* Ensure the ordering between the writing to q->offline and",
            "\t * qlist_free_all. Otherwise, cpu_quarantine may be corrupted",
            "\t * by interrupt.",
            "\t */",
            "\tWRITE_ONCE(q->offline, true);",
            "\tbarrier();",
            "\tqlist_free_all(q, NULL);",
            "\treturn 0;",
            "}",
            "static int __init kasan_cpu_quarantine_init(void)",
            "{",
            "\tint ret = 0;",
            "",
            "\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"mm/kasan:online\",",
            "\t\t\t\tkasan_cpu_online, kasan_cpu_offline);",
            "\tif (ret < 0)",
            "\t\tpr_err(\"kasan cpu quarantine register failed [%d]\\n\", ret);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "kasan_cpu_online, kasan_cpu_offline, kasan_cpu_quarantine_init",
          "description": "实现CPU热插拔时隔离区状态管理，kasan_cpu_online/kasan_cpu_offline控制隔离区可用性，kasan_cpu_quarantine_init注册CPU状态回调接口。",
          "similarity": 0.5366745591163635
        },
        {
          "chunk_id": 1,
          "file_path": "mm/kasan/quarantine.c",
          "start_line": 42,
          "end_line": 172,
          "content": [
            "static bool qlist_empty(struct qlist_head *q)",
            "{",
            "\treturn !q->head;",
            "}",
            "static void qlist_init(struct qlist_head *q)",
            "{",
            "\tq->head = q->tail = NULL;",
            "\tq->bytes = 0;",
            "}",
            "static void qlist_put(struct qlist_head *q, struct qlist_node *qlink,",
            "\t\tsize_t size)",
            "{",
            "\tif (unlikely(qlist_empty(q)))",
            "\t\tq->head = qlink;",
            "\telse",
            "\t\tq->tail->next = qlink;",
            "\tq->tail = qlink;",
            "\tqlink->next = NULL;",
            "\tq->bytes += size;",
            "}",
            "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)",
            "{",
            "\tif (unlikely(qlist_empty(from)))",
            "\t\treturn;",
            "",
            "\tif (qlist_empty(to)) {",
            "\t\t*to = *from;",
            "\t\tqlist_init(from);",
            "\t\treturn;",
            "\t}",
            "",
            "\tto->tail->next = from->head;",
            "\tto->tail = from->tail;",
            "\tto->bytes += from->bytes;",
            "",
            "\tqlist_init(from);",
            "}",
            "static void qlink_free(struct qlist_node *qlink, struct kmem_cache *cache)",
            "{",
            "\tvoid *object = qlink_to_object(qlink, cache);",
            "\tstruct kasan_free_meta *meta = kasan_get_free_meta(cache, object);",
            "",
            "\t/*",
            "\t * If init_on_free is enabled and KASAN's free metadata is stored in",
            "\t * the object, zero the metadata. Otherwise, the object's memory will",
            "\t * not be properly zeroed, as KASAN saves the metadata after the slab",
            "\t * allocator zeroes the object.",
            "\t */",
            "\tif (slab_want_init_on_free(cache) &&",
            "\t    cache->kasan_info.free_meta_offset == 0)",
            "\t\tmemzero_explicit(meta, sizeof(*meta));",
            "",
            "\t/*",
            "\t * As the object now gets freed from the quarantine, assume that its",
            "\t * free track is no longer valid.",
            "\t */",
            "\t*(u8 *)kasan_mem_to_shadow(object) = KASAN_SLAB_FREE;",
            "",
            "\t___cache_free(cache, object, _THIS_IP_);",
            "}",
            "static void qlist_free_all(struct qlist_head *q, struct kmem_cache *cache)",
            "{",
            "\tstruct qlist_node *qlink;",
            "",
            "\tif (unlikely(qlist_empty(q)))",
            "\t\treturn;",
            "",
            "\tqlink = q->head;",
            "\twhile (qlink) {",
            "\t\tstruct kmem_cache *obj_cache =",
            "\t\t\tcache ? cache :\tqlink_to_cache(qlink);",
            "\t\tstruct qlist_node *next = qlink->next;",
            "",
            "\t\tqlink_free(qlink, obj_cache);",
            "\t\tqlink = next;",
            "\t}",
            "\tqlist_init(q);",
            "}",
            "bool kasan_quarantine_put(struct kmem_cache *cache, void *object)",
            "{",
            "\tunsigned long flags;",
            "\tstruct qlist_head *q;",
            "\tstruct qlist_head temp = QLIST_INIT;",
            "\tstruct kasan_free_meta *meta = kasan_get_free_meta(cache, object);",
            "",
            "\t/*",
            "\t * If there's no metadata for this object, don't put it into",
            "\t * quarantine.",
            "\t */",
            "\tif (!meta)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Note: irq must be disabled until after we move the batch to the",
            "\t * global quarantine. Otherwise kasan_quarantine_remove_cache() can",
            "\t * miss some objects belonging to the cache if they are in our local",
            "\t * temp list. kasan_quarantine_remove_cache() executes on_each_cpu()",
            "\t * at the beginning which ensures that it either sees the objects in",
            "\t * per-cpu lists or in the global quarantine.",
            "\t */",
            "\tlocal_irq_save(flags);",
            "",
            "\tq = this_cpu_ptr(&cpu_quarantine);",
            "\tif (q->offline) {",
            "\t\tlocal_irq_restore(flags);",
            "\t\treturn false;",
            "\t}",
            "\tqlist_put(q, &meta->quarantine_link, cache->size);",
            "\tif (unlikely(q->bytes > QUARANTINE_PERCPU_SIZE)) {",
            "\t\tqlist_move_all(q, &temp);",
            "",
            "\t\traw_spin_lock(&quarantine_lock);",
            "\t\tWRITE_ONCE(quarantine_size, quarantine_size + temp.bytes);",
            "\t\tqlist_move_all(&temp, &global_quarantine[quarantine_tail]);",
            "\t\tif (global_quarantine[quarantine_tail].bytes >=",
            "\t\t\t\tREAD_ONCE(quarantine_batch_size)) {",
            "\t\t\tint new_tail;",
            "",
            "\t\t\tnew_tail = quarantine_tail + 1;",
            "\t\t\tif (new_tail == QUARANTINE_BATCHES)",
            "\t\t\t\tnew_tail = 0;",
            "\t\t\tif (new_tail != quarantine_head)",
            "\t\t\t\tquarantine_tail = new_tail;",
            "\t\t}",
            "\t\traw_spin_unlock(&quarantine_lock);",
            "\t}",
            "",
            "\tlocal_irq_restore(flags);",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "qlist_empty, qlist_init, qlist_put, qlist_move_all, qlink_free, qlist_free_all, kasan_quarantine_put",
          "description": "实现了隔离区队列的基本操作（空判断、初始化、插入、转移和释放），kasan_quarantine_put将对象加入当前CPU隔离队列并触发全局隔离区迁移，通过中断屏蔽保证并发安全性。",
          "similarity": 0.5343543291091919
        },
        {
          "chunk_id": 0,
          "file_path": "mm/kasan/quarantine.c",
          "start_line": 1,
          "end_line": 41,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * KASAN quarantine.",
            " *",
            " * Author: Alexander Potapenko <glider@google.com>",
            " * Copyright (C) 2016 Google, Inc.",
            " *",
            " * Based on code by Dmitry Chernenkov.",
            " */",
            "",
            "#include <linux/gfp.h>",
            "#include <linux/hash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/percpu.h>",
            "#include <linux/printk.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/cpuhotplug.h>",
            "",
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "",
            "/* Data structure and operations for quarantine queues. */",
            "",
            "/*",
            " * Each queue is a single-linked list, which also stores the total size of",
            " * objects inside of it.",
            " */",
            "struct qlist_head {",
            "\tstruct qlist_node *head;",
            "\tstruct qlist_node *tail;",
            "\tsize_t bytes;",
            "\tbool offline;",
            "};",
            "",
            "#define QLIST_INIT { NULL, NULL, 0 }",
            ""
          ],
          "function_name": null,
          "description": "定义了KASAN隔离区队列的数据结构qlist_head，包含头尾指针、总字节数和离线标志位，用于管理隔离对象的链表队列。",
          "similarity": 0.4633190631866455
        }
      ]
    },
    {
      "source_file": "kernel/watch_queue.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:50:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `watch_queue.c`\n\n---\n\n# watch_queue.c 技术文档\n\n## 文件概述\n\n`watch_queue.c` 实现了 Linux 内核中的**监视队列**（Watch Queue）机制，这是一种基于管道（pipe）构建的通用事件通知系统。该机制允许内核子系统（如文件系统、密钥管理、设备驱动等）向用户空间异步发送结构化通知。用户空间通过创建特殊类型的管道并关联监视队列，即可接收来自内核的各类事件通知。该文件定义了通知的投递、过滤、缓冲管理及与管道集成的核心逻辑。\n\n## 核心功能\n\n### 主要函数\n\n- **`__post_watch_notification()`**  \n  核心通知投递函数。遍历指定 `watch_list` 中所有匹配 `id` 的监视器（`watch`），对每个关联的 `watch_queue` 应用过滤规则、安全检查，并将通知写入底层管道。\n\n- **`post_one_notification()`**  \n  将单个通知写入指定 `watch_queue` 的底层管道缓冲区。负责从预分配的通知页中获取空闲槽位、填充数据、更新管道头指针并唤醒等待读取的进程。\n\n- **`filter_watch_notification()`**  \n  根据 `watch_filter` 中的类型、子类型和信息掩码规则，判断是否允许特定通知通过。\n\n- **`watch_queue_set_size()`**  \n  为监视队列分配预分配的通知缓冲区（页数组和位图），并调整底层管道的环形缓冲区大小。\n\n- **`watch_queue_pipe_buf_release()`**  \n  管道缓冲区释放回调。当用户空间读取完通知后，将对应的通知槽位在位图中标记为空闲，供后续复用。\n\n### 关键数据结构\n\n- **`struct watch_queue`**  \n  表示一个监视队列，包含：\n  - 指向底层 `pipe_inode_info` 的指针\n  - 预分配的通知页数组（`notes`）\n  - 通知槽位空闲位图（`notes_bitmap`）\n  - 通知过滤器（`filter`）\n  - 保护锁（`lock`）\n\n- **`struct watch_notification`**  \n  通用通知记录格式，包含类型（`type`）、子类型（`subtype`）、信息字段（`info`，含长度和ID）及可变负载。\n\n- **`struct watch_filter` / `struct watch_type_filter`**  \n  定义通知过滤规则，支持按类型、子类型及信息字段的位掩码进行精确过滤。\n\n- **`watch_queue_pipe_buf_ops`**  \n  自定义的 `pipe_buf_operations`，用于管理监视队列专用管道缓冲区的生命周期。\n\n## 关键实现\n\n### 基于管道的通知传输\n- 监视队列复用内核管道（`pipe_inode_info`）作为通知传输通道，利用其成熟的读写、轮询、异步通知机制。\n- 通过自定义 `pipe_buf_operations`（`watch_queue_pipe_buf_ops`）实现通知槽位的回收：当用户读取通知后，`release` 回调将对应槽位在 `notes_bitmap` 中置位，标记为空闲。\n\n### 预分配通知缓冲区\n- 通知数据存储在预分配的内核页（`notes`）中，每页划分为多个固定大小（128字节）的槽位（`WATCH_QUEUE_NOTE_SIZE`）。\n- 使用位图（`notes_bitmap`）跟踪槽位使用状态，1 表示空闲。投递通知时通过 `find_first_bit()` 快速查找空闲槽位。\n- 缓冲区大小由用户通过 `watch_queue_set_size()` 设置（1-512个通知），并受管道缓冲区配额限制。\n\n### 通知投递流程\n1. **匹配监视器**：遍历 `watch_list`，查找 `id` 匹配的 `watch`。\n2. **应用过滤**：若队列配置了过滤器，调用 `filter_watch_notification()` 决定是否丢弃。\n3. **安全检查**：调用 LSM 钩子 `security_post_notification()` 进行权限验证。\n4. **写入管道**：\n   - 获取空闲通知槽位，复制通知数据。\n   - 构造 `pipe_buffer` 指向该槽位，设置自定义操作集。\n   - 更新管道 `head` 指针，唤醒等待读取的进程。\n   - 若缓冲区满，标记前一个缓冲区为 `PIPE_BUF_FLAG_LOSS` 表示丢包。\n\n### 并发与同步\n- **RCU 保护**：`watch_list` 和 `watch_queue` 的访问通过 RCU 机制保护，确保遍历时结构体不被释放。\n- **自旋锁**：\n  - `wqueue->lock`：保护 `wqueue` 状态（如 `pipe` 指针有效性）。\n  - `pipe->rd_wait.lock`：保护管道环形缓冲区的读写操作。\n- **原子操作**：管道 `head` 指针使用 `smp_store_release()` 更新，确保与 `pipe_read()` 的同步。\n\n## 依赖关系\n\n- **管道子系统**（`fs/pipe.c`）  \n  依赖管道的核心数据结构（`pipe_inode_info`、`pipe_buffer`）和操作接口（`pipe_buf()`、`pipe_full()`、`generic_pipe_buf_*`）。\n\n- **内存管理**  \n  使用 `alloc_page()`、`kmap_atomic()` 管理通知缓冲区页，`bitmap_alloc()` 管理槽位位图。\n\n- **安全模块**（LSM）  \n  通过 `security_post_notification()` 钩子集成安全策略。\n\n- **用户空间接口**  \n  与 `fs/watch_queue.c` 中的系统调用（如 `watch_queue_set_size()`）协同工作，后者负责创建监视队列并与管道关联。\n\n- **头文件依赖**  \n  `linux/watch_queue.h`（核心数据结构定义）、`linux/pipe_fs_i.h`（管道内部接口）。\n\n## 使用场景\n\n- **文件系统事件监控**  \n  如 `fsnotify` 子系统可通过监视队列向用户空间报告文件访问、修改等事件。\n\n- **密钥管理通知**  \n  内核密钥环（`KEYS`）子系统使用该机制通知密钥状态变更（如过期、撤销）。\n\n- **设备事件上报**  \n  设备驱动可利用监视队列异步上报硬件状态变化或错误事件。\n\n- **通用内核事件分发**  \n  任何需要向特权用户空间守护进程（如 `systemd`）发送结构化事件的内核子系统均可集成此机制。\n\n- **用户空间消费**  \n  应用程序通过 `open(\"/dev/watch_queue\")` 获取监视队列文件描述符，调用 `ioctl()` 设置缓冲区大小和过滤器，然后像读取普通管道一样接收通知。",
      "similarity": 0.566463828086853,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/watch_queue.c",
          "start_line": 42,
          "end_line": 154,
          "content": [
            "static inline bool lock_wqueue(struct watch_queue *wqueue)",
            "{",
            "\tspin_lock_bh(&wqueue->lock);",
            "\tif (unlikely(!wqueue->pipe)) {",
            "\t\tspin_unlock_bh(&wqueue->lock);",
            "\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static inline void unlock_wqueue(struct watch_queue *wqueue)",
            "{",
            "\tspin_unlock_bh(&wqueue->lock);",
            "}",
            "static void watch_queue_pipe_buf_release(struct pipe_inode_info *pipe,",
            "\t\t\t\t\t struct pipe_buffer *buf)",
            "{",
            "\tstruct watch_queue *wqueue = (struct watch_queue *)buf->private;",
            "\tstruct page *page;",
            "\tunsigned int bit;",
            "",
            "\t/* We need to work out which note within the page this refers to, but",
            "\t * the note might have been maximum size, so merely ANDing the offset",
            "\t * off doesn't work.  OTOH, the note must've been more than zero size.",
            "\t */",
            "\tbit = buf->offset + buf->len;",
            "\tif ((bit & (WATCH_QUEUE_NOTE_SIZE - 1)) == 0)",
            "\t\tbit -= WATCH_QUEUE_NOTE_SIZE;",
            "\tbit /= WATCH_QUEUE_NOTE_SIZE;",
            "",
            "\tpage = buf->page;",
            "\tbit += page->index;",
            "",
            "\tset_bit(bit, wqueue->notes_bitmap);",
            "\tgeneric_pipe_buf_release(pipe, buf);",
            "}",
            "static bool post_one_notification(struct watch_queue *wqueue,",
            "\t\t\t\t  struct watch_notification *n)",
            "{",
            "\tvoid *p;",
            "\tstruct pipe_inode_info *pipe = wqueue->pipe;",
            "\tstruct pipe_buffer *buf;",
            "\tstruct page *page;",
            "\tunsigned int head, tail, note, offset, len;",
            "\tbool done = false;",
            "",
            "\tspin_lock_irq(&pipe->rd_wait.lock);",
            "",
            "\thead = pipe->head;",
            "\ttail = pipe->tail;",
            "\tif (pipe_full(head, tail, pipe->ring_size))",
            "\t\tgoto lost;",
            "",
            "\tnote = find_first_bit(wqueue->notes_bitmap, wqueue->nr_notes);",
            "\tif (note >= wqueue->nr_notes)",
            "\t\tgoto lost;",
            "",
            "\tpage = wqueue->notes[note / WATCH_QUEUE_NOTES_PER_PAGE];",
            "\toffset = note % WATCH_QUEUE_NOTES_PER_PAGE * WATCH_QUEUE_NOTE_SIZE;",
            "\tget_page(page);",
            "\tlen = n->info & WATCH_INFO_LENGTH;",
            "\tp = kmap_atomic(page);",
            "\tmemcpy(p + offset, n, len);",
            "\tkunmap_atomic(p);",
            "",
            "\tbuf = pipe_buf(pipe, head);",
            "\tbuf->page = page;",
            "\tbuf->private = (unsigned long)wqueue;",
            "\tbuf->ops = &watch_queue_pipe_buf_ops;",
            "\tbuf->offset = offset;",
            "\tbuf->len = len;",
            "\tbuf->flags = PIPE_BUF_FLAG_WHOLE;",
            "\tsmp_store_release(&pipe->head, head + 1); /* vs pipe_read() */",
            "",
            "\tif (!test_and_clear_bit(note, wqueue->notes_bitmap)) {",
            "\t\tspin_unlock_irq(&pipe->rd_wait.lock);",
            "\t\tBUG();",
            "\t}",
            "\twake_up_interruptible_sync_poll_locked(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);",
            "\tdone = true;",
            "",
            "out:",
            "\tspin_unlock_irq(&pipe->rd_wait.lock);",
            "\tif (done)",
            "\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);",
            "\treturn done;",
            "",
            "lost:",
            "\tbuf = pipe_buf(pipe, head - 1);",
            "\tbuf->flags |= PIPE_BUF_FLAG_LOSS;",
            "\tgoto out;",
            "}",
            "static bool filter_watch_notification(const struct watch_filter *wf,",
            "\t\t\t\t      const struct watch_notification *n)",
            "{",
            "\tconst struct watch_type_filter *wt;",
            "\tunsigned int st_bits = sizeof(wt->subtype_filter[0]) * 8;",
            "\tunsigned int st_index = n->subtype / st_bits;",
            "\tunsigned int st_bit = 1U << (n->subtype % st_bits);",
            "\tint i;",
            "",
            "\tif (!test_bit(n->type, wf->type_filter))",
            "\t\treturn false;",
            "",
            "\tfor (i = 0; i < wf->nr_filters; i++) {",
            "\t\twt = &wf->filters[i];",
            "\t\tif (n->type == wt->type &&",
            "\t\t    (wt->subtype_filter[st_index] & st_bit) &&",
            "\t\t    (n->info & wt->info_mask) == wt->info_filter)",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\treturn false; /* If there is a filter, the default is to reject. */",
            "}"
          ],
          "function_name": "lock_wqueue, unlock_wqueue, watch_queue_pipe_buf_release, post_one_notification, filter_watch_notification",
          "description": "实现了watch_queue的锁操作、缓冲区释放、通知提交及过滤逻辑。lock_wqueue/unlock_wqueue用于保护队列访问，watch_queue_pipe_buf_release处理缓冲区回收并更新位图，post_one_notification将通知数据写入管道，filter_watch_notification进行类型和子类型的匹配判断。",
          "similarity": 0.6032639741897583
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/watch_queue.c",
          "start_line": 602,
          "end_line": 680,
          "content": [
            "void watch_queue_clear(struct watch_queue *wqueue)",
            "{",
            "\tstruct watch_list *wlist;",
            "\tstruct watch *watch;",
            "\tbool release;",
            "",
            "\trcu_read_lock();",
            "\tspin_lock_bh(&wqueue->lock);",
            "",
            "\t/*",
            "\t * This pipe can be freed by callers like free_pipe_info().",
            "\t * Removing this reference also prevents new notifications.",
            "\t */",
            "\twqueue->pipe = NULL;",
            "",
            "\twhile (!hlist_empty(&wqueue->watches)) {",
            "\t\twatch = hlist_entry(wqueue->watches.first, struct watch, queue_node);",
            "\t\thlist_del_init_rcu(&watch->queue_node);",
            "\t\t/* We now own a ref on the watch. */",
            "\t\tspin_unlock_bh(&wqueue->lock);",
            "",
            "\t\t/* We can't do the next bit under the queue lock as we need to",
            "\t\t * get the list lock - which would cause a deadlock if someone",
            "\t\t * was removing from the opposite direction at the same time or",
            "\t\t * posting a notification.",
            "\t\t */",
            "\t\twlist = rcu_dereference(watch->watch_list);",
            "\t\tif (wlist) {",
            "\t\t\tvoid (*release_watch)(struct watch *);",
            "",
            "\t\t\tspin_lock(&wlist->lock);",
            "",
            "\t\t\trelease = !hlist_unhashed(&watch->list_node);",
            "\t\t\tif (release) {",
            "\t\t\t\thlist_del_init_rcu(&watch->list_node);",
            "\t\t\t\trcu_assign_pointer(watch->watch_list, NULL);",
            "",
            "\t\t\t\t/* We now own a second ref on the watch. */",
            "\t\t\t}",
            "",
            "\t\t\trelease_watch = wlist->release_watch;",
            "\t\t\tspin_unlock(&wlist->lock);",
            "",
            "\t\t\tif (release) {",
            "\t\t\t\tif (release_watch) {",
            "\t\t\t\t\trcu_read_unlock();",
            "\t\t\t\t\t/* This might need to call dput(), so",
            "\t\t\t\t\t * we have to drop all the locks.",
            "\t\t\t\t\t */",
            "\t\t\t\t\t(*release_watch)(watch);",
            "\t\t\t\t\trcu_read_lock();",
            "\t\t\t\t}",
            "\t\t\t\tput_watch(watch);",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tput_watch(watch);",
            "\t\tspin_lock_bh(&wqueue->lock);",
            "\t}",
            "",
            "\tspin_unlock_bh(&wqueue->lock);",
            "\trcu_read_unlock();",
            "}",
            "int watch_queue_init(struct pipe_inode_info *pipe)",
            "{",
            "\tstruct watch_queue *wqueue;",
            "",
            "\twqueue = kzalloc(sizeof(*wqueue), GFP_KERNEL);",
            "\tif (!wqueue)",
            "\t\treturn -ENOMEM;",
            "",
            "\twqueue->pipe = pipe;",
            "\tkref_init(&wqueue->usage);",
            "\tspin_lock_init(&wqueue->lock);",
            "\tINIT_HLIST_HEAD(&wqueue->watches);",
            "",
            "\tpipe->watch_queue = wqueue;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "watch_queue_clear, watch_queue_init",
          "description": "该代码实现了监视队列的初始化与清理功能。  \n`watch_queue_clear`通过RCU和自旋锁机制安全地移除所有监视项并释放资源，`watch_queue_init`初始化监视队列结构并绑定至管道对象。  \n上下文不完整：`release_watch`等关键函数依赖外部定义，部分RCU回调逻辑未完全展示。",
          "similarity": 0.5181819200515747
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/watch_queue.c",
          "start_line": 193,
          "end_line": 304,
          "content": [
            "void __post_watch_notification(struct watch_list *wlist,",
            "\t\t\t       struct watch_notification *n,",
            "\t\t\t       const struct cred *cred,",
            "\t\t\t       u64 id)",
            "{",
            "\tconst struct watch_filter *wf;",
            "\tstruct watch_queue *wqueue;",
            "\tstruct watch *watch;",
            "",
            "\tif (((n->info & WATCH_INFO_LENGTH) >> WATCH_INFO_LENGTH__SHIFT) == 0) {",
            "\t\tWARN_ON(1);",
            "\t\treturn;",
            "\t}",
            "",
            "\trcu_read_lock();",
            "",
            "\thlist_for_each_entry_rcu(watch, &wlist->watchers, list_node) {",
            "\t\tif (watch->id != id)",
            "\t\t\tcontinue;",
            "\t\tn->info &= ~WATCH_INFO_ID;",
            "\t\tn->info |= watch->info_id;",
            "",
            "\t\twqueue = rcu_dereference(watch->queue);",
            "\t\twf = rcu_dereference(wqueue->filter);",
            "\t\tif (wf && !filter_watch_notification(wf, n))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (security_post_notification(watch->cred, cred, n) < 0)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (lock_wqueue(wqueue)) {",
            "\t\t\tpost_one_notification(wqueue, n);",
            "\t\t\tunlock_wqueue(wqueue);",
            "\t\t}",
            "\t}",
            "",
            "\trcu_read_unlock();",
            "}",
            "long watch_queue_set_size(struct pipe_inode_info *pipe, unsigned int nr_notes)",
            "{",
            "\tstruct watch_queue *wqueue = pipe->watch_queue;",
            "\tstruct page **pages;",
            "\tunsigned long *bitmap;",
            "\tunsigned long user_bufs;",
            "\tint ret, i, nr_pages;",
            "",
            "\tif (!wqueue)",
            "\t\treturn -ENODEV;",
            "\tif (wqueue->notes)",
            "\t\treturn -EBUSY;",
            "",
            "\tif (nr_notes < 1 ||",
            "\t    nr_notes > 512) /* TODO: choose a better hard limit */",
            "\t\treturn -EINVAL;",
            "",
            "\tnr_pages = (nr_notes + WATCH_QUEUE_NOTES_PER_PAGE - 1);",
            "\tnr_pages /= WATCH_QUEUE_NOTES_PER_PAGE;",
            "\tuser_bufs = account_pipe_buffers(pipe->user, pipe->nr_accounted, nr_pages);",
            "",
            "\tif (nr_pages > pipe->max_usage &&",
            "\t    (too_many_pipe_buffers_hard(user_bufs) ||",
            "\t     too_many_pipe_buffers_soft(user_bufs)) &&",
            "\t    pipe_is_unprivileged_user()) {",
            "\t\tret = -EPERM;",
            "\t\tgoto error;",
            "\t}",
            "",
            "\tnr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;",
            "\tret = pipe_resize_ring(pipe, roundup_pow_of_two(nr_notes));",
            "\tif (ret < 0)",
            "\t\tgoto error;",
            "",
            "\t/*",
            "\t * pipe_resize_ring() does not update nr_accounted for watch_queue",
            "\t * pipes, because the above vastly overprovisions. Set nr_accounted on",
            "\t * and max_usage this pipe to the number that was actually charged to",
            "\t * the user above via account_pipe_buffers.",
            "\t */",
            "\tpipe->max_usage = nr_pages;",
            "\tpipe->nr_accounted = nr_pages;",
            "",
            "\tret = -ENOMEM;",
            "\tpages = kcalloc(sizeof(struct page *), nr_pages, GFP_KERNEL);",
            "\tif (!pages)",
            "\t\tgoto error;",
            "",
            "\tfor (i = 0; i < nr_pages; i++) {",
            "\t\tpages[i] = alloc_page(GFP_KERNEL);",
            "\t\tif (!pages[i])",
            "\t\t\tgoto error_p;",
            "\t\tpages[i]->index = i * WATCH_QUEUE_NOTES_PER_PAGE;",
            "\t}",
            "",
            "\tbitmap = bitmap_alloc(nr_notes, GFP_KERNEL);",
            "\tif (!bitmap)",
            "\t\tgoto error_p;",
            "",
            "\tbitmap_fill(bitmap, nr_notes);",
            "\twqueue->notes = pages;",
            "\twqueue->notes_bitmap = bitmap;",
            "\twqueue->nr_pages = nr_pages;",
            "\twqueue->nr_notes = nr_notes;",
            "\treturn 0;",
            "",
            "error_p:",
            "\twhile (--i >= 0)",
            "\t\t__free_page(pages[i]);",
            "\tkfree(pages);",
            "error:",
            "\t(void) account_pipe_buffers(pipe->user, nr_pages, pipe->nr_accounted);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__post_watch_notification, watch_queue_set_size",
          "description": "__post_watch_notification遍历watch列表并应用过滤器后提交通知，watch_queue_set_size动态调整管道容量，通过计算所需页数和位图分配，限制最大容量为512个笔记，支持扩展性需求。",
          "similarity": 0.4946327209472656
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/watch_queue.c",
          "start_line": 315,
          "end_line": 422,
          "content": [
            "long watch_queue_set_filter(struct pipe_inode_info *pipe,",
            "\t\t\t    struct watch_notification_filter __user *_filter)",
            "{",
            "\tstruct watch_notification_type_filter *tf;",
            "\tstruct watch_notification_filter filter;",
            "\tstruct watch_type_filter *q;",
            "\tstruct watch_filter *wfilter;",
            "\tstruct watch_queue *wqueue = pipe->watch_queue;",
            "\tint ret, nr_filter = 0, i;",
            "",
            "\tif (!wqueue)",
            "\t\treturn -ENODEV;",
            "",
            "\tif (!_filter) {",
            "\t\t/* Remove the old filter */",
            "\t\twfilter = NULL;",
            "\t\tgoto set;",
            "\t}",
            "",
            "\t/* Grab the user's filter specification */",
            "\tif (copy_from_user(&filter, _filter, sizeof(filter)) != 0)",
            "\t\treturn -EFAULT;",
            "\tif (filter.nr_filters == 0 ||",
            "\t    filter.nr_filters > 16 ||",
            "\t    filter.__reserved != 0)",
            "\t\treturn -EINVAL;",
            "",
            "\ttf = memdup_array_user(_filter->filters, filter.nr_filters, sizeof(*tf));",
            "\tif (IS_ERR(tf))",
            "\t\treturn PTR_ERR(tf);",
            "",
            "\tret = -EINVAL;",
            "\tfor (i = 0; i < filter.nr_filters; i++) {",
            "\t\tif ((tf[i].info_filter & ~tf[i].info_mask) ||",
            "\t\t    tf[i].info_mask & WATCH_INFO_LENGTH)",
            "\t\t\tgoto err_filter;",
            "\t\t/* Ignore any unknown types */",
            "\t\tif (tf[i].type >= WATCH_TYPE__NR)",
            "\t\t\tcontinue;",
            "\t\tnr_filter++;",
            "\t}",
            "",
            "\t/* Now we need to build the internal filter from only the relevant",
            "\t * user-specified filters.",
            "\t */",
            "\tret = -ENOMEM;",
            "\twfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);",
            "\tif (!wfilter)",
            "\t\tgoto err_filter;",
            "\twfilter->nr_filters = nr_filter;",
            "",
            "\tq = wfilter->filters;",
            "\tfor (i = 0; i < filter.nr_filters; i++) {",
            "\t\tif (tf[i].type >= WATCH_TYPE__NR)",
            "\t\t\tcontinue;",
            "",
            "\t\tq->type\t\t\t= tf[i].type;",
            "\t\tq->info_filter\t\t= tf[i].info_filter;",
            "\t\tq->info_mask\t\t= tf[i].info_mask;",
            "\t\tq->subtype_filter[0]\t= tf[i].subtype_filter[0];",
            "\t\t__set_bit(q->type, wfilter->type_filter);",
            "\t\tq++;",
            "\t}",
            "",
            "\tkfree(tf);",
            "set:",
            "\tpipe_lock(pipe);",
            "\twfilter = rcu_replace_pointer(wqueue->filter, wfilter,",
            "\t\t\t\t      lockdep_is_held(&pipe->mutex));",
            "\tpipe_unlock(pipe);",
            "\tif (wfilter)",
            "\t\tkfree_rcu(wfilter, rcu);",
            "\treturn 0;",
            "",
            "err_filter:",
            "\tkfree(tf);",
            "\treturn ret;",
            "}",
            "static void __put_watch_queue(struct kref *kref)",
            "{",
            "\tstruct watch_queue *wqueue =",
            "\t\tcontainer_of(kref, struct watch_queue, usage);",
            "\tstruct watch_filter *wfilter;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < wqueue->nr_pages; i++)",
            "\t\t__free_page(wqueue->notes[i]);",
            "\tkfree(wqueue->notes);",
            "\tbitmap_free(wqueue->notes_bitmap);",
            "",
            "\twfilter = rcu_access_pointer(wqueue->filter);",
            "\tif (wfilter)",
            "\t\tkfree_rcu(wfilter, rcu);",
            "\tkfree_rcu(wqueue, rcu);",
            "}",
            "void put_watch_queue(struct watch_queue *wqueue)",
            "{",
            "\tkref_put(&wqueue->usage, __put_watch_queue);",
            "}",
            "static void free_watch(struct rcu_head *rcu)",
            "{",
            "\tstruct watch *watch = container_of(rcu, struct watch, rcu);",
            "",
            "\tput_watch_queue(rcu_access_pointer(watch->queue));",
            "\tatomic_dec(&watch->cred->user->nr_watches);",
            "\tput_cred(watch->cred);",
            "\tkfree(watch);",
            "}"
          ],
          "function_name": "watch_queue_set_filter, __put_watch_queue, put_watch_queue, free_watch",
          "description": "watch_queue_set_filter设置过滤规则并转换为内核内部结构，__put_watch_queue释放watch_queue相关资源包括页面、位图和过滤器，put_watch_queue通过引用计数管理watch_queue生命周期，free_watch执行RCU回调完成最终释放。",
          "similarity": 0.4848463237285614
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/watch_queue.c",
          "start_line": 432,
          "end_line": 556,
          "content": [
            "static void __put_watch(struct kref *kref)",
            "{",
            "\tstruct watch *watch = container_of(kref, struct watch, usage);",
            "",
            "\tcall_rcu(&watch->rcu, free_watch);",
            "}",
            "static void put_watch(struct watch *watch)",
            "{",
            "\tkref_put(&watch->usage, __put_watch);",
            "}",
            "void init_watch(struct watch *watch, struct watch_queue *wqueue)",
            "{",
            "\tkref_init(&watch->usage);",
            "\tINIT_HLIST_NODE(&watch->list_node);",
            "\tINIT_HLIST_NODE(&watch->queue_node);",
            "\trcu_assign_pointer(watch->queue, wqueue);",
            "}",
            "static int add_one_watch(struct watch *watch, struct watch_list *wlist, struct watch_queue *wqueue)",
            "{",
            "\tconst struct cred *cred;",
            "\tstruct watch *w;",
            "",
            "\thlist_for_each_entry(w, &wlist->watchers, list_node) {",
            "\t\tstruct watch_queue *wq = rcu_access_pointer(w->queue);",
            "\t\tif (wqueue == wq && watch->id == w->id)",
            "\t\t\treturn -EBUSY;",
            "\t}",
            "",
            "\tcred = current_cred();",
            "\tif (atomic_inc_return(&cred->user->nr_watches) > task_rlimit(current, RLIMIT_NOFILE)) {",
            "\t\tatomic_dec(&cred->user->nr_watches);",
            "\t\treturn -EAGAIN;",
            "\t}",
            "",
            "\twatch->cred = get_cred(cred);",
            "\trcu_assign_pointer(watch->watch_list, wlist);",
            "",
            "\tkref_get(&wqueue->usage);",
            "\tkref_get(&watch->usage);",
            "\thlist_add_head(&watch->queue_node, &wqueue->watches);",
            "\thlist_add_head_rcu(&watch->list_node, &wlist->watchers);",
            "\treturn 0;",
            "}",
            "int add_watch_to_object(struct watch *watch, struct watch_list *wlist)",
            "{",
            "\tstruct watch_queue *wqueue;",
            "\tint ret = -ENOENT;",
            "",
            "\trcu_read_lock();",
            "",
            "\twqueue = rcu_access_pointer(watch->queue);",
            "\tif (lock_wqueue(wqueue)) {",
            "\t\tspin_lock(&wlist->lock);",
            "\t\tret = add_one_watch(watch, wlist, wqueue);",
            "\t\tspin_unlock(&wlist->lock);",
            "\t\tunlock_wqueue(wqueue);",
            "\t}",
            "",
            "\trcu_read_unlock();",
            "\treturn ret;",
            "}",
            "int remove_watch_from_object(struct watch_list *wlist, struct watch_queue *wq,",
            "\t\t\t     u64 id, bool all)",
            "{",
            "\tstruct watch_notification_removal n;",
            "\tstruct watch_queue *wqueue;",
            "\tstruct watch *watch;",
            "\tint ret = -EBADSLT;",
            "",
            "\trcu_read_lock();",
            "",
            "again:",
            "\tspin_lock(&wlist->lock);",
            "\thlist_for_each_entry(watch, &wlist->watchers, list_node) {",
            "\t\tif (all ||",
            "\t\t    (watch->id == id && rcu_access_pointer(watch->queue) == wq))",
            "\t\t\tgoto found;",
            "\t}",
            "\tspin_unlock(&wlist->lock);",
            "\tgoto out;",
            "",
            "found:",
            "\tret = 0;",
            "\thlist_del_init_rcu(&watch->list_node);",
            "\trcu_assign_pointer(watch->watch_list, NULL);",
            "\tspin_unlock(&wlist->lock);",
            "",
            "\t/* We now own the reference on watch that used to belong to wlist. */",
            "",
            "\tn.watch.type = WATCH_TYPE_META;",
            "\tn.watch.subtype = WATCH_META_REMOVAL_NOTIFICATION;",
            "\tn.watch.info = watch->info_id | watch_sizeof(n.watch);",
            "\tn.id = id;",
            "\tif (id != 0)",
            "\t\tn.watch.info = watch->info_id | watch_sizeof(n);",
            "",
            "\twqueue = rcu_dereference(watch->queue);",
            "",
            "\tif (lock_wqueue(wqueue)) {",
            "\t\tpost_one_notification(wqueue, &n.watch);",
            "",
            "\t\tif (!hlist_unhashed(&watch->queue_node)) {",
            "\t\t\thlist_del_init_rcu(&watch->queue_node);",
            "\t\t\tput_watch(watch);",
            "\t\t}",
            "",
            "\t\tunlock_wqueue(wqueue);",
            "\t}",
            "",
            "\tif (wlist->release_watch) {",
            "\t\tvoid (*release_watch)(struct watch *);",
            "",
            "\t\trelease_watch = wlist->release_watch;",
            "\t\trcu_read_unlock();",
            "\t\t(*release_watch)(watch);",
            "\t\trcu_read_lock();",
            "\t}",
            "\tput_watch(watch);",
            "",
            "\tif (all && !hlist_empty(&wlist->watchers))",
            "\t\tgoto again;",
            "out:",
            "\trcu_read_unlock();",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__put_watch, put_watch, init_watch, add_one_watch, add_watch_to_object, remove_watch_from_object",
          "description": "__put_watch通过RCU回调释放watch对象，init_watch初始化watch结构并绑定至watch_queue，add_one_watch将watch加入列表并增加引用计数，remove_watch_from_object安全移除watch并触发移除通知，维护watch列表的并发一致性。",
          "similarity": 0.45323050022125244
        }
      ]
    }
  ]
}