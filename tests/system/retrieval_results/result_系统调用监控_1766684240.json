{
  "query": "系统调用监控",
  "timestamp": "2025-12-26 01:37:20",
  "retrieved_files": [
    {
      "source_file": "kernel/entry/syscall_user_dispatch.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:20:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `entry\\syscall_user_dispatch.c`\n\n---\n\n# entry/syscall_user_dispatch.c 技术文档\n\n## 1. 文件概述\n\n`entry/syscall_user_dispatch.c` 实现了 **系统调用用户分发（Syscall User Dispatch, SUD）** 机制，该机制允许用户空间程序通过 `prctl()` 系统调用配置一个“选择器”（selector），用于在特定条件下拦截或允许系统调用的执行。当系统调用指令指针位于指定区域之外且选择器状态为“阻塞”时，内核会回滚该系统调用并向进程发送 `SIGSYS` 信号，从而实现对系统调用的细粒度控制。此功能常用于沙箱、安全监控或调试场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `trigger_sigsys(struct pt_regs *regs)`  \n  构造并强制发送 `SIGSYS` 信号，携带被拦截系统调用的详细信息（如地址、系统调用号、架构等）。\n\n- `syscall_user_dispatch(struct pt_regs *regs)`  \n  系统调用入口处的分发判断逻辑。根据当前指令指针位置和用户选择器状态决定是否拦截系统调用。\n\n- `task_set_syscall_user_dispatch(struct task_struct *task, ...)`  \n  为指定任务设置系统调用用户分发配置（开启/关闭、偏移、长度、选择器地址）。\n\n- `set_syscall_user_dispatch(...)`  \n  为当前任务设置系统调用用户分发配置的封装接口，供 `prctl()` 调用。\n\n- `syscall_user_dispatch_get_config(...)`  \n  通过 `ptrace` 获取指定任务的 SUD 配置。\n\n- `syscall_user_dispatch_set_config(...)`  \n  通过 `ptrace` 设置指定任务的 SUD 配置。\n\n### 关键数据结构\n\n- `struct syscall_user_dispatch`（定义在 `<linux/syscall_user_dispatch.h>`）  \n  存储每个任务的 SUD 配置：\n  - `selector`：指向用户空间选择器字节的指针\n  - `offset` / `len`：允许直接执行系统调用的代码区域（[offset, offset+len)）\n  - `on_dispatch`：标志位，表示当前是否处于分发拦截状态\n\n- `struct ptrace_sud_config`  \n  用于 `ptrace` 接口传递 SUD 配置的结构体，包含 `mode`、`offset`、`len` 和 `selector`。\n\n## 3. 关键实现\n\n### 系统调用拦截逻辑\n\n1. **区域检查**：若当前指令指针（`instruction_pointer(regs)`）落在 `[offset, offset + len)` 范围内，则**允许**系统调用直接执行，不进行拦截。\n2. **vdso 例外**：若系统调用来自 vDSO 中的 `sigreturn`（如 `arch_syscall_is_vdso_sigreturn()` 返回 true），则跳过拦截，避免干扰信号返回路径。\n3. **选择器读取**：若配置了 `selector`，则从用户空间读取一个字节的状态值：\n   - `SYSCALL_DISPATCH_FILTER_ALLOW`（0）：允许系统调用\n   - `SYSCALL_DISPATCH_FILTER_BLOCK`（1）：触发拦截\n   - 其他值：视为非法，发送 `SIGSYS`\n4. **拦截处理**：\n   - 设置 `on_dispatch = true`\n   - 调用 `syscall_rollback()` 回滚系统调用（恢复寄存器状态）\n   - 调用 `trigger_sigsys()` 发送 `SIGSYS` 信号\n\n### 安全与健壮性设计\n\n- **地址合法性校验**：在设置 `selector` 时使用 `access_ok(untagged_addr(selector), ...)`，确保地址可访问，并处理内存标记（如 ARM MTE）场景下调试器（tracer）与被调试进程（tracee）地址标记不一致的问题。\n- **溢出防护**：检查 `offset + len <= offset` 防止整数溢出导致无效区域。\n- **权限隔离**：`ptrace` 接口允许调试器配置其他进程的 SUD，但需具备相应权限。\n\n### 信号信息构造\n\n`trigger_sigsys()` 构造的 `siginfo_t` 包含：\n- `si_signo = SIGSYS`\n- `si_code = SYS_USER_DISPATCH`\n- `si_call_addr`：触发系统调用的用户空间地址\n- `si_syscall`：系统调用号\n- `si_arch`：系统调用架构（如 x86_64、AArch64）\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/prctl.h>`：定义 `PR_SYS_DISPATCH_*` 常量\n  - `<linux/syscall_user_dispatch.h>`：定义 `struct syscall_user_dispatch` 和相关常量\n  - `<asm/syscall.h>`：提供 `syscall_get_arch()`、`syscall_get_nr()` 等架构相关接口\n  - `\"common.h\"`：可能包含内核入口通用辅助函数\n- **内核子系统**：\n  - **调度器（sched）**：访问 `current` 任务结构\n  - **信号子系统（signal）**：发送 `SIGSYS` 信号\n  - **内存管理（uaccess）**：用户空间内存访问（`__get_user`, `access_ok`）\n  - **ptrace**：支持调试器配置 SUD\n  - **ELF**：可能用于架构识别（间接依赖）\n\n## 5. 使用场景\n\n- **沙箱环境**：限制应用只能在特定代码段发起系统调用，防止恶意代码绕过安全策略。\n- **动态二进制插桩（DBI）**：工具（如 Valgrind、Intel Pin）可拦截系统调用进行分析或重定向。\n- **安全监控**：监控程序可配置选择器为“阻塞”，在 `SIGSYS` 信号处理程序中记录或审查系统调用。\n- **调试与测试**：通过 `ptrace` 动态启用/禁用 SUD，用于测试系统调用拦截逻辑。\n- **W^X 策略增强**：结合代码段只读与 SUD，确保只有可信代码路径可发起系统调用。",
      "similarity": 0.6304888725280762,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 20,
          "end_line": 122,
          "content": [
            "static void trigger_sigsys(struct pt_regs *regs)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGSYS;",
            "\tinfo.si_code = SYS_USER_DISPATCH;",
            "\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_arch = syscall_get_arch(current);",
            "\tinfo.si_syscall = syscall_get_nr(current, regs);",
            "",
            "\tforce_sig_info(&info);",
            "}",
            "bool syscall_user_dispatch(struct pt_regs *regs)",
            "{",
            "\tstruct syscall_user_dispatch *sd = &current->syscall_dispatch;",
            "\tchar state;",
            "",
            "\tif (likely(instruction_pointer(regs) - sd->offset < sd->len))",
            "\t\treturn false;",
            "",
            "\tif (unlikely(arch_syscall_is_vdso_sigreturn(regs)))",
            "\t\treturn false;",
            "",
            "\tif (likely(sd->selector)) {",
            "\t\t/*",
            "\t\t * access_ok() is performed once, at prctl time, when",
            "\t\t * the selector is loaded by userspace.",
            "\t\t */",
            "\t\tif (unlikely(__get_user(state, sd->selector))) {",
            "\t\t\tforce_exit_sig(SIGSEGV);",
            "\t\t\treturn true;",
            "\t\t}",
            "",
            "\t\tif (likely(state == SYSCALL_DISPATCH_FILTER_ALLOW))",
            "\t\t\treturn false;",
            "",
            "\t\tif (state != SYSCALL_DISPATCH_FILTER_BLOCK) {",
            "\t\t\tforce_exit_sig(SIGSYS);",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\tsd->on_dispatch = true;",
            "\tsyscall_rollback(current, regs);",
            "\ttrigger_sigsys(regs);",
            "",
            "\treturn true;",
            "}",
            "static int task_set_syscall_user_dispatch(struct task_struct *task, unsigned long mode,",
            "\t\t\t\t\t  unsigned long offset, unsigned long len,",
            "\t\t\t\t\t  char __user *selector)",
            "{",
            "\tswitch (mode) {",
            "\tcase PR_SYS_DISPATCH_OFF:",
            "\t\tif (offset || len || selector)",
            "\t\t\treturn -EINVAL;",
            "\t\tbreak;",
            "\tcase PR_SYS_DISPATCH_ON:",
            "\t\t/*",
            "\t\t * Validate the direct dispatcher region just for basic",
            "\t\t * sanity against overflow and a 0-sized dispatcher",
            "\t\t * region.  If the user is able to submit a syscall from",
            "\t\t * an address, that address is obviously valid.",
            "\t\t */",
            "\t\tif (offset && offset + len <= offset)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\t/*",
            "\t\t * access_ok() will clear memory tags for tagged addresses",
            "\t\t * if current has memory tagging enabled.",
            "",
            "\t\t * To enable a tracer to set a tracees selector the",
            "\t\t * selector address must be untagged for access_ok(),",
            "\t\t * otherwise an untagged tracer will always fail to set a",
            "\t\t * tagged tracees selector.",
            "\t\t */",
            "\t\tif (selector && !access_ok(untagged_addr(selector), sizeof(*selector)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttask->syscall_dispatch.selector = selector;",
            "\ttask->syscall_dispatch.offset = offset;",
            "\ttask->syscall_dispatch.len = len;",
            "\ttask->syscall_dispatch.on_dispatch = false;",
            "",
            "\tif (mode == PR_SYS_DISPATCH_ON)",
            "\t\tset_task_syscall_work(task, SYSCALL_USER_DISPATCH);",
            "\telse",
            "\t\tclear_task_syscall_work(task, SYSCALL_USER_DISPATCH);",
            "",
            "\treturn 0;",
            "}",
            "int set_syscall_user_dispatch(unsigned long mode, unsigned long offset,",
            "\t\t\t      unsigned long len, char __user *selector)",
            "{",
            "\treturn task_set_syscall_user_dispatch(current, mode, offset, len, selector);",
            "}"
          ],
          "function_name": "trigger_sigsys, syscall_user_dispatch, task_set_syscall_user_dispatch, set_syscall_user_dispatch",
          "description": "实现系统调用用户分发核心逻辑，包含触发SIGSYS信号处理、配置验证、拦截判断及模式切换功能",
          "similarity": 0.6653319597244263
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 127,
          "end_line": 163,
          "content": [
            "int syscall_user_dispatch_get_config(struct task_struct *task, unsigned long size,",
            "\t\t\t\t     void __user *data)",
            "{",
            "\tstruct syscall_user_dispatch *sd = &task->syscall_dispatch;",
            "\tstruct ptrace_sud_config cfg;",
            "",
            "\tif (size != sizeof(cfg))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (test_task_syscall_work(task, SYSCALL_USER_DISPATCH))",
            "\t\tcfg.mode = PR_SYS_DISPATCH_ON;",
            "\telse",
            "\t\tcfg.mode = PR_SYS_DISPATCH_OFF;",
            "",
            "\tcfg.offset = sd->offset;",
            "\tcfg.len = sd->len;",
            "\tcfg.selector = (__u64)(uintptr_t)sd->selector;",
            "",
            "\tif (copy_to_user(data, &cfg, sizeof(cfg)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn 0;",
            "}",
            "int syscall_user_dispatch_set_config(struct task_struct *task, unsigned long size,",
            "\t\t\t\t     void __user *data)",
            "{",
            "\tstruct ptrace_sud_config cfg;",
            "",
            "\tif (size != sizeof(cfg))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (copy_from_user(&cfg, data, sizeof(cfg)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn task_set_syscall_user_dispatch(task, cfg.mode, cfg.offset, cfg.len,",
            "\t\t\t\t\t      (char __user *)(uintptr_t)cfg.selector);",
            "}"
          ],
          "function_name": "syscall_user_dispatch_get_config, syscall_user_dispatch_set_config",
          "description": "提供系统调用分发配置的获取与设置接口，通过用户态指针操作实现配置参数的双向传递",
          "similarity": 0.6401383280754089
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2020 Collabora Ltd.",
            " */",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscall_user_dispatch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/signal.h>",
            "#include <linux/elf.h>",
            "",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task_stack.h>",
            "",
            "#include <asm/syscall.h>",
            "",
            "#include \"common.h\"",
            ""
          ],
          "function_name": null,
          "description": "包含系统调用用户分发功能所需头文件及通用定义，提供架构相关接口和内核调度必要声明",
          "similarity": 0.5756065845489502
        }
      ]
    },
    {
      "source_file": "kernel/ptrace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:37:14\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `ptrace.c`\n\n---\n\n# ptrace.c 技术文档\n\n## 1. 文件概述\n\n`ptrace.c` 是 Linux 内核中实现 **ptrace**（进程跟踪）机制的核心通用代码文件。该文件提供了跨架构的 ptrace 公共接口和基础功能，避免在每个体系结构中重复实现相同逻辑。ptrace 机制允许一个进程（tracer，通常是调试器）观察和控制另一个进程（tracee）的执行，包括读写其内存、寄存器状态、拦截系统调用等，是调试器（如 GDB）、系统调用追踪工具（如 strace）和安全监控工具的基础。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`ptrace_access_vm()`**  \n  安全地访问被跟踪进程（tracee）的虚拟内存空间，用于读写其内存内容。\n\n- **`__ptrace_link()`**  \n  将被跟踪进程链接到跟踪进程（tracer）的 `ptraced` 链表中，并设置其父进程为 tracer。\n\n- **`ptrace_link()`**  \n  封装 `__ptrace_link()`，使用当前进程的凭证建立跟踪关系。\n\n- **`__ptrace_unlink()`**  \n  解除跟踪关系：将被跟踪进程从 tracer 的链表中移除，恢复其原始父进程，并根据进程组停止状态调整其任务状态（如从 `TASK_TRACED` 转为 `TASK_STOPPED` 或唤醒）。\n\n- **`ptrace_freeze_traced()`** / **`ptrace_unfreeze_traced()`**  \n  在执行 ptrace 操作期间临时冻结被跟踪进程，防止其被意外唤醒（即使是 SIGKILL），确保操作的原子性和一致性。\n\n- **`ptrace_check_attach()`**  \n  验证当前进程是否有权对目标进程执行 ptrace 操作，并确保目标进程处于合适的跟踪状态（可选）。\n\n- **`looks_like_a_spurious_pid()`**  \n  辅助函数，用于检测因线程组 leader 更换（如 `de_thread()`）导致的“虚假”ptrace 事件，避免对已销毁进程的误操作。\n\n### 关键数据结构字段（在 `task_struct` 中）\n\n- `ptrace`：标志位，表示进程是否被跟踪。\n- `parent` / `real_parent`：分别表示当前父进程（通常是 tracer）和原始父进程。\n- `ptraced`：链表头，包含所有被当前进程跟踪的子进程。\n- `ptrace_entry`：链表节点，用于加入 tracer 的 `ptraced` 链表。\n- `ptracer_cred`：跟踪进程的凭证（credentials），用于权限检查。\n- `jobctl`：任务控制标志，包含 `JOBCTL_PTRACE_FROZEN`、`JOBCTL_TRACED`、`JOBCTL_STOP_PENDING` 等 ptrace 相关状态。\n\n## 3. 关键实现\n\n### 安全内存访问 (`ptrace_access_vm`)\n- 通过 `get_task_mm()` 获取目标进程的内存描述符 `mm_struct`。\n- 执行严格的权限检查：\n  - 目标进程必须正在被跟踪（`tsk->ptrace` 非零）。\n  - 当前进程必须是目标进程的直接父进程（`current == tsk->parent`）。\n  - 或者当前进程在目标进程的用户命名空间中具有 `CAP_SYS_PTRACE` 能力（通过 `ptracer_capable()` 检查）。\n- 使用 `__access_remote_vm()` 安全地读写目标进程内存，避免直接遍历页表。\n\n### 跟踪关系管理\n- **链接**：`ptrace_link()` 在持有 `tasklist_lock` 写锁时调用 `__ptrace_link()`，将 tracee 加入 tracer 的 `ptraced` 链表，并保存 tracer 的凭证。\n- **解链接**：`__ptrace_unlink()` 在 detach 或 tracer 退出时调用：\n  - 清除 syscall trace/emu 标志。\n  - 恢复 `real_parent`。\n  - 清除 `ptrace` 标志和 jobctl 中的 trap 相关位。\n  - 根据进程组停止状态决定是否设置 `JOBCTL_STOP_PENDING` 并唤醒进程（`ptrace_signal_wake_up()`）。\n\n### 进程状态冻结机制\n- 在执行 ptrace 操作前调用 `ptrace_freeze_traced()`：\n  - 若 tracee 处于 `TASK_TRACED` 且无致命信号待处理，则设置 `JOBCTL_PTRACE_FROZEN` 标志，使其无法被唤醒。\n- 操作完成后调用 `ptrace_unfreeze_traced()`：\n  - 清除冻结标志。\n  - 若存在致命信号（如 SIGKILL），则清除 `JOBCTL_TRACED` 并唤醒进程以处理信号。\n\n### 权限与状态验证 (`ptrace_check_attach`)\n- 在 `tasklist_lock` 读锁保护下验证：\n  - 目标进程确由当前进程跟踪（`child->ptrace && child->parent == current`）。\n  - 若 `ignore_state=false`，则进一步冻结 tracee 以确保其处于稳定状态。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `task_struct`、`mm_struct`、`sighand_struct` 等核心数据结构，以及 `wake_up_state()`、`task_is_traced()` 等调度状态管理函数。\n- **内存管理**：通过 `get_task_mm()`、`mmput()` 和 `__access_remote_vm()` 访问远程进程内存。\n- **信号处理**：大量使用 `siglock`、`jobctl`、`signal_struct` 等信号相关机制管理进程状态转换。\n- **安全模块**：集成 LSM（Linux Security Module）钩子（`security_ptrace_access_check`）和能力检查（`capable()`）。\n- **审计与通知**：与 `audit` 和 `cn_proc`（进程事件连接器）交互，记录 ptrace 事件。\n- **体系结构相关代码**：依赖 `asm/syscall.h` 提供的 `syscall_get_*` 接口获取系统调用信息。\n- **硬件断点**：通过 `hw_breakpoint.h` 支持硬件断点调试功能。\n\n## 5. 使用场景\n\n- **调试器（如 GDB）**：attach 到目标进程，读取/修改寄存器和内存，设置断点，单步执行。\n- **系统调用追踪（如 strace）**：拦截并记录目标进程的所有系统调用及其参数和返回值。\n- **安全监控工具**：监控可疑进程的行为，如检测恶意代码注入或提权操作。\n- **容器与沙箱**：在用户命名空间中实现进程隔离和监控。\n- **内核测试**：用于内核自检和调试，验证进程行为和系统调用处理。\n- **进程注入与热补丁**：通过修改运行中进程的内存和寄存器状态实现代码注入或修复。",
      "similarity": 0.6150035262107849,
      "chunks": [
        {
          "chunk_id": 7,
          "file_path": "kernel/ptrace.c",
          "start_line": 967,
          "end_line": 1267,
          "content": [
            "static unsigned long",
            "ptrace_get_syscall_info_exit(struct task_struct *child, struct pt_regs *regs,",
            "\t\t\t     struct ptrace_syscall_info *info)",
            "{",
            "\tinfo->op = PTRACE_SYSCALL_INFO_EXIT;",
            "\tinfo->exit.rval = syscall_get_error(child, regs);",
            "\tinfo->exit.is_error = !!info->exit.rval;",
            "\tif (!info->exit.is_error)",
            "\t\tinfo->exit.rval = syscall_get_return_value(child, regs);",
            "",
            "\t/* is_error is the last field in struct ptrace_syscall_info.exit */",
            "\treturn offsetofend(struct ptrace_syscall_info, exit.is_error);",
            "}",
            "static int",
            "ptrace_get_syscall_info(struct task_struct *child, unsigned long user_size,",
            "\t\t\tvoid __user *datavp)",
            "{",
            "\tstruct pt_regs *regs = task_pt_regs(child);",
            "\tstruct ptrace_syscall_info info = {",
            "\t\t.op = PTRACE_SYSCALL_INFO_NONE,",
            "\t\t.arch = syscall_get_arch(child),",
            "\t\t.instruction_pointer = instruction_pointer(regs),",
            "\t\t.stack_pointer = user_stack_pointer(regs),",
            "\t};",
            "\tunsigned long actual_size = offsetof(struct ptrace_syscall_info, entry);",
            "\tunsigned long write_size;",
            "",
            "\t/*",
            "\t * This does not need lock_task_sighand() to access",
            "\t * child->last_siginfo because ptrace_freeze_traced()",
            "\t * called earlier by ptrace_check_attach() ensures that",
            "\t * the tracee cannot go away and clear its last_siginfo.",
            "\t */",
            "\tswitch (child->last_siginfo ? child->last_siginfo->si_code : 0) {",
            "\tcase SIGTRAP | 0x80:",
            "\t\tswitch (child->ptrace_message) {",
            "\t\tcase PTRACE_EVENTMSG_SYSCALL_ENTRY:",
            "\t\t\tactual_size = ptrace_get_syscall_info_entry(child, regs,",
            "\t\t\t\t\t\t\t\t    &info);",
            "\t\t\tbreak;",
            "\t\tcase PTRACE_EVENTMSG_SYSCALL_EXIT:",
            "\t\t\tactual_size = ptrace_get_syscall_info_exit(child, regs,",
            "\t\t\t\t\t\t\t\t   &info);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase SIGTRAP | (PTRACE_EVENT_SECCOMP << 8):",
            "\t\tactual_size = ptrace_get_syscall_info_seccomp(child, regs,",
            "\t\t\t\t\t\t\t      &info);",
            "\t\tbreak;",
            "\t}",
            "",
            "\twrite_size = min(actual_size, user_size);",
            "\treturn copy_to_user(datavp, &info, write_size) ? -EFAULT : actual_size;",
            "}",
            "int ptrace_request(struct task_struct *child, long request,",
            "\t\t   unsigned long addr, unsigned long data)",
            "{",
            "\tbool seized = child->ptrace & PT_SEIZED;",
            "\tint ret = -EIO;",
            "\tkernel_siginfo_t siginfo, *si;",
            "\tvoid __user *datavp = (void __user *) data;",
            "\tunsigned long __user *datalp = datavp;",
            "\tunsigned long flags;",
            "",
            "\tswitch (request) {",
            "\tcase PTRACE_PEEKTEXT:",
            "\tcase PTRACE_PEEKDATA:",
            "\t\treturn generic_ptrace_peekdata(child, addr, data);",
            "\tcase PTRACE_POKETEXT:",
            "\tcase PTRACE_POKEDATA:",
            "\t\treturn generic_ptrace_pokedata(child, addr, data);",
            "",
            "#ifdef PTRACE_OLDSETOPTIONS",
            "\tcase PTRACE_OLDSETOPTIONS:",
            "#endif",
            "\tcase PTRACE_SETOPTIONS:",
            "\t\tret = ptrace_setoptions(child, data);",
            "\t\tbreak;",
            "\tcase PTRACE_GETEVENTMSG:",
            "\t\tret = put_user(child->ptrace_message, datalp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_PEEKSIGINFO:",
            "\t\tret = ptrace_peek_siginfo(child, addr, data);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GETSIGINFO:",
            "\t\tret = ptrace_getsiginfo(child, &siginfo);",
            "\t\tif (!ret)",
            "\t\t\tret = copy_siginfo_to_user(datavp, &siginfo);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_SETSIGINFO:",
            "\t\tret = copy_siginfo_from_user(&siginfo, datavp);",
            "\t\tif (!ret)",
            "\t\t\tret = ptrace_setsiginfo(child, &siginfo);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GETSIGMASK: {",
            "\t\tsigset_t *mask;",
            "",
            "\t\tif (addr != sizeof(sigset_t)) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (test_tsk_restore_sigmask(child))",
            "\t\t\tmask = &child->saved_sigmask;",
            "\t\telse",
            "\t\t\tmask = &child->blocked;",
            "",
            "\t\tif (copy_to_user(datavp, mask, sizeof(sigset_t)))",
            "\t\t\tret = -EFAULT;",
            "\t\telse",
            "\t\t\tret = 0;",
            "",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_SETSIGMASK: {",
            "\t\tsigset_t new_set;",
            "",
            "\t\tif (addr != sizeof(sigset_t)) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (copy_from_user(&new_set, datavp, sizeof(sigset_t))) {",
            "\t\t\tret = -EFAULT;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));",
            "",
            "\t\t/*",
            "\t\t * Every thread does recalc_sigpending() after resume, so",
            "\t\t * retarget_shared_pending() and recalc_sigpending() are not",
            "\t\t * called here.",
            "\t\t */",
            "\t\tspin_lock_irq(&child->sighand->siglock);",
            "\t\tchild->blocked = new_set;",
            "\t\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\t\tclear_tsk_restore_sigmask(child);",
            "",
            "\t\tret = 0;",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_INTERRUPT:",
            "\t\t/*",
            "\t\t * Stop tracee without any side-effect on signal or job",
            "\t\t * control.  At least one trap is guaranteed to happen",
            "\t\t * after this request.  If @child is already trapped, the",
            "\t\t * current trap is not disturbed and another trap will",
            "\t\t * happen after the current trap is ended with PTRACE_CONT.",
            "\t\t *",
            "\t\t * The actual trap might not be PTRACE_EVENT_STOP trap but",
            "\t\t * the pending condition is cleared regardless.",
            "\t\t */",
            "\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * INTERRUPT doesn't disturb existing trap sans one",
            "\t\t * exception.  If ptracer issued LISTEN for the current",
            "\t\t * STOP, this INTERRUPT should clear LISTEN and re-trap",
            "\t\t * tracee into STOP.",
            "\t\t */",
            "\t\tif (likely(task_set_jobctl_pending(child, JOBCTL_TRAP_STOP)))",
            "\t\t\tptrace_signal_wake_up(child, child->jobctl & JOBCTL_LISTENING);",
            "",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t\tret = 0;",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_LISTEN:",
            "\t\t/*",
            "\t\t * Listen for events.  Tracee must be in STOP.  It's not",
            "\t\t * resumed per-se but is not considered to be in TRACED by",
            "\t\t * wait(2) or ptrace(2).  If an async event (e.g. group",
            "\t\t * stop state change) happens, tracee will enter STOP trap",
            "\t\t * again.  Alternatively, ptracer can issue INTERRUPT to",
            "\t\t * finish listening and re-trap tracee into STOP.",
            "\t\t */",
            "\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))",
            "\t\t\tbreak;",
            "",
            "\t\tsi = child->last_siginfo;",
            "\t\tif (likely(si && (si->si_code >> 8) == PTRACE_EVENT_STOP)) {",
            "\t\t\tchild->jobctl |= JOBCTL_LISTENING;",
            "\t\t\t/*",
            "\t\t\t * If NOTIFY is set, it means event happened between",
            "\t\t\t * start of this trap and now.  Trigger re-trap.",
            "\t\t\t */",
            "\t\t\tif (child->jobctl & JOBCTL_TRAP_NOTIFY)",
            "\t\t\t\tptrace_signal_wake_up(child, true);",
            "\t\t\tret = 0;",
            "\t\t}",
            "\t\tunlock_task_sighand(child, &flags);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_DETACH:\t /* detach a process that was attached. */",
            "\t\tret = ptrace_detach(child, data);",
            "\t\tbreak;",
            "",
            "#ifdef CONFIG_BINFMT_ELF_FDPIC",
            "\tcase PTRACE_GETFDPIC: {",
            "\t\tstruct mm_struct *mm = get_task_mm(child);",
            "\t\tunsigned long tmp = 0;",
            "",
            "\t\tret = -ESRCH;",
            "\t\tif (!mm)",
            "\t\t\tbreak;",
            "",
            "\t\tswitch (addr) {",
            "\t\tcase PTRACE_GETFDPIC_EXEC:",
            "\t\t\ttmp = mm->context.exec_fdpic_loadmap;",
            "\t\t\tbreak;",
            "\t\tcase PTRACE_GETFDPIC_INTERP:",
            "\t\t\ttmp = mm->context.interp_fdpic_loadmap;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tmmput(mm);",
            "",
            "\t\tret = put_user(tmp, datalp);",
            "\t\tbreak;",
            "\t}",
            "#endif",
            "",
            "\tcase PTRACE_SINGLESTEP:",
            "#ifdef PTRACE_SINGLEBLOCK",
            "\tcase PTRACE_SINGLEBLOCK:",
            "#endif",
            "#ifdef PTRACE_SYSEMU",
            "\tcase PTRACE_SYSEMU:",
            "\tcase PTRACE_SYSEMU_SINGLESTEP:",
            "#endif",
            "\tcase PTRACE_SYSCALL:",
            "\tcase PTRACE_CONT:",
            "\t\treturn ptrace_resume(child, request, data);",
            "",
            "\tcase PTRACE_KILL:",
            "\t\tsend_sig_info(SIGKILL, SEND_SIG_NOINFO, child);",
            "\t\treturn 0;",
            "",
            "#ifdef CONFIG_HAVE_ARCH_TRACEHOOK",
            "\tcase PTRACE_GETREGSET:",
            "\tcase PTRACE_SETREGSET: {",
            "\t\tstruct iovec kiov;",
            "\t\tstruct iovec __user *uiov = datavp;",
            "",
            "\t\tif (!access_ok(uiov, sizeof(*uiov)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tif (__get_user(kiov.iov_base, &uiov->iov_base) ||",
            "\t\t    __get_user(kiov.iov_len, &uiov->iov_len))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tret = ptrace_regset(child, request, addr, &kiov);",
            "\t\tif (!ret)",
            "\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tcase PTRACE_GET_SYSCALL_INFO:",
            "\t\tret = ptrace_get_syscall_info(child, addr, datavp);",
            "\t\tbreak;",
            "#endif",
            "",
            "\tcase PTRACE_SECCOMP_GET_FILTER:",
            "\t\tret = seccomp_get_filter(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_SECCOMP_GET_METADATA:",
            "\t\tret = seccomp_get_metadata(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "#ifdef CONFIG_RSEQ",
            "\tcase PTRACE_GET_RSEQ_CONFIGURATION:",
            "\t\tret = ptrace_get_rseq_configuration(child, addr, datavp);",
            "\t\tbreak;",
            "#endif",
            "",
            "\tcase PTRACE_SET_SYSCALL_USER_DISPATCH_CONFIG:",
            "\t\tret = syscall_user_dispatch_set_config(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tcase PTRACE_GET_SYSCALL_USER_DISPATCH_CONFIG:",
            "\t\tret = syscall_user_dispatch_get_config(child, addr, datavp);",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "ptrace_get_syscall_info_exit, ptrace_get_syscall_info, ptrace_request",
          "description": "ptrace_get_syscall_info根据进程最后信号信息构造系统调用详细数据结构；ptrace_request作为ptrace系统调用的核心分发函数，处理包括中断、继续执行、获取/设置信号掩码、获取系统调用信息等各类请求",
          "similarity": 0.6184260845184326
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/ptrace.c",
          "start_line": 806,
          "end_line": 922,
          "content": [
            "static long ptrace_get_rseq_configuration(struct task_struct *task,",
            "\t\t\t\t\t  unsigned long size, void __user *data)",
            "{",
            "\tstruct ptrace_rseq_configuration conf = {",
            "\t\t.rseq_abi_pointer = (u64)(uintptr_t)task->rseq,",
            "\t\t.rseq_abi_size = task->rseq_len,",
            "\t\t.signature = task->rseq_sig,",
            "\t\t.flags = 0,",
            "\t};",
            "",
            "\tsize = min_t(unsigned long, size, sizeof(conf));",
            "\tif (copy_to_user(data, &conf, size))",
            "\t\treturn -EFAULT;",
            "\treturn sizeof(conf);",
            "}",
            "static int ptrace_resume(struct task_struct *child, long request,",
            "\t\t\t unsigned long data)",
            "{",
            "\tif (!valid_signal(data))",
            "\t\treturn -EIO;",
            "",
            "\tif (request == PTRACE_SYSCALL)",
            "\t\tset_task_syscall_work(child, SYSCALL_TRACE);",
            "\telse",
            "\t\tclear_task_syscall_work(child, SYSCALL_TRACE);",
            "",
            "#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)",
            "\tif (request == PTRACE_SYSEMU || request == PTRACE_SYSEMU_SINGLESTEP)",
            "\t\tset_task_syscall_work(child, SYSCALL_EMU);",
            "\telse",
            "\t\tclear_task_syscall_work(child, SYSCALL_EMU);",
            "#endif",
            "",
            "\tif (is_singleblock(request)) {",
            "\t\tif (unlikely(!arch_has_block_step()))",
            "\t\t\treturn -EIO;",
            "\t\tuser_enable_block_step(child);",
            "\t} else if (is_singlestep(request) || is_sysemu_singlestep(request)) {",
            "\t\tif (unlikely(!arch_has_single_step()))",
            "\t\t\treturn -EIO;",
            "\t\tuser_enable_single_step(child);",
            "\t} else {",
            "\t\tuser_disable_single_step(child);",
            "\t}",
            "",
            "\t/*",
            "\t * Change ->exit_code and ->state under siglock to avoid the race",
            "\t * with wait_task_stopped() in between; a non-zero ->exit_code will",
            "\t * wrongly look like another report from tracee.",
            "\t *",
            "\t * Note that we need siglock even if ->exit_code == data and/or this",
            "\t * status was not reported yet, the new status must not be cleared by",
            "\t * wait_task_stopped() after resume.",
            "\t */",
            "\tspin_lock_irq(&child->sighand->siglock);",
            "\tchild->exit_code = data;",
            "\tchild->jobctl &= ~JOBCTL_TRACED;",
            "\twake_up_state(child, __TASK_TRACED);",
            "\tspin_unlock_irq(&child->sighand->siglock);",
            "",
            "\treturn 0;",
            "}",
            "static int ptrace_regset(struct task_struct *task, int req, unsigned int type,",
            "\t\t\t struct iovec *kiov)",
            "{",
            "\tconst struct user_regset_view *view = task_user_regset_view(task);",
            "\tconst struct user_regset *regset = find_regset(view, type);",
            "\tint regset_no;",
            "",
            "\tif (!regset || (kiov->iov_len % regset->size) != 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tregset_no = regset - view->regsets;",
            "\tkiov->iov_len = min(kiov->iov_len,",
            "\t\t\t    (__kernel_size_t) (regset->n * regset->size));",
            "",
            "\tif (req == PTRACE_GETREGSET)",
            "\t\treturn copy_regset_to_user(task, view, regset_no, 0,",
            "\t\t\t\t\t   kiov->iov_len, kiov->iov_base);",
            "\telse",
            "\t\treturn copy_regset_from_user(task, view, regset_no, 0,",
            "\t\t\t\t\t     kiov->iov_len, kiov->iov_base);",
            "}",
            "static unsigned long",
            "ptrace_get_syscall_info_entry(struct task_struct *child, struct pt_regs *regs,",
            "\t\t\t      struct ptrace_syscall_info *info)",
            "{",
            "\tunsigned long args[ARRAY_SIZE(info->entry.args)];",
            "\tint i;",
            "",
            "\tinfo->op = PTRACE_SYSCALL_INFO_ENTRY;",
            "\tinfo->entry.nr = syscall_get_nr(child, regs);",
            "\tsyscall_get_arguments(child, regs, args);",
            "\tfor (i = 0; i < ARRAY_SIZE(args); i++)",
            "\t\tinfo->entry.args[i] = args[i];",
            "",
            "\t/* args is the last field in struct ptrace_syscall_info.entry */",
            "\treturn offsetofend(struct ptrace_syscall_info, entry.args);",
            "}",
            "static unsigned long",
            "ptrace_get_syscall_info_seccomp(struct task_struct *child, struct pt_regs *regs,",
            "\t\t\t\tstruct ptrace_syscall_info *info)",
            "{",
            "\t/*",
            "\t * As struct ptrace_syscall_info.entry is currently a subset",
            "\t * of struct ptrace_syscall_info.seccomp, it makes sense to",
            "\t * initialize that subset using ptrace_get_syscall_info_entry().",
            "\t * This can be reconsidered in the future if these structures",
            "\t * diverge significantly enough.",
            "\t */",
            "\tptrace_get_syscall_info_entry(child, regs, info);",
            "\tinfo->op = PTRACE_SYSCALL_INFO_SECCOMP;",
            "\tinfo->seccomp.ret_data = child->ptrace_message;",
            "",
            "\t/* ret_data is the last field in struct ptrace_syscall_info.seccomp */",
            "\treturn offsetofend(struct ptrace_syscall_info, seccomp.ret_data);",
            "}"
          ],
          "function_name": "ptrace_get_rseq_configuration, ptrace_resume, ptrace_regset, ptrace_get_syscall_info_entry, ptrace_get_syscall_info_seccomp",
          "description": "ptrace_get_rseq_configuration获取RSEQ配置信息；ptrace_resume控制跟踪进程的恢复状态，包括系统调用跟踪、单步执行和信号处理；ptrace_regset处理用户寄存器集合的读写；ptrace_get_syscall_info_*系列函数构建系统调用相关信息结构体",
          "similarity": 0.6027841567993164
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/ptrace.c",
          "start_line": 44,
          "end_line": 148,
          "content": [
            "int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,",
            "\t\t     void *buf, int len, unsigned int gup_flags)",
            "{",
            "\tstruct mm_struct *mm;",
            "\tint ret;",
            "",
            "\tmm = get_task_mm(tsk);",
            "\tif (!mm)",
            "\t\treturn 0;",
            "",
            "\tif (!tsk->ptrace ||",
            "\t    (current != tsk->parent) ||",
            "\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&",
            "\t     !ptracer_capable(tsk, mm->user_ns))) {",
            "\t\tmmput(mm);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = __access_remote_vm(mm, addr, buf, len, gup_flags);",
            "\tmmput(mm);",
            "",
            "\treturn ret;",
            "}",
            "void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,",
            "\t\t   const struct cred *ptracer_cred)",
            "{",
            "\tBUG_ON(!list_empty(&child->ptrace_entry));",
            "\tlist_add(&child->ptrace_entry, &new_parent->ptraced);",
            "\tchild->parent = new_parent;",
            "\tchild->ptracer_cred = get_cred(ptracer_cred);",
            "}",
            "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)",
            "{",
            "\t__ptrace_link(child, new_parent, current_cred());",
            "}",
            "void __ptrace_unlink(struct task_struct *child)",
            "{",
            "\tconst struct cred *old_cred;",
            "\tBUG_ON(!child->ptrace);",
            "",
            "\tclear_task_syscall_work(child, SYSCALL_TRACE);",
            "#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)",
            "\tclear_task_syscall_work(child, SYSCALL_EMU);",
            "#endif",
            "",
            "\tchild->parent = child->real_parent;",
            "\tlist_del_init(&child->ptrace_entry);",
            "\told_cred = child->ptracer_cred;",
            "\tchild->ptracer_cred = NULL;",
            "\tput_cred(old_cred);",
            "",
            "\tspin_lock(&child->sighand->siglock);",
            "\tchild->ptrace = 0;",
            "\t/*",
            "\t * Clear all pending traps and TRAPPING.  TRAPPING should be",
            "\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.",
            "\t */",
            "\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);",
            "\ttask_clear_jobctl_trapping(child);",
            "",
            "\t/*",
            "\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and",
            "\t * @child isn't dead.",
            "\t */",
            "\tif (!(child->flags & PF_EXITING) &&",
            "\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||",
            "\t     child->signal->group_stop_count)) {",
            "\t\tchild->jobctl |= JOBCTL_STOP_PENDING;",
            "",
            "\t\t/*",
            "\t\t * This is only possible if this thread was cloned by the",
            "\t\t * traced task running in the stopped group, set the signal",
            "\t\t * for the future reports.",
            "\t\t * FIXME: we should change ptrace_init_task() to handle this",
            "\t\t * case.",
            "\t\t */",
            "\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))",
            "\t\t\tchild->jobctl |= SIGSTOP;",
            "\t}",
            "",
            "\t/*",
            "\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick",
            "\t * @child in the butt.  Note that @resume should be used iff @child",
            "\t * is in TASK_TRACED; otherwise, we might unduly disrupt",
            "\t * TASK_KILLABLE sleeps.",
            "\t */",
            "\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))",
            "\t\tptrace_signal_wake_up(child, true);",
            "",
            "\tspin_unlock(&child->sighand->siglock);",
            "}",
            "static bool looks_like_a_spurious_pid(struct task_struct *task)",
            "{",
            "\tif (task->exit_code != ((PTRACE_EVENT_EXEC << 8) | SIGTRAP))",
            "\t\treturn false;",
            "",
            "\tif (task_pid_vnr(task) == task->ptrace_message)",
            "\t\treturn false;",
            "\t/*",
            "\t * The tracee changed its pid but the PTRACE_EVENT_EXEC event",
            "\t * was not wait()'ed, most probably debugger targets the old",
            "\t * leader which was destroyed in de_thread().",
            "\t */",
            "\treturn true;",
            "}"
          ],
          "function_name": "ptrace_access_vm, __ptrace_link, ptrace_link, __ptrace_unlink, looks_like_a_spurious_pid",
          "description": "实现进程跟踪核心操作，包含访问目标进程地址空间、维护跟踪链表、解除跟踪关系及检测虚假PID逻辑，用于安全控制和状态同步。",
          "similarity": 0.6010317206382751
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/ptrace.c",
          "start_line": 195,
          "end_line": 336,
          "content": [
            "static bool ptrace_freeze_traced(struct task_struct *task)",
            "{",
            "\tbool ret = false;",
            "",
            "\t/* Lockless, nobody but us can set this flag */",
            "\tif (task->jobctl & JOBCTL_LISTENING)",
            "\t\treturn ret;",
            "",
            "\tspin_lock_irq(&task->sighand->siglock);",
            "\tif (task_is_traced(task) && !looks_like_a_spurious_pid(task) &&",
            "\t    !__fatal_signal_pending(task)) {",
            "\t\ttask->jobctl |= JOBCTL_PTRACE_FROZEN;",
            "\t\tret = true;",
            "\t}",
            "\tspin_unlock_irq(&task->sighand->siglock);",
            "",
            "\treturn ret;",
            "}",
            "static void ptrace_unfreeze_traced(struct task_struct *task)",
            "{",
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * The child may be awake and may have cleared",
            "\t * JOBCTL_PTRACE_FROZEN (see ptrace_resume).  The child will",
            "\t * not set JOBCTL_PTRACE_FROZEN or enter __TASK_TRACED anew.",
            "\t */",
            "\tif (lock_task_sighand(task, &flags)) {",
            "\t\ttask->jobctl &= ~JOBCTL_PTRACE_FROZEN;",
            "\t\tif (__fatal_signal_pending(task)) {",
            "\t\t\ttask->jobctl &= ~JOBCTL_TRACED;",
            "\t\t\twake_up_state(task, __TASK_TRACED);",
            "\t\t}",
            "\t\tunlock_task_sighand(task, &flags);",
            "\t}",
            "}",
            "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)",
            "{",
            "\tint ret = -ESRCH;",
            "",
            "\t/*",
            "\t * We take the read lock around doing both checks to close a",
            "\t * possible race where someone else was tracing our child and",
            "\t * detached between these two checks.  After this locked check,",
            "\t * we are sure that this is our traced child and that can only",
            "\t * be changed by us so it's not changing right after this.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tif (child->ptrace && child->parent == current) {",
            "\t\t/*",
            "\t\t * child->sighand can't be NULL, release_task()",
            "\t\t * does ptrace_unlink() before __exit_signal().",
            "\t\t */",
            "\t\tif (ignore_state || ptrace_freeze_traced(child))",
            "\t\t\tret = 0;",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tif (!ret && !ignore_state &&",
            "\t    WARN_ON_ONCE(!wait_task_inactive(child, __TASK_TRACED|TASK_FROZEN)))",
            "\t\tret = -ESRCH;",
            "",
            "\treturn ret;",
            "}",
            "static bool ptrace_has_cap(struct user_namespace *ns, unsigned int mode)",
            "{",
            "\tif (mode & PTRACE_MODE_NOAUDIT)",
            "\t\treturn ns_capable_noaudit(ns, CAP_SYS_PTRACE);",
            "\treturn ns_capable(ns, CAP_SYS_PTRACE);",
            "}",
            "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)",
            "{",
            "\tconst struct cred *cred = current_cred(), *tcred;",
            "\tstruct mm_struct *mm;",
            "\tkuid_t caller_uid;",
            "\tkgid_t caller_gid;",
            "",
            "\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {",
            "\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\t/* May we inspect the given task?",
            "\t * This check is used both for attaching with ptrace",
            "\t * and for allowing access to sensitive information in /proc.",
            "\t *",
            "\t * ptrace_attach denies several cases that /proc allows",
            "\t * because setting up the necessary parent/child relationship",
            "\t * or halting the specified task is impossible.",
            "\t */",
            "",
            "\t/* Don't let security modules deny introspection */",
            "\tif (same_thread_group(task, current))",
            "\t\treturn 0;",
            "\trcu_read_lock();",
            "\tif (mode & PTRACE_MODE_FSCREDS) {",
            "\t\tcaller_uid = cred->fsuid;",
            "\t\tcaller_gid = cred->fsgid;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Using the euid would make more sense here, but something",
            "\t\t * in userland might rely on the old behavior, and this",
            "\t\t * shouldn't be a security problem since",
            "\t\t * PTRACE_MODE_REALCREDS implies that the caller explicitly",
            "\t\t * used a syscall that requests access to another process",
            "\t\t * (and not a filesystem syscall to procfs).",
            "\t\t */",
            "\t\tcaller_uid = cred->uid;",
            "\t\tcaller_gid = cred->gid;",
            "\t}",
            "\ttcred = __task_cred(task);",
            "\tif (uid_eq(caller_uid, tcred->euid) &&",
            "\t    uid_eq(caller_uid, tcred->suid) &&",
            "\t    uid_eq(caller_uid, tcred->uid)  &&",
            "\t    gid_eq(caller_gid, tcred->egid) &&",
            "\t    gid_eq(caller_gid, tcred->sgid) &&",
            "\t    gid_eq(caller_gid, tcred->gid))",
            "\t\tgoto ok;",
            "\tif (ptrace_has_cap(tcred->user_ns, mode))",
            "\t\tgoto ok;",
            "\trcu_read_unlock();",
            "\treturn -EPERM;",
            "ok:",
            "\trcu_read_unlock();",
            "\t/*",
            "\t * If a task drops privileges and becomes nondumpable (through a syscall",
            "\t * like setresuid()) while we are trying to access it, we must ensure",
            "\t * that the dumpability is read after the credentials; otherwise,",
            "\t * we may be able to attach to a task that we shouldn't be able to",
            "\t * attach to (as if the task had dropped privileges without becoming",
            "\t * nondumpable).",
            "\t * Pairs with a write barrier in commit_creds().",
            "\t */",
            "\tsmp_rmb();",
            "\tmm = task->mm;",
            "\tif (mm &&",
            "\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&",
            "\t     !ptrace_has_cap(mm->user_ns, mode)))",
            "\t    return -EPERM;",
            "",
            "\treturn security_ptrace_access_check(task, mode);",
            "}"
          ],
          "function_name": "ptrace_freeze_traced, ptrace_unfreeze_traced, ptrace_check_attach, ptrace_has_cap, __ptrace_may_access",
          "description": "处理跟踪进程的冻结/解冻机制，检查附加合法性并验证能力权限，确保跟踪操作符合安全策略和内核状态约束。",
          "similarity": 0.5796365737915039
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/ptrace.c",
          "start_line": 360,
          "end_line": 490,
          "content": [
            "bool ptrace_may_access(struct task_struct *task, unsigned int mode)",
            "{",
            "\tint err;",
            "\ttask_lock(task);",
            "\terr = __ptrace_may_access(task, mode);",
            "\ttask_unlock(task);",
            "\treturn !err;",
            "}",
            "static int check_ptrace_options(unsigned long data)",
            "{",
            "\tif (data & ~(unsigned long)PTRACE_O_MASK)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {",
            "\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||",
            "\t\t    !IS_ENABLED(CONFIG_SECCOMP))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (!capable(CAP_SYS_ADMIN))",
            "\t\t\treturn -EPERM;",
            "",
            "\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||",
            "\t\t    current->ptrace & PT_SUSPEND_SECCOMP)",
            "\t\t\treturn -EPERM;",
            "\t}",
            "\treturn 0;",
            "}",
            "static inline void ptrace_set_stopped(struct task_struct *task)",
            "{",
            "\tguard(spinlock)(&task->sighand->siglock);",
            "",
            "\t/*",
            "\t * If the task is already STOPPED, set JOBCTL_TRAP_STOP and",
            "\t * TRAPPING, and kick it so that it transits to TRACED.  TRAPPING",
            "\t * will be cleared if the child completes the transition or any",
            "\t * event which clears the group stop states happens.  We'll wait",
            "\t * for the transition to complete before returning from this",
            "\t * function.",
            "\t *",
            "\t * This hides STOPPED -> RUNNING -> TRACED transition from the",
            "\t * attaching thread but a different thread in the same group can",
            "\t * still observe the transient RUNNING state.  IOW, if another",
            "\t * thread's WNOHANG wait(2) on the stopped tracee races against",
            "\t * ATTACH, the wait(2) may fail due to the transient RUNNING.",
            "\t *",
            "\t * The following task_is_stopped() test is safe as both transitions",
            "\t * in and out of STOPPED are protected by siglock.",
            "\t */",
            "\tif (task_is_stopped(task) &&",
            "\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING)) {",
            "\t\ttask->jobctl &= ~JOBCTL_STOPPED;",
            "\t\tsignal_wake_up_state(task, __TASK_STOPPED);",
            "\t}",
            "}",
            "static int ptrace_attach(struct task_struct *task, long request,",
            "\t\t\t unsigned long addr,",
            "\t\t\t unsigned long flags)",
            "{",
            "\tbool seize = (request == PTRACE_SEIZE);",
            "\tint retval;",
            "",
            "\tif (seize) {",
            "\t\tif (addr != 0)",
            "\t\t\treturn -EIO;",
            "\t\t/*",
            "\t\t * This duplicates the check in check_ptrace_options() because",
            "\t\t * ptrace_attach() and ptrace_setoptions() have historically",
            "\t\t * used different error codes for unknown ptrace options.",
            "\t\t */",
            "\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)",
            "\t\t\treturn -EIO;",
            "",
            "\t\tretval = check_ptrace_options(flags);",
            "\t\tif (retval)",
            "\t\t\treturn retval;",
            "\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);",
            "\t} else {",
            "\t\tflags = PT_PTRACED;",
            "\t}",
            "",
            "\taudit_ptrace(task);",
            "",
            "\tif (unlikely(task->flags & PF_KTHREAD))",
            "\t\treturn -EPERM;",
            "\tif (same_thread_group(task, current))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * Protect exec's credential calculations against our interference;",
            "\t * SUID, SGID and LSM creds get determined differently",
            "\t * under ptrace.",
            "\t */",
            "\tscoped_cond_guard (mutex_intr, return -ERESTARTNOINTR,",
            "\t\t\t   &task->signal->cred_guard_mutex) {",
            "",
            "\t\tscoped_guard (task_lock, task) {",
            "\t\t\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);",
            "\t\t\tif (retval)",
            "\t\t\t\treturn retval;",
            "\t\t}",
            "",
            "\t\tscoped_guard (write_lock_irq, &tasklist_lock) {",
            "\t\t\tif (unlikely(task->exit_state))",
            "\t\t\t\treturn -EPERM;",
            "\t\t\tif (task->ptrace)",
            "\t\t\t\treturn -EPERM;",
            "",
            "\t\t\ttask->ptrace = flags;",
            "",
            "\t\t\tptrace_link(task, current);",
            "",
            "\t\t\t/* SEIZE doesn't trap tracee on attach */",
            "\t\t\tif (!seize)",
            "\t\t\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);",
            "",
            "\t\t\tptrace_set_stopped(task);",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * We do not bother to change retval or clear JOBCTL_TRAPPING",
            "\t * if wait_on_bit() was interrupted by SIGKILL. The tracer will",
            "\t * not return to user-mode, it will exit and clear this bit in",
            "\t * __ptrace_unlink() if it wasn't already cleared by the tracee;",
            "\t * and until then nobody can ptrace this task.",
            "\t */",
            "\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);",
            "\tproc_ptrace_connector(task, PTRACE_ATTACH);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "ptrace_may_access, check_ptrace_options, ptrace_set_stopped, ptrace_attach",
          "description": "实现ptrace附加流程，包含权限校验、选项解析、停止状态设置及实际附加操作，协调信号传递和跟踪标志位更新。",
          "similarity": 0.5788462162017822
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_syscalls.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:39:27\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_syscalls.c`\n\n---\n\n# `trace_syscalls.c` 技术文档\n\n## 1. 文件概述\n\n`trace_syscalls.c` 是 Linux 内核中用于实现系统调用追踪（syscall tracing）的核心文件。它通过 ftrace 框架提供对系统调用入口（enter）和出口（exit）事件的动态追踪能力，支持将系统调用的名称、参数及返回值记录到内核追踪缓冲区中，供用户空间工具（如 `trace-cmd`、`perf`）分析使用。该文件负责注册系统调用追踪事件、解析系统调用元数据、格式化输出内容，并与架构相关的系统调用接口进行适配。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct syscall_metadata`：描述单个系统调用的元数据，包括名称、参数数量、参数类型、参数名、以及对应的 enter/exit 追踪事件。\n- `syscall_trace_enter` / `syscall_trace_exit`：用于在追踪缓冲区中记录系统调用进入和退出事件的数据结构。\n- `syscalls_metadata_sparse`（XArray）：在 `CONFIG_HAVE_SPARSE_SYSCALL_NR` 启用时，使用 XArray 存储稀疏的系统调用元数据映射。\n- `syscalls_metadata`（数组）：传统稠密数组形式的系统调用元数据索引。\n\n### 主要函数\n- `find_syscall_meta()`：根据系统调用函数地址查找对应的 `syscall_metadata`。\n- `syscall_nr_to_meta()`：根据系统调用号（syscall number）获取元数据。\n- `get_syscall_name()`：根据系统调用号返回其名称字符串。\n- `print_syscall_enter()` / `print_syscall_exit()`：格式化输出系统调用进入/退出事件到追踪序列。\n- `ftrace_syscall_enter()` / `ftrace_syscall_exit()`：ftrace 探针回调函数，在系统调用入口/出口处被调用，负责写入追踪事件。\n- `syscall_enter_define_fields()`：为追踪事件定义字段（用于过滤和解析）。\n- `set_syscall_print_fmt()` / `free_syscall_print_fmt()`：动态生成并管理追踪事件的打印格式字符串。\n- `syscall_enter_register()` / `syscall_exit_register()`：追踪事件注册/注销回调函数。\n- `trace_get_syscall_nr()`：获取当前任务的系统调用号，支持架构特定的兼容性处理（如忽略 32 位兼容调用）。\n\n## 3. 关键实现\n\n### 系统调用元数据管理\n- 系统调用元数据由编译器通过 `__start_syscalls_metadata` 和 `__stop_syscalls_metadata` 符号自动收集，形成一个静态数组。\n- 支持两种索引方式：\n  - **稠密数组**：`syscalls_metadata[nr]` 直接通过系统调用号索引（适用于系统调用号连续的架构）。\n  - **稀疏 XArray**：当启用 `CONFIG_HAVE_SPARSE_SYSCALL_NR` 时，使用 XArray 存储非连续的系统调用号映射，节省内存。\n\n### 架构适配机制\n- **符号名匹配**：通过 `arch_syscall_match_sym_name()` 忽略符号前缀差异（如 `sys_`、`.SyS_`、`.sys_`），确保正确匹配系统调用函数。\n- **兼容系统调用处理**：若定义 `ARCH_TRACE_IGNORE_COMPAT_SYSCALLS`，则通过 `arch_trace_is_compat_syscall()` 判断并忽略 32 位兼容系统调用，避免追踪错误。\n\n### 追踪事件格式化\n- **动态生成 print_fmt**：`__set_enter_print_fmt()` 根据系统调用的参数数量和名称，动态构造格式化字符串（如 `\"arg1: 0x%016lx, arg2: 0x%016lx\"`），用于 `trace_printk` 风格的输出。\n- **字段定义**：`syscall_enter_define_fields()` 为每个参数注册字段信息，支持后续的过滤和解析（如 `trace-cmd filter`）。\n\n### 安全与性能\n- **抢占保护**：在 `ftrace_syscall_enter/exit` 中使用 `guard(preempt_notrace)()` 禁用抢占，确保对 per-CPU ring buffer 的安全访问。\n- **RCU 保护**：通过 `rcu_dereference_sched()` 安全访问 per-tracer 的系统调用文件指针数组。\n- **软禁用检查**：调用 `trace_trigger_soft_disabled()` 检查是否临时禁用该追踪点，避免不必要的开销。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<trace/syscall.h>`：定义 `struct syscall_metadata` 等核心结构。\n  - `<trace/events/syscalls.h>`：声明系统调用追踪事件（`TRACE_EVENT` 宏生成）。\n  - `<asm/syscall.h>`：提供架构相关的 `syscall_get_nr()` 等函数。\n  - `\"trace.h\"` / `\"trace_output.h\"`：ftrace 核心接口和输出工具。\n- **内核子系统**：\n  - **ftrace**：作为 ftrace 的事件提供者，注册动态追踪点。\n  - **perf_events**：可通过 perf 接口启用系统调用追踪。\n  - **kallsyms**：用于通过地址反查符号名（`kallsyms_lookup`）。\n  - **XArray**：用于稀疏系统调用号的高效存储（`CONFIG_XARRAY`）。\n- **架构支持**：依赖架构实现 `syscall_get_nr()`、`arch_trace_is_compat_syscall()`（可选）等函数。\n\n## 5. 使用场景\n\n- **系统调用行为分析**：通过 `echo 1 > /sys/kernel/debug/tracing/events/syscalls/enable` 启用所有系统调用追踪，观察应用程序的系统调用序列、参数及返回值。\n- **性能剖析**：结合 `perf` 工具，统计特定系统调用的调用频率、延迟分布。\n- **安全审计**：监控敏感系统调用（如 `execve`、`open`）的使用情况。\n- **调试内核问题**：在系统调用路径上插入追踪点，辅助定位死锁、异常返回等问题。\n- **动态追踪框架集成**：作为 ftrace 事件源，被 `trace-cmd`、`bpftrace` 等高级追踪工具调用。",
      "similarity": 0.6074790954589844,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/trace_syscalls.c",
          "start_line": 569,
          "end_line": 669,
          "content": [
            "\tstruct syscall_tp_t {",
            "\t\tstruct trace_entry ent;",
            "\t\tunsigned long syscall_nr;",
            "\t\tunsigned long args[SYSCALL_DEFINE_MAXARGS];",
            "\t} __aligned(8) param;",
            "\tint i;",
            "",
            "\tBUILD_BUG_ON(sizeof(param.ent) < sizeof(void *));",
            "",
            "\t/* bpf prog requires 'regs' to be the first member in the ctx (a.k.a. &param) */",
            "\tperf_fetch_caller_regs(regs);",
            "\t*(struct pt_regs **)&param = regs;",
            "\tparam.syscall_nr = rec->nr;",
            "\tfor (i = 0; i < sys_data->nb_args; i++)",
            "\t\tparam.args[i] = rec->args[i];",
            "\treturn trace_call_bpf(call, &param);",
            "}",
            "",
            "static void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)",
            "{",
            "\tstruct syscall_metadata *sys_data;",
            "\tstruct syscall_trace_enter *rec;",
            "\tstruct pt_regs *fake_regs;",
            "\tstruct hlist_head *head;",
            "\tunsigned long args[6];",
            "\tbool valid_prog_array;",
            "\tint syscall_nr;",
            "\tint rctx;",
            "\tint size;",
            "",
            "\tsyscall_nr = trace_get_syscall_nr(current, regs);",
            "\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)",
            "\t\treturn;",
            "\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))",
            "\t\treturn;",
            "",
            "\tsys_data = syscall_nr_to_meta(syscall_nr);",
            "\tif (!sys_data)",
            "\t\treturn;",
            "",
            "\thead = this_cpu_ptr(sys_data->enter_event->perf_events);",
            "\tvalid_prog_array = bpf_prog_array_valid(sys_data->enter_event);",
            "\tif (!valid_prog_array && hlist_empty(head))",
            "\t\treturn;",
            "",
            "\t/* get the size after alignment with the u32 buffer size field */",
            "\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);",
            "\tsize = ALIGN(size + sizeof(u32), sizeof(u64));",
            "\tsize -= sizeof(u32);",
            "",
            "\trec = perf_trace_buf_alloc(size, &fake_regs, &rctx);",
            "\tif (!rec)",
            "\t\treturn;",
            "",
            "\trec->nr = syscall_nr;",
            "\tsyscall_get_arguments(current, regs, args);",
            "\tmemcpy(&rec->args, args, sizeof(unsigned long) * sys_data->nb_args);",
            "",
            "\tif ((valid_prog_array &&",
            "\t     !perf_call_bpf_enter(sys_data->enter_event, fake_regs, sys_data, rec)) ||",
            "\t    hlist_empty(head)) {",
            "\t\tperf_swevent_put_recursion_context(rctx);",
            "\t\treturn;",
            "\t}",
            "",
            "\tperf_trace_buf_submit(rec, size, rctx,",
            "\t\t\t      sys_data->enter_event->event.type, 1, regs,",
            "\t\t\t      head, NULL);",
            "}",
            "static int perf_sysenter_enable(struct trace_event_call *call)",
            "{",
            "\tint ret = 0;",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "",
            "\tmutex_lock(&syscall_trace_lock);",
            "\tif (!sys_perf_refcount_enter)",
            "\t\tret = register_trace_sys_enter(perf_syscall_enter, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"event trace: Could not activate syscall entry trace point\");",
            "\t} else {",
            "\t\tset_bit(num, enabled_perf_enter_syscalls);",
            "\t\tsys_perf_refcount_enter++;",
            "\t}",
            "\tmutex_unlock(&syscall_trace_lock);",
            "\treturn ret;",
            "}",
            "static void perf_sysenter_disable(struct trace_event_call *call)",
            "{",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "",
            "\tmutex_lock(&syscall_trace_lock);",
            "\tsys_perf_refcount_enter--;",
            "\tclear_bit(num, enabled_perf_enter_syscalls);",
            "\tif (!sys_perf_refcount_enter)",
            "\t\tunregister_trace_sys_enter(perf_syscall_enter, NULL);",
            "\tmutex_unlock(&syscall_trace_lock);",
            "}"
          ],
          "function_name": "__aligned, perf_sysenter_enable, perf_sysenter_disable",
          "description": "实现基于性能事件的系统调用入口跟踪逻辑，包含BPF程序调用支持，提供启用/禁用系统调用入口跟踪的控制接口。",
          "similarity": 0.6929945945739746
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/trace_syscalls.c",
          "start_line": 380,
          "end_line": 515,
          "content": [
            "static int reg_event_syscall_enter(struct trace_event_file *file,",
            "\t\t\t\t   struct trace_event_call *call)",
            "{",
            "\tstruct trace_array *tr = file->tr;",
            "\tint ret = 0;",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))",
            "\t\treturn -ENOSYS;",
            "\tmutex_lock(&syscall_trace_lock);",
            "\tif (!tr->sys_refcount_enter)",
            "\t\tret = register_trace_sys_enter(ftrace_syscall_enter, tr);",
            "\tif (!ret) {",
            "\t\trcu_assign_pointer(tr->enter_syscall_files[num], file);",
            "\t\ttr->sys_refcount_enter++;",
            "\t}",
            "\tmutex_unlock(&syscall_trace_lock);",
            "\treturn ret;",
            "}",
            "static void unreg_event_syscall_enter(struct trace_event_file *file,",
            "\t\t\t\t      struct trace_event_call *call)",
            "{",
            "\tstruct trace_array *tr = file->tr;",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))",
            "\t\treturn;",
            "\tmutex_lock(&syscall_trace_lock);",
            "\ttr->sys_refcount_enter--;",
            "\tRCU_INIT_POINTER(tr->enter_syscall_files[num], NULL);",
            "\tif (!tr->sys_refcount_enter)",
            "\t\tunregister_trace_sys_enter(ftrace_syscall_enter, tr);",
            "\tmutex_unlock(&syscall_trace_lock);",
            "}",
            "static int reg_event_syscall_exit(struct trace_event_file *file,",
            "\t\t\t\t  struct trace_event_call *call)",
            "{",
            "\tstruct trace_array *tr = file->tr;",
            "\tint ret = 0;",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))",
            "\t\treturn -ENOSYS;",
            "\tmutex_lock(&syscall_trace_lock);",
            "\tif (!tr->sys_refcount_exit)",
            "\t\tret = register_trace_sys_exit(ftrace_syscall_exit, tr);",
            "\tif (!ret) {",
            "\t\trcu_assign_pointer(tr->exit_syscall_files[num], file);",
            "\t\ttr->sys_refcount_exit++;",
            "\t}",
            "\tmutex_unlock(&syscall_trace_lock);",
            "\treturn ret;",
            "}",
            "static void unreg_event_syscall_exit(struct trace_event_file *file,",
            "\t\t\t\t     struct trace_event_call *call)",
            "{",
            "\tstruct trace_array *tr = file->tr;",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))",
            "\t\treturn;",
            "\tmutex_lock(&syscall_trace_lock);",
            "\ttr->sys_refcount_exit--;",
            "\tRCU_INIT_POINTER(tr->exit_syscall_files[num], NULL);",
            "\tif (!tr->sys_refcount_exit)",
            "\t\tunregister_trace_sys_exit(ftrace_syscall_exit, tr);",
            "\tmutex_unlock(&syscall_trace_lock);",
            "}",
            "static int __init init_syscall_trace(struct trace_event_call *call)",
            "{",
            "\tint id;",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "\tif (num < 0 || num >= NR_syscalls) {",
            "\t\tpr_debug(\"syscall %s metadata not mapped, disabling ftrace event\\n\",",
            "\t\t\t\t((struct syscall_metadata *)call->data)->name);",
            "\t\treturn -ENOSYS;",
            "\t}",
            "",
            "\tif (set_syscall_print_fmt(call) < 0)",
            "\t\treturn -ENOMEM;",
            "",
            "\tid = trace_event_raw_init(call);",
            "",
            "\tif (id < 0) {",
            "\t\tfree_syscall_print_fmt(call);",
            "\t\treturn id;",
            "\t}",
            "",
            "\treturn id;",
            "}",
            "unsigned long __init __weak arch_syscall_addr(int nr)",
            "{",
            "\treturn (unsigned long)sys_call_table[nr];",
            "}",
            "void __init init_ftrace_syscalls(void)",
            "{",
            "\tstruct syscall_metadata *meta;",
            "\tunsigned long addr;",
            "\tint i;",
            "\tvoid *ret;",
            "",
            "\tif (!IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR)) {",
            "\t\tsyscalls_metadata = kcalloc(NR_syscalls,",
            "\t\t\t\t\tsizeof(*syscalls_metadata),",
            "\t\t\t\t\tGFP_KERNEL);",
            "\t\tif (!syscalls_metadata) {",
            "\t\t\tWARN_ON(1);",
            "\t\t\treturn;",
            "\t\t}",
            "\t}",
            "",
            "\tfor (i = 0; i < NR_syscalls; i++) {",
            "\t\taddr = arch_syscall_addr(i);",
            "\t\tmeta = find_syscall_meta(addr);",
            "\t\tif (!meta)",
            "\t\t\tcontinue;",
            "",
            "\t\tmeta->syscall_nr = i;",
            "",
            "\t\tif (!IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR)) {",
            "\t\t\tsyscalls_metadata[i] = meta;",
            "\t\t} else {",
            "\t\t\tret = xa_store(&syscalls_metadata_sparse, i, meta,",
            "\t\t\t\t\tGFP_KERNEL);",
            "\t\t\tWARN(xa_is_err(ret),",
            "\t\t\t\t\"Syscall memory allocation failed\\n\");",
            "\t\t}",
            "",
            "\t}",
            "}"
          ],
          "function_name": "reg_event_syscall_enter, unreg_event_syscall_enter, reg_event_syscall_exit, unreg_event_syscall_exit, init_syscall_trace, arch_syscall_addr, init_ftrace_syscalls",
          "description": "管理系统调用跟踪事件的注册与取消注册操作，初始化系统调用跟踪元数据映射关系，建立系统调用号与跟踪文件的关联。",
          "similarity": 0.6662369966506958
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_syscalls.c",
          "start_line": 1,
          "end_line": 37,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <trace/syscall.h>",
            "#include <trace/events/syscalls.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/ftrace.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/xarray.h>",
            "#include <asm/syscall.h>",
            "",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "",
            "static DEFINE_MUTEX(syscall_trace_lock);",
            "",
            "static int syscall_enter_register(struct trace_event_call *event,",
            "\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,",
            "\t\t\t\t enum trace_reg type, void *data);",
            "",
            "static struct list_head *",
            "syscall_get_enter_fields(struct trace_event_call *call)",
            "{",
            "\tstruct syscall_metadata *entry = call->data;",
            "",
            "\treturn &entry->enter_fields;",
            "}",
            "",
            "extern struct syscall_metadata *__start_syscalls_metadata[];",
            "extern struct syscall_metadata *__stop_syscalls_metadata[];",
            "",
            "static DEFINE_XARRAY(syscalls_metadata_sparse);",
            "static struct syscall_metadata **syscalls_metadata;",
            "",
            "#ifndef ARCH_HAS_SYSCALL_MATCH_SYM_NAME"
          ],
          "function_name": null,
          "description": "定义系统调用跟踪所需的数据结构和锁，声明元数据数组及辅助函数，用于管理系统调用跟踪的注册与注销流程。",
          "similarity": 0.6645203232765198
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_syscalls.c",
          "start_line": 38,
          "end_line": 163,
          "content": [
            "static inline bool arch_syscall_match_sym_name(const char *sym, const char *name)",
            "{",
            "\t/*",
            "\t * Only compare after the \"sys\" prefix. Archs that use",
            "\t * syscall wrappers may have syscalls symbols aliases prefixed",
            "\t * with \".SyS\" or \".sys\" instead of \"sys\", leading to an unwanted",
            "\t * mismatch.",
            "\t */",
            "\treturn !strcmp(sym + 3, name + 3);",
            "}",
            "static int",
            "trace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)",
            "{",
            "\tif (unlikely(arch_trace_is_compat_syscall(regs)))",
            "\t\treturn -1;",
            "",
            "\treturn syscall_get_nr(task, regs);",
            "}",
            "static inline int",
            "trace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)",
            "{",
            "\treturn syscall_get_nr(task, regs);",
            "}",
            "static enum print_line_t",
            "print_syscall_enter(struct trace_iterator *iter, int flags,",
            "\t\t    struct trace_event *event)",
            "{",
            "\tstruct trace_array *tr = iter->tr;",
            "\tstruct trace_seq *s = &iter->seq;",
            "\tstruct trace_entry *ent = iter->ent;",
            "\tstruct syscall_trace_enter *trace;",
            "\tstruct syscall_metadata *entry;",
            "\tint i, syscall;",
            "",
            "\ttrace = (typeof(trace))ent;",
            "\tsyscall = trace->nr;",
            "\tentry = syscall_nr_to_meta(syscall);",
            "",
            "\tif (!entry)",
            "\t\tgoto end;",
            "",
            "\tif (entry->enter_event->event.type != ent->type) {",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tgoto end;",
            "\t}",
            "",
            "\ttrace_seq_printf(s, \"%s(\", entry->name);",
            "",
            "\tfor (i = 0; i < entry->nb_args; i++) {",
            "",
            "\t\tif (trace_seq_has_overflowed(s))",
            "\t\t\tgoto end;",
            "",
            "\t\t/* parameter types */",
            "\t\tif (tr && tr->trace_flags & TRACE_ITER_VERBOSE)",
            "\t\t\ttrace_seq_printf(s, \"%s \", entry->types[i]);",
            "",
            "\t\t/* parameter values */",
            "\t\ttrace_seq_printf(s, \"%s: %lx%s\", entry->args[i],",
            "\t\t\t\t trace->args[i],",
            "\t\t\t\t i == entry->nb_args - 1 ? \"\" : \", \");",
            "\t}",
            "",
            "\ttrace_seq_putc(s, ')');",
            "end:",
            "\ttrace_seq_putc(s, '\\n');",
            "",
            "\treturn trace_handle_return(s);",
            "}",
            "static enum print_line_t",
            "print_syscall_exit(struct trace_iterator *iter, int flags,",
            "\t\t   struct trace_event *event)",
            "{",
            "\tstruct trace_seq *s = &iter->seq;",
            "\tstruct trace_entry *ent = iter->ent;",
            "\tstruct syscall_trace_exit *trace;",
            "\tint syscall;",
            "\tstruct syscall_metadata *entry;",
            "",
            "\ttrace = (typeof(trace))ent;",
            "\tsyscall = trace->nr;",
            "\tentry = syscall_nr_to_meta(syscall);",
            "",
            "\tif (!entry) {",
            "\t\ttrace_seq_putc(s, '\\n');",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (entry->exit_event->event.type != ent->type) {",
            "\t\tWARN_ON_ONCE(1);",
            "\t\treturn TRACE_TYPE_UNHANDLED;",
            "\t}",
            "",
            "\ttrace_seq_printf(s, \"%s -> 0x%lx\\n\", entry->name,",
            "\t\t\t\ttrace->ret);",
            "",
            " out:",
            "\treturn trace_handle_return(s);",
            "}",
            "static int __init",
            "__set_enter_print_fmt(struct syscall_metadata *entry, char *buf, int len)",
            "{",
            "\tint i;",
            "\tint pos = 0;",
            "",
            "\t/* When len=0, we just calculate the needed length */",
            "#define LEN_OR_ZERO (len ? len - pos : 0)",
            "",
            "\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");",
            "\tfor (i = 0; i < entry->nb_args; i++) {",
            "\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s: 0x%%0%zulx%s\",",
            "\t\t\t\tentry->args[i], sizeof(unsigned long),",
            "\t\t\t\ti == entry->nb_args - 1 ? \"\" : \", \");",
            "\t}",
            "\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");",
            "",
            "\tfor (i = 0; i < entry->nb_args; i++) {",
            "\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,",
            "\t\t\t\t\", ((unsigned long)(REC->%s))\", entry->args[i]);",
            "\t}",
            "",
            "#undef LEN_OR_ZERO",
            "",
            "\t/* return the length of print_fmt */",
            "\treturn pos;",
            "}"
          ],
          "function_name": "arch_syscall_match_sym_name, trace_get_syscall_nr, trace_get_syscall_nr, print_syscall_enter, print_syscall_exit, __set_enter_print_fmt",
          "description": "实现系统调用号解析、符号匹配逻辑，以及跟踪事件打印函数，动态构造并输出系统调用参数和返回值的详细信息。",
          "similarity": 0.6453060507774353
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_syscalls.c",
          "start_line": 676,
          "end_line": 795,
          "content": [
            "\tstruct syscall_tp_t {",
            "\t\tstruct trace_entry ent;",
            "\t\tunsigned long syscall_nr;",
            "\t\tunsigned long ret;",
            "\t} __aligned(8) param;",
            "",
            "\t/* bpf prog requires 'regs' to be the first member in the ctx (a.k.a. &param) */",
            "\tperf_fetch_caller_regs(regs);",
            "\t*(struct pt_regs **)&param = regs;",
            "\tparam.syscall_nr = rec->nr;",
            "\tparam.ret = rec->ret;",
            "\treturn trace_call_bpf(call, &param);",
            "}",
            "",
            "static void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret)",
            "{",
            "\tstruct syscall_metadata *sys_data;",
            "\tstruct syscall_trace_exit *rec;",
            "\tstruct pt_regs *fake_regs;",
            "\tstruct hlist_head *head;",
            "\tbool valid_prog_array;",
            "\tint syscall_nr;",
            "\tint rctx;",
            "\tint size;",
            "",
            "\tsyscall_nr = trace_get_syscall_nr(current, regs);",
            "\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)",
            "\t\treturn;",
            "\tif (!test_bit(syscall_nr, enabled_perf_exit_syscalls))",
            "\t\treturn;",
            "",
            "\tsys_data = syscall_nr_to_meta(syscall_nr);",
            "\tif (!sys_data)",
            "\t\treturn;",
            "",
            "\thead = this_cpu_ptr(sys_data->exit_event->perf_events);",
            "\tvalid_prog_array = bpf_prog_array_valid(sys_data->exit_event);",
            "\tif (!valid_prog_array && hlist_empty(head))",
            "\t\treturn;",
            "",
            "\t/* We can probably do that at build time */",
            "\tsize = ALIGN(sizeof(*rec) + sizeof(u32), sizeof(u64));",
            "\tsize -= sizeof(u32);",
            "",
            "\trec = perf_trace_buf_alloc(size, &fake_regs, &rctx);",
            "\tif (!rec)",
            "\t\treturn;",
            "",
            "\trec->nr = syscall_nr;",
            "\trec->ret = syscall_get_return_value(current, regs);",
            "",
            "\tif ((valid_prog_array &&",
            "\t     !perf_call_bpf_exit(sys_data->exit_event, fake_regs, rec)) ||",
            "\t    hlist_empty(head)) {",
            "\t\tperf_swevent_put_recursion_context(rctx);",
            "\t\treturn;",
            "\t}",
            "",
            "\tperf_trace_buf_submit(rec, size, rctx, sys_data->exit_event->event.type,",
            "\t\t\t      1, regs, head, NULL);",
            "}",
            "static int perf_sysexit_enable(struct trace_event_call *call)",
            "{",
            "\tint ret = 0;",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "",
            "\tmutex_lock(&syscall_trace_lock);",
            "\tif (!sys_perf_refcount_exit)",
            "\t\tret = register_trace_sys_exit(perf_syscall_exit, NULL);",
            "\tif (ret) {",
            "\t\tpr_info(\"event trace: Could not activate syscall exit trace point\");",
            "\t} else {",
            "\t\tset_bit(num, enabled_perf_exit_syscalls);",
            "\t\tsys_perf_refcount_exit++;",
            "\t}",
            "\tmutex_unlock(&syscall_trace_lock);",
            "\treturn ret;",
            "}",
            "static void perf_sysexit_disable(struct trace_event_call *call)",
            "{",
            "\tint num;",
            "",
            "\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;",
            "",
            "\tmutex_lock(&syscall_trace_lock);",
            "\tsys_perf_refcount_exit--;",
            "\tclear_bit(num, enabled_perf_exit_syscalls);",
            "\tif (!sys_perf_refcount_exit)",
            "\t\tunregister_trace_sys_exit(perf_syscall_exit, NULL);",
            "\tmutex_unlock(&syscall_trace_lock);",
            "}",
            "static int syscall_enter_register(struct trace_event_call *event,",
            "\t\t\t\t enum trace_reg type, void *data)",
            "{",
            "\tstruct trace_event_file *file = data;",
            "",
            "\tswitch (type) {",
            "\tcase TRACE_REG_REGISTER:",
            "\t\treturn reg_event_syscall_enter(file, event);",
            "\tcase TRACE_REG_UNREGISTER:",
            "\t\tunreg_event_syscall_enter(file, event);",
            "\t\treturn 0;",
            "",
            "#ifdef CONFIG_PERF_EVENTS",
            "\tcase TRACE_REG_PERF_REGISTER:",
            "\t\treturn perf_sysenter_enable(event);",
            "\tcase TRACE_REG_PERF_UNREGISTER:",
            "\t\tperf_sysenter_disable(event);",
            "\t\treturn 0;",
            "\tcase TRACE_REG_PERF_OPEN:",
            "\tcase TRACE_REG_PERF_CLOSE:",
            "\tcase TRACE_REG_PERF_ADD:",
            "\tcase TRACE_REG_PERF_DEL:",
            "\t\treturn 0;",
            "#endif",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "__aligned, perf_sysexit_enable, perf_sysexit_disable, syscall_enter_register",
          "description": "定义了系统调用退出跟踪相关的结构体和辅助函数，通过perf事件框架实现系统调用返回值捕获与BPF程序调用，包含启用/禁用跟踪点注册及入口事件处理逻辑",
          "similarity": 0.6434670686721802
        }
      ]
    }
  ]
}