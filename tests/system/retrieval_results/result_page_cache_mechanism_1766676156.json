{
  "query": "page cache mechanism",
  "timestamp": "2025-12-25 23:22:36",
  "retrieved_files": [
    {
      "source_file": "mm/page_counter.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:00:45\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page_counter.c`\n\n---\n\n# page_counter.c 技术文档\n\n## 1. 文件概述\n\n`page_counter.c` 实现了一个无锁（lockless）的分层页面计数与限制机制，用于在 Linux 内核中对内存资源进行层级化计量、保护和限制。该机制主要用于 cgroup 内存控制器（如 memcg）中，支持对内存使用量进行精确跟踪，并提供 `memory.min` 和 `memory.low` 两种级别的内存保护策略，同时支持设置硬性上限（`memory.max`）。所有操作均基于原子操作实现，避免了传统锁带来的性能开销。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct page_counter`：核心计数器结构体，包含以下关键字段：\n  - `usage`：当前已使用的页面数（原子变量）\n  - `max`：硬性内存上限（可配置）\n  - `min` / `low`：内存保护阈值（软性保障）\n  - `min_usage` / `low_usage`：实际受保护的内存量\n  - `children_min_usage` / `children_low_usage`：子节点受保护内存总量\n  - `watermark`：历史最大使用量（用于统计）\n  - `failcnt`：因超出限制而失败的尝试次数\n  - `parent`：指向父级计数器的指针，构成层级树\n  - `protection_support`：是否启用保护机制的标志\n\n### 主要函数\n| 函数 | 功能说明 |\n|------|--------|\n| `page_counter_charge()` | 无条件地向计数器及其所有祖先层级增加指定页数 |\n| `page_counter_uncharge()` | 向计数器及其祖先层级减少指定页数（调用 `cancel`） |\n| `page_counter_try_charge()` | 尝试充电，若任一层级超过 `max` 则回滚并返回失败 |\n| `page_counter_cancel()` | 从本地计数器减去页数，处理下溢并更新保护用量 |\n| `page_counter_set_max()` | 设置硬性内存上限，若当前用量已超限则返回 `-EBUSY` |\n| `page_counter_set_min()` / `page_counter_set_low()` | 设置内存保护阈值，并触发保护用量传播 |\n| `page_counter_memparse()` | 解析用户输入的字符串（如 \"1G\"）为页数，支持 \"max\" 关键字 |\n| `propagate_protected_usage()` | （内部）根据当前用量和 min/low 阈值，向上更新受保护内存量 |\n\n## 3. 关键实现\n\n### 无锁层级更新\n- 所有计数操作（charge/uncharge）通过 `atomic_long_add_return()` 和 `atomic_long_sub_return()` 实现，确保线程安全。\n- 在 `page_counter_try_charge()` 中采用“先加后检”策略：先原子增加用量，再检查是否超过 `max`。若超限则回退。此方法虽存在短暂超限窗口，但避免了昂贵的 CAS 循环，适用于 THP（透明大页）等场景。\n\n### 内存保护机制\n- 引入 `min` 和 `low` 两级软保护：\n  - `min`：强保障，通常用于关键服务\n  - `low`：弱保障，用于优先级稍低的内存预留\n- `propagate_protected_usage()` 计算每个节点的实际受保护量：`protected = min(usage, threshold)`，并通过 `min_usage`/`low_usage` 原子变量记录，并累加到父节点的 `children_*_usage` 中，供上层决策（如内存回收）使用。\n\n### 水位线与失败计数\n- `watermark` 记录历史峰值用量，用于监控和调优。\n- `failcnt` 统计因超限导致的充电失败次数，仅用于统计信息，允许轻微不一致。\n\n### 安全的 max 更新\n- `page_counter_set_max()` 使用 `xchg()` 原子交换新旧上限，并通过循环验证：若在设置过程中用量增长导致新上限仍不足，则恢复旧值并重试，确保不会将上限设为低于当前用量的值。\n\n### 字符串解析\n- `page_counter_memparse()` 封装 `memparse()`，将用户空间传入的字符串（如 \"512M\"）转换为页数，并支持特殊值 \"max\" 表示 `PAGE_COUNTER_MAX`（即 `ULONG_MAX`）。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/page_counter.h>`：定义 `struct page_counter` 及函数声明\n  - `<linux/atomic.h>`：提供原子操作原语\n  - `<asm/page.h>`：提供 `PAGE_SIZE` 定义\n  - `<linux/kernel.h>`、`<linux/string.h>` 等基础内核头文件\n- **配置依赖**：\n  - 主要服务于 `CONFIG_MEMCG`（内存 cgroup）和 `CONFIG_CGROUP_DMEM`（设备内存 cgroup）\n  - 文件末尾的 `#if IS_ENABLED(...)` 表明其设计初衷是为 cgroup 内存控制器提供底层支持\n- **运行时依赖**：\n  - 依赖内核的原子操作和内存屏障语义保证正确性\n  - 与内存回收（reclaim）逻辑紧密配合，保护用量信息用于决定回收顺序\n\n## 5. 使用场景\n\n- **cgroup v2 内存控制器**：作为 `memory.max`、`memory.min`、`memory.low` 等接口的底层实现，管理容器或进程组的内存限额与保障。\n- **内存服务质量（QoS）**：通过 `min`/`low` 机制为关键应用提供内存预留，防止被普通任务挤占。\n- **内存超售（Overcommit）管理**：在云环境或虚拟化平台中，精确控制各租户的内存使用边界。\n- **透明大页（THP）分配**：`try_charge` 的投机性设计特别优化了 THP（2MB/1GB 页）与普通页（4KB）并发分配时的性能。\n- **系统监控与调优**：通过 `watermark` 和 `failcnt` 提供内存使用峰值和限制冲突的统计信息，辅助系统管理员进行容量规划。",
      "similarity": 0.5906183123588562,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/page_counter.c",
          "start_line": 16,
          "end_line": 132,
          "content": [
            "static bool track_protection(struct page_counter *c)",
            "{",
            "\treturn c->protection_support;",
            "}",
            "static void propagate_protected_usage(struct page_counter *c,",
            "\t\t\t\t      unsigned long usage)",
            "{",
            "\tunsigned long protected, old_protected;",
            "\tlong delta;",
            "",
            "\tif (!c->parent)",
            "\t\treturn;",
            "",
            "\tprotected = min(usage, READ_ONCE(c->min));",
            "\told_protected = atomic_long_read(&c->min_usage);",
            "\tif (protected != old_protected) {",
            "\t\told_protected = atomic_long_xchg(&c->min_usage, protected);",
            "\t\tdelta = protected - old_protected;",
            "\t\tif (delta)",
            "\t\t\tatomic_long_add(delta, &c->parent->children_min_usage);",
            "\t}",
            "",
            "\tprotected = min(usage, READ_ONCE(c->low));",
            "\told_protected = atomic_long_read(&c->low_usage);",
            "\tif (protected != old_protected) {",
            "\t\told_protected = atomic_long_xchg(&c->low_usage, protected);",
            "\t\tdelta = protected - old_protected;",
            "\t\tif (delta)",
            "\t\t\tatomic_long_add(delta, &c->parent->children_low_usage);",
            "\t}",
            "}",
            "void page_counter_cancel(struct page_counter *counter, unsigned long nr_pages)",
            "{",
            "\tlong new;",
            "",
            "\tnew = atomic_long_sub_return(nr_pages, &counter->usage);",
            "\t/* More uncharges than charges? */",
            "\tif (WARN_ONCE(new < 0, \"page_counter underflow: %ld nr_pages=%lu\\n\",",
            "\t\t      new, nr_pages)) {",
            "\t\tnew = 0;",
            "\t\tatomic_long_set(&counter->usage, new);",
            "\t}",
            "\tif (track_protection(counter))",
            "\t\tpropagate_protected_usage(counter, new);",
            "}",
            "void page_counter_charge(struct page_counter *counter, unsigned long nr_pages)",
            "{",
            "\tstruct page_counter *c;",
            "\tbool protection = track_protection(counter);",
            "",
            "\tfor (c = counter; c; c = c->parent) {",
            "\t\tlong new;",
            "",
            "\t\tnew = atomic_long_add_return(nr_pages, &c->usage);",
            "\t\tif (protection)",
            "\t\t\tpropagate_protected_usage(c, new);",
            "\t\t/*",
            "\t\t * This is indeed racy, but we can live with some",
            "\t\t * inaccuracy in the watermark.",
            "\t\t */",
            "\t\tif (new > READ_ONCE(c->watermark))",
            "\t\t\tWRITE_ONCE(c->watermark, new);",
            "\t}",
            "}",
            "bool page_counter_try_charge(struct page_counter *counter,",
            "\t\t\t     unsigned long nr_pages,",
            "\t\t\t     struct page_counter **fail)",
            "{",
            "\tstruct page_counter *c;",
            "\tbool protection = track_protection(counter);",
            "",
            "\tfor (c = counter; c; c = c->parent) {",
            "\t\tlong new;",
            "\t\t/*",
            "\t\t * Charge speculatively to avoid an expensive CAS.  If",
            "\t\t * a bigger charge fails, it might falsely lock out a",
            "\t\t * racing smaller charge and send it into reclaim",
            "\t\t * early, but the error is limited to the difference",
            "\t\t * between the two sizes, which is less than 2M/4M in",
            "\t\t * case of a THP locking out a regular page charge.",
            "\t\t *",
            "\t\t * The atomic_long_add_return() implies a full memory",
            "\t\t * barrier between incrementing the count and reading",
            "\t\t * the limit.  When racing with page_counter_set_max(),",
            "\t\t * we either see the new limit or the setter sees the",
            "\t\t * counter has changed and retries.",
            "\t\t */",
            "\t\tnew = atomic_long_add_return(nr_pages, &c->usage);",
            "\t\tif (new > c->max) {",
            "\t\t\tatomic_long_sub(nr_pages, &c->usage);",
            "\t\t\t/*",
            "\t\t\t * This is racy, but we can live with some",
            "\t\t\t * inaccuracy in the failcnt which is only used",
            "\t\t\t * to report stats.",
            "\t\t\t */",
            "\t\t\tdata_race(c->failcnt++);",
            "\t\t\t*fail = c;",
            "\t\t\tgoto failed;",
            "\t\t}",
            "\t\tif (protection)",
            "\t\t\tpropagate_protected_usage(c, new);",
            "",
            "\t\t/*",
            "\t\t * Just like with failcnt, we can live with some",
            "\t\t * inaccuracy in the watermark.",
            "\t\t */",
            "\t\tif (new > READ_ONCE(c->watermark))",
            "\t\t\tWRITE_ONCE(c->watermark, new);",
            "\t}",
            "\treturn true;",
            "",
            "failed:",
            "\tfor (c = counter; c != *fail; c = c->parent)",
            "\t\tpage_counter_cancel(c, nr_pages);",
            "",
            "\treturn false;",
            "}"
          ],
          "function_name": "track_protection, propagate_protected_usage, page_counter_cancel, page_counter_charge, page_counter_try_charge",
          "description": "实现页面使用量的追踪与传播逻辑，包含受保护使用量更新、充放电操作及限制检查，通过层级传播维护父子计数器间的最小/低水位线状态同步。",
          "similarity": 0.5250527262687683
        },
        {
          "chunk_id": 0,
          "file_path": "mm/page_counter.c",
          "start_line": 1,
          "end_line": 15,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Lockless hierarchical page accounting & limiting",
            " *",
            " * Copyright (C) 2014 Red Hat, Inc., Johannes Weiner",
            " */",
            "",
            "#include <linux/page_counter.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/sched.h>",
            "#include <linux/bug.h>",
            "#include <asm/page.h>",
            ""
          ],
          "function_name": null,
          "description": "定义页面计数器相关头文件及基础宏，提供锁无关的分层页面计数与限制机制框架，声明核心结构体和辅助函数原型，为后续实现提供基础设施。",
          "similarity": 0.5017350316047668
        },
        {
          "chunk_id": 2,
          "file_path": "mm/page_counter.c",
          "start_line": 164,
          "end_line": 312,
          "content": [
            "void page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)",
            "{",
            "\tstruct page_counter *c;",
            "",
            "\tfor (c = counter; c; c = c->parent)",
            "\t\tpage_counter_cancel(c, nr_pages);",
            "}",
            "int page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)",
            "{",
            "\tfor (;;) {",
            "\t\tunsigned long old;",
            "\t\tlong usage;",
            "",
            "\t\t/*",
            "\t\t * Update the limit while making sure that it's not",
            "\t\t * below the concurrently-changing counter value.",
            "\t\t *",
            "\t\t * The xchg implies two full memory barriers before",
            "\t\t * and after, so the read-swap-read is ordered and",
            "\t\t * ensures coherency with page_counter_try_charge():",
            "\t\t * that function modifies the count before checking",
            "\t\t * the limit, so if it sees the old limit, we see the",
            "\t\t * modified counter and retry.",
            "\t\t */",
            "\t\tusage = page_counter_read(counter);",
            "",
            "\t\tif (usage > nr_pages)",
            "\t\t\treturn -EBUSY;",
            "",
            "\t\told = xchg(&counter->max, nr_pages);",
            "",
            "\t\tif (page_counter_read(counter) <= usage || nr_pages >= old)",
            "\t\t\treturn 0;",
            "",
            "\t\tcounter->max = old;",
            "\t\tcond_resched();",
            "\t}",
            "}",
            "void page_counter_set_min(struct page_counter *counter, unsigned long nr_pages)",
            "{",
            "\tstruct page_counter *c;",
            "",
            "\tWRITE_ONCE(counter->min, nr_pages);",
            "",
            "\tfor (c = counter; c; c = c->parent)",
            "\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));",
            "}",
            "void page_counter_set_low(struct page_counter *counter, unsigned long nr_pages)",
            "{",
            "\tstruct page_counter *c;",
            "",
            "\tWRITE_ONCE(counter->low, nr_pages);",
            "",
            "\tfor (c = counter; c; c = c->parent)",
            "\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));",
            "}",
            "int page_counter_memparse(const char *buf, const char *max,",
            "\t\t\t  unsigned long *nr_pages)",
            "{",
            "\tchar *end;",
            "\tu64 bytes;",
            "",
            "\tif (!strcmp(buf, max)) {",
            "\t\t*nr_pages = PAGE_COUNTER_MAX;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tbytes = memparse(buf, &end);",
            "\tif (*end != '\\0')",
            "\t\treturn -EINVAL;",
            "",
            "\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);",
            "",
            "\treturn 0;",
            "}",
            "static unsigned long effective_protection(unsigned long usage,",
            "\t\t\t\t\t  unsigned long parent_usage,",
            "\t\t\t\t\t  unsigned long setting,",
            "\t\t\t\t\t  unsigned long parent_effective,",
            "\t\t\t\t\t  unsigned long siblings_protected,",
            "\t\t\t\t\t  bool recursive_protection)",
            "{",
            "\tunsigned long protected;",
            "\tunsigned long ep;",
            "",
            "\tprotected = min(usage, setting);",
            "\t/*",
            "\t * If all cgroups at this level combined claim and use more",
            "\t * protection than what the parent affords them, distribute",
            "\t * shares in proportion to utilization.",
            "\t *",
            "\t * We are using actual utilization rather than the statically",
            "\t * claimed protection in order to be work-conserving: claimed",
            "\t * but unused protection is available to siblings that would",
            "\t * otherwise get a smaller chunk than what they claimed.",
            "\t */",
            "\tif (siblings_protected > parent_effective)",
            "\t\treturn protected * parent_effective / siblings_protected;",
            "",
            "\t/*",
            "\t * Ok, utilized protection of all children is within what the",
            "\t * parent affords them, so we know whatever this child claims",
            "\t * and utilizes is effectively protected.",
            "\t *",
            "\t * If there is unprotected usage beyond this value, reclaim",
            "\t * will apply pressure in proportion to that amount.",
            "\t *",
            "\t * If there is unutilized protection, the cgroup will be fully",
            "\t * shielded from reclaim, but we do return a smaller value for",
            "\t * protection than what the group could enjoy in theory. This",
            "\t * is okay. With the overcommit distribution above, effective",
            "\t * protection is always dependent on how memory is actually",
            "\t * consumed among the siblings anyway.",
            "\t */",
            "\tep = protected;",
            "",
            "\t/*",
            "\t * If the children aren't claiming (all of) the protection",
            "\t * afforded to them by the parent, distribute the remainder in",
            "\t * proportion to the (unprotected) memory of each cgroup. That",
            "\t * way, cgroups that aren't explicitly prioritized wrt each",
            "\t * other compete freely over the allowance, but they are",
            "\t * collectively protected from neighboring trees.",
            "\t *",
            "\t * We're using unprotected memory for the weight so that if",
            "\t * some cgroups DO claim explicit protection, we don't protect",
            "\t * the same bytes twice.",
            "\t *",
            "\t * Check both usage and parent_usage against the respective",
            "\t * protected values. One should imply the other, but they",
            "\t * aren't read atomically - make sure the division is sane.",
            "\t */",
            "\tif (!recursive_protection)",
            "\t\treturn ep;",
            "",
            "\tif (parent_effective > siblings_protected &&",
            "\t    parent_usage > siblings_protected &&",
            "\t    usage > protected) {",
            "\t\tunsigned long unclaimed;",
            "",
            "\t\tunclaimed = parent_effective - siblings_protected;",
            "\t\tunclaimed *= usage - protected;",
            "\t\tunclaimed /= parent_usage - siblings_protected;",
            "",
            "\t\tep += unclaimed;",
            "\t}",
            "",
            "\treturn ep;",
            "}"
          ],
          "function_name": "page_counter_uncharge, page_counter_set_max, page_counter_set_min, page_counter_set_low, page_counter_memparse, effective_protection",
          "description": "提供计数器阈值配置接口及内存参数解析，包含最大值设置、最小/低水位线更新和有效保护计算，实现基于实际使用情况的动态保护分配算法。",
          "similarity": 0.4345271587371826
        },
        {
          "chunk_id": 3,
          "file_path": "mm/page_counter.c",
          "start_line": 409,
          "end_line": 449,
          "content": [
            "void page_counter_calculate_protection(struct page_counter *root,",
            "\t\t\t\t       struct page_counter *counter,",
            "\t\t\t\t       bool recursive_protection)",
            "{",
            "\tunsigned long usage, parent_usage;",
            "\tstruct page_counter *parent = counter->parent;",
            "",
            "\t/*",
            "\t * Effective values of the reclaim targets are ignored so they",
            "\t * can be stale. Have a look at mem_cgroup_protection for more",
            "\t * details.",
            "\t * TODO: calculation should be more robust so that we do not need",
            "\t * that special casing.",
            "\t */",
            "\tif (root == counter)",
            "\t\treturn;",
            "",
            "\tusage = page_counter_read(counter);",
            "\tif (!usage)",
            "\t\treturn;",
            "",
            "\tif (parent == root) {",
            "\t\tcounter->emin = READ_ONCE(counter->min);",
            "\t\tcounter->elow = READ_ONCE(counter->low);",
            "\t\treturn;",
            "\t}",
            "",
            "\tparent_usage = page_counter_read(parent);",
            "",
            "\tWRITE_ONCE(counter->emin, effective_protection(usage, parent_usage,",
            "\t\t\tREAD_ONCE(counter->min),",
            "\t\t\tREAD_ONCE(parent->emin),",
            "\t\t\tatomic_long_read(&parent->children_min_usage),",
            "\t\t\trecursive_protection));",
            "",
            "\tWRITE_ONCE(counter->elow, effective_protection(usage, parent_usage,",
            "\t\t\tREAD_ONCE(counter->low),",
            "\t\t\tREAD_ONCE(parent->elow),",
            "\t\t\tatomic_long_read(&parent->children_low_usage),",
            "\t\t\trecursive_protection));",
            "}"
          ],
          "function_name": "page_counter_calculate_protection",
          "description": "计算并设置计数器的有效保护值，通过递归遍历层级关系，结合父级保护策略和当前使用比例，动态调整子级的最小/低水位线保护范围。",
          "similarity": 0.42796847224235535
        }
      ]
    },
    {
      "source_file": "mm/shuffle.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:21:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `shuffle.c`\n\n---\n\n# shuffle.c 技术文档\n\n## 1. 文件概述\n\n`shuffle.c` 实现了 Linux 内核内存管理子系统中的**页面分配随机化（Page Allocation Shuffling）**功能。该机制通过在内存初始化阶段对空闲页面链表进行 Fisher-Yates 洗牌操作，降低物理页帧分配的可预测性，从而增强系统安全性，抵御基于内存布局预测的攻击（如堆喷射、地址泄露等）。该功能默认关闭，可通过内核启动参数 `shuffle=1` 启用。\n\n## 2. 核心功能\n\n### 数据结构与全局变量\n- `page_alloc_shuffle_key`：静态分支键（static key），用于运行时启用/禁用洗牌逻辑，减少未启用时的性能开销。\n- `shuffle_param`：模块参数布尔值，控制是否启用洗牌功能。\n- `shuffle_param_ops`：自定义模块参数操作集，用于处理 `shuffle` 参数的设置和读取。\n\n### 主要函数\n- `shuffle_param_set()`：解析并设置 `shuffle` 内核参数，若启用则激活 `page_alloc_shuffle_key`。\n- `shuffle_valid_page()`：验证指定 PFN 的页面是否满足洗牌条件（属于 buddy 系统、同 zone、空闲、相同 order 和 migratetype）。\n- `__shuffle_zone()`：对指定内存区域（zone）执行 Fisher-Yates 洗牌算法，随机交换同阶空闲页面。\n- `__shuffle_free_memory()`：遍历节点（pgdat）中所有 zone，依次调用 `shuffle_zone()` 进行洗牌。\n- `shuffle_pick_tail()`：提供轻量级随机位生成器，用于在分配时决定从链表头部还是尾部取页（增强运行时随机性）。\n\n## 3. 关键实现\n\n### 洗牌算法（Fisher-Yates）\n- **粒度**：以 `SHUFFLE_ORDER`（通常为 0，即单页）为单位进行洗牌。\n- **范围**：遍历 zone 内所有按 order 对齐的 PFN，对每个有效页面 `page_i` 随机选择另一个有效页面 `page_j` 进行交换。\n- **有效性校验**：通过 `shuffle_valid_page()` 确保交换双方均为 buddy 系统管理的空闲页，且具有相同的迁移类型（migratetype）。\n- **重试机制**：最多尝试 `SHUFFLE_RETRY`（10 次）寻找有效的随机目标页，避免因内存空洞导致失败。\n- **锁优化**：每处理 100 个页面后释放 zone 自旋锁并调度，防止长时间持锁影响系统响应。\n\n### 随机性来源\n- 使用 `get_random_long()` 获取高质量伪随机数作为洗牌索引。\n- `shuffle_pick_tail()` 使用无锁的 64 位随机状态生成器，每次返回最低位并右移，用于运行时分配策略的微调。\n\n### 安全性权衡\n- 明确承认不消除模运算偏差（modulo bias）或 PRNG 偏差，目标是“提高攻击门槛”而非完美随机。\n- 仅在内存初始化阶段（`__meminit`）执行一次洗牌，不影响运行时分配性能。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/mm.h>`、`<linux/mmzone.h>`：内存管理核心数据结构（`struct zone`, `struct page`）。\n  - `<linux/random.h>`：提供 `get_random_long()` 和 `get_random_u64()`。\n  - `\"internal.h\"`、`\"shuffle.h\"`：内核 MM 子系统内部接口及洗牌功能声明。\n- **功能依赖**：\n  - Buddy 分配器：依赖 `PageBuddy()`、`buddy_order()` 等接口判断页面状态。\n  - 页面迁移类型（Migratetype）：确保洗牌不破坏不同迁移类型页面的隔离。\n  - 静态分支（Static Keys）：通过 `static_branch_enable()` 动态启用洗牌路径。\n\n## 5. 使用场景\n\n- **安全加固**：在需要防范物理地址预测攻击的场景（如虚拟化宿主机、安全敏感设备）中启用，增加攻击者利用内存布局漏洞的难度。\n- **内核初始化**：在 `free_area_init_core()` 等内存子系统初始化流程中调用 `__shuffle_free_memory()`，对初始空闲内存进行一次性洗牌。\n- **运行时分配辅助**：`shuffle_pick_tail()` 被页面分配器调用，决定从空闲链表头/尾取页，进一步增加分配时序的不可预测性。\n- **调试支持**：通过 `pr_debug()` 输出洗牌失败或迁移类型不匹配的日志，便于问题诊断（需开启 `DEBUG_SHUFFLE`）。",
      "similarity": 0.5828247666358948,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/shuffle.c",
          "start_line": 16,
          "end_line": 121,
          "content": [
            "static __meminit int shuffle_param_set(const char *val,",
            "\t\tconst struct kernel_param *kp)",
            "{",
            "\tif (param_set_bool(val, kp))",
            "\t\treturn -EINVAL;",
            "\tif (*(bool *)kp->arg)",
            "\t\tstatic_branch_enable(&page_alloc_shuffle_key);",
            "\treturn 0;",
            "}",
            "void __meminit __shuffle_zone(struct zone *z)",
            "{",
            "\tunsigned long i, flags;",
            "\tunsigned long start_pfn = z->zone_start_pfn;",
            "\tunsigned long end_pfn = zone_end_pfn(z);",
            "\tconst int order = SHUFFLE_ORDER;",
            "\tconst int order_pages = 1 << order;",
            "",
            "\tspin_lock_irqsave(&z->lock, flags);",
            "\tstart_pfn = ALIGN(start_pfn, order_pages);",
            "\tfor (i = start_pfn; i < end_pfn; i += order_pages) {",
            "\t\tunsigned long j;",
            "\t\tint migratetype, retry;",
            "\t\tstruct page *page_i, *page_j;",
            "",
            "\t\t/*",
            "\t\t * We expect page_i, in the sub-range of a zone being added",
            "\t\t * (@start_pfn to @end_pfn), to more likely be valid compared to",
            "\t\t * page_j randomly selected in the span @zone_start_pfn to",
            "\t\t * @spanned_pages.",
            "\t\t */",
            "\t\tpage_i = shuffle_valid_page(z, i, order);",
            "\t\tif (!page_i)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (retry = 0; retry < SHUFFLE_RETRY; retry++) {",
            "\t\t\t/*",
            "\t\t\t * Pick a random order aligned page in the zone span as",
            "\t\t\t * a swap target. If the selected pfn is a hole, retry",
            "\t\t\t * up to SHUFFLE_RETRY attempts find a random valid pfn",
            "\t\t\t * in the zone.",
            "\t\t\t */",
            "\t\t\tj = z->zone_start_pfn +",
            "\t\t\t\tALIGN_DOWN(get_random_long() % z->spanned_pages,",
            "\t\t\t\t\t\torder_pages);",
            "\t\t\tpage_j = shuffle_valid_page(z, j, order);",
            "\t\t\tif (page_j && page_j != page_i)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (retry >= SHUFFLE_RETRY) {",
            "\t\t\tpr_debug(\"%s: failed to swap %#lx\\n\", __func__, i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Each migratetype corresponds to its own list, make sure the",
            "\t\t * types match otherwise we're moving pages to lists where they",
            "\t\t * do not belong.",
            "\t\t */",
            "\t\tmigratetype = get_pageblock_migratetype(page_i);",
            "\t\tif (get_pageblock_migratetype(page_j) != migratetype) {",
            "\t\t\tpr_debug(\"%s: migratetype mismatch %#lx\\n\", __func__, i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tlist_swap(&page_i->lru, &page_j->lru);",
            "",
            "\t\tpr_debug(\"%s: swap: %#lx -> %#lx\\n\", __func__, i, j);",
            "",
            "\t\t/* take it easy on the zone lock */",
            "\t\tif ((i % (100 * order_pages)) == 0) {",
            "\t\t\tspin_unlock_irqrestore(&z->lock, flags);",
            "\t\t\tcond_resched();",
            "\t\t\tspin_lock_irqsave(&z->lock, flags);",
            "\t\t}",
            "\t}",
            "\tspin_unlock_irqrestore(&z->lock, flags);",
            "}",
            "void __meminit __shuffle_free_memory(pg_data_t *pgdat)",
            "{",
            "\tstruct zone *z;",
            "",
            "\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)",
            "\t\tshuffle_zone(z);",
            "}",
            "bool shuffle_pick_tail(void)",
            "{",
            "\tstatic u64 rand;",
            "\tstatic u8 rand_bits;",
            "\tbool ret;",
            "",
            "\t/*",
            "\t * The lack of locking is deliberate. If 2 threads race to",
            "\t * update the rand state it just adds to the entropy.",
            "\t */",
            "\tif (rand_bits == 0) {",
            "\t\trand_bits = 64;",
            "\t\trand = get_random_u64();",
            "\t}",
            "",
            "\tret = rand & 1;",
            "",
            "\trand_bits--;",
            "\trand >>= 1;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "shuffle_param_set, __shuffle_zone, __shuffle_free_memory, shuffle_pick_tail",
          "description": "shuffle_param_set设置参数并启用/禁用静态键；__shuffle_zone在内存区随机交换页面以打乱物理顺序；__shuffle_free_memory初始化时调用__shuffle_zone；shuffle_pick_tail生成随机布尔值用于选择尾部页",
          "similarity": 0.5433977842330933
        },
        {
          "chunk_id": 0,
          "file_path": "mm/shuffle.c",
          "start_line": 1,
          "end_line": 15,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright(c) 2018 Intel Corporation. All rights reserved.",
            "",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/random.h>",
            "#include <linux/moduleparam.h>",
            "#include \"internal.h\"",
            "#include \"shuffle.h\"",
            "",
            "DEFINE_STATIC_KEY_FALSE(page_alloc_shuffle_key);",
            "",
            "static bool shuffle_param;",
            ""
          ],
          "function_name": null,
          "description": "定义静态键用于控制页面分配随机化功能，并声明参数变量shuffle_param，用于启用或禁用相关机制",
          "similarity": 0.44374531507492065
        }
      ]
    },
    {
      "source_file": "mm/debug_page_alloc.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:54:55\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `debug_page_alloc.c`\n\n---\n\n# debug_page_alloc.c 技术文档\n\n## 1. 文件概述\n\n`debug_page_alloc.c` 是 Linux 内核中用于支持页分配调试功能的核心实现文件。该文件主要提供两个关键调试机制：\n\n- **页分配调试（debug_pagealloc）**：在内存分配/释放时对页面进行特殊标记和保护，用于检测内存越界访问、重复释放等错误。\n- **守护页（guard page）机制**：在分配的大块内存前后插入不可访问的“守护页”，用于捕获缓冲区溢出等内存破坏问题。\n\n该文件通过内核启动参数控制调试功能的启用状态和行为参数，并提供底层页标志操作接口供内存管理子系统调用。\n\n## 2. 核心功能\n\n### 全局变量\n- `_debug_guardpage_minorder`：守护页机制生效的最小分配阶数阈值\n- `_debug_pagealloc_enabled_early`：早期启动阶段页分配调试的启用状态\n- `_debug_pagealloc_enabled`：运行时页分配调试功能的静态键开关\n- `_debug_guardpage_enabled`：守护页功能的静态键开关\n\n### 函数接口\n- `early_debug_pagealloc()`：解析 `debug_pagealloc=` 内核启动参数\n- `debug_guardpage_minorder_setup()`：解析 `debug_guardpage_minorder=` 内核启动参数\n- `__set_page_guard()`：为指定页面设置守护页标志和相关属性\n- `__clear_page_guard()`：清除页面的守护页标志和相关属性\n\n### 宏定义\n- `debug_guardpage_minorder()`：获取当前守护页最小阶数值（内联函数）\n\n## 3. 关键实现\n\n### 启动参数处理\n- **`debug_pagealloc` 参数**：通过 `early_param()` 在内核早期初始化阶段解析布尔值参数，控制 `_debug_pagealloc_enabled_early` 的初始状态\n- **`debug_guardpage_minorder` 参数**：解析无符号长整型参数，验证其有效性（0 ≤ value ≤ MAX_PAGE_ORDER/2），设置 `_debug_guardpage_minorder` 全局变量\n\n### 守护页管理\n- **设置守护页 (`__set_page_guard`)**：\n  - 仅当请求的分配阶数小于 `_debug_guardpage_minorder` 时才启用守护页\n  - 设置 `PG_guard` 页面标志位\n  - 初始化 buddy_list 为空链表（防止误用）\n  - 将分配阶数存储在 page->private 字段中\n- **清除守护页 (`__clear_page_guard`)**：\n  - 清除 `PG_guard` 标志位\n  - 将 page->private 重置为 0\n\n### 静态键优化\n- 使用 `DEFINE_STATIC_KEY_FALSE` 定义运行时开关，避免调试代码路径的性能开销\n- 通过 `EXPORT_SYMBOL` 导出符号供其他内核模块使用\n\n## 4. 依赖关系\n\n### 头文件依赖\n- `<linux/mm.h>`：提供核心内存管理数据结构和函数声明\n- `<linux/page-isolation.h>`：提供页面隔离相关功能（如 `__SetPageGuard` 等宏定义）\n\n### 内核配置依赖\n- `CONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT`：控制默认是否启用页分配调试功能\n- `MAX_PAGE_ORDER`：定义最大分配阶数常量，用于参数验证\n\n### 符号导出\n- `_debug_pagealloc_enabled_early` 和 `_debug_pagealloc_enabled` 被导出，供内存管理子系统（如伙伴系统）查询调试状态\n\n## 5. 使用场景\n\n### 内存错误检测\n- 在开发和调试阶段启用 `debug_pagealloc=1`，可检测内存越界写入、使用已释放内存等问题\n- 守护页机制特别适用于捕获大内存块分配时的缓冲区溢出错误\n\n### 性能敏感环境\n- 默认情况下调试功能关闭，避免运行时性能开销\n- 通过静态键机制确保禁用时调试代码路径完全不执行\n\n### 内核启动配置\n- 系统管理员可通过内核命令行参数动态调整调试行为：\n  - `debug_pagealloc=1` 启用页分配调试\n  - `debug_guardpage_minorder=N` 设置守护页触发的最小分配阶数\n\n### 内存管理子系统集成\n- 伙伴系统（buddy allocator）在页面分配/释放时调用 `__set_page_guard()` 和 `__clear_page_guard()` 管理守护页状态\n- 页面迁移、内存热插拔等子系统依赖此模块提供的页面状态管理功能",
      "similarity": 0.5800060629844666,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/debug_page_alloc.c",
          "start_line": 15,
          "end_line": 46,
          "content": [
            "static int __init early_debug_pagealloc(char *buf)",
            "{",
            "\treturn kstrtobool(buf, &_debug_pagealloc_enabled_early);",
            "}",
            "static int __init debug_guardpage_minorder_setup(char *buf)",
            "{",
            "\tunsigned long res;",
            "",
            "\tif (kstrtoul(buf, 10, &res) < 0 ||  res > MAX_PAGE_ORDER / 2) {",
            "\t\tpr_err(\"Bad debug_guardpage_minorder value\\n\");",
            "\t\treturn 0;",
            "\t}",
            "\t_debug_guardpage_minorder = res;",
            "\tpr_info(\"Setting debug_guardpage_minorder to %lu\\n\", res);",
            "\treturn 0;",
            "}",
            "bool __set_page_guard(struct zone *zone, struct page *page, unsigned int order)",
            "{",
            "\tif (order >= debug_guardpage_minorder())",
            "\t\treturn false;",
            "",
            "\t__SetPageGuard(page);",
            "\tINIT_LIST_HEAD(&page->buddy_list);",
            "\tset_page_private(page, order);",
            "",
            "\treturn true;",
            "}",
            "void __clear_page_guard(struct zone *zone, struct page *page, unsigned int order)",
            "{",
            "\t__ClearPageGuard(page);",
            "\tset_page_private(page, 0);",
            "}"
          ],
          "function_name": "early_debug_pagealloc, debug_guardpage_minorder_setup, __set_page_guard, __clear_page_guard",
          "description": "实现早期调试参数解析、最小订单值设置及页保护状态管理逻辑，通过订单阈值控制是否对页面添加守护标志并修改页面私有数据",
          "similarity": 0.48965001106262207
        },
        {
          "chunk_id": 0,
          "file_path": "mm/debug_page_alloc.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/mm.h>",
            "#include <linux/page-isolation.h>",
            "",
            "unsigned int _debug_guardpage_minorder;",
            "",
            "bool _debug_pagealloc_enabled_early __read_mostly",
            "\t\t\t= IS_ENABLED(CONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT);",
            "EXPORT_SYMBOL(_debug_pagealloc_enabled_early);",
            "DEFINE_STATIC_KEY_FALSE(_debug_pagealloc_enabled);",
            "EXPORT_SYMBOL(_debug_pagealloc_enabled);",
            "",
            "DEFINE_STATIC_KEY_FALSE(_debug_guardpage_enabled);",
            ""
          ],
          "function_name": null,
          "description": "定义调试页面分配相关全局变量及符号导出，用于控制早期调试功能启用状态和静态键，支持动态开关调试页保护机制",
          "similarity": 0.4460732340812683
        }
      ]
    }
  ]
}