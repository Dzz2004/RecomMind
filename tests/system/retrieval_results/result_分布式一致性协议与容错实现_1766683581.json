{
  "query": "分布式一致性协议与容错实现",
  "timestamp": "2025-12-26 01:26:21",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/affinity.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:46:53\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\affinity.c`\n\n---\n\n# `irq/affinity.c` 技术文档\n\n## 1. 文件概述\n\n`irq/affinity.c` 是 Linux 内核中用于管理中断亲和性（IRQ affinity）的核心实现文件，主要负责为多队列设备（如多队列网卡、NVMe SSD 等）动态生成合理的 CPU 亲和性掩码（cpumask），以实现中断在多个 CPU 核心上的均衡分布。该文件提供了两个关键接口：  \n- `irq_create_affinity_masks()`：根据设备需求和系统 CPU 拓扑，生成每中断向量对应的 CPU 亲和性掩码。  \n- `irq_calc_affinity_vectors()`：计算在给定约束下可有效用于亲和性分配的最优中断向量数量。  \n\n该机制支持将中断向量划分为多个“集合”（sets），每个集合可独立分配 CPU 资源，适用于需要分层或分组中断处理的复杂设备。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`irq_create_affinity_masks(unsigned int nvecs, struct irq_affinity *affd)`**  \n  为指定数量的中断向量生成亲和性掩码数组。支持预定义（pre_vectors）、可管理（managed）和后置（post_vectors）三类中断向量，并通过 `group_cpus_evenly()` 实现 CPU 均匀分配。\n\n- **`irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec, const struct irq_affinity *affd)`**  \n  在 `[minvec, maxvec]` 范围内计算可用于亲和性分配的最优中断向量总数，考虑设备保留向量和系统 CPU 数量限制。\n\n### 关键数据结构\n\n- **`struct irq_affinity`**（定义于 `<linux/interrupt.h>`）  \n  描述中断亲和性分配需求：\n  - `pre_vectors` / `post_vectors`：保留的前后固定向量数（通常用于管理或特殊用途）。\n  - `calc_sets`：回调函数，用于自定义如何将可分配向量划分为多个集合（sets）。\n  - `nr_sets` / `set_size[]`：由 `calc_sets` 填充，表示集合数量及每个集合的向量数。\n\n- **`struct irq_affinity_desc`**（定义于 `<linux/interrupt.h>`）  \n  单个中断向量的亲和性描述：\n  - `mask`：该向量绑定的 CPU 掩码。\n  - `is_managed`：标志位，表示该向量是否由内核自动管理亲和性。\n\n### 辅助函数\n\n- **`default_calc_sets(struct irq_affinity *affd, unsigned int affvecs)`**  \n  默认的集合划分策略：将所有可分配向量归入单个集合。\n\n## 3. 关键实现\n\n### 亲和性掩码生成流程（`irq_create_affinity_masks`）\n\n1. **计算可分配向量数**：  \n   `affvecs = nvecs - pre_vectors - post_vectors`，若结果 ≤0 则无需分配。\n\n2. **设置集合划分策略**：  \n   若用户未提供 `calc_sets` 回调，则使用 `default_calc_sets`（单集合）。\n\n3. **生成每集合的 CPU 掩码**：  \n   对每个集合调用 `group_cpus_evenly(this_vecs)`，该函数根据系统 CPU 拓扑（如 NUMA、超线程）将 `this_vecs` 个中断均匀分配到物理 CPU 上，返回一个 `cpumask` 数组。\n\n4. **填充掩码数组**：  \n   - 前 `pre_vectors` 个向量：使用全局默认亲和性 `irq_default_affinity`。\n   - 中间 `affvecs` 个向量：按集合依次填充 `group_cpus_evenly` 的结果。\n   - 后 `post_vectors` 个向量：同样使用默认亲和性。\n   - 标记 `pre_vectors` 到 `nvecs - post_vectors` 之间的向量为 `is_managed = 1`。\n\n### 向量数量计算（`irq_calc_affinity_vectors`）\n\n- 若设备保留向量数（`resv = pre + post`）超过 `minvec`，返回 0（无法满足最小需求）。\n- 若提供 `calc_sets` 回调，则最大可分配向量数为 `maxvec - resv`。\n- 否则，以系统可能 CPU 数（`cpu_possible_mask`）为上限。\n- 最终结果：`resv + min(可分配向量上限, maxvec - resv)`。\n\n### 错误处理\n\n- 集合数超过 `IRQ_AFFINITY_MAX_SETS`（通常为 4）时触发 `WARN_ON_ONCE` 并返回 `NULL`。\n- 内存分配失败或 `group_cpus_evenly` 失败时释放已分配资源并返回 `NULL`。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/interrupt.h>`：定义 `irq_affinity`、`irq_affinity_desc` 等核心结构。\n  - `<linux/group_cpus.h>`：提供 `group_cpus_evenly()` 函数，实现基于拓扑的 CPU 分组。\n  - `<linux/cpu.h>`：访问 CPU 掩码（如 `cpu_possible_mask`）和锁机制（`cpus_read_lock/unlock`）。\n  - `<linux/slab.h>`：内存分配（`kcalloc`/`kfree`）。\n  - `<linux/kernel.h>`：基础内核 API（如 `WARN_ON_ONCE`、`min` 宏）。\n\n- **内核子系统**：\n  - **中断子系统**：与 `irqdesc`、`irqdomain` 等模块协同工作。\n  - **CPU 拓扑管理**：依赖 `group_cpus_evenly` 的底层实现（位于 `kernel/cpu.c`），该函数利用调度域（sched domain）信息进行 CPU 分组。\n\n## 5. 使用场景\n\n- **多队列设备驱动初始化**：  \n  网卡（如 `ixgbe`、`mlx5`）、NVMe SSD 等驱动在申请 MSI-X 中断时，调用 `irq_create_affinity_masks` 生成亲和性掩码，再通过 `pci_alloc_irq_vectors_affinity()` 申请中断，实现中断在 CPU 间的负载均衡。\n\n- **动态中断向量调整**：  \n  设备在运行时调整队列数量时，通过 `irq_calc_affinity_vectors` 计算可用向量数，确保不超过硬件和系统限制。\n\n- **NUMA 感知中断分配**：  \n  `group_cpus_evenly` 自动考虑 NUMA 节点拓扑，使同一队列的中断优先分配到同一 NUMA 节点的 CPU，减少跨节点访问延迟。\n\n- **保留中断向量处理**：  \n  设备可保留部分向量用于管理任务（如 `pre_vectors` 用于控制队列，`post_vectors` 用于错误处理），其余向量交由内核自动分配亲和性。",
      "similarity": 0.5407859086990356,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/affinity.c",
          "start_line": 12,
          "end_line": 35,
          "content": [
            "static void default_calc_sets(struct irq_affinity *affd, unsigned int affvecs)",
            "{",
            "\taffd->nr_sets = 1;",
            "\taffd->set_size[0] = affvecs;",
            "}",
            "unsigned int irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec,",
            "\t\t\t\t       const struct irq_affinity *affd)",
            "{",
            "\tunsigned int resv = affd->pre_vectors + affd->post_vectors;",
            "\tunsigned int set_vecs;",
            "",
            "\tif (resv > minvec)",
            "\t\treturn 0;",
            "",
            "\tif (affd->calc_sets) {",
            "\t\tset_vecs = maxvec - resv;",
            "\t} else {",
            "\t\tcpus_read_lock();",
            "\t\tset_vecs = cpumask_weight(cpu_possible_mask);",
            "\t\tcpus_read_unlock();",
            "\t}",
            "",
            "\treturn resv + min(set_vecs, maxvec - resv);",
            "}"
          ],
          "function_name": "default_calc_sets, irq_calc_affinity_vectors",
          "description": "定义默认亲和性集合计算函数并实现向量分配策略，用于确定中断向量在CPU核心间的分布方式",
          "similarity": 0.5517525672912598
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/affinity.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2016 Thomas Gleixner.",
            " * Copyright (C) 2016-2017 Christoph Hellwig.",
            " */",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpu.h>",
            "#include <linux/group_cpus.h>",
            ""
          ],
          "function_name": null,
          "description": "包含中断亲和性管理所需的头文件，为IRQ核心亲和性配置提供基础支持",
          "similarity": 0.49878939986228943
        }
      ]
    },
    {
      "source_file": "kernel/rcu/tree_plugin.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:48:59\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `rcu\\tree_plugin.h`\n\n---\n\n# `rcu/tree_plugin.h` 技术文档\n\n## 1. 文件概述\n\n`rcu/tree_plugin.h` 是 Linux 内核中 **树形 RCU（Read-Copy Update）机制** 的内部头文件，用于实现基于分层树结构的 RCU 互斥机制。该文件定义了适用于 **经典 RCU** 或 **可抢占 RCU（PREEMPT_RCU）** 的内部非公开接口和辅助函数，主要服务于 `kernel/rcu/tree.c` 等核心 RCU 实现模块。其核心目标是在大规模 CPU 系统中高效管理宽限期（Grace Period）的检测与回调处理，同时支持 NOCB（No-CBs，即回调卸载）等高级特性。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`rcu_rdp_is_offloaded(struct rcu_data *rdp)`**  \n  安全地判断指定 CPU 的 `rcu_data` 是否启用了 NOCB（回调卸载）模式。该函数包含严格的锁依赖检查（通过 `RCU_LOCKDEP_WARN`），确保在读取 `offloaded` 状态时不会因并发修改导致数据不一致。\n\n- **`rcu_bootup_announce_oddness(void)`**  \n  在内核启动阶段检测并打印所有非默认或调试相关的 RCU 配置参数，用于诊断和性能调优。涵盖内容包括：扇出（fanout）设置、回调水位线、FQS（Force Quiescent State）延迟、软中断处理方式、调试选项等。\n\n- **`rcu_bootup_announce(void)`**（仅 `CONFIG_PREEMPT_RCU`）  \n  启动时声明当前使用的是“可抢占的分层 RCU 实现”，并调用 `rcu_bootup_announce_oddness()` 输出配置异常信息。\n\n- **`rcu_preempt_ctxt_queue(struct rcu_node *rnp, struct rcu_data *rdp)`**（仅 `CONFIG_PREEMPT_RCU`）  \n  将当前被抢占且处于 RCU 读侧临界区的任务插入到 `rcu_node` 的阻塞任务链表（`blkd_tasks`）中的合适位置。其插入策略基于当前是否存在普通或加速宽限期（GP/EXP GP），以及当前 CPU 是否被这些宽限期阻塞，以最小化对已有宽限期的不必要阻塞。\n\n### 关键宏定义（仅 `CONFIG_PREEMPT_RCU`）\n\n- **`RCU_GP_TASKS` / `RCU_EXP_TASKS` / `RCU_GP_BLKD` / `RCU_EXP_BLKD`**  \n  用于构建决策表，表示 `rcu_node` 中普通/加速宽限期的等待状态及当前 CPU 的阻塞状态，指导 `rcu_preempt_ctxt_queue()` 的任务插入逻辑。\n\n## 3. 关键实现\n\n### 安全读取 NOCB 状态\n`rcu_rdp_is_offloaded()` 通过 `RCU_LOCKDEP_WARN` 强制要求调用者必须持有以下任一同步原语：\n- `rcu_state.barrier_mutex`\n- CPU 热插拔锁（读/写）\n- 对应 `rdp` 的 NOCB 锁\n- 在本地 CPU 且不可抢占（非 `CONFIG_PREEMPT_COUNT` 或不可抢占上下文）\n- 当前为 NOCB 内核线程  \n这确保了在读取 `rdp->cblist` 的 `offloaded` 标志时，其值不会被并发修改。\n\n### 可抢占 RCU 的任务阻塞队列策略\n在 `CONFIG_PREEMPT_RCU` 下，当任务在 RCU 读侧临界区内被抢占时，需将其加入 `rcu_node->blkd_tasks` 链表。`rcu_preempt_ctxt_queue()` 使用 **状态决策表**（基于 `blkd_state` 的 4 位组合）决定插入位置：\n- **插入链表头部**：当任务不会阻塞任何**已存在的**宽限期（尤其是加速宽限期）时，避免延长已有宽限期。\n- **插入链表尾部**（代码未完整显示，但逻辑隐含）：当任务会阻塞已有宽限期时，需排在末尾以确保正确性。  \n该策略优先保护**加速宽限期**的低延迟特性，即使可能轻微延长普通宽限期。\n\n### 启动配置诊断\n`rcu_bootup_announce_oddness()` 系统性地检查数十个编译时和运行时 RCU 参数，对任何非默认值或启用的调试功能输出 `pr_info` 日志。这为系统管理员和开发者提供了 RCU 行为的透明视图，便于性能分析和问题排查。\n\n## 4. 依赖关系\n\n- **内部依赖**：\n  - `../locking/rtmutex_common.h`：提供 `lockdep_is_cpus_held()` 等锁依赖检查宏。\n  - `rcu_segcblist_is_offloaded()`：来自 RCU 回调段管理模块，用于查询 NOCB 状态。\n  - `rcu_lockdep_is_held_nocb()`、`rcu_current_is_nocb_kthread()`：NOCB 相关的锁依赖和上下文检查函数。\n  - `rcupdate_announce_bootup_oddness()`：来自 `kernel/rcu/update.c`，用于打印通用 RCU 启动信息。\n\n- **配置依赖**：\n  - `CONFIG_PREEMPT_RCU`：启用可抢占 RCU 的特定逻辑（如任务阻塞队列）。\n  - `CONFIG_RCU_TRACE`、`CONFIG_PROVE_RCU`、`CONFIG_RCU_BOOST` 等：控制启动诊断信息的输出。\n  - `CONFIG_HOTPLUG_CPU`：影响 CPU 热插拔锁的检查逻辑。\n\n- **数据结构依赖**：\n  - `struct rcu_data`、`struct rcu_node`：RCU 核心数据结构，定义在 `kernel/rcu/tree.h`。\n  - `rcu_state`：全局 RCU 状态结构体。\n\n## 5. 使用场景\n\n- **内核启动阶段**：  \n  `rcu_bootup_announce()` 和 `rcu_bootup_announce_oddness()` 在 RCU 初始化时被调用，输出配置诊断信息，帮助确认 RCU 子系统按预期配置。\n\n- **NOCB（回调卸载）模式运行时**：  \n  当系统启用 `CONFIG_RCU_NOCB_CPU` 时，`rcu_rdp_is_offloaded()` 被频繁调用（如在回调处理、宽限期推进路径中），以安全判断当前 CPU 的回调是否由专用内核线程处理。\n\n- **可抢占内核中的任务调度**：  \n  在 `CONFIG_PREEMPT_RCU` 系统中，当任务在 RCU 读侧临界区内被抢占时，调度器路径会调用 `rcu_preempt_ctxt_queue()`，将任务加入阻塞链表，确保宽限期能正确等待该任务退出临界区。\n\n- **调试与性能分析**：  \n  启动时的“oddness”日志为 RCU 调优提供依据；`RCU_LOCKDEP_WARN` 等检查帮助开发者发现 RCU 状态访问的同步错误。",
      "similarity": 0.527582049369812,
      "chunks": []
    },
    {
      "source_file": "kernel/capability.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:39:00\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `capability.c`\n\n---\n\n# capability.c 技术文档\n\n## 1. 文件概述\n\n`capability.c` 是 Linux 内核中实现 POSIX 能力（Capabilities）机制的核心文件，位于 `kernel/` 目录下。该文件主要负责提供用户空间与内核之间进行能力获取（`capget`）和设置（`capset`）的系统调用接口，并维护能力模型的版本兼容性、安全策略检查以及与 LSM（Linux Security Module）框架的集成。能力机制允许将传统超级用户权限细分为多个独立的特权单元，从而实现最小权限原则。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `file_caps_enabled`：控制是否启用文件能力（File Capabilities）功能的全局开关，默认启用。可通过内核启动参数 `no_file_caps` 禁用。\n\n### 主要函数\n- **`cap_validate_magic()`**：验证用户传入的能力结构体版本号，支持 v1、v2、v3 版本，并对旧版本发出警告。\n- **`cap_get_target_pid()`**：安全地获取指定进程（通过 PID）的有效（Effective）、可继承（Inheritable）和允许（Permitted）能力集。\n- **`sys_capget()`**：`capget(2)` 系统调用的实现，用于查询指定进程的能力集。\n- **`sys_capset()`**：`capset(2)` 系统调用的实现，用于设置当前进程的能力集（仅限自身）。\n- **`mk_kernel_cap()`**：将用户空间传入的高低 32 位能力值组合成内核内部的 `kernel_cap_t` 类型。\n- **`has_ns_capability()`**（截断）：检查指定任务在给定用户命名空间中是否拥有某项能力（函数体在提供的代码中被截断）。\n\n### 辅助函数\n- `warn_legacy_capability_use()`：对使用 v1（32 位）能力接口的应用程序发出一次性警告。\n- `warn_deprecated_v2()`：对使用已弃用的 v2 能力接口的应用程序发出一次性警告。\n\n## 3. 关键实现\n\n### 能力版本兼容性处理\n- 支持三种能力结构版本：\n  - **v1 (`_LINUX_CAPABILITY_VERSION_1`)**：仅支持 32 位能力（旧版），调用时触发 `warn_legacy_capability_use()`。\n  - **v2 (`_LINUX_CAPABILITY_VERSION_2`)**：支持 64 位能力但存在安全风险，调用时触发 `warn_deprecated_v2()`。\n  - **v3 (`_LINUX_CAPABILITY_VERSION_3`)**：当前推荐版本，功能等同于 v2 但通过头文件变更避免误用。\n- 对于无效版本，内核会尝试将当前支持的版本号写回用户空间并返回 `-EINVAL`。\n\n### 能力数据传输格式\n- 用户空间使用两个 `__user_cap_data_struct` 结构体（`kdata[2]`）来表示 64 位能力值：\n  - `kdata[0]` 存储低 32 位\n  - `kdata[1]` 存储高 32 位\n- 在 `capget` 中，内核能力值被拆分为高低 32 位写入用户缓冲区；在 `capset` 中则反向组合。\n- **向后兼容策略**：当用户空间请求的版本只支持 32 位（`tocopy = 1`）时，内核会静默丢弃高 32 位能力，避免旧版 `libcap` 应用崩溃。\n\n### 安全限制\n- **`capset` 限制**：仅允许进程修改自身能力（`pid` 必须为 0 或当前进程 PID），修改其他进程能力的功能已被移除。\n- **能力设置规则**（由 LSM 实现，如 `security_capset`）：\n  - 新的 **可继承集（I）** 和 **允许集（P）** 只能是旧允许集的子集。\n  - 新的 **有效集（E）** 必须是新允许集的子集。\n- 使用 `prepare_creds()` / `commit_creds()` 机制安全地更新进程凭证（credentials），并在失败时通过 `abort_creds()` 回滚。\n\n### 并发与锁机制\n- 获取**其他进程**能力时，使用 `rcu_read_lock()` 保护对进程链表的访问（通过 `find_task_by_vpid()`）。\n- 获取**当前进程**能力时无需加锁，因为能力修改是原子的（通过凭证替换）。\n\n### 审计与日志\n- `capset` 成功时调用 `audit_log_capset()` 记录能力变更事件，用于安全审计。\n- 对旧版能力接口的使用通过 `pr_info_once()` 发出一次性内核日志警告。\n\n## 4. 依赖关系\n\n- **LSM 框架**：通过 `security_capget()` 和 `security_capset()` 钩子与安全模块（如 SELinux、AppArmor）交互，实际的能力检查和设置策略由 LSM 实现。\n- **凭证子系统**：依赖 `cred` 结构体管理进程权限，使用 `prepare_creds()`、`commit_creds()` 等函数安全更新。\n- **命名空间**：支持用户命名空间（`user_namespace.h`），能力检查与命名空间隔离相关（体现在 `has_ns_capability` 等函数中）。\n- **审计子系统**：通过 `audit.h` 提供能力变更的审计日志。\n- **系统调用接口**：通过 `SYSCALL_DEFINE2` 定义 `capget` 和 `capset` 系统调用。\n- **用户空间访问**：使用 `uaccess.h` 中的 `copy_to_user()` 和 `copy_from_user()` 安全传输数据。\n\n## 5. 使用场景\n\n- **容器与沙箱**：容器运行时（如 Docker、runc）通过 `capset` 限制容器内进程的能力集，实现权限隔离。\n- **特权程序降权**：需要临时提升权限的程序（如 `ping` 使用 `CAP_NET_RAW`）可在执行关键操作后通过 `capset` 丢弃多余能力。\n- **安全策略实施**：系统管理员或安全模块通过限制进程能力，遵循最小权限原则，减少攻击面。\n- **调试与监控**：安全工具（如 `getpcaps`）通过 `capget` 查询进程当前能力状态，用于诊断或合规检查。\n- **文件能力加载**：虽然本文件不直接处理文件能力，但 `file_caps_enabled` 开关控制是否启用基于文件扩展属性（xattr）的能力加载机制（由 `fs/` 子系统实现）。",
      "similarity": 0.5269182324409485,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/capability.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * linux/kernel/capability.c",
            " *",
            " * Copyright (C) 1997  Andrew Main <zefram@fysh.org>",
            " *",
            " * Integrated into 2.1.97+,  Andrew G. Morgan <morgan@kernel.org>",
            " * 30 May 2002:\tCleanup, Robert M. Love <rml@tech9.net>",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/uaccess.h>",
            "",
            "int file_caps_enabled = 1;",
            ""
          ],
          "function_name": null,
          "description": "声明模块许可证并包含必要的头文件，定义控制文件能力启用状态的全局变量file_caps_enabled",
          "similarity": 0.49047625064849854
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/capability.c",
          "start_line": 25,
          "end_line": 125,
          "content": [
            "static int __init file_caps_disable(char *str)",
            "{",
            "\tfile_caps_enabled = 0;",
            "\treturn 1;",
            "}",
            "static void warn_legacy_capability_use(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static void warn_deprecated_v2(void)",
            "{",
            "\tchar name[sizeof(current->comm)];",
            "",
            "\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",",
            "\t\t     get_task_comm(name, current));",
            "}",
            "static int cap_validate_magic(cap_user_header_t header, unsigned *tocopy)",
            "{",
            "\t__u32 version;",
            "",
            "\tif (get_user(version, &header->version))",
            "\t\treturn -EFAULT;",
            "",
            "\tswitch (version) {",
            "\tcase _LINUX_CAPABILITY_VERSION_1:",
            "\t\twarn_legacy_capability_use();",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_1;",
            "\t\tbreak;",
            "\tcase _LINUX_CAPABILITY_VERSION_2:",
            "\t\twarn_deprecated_v2();",
            "\t\tfallthrough;\t/* v3 is otherwise equivalent to v2 */",
            "\tcase _LINUX_CAPABILITY_VERSION_3:",
            "\t\t*tocopy = _LINUX_CAPABILITY_U32S_3;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tif (put_user((u32)_KERNEL_CAPABILITY_VERSION, &header->version))",
            "\t\t\treturn -EFAULT;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,",
            "\t\t\t\t     kernel_cap_t *pIp, kernel_cap_t *pPp)",
            "{",
            "\tint ret;",
            "",
            "\tif (pid && (pid != task_pid_vnr(current))) {",
            "\t\tconst struct task_struct *target;",
            "",
            "\t\trcu_read_lock();",
            "",
            "\t\ttarget = find_task_by_vpid(pid);",
            "\t\tif (!target)",
            "\t\t\tret = -ESRCH;",
            "\t\telse",
            "\t\t\tret = security_capget(target, pEp, pIp, pPp);",
            "",
            "\t\trcu_read_unlock();",
            "\t} else",
            "\t\tret = security_capget(current, pEp, pIp, pPp);",
            "",
            "\treturn ret;",
            "}",
            "static kernel_cap_t mk_kernel_cap(u32 low, u32 high)",
            "{",
            "\treturn (kernel_cap_t) { (low | ((u64)high << 32)) & CAP_VALID_MASK };",
            "}",
            "bool has_ns_capability(struct task_struct *t,",
            "\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability(t, &init_user_ns, cap);",
            "}",
            "bool has_ns_capability_noaudit(struct task_struct *t,",
            "\t\t\t       struct user_namespace *ns, int cap)",
            "{",
            "\tint ret;",
            "",
            "\trcu_read_lock();",
            "\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "",
            "\treturn (ret == 0);",
            "}",
            "bool has_capability_noaudit(struct task_struct *t, int cap)",
            "{",
            "\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);",
            "}"
          ],
          "function_name": "file_caps_disable, warn_legacy_capability_use, warn_deprecated_v2, cap_validate_magic, cap_get_target_pid, mk_kernel_cap, has_ns_capability, has_capability, has_ns_capability_noaudit, has_capability_noaudit",
          "description": "提供能力相关辅助函数，包括禁用文件能力标志、版本验证警告、目标进程能力获取及能力结构构建，实现命名空间能力检查和权限验证逻辑",
          "similarity": 0.4897794723510742
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/capability.c",
          "start_line": 351,
          "end_line": 424,
          "content": [
            "static bool ns_capable_common(struct user_namespace *ns,",
            "\t\t\t      int cap,",
            "\t\t\t      unsigned int opts)",
            "{",
            "\tint capable;",
            "",
            "\tif (unlikely(!cap_valid(cap))) {",
            "\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);",
            "\t\tBUG();",
            "\t}",
            "",
            "\tcapable = security_capable(current_cred(), ns, cap, opts);",
            "\tif (capable == 0) {",
            "\t\tcurrent->flags |= PF_SUPERPRIV;",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "bool ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NONE);",
            "}",
            "bool ns_capable_noaudit(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);",
            "}",
            "bool ns_capable_setid(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);",
            "}",
            "bool capable(int cap)",
            "{",
            "\treturn ns_capable(&init_user_ns, cap);",
            "}",
            "bool file_ns_capable(const struct file *file, struct user_namespace *ns,",
            "\t\t     int cap)",
            "{",
            "",
            "\tif (WARN_ON_ONCE(!cap_valid(cap)))",
            "\t\treturn false;",
            "",
            "\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "bool privileged_wrt_inode_uidgid(struct user_namespace *ns,",
            "\t\t\t\t struct mnt_idmap *idmap,",
            "\t\t\t\t const struct inode *inode)",
            "{",
            "\treturn vfsuid_has_mapping(ns, i_uid_into_vfsuid(idmap, inode)) &&",
            "\t       vfsgid_has_mapping(ns, i_gid_into_vfsgid(idmap, inode));",
            "}",
            "bool capable_wrt_inode_uidgid(struct mnt_idmap *idmap,",
            "\t\t\t      const struct inode *inode, int cap)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "",
            "\treturn ns_capable(ns, cap) &&",
            "\t       privileged_wrt_inode_uidgid(ns, idmap, inode);",
            "}",
            "bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)",
            "{",
            "\tint ret = 0;  /* An absent tracer adds no restrictions */",
            "\tconst struct cred *cred;",
            "",
            "\trcu_read_lock();",
            "\tcred = rcu_dereference(tsk->ptracer_cred);",
            "\tif (cred)",
            "\t\tret = security_capable(cred, ns, CAP_SYS_PTRACE,",
            "\t\t\t\t       CAP_OPT_NOAUDIT);",
            "\trcu_read_unlock();",
            "\treturn (ret == 0);",
            "}"
          ],
          "function_name": "ns_capable_common, ns_capable, ns_capable_noaudit, ns_capable_setid, capable, file_ns_capable, privileged_wrt_inode_uidgid, capable_wrt_inode_uidgid, ptracer_capable",
          "description": "实现核心能力检查函数，包含通用命名空间能力检测、当前命名空间能力检查、文件能力验证、基于inode UID/GID的特权判断及跟踪者能力检查等功能",
          "similarity": 0.4751003384590149
        }
      ]
    }
  ]
}