{
  "query": "文件系统结构与mkfs命令详解",
  "timestamp": "2025-12-25 23:32:17",
  "retrieved_files": [
    {
      "source_file": "mm/damon/sysfs.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:52:10\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `damon\\sysfs.c`\n\n---\n\n# damon/sysfs.c 技术文档\n\n## 1. 文件概述\n\n`damon/sysfs.c` 是 Linux 内核中 DAMON（Data Access MONitor）子系统的 sysfs 接口实现文件。该文件通过 sysfs 提供用户空间可配置的接口，用于动态管理 DAMON 监控目标（如进程 PID）及其对应的内存区域（regions）。用户可通过标准文件系统操作（读/写）来设置监控目标数量、每个目标的 PID 以及其监控的虚拟地址范围（起始和结束地址），从而实现对 DAMON 行为的灵活控制。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct damon_sysfs_region`：表示一个内存监控区域，包含起始地址（`start`）和结束地址（`end`）。\n- `struct damon_sysfs_regions`：表示一个目标进程的所有监控区域集合，包含区域数组和数量。\n- `struct damon_sysfs_target`：表示一个 DAMON 监控目标，包含进程 PID 和对应的 regions 对象。\n- `struct damon_sysfs_targets`：表示所有监控目标的集合，包含 targets 数组和数量。\n\n### 主要函数\n- **Region 层级**：\n  - `damon_sysfs_region_alloc()`：分配并初始化 region 对象。\n  - `start_show()` / `start_store()`：读取/写入 region 起始地址。\n  - `end_show()` / `end_store()`：读取/写入 region 结束地址。\n  - `damon_sysfs_region_release()`：释放 region 对象。\n\n- **Regions 层级**：\n  - `damon_sysfs_regions_alloc()`：分配 regions 对象。\n  - `damon_sysfs_regions_add_dirs()`：根据指定数量动态创建 region 子目录。\n  - `damon_sysfs_regions_rm_dirs()`：删除所有 region 子目录并释放资源。\n  - `nr_regions_show()` / `nr_regions_store()`：读取/设置 regions 数量。\n\n- **Target 层级**：\n  - `damon_sysfs_target_alloc()`：分配 target 对象。\n  - `damon_sysfs_target_add_dirs()`：为目标创建 regions 子目录。\n  - `damon_sysfs_target_rm_dirs()`：删除目标的 regions 子目录。\n  - `pid_target_show()` / `pid_target_store()`：读取/设置目标进程 PID。\n\n- **Targets 层级**：\n  - `damon_sysfs_targets_alloc()`：分配 targets 对象。\n  - `damon_sysfs_targets_add_dirs()`：根据指定数量动态创建 target 子目录。\n  - `damon_sysfs_targets_rm_dirs()`：删除所有 target 子目录并释放资源。\n\n## 3. 关键实现\n\n- **分层 sysfs 目录结构**：  \n  实现了四层嵌套的 sysfs 目录结构：  \n  `targets/` → `targets/<index>/` → `targets/<index>/regions/` → `targets/<index>/regions/<index>/`  \n  每层通过 `kobject` 和 `kobj_type` 管理生命周期和属性操作。\n\n- **动态目录管理**：  \n  通过写入 `nr_regions` 或上层 targets 的数量，动态创建或销毁对应数量的子目录。例如，向 `targets/nr_targets` 写入 `3` 会创建 `0/`、`1/`、`2/` 三个 target 目录。\n\n- **并发控制**：  \n  在修改 regions 数量时使用全局互斥锁 `damon_sysfs_lock`（定义在 `sysfs-common.h` 中），防止并发修改导致状态不一致。\n\n- **内存安全**：  \n  所有分配均使用 `kzalloc` 初始化，并在失败路径中进行完整的资源回滚（如 `damon_sysfs_regions_add_dirs` 失败时调用 `damon_sysfs_regions_rm_dirs` 清理已分配对象）。\n\n- **属性权限**：  \n  所有 sysfs 属性均设置为 `0600`（仅 root 可读写），确保安全性。\n\n## 4. 依赖关系\n\n- **内部依赖**：\n  - `sysfs-common.h`：提供全局锁 `damon_sysfs_lock` 和通用 sysfs 操作辅助函数。\n  - `damon.h`（间接）：使用 `struct damon_addr_range` 定义内存区域。\n\n- **内核核心依赖**：\n  - `<linux/kobject.h>`：提供 kobject 基础设施（通过 `sysfs-common.h` 间接包含）。\n  - `<linux/slab.h>`：提供内存分配函数 `kzalloc`、`kmalloc_array`。\n  - `<linux/pid.h>` 和 `<linux/sched.h>`：用于进程相关操作（尽管当前代码未直接使用，但为未来扩展预留）。\n\n## 5. 使用场景\n\n- **DAMON 配置**：  \n  用户空间工具（如 `damo`）通过写入 sysfs 文件配置 DAMON 监控目标。例如：\n  ```bash\n  echo 1 > /sys/kernel/mm/damon/targets/nr_targets\n  echo 1234 > /sys/kernel/mm/damon/targets/0/pid_target\n  echo 2 > /sys/kernel/mm/damon/targets/0/regions/nr_regions\n  echo 0x100000 > /sys/kernel/mm/damon/targets/0/regions/0/start\n  echo 0x200000 > /sys/kernel/mm/damon/targets/0/regions/0/end\n  ```\n\n- **动态调整监控范围**：  \n  在 DAMON 运行时，可动态增减监控目标或修改内存区域，无需重启内核模块。\n\n- **调试与监控**：  \n  通过读取 sysfs 文件验证当前 DAMON 配置状态，辅助调试内存访问模式分析任务。",
      "similarity": 0.6122196912765503,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "mm/damon/sysfs.c",
          "start_line": 709,
          "end_line": 839,
          "content": [
            "static int damon_sysfs_context_add_dirs(struct damon_sysfs_context *context)",
            "{",
            "\tint err;",
            "",
            "\terr = damon_sysfs_context_set_attrs(context);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = damon_sysfs_context_set_targets(context);",
            "\tif (err)",
            "\t\tgoto put_attrs_out;",
            "",
            "\terr = damon_sysfs_context_set_schemes(context);",
            "\tif (err)",
            "\t\tgoto put_targets_attrs_out;",
            "\treturn 0;",
            "",
            "put_targets_attrs_out:",
            "\tkobject_put(&context->targets->kobj);",
            "\tcontext->targets = NULL;",
            "put_attrs_out:",
            "\tkobject_put(&context->attrs->kobj);",
            "\tcontext->attrs = NULL;",
            "\treturn err;",
            "}",
            "static void damon_sysfs_context_rm_dirs(struct damon_sysfs_context *context)",
            "{",
            "\tdamon_sysfs_attrs_rm_dirs(context->attrs);",
            "\tkobject_put(&context->attrs->kobj);",
            "\tdamon_sysfs_targets_rm_dirs(context->targets);",
            "\tkobject_put(&context->targets->kobj);",
            "\tdamon_sysfs_schemes_rm_dirs(context->schemes);",
            "\tkobject_put(&context->schemes->kobj);",
            "}",
            "static ssize_t avail_operations_show(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, char *buf)",
            "{",
            "\tenum damon_ops_id id;",
            "\tint len = 0;",
            "",
            "\tfor (id = 0; id < NR_DAMON_OPS; id++) {",
            "\t\tif (!damon_is_registered_ops(id))",
            "\t\t\tcontinue;",
            "\t\tlen += sysfs_emit_at(buf, len, \"%s\\n\",",
            "\t\t\t\tdamon_sysfs_ops_strs[id]);",
            "\t}",
            "\treturn len;",
            "}",
            "static ssize_t operations_show(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, char *buf)",
            "{",
            "\tstruct damon_sysfs_context *context = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_context, kobj);",
            "",
            "\treturn sysfs_emit(buf, \"%s\\n\", damon_sysfs_ops_strs[context->ops_id]);",
            "}",
            "static ssize_t operations_store(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, const char *buf, size_t count)",
            "{",
            "\tstruct damon_sysfs_context *context = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_context, kobj);",
            "\tenum damon_ops_id id;",
            "",
            "\tfor (id = 0; id < NR_DAMON_OPS; id++) {",
            "\t\tif (sysfs_streq(buf, damon_sysfs_ops_strs[id])) {",
            "\t\t\tcontext->ops_id = id;",
            "\t\t\treturn count;",
            "\t\t}",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "static void damon_sysfs_context_release(struct kobject *kobj)",
            "{",
            "\tkfree(container_of(kobj, struct damon_sysfs_context, kobj));",
            "}",
            "static void damon_sysfs_contexts_rm_dirs(struct damon_sysfs_contexts *contexts)",
            "{",
            "\tstruct damon_sysfs_context **contexts_arr = contexts->contexts_arr;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < contexts->nr; i++) {",
            "\t\tdamon_sysfs_context_rm_dirs(contexts_arr[i]);",
            "\t\tkobject_put(&contexts_arr[i]->kobj);",
            "\t}",
            "\tcontexts->nr = 0;",
            "\tkfree(contexts_arr);",
            "\tcontexts->contexts_arr = NULL;",
            "}",
            "static int damon_sysfs_contexts_add_dirs(struct damon_sysfs_contexts *contexts,",
            "\t\tint nr_contexts)",
            "{",
            "\tstruct damon_sysfs_context **contexts_arr, *context;",
            "\tint err, i;",
            "",
            "\tdamon_sysfs_contexts_rm_dirs(contexts);",
            "\tif (!nr_contexts)",
            "\t\treturn 0;",
            "",
            "\tcontexts_arr = kmalloc_array(nr_contexts, sizeof(*contexts_arr),",
            "\t\t\tGFP_KERNEL | __GFP_NOWARN);",
            "\tif (!contexts_arr)",
            "\t\treturn -ENOMEM;",
            "\tcontexts->contexts_arr = contexts_arr;",
            "",
            "\tfor (i = 0; i < nr_contexts; i++) {",
            "\t\tcontext = damon_sysfs_context_alloc(DAMON_OPS_VADDR);",
            "\t\tif (!context) {",
            "\t\t\tdamon_sysfs_contexts_rm_dirs(contexts);",
            "\t\t\treturn -ENOMEM;",
            "\t\t}",
            "",
            "\t\terr = kobject_init_and_add(&context->kobj,",
            "\t\t\t\t&damon_sysfs_context_ktype, &contexts->kobj,",
            "\t\t\t\t\"%d\", i);",
            "\t\tif (err)",
            "\t\t\tgoto out;",
            "",
            "\t\terr = damon_sysfs_context_add_dirs(context);",
            "\t\tif (err)",
            "\t\t\tgoto out;",
            "",
            "\t\tcontexts_arr[i] = context;",
            "\t\tcontexts->nr++;",
            "\t}",
            "\treturn 0;",
            "",
            "out:",
            "\tdamon_sysfs_contexts_rm_dirs(contexts);",
            "\tkobject_put(&context->kobj);",
            "\treturn err;",
            "}"
          ],
          "function_name": "damon_sysfs_context_add_dirs, damon_sysfs_context_rm_dirs, avail_operations_show, operations_show, operations_store, damon_sysfs_context_release, damon_sysfs_contexts_rm_dirs, damon_sysfs_contexts_add_dirs",
          "description": "实现DAMON sysfs上下文目录的添加和移除逻辑，包含属性、目标和方案的初始化及清理，通过kobject管理子目录并处理错误回滚。",
          "similarity": 0.6011359095573425
        },
        {
          "chunk_id": 6,
          "file_path": "mm/damon/sysfs.c",
          "start_line": 882,
          "end_line": 982,
          "content": [
            "static ssize_t nr_contexts_show(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, char *buf)",
            "{",
            "\tstruct damon_sysfs_contexts *contexts = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_contexts, kobj);",
            "",
            "\treturn sysfs_emit(buf, \"%d\\n\", contexts->nr);",
            "}",
            "static ssize_t nr_contexts_store(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, const char *buf, size_t count)",
            "{",
            "\tstruct damon_sysfs_contexts *contexts;",
            "\tint nr, err;",
            "",
            "\terr = kstrtoint(buf, 0, &nr);",
            "\tif (err)",
            "\t\treturn err;",
            "\t/* TODO: support multiple contexts per kdamond */",
            "\tif (nr < 0 || 1 < nr)",
            "\t\treturn -EINVAL;",
            "",
            "\tcontexts = container_of(kobj, struct damon_sysfs_contexts, kobj);",
            "\tif (!mutex_trylock(&damon_sysfs_lock))",
            "\t\treturn -EBUSY;",
            "\terr = damon_sysfs_contexts_add_dirs(contexts, nr);",
            "\tmutex_unlock(&damon_sysfs_lock);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\treturn count;",
            "}",
            "static void damon_sysfs_contexts_release(struct kobject *kobj)",
            "{",
            "\tkfree(container_of(kobj, struct damon_sysfs_contexts, kobj));",
            "}",
            "static int damon_sysfs_kdamond_add_dirs(struct damon_sysfs_kdamond *kdamond)",
            "{",
            "\tstruct damon_sysfs_contexts *contexts;",
            "\tint err;",
            "",
            "\tcontexts = damon_sysfs_contexts_alloc();",
            "\tif (!contexts)",
            "\t\treturn -ENOMEM;",
            "",
            "\terr = kobject_init_and_add(&contexts->kobj,",
            "\t\t\t&damon_sysfs_contexts_ktype, &kdamond->kobj,",
            "\t\t\t\"contexts\");",
            "\tif (err) {",
            "\t\tkobject_put(&contexts->kobj);",
            "\t\treturn err;",
            "\t}",
            "\tkdamond->contexts = contexts;",
            "",
            "\treturn err;",
            "}",
            "static void damon_sysfs_kdamond_rm_dirs(struct damon_sysfs_kdamond *kdamond)",
            "{",
            "\tdamon_sysfs_contexts_rm_dirs(kdamond->contexts);",
            "\tkobject_put(&kdamond->contexts->kobj);",
            "}",
            "static bool damon_sysfs_ctx_running(struct damon_ctx *ctx)",
            "{",
            "\tbool running;",
            "",
            "\tmutex_lock(&ctx->kdamond_lock);",
            "\trunning = ctx->kdamond != NULL;",
            "\tmutex_unlock(&ctx->kdamond_lock);",
            "\treturn running;",
            "}",
            "static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\tchar *buf)",
            "{",
            "\tstruct damon_sysfs_kdamond *kdamond = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_kdamond, kobj);",
            "\tstruct damon_ctx *ctx = kdamond->damon_ctx;",
            "\tbool running;",
            "",
            "\tif (!ctx)",
            "\t\trunning = false;",
            "\telse",
            "\t\trunning = damon_sysfs_ctx_running(ctx);",
            "",
            "\treturn sysfs_emit(buf, \"%s\\n\", running ?",
            "\t\t\tdamon_sysfs_cmd_strs[DAMON_SYSFS_CMD_ON] :",
            "\t\t\tdamon_sysfs_cmd_strs[DAMON_SYSFS_CMD_OFF]);",
            "}",
            "static int damon_sysfs_set_attrs(struct damon_ctx *ctx,",
            "\t\tstruct damon_sysfs_attrs *sys_attrs)",
            "{",
            "\tstruct damon_sysfs_intervals *sys_intervals = sys_attrs->intervals;",
            "\tstruct damon_sysfs_ul_range *sys_nr_regions =",
            "\t\tsys_attrs->nr_regions_range;",
            "\tstruct damon_attrs attrs = {",
            "\t\t.sample_interval = sys_intervals->sample_us,",
            "\t\t.aggr_interval = sys_intervals->aggr_us,",
            "\t\t.ops_update_interval = sys_intervals->update_us,",
            "\t\t.min_nr_regions = sys_nr_regions->min,",
            "\t\t.max_nr_regions = sys_nr_regions->max,",
            "\t};",
            "\treturn damon_set_attrs(ctx, &attrs);",
            "}"
          ],
          "function_name": "nr_contexts_show, nr_contexts_store, damon_sysfs_contexts_release, damon_sysfs_kdamond_add_dirs, damon_sysfs_kdamond_rm_dirs, damon_sysfs_ctx_running, state_show, damon_sysfs_set_attrs",
          "description": "提供sysfs接口读取/设置上下文数量，管理kdamond目录结构，状态展示及属性设置功能，支持动态更新监控参数。",
          "similarity": 0.5816254615783691
        },
        {
          "chunk_id": 1,
          "file_path": "mm/damon/sysfs.c",
          "start_line": 28,
          "end_line": 143,
          "content": [
            "static ssize_t start_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\tchar *buf)",
            "{",
            "\tstruct damon_sysfs_region *region = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_region, kobj);",
            "",
            "\treturn sysfs_emit(buf, \"%lu\\n\", region->ar.start);",
            "}",
            "static ssize_t start_store(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\tconst char *buf, size_t count)",
            "{",
            "\tstruct damon_sysfs_region *region = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_region, kobj);",
            "\tint err = kstrtoul(buf, 0, &region->ar.start);",
            "",
            "\treturn err ? err : count;",
            "}",
            "static ssize_t end_show(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\tchar *buf)",
            "{",
            "\tstruct damon_sysfs_region *region = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_region, kobj);",
            "",
            "\treturn sysfs_emit(buf, \"%lu\\n\", region->ar.end);",
            "}",
            "static ssize_t end_store(struct kobject *kobj, struct kobj_attribute *attr,",
            "\t\tconst char *buf, size_t count)",
            "{",
            "\tstruct damon_sysfs_region *region = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_region, kobj);",
            "\tint err = kstrtoul(buf, 0, &region->ar.end);",
            "",
            "\treturn err ? err : count;",
            "}",
            "static void damon_sysfs_region_release(struct kobject *kobj)",
            "{",
            "\tkfree(container_of(kobj, struct damon_sysfs_region, kobj));",
            "}",
            "static void damon_sysfs_regions_rm_dirs(struct damon_sysfs_regions *regions)",
            "{",
            "\tstruct damon_sysfs_region **regions_arr = regions->regions_arr;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < regions->nr; i++)",
            "\t\tkobject_put(&regions_arr[i]->kobj);",
            "\tregions->nr = 0;",
            "\tkfree(regions_arr);",
            "\tregions->regions_arr = NULL;",
            "}",
            "static int damon_sysfs_regions_add_dirs(struct damon_sysfs_regions *regions,",
            "\t\tint nr_regions)",
            "{",
            "\tstruct damon_sysfs_region **regions_arr, *region;",
            "\tint err, i;",
            "",
            "\tdamon_sysfs_regions_rm_dirs(regions);",
            "\tif (!nr_regions)",
            "\t\treturn 0;",
            "",
            "\tregions_arr = kmalloc_array(nr_regions, sizeof(*regions_arr),",
            "\t\t\tGFP_KERNEL | __GFP_NOWARN);",
            "\tif (!regions_arr)",
            "\t\treturn -ENOMEM;",
            "\tregions->regions_arr = regions_arr;",
            "",
            "\tfor (i = 0; i < nr_regions; i++) {",
            "\t\tregion = damon_sysfs_region_alloc();",
            "\t\tif (!region) {",
            "\t\t\tdamon_sysfs_regions_rm_dirs(regions);",
            "\t\t\treturn -ENOMEM;",
            "\t\t}",
            "",
            "\t\terr = kobject_init_and_add(&region->kobj,",
            "\t\t\t\t&damon_sysfs_region_ktype, &regions->kobj,",
            "\t\t\t\t\"%d\", i);",
            "\t\tif (err) {",
            "\t\t\tkobject_put(&region->kobj);",
            "\t\t\tdamon_sysfs_regions_rm_dirs(regions);",
            "\t\t\treturn err;",
            "\t\t}",
            "",
            "\t\tregions_arr[i] = region;",
            "\t\tregions->nr++;",
            "\t}",
            "\treturn 0;",
            "}",
            "static ssize_t nr_regions_show(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, char *buf)",
            "{",
            "\tstruct damon_sysfs_regions *regions = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_regions, kobj);",
            "",
            "\treturn sysfs_emit(buf, \"%d\\n\", regions->nr);",
            "}",
            "static ssize_t nr_regions_store(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, const char *buf, size_t count)",
            "{",
            "\tstruct damon_sysfs_regions *regions;",
            "\tint nr, err = kstrtoint(buf, 0, &nr);",
            "",
            "\tif (err)",
            "\t\treturn err;",
            "\tif (nr < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tregions = container_of(kobj, struct damon_sysfs_regions, kobj);",
            "",
            "\tif (!mutex_trylock(&damon_sysfs_lock))",
            "\t\treturn -EBUSY;",
            "\terr = damon_sysfs_regions_add_dirs(regions, nr);",
            "\tmutex_unlock(&damon_sysfs_lock);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\treturn count;",
            "}"
          ],
          "function_name": "start_show, start_store, end_show, end_store, damon_sysfs_region_release, damon_sysfs_regions_rm_dirs, damon_sysfs_regions_add_dirs, nr_regions_show, nr_regions_store",
          "description": "实现区域起始/结束地址的sysfs读写操作，管理区域目录的增删，通过kobject接口暴露监控区域配置参数。",
          "similarity": 0.5798302292823792
        },
        {
          "chunk_id": 12,
          "file_path": "mm/damon/sysfs.c",
          "start_line": 1730,
          "end_line": 1785,
          "content": [
            "static void damon_sysfs_kdamonds_release(struct kobject *kobj)",
            "{",
            "\tkfree(container_of(kobj, struct damon_sysfs_kdamonds, kobj));",
            "}",
            "static int damon_sysfs_ui_dir_add_dirs(struct damon_sysfs_ui_dir *ui_dir)",
            "{",
            "\tstruct damon_sysfs_kdamonds *kdamonds;",
            "\tint err;",
            "",
            "\tkdamonds = damon_sysfs_kdamonds_alloc();",
            "\tif (!kdamonds)",
            "\t\treturn -ENOMEM;",
            "",
            "\terr = kobject_init_and_add(&kdamonds->kobj,",
            "\t\t\t&damon_sysfs_kdamonds_ktype, &ui_dir->kobj,",
            "\t\t\t\"kdamonds\");",
            "\tif (err) {",
            "\t\tkobject_put(&kdamonds->kobj);",
            "\t\treturn err;",
            "\t}",
            "\tui_dir->kdamonds = kdamonds;",
            "\treturn err;",
            "}",
            "static void damon_sysfs_ui_dir_release(struct kobject *kobj)",
            "{",
            "\tkfree(container_of(kobj, struct damon_sysfs_ui_dir, kobj));",
            "}",
            "static int __init damon_sysfs_init(void)",
            "{",
            "\tstruct kobject *damon_sysfs_root;",
            "\tstruct damon_sysfs_ui_dir *admin;",
            "\tint err;",
            "",
            "\tdamon_sysfs_root = kobject_create_and_add(\"damon\", mm_kobj);",
            "\tif (!damon_sysfs_root)",
            "\t\treturn -ENOMEM;",
            "",
            "\tadmin = damon_sysfs_ui_dir_alloc();",
            "\tif (!admin) {",
            "\t\tkobject_put(damon_sysfs_root);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\terr = kobject_init_and_add(&admin->kobj, &damon_sysfs_ui_dir_ktype,",
            "\t\t\tdamon_sysfs_root, \"admin\");",
            "\tif (err)",
            "\t\tgoto out;",
            "\terr = damon_sysfs_ui_dir_add_dirs(admin);",
            "\tif (err)",
            "\t\tgoto out;",
            "\treturn 0;",
            "",
            "out:",
            "\tkobject_put(&admin->kobj);",
            "\tkobject_put(damon_sysfs_root);",
            "\treturn err;",
            "}"
          ],
          "function_name": "damon_sysfs_kdamonds_release, damon_sysfs_ui_dir_add_dirs, damon_sysfs_ui_dir_release, damon_sysfs_init",
          "description": "构建DAMON sysfs层级结构，初始化根目录并注册管理接口。damon_sysfs_init创建\"damon\" sysfs节点，admin目录注册UI控制接口，实现监控实例集合的动态管理与资源释放。",
          "similarity": 0.5544273853302002
        },
        {
          "chunk_id": 2,
          "file_path": "mm/damon/sysfs.c",
          "start_line": 187,
          "end_line": 290,
          "content": [
            "static void damon_sysfs_regions_release(struct kobject *kobj)",
            "{",
            "\tkfree(container_of(kobj, struct damon_sysfs_regions, kobj));",
            "}",
            "static int damon_sysfs_target_add_dirs(struct damon_sysfs_target *target)",
            "{",
            "\tstruct damon_sysfs_regions *regions = damon_sysfs_regions_alloc();",
            "\tint err;",
            "",
            "\tif (!regions)",
            "\t\treturn -ENOMEM;",
            "",
            "\terr = kobject_init_and_add(&regions->kobj, &damon_sysfs_regions_ktype,",
            "\t\t\t&target->kobj, \"regions\");",
            "\tif (err)",
            "\t\tkobject_put(&regions->kobj);",
            "\telse",
            "\t\ttarget->regions = regions;",
            "\treturn err;",
            "}",
            "static void damon_sysfs_target_rm_dirs(struct damon_sysfs_target *target)",
            "{",
            "\tdamon_sysfs_regions_rm_dirs(target->regions);",
            "\tkobject_put(&target->regions->kobj);",
            "}",
            "static ssize_t pid_target_show(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, char *buf)",
            "{",
            "\tstruct damon_sysfs_target *target = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_target, kobj);",
            "",
            "\treturn sysfs_emit(buf, \"%d\\n\", target->pid);",
            "}",
            "static ssize_t pid_target_store(struct kobject *kobj,",
            "\t\tstruct kobj_attribute *attr, const char *buf, size_t count)",
            "{",
            "\tstruct damon_sysfs_target *target = container_of(kobj,",
            "\t\t\tstruct damon_sysfs_target, kobj);",
            "\tint err = kstrtoint(buf, 0, &target->pid);",
            "",
            "\tif (err)",
            "\t\treturn -EINVAL;",
            "\treturn count;",
            "}",
            "static void damon_sysfs_target_release(struct kobject *kobj)",
            "{",
            "\tkfree(container_of(kobj, struct damon_sysfs_target, kobj));",
            "}",
            "static void damon_sysfs_targets_rm_dirs(struct damon_sysfs_targets *targets)",
            "{",
            "\tstruct damon_sysfs_target **targets_arr = targets->targets_arr;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < targets->nr; i++) {",
            "\t\tdamon_sysfs_target_rm_dirs(targets_arr[i]);",
            "\t\tkobject_put(&targets_arr[i]->kobj);",
            "\t}",
            "\ttargets->nr = 0;",
            "\tkfree(targets_arr);",
            "\ttargets->targets_arr = NULL;",
            "}",
            "static int damon_sysfs_targets_add_dirs(struct damon_sysfs_targets *targets,",
            "\t\tint nr_targets)",
            "{",
            "\tstruct damon_sysfs_target **targets_arr, *target;",
            "\tint err, i;",
            "",
            "\tdamon_sysfs_targets_rm_dirs(targets);",
            "\tif (!nr_targets)",
            "\t\treturn 0;",
            "",
            "\ttargets_arr = kmalloc_array(nr_targets, sizeof(*targets_arr),",
            "\t\t\tGFP_KERNEL | __GFP_NOWARN);",
            "\tif (!targets_arr)",
            "\t\treturn -ENOMEM;",
            "\ttargets->targets_arr = targets_arr;",
            "",
            "\tfor (i = 0; i < nr_targets; i++) {",
            "\t\ttarget = damon_sysfs_target_alloc();",
            "\t\tif (!target) {",
            "\t\t\tdamon_sysfs_targets_rm_dirs(targets);",
            "\t\t\treturn -ENOMEM;",
            "\t\t}",
            "",
            "\t\terr = kobject_init_and_add(&target->kobj,",
            "\t\t\t\t&damon_sysfs_target_ktype, &targets->kobj,",
            "\t\t\t\t\"%d\", i);",
            "\t\tif (err)",
            "\t\t\tgoto out;",
            "",
            "\t\terr = damon_sysfs_target_add_dirs(target);",
            "\t\tif (err)",
            "\t\t\tgoto out;",
            "",
            "\t\ttargets_arr[i] = target;",
            "\t\ttargets->nr++;",
            "\t}",
            "\treturn 0;",
            "",
            "out:",
            "\tdamon_sysfs_targets_rm_dirs(targets);",
            "\tkobject_put(&target->kobj);",
            "\treturn err;",
            "}"
          ],
          "function_name": "damon_sysfs_regions_release, damon_sysfs_target_add_dirs, damon_sysfs_target_rm_dirs, pid_target_show, pid_target_store, damon_sysfs_target_release, damon_sysfs_targets_rm_dirs, damon_sysfs_targets_add_dirs",
          "description": "实现目标进程PID的sysfs读写，管理目标目录的增删，建立进程与监控区域的关联关系。",
          "similarity": 0.5488044619560242
        }
      ]
    },
    {
      "source_file": "mm/cma_sysfs.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:43:57\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cma_sysfs.c`\n\n---\n\n# cma_sysfs.c 技术文档\n\n## 1. 文件概述\n\n`cma_sysfs.c` 实现了连续内存分配器（Contiguous Memory Allocator, CMA）的 sysfs 接口，用于向用户空间暴露 CMA 区域的运行时统计信息。通过该接口，用户可以在 `/sys/kernel/mm/cma/` 目录下查看每个 CMA 区域成功和失败分配的页面数量，便于系统调试与性能分析。\n\n## 2. 核心功能\n\n### 主要函数\n- `cma_sysfs_account_success_pages(struct cma *cma, unsigned long nr_pages)`  \n  原子累加成功分配的页面数到指定 CMA 区域的统计计数器。\n  \n- `cma_sysfs_account_fail_pages(struct cma *cma, unsigned long nr_pages)`  \n  原子累加分配失败的页面数到指定 CMA 区域的统计计数器。\n\n- `alloc_pages_success_show()`  \n  sysfs 属性读取回调，返回 `nr_pages_succeeded` 的当前值。\n\n- `alloc_pages_fail_show()`  \n  sysfs 属性读取回调，返回 `nr_pages_failed` 的当前值。\n\n- `cma_kobj_release()`  \n  CMA kobject 的释放回调，负责清理关联的 `cma_kobject` 结构。\n\n- `cma_sysfs_init()`  \n  模块初始化函数，创建 sysfs 目录结构并为每个 CMA 区域注册对应的 sysfs 条目。\n\n### 主要数据结构\n- `struct cma_kobject`（定义在 `cma.h` 中）  \n  封装 `kobject` 与指向 `struct cma` 的指针，用于 sysfs 表示。\n\n- `cma_ktype`  \n  定义 CMA kobject 的类型，包含 release 回调、sysfs 操作集和默认属性组。\n\n- `cma_attrs[]` 和 `cma_groups`  \n  定义 sysfs 中可读的属性列表（`alloc_pages_success` 和 `alloc_pages_fail`）。\n\n## 3. 关键实现\n\n- **原子计数**：使用 `atomic64_t` 类型（`nr_pages_succeeded` 和 `nr_pages_failed`）确保多线程环境下统计信息的准确性。\n  \n- **kobject 封装**：通过 `container_of` 宏从 `kobject` 反向获取所属的 `struct cma`，实现 sysfs 对象与内核 CMA 区域的绑定。\n\n- **sysfs 属性生成**：利用 `CMA_ATTR_RO` 宏简化只读属性的定义，自动创建符合 sysfs 规范的 `kobj_attribute`。\n\n- **动态目录创建**：在 `mm_kobj`（即 `/sys/kernel/mm/`）下创建 `cma` 子目录，并为每个已注册的 CMA 区域（`cma_areas[]`）创建以区域名为名的子目录。\n\n- **错误处理与资源回收**：初始化过程中若任一 CMA 区域的 kobject 创建失败，会回滚已创建的 kobject 并释放资源，避免内存泄漏。\n\n- **初始化时机**：通过 `subsys_initcall` 注册，确保在内核子系统初始化阶段（早于普通模块）完成 sysfs 结构的建立。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/cma.h>`：提供 CMA 核心 API 和 `struct cma` 定义。\n  - `\"cma.h\"`（本地头文件）：定义 `struct cma_kobject` 等内部结构。\n  - `<linux/kernel.h>`、`<linux/slab.h>`：提供基础内核工具函数和内存分配接口。\n\n- **内核子系统依赖**：\n  - **sysfs 子系统**：依赖 `kobject`、`kobj_attribute` 等机制暴露用户接口。\n  - **内存管理子系统**：依赖 `mm_kobj` 作为 sysfs 挂载点，以及 CMA 核心逻辑提供的 `cma_areas` 和 `cma_area_count`。\n\n## 5. 使用场景\n\n- **系统调试**：开发人员可通过读取 `/sys/kernel/mm/cma/<area>/alloc_pages_success` 和 `alloc_pages_fail` 快速判断 CMA 分配器的工作状态，识别内存碎片或配置问题。\n\n- **性能监控**：运维工具可定期采集 CMA 分配成功率，用于评估系统实时性或大块连续内存需求的满足情况。\n\n- **内核测试**：在 CMA 相关功能验证中，该接口提供可量化的分配行为指标，辅助回归测试和压力测试。\n\n- **驱动开发参考**：设备驱动在使用 `dma_alloc_coherent()` 等 CMA 接口时，可通过此 sysfs 路径确认底层分配是否按预期工作。",
      "similarity": 0.6109112501144409,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/cma_sysfs.c",
          "start_line": 17,
          "end_line": 86,
          "content": [
            "void cma_sysfs_account_success_pages(struct cma *cma, unsigned long nr_pages)",
            "{",
            "\tatomic64_add(nr_pages, &cma->nr_pages_succeeded);",
            "}",
            "void cma_sysfs_account_fail_pages(struct cma *cma, unsigned long nr_pages)",
            "{",
            "\tatomic64_add(nr_pages, &cma->nr_pages_failed);",
            "}",
            "static ssize_t alloc_pages_success_show(struct kobject *kobj,",
            "\t\t\t\t\tstruct kobj_attribute *attr, char *buf)",
            "{",
            "\tstruct cma *cma = cma_from_kobj(kobj);",
            "",
            "\treturn sysfs_emit(buf, \"%llu\\n\",",
            "\t\t\t  atomic64_read(&cma->nr_pages_succeeded));",
            "}",
            "static ssize_t alloc_pages_fail_show(struct kobject *kobj,",
            "\t\t\t\t     struct kobj_attribute *attr, char *buf)",
            "{",
            "\tstruct cma *cma = cma_from_kobj(kobj);",
            "",
            "\treturn sysfs_emit(buf, \"%llu\\n\", atomic64_read(&cma->nr_pages_failed));",
            "}",
            "static void cma_kobj_release(struct kobject *kobj)",
            "{",
            "\tstruct cma *cma = cma_from_kobj(kobj);",
            "\tstruct cma_kobject *cma_kobj = cma->cma_kobj;",
            "",
            "\tkfree(cma_kobj);",
            "\tcma->cma_kobj = NULL;",
            "}",
            "static int __init cma_sysfs_init(void)",
            "{",
            "\tstruct kobject *cma_kobj_root;",
            "\tstruct cma_kobject *cma_kobj;",
            "\tstruct cma *cma;",
            "\tint i, err;",
            "",
            "\tcma_kobj_root = kobject_create_and_add(\"cma\", mm_kobj);",
            "\tif (!cma_kobj_root)",
            "\t\treturn -ENOMEM;",
            "",
            "\tfor (i = 0; i < cma_area_count; i++) {",
            "\t\tcma_kobj = kzalloc(sizeof(*cma_kobj), GFP_KERNEL);",
            "\t\tif (!cma_kobj) {",
            "\t\t\terr = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tcma = &cma_areas[i];",
            "\t\tcma->cma_kobj = cma_kobj;",
            "\t\tcma_kobj->cma = cma;",
            "\t\terr = kobject_init_and_add(&cma_kobj->kobj, &cma_ktype,",
            "\t\t\t\t\t   cma_kobj_root, \"%s\", cma->name);",
            "\t\tif (err) {",
            "\t\t\tkobject_put(&cma_kobj->kobj);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\treturn 0;",
            "out:",
            "\twhile (--i >= 0) {",
            "\t\tcma = &cma_areas[i];",
            "\t\tkobject_put(&cma->cma_kobj->kobj);",
            "\t}",
            "\tkobject_put(cma_kobj_root);",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "cma_sysfs_account_success_pages, cma_sysfs_account_fail_pages, alloc_pages_success_show, alloc_pages_fail_show, cma_kobj_release, cma_sysfs_init",
          "description": "实现CMA内存分配统计功能，包含成功/失败页数记录函数、sysfs属性展示函数及SysFS初始化与清理逻辑",
          "similarity": 0.5884869694709778
        },
        {
          "chunk_id": 0,
          "file_path": "mm/cma_sysfs.c",
          "start_line": 1,
          "end_line": 16,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * CMA SysFS Interface",
            " *",
            " * Copyright (c) 2021 Minchan Kim <minchan@kernel.org>",
            " */",
            "",
            "#include <linux/cma.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "",
            "#include \"cma.h\"",
            "",
            "#define CMA_ATTR_RO(_name) \\",
            "\tstatic struct kobj_attribute _name##_attr = __ATTR_RO(_name)",
            ""
          ],
          "function_name": null,
          "description": "定义CMA SysFS只读属性宏，用于后续注册CMA内存区域的sysfs属性",
          "similarity": 0.5048696994781494
        }
      ]
    },
    {
      "source_file": "kernel/module/sysfs.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:08:12\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\sysfs.c`\n\n---\n\n# module/sysfs.c 技术文档\n\n## 1. 文件概述\n\n`module/sysfs.c` 是 Linux 内核模块子系统中负责为已加载内核模块在 sysfs 虚拟文件系统中创建和管理属性接口的核心实现文件。该文件通过 sysfs 向用户空间暴露模块的元信息，包括节区（sections）地址、SHT_NOTE 类型节区内容、模块依赖关系（holders）以及模块信息（modinfo）等。这些信息对调试、监控和模块管理至关重要。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct module_sect_attr`**  \n  表示单个 ELF 节区的二进制属性，包含节区虚拟地址和对应的 `bin_attribute`。\n  \n- **`struct module_sect_attrs`**  \n  管理模块所有非空节区的属性组（`attribute_group`），包含节区数量和动态数组 `attrs[]`。\n\n- **`struct module_notes_attrs`**  \n  管理模块中类型为 `SHT_NOTE` 的节区内容，通过二进制文件暴露其原始数据。\n\n- **`struct module_attribute`**  \n  用于表示模块的通用属性（如 `version`、`license` 等 modinfo 字段），由外部定义并在此注册到 sysfs。\n\n### 主要函数\n\n- **`add_sect_attrs()` / `remove_sect_attrs()`**  \n  在 `/sys/module/<modname>/sections/` 下为每个非空 ELF 节区创建只读二进制文件，显示其加载地址（受 `kallsyms_show_value()` 权限控制）。\n\n- **`add_notes_attrs()` / `remove_notes_attrs()`**  \n  在 `/sys/module/<modname>/notes/` 下为每个 `SHT_NOTE` 类型节区创建二进制文件，直接暴露其原始内容。\n\n- **`add_usage_links()` / `del_usage_links()`**  \n  在模块依赖关系启用（`CONFIG_MODULE_UNLOAD`）时，为每个被当前模块使用的其他模块在其 `holders/` 目录下创建指向当前模块的符号链接。\n\n- **`module_add_modinfo_attrs()` / `module_remove_modinfo_attrs()`**  \n  将模块的 modinfo 字段（如 `author`、`description` 等）注册为 sysfs 中的普通属性文件。\n\n## 3. 关键实现\n\n### 节区地址显示（`module_sect_read`）\n\n- 使用 `scnprintf` 将地址格式化为 `\"0x<addr>\\n\"` 字符串。\n- 由于 `bin_attribute` 的 `read` 回调需处理任意 `pos` 和 `count`，但地址只需从位置 0 读取，故对非零 `pos` 返回 `-EINVAL`。\n- 为避免 `sprintf` 写入尾部 NUL 字符导致用户空间读取截断，使用 bounce buffer 中转数据。\n\n### 动态内存布局（`module_sect_attrs`）\n\n- 使用灵活数组成员（FAM）`attrs[]` 存储多个 `module_sect_attr`。\n- 通过 `struct_size()` 计算结构体总大小，并额外分配空间存放 `bin_attrs` 指针数组。\n- `bin_attrs` 指针数组紧邻结构体末尾，通过指针偏移访问。\n\n### 权限控制（`kallsyms_show_value`）\n\n- 节区地址是否显示为实际值（如 `0xffffffffc0001234`）或 `0x0`，取决于当前进程凭证是否具有 `kallsyms` 地址查看权限（通常需 `CAP_SYSLOG`）。\n\n### SHT_NOTE 节区暴露\n\n- 复用 `sect_attrs` 中已分配的节区名称字符串，避免重复分配。\n- `bin_attribute.private` 直接指向节区在内核空间的虚拟地址，`module_notes_read` 通过 `memcpy` 返回原始数据。\n\n### 模块依赖链接\n\n- 依赖关系通过 `module_use` 链表维护。\n- 每个被依赖模块的 `holders_dir`（即 `/sys/module/<target>/holders/`）下创建指向当前模块 kobject 的符号链接，名称为当前模块名。\n\n## 4. 依赖关系\n\n- **内核配置依赖**：\n  - `CONFIG_KALLSYMS`：启用节区地址和 notes 节区的 sysfs 接口。\n  - `CONFIG_MODULE_UNLOAD`：启用模块依赖关系的符号链接。\n- **头文件依赖**：\n  - `<linux/sysfs.h>`：提供 sysfs 属性和组操作接口。\n  - `<linux/kallsyms.h>`：提供符号地址权限检查函数 `kallsyms_show_value()`。\n  - `\"internal.h\"`：包含模块子系统内部定义（如 `struct load_info`、`sect_empty()` 等）。\n- **数据结构依赖**：\n  - `struct module`：包含 `sect_attrs`、`notes_attrs`、`modinfo_attrs` 等字段用于存储 sysfs 状态。\n  - `struct load_info`：提供模块加载时的 ELF 头、节区头和字符串表信息。\n\n## 5. 使用场景\n\n- **系统调试与分析**：  \n  用户可通过 `/sys/module/<mod>/sections/.text` 等文件查看模块各节区的加载地址，辅助内核调试和性能分析。\n\n- **安全审计**：  \n  通过检查模块的 license、author、description 等 modinfo 属性，验证模块合法性。\n\n- **依赖关系追踪**：  \n  通过 `holders/` 目录下的符号链接，确定哪些模块依赖于当前模块，辅助模块卸载决策。\n\n- **固件与元数据提取**：  \n  某些模块将固件或构建信息嵌入 `SHT_NOTE` 节区，用户空间工具可通过 `/sys/module/<mod>/notes/` 直接读取这些数据。\n\n- **内核开发与测试**：  \n  开发者可利用这些接口验证模块加载行为、节区布局和符号解析结果。",
      "similarity": 0.6053005456924438,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/module/sysfs.c",
          "start_line": 275,
          "end_line": 410,
          "content": [
            "static void module_remove_modinfo_attrs(struct module *mod, int end)",
            "{",
            "\tstruct module_attribute *attr;",
            "\tint i;",
            "",
            "\tfor (i = 0; (attr = &mod->modinfo_attrs[i]); i++) {",
            "\t\tif (end >= 0 && i > end)",
            "\t\t\tbreak;",
            "\t\t/* pick a field to test for end of list */",
            "\t\tif (!attr->attr.name)",
            "\t\t\tbreak;",
            "\t\tsysfs_remove_file(&mod->mkobj.kobj, &attr->attr);",
            "\t\tif (attr->free)",
            "\t\t\tattr->free(mod);",
            "\t}",
            "\tkfree(mod->modinfo_attrs);",
            "}",
            "static int module_add_modinfo_attrs(struct module *mod)",
            "{",
            "\tstruct module_attribute *attr;",
            "\tstruct module_attribute *temp_attr;",
            "\tint error = 0;",
            "\tint i;",
            "",
            "\tmod->modinfo_attrs = kzalloc((sizeof(struct module_attribute) *",
            "\t\t\t\t\t(modinfo_attrs_count + 1)),",
            "\t\t\t\t\tGFP_KERNEL);",
            "\tif (!mod->modinfo_attrs)",
            "\t\treturn -ENOMEM;",
            "",
            "\ttemp_attr = mod->modinfo_attrs;",
            "\tfor (i = 0; (attr = modinfo_attrs[i]); i++) {",
            "\t\tif (!attr->test || attr->test(mod)) {",
            "\t\t\tmemcpy(temp_attr, attr, sizeof(*temp_attr));",
            "\t\t\tsysfs_attr_init(&temp_attr->attr);",
            "\t\t\terror = sysfs_create_file(&mod->mkobj.kobj,",
            "\t\t\t\t\t\t  &temp_attr->attr);",
            "\t\t\tif (error)",
            "\t\t\t\tgoto error_out;",
            "\t\t\t++temp_attr;",
            "\t\t}",
            "\t}",
            "",
            "\treturn 0;",
            "",
            "error_out:",
            "\tif (i > 0)",
            "\t\tmodule_remove_modinfo_attrs(mod, --i);",
            "\telse",
            "\t\tkfree(mod->modinfo_attrs);",
            "\treturn error;",
            "}",
            "static void mod_kobject_put(struct module *mod)",
            "{",
            "\tDECLARE_COMPLETION_ONSTACK(c);",
            "",
            "\tmod->mkobj.kobj_completion = &c;",
            "\tkobject_put(&mod->mkobj.kobj);",
            "\twait_for_completion(&c);",
            "}",
            "static int mod_sysfs_init(struct module *mod)",
            "{",
            "\tint err;",
            "\tstruct kobject *kobj;",
            "",
            "\tif (!module_kset) {",
            "\t\tpr_err(\"%s: module sysfs not initialized\\n\", mod->name);",
            "\t\terr = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tkobj = kset_find_obj(module_kset, mod->name);",
            "\tif (kobj) {",
            "\t\tpr_err(\"%s: module is already loaded\\n\", mod->name);",
            "\t\tkobject_put(kobj);",
            "\t\terr = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tmod->mkobj.mod = mod;",
            "",
            "\tmemset(&mod->mkobj.kobj, 0, sizeof(mod->mkobj.kobj));",
            "\tmod->mkobj.kobj.kset = module_kset;",
            "\terr = kobject_init_and_add(&mod->mkobj.kobj, &module_ktype, NULL,",
            "\t\t\t\t   \"%s\", mod->name);",
            "\tif (err)",
            "\t\tmod_kobject_put(mod);",
            "",
            "out:",
            "\treturn err;",
            "}",
            "int mod_sysfs_setup(struct module *mod,",
            "\t\t    const struct load_info *info,",
            "\t\t\t   struct kernel_param *kparam,",
            "\t\t\t   unsigned int num_params)",
            "{",
            "\tint err;",
            "",
            "\terr = mod_sysfs_init(mod);",
            "\tif (err)",
            "\t\tgoto out;",
            "",
            "\tmod->holders_dir = kobject_create_and_add(\"holders\", &mod->mkobj.kobj);",
            "\tif (!mod->holders_dir) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto out_unreg;",
            "\t}",
            "",
            "\terr = module_param_sysfs_setup(mod, kparam, num_params);",
            "\tif (err)",
            "\t\tgoto out_unreg_holders;",
            "",
            "\terr = module_add_modinfo_attrs(mod);",
            "\tif (err)",
            "\t\tgoto out_unreg_param;",
            "",
            "\terr = add_usage_links(mod);",
            "\tif (err)",
            "\t\tgoto out_unreg_modinfo_attrs;",
            "",
            "\tadd_sect_attrs(mod, info);",
            "\tadd_notes_attrs(mod, info);",
            "",
            "\treturn 0;",
            "",
            "out_unreg_modinfo_attrs:",
            "\tmodule_remove_modinfo_attrs(mod, -1);",
            "out_unreg_param:",
            "\tmodule_param_sysfs_remove(mod);",
            "out_unreg_holders:",
            "\tkobject_put(mod->holders_dir);",
            "out_unreg:",
            "\tmod_kobject_put(mod);",
            "out:",
            "\treturn err;",
            "}"
          ],
          "function_name": "module_remove_modinfo_attrs, module_add_modinfo_attrs, mod_kobject_put, mod_sysfs_init, mod_sysfs_setup",
          "description": "实现模块元信息属性的动态注册与清理，初始化模块sysfs对象结构，建立模块参数、持有者链接及驱动目录体系，包含错误恢复机制和资源回收路径。",
          "similarity": 0.569892406463623
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/module/sysfs.c",
          "start_line": 416,
          "end_line": 434,
          "content": [
            "static void mod_sysfs_fini(struct module *mod)",
            "{",
            "\tremove_notes_attrs(mod);",
            "\tremove_sect_attrs(mod);",
            "\tmod_kobject_put(mod);",
            "}",
            "void mod_sysfs_teardown(struct module *mod)",
            "{",
            "\tdel_usage_links(mod);",
            "\tmodule_remove_modinfo_attrs(mod, -1);",
            "\tmodule_param_sysfs_remove(mod);",
            "\tkobject_put(mod->mkobj.drivers_dir);",
            "\tkobject_put(mod->holders_dir);",
            "\tmod_sysfs_fini(mod);",
            "}",
            "void init_param_lock(struct module *mod)",
            "{",
            "\tmutex_init(&mod->param_lock);",
            "}"
          ],
          "function_name": "mod_sysfs_fini, mod_sysfs_teardown, init_param_lock",
          "description": "提供模块sysfs资源的最终清理接口，依次移除note/section属性、参数链接、驱动目录及基础对象，包含互斥锁初始化以保障参数访问安全。",
          "similarity": 0.5648875832557678
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/sysfs.c",
          "start_line": 1,
          "end_line": 33,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Module sysfs support",
            " *",
            " * Copyright (C) 2008 Rusty Russell",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mutex.h>",
            "#include \"internal.h\"",
            "",
            "/*",
            " * /sys/module/foo/sections stuff",
            " * J. Corbet <corbet@lwn.net>",
            " */",
            "#ifdef CONFIG_KALLSYMS",
            "struct module_sect_attr {",
            "\tstruct bin_attribute battr;",
            "\tunsigned long address;",
            "};",
            "",
            "struct module_sect_attrs {",
            "\tstruct attribute_group grp;",
            "\tunsigned int nsections;",
            "\tstruct module_sect_attr attrs[];",
            "};",
            "",
            "#define MODULE_SECT_READ_SIZE (3 /* \"0x\", \"\\n\" */ + (BITS_PER_LONG / 4))"
          ],
          "function_name": null,
          "description": "定义用于模块sysfs接口的结构体和宏，声明module_sect_attr用于表示模块section属性，module_sect_attrs用于管理多个section属性组，MODULE_SECT_READ_SIZE定义section地址显示缓冲区大小。",
          "similarity": 0.5376684069633484
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/sysfs.c",
          "start_line": 34,
          "end_line": 134,
          "content": [
            "static ssize_t module_sect_read(struct file *file, struct kobject *kobj,",
            "\t\t\t\tstruct bin_attribute *battr,",
            "\t\t\t\tchar *buf, loff_t pos, size_t count)",
            "{",
            "\tstruct module_sect_attr *sattr =",
            "\t\tcontainer_of(battr, struct module_sect_attr, battr);",
            "\tchar bounce[MODULE_SECT_READ_SIZE + 1];",
            "\tsize_t wrote;",
            "",
            "\tif (pos != 0)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Since we're a binary read handler, we must account for the",
            "\t * trailing NUL byte that sprintf will write: if \"buf\" is",
            "\t * too small to hold the NUL, or the NUL is exactly the last",
            "\t * byte, the read will look like it got truncated by one byte.",
            "\t * Since there is no way to ask sprintf nicely to not write",
            "\t * the NUL, we have to use a bounce buffer.",
            "\t */",
            "\twrote = scnprintf(bounce, sizeof(bounce), \"0x%px\\n\",",
            "\t\t\t  kallsyms_show_value(file->f_cred)",
            "\t\t\t\t? (void *)sattr->address : NULL);",
            "\tcount = min(count, wrote);",
            "\tmemcpy(buf, bounce, count);",
            "",
            "\treturn count;",
            "}",
            "static void free_sect_attrs(struct module_sect_attrs *sect_attrs)",
            "{",
            "\tunsigned int section;",
            "",
            "\tfor (section = 0; section < sect_attrs->nsections; section++)",
            "\t\tkfree(sect_attrs->attrs[section].battr.attr.name);",
            "\tkfree(sect_attrs);",
            "}",
            "static void add_sect_attrs(struct module *mod, const struct load_info *info)",
            "{",
            "\tunsigned int nloaded = 0, i, size[2];",
            "\tstruct module_sect_attrs *sect_attrs;",
            "\tstruct module_sect_attr *sattr;",
            "\tstruct bin_attribute **gattr;",
            "",
            "\t/* Count loaded sections and allocate structures */",
            "\tfor (i = 0; i < info->hdr->e_shnum; i++)",
            "\t\tif (!sect_empty(&info->sechdrs[i]))",
            "\t\t\tnloaded++;",
            "\tsize[0] = ALIGN(struct_size(sect_attrs, attrs, nloaded),",
            "\t\t\tsizeof(sect_attrs->grp.bin_attrs[0]));",
            "\tsize[1] = (nloaded + 1) * sizeof(sect_attrs->grp.bin_attrs[0]);",
            "\tsect_attrs = kzalloc(size[0] + size[1], GFP_KERNEL);",
            "\tif (!sect_attrs)",
            "\t\treturn;",
            "",
            "\t/* Setup section attributes. */",
            "\tsect_attrs->grp.name = \"sections\";",
            "\tsect_attrs->grp.bin_attrs = (void *)sect_attrs + size[0];",
            "",
            "\tsect_attrs->nsections = 0;",
            "\tsattr = &sect_attrs->attrs[0];",
            "\tgattr = &sect_attrs->grp.bin_attrs[0];",
            "\tfor (i = 0; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *sec = &info->sechdrs[i];",
            "",
            "\t\tif (sect_empty(sec))",
            "\t\t\tcontinue;",
            "\t\tsysfs_bin_attr_init(&sattr->battr);",
            "\t\tsattr->address = sec->sh_addr;",
            "\t\tsattr->battr.attr.name =",
            "\t\t\tkstrdup(info->secstrings + sec->sh_name, GFP_KERNEL);",
            "\t\tif (!sattr->battr.attr.name)",
            "\t\t\tgoto out;",
            "\t\tsect_attrs->nsections++;",
            "\t\tsattr->battr.read = module_sect_read;",
            "\t\tsattr->battr.size = MODULE_SECT_READ_SIZE;",
            "\t\tsattr->battr.attr.mode = 0400;",
            "\t\t*(gattr++) = &(sattr++)->battr;",
            "\t}",
            "\t*gattr = NULL;",
            "",
            "\tif (sysfs_create_group(&mod->mkobj.kobj, &sect_attrs->grp))",
            "\t\tgoto out;",
            "",
            "\tmod->sect_attrs = sect_attrs;",
            "\treturn;",
            "out:",
            "\tfree_sect_attrs(sect_attrs);",
            "}",
            "static void remove_sect_attrs(struct module *mod)",
            "{",
            "\tif (mod->sect_attrs) {",
            "\t\tsysfs_remove_group(&mod->mkobj.kobj,",
            "\t\t\t\t   &mod->sect_attrs->grp);",
            "\t\t/*",
            "\t\t * We are positive that no one is using any sect attrs",
            "\t\t * at this point.  Deallocate immediately.",
            "\t\t */",
            "\t\tfree_sect_attrs(mod->sect_attrs);",
            "\t\tmod->sect_attrs = NULL;",
            "\t}",
            "}"
          ],
          "function_name": "module_sect_read, free_sect_attrs, add_sect_attrs, remove_sect_attrs",
          "description": "实现模块section属性的读取、释放和注册逻辑，通过bin_attribute接口暴露section地址，动态创建并管理sysfs属性组，包含内存分配、属性初始化及错误处理流程。",
          "similarity": 0.5304917097091675
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/module/sysfs.c",
          "start_line": 149,
          "end_line": 265,
          "content": [
            "static ssize_t module_notes_read(struct file *filp, struct kobject *kobj,",
            "\t\t\t\t struct bin_attribute *bin_attr,",
            "\t\t\t\t char *buf, loff_t pos, size_t count)",
            "{",
            "\t/*",
            "\t * The caller checked the pos and count against our size.",
            "\t */",
            "\tmemcpy(buf, bin_attr->private + pos, count);",
            "\treturn count;",
            "}",
            "static void free_notes_attrs(struct module_notes_attrs *notes_attrs,",
            "\t\t\t     unsigned int i)",
            "{",
            "\tif (notes_attrs->dir) {",
            "\t\twhile (i-- > 0)",
            "\t\t\tsysfs_remove_bin_file(notes_attrs->dir,",
            "\t\t\t\t\t      &notes_attrs->attrs[i]);",
            "\t\tkobject_put(notes_attrs->dir);",
            "\t}",
            "\tkfree(notes_attrs);",
            "}",
            "static void add_notes_attrs(struct module *mod, const struct load_info *info)",
            "{",
            "\tunsigned int notes, loaded, i;",
            "\tstruct module_notes_attrs *notes_attrs;",
            "\tstruct bin_attribute *nattr;",
            "",
            "\t/* failed to create section attributes, so can't create notes */",
            "\tif (!mod->sect_attrs)",
            "\t\treturn;",
            "",
            "\t/* Count notes sections and allocate structures.  */",
            "\tnotes = 0;",
            "\tfor (i = 0; i < info->hdr->e_shnum; i++)",
            "\t\tif (!sect_empty(&info->sechdrs[i]) &&",
            "\t\t    info->sechdrs[i].sh_type == SHT_NOTE)",
            "\t\t\t++notes;",
            "",
            "\tif (notes == 0)",
            "\t\treturn;",
            "",
            "\tnotes_attrs = kzalloc(struct_size(notes_attrs, attrs, notes),",
            "\t\t\t      GFP_KERNEL);",
            "\tif (!notes_attrs)",
            "\t\treturn;",
            "",
            "\tnotes_attrs->notes = notes;",
            "\tnattr = &notes_attrs->attrs[0];",
            "\tfor (loaded = i = 0; i < info->hdr->e_shnum; ++i) {",
            "\t\tif (sect_empty(&info->sechdrs[i]))",
            "\t\t\tcontinue;",
            "\t\tif (info->sechdrs[i].sh_type == SHT_NOTE) {",
            "\t\t\tsysfs_bin_attr_init(nattr);",
            "\t\t\tnattr->attr.name = mod->sect_attrs->attrs[loaded].battr.attr.name;",
            "\t\t\tnattr->attr.mode = 0444;",
            "\t\t\tnattr->size = info->sechdrs[i].sh_size;",
            "\t\t\tnattr->private = (void *)info->sechdrs[i].sh_addr;",
            "\t\t\tnattr->read = module_notes_read;",
            "\t\t\t++nattr;",
            "\t\t}",
            "\t\t++loaded;",
            "\t}",
            "",
            "\tnotes_attrs->dir = kobject_create_and_add(\"notes\", &mod->mkobj.kobj);",
            "\tif (!notes_attrs->dir)",
            "\t\tgoto out;",
            "",
            "\tfor (i = 0; i < notes; ++i)",
            "\t\tif (sysfs_create_bin_file(notes_attrs->dir,",
            "\t\t\t\t\t  &notes_attrs->attrs[i]))",
            "\t\t\tgoto out;",
            "",
            "\tmod->notes_attrs = notes_attrs;",
            "\treturn;",
            "",
            "out:",
            "\tfree_notes_attrs(notes_attrs, i);",
            "}",
            "static void remove_notes_attrs(struct module *mod)",
            "{",
            "\tif (mod->notes_attrs)",
            "\t\tfree_notes_attrs(mod->notes_attrs, mod->notes_attrs->notes);",
            "}",
            "static inline void add_sect_attrs(struct module *mod, const struct load_info *info) { }",
            "static inline void remove_sect_attrs(struct module *mod) { }",
            "static inline void add_notes_attrs(struct module *mod, const struct load_info *info) { }",
            "static inline void remove_notes_attrs(struct module *mod) { }",
            "static void del_usage_links(struct module *mod)",
            "{",
            "#ifdef CONFIG_MODULE_UNLOAD",
            "\tstruct module_use *use;",
            "",
            "\tmutex_lock(&module_mutex);",
            "\tlist_for_each_entry(use, &mod->target_list, target_list)",
            "\t\tsysfs_remove_link(use->target->holders_dir, mod->name);",
            "\tmutex_unlock(&module_mutex);",
            "#endif",
            "}",
            "static int add_usage_links(struct module *mod)",
            "{",
            "\tint ret = 0;",
            "#ifdef CONFIG_MODULE_UNLOAD",
            "\tstruct module_use *use;",
            "",
            "\tmutex_lock(&module_mutex);",
            "\tlist_for_each_entry(use, &mod->target_list, target_list) {",
            "\t\tret = sysfs_create_link(use->target->holders_dir,",
            "\t\t\t\t\t&mod->mkobj.kobj, mod->name);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "\tmutex_unlock(&module_mutex);",
            "\tif (ret)",
            "\t\tdel_usage_links(mod);",
            "#endif",
            "\treturn ret;",
            "}"
          ],
          "function_name": "module_notes_read, free_notes_attrs, add_notes_attrs, remove_notes_attrs, add_sect_attrs, remove_sect_attrs, add_notes_attrs, remove_notes_attrs, del_usage_links, add_usage_links",
          "description": "处理模块note段的sysfs暴露，通过binary属性存储note数据，实现notes属性的创建、销毁和链接管理，包含对section属性的引用检查及使用链表操作。",
          "similarity": 0.5238673686981201
        }
      ]
    }
  ]
}