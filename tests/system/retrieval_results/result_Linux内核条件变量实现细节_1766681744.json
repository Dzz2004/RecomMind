{
  "query": "Linux内核条件变量实现细节",
  "timestamp": "2025-12-26 00:55:44",
  "retrieved_files": [
    {
      "source_file": "kernel/params.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:15:19\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `params.c`\n\n---\n\n# params.c 技术文档\n\n## 1. 文件概述\n\n`params.c` 是 Linux 内核中用于解析内核命令行参数（kernel command line）和模块参数（module parameters）的核心辅助文件。它提供了一套通用的参数解析框架，支持从字符串形式的参数值转换为内核内部数据类型，并允许注册自定义参数处理函数。该文件实现了参数的设置、获取、内存管理、安全检查以及未知参数的回调处理机制，是内核启动参数和模块参数系统的基础组件。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `parameq(const char *a, const char *b)` / `parameqn(...)`：比较两个参数名是否相等，将 `-` 视为 `_`（兼容命令行习惯）。\n- `parse_one(...)`：解析单个参数（如 `foo=bar`），在参数表中查找匹配项并调用其 `set` 操作。\n- `parse_args(...)`：解析完整的参数字符串（如 `\"foo=bar,baz=1\"`），按逗号或空格分隔，逐个调用 `parse_one`。\n- `param_set_*` / `param_get_*` 系列函数：为标准数据类型（byte、int、ulong 等）提供参数设置和获取操作。\n- `param_set_charp` / `param_get_charp` / `param_free_charp`：处理字符串类型参数，支持动态内存分配与释放。\n- `param_set_bool` / `param_get_bool`：处理布尔类型参数，支持 `y/n/Y/N/0/1` 等输入格式。\n- `param_check_unsafe(...)`：检查参数是否为“危险”或“硬件相关”，并在安全锁定（lockdown）模式下限制访问。\n\n### 主要数据结构\n\n- `struct kernel_param`：描述一个内核参数，包含名称、操作函数集（`ops`）、参数地址（`arg`）、所属模块（`mod`）和安全标志（`flags`）。\n- `struct kernel_param_ops`：定义参数的操作接口，包括 `set`（设置）、`get`（获取）和可选的 `free`（释放）函数。\n- `struct kmalloced_param`：用于跟踪通过 `kmalloc` 分配的字符串参数内存，便于统一释放。\n\n### 宏定义\n\n- `STANDARD_PARAM_DEF(name, type, format, strtolfn)`：用于快速定义标准类型参数的 `set`/`get` 函数和 `ops` 结构体。\n\n## 3. 关键实现\n\n### 参数名等价处理\n函数 `dash2underscore()` 将连字符 `-` 转换为下划线 `_`，使得命令行中 `foo-bar=1` 可以匹配内核中名为 `foo_bar` 的参数，提升用户友好性。\n\n### 内存管理机制\n对于字符串参数（`charp` 类型），使用 `kmalloced_param` 链表跟踪所有动态分配的内存。在早期启动阶段（slab 分配器不可用时），直接使用命令行字符串指针；后期则分配新内存并复制内容。`maybe_kfree_parameter()` 在参数重设或模块卸载时安全释放内存。\n\n### 并发与锁机制\n在 `CONFIG_SYSFS` 启用时，使用互斥锁（`param_lock` 或模块私有 `param_lock`）保护参数设置操作，防止并发修改。`check_kparam_locked()` 在调试模式下验证锁状态。\n\n### 安全限制\n通过 `param_check_unsafe()` 检查参数标志：\n- 若参数标记为 `KERNEL_PARAM_FL_HWPARAM` 且系统处于 `LOCKDOWN_MODULE_PARAMETERS` 锁定状态，则拒绝设置（返回 `-EPERM`）。\n- 若参数标记为 `KERNEL_PARAM_FL_UNSAFE`，则设置时打印警告并污染内核（`add_taint(TAINT_USER)`）。\n\n### 参数解析流程\n`parse_args()` 使用 `next_arg()` 拆分参数字符串，对每个 `param=val` 调用 `parse_one()`。若未找到匹配参数且提供了 `unknown` 回调，则交由回调处理；否则报错。支持以 `--` 终止解析。\n\n### 标准类型支持\n通过 `STANDARD_PARAM_DEF` 宏自动生成多种整数类型（byte/short/int/long/ulong/ullong/hexint）的参数操作函数，统一使用 `kstrto*` 系列函数进行字符串到数值的转换。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/kernel.h>`：基础内核 API\n  - `<linux/kstrtox.h>`：字符串转数值函数（`kstrtoull` 等）\n  - `<linux/module.h>` / `<linux/moduleparam.h>`：模块参数相关定义\n  - `<linux/security.h>`：安全锁定（lockdown）检查\n  - `<linux/slab.h>`：内存分配（`kmalloc`/`kfree`）\n  - `<linux/ctype.h>`：字符处理（`skip_spaces` 等）\n\n- **配置依赖**：\n  - `CONFIG_SYSFS`：启用参数锁机制\n  - `CONFIG_MODULES`：区分内置参数与模块参数的锁\n\n- **导出符号**：\n  - 所有 `param_set_*`、`param_get_*`、`param_ops_*` 均通过 `EXPORT_SYMBOL` 导出，供模块使用。\n  - `param_set_uint_minmax` 通过 `EXPORT_SYMBOL_GPL` 导出，用于带范围检查的无符号整数参数。\n\n## 5. 使用场景\n\n- **内核启动参数解析**：在 `start_kernel()` 阶段，通过 `parse_args()` 解析 `boot_command_line`，设置内核全局变量（如 `initcall_debug`、`loglevel` 等）。\n- **内核模块参数处理**：模块加载时（`init_module` 系统调用），解析用户传入的参数字符串，调用对应参数的 `set` 函数初始化模块变量。\n- **sysfs 参数接口**：当 `CONFIG_SYSFS` 启用时，模块参数会暴露在 `/sys/module/<modname>/parameters/` 下，读写操作分别调用 `get` 和 `set` 函数。\n- **动态参数调整**：运行时可通过 `sysfs` 或 `modprobe` 修改模块参数值，触发 `param_set_*` 函数执行。\n- **安全敏感系统**：在启用了内核锁定（lockdown）的系统中，阻止用户空间修改关键硬件参数，增强系统安全性。",
      "similarity": 0.5915653705596924,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/params.c",
          "start_line": 463,
          "end_line": 621,
          "content": [
            "static int param_array_set(const char *val, const struct kernel_param *kp)",
            "{",
            "\tconst struct kparam_array *arr = kp->arr;",
            "\tunsigned int temp_num;",
            "",
            "\treturn param_array(kp->mod, kp->name, val, 1, arr->max, arr->elem,",
            "\t\t\t   arr->elemsize, arr->ops->set, kp->level,",
            "\t\t\t   arr->num ?: &temp_num);",
            "}",
            "static int param_array_get(char *buffer, const struct kernel_param *kp)",
            "{",
            "\tint i, off, ret;",
            "\tconst struct kparam_array *arr = kp->arr;",
            "\tstruct kernel_param p = *kp;",
            "",
            "\tfor (i = off = 0; i < (arr->num ? *arr->num : arr->max); i++) {",
            "\t\t/* Replace \\n with comma */",
            "\t\tif (i)",
            "\t\t\tbuffer[off - 1] = ',';",
            "\t\tp.arg = arr->elem + arr->elemsize * i;",
            "\t\tcheck_kparam_locked(p.mod);",
            "\t\tret = arr->ops->get(buffer + off, &p);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t\toff += ret;",
            "\t}",
            "\tbuffer[off] = '\\0';",
            "\treturn off;",
            "}",
            "static void param_array_free(void *arg)",
            "{",
            "\tunsigned int i;",
            "\tconst struct kparam_array *arr = arg;",
            "",
            "\tif (arr->ops->free)",
            "\t\tfor (i = 0; i < (arr->num ? *arr->num : arr->max); i++)",
            "\t\t\tarr->ops->free(arr->elem + arr->elemsize * i);",
            "}",
            "int param_set_copystring(const char *val, const struct kernel_param *kp)",
            "{",
            "\tconst struct kparam_string *kps = kp->str;",
            "",
            "\tif (strlen(val)+1 > kps->maxlen) {",
            "\t\tpr_err(\"%s: string doesn't fit in %u chars.\\n\",",
            "\t\t       kp->name, kps->maxlen-1);",
            "\t\treturn -ENOSPC;",
            "\t}",
            "\tstrcpy(kps->string, val);",
            "\treturn 0;",
            "}",
            "int param_get_string(char *buffer, const struct kernel_param *kp)",
            "{",
            "\tconst struct kparam_string *kps = kp->str;",
            "\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", kps->string);",
            "}",
            "static ssize_t param_attr_show(struct module_attribute *mattr,",
            "\t\t\t       struct module_kobject *mk, char *buf)",
            "{",
            "\tint count;",
            "\tstruct param_attribute *attribute = to_param_attr(mattr);",
            "",
            "\tif (!attribute->param->ops->get)",
            "\t\treturn -EPERM;",
            "",
            "\tkernel_param_lock(mk->mod);",
            "\tcount = attribute->param->ops->get(buf, attribute->param);",
            "\tkernel_param_unlock(mk->mod);",
            "\treturn count;",
            "}",
            "static ssize_t param_attr_store(struct module_attribute *mattr,",
            "\t\t\t\tstruct module_kobject *mk,",
            "\t\t\t\tconst char *buf, size_t len)",
            "{",
            " \tint err;",
            "\tstruct param_attribute *attribute = to_param_attr(mattr);",
            "",
            "\tif (!attribute->param->ops->set)",
            "\t\treturn -EPERM;",
            "",
            "\tkernel_param_lock(mk->mod);",
            "\tif (param_check_unsafe(attribute->param))",
            "\t\terr = attribute->param->ops->set(buf, attribute->param);",
            "\telse",
            "\t\terr = -EPERM;",
            "\tkernel_param_unlock(mk->mod);",
            "\tif (!err)",
            "\t\treturn len;",
            "\treturn err;",
            "}",
            "void kernel_param_lock(struct module *mod)",
            "{",
            "\tmutex_lock(KPARAM_MUTEX(mod));",
            "}",
            "void kernel_param_unlock(struct module *mod)",
            "{",
            "\tmutex_unlock(KPARAM_MUTEX(mod));",
            "}",
            "static __modinit int add_sysfs_param(struct module_kobject *mk,",
            "\t\t\t\t     const struct kernel_param *kp,",
            "\t\t\t\t     const char *name)",
            "{",
            "\tstruct module_param_attrs *new_mp;",
            "\tstruct attribute **new_attrs;",
            "\tunsigned int i;",
            "",
            "\t/* We don't bother calling this with invisible parameters. */",
            "\tBUG_ON(!kp->perm);",
            "",
            "\tif (!mk->mp) {",
            "\t\t/* First allocation. */",
            "\t\tmk->mp = kzalloc(sizeof(*mk->mp), GFP_KERNEL);",
            "\t\tif (!mk->mp)",
            "\t\t\treturn -ENOMEM;",
            "\t\tmk->mp->grp.name = \"parameters\";",
            "\t\t/* NULL-terminated attribute array. */",
            "\t\tmk->mp->grp.attrs = kzalloc(sizeof(mk->mp->grp.attrs[0]),",
            "\t\t\t\t\t    GFP_KERNEL);",
            "\t\t/* Caller will cleanup via free_module_param_attrs */",
            "\t\tif (!mk->mp->grp.attrs)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\t/* Enlarge allocations. */",
            "\tnew_mp = krealloc(mk->mp,",
            "\t\t\t  sizeof(*mk->mp) +",
            "\t\t\t  sizeof(mk->mp->attrs[0]) * (mk->mp->num + 1),",
            "\t\t\t  GFP_KERNEL);",
            "\tif (!new_mp)",
            "\t\treturn -ENOMEM;",
            "\tmk->mp = new_mp;",
            "",
            "\t/* Extra pointer for NULL terminator */",
            "\tnew_attrs = krealloc(mk->mp->grp.attrs,",
            "\t\t\t     sizeof(mk->mp->grp.attrs[0]) * (mk->mp->num + 2),",
            "\t\t\t     GFP_KERNEL);",
            "\tif (!new_attrs)",
            "\t\treturn -ENOMEM;",
            "\tmk->mp->grp.attrs = new_attrs;",
            "",
            "\t/* Tack new one on the end. */",
            "\tmemset(&mk->mp->attrs[mk->mp->num], 0, sizeof(mk->mp->attrs[0]));",
            "\tsysfs_attr_init(&mk->mp->attrs[mk->mp->num].mattr.attr);",
            "\tmk->mp->attrs[mk->mp->num].param = kp;",
            "\tmk->mp->attrs[mk->mp->num].mattr.show = param_attr_show;",
            "\t/* Do not allow runtime DAC changes to make param writable. */",
            "\tif ((kp->perm & (S_IWUSR | S_IWGRP | S_IWOTH)) != 0)",
            "\t\tmk->mp->attrs[mk->mp->num].mattr.store = param_attr_store;",
            "\telse",
            "\t\tmk->mp->attrs[mk->mp->num].mattr.store = NULL;",
            "\tmk->mp->attrs[mk->mp->num].mattr.attr.name = (char *)name;",
            "\tmk->mp->attrs[mk->mp->num].mattr.attr.mode = kp->perm;",
            "\tmk->mp->num++;",
            "",
            "\t/* Fix up all the pointers, since krealloc can move us */",
            "\tfor (i = 0; i < mk->mp->num; i++)",
            "\t\tmk->mp->grp.attrs[i] = &mk->mp->attrs[i].mattr.attr;",
            "\tmk->mp->grp.attrs[mk->mp->num] = NULL;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "param_array_set, param_array_get, param_array_free, param_set_copystring, param_get_string, param_attr_show, param_attr_store, kernel_param_lock, kernel_param_unlock, add_sysfs_param",
          "description": "实现sysfs接口参数暴露机制，包含参数属性展示/存储方法、数组参数处理、字符串拷贝等操作，支持模块参数的动态配置与监控。",
          "similarity": 0.557677149772644
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/params.c",
          "start_line": 265,
          "end_line": 406,
          "content": [
            "int param_set_charp(const char *val, const struct kernel_param *kp)",
            "{",
            "\tif (strlen(val) > 1024) {",
            "\t\tpr_err(\"%s: string parameter too long\\n\", kp->name);",
            "\t\treturn -ENOSPC;",
            "\t}",
            "",
            "\tmaybe_kfree_parameter(*(char **)kp->arg);",
            "",
            "\t/* This is a hack.  We can't kmalloc in early boot, and we",
            "\t * don't need to; this mangled commandline is preserved. */",
            "\tif (slab_is_available()) {",
            "\t\t*(char **)kp->arg = kmalloc_parameter(strlen(val)+1);",
            "\t\tif (!*(char **)kp->arg)",
            "\t\t\treturn -ENOMEM;",
            "\t\tstrcpy(*(char **)kp->arg, val);",
            "\t} else",
            "\t\t*(const char **)kp->arg = val;",
            "",
            "\treturn 0;",
            "}",
            "int param_get_charp(char *buffer, const struct kernel_param *kp)",
            "{",
            "\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", *((char **)kp->arg));",
            "}",
            "void param_free_charp(void *arg)",
            "{",
            "\tmaybe_kfree_parameter(*((char **)arg));",
            "}",
            "int param_set_bool(const char *val, const struct kernel_param *kp)",
            "{",
            "\t/* No equals means \"set\"... */",
            "\tif (!val) val = \"1\";",
            "",
            "\t/* One of =[yYnN01] */",
            "\treturn kstrtobool(val, kp->arg);",
            "}",
            "int param_get_bool(char *buffer, const struct kernel_param *kp)",
            "{",
            "\t/* Y and N chosen as being relatively non-coder friendly */",
            "\treturn sprintf(buffer, \"%c\\n\", *(bool *)kp->arg ? 'Y' : 'N');",
            "}",
            "int param_set_bool_enable_only(const char *val, const struct kernel_param *kp)",
            "{",
            "\tint err;",
            "\tbool new_value;",
            "\tbool orig_value = *(bool *)kp->arg;",
            "\tstruct kernel_param dummy_kp = *kp;",
            "",
            "\tdummy_kp.arg = &new_value;",
            "",
            "\terr = param_set_bool(val, &dummy_kp);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\t/* Don't let them unset it once it's set! */",
            "\tif (!new_value && orig_value)",
            "\t\treturn -EROFS;",
            "",
            "\tif (new_value)",
            "\t\terr = param_set_bool(val, kp);",
            "",
            "\treturn err;",
            "}",
            "int param_set_invbool(const char *val, const struct kernel_param *kp)",
            "{",
            "\tint ret;",
            "\tbool boolval;",
            "\tstruct kernel_param dummy;",
            "",
            "\tdummy.arg = &boolval;",
            "\tret = param_set_bool(val, &dummy);",
            "\tif (ret == 0)",
            "\t\t*(bool *)kp->arg = !boolval;",
            "\treturn ret;",
            "}",
            "int param_get_invbool(char *buffer, const struct kernel_param *kp)",
            "{",
            "\treturn sprintf(buffer, \"%c\\n\", (*(bool *)kp->arg) ? 'N' : 'Y');",
            "}",
            "int param_set_bint(const char *val, const struct kernel_param *kp)",
            "{",
            "\t/* Match bool exactly, by re-using it. */",
            "\tstruct kernel_param boolkp = *kp;",
            "\tbool v;",
            "\tint ret;",
            "",
            "\tboolkp.arg = &v;",
            "",
            "\tret = param_set_bool(val, &boolkp);",
            "\tif (ret == 0)",
            "\t\t*(int *)kp->arg = v;",
            "\treturn ret;",
            "}",
            "static int param_array(struct module *mod,",
            "\t\t       const char *name,",
            "\t\t       const char *val,",
            "\t\t       unsigned int min, unsigned int max,",
            "\t\t       void *elem, int elemsize,",
            "\t\t       int (*set)(const char *, const struct kernel_param *kp),",
            "\t\t       s16 level,",
            "\t\t       unsigned int *num)",
            "{",
            "\tint ret;",
            "\tstruct kernel_param kp;",
            "\tchar save;",
            "",
            "\t/* Get the name right for errors. */",
            "\tkp.name = name;",
            "\tkp.arg = elem;",
            "\tkp.level = level;",
            "",
            "\t*num = 0;",
            "\t/* We expect a comma-separated list of values. */",
            "\tdo {",
            "\t\tint len;",
            "",
            "\t\tif (*num == max) {",
            "\t\t\tpr_err(\"%s: can only take %i arguments\\n\", name, max);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t\tlen = strcspn(val, \",\");",
            "",
            "\t\t/* nul-terminate and parse */",
            "\t\tsave = val[len];",
            "\t\t((char *)val)[len] = '\\0';",
            "\t\tcheck_kparam_locked(mod);",
            "\t\tret = set(val, &kp);",
            "",
            "\t\tif (ret != 0)",
            "\t\t\treturn ret;",
            "\t\tkp.arg += elemsize;",
            "\t\tval += len+1;",
            "\t\t(*num)++;",
            "\t} while (save == ',');",
            "",
            "\tif (*num < min) {",
            "\t\tpr_err(\"%s: needs at least %i arguments\\n\", name, min);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "param_set_charp, param_get_charp, param_free_charp, param_set_bool, param_get_bool, param_set_bool_enable_only, param_set_invbool, param_get_invbool, param_set_bint, param_array",
          "description": "提供特定参数类型的处理实现，包括字符串参数分配、布尔值转换、数组参数处理等，包含内存管理、格式化输出等辅助功能。",
          "similarity": 0.5511921048164368
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/params.c",
          "start_line": 868,
          "end_line": 955,
          "content": [
            "static void __init version_sysfs_builtin(void)",
            "{",
            "\tconst struct module_version_attribute *vattr;",
            "\tstruct module_kobject *mk;",
            "\tint err;",
            "",
            "\tfor (vattr = __start___modver; vattr < __stop___modver; vattr++) {",
            "\t\tmk = lookup_or_create_module_kobject(vattr->module_name);",
            "\t\tif (mk) {",
            "\t\t\terr = sysfs_create_file(&mk->kobj, &vattr->mattr.attr);",
            "\t\t\tWARN_ON_ONCE(err);",
            "\t\t\tkobject_uevent(&mk->kobj, KOBJ_ADD);",
            "\t\t\tkobject_put(&mk->kobj);",
            "\t\t}",
            "\t}",
            "}",
            "static ssize_t module_attr_show(struct kobject *kobj,",
            "\t\t\t\tstruct attribute *attr,",
            "\t\t\t\tchar *buf)",
            "{",
            "\tstruct module_attribute *attribute;",
            "\tstruct module_kobject *mk;",
            "\tint ret;",
            "",
            "\tattribute = to_module_attr(attr);",
            "\tmk = to_module_kobject(kobj);",
            "",
            "\tif (!attribute->show)",
            "\t\treturn -EIO;",
            "",
            "\tret = attribute->show(attribute, mk, buf);",
            "",
            "\treturn ret;",
            "}",
            "static ssize_t module_attr_store(struct kobject *kobj,",
            "\t\t\t\tstruct attribute *attr,",
            "\t\t\t\tconst char *buf, size_t len)",
            "{",
            "\tstruct module_attribute *attribute;",
            "\tstruct module_kobject *mk;",
            "\tint ret;",
            "",
            "\tattribute = to_module_attr(attr);",
            "\tmk = to_module_kobject(kobj);",
            "",
            "\tif (!attribute->store)",
            "\t\treturn -EIO;",
            "",
            "\tret = attribute->store(attribute, mk, buf, len);",
            "",
            "\treturn ret;",
            "}",
            "static int uevent_filter(const struct kobject *kobj)",
            "{",
            "\tconst struct kobj_type *ktype = get_ktype(kobj);",
            "",
            "\tif (ktype == &module_ktype)",
            "\t\treturn 1;",
            "\treturn 0;",
            "}",
            "static void module_kobj_release(struct kobject *kobj)",
            "{",
            "\tstruct module_kobject *mk = to_module_kobject(kobj);",
            "",
            "\tif (mk->kobj_completion)",
            "\t\tcomplete(mk->kobj_completion);",
            "}",
            "static int __init param_sysfs_init(void)",
            "{",
            "\tmodule_kset = kset_create_and_add(\"module\", &module_uevent_ops, NULL);",
            "\tif (!module_kset) {",
            "\t\tprintk(KERN_WARNING \"%s (%d): error creating kset\\n\",",
            "\t\t\t__FILE__, __LINE__);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init param_sysfs_builtin_init(void)",
            "{",
            "\tif (!module_kset)",
            "\t\treturn -ENOMEM;",
            "",
            "\tversion_sysfs_builtin();",
            "\tparam_sysfs_builtin();",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "version_sysfs_builtin, module_attr_show, module_attr_store, uevent_filter, module_kobj_release, param_sysfs_init, param_sysfs_builtin_init",
          "description": "该代码段主要实现模块参数的SysFS接口初始化与管理，包含以下功能：  \n1. `version_sysfs_builtin` 初始化模块版本属性到SysFS，创建对应文件并触发设备添加事件；  \n2. `module_attr_show/store` 定义模块属性的通用读写接口，通过回调函数实现具体逻辑；  \n3. `param_sysfs_init` 创建模块KSet并注册UEVENT过滤规则，`param_sysfs_builtin_init` 统一调用版本相关初始化函数。",
          "similarity": 0.530001163482666
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/params.c",
          "start_line": 29,
          "end_line": 143,
          "content": [
            "static inline void check_kparam_locked(struct module *mod)",
            "{",
            "\tBUG_ON(!mutex_is_locked(KPARAM_MUTEX(mod)));",
            "}",
            "static inline void check_kparam_locked(struct module *mod)",
            "{",
            "}",
            "static void maybe_kfree_parameter(void *param)",
            "{",
            "\tstruct kmalloced_param *p;",
            "",
            "\tspin_lock(&kmalloced_params_lock);",
            "\tlist_for_each_entry(p, &kmalloced_params, list) {",
            "\t\tif (p->val == param) {",
            "\t\t\tlist_del(&p->list);",
            "\t\t\tkfree(p);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tspin_unlock(&kmalloced_params_lock);",
            "}",
            "static char dash2underscore(char c)",
            "{",
            "\tif (c == '-')",
            "\t\treturn '_';",
            "\treturn c;",
            "}",
            "bool parameqn(const char *a, const char *b, size_t n)",
            "{",
            "\tsize_t i;",
            "",
            "\tfor (i = 0; i < n; i++) {",
            "\t\tif (dash2underscore(a[i]) != dash2underscore(b[i]))",
            "\t\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "bool parameq(const char *a, const char *b)",
            "{",
            "\treturn parameqn(a, b, strlen(a)+1);",
            "}",
            "static bool param_check_unsafe(const struct kernel_param *kp)",
            "{",
            "\tif (kp->flags & KERNEL_PARAM_FL_HWPARAM &&",
            "\t    security_locked_down(LOCKDOWN_MODULE_PARAMETERS))",
            "\t\treturn false;",
            "",
            "\tif (kp->flags & KERNEL_PARAM_FL_UNSAFE) {",
            "\t\tpr_notice(\"Setting dangerous option %s - tainting kernel\\n\",",
            "\t\t\t  kp->name);",
            "\t\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);",
            "\t}",
            "",
            "\treturn true;",
            "}",
            "static int parse_one(char *param,",
            "\t\t     char *val,",
            "\t\t     const char *doing,",
            "\t\t     const struct kernel_param *params,",
            "\t\t     unsigned num_params,",
            "\t\t     s16 min_level,",
            "\t\t     s16 max_level,",
            "\t\t     void *arg,",
            "\t\t     int (*handle_unknown)(char *param, char *val,",
            "\t\t\t\t     const char *doing, void *arg))",
            "{",
            "\tunsigned int i;",
            "\tint err;",
            "",
            "\t/* Find parameter */",
            "\tfor (i = 0; i < num_params; i++) {",
            "\t\tif (parameq(param, params[i].name)) {",
            "\t\t\tif (params[i].level < min_level",
            "\t\t\t    || params[i].level > max_level)",
            "\t\t\t\treturn 0;",
            "\t\t\t/* No one handled NULL, so do it here. */",
            "\t\t\tif (!val &&",
            "\t\t\t    !(params[i].ops->flags & KERNEL_PARAM_OPS_FL_NOARG))",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\tpr_debug(\"handling %s with %p\\n\", param,",
            "\t\t\t\tparams[i].ops->set);",
            "\t\t\tkernel_param_lock(params[i].mod);",
            "\t\t\tif (param_check_unsafe(&params[i]))",
            "\t\t\t\terr = params[i].ops->set(val, &params[i]);",
            "\t\t\telse",
            "\t\t\t\terr = -EPERM;",
            "\t\t\tkernel_param_unlock(params[i].mod);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t}",
            "",
            "\tif (handle_unknown) {",
            "\t\tpr_debug(\"doing %s: %s='%s'\\n\", doing, param, val);",
            "\t\treturn handle_unknown(param, val, doing, arg);",
            "\t}",
            "",
            "\tpr_debug(\"Unknown argument '%s'\\n\", param);",
            "\treturn -ENOENT;",
            "}",
            "int param_set_uint_minmax(const char *val, const struct kernel_param *kp,",
            "\t\tunsigned int min, unsigned int max)",
            "{",
            "\tunsigned int num;",
            "\tint ret;",
            "",
            "\tif (!val)",
            "\t\treturn -EINVAL;",
            "\tret = kstrtouint(val, 0, &num);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tif (num < min || num > max)",
            "\t\treturn -EINVAL;",
            "\t*((unsigned int *)kp->arg) = num;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "check_kparam_locked, check_kparam_locked, maybe_kfree_parameter, dash2underscore, parameqn, parameq, param_check_unsafe, parse_one, param_set_uint_minmax",
          "description": "实现参数解析核心逻辑，包含参数匹配、权限检查、类型转换及异常处理，支持布尔、整数、字符串等基本类型参数的统一处理框架。",
          "similarity": 0.5153672099113464
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/params.c",
          "start_line": 690,
          "end_line": 795,
          "content": [
            "static void free_module_param_attrs(struct module_kobject *mk)",
            "{",
            "\tif (mk->mp)",
            "\t\tkfree(mk->mp->grp.attrs);",
            "\tkfree(mk->mp);",
            "\tmk->mp = NULL;",
            "}",
            "int module_param_sysfs_setup(struct module *mod,",
            "\t\t\t     const struct kernel_param *kparam,",
            "\t\t\t     unsigned int num_params)",
            "{",
            "\tint i, err;",
            "\tbool params = false;",
            "",
            "\tfor (i = 0; i < num_params; i++) {",
            "\t\tif (kparam[i].perm == 0)",
            "\t\t\tcontinue;",
            "\t\terr = add_sysfs_param(&mod->mkobj, &kparam[i], kparam[i].name);",
            "\t\tif (err) {",
            "\t\t\tfree_module_param_attrs(&mod->mkobj);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t\tparams = true;",
            "\t}",
            "",
            "\tif (!params)",
            "\t\treturn 0;",
            "",
            "\t/* Create the param group. */",
            "\terr = sysfs_create_group(&mod->mkobj.kobj, &mod->mkobj.mp->grp);",
            "\tif (err)",
            "\t\tfree_module_param_attrs(&mod->mkobj);",
            "\treturn err;",
            "}",
            "void module_param_sysfs_remove(struct module *mod)",
            "{",
            "\tif (mod->mkobj.mp) {",
            "\t\tsysfs_remove_group(&mod->mkobj.kobj, &mod->mkobj.mp->grp);",
            "\t\t/* We are positive that no one is using any param",
            "\t\t * attrs at this point.  Deallocate immediately. */",
            "\t\tfree_module_param_attrs(&mod->mkobj);",
            "\t}",
            "}",
            "void destroy_params(const struct kernel_param *params, unsigned num)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 0; i < num; i++)",
            "\t\tif (params[i].ops->free)",
            "\t\t\tparams[i].ops->free(params[i].arg);",
            "}",
            "static void __init kernel_add_sysfs_param(const char *name,",
            "\t\t\t\t\t  const struct kernel_param *kparam,",
            "\t\t\t\t\t  unsigned int name_skip)",
            "{",
            "\tstruct module_kobject *mk;",
            "\tint err;",
            "",
            "\tmk = lookup_or_create_module_kobject(name);",
            "\tif (!mk)",
            "\t\treturn;",
            "",
            "\t/* We need to remove old parameters before adding more. */",
            "\tif (mk->mp)",
            "\t\tsysfs_remove_group(&mk->kobj, &mk->mp->grp);",
            "",
            "\t/* These should not fail at boot. */",
            "\terr = add_sysfs_param(mk, kparam, kparam->name + name_skip);",
            "\tBUG_ON(err);",
            "\terr = sysfs_create_group(&mk->kobj, &mk->mp->grp);",
            "\tBUG_ON(err);",
            "\tkobject_uevent(&mk->kobj, KOBJ_ADD);",
            "\tkobject_put(&mk->kobj);",
            "}",
            "static void __init param_sysfs_builtin(void)",
            "{",
            "\tconst struct kernel_param *kp;",
            "\tunsigned int name_len;",
            "\tchar modname[MODULE_NAME_LEN];",
            "",
            "\tfor (kp = __start___param; kp < __stop___param; kp++) {",
            "\t\tchar *dot;",
            "",
            "\t\tif (kp->perm == 0)",
            "\t\t\tcontinue;",
            "",
            "\t\tdot = strchr(kp->name, '.');",
            "\t\tif (!dot) {",
            "\t\t\t/* This happens for core_param() */",
            "\t\t\tstrcpy(modname, \"kernel\");",
            "\t\t\tname_len = 0;",
            "\t\t} else {",
            "\t\t\tname_len = dot - kp->name + 1;",
            "\t\t\tstrscpy(modname, kp->name, name_len);",
            "\t\t}",
            "\t\tkernel_add_sysfs_param(modname, kp, name_len);",
            "\t}",
            "}",
            "ssize_t __modver_version_show(struct module_attribute *mattr,",
            "\t\t\t      struct module_kobject *mk, char *buf)",
            "{",
            "\tstruct module_version_attribute *vattr =",
            "\t\tcontainer_of(mattr, struct module_version_attribute, mattr);",
            "",
            "\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", vattr->version);",
            "}"
          ],
          "function_name": "free_module_param_attrs, module_param_sysfs_setup, module_param_sysfs_remove, destroy_params, kernel_add_sysfs_param, param_sysfs_builtin, __modver_version_show",
          "description": "管理模块参数的sysfs节点生命周期，包含参数组创建/移除、参数释放、内核内置参数注册等基础设施，负责模块参数的系统级集成。",
          "similarity": 0.4931475818157196
        }
      ]
    },
    {
      "source_file": "kernel/module/internal.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:01:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\internal.h`\n\n---\n\n# `module/internal.h` 技术文档\n\n## 1. 文件概述\n\n`module/internal.h` 是 Linux 内核模块子系统的核心内部头文件，定义了模块加载、符号解析、内存布局、调试统计等关键内部数据结构和辅助函数。该文件仅供内核模块子系统内部使用，不对外暴露给模块开发者。它封装了模块加载过程中的中间状态、符号查找逻辑、内存管理细节以及与架构相关的重定位处理，并集成了模块压缩、热补丁（livepatch）、污点追踪（taint tracking）和调试统计等可选功能的支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct kernel_symbol`**  \n  内核符号的内部表示，支持两种模式：  \n  - 普通模式：直接存储符号值（`value`）、名称（`name`）和命名空间（`namespace`）指针。  \n  - `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 模式：使用偏移量（`value_offset` 等）以节省内存并支持位置无关代码。\n\n- **`struct load_info`**  \n  模块加载过程中的临时信息容器，包含 ELF 头、节头表、字符串表、符号表、各节偏移、签名状态、解压页信息等，贯穿整个 `load_module()` 流程。\n\n- **`struct find_symbol_arg`**  \n  符号查找的输入/输出参数结构，用于 `find_symbol()` 函数，支持按名称、GPL 许可限制进行符号搜索。\n\n- **`enum fail_dup_mod_reason`**  \n  定义重复模块加载失败的两种场景：`FAIL_DUP_MOD_BECOMING`（早期检查阶段发现重复）和 `FAIL_DUP_MOD_LOAD`（分配内存后发现重复）。\n\n- **`struct mod_fail_load`**（仅当 `CONFIG_MODULE_STATS` 启用）  \n  用于统计重复加载失败的模块信息。\n\n- **`struct mod_unload_taint`**（仅当 `CONFIG_MODULE_UNLOAD_TAINT_TRACKING` 启用）  \n  记录卸载时带有污点（taint）的模块信息。\n\n### 主要函数\n\n- **符号管理**  \n  - `find_symbol()`：在全局符号表中查找指定名称的符号。  \n  - `kernel_symbol_value()`：获取 `kernel_symbol` 结构中符号的实际地址。\n\n- **模块加载辅助**  \n  - `mod_verify_sig()`：验证模块签名。  \n  - `try_to_force_load()`：在特定条件下强制加载被拒绝的模块（如 taint 原因）。  \n  - `module_get_offset_and_type()`：计算模块节在目标内存布局中的偏移和内存类型。  \n  - `module_flags()` / `module_flags_taint()`：生成模块状态或污点标志的字符串表示。\n\n- **模块信息解析**  \n  - `module_next_tag_pair()`：解析模块信息（modinfo）中的键值对。  \n  - `for_each_modinfo_entry`：遍历指定名称的 modinfo 条目。\n\n- **热补丁支持**（`CONFIG_LIVEPATCH`）  \n  - `copy_module_elf()` / `free_module_elf()`：复制或释放模块的 ELF 原始数据，供 livepatch 使用。  \n  - `set_livepatch_module()`：标记模块为 livepatch 模块。\n\n- **统计与调试**（条件编译）  \n  - `try_add_failed_module()`：记录重复加载失败事件。  \n  - `mod_stat_bump_invalid()` / `mod_stat_bump_becoming()`：更新无效或正在加载的模块统计。  \n  - `try_add_tainted_module()` / `print_unloaded_tainted_modules()`：跟踪并打印卸载时带污点的模块。  \n  - `kmod_dup_request_exists_wait()` / `kmod_dup_request_announce()`：用于调试自动加载重复请求。\n\n- **解压支持**（`CONFIG_MODULE_DECOMPRESS`）  \n  - `module_decompress()` / `module_decompress_cleanup()`：解压压缩的模块镜像。\n\n### 全局变量\n\n- `module_mutex`：保护模块列表和状态的全局互斥锁。  \n- `modules`：已加载模块的全局链表。  \n- `modinfo_attrs[]` / `modinfo_attrs_count`：模块信息属性数组及其数量。  \n- `__start___ksymtab[]` 等：链接器生成的内核符号表起止标记。  \n- 各类统计计数器（如 `total_mod_size`, `modcount` 等，仅当 `CONFIG_MODULE_STATS` 启用）。\n\n## 3. 关键实现\n\n### 符号表与重定位优化\n- 通过 `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 支持使用 32 位相对偏移代替 64 位绝对指针，显著减少符号表内存占用，尤其在 64 位系统上。\n- `kernel_symbol_value()` 宏根据配置自动选择解析方式，对上层透明。\n\n### 节类型编码\n- 利用 ELF 节头 `sh_entsize` 的高 4 位存储 `mod_mem_type`（内存类型），低 28/60 位存储偏移量。\n- 定义了 `SH_ENTSIZE_TYPE_BITS`、`SH_ENTSIZE_TYPE_MASK` 等宏进行位操作，确保在 32/64 位系统上正确分离类型与偏移。\n\n### 模块加载状态保护\n- `module_assert_mutex_or_preempt()` 利用 `lockdep` 和 `rcu_read_lock_sched_held()` 确保关键操作在持有 `module_mutex` 或处于 RCU 读临界区中执行，防止并发错误。\n\n### 重复模块检测\n- `enum fail_dup_mod_reason` 精确区分重复模块在加载流程中被发现的两个关键点，有助于分析资源浪费（如 vmap 空间）和竞态条件。\n\n### 条件编译功能集成\n- 通过 `#ifdef CONFIG_XXX` 将模块统计、污点追踪、自动加载调试、解压、热补丁等功能模块化，保持核心逻辑简洁，按需启用。\n\n## 4. 依赖关系\n\n- **内核核心头文件**：  \n  - `<linux/elf.h>`：ELF 格式定义。  \n  - `<linux/module.h>`：模块公共接口。  \n  - `<linux/mutex.h>`, `<linux/rculist.h>`, `<linux/rcupdate.h>`：同步原语。  \n  - `<linux/mm.h>`：内存管理相关定义。\n\n- **架构相关**：  \n  - `ARCH_SHF_SMALL`：架构特定的节标志，用于小内存模型。\n\n- **可选子系统**：  \n  - `CONFIG_KALLSYMS`：内核符号表支持。  \n  - `CONFIG_LIVEPATCH`：内核热补丁。  \n  - `CONFIG_MODULE_DECOMPRESS`：模块解压。  \n  - `CONFIG_MODULE_STATS` / `CONFIG_MODULE_DEBUGFS` / `CONFIG_MODULE_UNLOAD_TAINT_TRACKING` / `CONFIG_MODULE_DEBUG_AUTOLOAD_DUPS`：各类调试与统计功能。\n\n- **链接器脚本**：  \n  - 依赖链接器生成的 `__start___ksymtab`、`__stop___ksymtab_gpl` 等符号，用于遍历内建符号表。\n\n## 5. 使用场景\n\n- **模块加载流程**：`load_module()` 及其辅助函数使用 `struct load_info` 传递解析后的 ELF 信息，并调用 `mod_verify_sig()`、`module_decompress()` 等进行预处理。\n- **符号解析**：`find_symbol()` 被 `kernel/module.c` 中的符号导出/导入机制调用，实现模块间及内核与模块间的符号链接。\n- **内存布局**：`module_get_offset_and_type()` 在 `layout_and_allocate()` 阶段确定各节在模块内存映像中的位置。\n- **调试与监控**：  \n  - `module_flags()` 用于 `/sys/module/<name>/taint` 等接口显示模块状态。  \n  - 统计功能（`CONFIG_MODULE_STATS`）帮助分析模块加载性能与失败原因。  \n  - 污点追踪（`CONFIG_MODULE_UNLOAD_TAINT_TRACKING`）记录可能导致系统不稳定模块的卸载信息。\n- **热补丁**：livepatch 子系统通过 `copy_module_elf()` 保留原始 ELF 用于补丁验证和回滚。\n- **并发控制**：所有修改全局模块列表或状态的操作必须通过 `module_mutex` 保护，`module_assert_mutex_or_preempt()` 用于运行时检查。",
      "similarity": 0.581071138381958,
      "chunks": []
    },
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.5704185962677002,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.5468080043792725
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.4967189431190491
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.4748508930206299
        }
      ]
    }
  ]
}