{
  "query": "引导程序如何加载内核镜像",
  "timestamp": "2025-12-26 00:36:01",
  "retrieved_files": [
    {
      "source_file": "kernel/kexec.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:23:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kexec.c`\n\n---\n\n# kexec.c 技术文档\n\n## 1. 文件概述\n\n`kexec.c` 是 Linux 内核中实现 `kexec_load` 系统调用的核心源文件，负责加载新内核镜像以支持在不重启硬件的情况下切换到另一个内核（即“热启动”）。该机制广泛用于快速重启、内核崩溃转储（crash dump）以及高可用性系统中。文件主要处理用户空间传入的内核镜像段、进行安全性和合法性校验、分配必要的控制结构和内存页，并调用架构相关代码完成最终的加载准备。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`kimage_alloc_init()`**  \n  分配并初始化 `kimage` 控制结构，验证段列表合法性，分配控制代码页和交换页（非崩溃场景）。\n\n- **`do_kexec_load()`**  \n  执行 `kexec_load` 的核心逻辑：加锁、释放旧镜像、调用 `kimage_alloc_init()`、准备架构相关资源、复制段数据、设置最终镜像指针。\n\n- **`kexec_load_check()`**  \n  执行权限、安全模块（LSM/IMA）、锁定策略（LOCKDOWN）及参数合法性检查。\n\n- **`SYSCALL_DEFINE4(kexec_load)`**  \n  64 位系统调用入口，从用户空间复制 `kexec_segment` 数组并调用 `do_kexec_load()`。\n\n- **`COMPAT_SYSCALL_DEFINE4(kexec_load)`**  \n  32 位兼容系统调用入口，处理 `compat_kexec_segment` 结构的转换。\n\n### 关键数据结构\n\n- **`struct kimage`**（定义于 `kexec_internal.h`）  \n  表示一个待加载的内核镜像，包含入口地址、段信息、控制页、交换页、类型（普通/崩溃）等字段。\n\n- **`struct kexec_segment`**  \n  描述一个内存段，包含用户缓冲区地址/大小（`buf`/`bufsz`）和目标物理地址/大小（`mem`/`memsz`）。\n\n## 3. 关键实现\n\n### 镜像加载流程\n1. **权限与安全校验**：通过 `kexec_load_check()` 确保调用者具有 `CAP_SYS_BOOT` 能力，并通过 LSM 和内核锁定机制（如 `LOCKDOWN_KEXEC`）防止绕过模块加载限制。\n2. **崩溃内核特殊处理**：\n   - 若设置了 `KEXEC_ON_CRASH` 标志，则镜像类型为 `KEXEC_TYPE_CRASH`。\n   - 入口地址必须位于 `crashk_res`（崩溃保留内存区域）内。\n   - 控制页固定为 `crashk_res.start`，且不分配交换页。\n   - 加载过程中需临时解除对崩溃内存区域的保护（`arch_kexec_unprotect_crashkres()`），加载完成后重新保护。\n3. **内存分配**：\n   - 使用 `kimage_alloc_control_pages()` 分配控制代码页（大小为 `KEXEC_CONTROL_PAGE_SIZE`）。\n   - 普通镜像额外分配一个交换页用于段加载时的页面交换。\n4. **段加载**：遍历所有段，调用 `kimage_load_segment()` 将用户数据复制到目标物理内存。\n5. **架构适配**：\n   - 调用 `machine_kexec_prepare()` 进行架构特定的准备（如设置页表、禁用中断等）。\n   - 调用 `kimage_crash_copy_vmcoreinfo()` 在准备完成后更新崩溃转储所需的 `vmcoreinfo` 数据。\n   - 最终调用 `machine_kexec_post_load()` 完成架构相关后处理。\n\n### 并发控制\n- 使用 `kexec_trylock()`/`kexec_unlock()` 互斥锁防止多个进程同时加载崩溃内核，避免破坏保留内存区域。\n\n### 兼容性支持\n- 通过 `COMPAT_SYSCALL_DEFINE4` 处理 32 位用户程序在 64 位内核上的调用，将 `compat_ptr` 转换为原生指针。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/kexec.h>`：定义 `kexec_segment`、`KEXEC_*` 常量及公共接口。\n  - `\"kexec_internal.h\"`：包含 `kimage` 结构及内部函数声明（如 `do_kimage_alloc_init`、`kimage_free`）。\n  - `<linux/security.h>`：提供 LSM 安全钩子（`security_kernel_load_data`、`security_locked_down`）。\n  - `<linux/crash_dump.h>`（隐式）：通过 `CONFIG_CRASH_DUMP` 条件编译使用 `crashk_res`。\n\n- **架构相关代码**：\n  - `arch_kexec_protect_crashkres()` / `arch_kexec_unprotect_crashkres()`：由各架构实现，用于保护/解除保护崩溃内存区域。\n  - `machine_kexec_prepare()` / `machine_kexec_post_load()`：架构特定的镜像准备和后处理函数。\n\n- **内存管理子系统**：\n  - 依赖 `vmalloc`、`slab` 分配器及 `kimage_alloc_control_pages()`（通常基于 `alloc_pages()`）。\n\n## 5. 使用场景\n\n- **快速系统重启**：通过 `kexec` 工具加载新内核并跳转，跳过 BIOS/UEFI 和硬件初始化阶段，显著缩短重启时间。\n- **内核崩溃转储（kdump）**：\n  - 系统崩溃前预先加载一个“捕获内核”（通过 `KEXEC_ON_CRASH` 标志）。\n  - 崩溃时直接跳转至捕获内核，将原内核内存保存为 `vmcore` 文件用于事后分析。\n- **高可用性系统**：在关键服务中实现无缝内核切换，减少停机时间。\n- **内核开发与测试**：快速迭代测试新内核版本，无需物理重启。",
      "similarity": 0.6195746064186096,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/kexec.c",
          "start_line": 1,
          "end_line": 21,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * kexec.c - kexec_load system call",
            " * Copyright (C) 2002-2004 Eric Biederman  <ebiederm@xmission.com>",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/security.h>",
            "#include <linux/kexec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "",
            "#include \"kexec_internal.h\"",
            ""
          ],
          "function_name": null,
          "description": "声明GPL许可证和注释，引入kexec相关头文件及内部实现头文件，为kexec_load系统调用提供基础支持",
          "similarity": 0.522470235824585
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/kexec.c",
          "start_line": 22,
          "end_line": 178,
          "content": [
            "static int kimage_alloc_init(struct kimage **rimage, unsigned long entry,",
            "\t\t\t     unsigned long nr_segments,",
            "\t\t\t     struct kexec_segment *segments,",
            "\t\t\t     unsigned long flags)",
            "{",
            "\tint ret;",
            "\tstruct kimage *image;",
            "\tbool kexec_on_panic = flags & KEXEC_ON_CRASH;",
            "",
            "#ifdef CONFIG_CRASH_DUMP",
            "\tif (kexec_on_panic) {",
            "\t\t/* Verify we have a valid entry point */",
            "\t\tif ((entry < phys_to_boot_phys(crashk_res.start)) ||",
            "\t\t    (entry > phys_to_boot_phys(crashk_res.end)))",
            "\t\t\treturn -EADDRNOTAVAIL;",
            "\t}",
            "#endif",
            "",
            "\t/* Allocate and initialize a controlling structure */",
            "\timage = do_kimage_alloc_init();",
            "\tif (!image)",
            "\t\treturn -ENOMEM;",
            "",
            "\timage->start = entry;",
            "\timage->nr_segments = nr_segments;",
            "\tmemcpy(image->segment, segments, nr_segments * sizeof(*segments));",
            "",
            "#ifdef CONFIG_CRASH_DUMP",
            "\tif (kexec_on_panic) {",
            "\t\t/* Enable special crash kernel control page alloc policy. */",
            "\t\timage->control_page = crashk_res.start;",
            "\t\timage->type = KEXEC_TYPE_CRASH;",
            "\t}",
            "#endif",
            "",
            "\tret = sanity_check_segment_list(image);",
            "\tif (ret)",
            "\t\tgoto out_free_image;",
            "",
            "\t/*",
            "\t * Find a location for the control code buffer, and add it",
            "\t * the vector of segments so that it's pages will also be",
            "\t * counted as destination pages.",
            "\t */",
            "\tret = -ENOMEM;",
            "\timage->control_code_page = kimage_alloc_control_pages(image,",
            "\t\t\t\t\t   get_order(KEXEC_CONTROL_PAGE_SIZE));",
            "\tif (!image->control_code_page) {",
            "\t\tpr_err(\"Could not allocate control_code_buffer\\n\");",
            "\t\tgoto out_free_image;",
            "\t}",
            "",
            "\tif (!kexec_on_panic) {",
            "\t\timage->swap_page = kimage_alloc_control_pages(image, 0);",
            "\t\tif (!image->swap_page) {",
            "\t\t\tpr_err(\"Could not allocate swap buffer\\n\");",
            "\t\t\tgoto out_free_control_pages;",
            "\t\t}",
            "\t}",
            "",
            "\t*rimage = image;",
            "\treturn 0;",
            "out_free_control_pages:",
            "\tkimage_free_page_list(&image->control_pages);",
            "out_free_image:",
            "\tkfree(image);",
            "\treturn ret;",
            "}",
            "static int do_kexec_load(unsigned long entry, unsigned long nr_segments,",
            "\t\tstruct kexec_segment *segments, unsigned long flags)",
            "{",
            "\tstruct kimage **dest_image, *image;",
            "\tunsigned long i;",
            "\tint ret;",
            "",
            "\t/*",
            "\t * Because we write directly to the reserved memory region when loading",
            "\t * crash kernels we need a serialization here to prevent multiple crash",
            "\t * kernels from attempting to load simultaneously.",
            "\t */",
            "\tif (!kexec_trylock())",
            "\t\treturn -EBUSY;",
            "",
            "#ifdef CONFIG_CRASH_DUMP",
            "\tif (flags & KEXEC_ON_CRASH) {",
            "\t\tdest_image = &kexec_crash_image;",
            "\t\tif (kexec_crash_image)",
            "\t\t\tarch_kexec_unprotect_crashkres();",
            "\t} else",
            "#endif",
            "\t\tdest_image = &kexec_image;",
            "",
            "\tif (nr_segments == 0) {",
            "\t\t/* Uninstall image */",
            "\t\tkimage_free(xchg(dest_image, NULL));",
            "\t\tret = 0;",
            "\t\tgoto out_unlock;",
            "\t}",
            "\tif (flags & KEXEC_ON_CRASH) {",
            "\t\t/*",
            "\t\t * Loading another kernel to switch to if this one",
            "\t\t * crashes.  Free any current crash dump kernel before",
            "\t\t * we corrupt it.",
            "\t\t */",
            "\t\tkimage_free(xchg(&kexec_crash_image, NULL));",
            "\t}",
            "",
            "\tret = kimage_alloc_init(&image, entry, nr_segments, segments, flags);",
            "\tif (ret)",
            "\t\tgoto out_unlock;",
            "",
            "\tif (flags & KEXEC_PRESERVE_CONTEXT)",
            "\t\timage->preserve_context = 1;",
            "",
            "#ifdef CONFIG_CRASH_HOTPLUG",
            "\tif (flags & KEXEC_UPDATE_ELFCOREHDR)",
            "\t\timage->update_elfcorehdr = 1;",
            "#endif",
            "",
            "\tret = machine_kexec_prepare(image);",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Some architecture(like S390) may touch the crash memory before",
            "\t * machine_kexec_prepare(), we must copy vmcoreinfo data after it.",
            "\t */",
            "\tret = kimage_crash_copy_vmcoreinfo(image);",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tfor (i = 0; i < nr_segments; i++) {",
            "\t\tret = kimage_load_segment(image, &image->segment[i]);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tkimage_terminate(image);",
            "",
            "\tret = machine_kexec_post_load(image);",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\t/* Install the new kernel and uninstall the old */",
            "\timage = xchg(dest_image, image);",
            "",
            "out:",
            "#ifdef CONFIG_CRASH_DUMP",
            "\tif ((flags & KEXEC_ON_CRASH) && kexec_crash_image)",
            "\t\tarch_kexec_protect_crashkres();",
            "#endif",
            "",
            "\tkimage_free(image);",
            "out_unlock:",
            "\tkexec_unlock();",
            "\treturn ret;",
            "}"
          ],
          "function_name": "kimage_alloc_init, do_kexec_load",
          "description": "实现kimage_alloc_init分配并初始化kimage结构体，do_kexec_load处理kexec_load系统调用核心逻辑，包括参数校验、内存分配、段加载及架构特定准备流程",
          "similarity": 0.5011583566665649
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/kexec.c",
          "start_line": 202,
          "end_line": 240,
          "content": [
            "static inline int kexec_load_check(unsigned long nr_segments,",
            "\t\t\t\t   unsigned long flags)",
            "{",
            "\tint image_type = (flags & KEXEC_ON_CRASH) ?",
            "\t\t\t KEXEC_TYPE_CRASH : KEXEC_TYPE_DEFAULT;",
            "\tint result;",
            "",
            "\t/* We only trust the superuser with rebooting the system. */",
            "\tif (!kexec_load_permitted(image_type))",
            "\t\treturn -EPERM;",
            "",
            "\t/* Permit LSMs and IMA to fail the kexec */",
            "\tresult = security_kernel_load_data(LOADING_KEXEC_IMAGE, false);",
            "\tif (result < 0)",
            "\t\treturn result;",
            "",
            "\t/*",
            "\t * kexec can be used to circumvent module loading restrictions, so",
            "\t * prevent loading in that case",
            "\t */",
            "\tresult = security_locked_down(LOCKDOWN_KEXEC);",
            "\tif (result)",
            "\t\treturn result;",
            "",
            "\t/*",
            "\t * Verify we have a legal set of flags",
            "\t * This leaves us room for future extensions.",
            "\t */",
            "\tif ((flags & KEXEC_FLAGS) != (flags & ~KEXEC_ARCH_MASK))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Put an artificial cap on the number",
            "\t * of segments passed to kexec_load.",
            "\t */",
            "\tif (nr_segments > KEXEC_SEGMENT_MAX)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "kexec_load_check",
          "description": "实现kexec_load_check进行安全性和参数合法性检查，验证调用者权限、标志位有效性及段数量限制，确保kexec操作符合安全策略",
          "similarity": 0.4835045039653778
        }
      ]
    },
    {
      "source_file": "mm/hwpoison-inject.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:08:30\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `hwpoison-inject.c`\n\n---\n\n# hwpoison-inject.c 技术文档\n\n## 1. 文件概述\n\n`hwpoison-inject.c` 是 Linux 内核中用于**软件模拟硬件内存故障（Hardware Poison）注入与清除**的调试模块。该模块通过 debugfs 接口，允许具有 `CAP_SYS_ADMIN` 权限的用户空间程序向指定物理页帧号（PFN）注入或清除“坏页”标记（`PG_hwpoison`），主要用于测试内核内存错误处理机制（如 `memory_failure()` 路径）在无真实硬件故障情况下的行为。\n\n## 2. 核心功能\n\n### 主要函数\n- **`hwpoison_inject(void *data, u64 val)`**  \n  向指定 PFN 注入硬件内存故障。执行权限检查、页有效性验证、过滤器判断后调用 `memory_failure()`。\n  \n- **`hwpoison_unpoison(void *data, u64 val)`**  \n  清除指定 PFN 的硬件内存故障标记，调用 `unpoison_memory()`。\n\n- **`pfn_inject_init(void)`**  \n  模块初始化函数，创建 debugfs 目录及控制文件。\n\n- **`pfn_inject_exit(void)`**  \n  模块退出函数，清理 debugfs 条目并禁用过滤器。\n\n### 主要数据结构/全局变量\n- **`hwpoison_dir`**：debugfs 目录入口（`/sys/kernel/debug/hwpoison/`）。\n- **`hwpoison_fops` / `unpoison_fops`**：debugfs 文件操作接口，分别用于写入 corrupt/unpoison 请求。\n- **`hwpoison_filter_enable` 等全局变量**：控制 hwpoison 过滤器的行为参数（通过 debugfs 可配置）。\n\n## 3. 关键实现\n\n### 故障注入流程 (`hwpoison_inject`)\n1. **权限与有效性校验**：仅允许 `CAP_SYS_ADMIN` 用户操作，并确保输入 PFN 有效（`pfn_valid()`）。\n2. **页类型过滤**：\n   - 若 `hwpoison_filter_enable=0`，跳过过滤直接注入。\n   - 否则，仅对 **LRU 页**、**HugeTLB 页** 或 **空闲 Buddy 页** 允许注入，其他非 LRU 页（如 slab、匿名映射未加入 LRU 的页）被忽略。\n3. **过滤器检查**：调用 `hwpoison_filter()` 执行基于设备号、页标志、memcg 等条件的精细过滤（racy check，最终由 `memory_failure()` 在持锁下确认）。\n4. **触发内存故障处理**：调用 `memory_failure(pfn, MF_SW_SIMULATED)`，其中 `MF_SW_SIMULATED` 表示软件模拟故障。\n\n### 故障清除流程 (`hwpoison_unpoison`)\n- 直接调用通用接口 `unpoison_memory()` 清除 `PG_hwpoison` 标记，适用于已标记为坏页的页面。\n\n### DebugFS 接口设计\n- **`corrupt-pfn`**：写入 PFN 触发注入（权限 `0200`，仅写）。\n- **`unpoison-pfn`**：写入 PFN 触发清除（权限 `0200`，仅写）。\n- **过滤器控制参数**：提供 `corrupt-filter-*` 系列文件动态配置过滤条件（如设备号、页标志掩码、memcg ID）。\n\n## 4. 依赖关系\n\n- **核心内存管理子系统**：\n  - `<linux/mm.h>`、`<linux/pagemap.h>`：页结构、PFN 转换、LRU 状态检查。\n  - `<linux/hugetlb.h>`：HugeTLB 页支持。\n  - `\"internal.h\"`：内核 MM 内部接口（如 `shake_folio()`、`hwpoison_filter()`）。\n- **内存故障处理框架**：\n  - `memory_failure()` 和 `unpoison_memory()`：定义于 `mm/memory-failure.c`，负责实际坏页处理逻辑。\n- **DebugFS 基础设施**：依赖 `<linux/debugfs.h>` 提供用户态交互接口。\n- **可选依赖**：\n  - `CONFIG_MEMCG`：若启用内存控制组，则支持基于 memcg 的过滤。\n\n## 5. 使用场景\n\n- **内核开发与测试**：\n  - 验证 `memory_failure()` 路径对不同类型页面（匿名页、文件页、HugeTLB 页等）的处理正确性。\n  - 测试 hwpoison 过滤器逻辑（如基于设备、memcg 的隔离策略）。\n- **系统可靠性验证**：\n  - 模拟硬件内存故障，评估应用程序和内核在坏页注入下的恢复能力（如进程终止、页面迁移）。\n- **故障注入工具集成**：\n  - 作为底层接口被用户态工具（如 `mce-inject` 或自定义脚本）调用，实现可控的内存错误注入实验。",
      "similarity": 0.6111828684806824,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/hwpoison-inject.c",
          "start_line": 1,
          "end_line": 13,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Inject a hwpoison memory failure on a arbitrary pfn */",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include \"internal.h\"",
            "",
            "static struct dentry *hwpoison_dir;",
            ""
          ],
          "function_name": null,
          "description": "定义并初始化用于硬件中毒注入的调试文件系统目录结构",
          "similarity": 0.5892053842544556
        },
        {
          "chunk_id": 1,
          "file_path": "mm/hwpoison-inject.c",
          "start_line": 14,
          "end_line": 103,
          "content": [
            "static int hwpoison_inject(void *data, u64 val)",
            "{",
            "\tunsigned long pfn = val;",
            "\tstruct page *p;",
            "\tstruct folio *folio;",
            "\tint err;",
            "",
            "\tif (!capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tif (!pfn_valid(pfn))",
            "\t\treturn -ENXIO;",
            "",
            "\tp = pfn_to_page(pfn);",
            "\tfolio = page_folio(p);",
            "",
            "\tif (!hwpoison_filter_enable)",
            "\t\tgoto inject;",
            "",
            "\tshake_folio(folio);",
            "\t/*",
            "\t * This implies unable to support non-LRU pages except free page.",
            "\t */",
            "\tif (!folio_test_lru(folio) && !folio_test_hugetlb(folio) &&",
            "\t    !is_free_buddy_page(p))",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * do a racy check to make sure PG_hwpoison will only be set for",
            "\t * the targeted owner (or on a free page).",
            "\t * memory_failure() will redo the check reliably inside page lock.",
            "\t */",
            "\terr = hwpoison_filter(&folio->page);",
            "\tif (err)",
            "\t\treturn 0;",
            "",
            "inject:",
            "\tpr_info(\"Injecting memory failure at pfn %#lx\\n\", pfn);",
            "\terr = memory_failure(pfn, MF_SW_SIMULATED);",
            "\treturn (err == -EOPNOTSUPP) ? 0 : err;",
            "}",
            "static int hwpoison_unpoison(void *data, u64 val)",
            "{",
            "\tif (!capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\treturn unpoison_memory(val);",
            "}",
            "static void __exit pfn_inject_exit(void)",
            "{",
            "\thwpoison_filter_enable = 0;",
            "\tdebugfs_remove_recursive(hwpoison_dir);",
            "}",
            "static int __init pfn_inject_init(void)",
            "{",
            "\thwpoison_dir = debugfs_create_dir(\"hwpoison\", NULL);",
            "",
            "\t/*",
            "\t * Note that the below poison/unpoison interfaces do not involve",
            "\t * hardware status change, hence do not require hardware support.",
            "\t * They are mainly for testing hwpoison in software level.",
            "\t */",
            "\tdebugfs_create_file(\"corrupt-pfn\", 0200, hwpoison_dir, NULL,",
            "\t\t\t    &hwpoison_fops);",
            "",
            "\tdebugfs_create_file(\"unpoison-pfn\", 0200, hwpoison_dir, NULL,",
            "\t\t\t    &unpoison_fops);",
            "",
            "\tdebugfs_create_u32(\"corrupt-filter-enable\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_enable);",
            "",
            "\tdebugfs_create_u32(\"corrupt-filter-dev-major\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_dev_major);",
            "",
            "\tdebugfs_create_u32(\"corrupt-filter-dev-minor\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_dev_minor);",
            "",
            "\tdebugfs_create_u64(\"corrupt-filter-flags-mask\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_flags_mask);",
            "",
            "\tdebugfs_create_u64(\"corrupt-filter-flags-value\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_flags_value);",
            "",
            "#ifdef CONFIG_MEMCG",
            "\tdebugfs_create_u64(\"corrupt-filter-memcg\", 0600, hwpoison_dir,",
            "\t\t\t   &hwpoison_filter_memcg);",
            "#endif",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "hwpoison_inject, hwpoison_unpoison, pfn_inject_exit, pfn_inject_init",
          "description": "提供硬件中毒注入与解除接口，包含权限校验、PFN有效性检查、页面状态修改及debugfs控制接口注册功能",
          "similarity": 0.5266431570053101
        }
      ]
    },
    {
      "source_file": "kernel/module/kmod.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:03:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\kmod.c`\n\n---\n\n# `module/kmod.c` 技术文档\n\n## 1. 文件概述\n\n`kmod.c` 是 Linux 内核中负责**内核模块自动加载机制**的核心实现文件。它提供了从内核空间调用用户态 `modprobe` 工具以动态加载缺失模块的能力。该机制允许内核在运行时按需加载驱动或功能模块（例如当设备被探测到但对应驱动未加载时），从而提升系统灵活性和资源利用率。\n\n该文件实现了 `__request_module()` 接口，作为内核其他子系统请求模块加载的统一入口，并通过 `call_usermodehelper` 机制安全地调用用户空间的 `/sbin/modprobe`（或由 `modprobe_path` 指定的路径）。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`__request_module(bool wait, const char *fmt, ...)`**  \n  内核模块加载的主入口函数。支持格式化模块名，可选择同步（`wait=true`）或异步（`wait=false`）执行。返回值为 0 表示成功启动加载过程，负值为错误码，正值为 `modprobe` 的退出码。\n\n- **`call_modprobe(char *orig_module_name, int wait)`**  \n  封装对用户态 `modprobe` 的调用。构造命令行参数（`modprobe -q -- <module_name>`）和环境变量，通过 `call_usermodehelper_setup()` 和 `call_usermodehelper_exec()` 执行。\n\n- **`free_modprobe_argv(struct subprocess_info *info)`**  \n  释放 `call_modprobe` 中分配的参数内存，作为 `call_usermodehelper_setup()` 的清理回调。\n\n### 关键数据结构与变量\n\n- **`modprobe_path[KMOD_PATH_LEN]`**  \n  全局可配置的 `modprobe` 可执行文件路径，默认为 `CONFIG_MODPROBE_PATH`（通常为 `\"/sbin/modprobe\"`），可通过 `/proc/sys/kernel/modprobe` 修改。\n\n- **`kmod_concurrent_max`**  \n  信号量，限制同时进行的模块加载请求数量，上限为 `MAX_KMOD_CONCURRENT`（50），防止资源耗尽或递归依赖导致的死锁。\n\n- **`MAX_KMOD_ALL_BUSY_TIMEOUT`**  \n  超时阈值（5 秒），当所有并发槽位被占用超过此时间，判定为可能的模块依赖循环，拒绝新请求。\n\n## 3. 关键实现\n\n### 并发控制与死锁预防\n\n- 使用 `down_timeout(&kmod_concurrent_max, ...)` 限制并发加载线程数，避免系统资源（如内存、进程数）被大量 `modprobe` 进程耗尽。\n- 若所有 50 个并发槽位在 5 秒内未释放，内核判定为**模块依赖循环**（如 A 依赖 B，B 又依赖 A），主动拒绝请求并打印警告，防止无限递归。\n- 通过 `WARN_ON_ONCE(wait && current_is_async())` 禁止在异步上下文（如 workqueue、async 任务）中执行**同步**模块加载，避免与 `async_synchronize_full()` 产生死锁。\n\n### 安全与资源管理\n\n- 调用 `security_kernel_module_request()` 执行 LSM（Linux Security Module）安全检查，允许安全模块（如 SELinux、AppArmor）控制模块加载权限。\n- 使用 `UMH_KILLABLE` 标志使 `modprobe` 进程可被信号中断，提升系统响应性。\n- 通过 `kmod_dup_request_exists_wait()` 检测重复的模块加载请求，避免对同一模块发起多次 `modprobe` 调用，提升效率。\n\n### 用户态交互\n\n- 构造标准环境变量（`HOME=/`, `PATH=/sbin:/usr/sbin:/bin:/usr/bin`）确保 `modprobe` 在受限但可用的环境中执行。\n- 使用 `call_usermodehelper` 子系统创建内核线程执行用户态程序，该机制处理了凭证（cred）、文件描述符、挂载命名空间等上下文隔离。\n\n### 跟踪与调试\n\n- 集成 `trace_module_request` 跟踪点，可通过 ftrace 或 perf 监控模块加载请求。\n- 调用 `kmod_dup_request_announce()` 记录重复请求或失败事件，便于诊断。\n\n## 4. 依赖关系\n\n- **内核子系统依赖**：\n  - `call_usermodehelper`（`<linux/unistd.h>`, `<linux/binfmts.h>`）：用于执行用户态 helper 程序。\n  - LSM 框架（`<linux/security.h>`）：执行模块加载安全策略。\n  - 内存管理（`<linux/slab.h>`）：动态分配参数字符串。\n  - 同步原语（`<linux/semaphore.h>` via `DEFINE_SEMAPHORE`）：并发控制。\n  - 调试与跟踪（`<trace/events/module.h>`）：性能分析支持。\n- **配置依赖**：\n  - `CONFIG_MODULES`：模块支持必须启用。\n  - `CONFIG_MODPROBE_PATH`：定义默认 `modprobe` 路径。\n- **内部依赖**：\n  - `internal.h`：包含模块子系统内部声明（如 `kmod_dup_request_exists_wait`）。\n\n## 5. 使用场景\n\n- **设备驱动自动加载**：当内核探测到新硬件（如 USB 设备）但无对应驱动时，通过 `__request_module(\"usb:vXXXXpXXXX...\")` 触发驱动加载。\n- **文件系统按需挂载**：挂载未知文件系统类型时（如 `mount -t foo`），内核调用 `__request_module(\"fs-foo\")` 加载文件系统模块。\n- **网络协议模块加载**：使用未加载的网络协议（如 `AF_PHONET`）时自动加载对应模块。\n- **内核特性动态扩展**：如加密算法、压缩模块等在首次使用时按需加载。\n- **内核模块依赖解析**：当模块 A 依赖模块 B，而 B 未加载时，`insmod`/`modprobe` 内部会通过此机制加载 B。\n\n> **注意**：成功返回仅表示 `modprobe` 已启动，不保证模块最终加载成功。调用者必须验证所需功能是否可用。",
      "similarity": 0.603797435760498,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/kmod.c",
          "start_line": 66,
          "end_line": 161,
          "content": [
            "static void free_modprobe_argv(struct subprocess_info *info)",
            "{",
            "\tkfree(info->argv[3]); /* check call_modprobe() */",
            "\tkfree(info->argv);",
            "}",
            "static int call_modprobe(char *orig_module_name, int wait)",
            "{",
            "\tstruct subprocess_info *info;",
            "\tstatic char *envp[] = {",
            "\t\t\"HOME=/\",",
            "\t\t\"TERM=linux\",",
            "\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",",
            "\t\tNULL",
            "\t};",
            "\tchar *module_name;",
            "\tint ret;",
            "",
            "\tchar **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);",
            "\tif (!argv)",
            "\t\tgoto out;",
            "",
            "\tmodule_name = kstrdup(orig_module_name, GFP_KERNEL);",
            "\tif (!module_name)",
            "\t\tgoto free_argv;",
            "",
            "\targv[0] = modprobe_path;",
            "\targv[1] = \"-q\";",
            "\targv[2] = \"--\";",
            "\targv[3] = module_name;\t/* check free_modprobe_argv() */",
            "\targv[4] = NULL;",
            "",
            "\tinfo = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,",
            "\t\t\t\t\t NULL, free_modprobe_argv, NULL);",
            "\tif (!info)",
            "\t\tgoto free_module_name;",
            "",
            "\tret = call_usermodehelper_exec(info, wait | UMH_KILLABLE);",
            "\tkmod_dup_request_announce(orig_module_name, ret);",
            "\treturn ret;",
            "",
            "free_module_name:",
            "\tkfree(module_name);",
            "free_argv:",
            "\tkfree(argv);",
            "out:",
            "\tkmod_dup_request_announce(orig_module_name, -ENOMEM);",
            "\treturn -ENOMEM;",
            "}",
            "int __request_module(bool wait, const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "\tchar module_name[MODULE_NAME_LEN];",
            "\tint ret, dup_ret;",
            "",
            "\t/*",
            "\t * We don't allow synchronous module loading from async.  Module",
            "\t * init may invoke async_synchronize_full() which will end up",
            "\t * waiting for this task which already is waiting for the module",
            "\t * loading to complete, leading to a deadlock.",
            "\t */",
            "\tWARN_ON_ONCE(wait && current_is_async());",
            "",
            "\tif (!modprobe_path[0])",
            "\t\treturn -ENOENT;",
            "",
            "\tva_start(args, fmt);",
            "\tret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);",
            "\tva_end(args);",
            "\tif (ret >= MODULE_NAME_LEN)",
            "\t\treturn -ENAMETOOLONG;",
            "",
            "\tret = security_kernel_module_request(module_name);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = down_timeout(&kmod_concurrent_max, MAX_KMOD_ALL_BUSY_TIMEOUT * HZ);",
            "\tif (ret) {",
            "\t\tpr_warn_ratelimited(\"request_module: modprobe %s cannot be processed, kmod busy with %d threads for more than %d seconds now\",",
            "\t\t\t\t    module_name, MAX_KMOD_CONCURRENT, MAX_KMOD_ALL_BUSY_TIMEOUT);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ttrace_module_request(module_name, wait, _RET_IP_);",
            "",
            "\tif (kmod_dup_request_exists_wait(module_name, wait, &dup_ret)) {",
            "\t\tret = dup_ret;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);",
            "",
            "out:",
            "\tup(&kmod_concurrent_max);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "free_modprobe_argv, call_modprobe, __request_module",
          "description": "实现模块请求处理逻辑，通过调用modprobe执行模块加载，包含参数构造、子进程管理及并发控制机制",
          "similarity": 0.5432028770446777
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/kmod.c",
          "start_line": 1,
          "end_line": 65,
          "content": [
            "/*",
            " * kmod - the kernel module loader",
            " *",
            " * Copyright (C) 2023 Luis Chamberlain <mcgrof@kernel.org>",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/unistd.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/cred.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/resource.h>",
            "#include <linux/notifier.h>",
            "#include <linux/suspend.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/async.h>",
            "#include <linux/uaccess.h>",
            "",
            "#include <trace/events/module.h>",
            "#include \"internal.h\"",
            "",
            "/*",
            " * Assuming:",
            " *",
            " * threads = div64_u64((u64) totalram_pages * (u64) PAGE_SIZE,",
            " *\t\t       (u64) THREAD_SIZE * 8UL);",
            " *",
            " * If you need less than 50 threads would mean we're dealing with systems",
            " * smaller than 3200 pages. This assumes you are capable of having ~13M memory,",
            " * and this would only be an upper limit, after which the OOM killer would take",
            " * effect. Systems like these are very unlikely if modules are enabled.",
            " */",
            "#define MAX_KMOD_CONCURRENT 50",
            "static DEFINE_SEMAPHORE(kmod_concurrent_max, MAX_KMOD_CONCURRENT);",
            "",
            "/*",
            " * This is a restriction on having *all* MAX_KMOD_CONCURRENT threads",
            " * running at the same time without returning. When this happens we",
            " * believe you've somehow ended up with a recursive module dependency",
            " * creating a loop.",
            " *",
            " * We have no option but to fail.",
            " *",
            " * Userspace should proactively try to detect and prevent these.",
            " */",
            "#define MAX_KMOD_ALL_BUSY_TIMEOUT 5",
            "",
            "/*",
            "\tmodprobe_path is set via /proc/sys.",
            "*/",
            "char modprobe_path[KMOD_PATH_LEN] = CONFIG_MODPROBE_PATH;",
            ""
          ],
          "function_name": null,
          "description": "定义模块加载并发控制相关常量与全局变量，包含模块加载所需头文件并初始化modprobe路径",
          "similarity": 0.5347773432731628
        }
      ]
    }
  ]
}