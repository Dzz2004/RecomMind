{
  "query": "zombie process handling",
  "timestamp": "2025-12-26 00:40:52",
  "retrieved_files": [
    {
      "source_file": "kernel/power/process.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:23:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `power\\process.c`\n\n---\n\n# `power/process.c` 技术文档\n\n## 1. 文件概述\n\n`power/process.c` 是 Linux 内核电源管理子系统中的关键文件，负责在系统挂起（suspend）过程中冻结（freeze）和解冻（thaw）用户空间进程及可冻结的内核线程。该机制确保在系统进入低功耗状态前，所有可冻结任务已暂停执行，避免在挂起期间发生不一致状态或资源竞争；在恢复时再安全地唤醒这些任务。此功能最初源自 swsusp（Software Suspend）项目，现已成为通用冻结框架的一部分。\n\n## 2. 核心功能\n\n### 全局变量\n- `freeze_timeout_msecs`：冻结任务的超时时间（默认 20 秒），标记为 `__read_mostly` 以优化缓存。\n\n### 主要函数\n- `try_to_freeze_tasks(bool user_only)`：尝试冻结指定范围内的任务（仅用户进程或包括内核线程）。\n- `freeze_processes(void)`：冻结所有用户空间进程，并禁用用户模式辅助程序（usermodehelper）和 OOM killer。\n- `freeze_kernel_threads(void)`：冻结所有可冻结的内核线程（在用户进程已冻结后调用）。\n- `thaw_processes(void)`：解冻所有任务（包括用户进程和内核线程），并重新启用 OOM killer 和 usermodehelper。\n- `thaw_kernel_threads(void)`：仅解冻内核线程（用于错误恢复或分阶段解冻）。\n\n### 辅助机制\n- 使用 `PF_SUSPEND_TASK` 标志标记当前执行冻结操作的进程，防止其自身被冻结。\n- 通过 `freezer_active` 静态分支优化冻结状态的判断性能。\n- 集成 tracepoint（`trace_suspend_resume`）用于跟踪冻结/解冻事件。\n\n## 3. 关键实现\n\n### 冻结流程 (`try_to_freeze_tasks`)\n1. **初始化**：记录开始时间，设置超时阈值（基于 `freeze_timeout_msecs`）。\n2. **工作队列冻结**：若 `user_only=false`，调用 `freeze_workqueues_begin()` 开始冻结工作队列。\n3. **遍历任务**：通过 `for_each_process_thread` 遍历所有进程和线程，对每个非当前任务调用 `freeze_task()` 发送冻结信号。\n4. **重试与退避**：若仍有任务未冻结且未超时，使用指数退避策略（1ms → 2ms → 4ms → 8ms）进行短暂休眠后重试。\n5. **中断处理**：若在冻结过程中检测到唤醒事件（`pm_wakeup_pending()`），立即中止冻结。\n6. **错误诊断**：冻结失败时，打印未冻结任务列表（通过 `sched_show_task`）和繁忙的工作队列信息（`show_freezable_workqueues`）。\n\n### 用户进程冻结 (`freeze_processes`)\n- 禁用 `usermodehelper`（防止挂起期间加载内核模块）。\n- 设置当前任务 `PF_SUSPEND_TASK` 标志以豁免自身。\n- 激活全局冻结状态（`pm_freezing = true`）。\n- 冻结用户进程后，禁用 OOM killer（防止其在冻结期间杀死任务导致状态不一致）。\n- 若冻结失败，自动调用 `thaw_processes` 回滚状态。\n\n### 内核线程冻结 (`freeze_kernel_threads`)\n- 设置 `pm_nosig_freezing = true` 表示进入无信号冻结阶段（仅影响内核线程）。\n- 调用 `try_to_freeze_tasks(false)` 冻结剩余可冻结任务（包括内核线程和工作队列）。\n- 失败时仅解冻内核线程（`thaw_kernel_threads`），由调用者负责后续用户进程解冻。\n\n### 解冻流程 (`thaw_processes`)\n- 清除全局冻结标志，重新启用 OOM killer 和 usermodehelper。\n- 遍历所有任务，调用 `__thaw_task` 清除冻结状态。\n- 显式调用 `schedule()` 触发调度，确保解冻任务能及时运行。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/freezer.h>`：提供 `freeze_task`、`__thaw_task` 等冻结核心接口。\n  - `<linux/suspend.h>`：定义 `pm_freezing`、`pm_wakeup_pending` 等电源管理状态变量。\n  - `<linux/oom.h>`：提供 OOM killer 启用/禁用接口。\n  - `<linux/workqueue.h>`：提供工作队列冻结/解冻支持。\n  - `<trace/events/power.h>`：提供 suspend/resume 跟踪点。\n- **模块交互**：\n  - 与 **OOM killer** 协同：冻结期间禁用 OOM，防止干扰冻结任务。\n  - 与 **usermodehelper** 协同：冻结期间禁用用户模式辅助程序，避免挂起时执行外部命令。\n  - 与 **工作队列子系统** 协同：通过 `freeze_workqueues_begin`/`thaw_workqueues` 管理工作项执行。\n  - 与 **调度器** 协同：通过 `sched_show_task` 诊断冻结失败任务。\n\n## 5. 使用场景\n\n- **系统挂起（Suspend-to-RAM/Disk）**：\n  1. `freeze_processes()` 冻结用户空间进程。\n  2. `freeze_kernel_threads()` 冻结内核线程。\n  3. 系统进入低功耗状态。\n  4. 唤醒后，`thaw_processes()` 解冻所有任务。\n- **休眠（Hibernation）**：在保存内存镜像前冻结所有任务，确保系统状态一致性。\n- **错误恢复**：若冻结过程因超时或唤醒事件失败，自动回滚解冻状态，保证系统可用性。\n- **调试支持**：通过 `pm_debug_messages_on` 控制冻结失败时的详细任务信息输出，辅助诊断冻结问题。",
      "similarity": 0.5329701900482178,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/power/process.c",
          "start_line": 28,
          "end_line": 147,
          "content": [
            "static int try_to_freeze_tasks(bool user_only)",
            "{",
            "\tconst char *what = user_only ? \"user space processes\" :",
            "\t\t\t\t\t\"remaining freezable tasks\";",
            "\tstruct task_struct *g, *p;",
            "\tunsigned long end_time;",
            "\tunsigned int todo;",
            "\tbool wq_busy = false;",
            "\tktime_t start, end, elapsed;",
            "\tunsigned int elapsed_msecs;",
            "\tbool wakeup = false;",
            "\tint sleep_usecs = USEC_PER_MSEC;",
            "",
            "\tpr_info(\"Freezing %s\\n\", what);",
            "",
            "\tstart = ktime_get_boottime();",
            "",
            "\tend_time = jiffies + msecs_to_jiffies(freeze_timeout_msecs);",
            "",
            "\tif (!user_only)",
            "\t\tfreeze_workqueues_begin();",
            "",
            "\twhile (true) {",
            "\t\ttodo = 0;",
            "\t\tread_lock(&tasklist_lock);",
            "\t\tfor_each_process_thread(g, p) {",
            "\t\t\tif (p == current || !freeze_task(p))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\ttodo++;",
            "\t\t}",
            "\t\tread_unlock(&tasklist_lock);",
            "",
            "\t\tif (!user_only) {",
            "\t\t\twq_busy = freeze_workqueues_busy();",
            "\t\t\ttodo += wq_busy;",
            "\t\t}",
            "",
            "\t\tif (!todo || time_after(jiffies, end_time))",
            "\t\t\tbreak;",
            "",
            "\t\tif (pm_wakeup_pending()) {",
            "\t\t\twakeup = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * We need to retry, but first give the freezing tasks some",
            "\t\t * time to enter the refrigerator.  Start with an initial",
            "\t\t * 1 ms sleep followed by exponential backoff until 8 ms.",
            "\t\t */",
            "\t\tusleep_range(sleep_usecs / 2, sleep_usecs);",
            "\t\tif (sleep_usecs < 8 * USEC_PER_MSEC)",
            "\t\t\tsleep_usecs *= 2;",
            "\t}",
            "",
            "\tend = ktime_get_boottime();",
            "\telapsed = ktime_sub(end, start);",
            "\telapsed_msecs = ktime_to_ms(elapsed);",
            "",
            "\tif (todo) {",
            "\t\tpr_err(\"Freezing %s %s after %d.%03d seconds \"",
            "\t\t       \"(%d tasks refusing to freeze, wq_busy=%d):\\n\", what,",
            "\t\t       wakeup ? \"aborted\" : \"failed\",",
            "\t\t       elapsed_msecs / 1000, elapsed_msecs % 1000,",
            "\t\t       todo - wq_busy, wq_busy);",
            "",
            "\t\tif (wq_busy)",
            "\t\t\tshow_freezable_workqueues();",
            "",
            "\t\tif (!wakeup || pm_debug_messages_on) {",
            "\t\t\tread_lock(&tasklist_lock);",
            "\t\t\tfor_each_process_thread(g, p) {",
            "\t\t\t\tif (p != current && freezing(p) && !frozen(p))",
            "\t\t\t\t\tsched_show_task(p);",
            "\t\t\t}",
            "\t\t\tread_unlock(&tasklist_lock);",
            "\t\t}",
            "\t} else {",
            "\t\tpr_info(\"Freezing %s completed (elapsed %d.%03d seconds)\\n\",",
            "\t\t\twhat, elapsed_msecs / 1000, elapsed_msecs % 1000);",
            "\t}",
            "",
            "\treturn todo ? -EBUSY : 0;",
            "}",
            "int freeze_processes(void)",
            "{",
            "\tint error;",
            "",
            "\terror = __usermodehelper_disable(UMH_FREEZING);",
            "\tif (error)",
            "\t\treturn error;",
            "",
            "\t/* Make sure this task doesn't get frozen */",
            "\tcurrent->flags |= PF_SUSPEND_TASK;",
            "",
            "\tif (!pm_freezing)",
            "\t\tstatic_branch_inc(&freezer_active);",
            "",
            "\tpm_wakeup_clear(0);",
            "\tpm_freezing = true;",
            "\terror = try_to_freeze_tasks(true);",
            "\tif (!error)",
            "\t\t__usermodehelper_set_disable_depth(UMH_DISABLED);",
            "",
            "\tBUG_ON(in_atomic());",
            "",
            "\t/*",
            "\t * Now that the whole userspace is frozen we need to disable",
            "\t * the OOM killer to disallow any further interference with",
            "\t * killable tasks. There is no guarantee oom victims will",
            "\t * ever reach a point they go away we have to wait with a timeout.",
            "\t */",
            "\tif (!error && !oom_killer_disable(msecs_to_jiffies(freeze_timeout_msecs)))",
            "\t\terror = -EBUSY;",
            "",
            "\tif (error)",
            "\t\tthaw_processes();",
            "\treturn error;",
            "}"
          ],
          "function_name": "try_to_freeze_tasks, freeze_processes",
          "description": "try_to_freeze_tasks尝试冻结所有可冻结任务，通过遍历进程列表并处理工作队列实现；freeze_processes执行完整进程冻结流程，包括禁用用户模式辅助、标记冻结状态及处理OOM防护",
          "similarity": 0.5280646085739136
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/power/process.c",
          "start_line": 165,
          "end_line": 231,
          "content": [
            "int freeze_kernel_threads(void)",
            "{",
            "\tint error;",
            "",
            "\tpm_nosig_freezing = true;",
            "\terror = try_to_freeze_tasks(false);",
            "",
            "\tBUG_ON(in_atomic());",
            "",
            "\tif (error)",
            "\t\tthaw_kernel_threads();",
            "\treturn error;",
            "}",
            "void thaw_processes(void)",
            "{",
            "\tstruct task_struct *g, *p;",
            "\tstruct task_struct *curr = current;",
            "",
            "\ttrace_suspend_resume(TPS(\"thaw_processes\"), 0, true);",
            "\tif (pm_freezing)",
            "\t\tstatic_branch_dec(&freezer_active);",
            "\tpm_freezing = false;",
            "\tpm_nosig_freezing = false;",
            "",
            "\toom_killer_enable();",
            "",
            "\tpr_info(\"Restarting tasks: Starting\\n\");",
            "",
            "\t__usermodehelper_set_disable_depth(UMH_FREEZING);",
            "\tthaw_workqueues();",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, p) {",
            "\t\t/* No other threads should have PF_SUSPEND_TASK set */",
            "\t\tWARN_ON((p != curr) && (p->flags & PF_SUSPEND_TASK));",
            "\t\t__thaw_task(p);",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tWARN_ON(!(curr->flags & PF_SUSPEND_TASK));",
            "\tcurr->flags &= ~PF_SUSPEND_TASK;",
            "",
            "\tusermodehelper_enable();",
            "",
            "\tschedule();",
            "\tpr_info(\"Restarting tasks: Done\\n\");",
            "\ttrace_suspend_resume(TPS(\"thaw_processes\"), 0, false);",
            "}",
            "void thaw_kernel_threads(void)",
            "{",
            "\tstruct task_struct *g, *p;",
            "",
            "\tpm_nosig_freezing = false;",
            "\tpr_info(\"Restarting kernel threads ... \");",
            "",
            "\tthaw_workqueues();",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, p) {",
            "\t\tif (p->flags & PF_KTHREAD)",
            "\t\t\t__thaw_task(p);",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tschedule();",
            "\tpr_cont(\"done.\\n\");",
            "}"
          ],
          "function_name": "freeze_kernel_threads, thaw_processes, thaw_kernel_threads",
          "description": "freeze_kernel_threads冻结内核线程；thaw_processes解冻所有进程并恢复系统状态；thaw_kernel_threads专门解冻内核线程，三者协同完成睡眠状态转换期间的任务冻结与恢复操作",
          "similarity": 0.5265297293663025
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/power/process.c",
          "start_line": 1,
          "end_line": 27,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * drivers/power/process.c - Functions for starting/stopping processes on",
            " *                           suspend transitions.",
            " *",
            " * Originally from swsusp.",
            " */",
            "",
            "#include <linux/interrupt.h>",
            "#include <linux/oom.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kmod.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "",
            "/*",
            " * Timeout for stopping processes",
            " */",
            "unsigned int __read_mostly freeze_timeout_msecs = 20 * MSEC_PER_SEC;",
            ""
          ],
          "function_name": null,
          "description": "定义进程冻结操作的超时时间常量freeze_timeout_msecs，用于控制冻结进程的最大等待时间",
          "similarity": 0.48145970702171326
        }
      ]
    },
    {
      "source_file": "mm/oom_kill.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:58:11\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `oom_kill.c`\n\n---\n\n# oom_kill.c 技术文档\n\n## 1. 文件概述\n\n`oom_kill.c` 是 Linux 内核内存管理子系统中的关键组件，负责在系统严重内存不足（Out-Of-Memory, OOM）时选择并终止一个或多个进程，以释放内存资源、防止系统崩溃。该文件实现了 OOM Killer 的核心逻辑，包括候选进程的选择策略、内存压力评估、以及与内存控制组（memcg）、NUMA 策略、cpuset 等子系统的集成。OOM Killer 通常由 `__alloc_pages()` 在无法满足内存分配请求时触发。\n\n## 2. 核心功能\n\n### 主要函数\n- **`out_of_memory()`**：OOM Killer 的主入口函数（虽未在片段中完整显示，但为本文件核心）\n- **`oom_badness()`**：计算进程“坏度”（badness）分数的核心启发式函数，用于决定哪个进程最应被杀死\n- **`find_lock_task_mm()`**：在进程及其线程组中查找具有有效内存描述符（`mm_struct`）的可杀任务，并加锁\n- **`oom_unkillable_task()`**：判断某任务是否不可被 OOM Killer 杀死（如 init 进程、内核线程）\n- **`constrained_alloc()`**：确定当前内存分配所受的约束类型（如 memcg、cpuset、mempolicy）\n- **`oom_cpuset_eligible()`**（仅 CONFIG_NUMA）：在 NUMA 系统中检查任务是否符合 cpuset 或 mempolicy 的 OOM 杀死条件\n- **`should_dump_unreclaim_slab()`**：判断是否因不可回收 slab 内存过多而触发 OOM，用于辅助诊断\n\n### 关键数据结构\n- **`struct oom_control`**：封装 OOM 事件上下文，包括分配标志（`gfp_mask`）、节点掩码（`nodemask`）、内存控制组（`memcg`）、分配阶数（`order`）等\n- **`enum oom_constraint`**：表示内存分配受限的类型（`CONSTRAINT_NONE`、`CONSTRAINT_CPUSET`、`CONSTRAINT_MEMORY_POLICY`、`CONSTRAINT_MEMCG`）\n\n### 全局变量\n- **`sysctl_panic_on_oom`**：控制 OOM 时是否直接 panic\n- **`sysctl_oom_kill_allocating_task`**：若置位，则优先杀死触发 OOM 的进程\n- **`sysctl_oom_dump_tasks`**：控制 OOM 时是否打印所有任务的内存使用信息\n- **`oom_lock`**：互斥锁，序列化 OOM Killer 调用，防止并发过度杀进程\n- **`oom_adj_mutex`**：互斥锁，保护 `oom_score_adj` 和 `oom_score_adj_min` 的更新\n\n## 3. 关键实现\n\n### OOM 坏度评分算法 (`oom_badness`)\n- **基础分值**：基于进程的 RSS（Resident Set Size）、交换页数量（`MM_SWAPENTS`）和页表占用内存（`mm_pgtables_bytes`），单位为页数。\n- **调整因子**：通过 `oom_score_adj`（范围 [-1000, 1000]）进行线性调整。调整量 = `oom_score_adj * totalpages / 1000`，其中 `totalpages` 为当前 OOM 上下文允许的最大内存页数（全局或 memcg 限制）。\n- **排除规则**：\n  - 全局 init 进程（PID 1）和内核线程（`PF_KTHREAD`）不可杀。\n  - 显式设置 `oom_score_adj = OOM_SCORE_ADJ_MIN (-1000)` 的进程不可杀。\n  - 已被标记跳过（`MMF_OOM_SKIP`）或处于 `vfork` 中间状态的进程不可杀。\n- **返回值**：`LONG_MIN` 表示不可杀；否则返回综合评分，值越大越优先被杀。\n\n### 内存分配约束识别 (`constrained_alloc`)\n- **Memcg OOM**：若 `oc->memcg` 非空，则 `totalpages` 设为 memcg 的内存上限，约束类型为 `CONSTRAINT_MEMCG`。\n- **全局 OOM**：默认 `totalpages = totalram_pages + total_swap_pages`。\n- **NUMA 约束**：\n  - 若分配请求指定 `__GFP_THISNODE`，视为无特殊约束（避免杀死当前进程）。\n  - 若存在非全集的 `nodemask`（来自 mempolicy），则 `totalpages` 仅统计该 nodemask 覆盖节点的内存，约束类型为 `CONSTRAINT_MEMORY_POLICY`。\n  - Cpuset 约束由页面分配器处理，此处不直接计算。\n\n### 多线程与内存描述符处理 (`find_lock_task_mm`)\n- 遍历目标进程的整个线程组（`for_each_thread`），寻找任一仍持有有效 `mm_struct` 的线程。\n- 对找到的线程加 `task_lock` 并返回，确保在检查其内存状态时不会被释放。\n- 适用于主线程已退出但子线程仍在运行的场景。\n\n### NUMA 可杀性检查 (`oom_cpuset_eligible`)\n- 在 NUMA 系统中，仅当候选任务与触发 OOM 的当前任务在内存策略（mempolicy）或 cpuset 允许的节点集上有交集时，才视为可杀。\n- 若 OOM 由 mempolicy 触发（`oc->nodemask` 非空），则仅检查 mempolicy 交集。\n- 否则，检查 cpuset 的 `mems_allowed` 交集。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/gfp.h>`、`<linux/swap.h>` 获取内存状态、分配标志和交换信息。\n- **进程调度与管理**：依赖 `<linux/sched.h>` 及相关头文件访问任务结构、线程组、cpuset 和内存策略。\n- **内存控制组 (cgroup v2)**：通过 `<linux/memcontrol.h>` 集成 memcg，支持容器级 OOM。\n- **安全模块**：通过 `<linux/security.h>` 调用 LSM 钩子（如 `security_oom_kill()`）。\n- **调试与追踪**：使用 ftrace (`<linux/ftrace.h>`) 和自定义 tracepoint (`trace/events/oom.h`) 记录 OOM 事件。\n- **体系结构相关**：包含 `<asm/tlb.h>` 处理 TLB 刷新。\n- **内部 MM 实现**：包含 `\"internal.h\"` 和 `\"slab.h\"` 访问内核私有内存管理接口。\n\n## 5. 使用场景\n\n- **全局内存耗尽**：当系统整体可用内存（含 swap）低于临界阈值，且无法通过页面回收释放足够内存时，由页面分配器调用 `out_of_memory()`。\n- **Memcg 内存超限**：当某个 memory cgroup 的内存使用超过其配额时，触发该 cgroup 内的 OOM Killer。\n- **SysRq 触发**：通过 Magic SysRq 键（`Alt+SysRq+f`）手动触发 OOM Killer，此时 `oc->order = -1`。\n- **诊断辅助**：当不可回收 slab 内存（如内核对象缓存）异常增长导致 OOM 时，`should_dump_unreclaim_slab()` 可触发 slab 信息转储以辅助调试。\n- **策略约束下的 OOM**：在 NUMA 系统中，受 cpuset 或 mempolicy 限制的进程在局部节点内存耗尽时触发针对性 OOM。",
      "similarity": 0.5278459787368774,
      "chunks": [
        {
          "chunk_id": 7,
          "file_path": "mm/oom_kill.c",
          "start_line": 1011,
          "end_line": 1162,
          "content": [
            "static int oom_kill_memcg_member(struct task_struct *task, void *message)",
            "{",
            "\tif (task->signal->oom_score_adj != OOM_SCORE_ADJ_MIN &&",
            "\t    !is_global_init(task)) {",
            "\t\tget_task_struct(task);",
            "\t\t__oom_kill_process(task, message);",
            "\t}",
            "\treturn 0;",
            "}",
            "static void oom_kill_process(struct oom_control *oc, const char *message)",
            "{",
            "\tstruct task_struct *victim = oc->chosen;",
            "\tstruct mem_cgroup *oom_group;",
            "\tstatic DEFINE_RATELIMIT_STATE(oom_rs, DEFAULT_RATELIMIT_INTERVAL,",
            "\t\t\t\t\t      DEFAULT_RATELIMIT_BURST);",
            "",
            "\t/*",
            "\t * If the task is already exiting, don't alarm the sysadmin or kill",
            "\t * its children or threads, just give it access to memory reserves",
            "\t * so it can die quickly",
            "\t */",
            "\ttask_lock(victim);",
            "\tif (task_will_free_mem(victim)) {",
            "\t\tmark_oom_victim(victim);",
            "\t\tqueue_oom_reaper(victim);",
            "\t\ttask_unlock(victim);",
            "\t\tput_task_struct(victim);",
            "\t\treturn;",
            "\t}",
            "\ttask_unlock(victim);",
            "",
            "\tif (__ratelimit(&oom_rs))",
            "\t\tdump_header(oc, victim);",
            "",
            "\t/*",
            "\t * Do we need to kill the entire memory cgroup?",
            "\t * Or even one of the ancestor memory cgroups?",
            "\t * Check this out before killing the victim task.",
            "\t */",
            "\toom_group = mem_cgroup_get_oom_group(victim, oc->memcg);",
            "",
            "\t__oom_kill_process(victim, message);",
            "",
            "\t/*",
            "\t * If necessary, kill all tasks in the selected memory cgroup.",
            "\t */",
            "\tif (oom_group) {",
            "\t\tmemcg_memory_event(oom_group, MEMCG_OOM_GROUP_KILL);",
            "\t\tmem_cgroup_print_oom_group(oom_group);",
            "\t\tmem_cgroup_scan_tasks(oom_group, oom_kill_memcg_member,",
            "\t\t\t\t      (void *)message);",
            "\t\tmem_cgroup_put(oom_group);",
            "\t}",
            "}",
            "static void check_panic_on_oom(struct oom_control *oc)",
            "{",
            "\tif (likely(!sysctl_panic_on_oom))",
            "\t\treturn;",
            "\tif (sysctl_panic_on_oom != 2) {",
            "\t\t/*",
            "\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel",
            "\t\t * does not panic for cpuset, mempolicy, or memcg allocation",
            "\t\t * failures.",
            "\t\t */",
            "\t\tif (oc->constraint != CONSTRAINT_NONE)",
            "\t\t\treturn;",
            "\t}",
            "\t/* Do not panic for oom kills triggered by sysrq */",
            "\tif (is_sysrq_oom(oc))",
            "\t\treturn;",
            "\tdump_header(oc, NULL);",
            "\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",",
            "\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");",
            "}",
            "int register_oom_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&oom_notify_list, nb);",
            "}",
            "int unregister_oom_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&oom_notify_list, nb);",
            "}",
            "bool out_of_memory(struct oom_control *oc)",
            "{",
            "\tunsigned long freed = 0;",
            "",
            "\tif (oom_killer_disabled)",
            "\t\treturn false;",
            "",
            "\tif (!is_memcg_oom(oc)) {",
            "\t\tblocking_notifier_call_chain(&oom_notify_list, 0, &freed);",
            "\t\tif (freed > 0 && !is_sysrq_oom(oc))",
            "\t\t\t/* Got some memory back in the last second. */",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\t/*",
            "\t * If current has a pending SIGKILL or is exiting, then automatically",
            "\t * select it.  The goal is to allow it to allocate so that it may",
            "\t * quickly exit and free its memory.",
            "\t */",
            "\tif (task_will_free_mem(current)) {",
            "\t\tmark_oom_victim(current);",
            "\t\tqueue_oom_reaper(current);",
            "\t\treturn true;",
            "\t}",
            "",
            "\t/*",
            "\t * The OOM killer does not compensate for IO-less reclaim.",
            "\t * But mem_cgroup_oom() has to invoke the OOM killer even",
            "\t * if it is a GFP_NOFS allocation.",
            "\t */",
            "\tif (!(oc->gfp_mask & __GFP_FS) && !is_memcg_oom(oc))",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * Check if there were limitations on the allocation (only relevant for",
            "\t * NUMA and memcg) that may require different handling.",
            "\t */",
            "\toc->constraint = constrained_alloc(oc);",
            "\tif (oc->constraint != CONSTRAINT_MEMORY_POLICY)",
            "\t\toc->nodemask = NULL;",
            "\tcheck_panic_on_oom(oc);",
            "",
            "\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&",
            "\t    current->mm && !oom_unkillable_task(current) &&",
            "\t    oom_cpuset_eligible(current, oc) &&",
            "\t    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {",
            "\t\tget_task_struct(current);",
            "\t\toc->chosen = current;",
            "\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");",
            "\t\treturn true;",
            "\t}",
            "",
            "\tselect_bad_process(oc);",
            "\t/* Found nothing?!?! */",
            "\tif (!oc->chosen) {",
            "\t\tdump_header(oc, NULL);",
            "\t\tpr_warn(\"Out of memory and no killable processes...\\n\");",
            "\t\t/*",
            "\t\t * If we got here due to an actual allocation at the",
            "\t\t * system level, we cannot survive this and will enter",
            "\t\t * an endless loop in the allocator. Bail out now.",
            "\t\t */",
            "\t\tif (!is_sysrq_oom(oc) && !is_memcg_oom(oc))",
            "\t\t\tpanic(\"System is deadlocked on memory\\n\");",
            "\t}",
            "\tif (oc->chosen && oc->chosen != (void *)-1UL)",
            "\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :",
            "\t\t\t\t \"Memory cgroup out of memory\");",
            "\treturn !!oc->chosen;",
            "}"
          ],
          "function_name": "oom_kill_memcg_member, oom_kill_process, check_panic_on_oom, register_oom_notifier, unregister_oom_notifier, out_of_memory",
          "description": "实现基于内存控制组的OOM处理逻辑，集成OOM通知机制，包含OOM触发判定、进程选择算法、内存组遍历杀进程等功能，支持系统级OOM恐慌检测",
          "similarity": 0.5845988988876343
        },
        {
          "chunk_id": 8,
          "file_path": "mm/oom_kill.c",
          "start_line": 1191,
          "end_line": 1204,
          "content": [
            "void pagefault_out_of_memory(void)",
            "{",
            "\tstatic DEFINE_RATELIMIT_STATE(pfoom_rs, DEFAULT_RATELIMIT_INTERVAL,",
            "\t\t\t\t      DEFAULT_RATELIMIT_BURST);",
            "",
            "\tif (mem_cgroup_oom_synchronize(true))",
            "\t\treturn;",
            "",
            "\tif (fatal_signal_pending(current))",
            "\t\treturn;",
            "",
            "\tif (__ratelimit(&pfoom_rs))",
            "\t\tpr_warn(\"Huh VM_FAULT_OOM leaked out to the #PF handler. Retrying PF\\n\");",
            "}"
          ],
          "function_name": "pagefault_out_of_memory",
          "description": "处理页面故障引发的OOM场景，通过速率限制控制日志输出，同步内存控制组状态以防止无限循环分配，避免对已挂起的进程重复触发OOM处理",
          "similarity": 0.558570384979248
        },
        {
          "chunk_id": 6,
          "file_path": "mm/oom_kill.c",
          "start_line": 826,
          "end_line": 995,
          "content": [
            "bool oom_killer_disable(signed long timeout)",
            "{",
            "\tsigned long ret;",
            "",
            "\t/*",
            "\t * Make sure to not race with an ongoing OOM killer. Check that the",
            "\t * current is not killed (possibly due to sharing the victim's memory).",
            "\t */",
            "\tif (mutex_lock_killable(&oom_lock))",
            "\t\treturn false;",
            "\toom_killer_disabled = true;",
            "\tmutex_unlock(&oom_lock);",
            "",
            "\tret = wait_event_interruptible_timeout(oom_victims_wait,",
            "\t\t\t!atomic_read(&oom_victims), timeout);",
            "\tif (ret <= 0) {",
            "\t\toom_killer_enable();",
            "\t\treturn false;",
            "\t}",
            "\tpr_info(\"OOM killer disabled.\\n\");",
            "",
            "\treturn true;",
            "}",
            "static inline bool __task_will_free_mem(struct task_struct *task)",
            "{",
            "\tstruct signal_struct *sig = task->signal;",
            "",
            "\t/*",
            "\t * A coredumping process may sleep for an extended period in",
            "\t * coredump_task_exit(), so the oom killer cannot assume that",
            "\t * the process will promptly exit and release memory.",
            "\t */",
            "\tif (sig->core_state)",
            "\t\treturn false;",
            "",
            "\tif (sig->flags & SIGNAL_GROUP_EXIT)",
            "\t\treturn true;",
            "",
            "\tif (thread_group_empty(task) && (task->flags & PF_EXITING))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "static bool task_will_free_mem(struct task_struct *task)",
            "{",
            "\tstruct mm_struct *mm = task->mm;",
            "\tstruct task_struct *p;",
            "\tbool ret = true;",
            "",
            "\t/*",
            "\t * Skip tasks without mm because it might have passed its exit_mm and",
            "\t * exit_oom_victim. oom_reaper could have rescued that but do not rely",
            "\t * on that for now. We can consider find_lock_task_mm in future.",
            "\t */",
            "\tif (!mm)",
            "\t\treturn false;",
            "",
            "\tif (!__task_will_free_mem(task))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * This task has already been drained by the oom reaper so there are",
            "\t * only small chances it will free some more",
            "\t */",
            "\tif (test_bit(MMF_OOM_SKIP, &mm->flags))",
            "\t\treturn false;",
            "",
            "\tif (atomic_read(&mm->mm_users) <= 1)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * Make sure that all tasks which share the mm with the given tasks",
            "\t * are dying as well to make sure that a) nobody pins its mm and",
            "\t * b) the task is also reapable by the oom reaper.",
            "\t */",
            "\trcu_read_lock();",
            "\tfor_each_process(p) {",
            "\t\tif (!process_shares_mm(p, mm))",
            "\t\t\tcontinue;",
            "\t\tif (same_thread_group(task, p))",
            "\t\t\tcontinue;",
            "\t\tret = __task_will_free_mem(p);",
            "\t\tif (!ret)",
            "\t\t\tbreak;",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\treturn ret;",
            "}",
            "static void __oom_kill_process(struct task_struct *victim, const char *message)",
            "{",
            "\tstruct task_struct *p;",
            "\tstruct mm_struct *mm;",
            "\tbool can_oom_reap = true;",
            "",
            "\tp = find_lock_task_mm(victim);",
            "\tif (!p) {",
            "\t\tpr_info(\"%s: OOM victim %d (%s) is already exiting. Skip killing the task\\n\",",
            "\t\t\tmessage, task_pid_nr(victim), victim->comm);",
            "\t\tput_task_struct(victim);",
            "\t\treturn;",
            "\t} else if (victim != p) {",
            "\t\tget_task_struct(p);",
            "\t\tput_task_struct(victim);",
            "\t\tvictim = p;",
            "\t}",
            "",
            "\t/* Get a reference to safely compare mm after task_unlock(victim) */",
            "\tmm = victim->mm;",
            "\tmmgrab(mm);",
            "",
            "\t/* Raise event before sending signal: task reaper must see this */",
            "\tcount_vm_event(OOM_KILL);",
            "\tmemcg_memory_event_mm(mm, MEMCG_OOM_KILL);",
            "",
            "\t/*",
            "\t * We should send SIGKILL before granting access to memory reserves",
            "\t * in order to prevent the OOM victim from depleting the memory",
            "\t * reserves from the user space under its control.",
            "\t */",
            "\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, victim, PIDTYPE_TGID);",
            "\tmark_oom_victim(victim);",
            "\tpr_err(\"%s: Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB, UID:%u pgtables:%lukB oom_score_adj:%hd\\n\",",
            "\t\tmessage, task_pid_nr(victim), victim->comm, K(mm->total_vm),",
            "\t\tK(get_mm_counter(mm, MM_ANONPAGES)),",
            "\t\tK(get_mm_counter(mm, MM_FILEPAGES)),",
            "\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)),",
            "\t\tfrom_kuid(&init_user_ns, task_uid(victim)),",
            "\t\tmm_pgtables_bytes(mm) >> 10, victim->signal->oom_score_adj);",
            "\ttask_unlock(victim);",
            "",
            "\t/*",
            "\t * Kill all user processes sharing victim->mm in other thread groups, if",
            "\t * any.  They don't get access to memory reserves, though, to avoid",
            "\t * depletion of all memory.  This prevents mm->mmap_lock livelock when an",
            "\t * oom killed thread cannot exit because it requires the semaphore and",
            "\t * its contended by another thread trying to allocate memory itself.",
            "\t * That thread will now get access to memory reserves since it has a",
            "\t * pending fatal signal.",
            "\t */",
            "\trcu_read_lock();",
            "\tfor_each_process(p) {",
            "\t\tif (!process_shares_mm(p, mm))",
            "\t\t\tcontinue;",
            "\t\tif (same_thread_group(p, victim))",
            "\t\t\tcontinue;",
            "\t\tif (is_global_init(p)) {",
            "\t\t\tcan_oom_reap = false;",
            "\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);",
            "\t\t\tpr_info(\"oom killer %d (%s) has mm pinned by %d (%s)\\n\",",
            "\t\t\t\t\ttask_pid_nr(victim), victim->comm,",
            "\t\t\t\t\ttask_pid_nr(p), p->comm);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t/*",
            "\t\t * No kthread_use_mm() user needs to read from the userspace so",
            "\t\t * we are ok to reap it.",
            "\t\t */",
            "\t\tif (unlikely(p->flags & PF_KTHREAD))",
            "\t\t\tcontinue;",
            "\t\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_TGID);",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\tif (can_oom_reap)",
            "\t\tqueue_oom_reaper(victim);",
            "",
            "\tmmdrop(mm);",
            "\tput_task_struct(victim);",
            "}"
          ],
          "function_name": "oom_killer_disable, __task_will_free_mem, task_will_free_mem, __oom_kill_process",
          "description": "提供OOM杀手禁用逻辑及进程可回收性判断，实现OOM触发时的进程强制终止流程，包含共享MM处理、信号发送、内存统计等核心操作",
          "similarity": 0.5579148530960083
        },
        {
          "chunk_id": 1,
          "file_path": "mm/oom_kill.c",
          "start_line": 73,
          "end_line": 176,
          "content": [
            "static inline bool is_memcg_oom(struct oom_control *oc)",
            "{",
            "\treturn oc->memcg != NULL;",
            "}",
            "static bool oom_cpuset_eligible(struct task_struct *start,",
            "\t\t\t\tstruct oom_control *oc)",
            "{",
            "\tstruct task_struct *tsk;",
            "\tbool ret = false;",
            "\tconst nodemask_t *mask = oc->nodemask;",
            "",
            "\trcu_read_lock();",
            "\tfor_each_thread(start, tsk) {",
            "\t\tif (mask) {",
            "\t\t\t/*",
            "\t\t\t * If this is a mempolicy constrained oom, tsk's",
            "\t\t\t * cpuset is irrelevant.  Only return true if its",
            "\t\t\t * mempolicy intersects current, otherwise it may be",
            "\t\t\t * needlessly killed.",
            "\t\t\t */",
            "\t\t\tret = mempolicy_in_oom_domain(tsk, mask);",
            "\t\t} else {",
            "\t\t\t/*",
            "\t\t\t * This is not a mempolicy constrained oom, so only",
            "\t\t\t * check the mems of tsk's cpuset.",
            "\t\t\t */",
            "\t\t\tret = cpuset_mems_allowed_intersects(current, tsk);",
            "\t\t}",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\treturn ret;",
            "}",
            "static bool oom_cpuset_eligible(struct task_struct *tsk, struct oom_control *oc)",
            "{",
            "\treturn true;",
            "}",
            "static inline bool is_sysrq_oom(struct oom_control *oc)",
            "{",
            "\treturn oc->order == -1;",
            "}",
            "static bool oom_unkillable_task(struct task_struct *p)",
            "{",
            "\tif (is_global_init(p))",
            "\t\treturn true;",
            "\tif (p->flags & PF_KTHREAD)",
            "\t\treturn true;",
            "\treturn false;",
            "}",
            "static bool should_dump_unreclaim_slab(void)",
            "{",
            "\tunsigned long nr_lru;",
            "",
            "\tnr_lru = global_node_page_state(NR_ACTIVE_ANON) +",
            "\t\t global_node_page_state(NR_INACTIVE_ANON) +",
            "\t\t global_node_page_state(NR_ACTIVE_FILE) +",
            "\t\t global_node_page_state(NR_INACTIVE_FILE) +",
            "\t\t global_node_page_state(NR_ISOLATED_ANON) +",
            "\t\t global_node_page_state(NR_ISOLATED_FILE) +",
            "\t\t global_node_page_state(NR_UNEVICTABLE);",
            "",
            "\treturn (global_node_page_state_pages(NR_SLAB_UNRECLAIMABLE_B) > nr_lru);",
            "}",
            "long oom_badness(struct task_struct *p, unsigned long totalpages)",
            "{",
            "\tlong points;",
            "\tlong adj;",
            "",
            "\tif (oom_unkillable_task(p))",
            "\t\treturn LONG_MIN;",
            "",
            "\tp = find_lock_task_mm(p);",
            "\tif (!p)",
            "\t\treturn LONG_MIN;",
            "",
            "\t/*",
            "\t * Do not even consider tasks which are explicitly marked oom",
            "\t * unkillable or have been already oom reaped or the are in",
            "\t * the middle of vfork",
            "\t */",
            "\tadj = (long)p->signal->oom_score_adj;",
            "\tif (adj == OOM_SCORE_ADJ_MIN ||",
            "\t\t\ttest_bit(MMF_OOM_SKIP, &p->mm->flags) ||",
            "\t\t\tin_vfork(p)) {",
            "\t\ttask_unlock(p);",
            "\t\treturn LONG_MIN;",
            "\t}",
            "",
            "\t/*",
            "\t * The baseline for the badness score is the proportion of RAM that each",
            "\t * task's rss, pagetable and swap space use.",
            "\t */",
            "\tpoints = get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS) +",
            "\t\tmm_pgtables_bytes(p->mm) / PAGE_SIZE;",
            "\ttask_unlock(p);",
            "",
            "\t/* Normalize to oom_score_adj units */",
            "\tadj *= totalpages / 1000;",
            "\tpoints += adj;",
            "",
            "\treturn points;",
            "}"
          ],
          "function_name": "is_memcg_oom, oom_cpuset_eligible, oom_cpuset_eligible, is_sysrq_oom, oom_unkillable_task, should_dump_unreclaim_slab, oom_badness",
          "description": "实现OOM候选进程的过滤逻辑，判断进程是否满足内存组、CPU集、不可杀标记等条件，并计算进程的OOM不良程度评分。",
          "similarity": 0.5563104152679443
        },
        {
          "chunk_id": 4,
          "file_path": "mm/oom_kill.c",
          "start_line": 496,
          "end_line": 624,
          "content": [
            "bool process_shares_mm(struct task_struct *p, struct mm_struct *mm)",
            "{",
            "\tstruct task_struct *t;",
            "",
            "\tfor_each_thread(p, t) {",
            "\t\tstruct mm_struct *t_mm = READ_ONCE(t->mm);",
            "\t\tif (t_mm)",
            "\t\t\treturn t_mm == mm;",
            "\t}",
            "\treturn false;",
            "}",
            "static bool __oom_reap_task_mm(struct mm_struct *mm)",
            "{",
            "\tstruct vm_area_struct *vma;",
            "\tbool ret = true;",
            "\tVMA_ITERATOR(vmi, mm, 0);",
            "",
            "\t/*",
            "\t * Tell all users of get_user/copy_from_user etc... that the content",
            "\t * is no longer stable. No barriers really needed because unmapping",
            "\t * should imply barriers already and the reader would hit a page fault",
            "\t * if it stumbled over a reaped memory.",
            "\t */",
            "\tset_bit(MMF_UNSTABLE, &mm->flags);",
            "",
            "\tfor_each_vma(vmi, vma) {",
            "\t\tif (vma->vm_flags & (VM_HUGETLB|VM_PFNMAP))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Only anonymous pages have a good chance to be dropped",
            "\t\t * without additional steps which we cannot afford as we",
            "\t\t * are OOM already.",
            "\t\t *",
            "\t\t * We do not even care about fs backed pages because all",
            "\t\t * which are reclaimable have already been reclaimed and",
            "\t\t * we do not want to block exit_mmap by keeping mm ref",
            "\t\t * count elevated without a good reason.",
            "\t\t */",
            "\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {",
            "\t\t\tstruct mmu_notifier_range range;",
            "\t\t\tstruct mmu_gather tlb;",
            "",
            "\t\t\tmmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0,",
            "\t\t\t\t\t\tmm, vma->vm_start,",
            "\t\t\t\t\t\tvma->vm_end);",
            "\t\t\ttlb_gather_mmu(&tlb, mm);",
            "\t\t\tif (mmu_notifier_invalidate_range_start_nonblock(&range)) {",
            "\t\t\t\ttlb_finish_mmu(&tlb);",
            "\t\t\t\tret = false;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tunmap_page_range(&tlb, vma, range.start, range.end, NULL);",
            "\t\t\tmmu_notifier_invalidate_range_end(&range);",
            "\t\t\ttlb_finish_mmu(&tlb);",
            "\t\t}",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)",
            "{",
            "\tbool ret = true;",
            "",
            "\tif (!mmap_read_trylock(mm)) {",
            "\t\ttrace_skip_task_reaping(tsk->pid);",
            "\t\treturn false;",
            "\t}",
            "",
            "\t/*",
            "\t * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't",
            "\t * work on the mm anymore. The check for MMF_OOM_SKIP must run",
            "\t * under mmap_lock for reading because it serializes against the",
            "\t * mmap_write_lock();mmap_write_unlock() cycle in exit_mmap().",
            "\t */",
            "\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {",
            "\t\ttrace_skip_task_reaping(tsk->pid);",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\ttrace_start_task_reaping(tsk->pid);",
            "",
            "\t/* failed to reap part of the address space. Try again later */",
            "\tret = __oom_reap_task_mm(mm);",
            "\tif (!ret)",
            "\t\tgoto out_finish;",
            "",
            "\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",",
            "\t\t\ttask_pid_nr(tsk), tsk->comm,",
            "\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),",
            "\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),",
            "\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));",
            "out_finish:",
            "\ttrace_finish_task_reaping(tsk->pid);",
            "out_unlock:",
            "\tmmap_read_unlock(mm);",
            "",
            "\treturn ret;",
            "}",
            "static void oom_reap_task(struct task_struct *tsk)",
            "{",
            "\tint attempts = 0;",
            "\tstruct mm_struct *mm = tsk->signal->oom_mm;",
            "",
            "\t/* Retry the mmap_read_trylock(mm) a few times */",
            "\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !oom_reap_task_mm(tsk, mm))",
            "\t\tschedule_timeout_idle(HZ/10);",
            "",
            "\tif (attempts <= MAX_OOM_REAP_RETRIES ||",
            "\t    test_bit(MMF_OOM_SKIP, &mm->flags))",
            "\t\tgoto done;",
            "",
            "\tpr_info(\"oom_reaper: unable to reap pid:%d (%s)\\n\",",
            "\t\ttask_pid_nr(tsk), tsk->comm);",
            "\tsched_show_task(tsk);",
            "\tdebug_show_all_locks();",
            "",
            "done:",
            "\ttsk->oom_reaper_list = NULL;",
            "",
            "\t/*",
            "\t * Hide this mm from OOM killer because it has been either reaped or",
            "\t * somebody can't call mmap_write_unlock(mm).",
            "\t */",
            "\tset_bit(MMF_OOM_SKIP, &mm->flags);",
            "",
            "\t/* Drop a reference taken by queue_oom_reaper */",
            "\tput_task_struct(tsk);",
            "}"
          ],
          "function_name": "process_shares_mm, __oom_reap_task_mm, oom_reap_task_mm, oom_reap_task",
          "description": "通过强制解除地址空间映射、清除MMF_OOM_SKIP标志等方式尝试回收选定进程的内存资源，最终标记该进程为不可再次被OOM杀手处理。",
          "similarity": 0.5295904278755188
        }
      ]
    },
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.5085322856903076,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.4743133783340454
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.43838435411453247
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.3572165071964264
        }
      ]
    }
  ]
}