{
  "query": "swap缓存管理源码分析",
  "timestamp": "2025-12-26 00:21:27",
  "retrieved_files": [
    {
      "source_file": "kernel/power/swap.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:27:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `power\\swap.c`\n\n---\n\n# `power/swap.c` 技术文档\n\n## 1. 文件概述\n\n`power/swap.c` 是 Linux 内核电源管理子系统中负责**休眠（hibernation）功能**的核心文件之一，主要实现将系统内存镜像（suspend image）**写入交换分区（swap）** 以及从交换分区**恢复镜像**的功能。该文件通过管理交换空间的分配、镜像数据的读写、校验和跟踪机制，确保休眠/恢复过程的可靠性和完整性。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct swap_map_page`**  \n  用于记录写入交换分区的每个内存页对应的扇区位置，支持链式结构（通过 `next_swap` 字段链接多个 map 页）。\n\n- **`struct swap_map_handle`**  \n  管理交换映射的句柄，包含当前 map 页、map 链表、当前扇区、起始扇区、CRC32 校验值等信息。\n\n- **`struct swsusp_header`**  \n  休眠镜像头部结构，存储在交换分区固定位置（`swsusp_resume_block`），包含魔数（`HIBERNATE_SIG`）、镜像起始扇区、硬件签名、CRC32 校验等元数据。\n\n- **`struct swsusp_extent`**  \n  使用红黑树（`rb_root swsusp_extents`）跟踪已分配的交换页范围，用于错误恢复时释放已分配的交换空间。\n\n- **`struct hib_bio_batch`**  \n  用于批量提交 BIO 请求，支持异步 I/O 和错误处理，提升休眠/恢复性能。\n\n### 主要函数\n\n- **`alloc_swapdev_block(int swap)`**  \n  从指定交换设备分配一个交换页，并将其记录到 `swsusp_extents` 红黑树中。\n\n- **`free_all_swap_pages(int swap)`**  \n  释放所有在休眠过程中分配的交换页，并清空 `swsusp_extents` 树。\n\n- **`swsusp_swap_in_use(void)`**  \n  检查是否有交换页已被分配用于休眠。\n\n- **`hib_submit_io()` / `hib_end_io()` / `hib_wait_io()`**  \n  封装块设备 I/O 操作，支持同步/异步读写交换分区，处理缓存一致性（如 `flush_icache_range`）。\n\n- **`mark_swapfiles()`**  \n  在交换分区头部写入休眠标识（`HIBERNATE_SIG`）和镜像元数据，标记该交换分区包含有效休眠镜像。\n\n- **`low_free_pages()` / `reqd_free_pages()`**  \n  计算系统中可用的低内存页数量，确保休眠过程中保留足够内存用于 I/O 操作。\n\n## 3. 关键实现\n\n### 交换映射管理\n- 使用链式 `swap_map_page` 结构记录所有被写入交换分区的内存页位置。\n- 每个 `swap_map_page` 可存储 `MAP_PAGE_ENTRIES = (PAGE_SIZE / sizeof(sector_t) - 1)` 个扇区地址，最后一个字段用于指向下一个 map 页。\n- 映射信息本身也写入交换分区，形成自描述的镜像结构。\n\n### 交换页跟踪与错误恢复\n- 通过红黑树 `swsusp_extents` 动态记录所有已分配的交换页范围。\n- 支持相邻区间的自动合并，减少内存开销。\n- 若休眠失败，可通过 `free_all_swap_pages()` 安全释放所有已分配交换页。\n\n### I/O 优化与缓存一致性\n- 使用 `hib_bio_batch` 批量提交 BIO，结合 `blk_plug` 机制减少 I/O 中断。\n- 在读取镜像页后，若 `clean_pages_on_read` 为真，则调用 `flush_icache_range` 确保指令缓存一致性（对某些架构如 ARM/MIPS 必需）。\n- 支持 CRC32 校验（`swsusp_header->crc32`），用于验证镜像完整性。\n\n### 内存压力控制\n- `reqd_free_pages()` 保留至少一半的低内存页，防止在写入镜像时因内存不足导致系统崩溃。\n\n### 休眠标识与硬件签名\n- 交换分区头部原为 `SWAP-SPACE` 或 `SWAPSPACE2`，休眠时替换为 `S1SUSPEND`（`HIBERNATE_SIG`）。\n- 可选写入硬件签名（`swsusp_hardware_signature`），防止在不同硬件上错误恢复。\n\n## 4. 依赖关系\n\n- **块设备层**：依赖 `<linux/blkdev.h>`、`<linux/bio.h>` 进行底层 I/O 操作。\n- **内存管理**：依赖 `<linux/swap.h>`、`<linux/swapops.h>` 管理交换页分配与释放。\n- **电源管理核心**：包含 `\"power.h\"`，与 `swsusp.c`、`snapshot.c` 等协同工作。\n- **压缩支持**：包含 `<linux/lzo.h>`，为后续压缩镜像提供接口（尽管本文件未直接实现压缩）。\n- **校验与调试**：使用 `<linux/crc32.h>` 进行数据校验，`<linux/ktime.h>` 用于性能追踪。\n\n## 5. 使用场景\n\n- **系统休眠（Suspend-to-Disk / Hibernation）**：  \n  当用户执行 `echo disk > /sys/power/state` 时，内核调用此模块将内存镜像写入交换分区。\n\n- **系统恢复（Resume from Hibernation）**：  \n  启动时若检测到交换分区包含有效 `HIBERNATE_SIG`，内核使用此模块从交换分区读取镜像并恢复系统状态。\n\n- **交换分区管理**：  \n  在休眠过程中动态分配和跟踪交换页，确保不与常规 swap 使用冲突，并在失败时安全回滚。\n\n- **跨架构支持**：  \n  通过 `clean_pages_on_read` 机制适配需要指令缓存刷新的 CPU 架构，保证恢复后代码可正确执行。",
      "similarity": 0.6723924279212952,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/power/swap.c",
          "start_line": 885,
          "end_line": 992,
          "content": [
            "static int enough_swap(unsigned int nr_pages)",
            "{",
            "\tunsigned int free_swap = count_swap_pages(root_swap, 1);",
            "\tunsigned int required;",
            "",
            "\tpr_debug(\"Free swap pages: %u\\n\", free_swap);",
            "",
            "\trequired = PAGES_FOR_IO + nr_pages;",
            "\treturn free_swap > required;",
            "}",
            "int swsusp_write(unsigned int flags)",
            "{",
            "\tstruct swap_map_handle handle;",
            "\tstruct snapshot_handle snapshot;",
            "\tstruct swsusp_info *header;",
            "\tunsigned long pages;",
            "\tint error;",
            "",
            "\tpages = snapshot_get_image_size();",
            "\terror = get_swap_writer(&handle);",
            "\tif (error) {",
            "\t\tpr_err(\"Cannot get swap writer\\n\");",
            "\t\treturn error;",
            "\t}",
            "\tif (flags & SF_NOCOMPRESS_MODE) {",
            "\t\tif (!enough_swap(pages)) {",
            "\t\t\tpr_err(\"Not enough free swap\\n\");",
            "\t\t\terror = -ENOSPC;",
            "\t\t\tgoto out_finish;",
            "\t\t}",
            "\t}",
            "\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));",
            "\terror = snapshot_read_next(&snapshot);",
            "\tif (error < (int)PAGE_SIZE) {",
            "\t\tif (error >= 0)",
            "\t\t\terror = -EFAULT;",
            "",
            "\t\tgoto out_finish;",
            "\t}",
            "\theader = (struct swsusp_info *)data_of(snapshot);",
            "\terror = swap_write_page(&handle, header, NULL);",
            "\tif (!error) {",
            "\t\terror = (flags & SF_NOCOMPRESS_MODE) ?",
            "\t\t\tsave_image(&handle, &snapshot, pages - 1) :",
            "\t\t\tsave_image_lzo(&handle, &snapshot, pages - 1);",
            "\t}",
            "out_finish:",
            "\terror = swap_writer_finish(&handle, flags, error);",
            "\treturn error;",
            "}",
            "static void release_swap_reader(struct swap_map_handle *handle)",
            "{",
            "\tstruct swap_map_page_list *tmp;",
            "",
            "\twhile (handle->maps) {",
            "\t\tif (handle->maps->map)",
            "\t\t\tfree_page((unsigned long)handle->maps->map);",
            "\t\ttmp = handle->maps;",
            "\t\thandle->maps = handle->maps->next;",
            "\t\tkfree(tmp);",
            "\t}",
            "\thandle->cur = NULL;",
            "}",
            "static int get_swap_reader(struct swap_map_handle *handle,",
            "\t\tunsigned int *flags_p)",
            "{",
            "\tint error;",
            "\tstruct swap_map_page_list *tmp, *last;",
            "\tsector_t offset;",
            "",
            "\t*flags_p = swsusp_header->flags;",
            "",
            "\tif (!swsusp_header->image) /* how can this happen? */",
            "\t\treturn -EINVAL;",
            "",
            "\thandle->cur = NULL;",
            "\tlast = handle->maps = NULL;",
            "\toffset = swsusp_header->image;",
            "\twhile (offset) {",
            "\t\ttmp = kzalloc(sizeof(*handle->maps), GFP_KERNEL);",
            "\t\tif (!tmp) {",
            "\t\t\trelease_swap_reader(handle);",
            "\t\t\treturn -ENOMEM;",
            "\t\t}",
            "\t\tif (!handle->maps)",
            "\t\t\thandle->maps = tmp;",
            "\t\tif (last)",
            "\t\t\tlast->next = tmp;",
            "\t\tlast = tmp;",
            "",
            "\t\ttmp->map = (struct swap_map_page *)",
            "\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);",
            "\t\tif (!tmp->map) {",
            "\t\t\trelease_swap_reader(handle);",
            "\t\t\treturn -ENOMEM;",
            "\t\t}",
            "",
            "\t\terror = hib_submit_io(REQ_OP_READ, offset, tmp->map, NULL);",
            "\t\tif (error) {",
            "\t\t\trelease_swap_reader(handle);",
            "\t\t\treturn error;",
            "\t\t}",
            "\t\toffset = tmp->map->next_swap;",
            "\t}",
            "\thandle->k = 0;",
            "\thandle->cur = handle->maps->map;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "enough_swap, swsusp_write, release_swap_reader, get_swap_reader",
          "description": "实现足够交换页检查及休眠图像写入逻辑。enough_swap计算可用交换页判断是否满足需求，swsusp_write执行图像写入操作，get_swap_reader/get_swap_reader管理交换页读取句柄，release_swap_reader释放相关资源",
          "similarity": 0.6124714612960815
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/power/swap.c",
          "start_line": 67,
          "end_line": 181,
          "content": [
            "static inline unsigned long low_free_pages(void)",
            "{",
            "\treturn nr_free_pages() - nr_free_highpages();",
            "}",
            "static inline unsigned long reqd_free_pages(void)",
            "{",
            "\treturn low_free_pages() / 2;",
            "}",
            "static int swsusp_extents_insert(unsigned long swap_offset)",
            "{",
            "\tstruct rb_node **new = &(swsusp_extents.rb_node);",
            "\tstruct rb_node *parent = NULL;",
            "\tstruct swsusp_extent *ext;",
            "",
            "\t/* Figure out where to put the new node */",
            "\twhile (*new) {",
            "\t\text = rb_entry(*new, struct swsusp_extent, node);",
            "\t\tparent = *new;",
            "\t\tif (swap_offset < ext->start) {",
            "\t\t\t/* Try to merge */",
            "\t\t\tif (swap_offset == ext->start - 1) {",
            "\t\t\t\text->start--;",
            "\t\t\t\treturn 0;",
            "\t\t\t}",
            "\t\t\tnew = &((*new)->rb_left);",
            "\t\t} else if (swap_offset > ext->end) {",
            "\t\t\t/* Try to merge */",
            "\t\t\tif (swap_offset == ext->end + 1) {",
            "\t\t\t\text->end++;",
            "\t\t\t\treturn 0;",
            "\t\t\t}",
            "\t\t\tnew = &((*new)->rb_right);",
            "\t\t} else {",
            "\t\t\t/* It already is in the tree */",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "\t/* Add the new node and rebalance the tree. */",
            "\text = kzalloc(sizeof(struct swsusp_extent), GFP_KERNEL);",
            "\tif (!ext)",
            "\t\treturn -ENOMEM;",
            "",
            "\text->start = swap_offset;",
            "\text->end = swap_offset;",
            "\trb_link_node(&ext->node, parent, new);",
            "\trb_insert_color(&ext->node, &swsusp_extents);",
            "\treturn 0;",
            "}",
            "sector_t alloc_swapdev_block(int swap)",
            "{",
            "\tunsigned long offset;",
            "",
            "\toffset = swp_offset(get_swap_page_of_type(swap));",
            "\tif (offset) {",
            "\t\tif (swsusp_extents_insert(offset))",
            "\t\t\tswap_free(swp_entry(swap, offset));",
            "\t\telse",
            "\t\t\treturn swapdev_block(swap, offset);",
            "\t}",
            "\treturn 0;",
            "}",
            "void free_all_swap_pages(int swap)",
            "{",
            "\tstruct rb_node *node;",
            "",
            "\twhile ((node = swsusp_extents.rb_node)) {",
            "\t\tstruct swsusp_extent *ext;",
            "",
            "\t\text = rb_entry(node, struct swsusp_extent, node);",
            "\t\trb_erase(node, &swsusp_extents);",
            "\t\tswap_free_nr(swp_entry(swap, ext->start),",
            "\t\t\t     ext->end - ext->start + 1);",
            "",
            "\t\tkfree(ext);",
            "\t}",
            "}",
            "int swsusp_swap_in_use(void)",
            "{",
            "\treturn (swsusp_extents.rb_node != NULL);",
            "}",
            "static void hib_init_batch(struct hib_bio_batch *hb)",
            "{",
            "\tatomic_set(&hb->count, 0);",
            "\tinit_waitqueue_head(&hb->wait);",
            "\thb->error = BLK_STS_OK;",
            "\tblk_start_plug(&hb->plug);",
            "}",
            "static void hib_finish_batch(struct hib_bio_batch *hb)",
            "{",
            "\tblk_finish_plug(&hb->plug);",
            "}",
            "static void hib_end_io(struct bio *bio)",
            "{",
            "\tstruct hib_bio_batch *hb = bio->bi_private;",
            "\tstruct page *page = bio_first_page_all(bio);",
            "",
            "\tif (bio->bi_status) {",
            "\t\tpr_alert(\"Read-error on swap-device (%u:%u:%Lu)\\n\",",
            "\t\t\t MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),",
            "\t\t\t (unsigned long long)bio->bi_iter.bi_sector);",
            "\t}",
            "",
            "\tif (bio_data_dir(bio) == WRITE)",
            "\t\tput_page(page);",
            "\telse if (clean_pages_on_read)",
            "\t\tflush_icache_range((unsigned long)page_address(page),",
            "\t\t\t\t   (unsigned long)page_address(page) + PAGE_SIZE);",
            "",
            "\tif (bio->bi_status && !hb->error)",
            "\t\thb->error = bio->bi_status;",
            "\tif (atomic_dec_and_test(&hb->count))",
            "\t\twake_up(&hb->wait);",
            "",
            "\tbio_put(bio);",
            "}"
          ],
          "function_name": "low_free_pages, reqd_free_pages, swsusp_extents_insert, alloc_swapdev_block, free_all_swap_pages, swsusp_swap_in_use, hib_init_batch, hib_finish_batch, hib_end_io",
          "description": "实现了一系列与交换设备管理相关的辅助函数，包括跟踪交换区域的范围插入（swsusp_extents_insert）、分配/释放交换块（alloc_swapdev_block/free_all_swap_pages），以及管理I/O批次处理的初始化/完成函数（hib_init_batch/hib_finish_batch）。核心功能是维护交换设备的可用空间并管理批量I/O操作。",
          "similarity": 0.5985299348831177
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/power/swap.c",
          "start_line": 408,
          "end_line": 549,
          "content": [
            "static void release_swap_writer(struct swap_map_handle *handle)",
            "{",
            "\tif (handle->cur)",
            "\t\tfree_page((unsigned long)handle->cur);",
            "\thandle->cur = NULL;",
            "}",
            "static int get_swap_writer(struct swap_map_handle *handle)",
            "{",
            "\tint ret;",
            "",
            "\tret = swsusp_swap_check();",
            "\tif (ret) {",
            "\t\tif (ret != -ENOSPC)",
            "\t\t\tpr_err(\"Cannot find swap device, try swapon -a\\n\");",
            "\t\treturn ret;",
            "\t}",
            "\thandle->cur = (struct swap_map_page *)get_zeroed_page(GFP_KERNEL);",
            "\tif (!handle->cur) {",
            "\t\tret = -ENOMEM;",
            "\t\tgoto err_close;",
            "\t}",
            "\thandle->cur_swap = alloc_swapdev_block(root_swap);",
            "\tif (!handle->cur_swap) {",
            "\t\tret = -ENOSPC;",
            "\t\tgoto err_rel;",
            "\t}",
            "\thandle->k = 0;",
            "\thandle->reqd_free_pages = reqd_free_pages();",
            "\thandle->first_sector = handle->cur_swap;",
            "\treturn 0;",
            "err_rel:",
            "\trelease_swap_writer(handle);",
            "err_close:",
            "\tswsusp_close();",
            "\treturn ret;",
            "}",
            "static int swap_write_page(struct swap_map_handle *handle, void *buf,",
            "\t\tstruct hib_bio_batch *hb)",
            "{",
            "\tint error = 0;",
            "\tsector_t offset;",
            "",
            "\tif (!handle->cur)",
            "\t\treturn -EINVAL;",
            "\toffset = alloc_swapdev_block(root_swap);",
            "\terror = write_page(buf, offset, hb);",
            "\tif (error)",
            "\t\treturn error;",
            "\thandle->cur->entries[handle->k++] = offset;",
            "\tif (handle->k >= MAP_PAGE_ENTRIES) {",
            "\t\toffset = alloc_swapdev_block(root_swap);",
            "\t\tif (!offset)",
            "\t\t\treturn -ENOSPC;",
            "\t\thandle->cur->next_swap = offset;",
            "\t\terror = write_page(handle->cur, handle->cur_swap, hb);",
            "\t\tif (error)",
            "\t\t\tgoto out;",
            "\t\tclear_page(handle->cur);",
            "\t\thandle->cur_swap = offset;",
            "\t\thandle->k = 0;",
            "",
            "\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {",
            "\t\t\terror = hib_wait_io(hb);",
            "\t\t\tif (error)",
            "\t\t\t\tgoto out;",
            "\t\t\t/*",
            "\t\t\t * Recalculate the number of required free pages, to",
            "\t\t\t * make sure we never take more than half.",
            "\t\t\t */",
            "\t\t\thandle->reqd_free_pages = reqd_free_pages();",
            "\t\t}",
            "\t}",
            " out:",
            "\treturn error;",
            "}",
            "static int flush_swap_writer(struct swap_map_handle *handle)",
            "{",
            "\tif (handle->cur && handle->cur_swap)",
            "\t\treturn write_page(handle->cur, handle->cur_swap, NULL);",
            "\telse",
            "\t\treturn -EINVAL;",
            "}",
            "static int swap_writer_finish(struct swap_map_handle *handle,",
            "\t\tunsigned int flags, int error)",
            "{",
            "\tif (!error) {",
            "\t\tpr_info(\"S\");",
            "\t\terror = mark_swapfiles(handle, flags);",
            "\t\tpr_cont(\"|\\n\");",
            "\t\tflush_swap_writer(handle);",
            "\t}",
            "",
            "\tif (error)",
            "\t\tfree_all_swap_pages(root_swap);",
            "\trelease_swap_writer(handle);",
            "\tswsusp_close();",
            "",
            "\treturn error;",
            "}",
            "static int save_image(struct swap_map_handle *handle,",
            "                      struct snapshot_handle *snapshot,",
            "                      unsigned int nr_to_write)",
            "{",
            "\tunsigned int m;",
            "\tint ret;",
            "\tint nr_pages;",
            "\tint err2;",
            "\tstruct hib_bio_batch hb;",
            "\tktime_t start;",
            "\tktime_t stop;",
            "",
            "\thib_init_batch(&hb);",
            "",
            "\tpr_info(\"Saving image data pages (%u pages)...\\n\",",
            "\t\tnr_to_write);",
            "\tm = nr_to_write / 10;",
            "\tif (!m)",
            "\t\tm = 1;",
            "\tnr_pages = 0;",
            "\tstart = ktime_get();",
            "\twhile (1) {",
            "\t\tret = snapshot_read_next(snapshot);",
            "\t\tif (ret <= 0)",
            "\t\t\tbreak;",
            "\t\tret = swap_write_page(handle, data_of(*snapshot), &hb);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t\tif (!(nr_pages % m))",
            "\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",",
            "\t\t\t\tnr_pages / m * 10);",
            "\t\tnr_pages++;",
            "\t}",
            "\terr2 = hib_wait_io(&hb);",
            "\thib_finish_batch(&hb);",
            "\tstop = ktime_get();",
            "\tif (!ret)",
            "\t\tret = err2;",
            "\tif (!ret)",
            "\t\tpr_info(\"Image saving done\\n\");",
            "\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");",
            "\treturn ret;",
            "}"
          ],
          "function_name": "release_swap_writer, get_swap_writer, swap_write_page, flush_swap_writer, swap_writer_finish, save_image",
          "description": "实现交换写入器的生命周期管理（get_swap_writer/release_swap_writer），负责将页面数据按顺序写入交换设备的swap_write_page函数，以及最终完成写入的swap_writer_finish函数。核心功能是按页序组织休眠图像数据并持久化到交换设备。",
          "similarity": 0.5851508378982544
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/power/swap.c",
          "start_line": 271,
          "end_line": 386,
          "content": [
            "static int hib_submit_io(blk_opf_t opf, pgoff_t page_off, void *addr,",
            "\t\t\t struct hib_bio_batch *hb)",
            "{",
            "\tstruct page *page = virt_to_page(addr);",
            "\tstruct bio *bio;",
            "\tint error = 0;",
            "",
            "\tbio = bio_alloc(file_bdev(hib_resume_bdev_file), 1, opf,",
            "\t\t\tGFP_NOIO | __GFP_HIGH);",
            "\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);",
            "",
            "\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {",
            "\t\tpr_err(\"Adding page to bio failed at %llu\\n\",",
            "\t\t       (unsigned long long)bio->bi_iter.bi_sector);",
            "\t\tbio_put(bio);",
            "\t\treturn -EFAULT;",
            "\t}",
            "",
            "\tif (hb) {",
            "\t\tbio->bi_end_io = hib_end_io;",
            "\t\tbio->bi_private = hb;",
            "\t\tatomic_inc(&hb->count);",
            "\t\tsubmit_bio(bio);",
            "\t} else {",
            "\t\terror = submit_bio_wait(bio);",
            "\t\tbio_put(bio);",
            "\t}",
            "",
            "\treturn error;",
            "}",
            "static int hib_wait_io(struct hib_bio_batch *hb)",
            "{",
            "\t/*",
            "\t * We are relying on the behavior of blk_plug that a thread with",
            "\t * a plug will flush the plug list before sleeping.",
            "\t */",
            "\twait_event(hb->wait, atomic_read(&hb->count) == 0);",
            "\treturn blk_status_to_errno(hb->error);",
            "}",
            "static int mark_swapfiles(struct swap_map_handle *handle, unsigned int flags)",
            "{",
            "\tint error;",
            "",
            "\thib_submit_io(REQ_OP_READ, swsusp_resume_block, swsusp_header, NULL);",
            "\tif (!memcmp(\"SWAP-SPACE\",swsusp_header->sig, 10) ||",
            "\t    !memcmp(\"SWAPSPACE2\",swsusp_header->sig, 10)) {",
            "\t\tmemcpy(swsusp_header->orig_sig,swsusp_header->sig, 10);",
            "\t\tmemcpy(swsusp_header->sig, HIBERNATE_SIG, 10);",
            "\t\tswsusp_header->image = handle->first_sector;",
            "\t\tif (swsusp_hardware_signature) {",
            "\t\t\tswsusp_header->hw_sig = swsusp_hardware_signature;",
            "\t\t\tflags |= SF_HW_SIG;",
            "\t\t}",
            "\t\tswsusp_header->flags = flags;",
            "\t\tif (flags & SF_CRC32_MODE)",
            "\t\t\tswsusp_header->crc32 = handle->crc32;",
            "\t\terror = hib_submit_io(REQ_OP_WRITE | REQ_SYNC,",
            "\t\t\t\t      swsusp_resume_block, swsusp_header, NULL);",
            "\t} else {",
            "\t\tpr_err(\"Swap header not found!\\n\");",
            "\t\terror = -ENODEV;",
            "\t}",
            "\treturn error;",
            "}",
            "static int swsusp_swap_check(void)",
            "{",
            "\tint res;",
            "",
            "\tif (swsusp_resume_device)",
            "\t\tres = swap_type_of(swsusp_resume_device, swsusp_resume_block);",
            "\telse",
            "\t\tres = find_first_swap(&swsusp_resume_device);",
            "\tif (res < 0)",
            "\t\treturn res;",
            "\troot_swap = res;",
            "",
            "\thib_resume_bdev_file = bdev_file_open_by_dev(swsusp_resume_device,",
            "\t\t\tBLK_OPEN_WRITE, NULL, NULL);",
            "\tif (IS_ERR(hib_resume_bdev_file))",
            "\t\treturn PTR_ERR(hib_resume_bdev_file);",
            "",
            "\treturn 0;",
            "}",
            "static int write_page(void *buf, sector_t offset, struct hib_bio_batch *hb)",
            "{",
            "\tvoid *src;",
            "\tint ret;",
            "",
            "\tif (!offset)",
            "\t\treturn -ENOSPC;",
            "",
            "\tif (hb) {",
            "\t\tsrc = (void *)__get_free_page(GFP_NOIO | __GFP_NOWARN |",
            "\t\t                              __GFP_NORETRY);",
            "\t\tif (src) {",
            "\t\t\tcopy_page(src, buf);",
            "\t\t} else {",
            "\t\t\tret = hib_wait_io(hb); /* Free pages */",
            "\t\t\tif (ret)",
            "\t\t\t\treturn ret;",
            "\t\t\tsrc = (void *)__get_free_page(GFP_NOIO |",
            "\t\t\t                              __GFP_NOWARN |",
            "\t\t\t                              __GFP_NORETRY);",
            "\t\t\tif (src) {",
            "\t\t\t\tcopy_page(src, buf);",
            "\t\t\t} else {",
            "\t\t\t\tWARN_ON_ONCE(1);",
            "\t\t\t\thb = NULL;\t/* Go synchronous */",
            "\t\t\t\tsrc = buf;",
            "\t\t\t}",
            "\t\t}",
            "\t} else {",
            "\t\tsrc = buf;",
            "\t}",
            "\treturn hib_submit_io(REQ_OP_WRITE | REQ_SYNC, offset, src, hb);",
            "}"
          ],
          "function_name": "hib_submit_io, hib_wait_io, mark_swapfiles, swsusp_swap_check, write_page",
          "description": "包含休眠图像数据的提交与等待I/O函数（hib_submit_io/hib_wait_io），检查交换设备存在的函数（swsusp_swap_check），以及将页面数据写入指定偏移的write_page函数。核心功能是执行休眠图像的物理存储操作并验证交换设备有效性。",
          "similarity": 0.5728703737258911
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/power/swap.c",
          "start_line": 1012,
          "end_line": 1124,
          "content": [
            "static int swap_read_page(struct swap_map_handle *handle, void *buf,",
            "\t\tstruct hib_bio_batch *hb)",
            "{",
            "\tsector_t offset;",
            "\tint error;",
            "\tstruct swap_map_page_list *tmp;",
            "",
            "\tif (!handle->cur)",
            "\t\treturn -EINVAL;",
            "\toffset = handle->cur->entries[handle->k];",
            "\tif (!offset)",
            "\t\treturn -EFAULT;",
            "\terror = hib_submit_io(REQ_OP_READ, offset, buf, hb);",
            "\tif (error)",
            "\t\treturn error;",
            "\tif (++handle->k >= MAP_PAGE_ENTRIES) {",
            "\t\thandle->k = 0;",
            "\t\tfree_page((unsigned long)handle->maps->map);",
            "\t\ttmp = handle->maps;",
            "\t\thandle->maps = handle->maps->next;",
            "\t\tkfree(tmp);",
            "\t\tif (!handle->maps)",
            "\t\t\trelease_swap_reader(handle);",
            "\t\telse",
            "\t\t\thandle->cur = handle->maps->map;",
            "\t}",
            "\treturn error;",
            "}",
            "static int swap_reader_finish(struct swap_map_handle *handle)",
            "{",
            "\trelease_swap_reader(handle);",
            "",
            "\treturn 0;",
            "}",
            "static int load_image(struct swap_map_handle *handle,",
            "                      struct snapshot_handle *snapshot,",
            "                      unsigned int nr_to_read)",
            "{",
            "\tunsigned int m;",
            "\tint ret = 0;",
            "\tktime_t start;",
            "\tktime_t stop;",
            "\tstruct hib_bio_batch hb;",
            "\tint err2;",
            "\tunsigned nr_pages;",
            "",
            "\thib_init_batch(&hb);",
            "",
            "\tclean_pages_on_read = true;",
            "\tpr_info(\"Loading image data pages (%u pages)...\\n\", nr_to_read);",
            "\tm = nr_to_read / 10;",
            "\tif (!m)",
            "\t\tm = 1;",
            "\tnr_pages = 0;",
            "\tstart = ktime_get();",
            "\tfor ( ; ; ) {",
            "\t\tret = snapshot_write_next(snapshot);",
            "\t\tif (ret <= 0)",
            "\t\t\tbreak;",
            "\t\tret = swap_read_page(handle, data_of(*snapshot), &hb);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t\tif (snapshot->sync_read)",
            "\t\t\tret = hib_wait_io(&hb);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t\tif (!(nr_pages % m))",
            "\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",",
            "\t\t\t\tnr_pages / m * 10);",
            "\t\tnr_pages++;",
            "\t}",
            "\terr2 = hib_wait_io(&hb);",
            "\thib_finish_batch(&hb);",
            "\tstop = ktime_get();",
            "\tif (!ret)",
            "\t\tret = err2;",
            "\tif (!ret) {",
            "\t\tpr_info(\"Image loading done\\n\");",
            "\t\tsnapshot_write_finalize(snapshot);",
            "\t\tif (!snapshot_image_loaded(snapshot))",
            "\t\t\tret = -ENODATA;",
            "\t}",
            "\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");",
            "\treturn ret;",
            "}",
            "static int lzo_decompress_threadfn(void *data)",
            "{",
            "\tstruct dec_data *d = data;",
            "",
            "\twhile (1) {",
            "\t\twait_event(d->go, atomic_read_acquire(&d->ready) ||",
            "\t\t                  kthread_should_stop());",
            "\t\tif (kthread_should_stop()) {",
            "\t\t\td->thr = NULL;",
            "\t\t\td->ret = -1;",
            "\t\t\tatomic_set_release(&d->stop, 1);",
            "\t\t\twake_up(&d->done);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tatomic_set(&d->ready, 0);",
            "",
            "\t\td->unc_len = LZO_UNC_SIZE;",
            "\t\td->ret = lzo1x_decompress_safe(d->cmp + LZO_HEADER, d->cmp_len,",
            "\t\t                               d->unc, &d->unc_len);",
            "\t\tif (clean_pages_on_decompress)",
            "\t\t\tflush_icache_range((unsigned long)d->unc,",
            "\t\t\t\t\t   (unsigned long)d->unc + d->unc_len);",
            "",
            "\t\tatomic_set_release(&d->stop, 1);",
            "\t\twake_up(&d->done);",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "swap_read_page, swap_reader_finish, load_image, lzo_decompress_threadfn",
          "description": "提供交换页读取、结束处理及图像加载功能。swap_read_page读取指定偏移数据至缓冲区，swap_reader_finish调用释放函数，load_image加载非压缩图像数据，lzo_decompress_threadfn作为线程解压LZO压缩数据",
          "similarity": 0.5449390411376953
        }
      ]
    },
    {
      "source_file": "mm/swap_cgroup.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:26:23\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `swap_cgroup.c`\n\n---\n\n# swap_cgroup.c 技术文档\n\n## 1. 文件概述\n\n`swap_cgroup.c` 实现了 Linux 内核中用于跟踪交换（swap）条目与内存控制组（mem_cgroup）之间关联关系的机制。该文件通过紧凑的数据结构将每个 swap 条目映射到对应的 mem_cgroup ID，从而支持基于 cgroup 的内存资源统计和限制功能（特别是 swap accounting）。当系统启用 `CONFIG_MEMCG_SWAP` 时，此机制用于在页面换出（swap out）时记录所属 cgroup，并在换入（swap in）或释放 swap 槽位时清除记录。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct swap_cgroup`**  \n  原子变量（`atomic_t`）封装结构，用于存储多个 swap 条目的 cgroup ID。每个 `swap_cgroup` 实例可容纳 `ID_PER_SC` 个 16 位的 cgroup ID。\n\n- **`struct swap_cgroup_ctrl`**  \n  每个 swap 设备（最多 `MAX_SWAPFILES` 个）对应一个控制器，包含指向 `swap_cgroup` 数组的指针 `map`。\n\n- **全局数组 `swap_cgroup_ctrl[MAX_SWAPFILES]`**  \n  管理所有已激活 swap 设备的 cgroup 映射表。\n\n### 主要函数\n\n- **`swap_cgroup_record()`**  \n  为属于同一 folio 的连续多个 swap 条目记录指定的 mem_cgroup ID。\n\n- **`swap_cgroup_clear()`**  \n  清除一组连续 swap 条目所关联的 mem_cgroup ID，并返回原 ID。\n\n- **`lookup_swap_cgroup_id()`**  \n  查询指定 swap 条目当前关联的 mem_cgroup ID。\n\n- **`swap_cgroup_swapon()`**  \n  在启用 swap 设备时，为其分配并初始化 cgroup 映射表。\n\n- **`swap_cgroup_swapoff()`**  \n  在停用 swap 设备时，释放其对应的 cgroup 映射表。\n\n## 3. 关键实现\n\n### 紧凑存储设计\n\n- 利用 `atomic_t`（通常为 32 位）同时存储两个 16 位的 cgroup ID（`ID_PER_SC = 2`），通过位操作实现高效存取。\n- 定义宏：\n  - `ID_SHIFT = 16`（`unsigned short` 的位宽）\n  - `ID_MASK = 0xFFFF`\n  - 每个 `swap_cgroup` 结构体大小等于 `atomic_t`，确保原子操作可行性。\n\n### 原子读写操作\n\n- **`__swap_cgroup_id_lookup()`**：通过位移和掩码从 `atomic_t` 中提取指定偏移的 ID。\n- **`__swap_cgroup_id_xchg()`**：使用 `atomic_try_cmpxchg()` 循环实现无锁更新，确保并发安全地替换指定位置的 ID。\n\n### 内存管理\n\n- 使用 `vzalloc()` 分配大块非连续虚拟内存（因 swap 空间可能很大），并在 `swapoff` 时通过 `vfree()` 释放。\n- 分配大小为 `DIV_ROUND_UP(max_pages, ID_PER_SC) * sizeof(struct swap_cgroup)`，即每两个 swap 条目共享一个 `swap_cgroup` 结构。\n\n### 安全性保障\n\n- 使用 `mutex`（`swap_cgroup_mutex`）保护 `swap_cgroup_ctrl[].map` 的赋值/清空操作，防止 swapon/swapoff 期间的竞态。\n- 多处使用 `VM_BUG_ON()` 断言确保调用前提（如清除时所有条目 ID 一致、记录时原 ID 为 0）。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/swap_cgroup.h>`：声明对外接口\n  - `<linux/vmalloc.h>`：提供 `vzalloc`/`vfree`\n  - `<linux/mm.h>` 和 `<linux/swapops.h>`：提供 swap 条目操作（`swp_offset`, `swp_type`）及内存管理基础\n\n- **配置依赖**：\n  - 仅在 `CONFIG_MEMCG` 启用且未通过 `swapaccount=0` 禁用时生效（由 `mem_cgroup_disabled()` 控制）\n\n- **与其他子系统交互**：\n  - 与 **memory cgroup (memcg)** 子系统紧密集成，在页面换出/换入路径中被调用\n  - 依赖 **swap subsystem** 提供的 `swp_entry_t` 抽象和 swap 设备管理\n\n## 5. 使用场景\n\n- **Swap Accounting（cgroup v1）**：  \n  当进程属于特定 mem cgroup 且其匿名页被换出时，内核调用 `swap_cgroup_record()` 将 swap 条目与 cgroup ID 绑定；后续换入或释放 swap 槽位时调用 `swap_cgroup_clear()` 解绑。\n\n- **资源统计与限制**：  \n  通过 `lookup_swap_cgroup_id()` 查询 swap 条目所属 cgroup，用于统计各 cgroup 的 swap 使用量，并在达到 `memory.swappiness` 或 `memory.limit_in_bytes` 限制时触发回收。\n\n- **Swap 设备生命周期管理**：  \n  在 `sys_swapon()` 中调用 `swap_cgroup_swapon()` 初始化映射表，在 `sys_swapoff()` 中调用 `swap_cgroup_swapoff()` 释放资源。",
      "similarity": 0.6687981486320496,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/swap_cgroup.c",
          "start_line": 24,
          "end_line": 136,
          "content": [
            "static unsigned short __swap_cgroup_id_lookup(struct swap_cgroup *map,",
            "\t\t\t\t\t      pgoff_t offset)",
            "{",
            "\tunsigned int shift = (offset % ID_PER_SC) * ID_SHIFT;",
            "\tunsigned int old_ids = atomic_read(&map[offset / ID_PER_SC].ids);",
            "",
            "\tBUILD_BUG_ON(!is_power_of_2(ID_PER_SC));",
            "\tBUILD_BUG_ON(sizeof(struct swap_cgroup) != sizeof(atomic_t));",
            "",
            "\treturn (old_ids >> shift) & ID_MASK;",
            "}",
            "static unsigned short __swap_cgroup_id_xchg(struct swap_cgroup *map,",
            "\t\t\t\t\t    pgoff_t offset,",
            "\t\t\t\t\t    unsigned short new_id)",
            "{",
            "\tunsigned short old_id;",
            "\tstruct swap_cgroup *sc = &map[offset / ID_PER_SC];",
            "\tunsigned int shift = (offset % ID_PER_SC) * ID_SHIFT;",
            "\tunsigned int new_ids, old_ids = atomic_read(&sc->ids);",
            "",
            "\tdo {",
            "\t\told_id = (old_ids >> shift) & ID_MASK;",
            "\t\tnew_ids = (old_ids & ~(ID_MASK << shift));",
            "\t\tnew_ids |= ((unsigned int)new_id) << shift;",
            "\t} while (!atomic_try_cmpxchg(&sc->ids, &old_ids, new_ids));",
            "",
            "\treturn old_id;",
            "}",
            "void swap_cgroup_record(struct folio *folio, unsigned short id,",
            "\t\t\tswp_entry_t ent)",
            "{",
            "\tunsigned int nr_ents = folio_nr_pages(folio);",
            "\tstruct swap_cgroup *map;",
            "\tpgoff_t offset, end;",
            "\tunsigned short old;",
            "",
            "\toffset = swp_offset(ent);",
            "\tend = offset + nr_ents;",
            "\tmap = swap_cgroup_ctrl[swp_type(ent)].map;",
            "",
            "\tdo {",
            "\t\told = __swap_cgroup_id_xchg(map, offset, id);",
            "\t\tVM_BUG_ON(old);",
            "\t} while (++offset != end);",
            "}",
            "unsigned short swap_cgroup_clear(swp_entry_t ent, unsigned int nr_ents)",
            "{",
            "\tpgoff_t offset, end;",
            "\tstruct swap_cgroup *map;",
            "\tunsigned short old, iter = 0;",
            "",
            "\toffset = swp_offset(ent);",
            "\tend = offset + nr_ents;",
            "\tmap = swap_cgroup_ctrl[swp_type(ent)].map;",
            "",
            "\tdo {",
            "\t\told = __swap_cgroup_id_xchg(map, offset, 0);",
            "\t\tif (!iter)",
            "\t\t\titer = old;",
            "\t\tVM_BUG_ON(iter != old);",
            "\t} while (++offset != end);",
            "",
            "\treturn old;",
            "}",
            "unsigned short lookup_swap_cgroup_id(swp_entry_t ent)",
            "{",
            "\tstruct swap_cgroup_ctrl *ctrl;",
            "",
            "\tctrl = &swap_cgroup_ctrl[swp_type(ent)];",
            "\treturn __swap_cgroup_id_lookup(ctrl->map, swp_offset(ent));",
            "}",
            "int swap_cgroup_swapon(int type, unsigned long max_pages)",
            "{",
            "\tstruct swap_cgroup *map;",
            "\tstruct swap_cgroup_ctrl *ctrl;",
            "",
            "\tif (mem_cgroup_disabled())",
            "\t\treturn 0;",
            "",
            "\tBUILD_BUG_ON(sizeof(unsigned short) * ID_PER_SC !=",
            "\t\t     sizeof(struct swap_cgroup));",
            "\tmap = vzalloc(DIV_ROUND_UP(max_pages, ID_PER_SC) *",
            "\t\t      sizeof(struct swap_cgroup));",
            "\tif (!map)",
            "\t\tgoto nomem;",
            "",
            "\tctrl = &swap_cgroup_ctrl[type];",
            "\tmutex_lock(&swap_cgroup_mutex);",
            "\tctrl->map = map;",
            "\tmutex_unlock(&swap_cgroup_mutex);",
            "",
            "\treturn 0;",
            "nomem:",
            "\tpr_info(\"couldn't allocate enough memory for swap_cgroup\\n\");",
            "\tpr_info(\"swap_cgroup can be disabled by swapaccount=0 boot option\\n\");",
            "\treturn -ENOMEM;",
            "}",
            "void swap_cgroup_swapoff(int type)",
            "{",
            "\tstruct swap_cgroup *map;",
            "\tstruct swap_cgroup_ctrl *ctrl;",
            "",
            "\tif (mem_cgroup_disabled())",
            "\t\treturn;",
            "",
            "\tmutex_lock(&swap_cgroup_mutex);",
            "\tctrl = &swap_cgroup_ctrl[type];",
            "\tmap = ctrl->map;",
            "\tctrl->map = NULL;",
            "\tmutex_unlock(&swap_cgroup_mutex);",
            "",
            "\tvfree(map);",
            "}"
          ],
          "function_name": "__swap_cgroup_id_lookup, __swap_cgroup_id_xchg, swap_cgroup_record, swap_cgroup_clear, lookup_swap_cgroup_id, swap_cgroup_swapon, swap_cgroup_swapoff",
          "description": "实现交换cgroup的ID管理功能，包含ID查找、原子替换、记录/清除操作及交换设备挂载/卸载逻辑，通过原子操作保证多线程访问安全性",
          "similarity": 0.5249906778335571
        },
        {
          "chunk_id": 0,
          "file_path": "mm/swap_cgroup.c",
          "start_line": 1,
          "end_line": 23,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "",
            "#include <linux/swapops.h> /* depends on mm.h include */",
            "",
            "static DEFINE_MUTEX(swap_cgroup_mutex);",
            "",
            "/* Pack two cgroup id (short) of two entries in one swap_cgroup (atomic_t) */",
            "#define ID_PER_SC (sizeof(struct swap_cgroup) / sizeof(unsigned short))",
            "#define ID_SHIFT (BITS_PER_TYPE(unsigned short))",
            "#define ID_MASK (BIT(ID_SHIFT) - 1)",
            "struct swap_cgroup {",
            "\tatomic_t ids;",
            "};",
            "",
            "struct swap_cgroup_ctrl {",
            "\tstruct swap_cgroup *map;",
            "};",
            "",
            "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];",
            ""
          ],
          "function_name": null,
          "description": "定义了用于交换cgroup的原子操作数据结构和宏，其中swap_cgroup结构体通过原子类型ids存储多个cgroup ID，swap_cgroup_ctrl维护各交换设备对应的映射表",
          "similarity": 0.5219186544418335
        }
      ]
    },
    {
      "source_file": "mm/swap_slots.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:27:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `swap_slots.c`\n\n---\n\n# swap_slots.c 技术文档\n\n## 1. 文件概述\n\n`swap_slots.c` 实现了 Linux 内核中用于管理交换槽（swap slots）的本地 CPU 缓存机制。该机制通过为每个 CPU 维护一个交换槽缓存，避免在每次分配或释放交换槽时频繁获取全局 `swap_info` 锁，从而提升性能。同时，它支持将回收的交换槽批量归还到全局池中，以减少内存碎片。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct swap_slots_cache`：每个 CPU 的交换槽缓存结构，包含两个数组：\n  - `slots`：用于分配的交换槽缓存\n  - `slots_ret`：用于暂存待回收的交换槽\n- 全局 per-CPU 变量 `swp_slots`：存储各 CPU 的交换槽缓存实例\n\n### 主要函数\n- `alloc_swap_slot_cache()`：为指定 CPU 分配交换槽缓存内存\n- `free_slot_cache()`：释放指定 CPU 的交换槽缓存\n- `refill_swap_slots_cache()`：从全局交换池填充本地缓存\n- `free_swap_slot()`：将交换槽返回到本地缓存或直接释放\n- `__drain_swap_slots_cache()`：将所有在线 CPU 的缓存中的交换槽归还到全局池\n- `drain_slots_cache_cpu()`：清空指定 CPU 的交换槽缓存\n- `enable_swap_slots_cache()`：启用交换槽缓存机制\n- `disable_swap_slots_cache_lock()` / `reenable_swap_slots_cache_unlock()`：禁用/重新启用缓存\n- `check_cache_active()`：根据系统交换页数量动态激活/停用缓存\n\n### 全局变量\n- `swap_slot_cache_active`：指示缓存是否当前处于活跃状态\n- `swap_slot_cache_enabled`：指示缓存功能是否已启用\n- `swap_slot_cache_initialized`：指示缓存子系统是否已完成初始化\n- `swap_slots_cache_mutex`：保护缓存操作的互斥锁\n- `swap_slots_cache_enable_mutex`：序列化缓存启用/禁用操作的互斥锁\n\n## 3. 关键实现\n\n### 本地缓存设计\n- 每个 CPU 拥有两个交换槽数组：\n  - `slots`：用于快速分配交换槽（受 `alloc_lock` 互斥锁保护）\n  - `slots_ret`：用于暂存待释放的交换槽（受 `free_lock` 自旋锁保护）\n- 分配时优先从本地 `slots` 数组获取；若为空，则批量从全局池获取 `SWAP_SLOTS_CACHE_SIZE` 个槽位填充\n- 释放时先放入 `slots_ret`，当其满时才批量归还到全局池，有助于减少锁竞争和内存碎片\n\n### 动态启停机制\n- 通过 `check_cache_active()` 根据可用交换页数量动态控制缓存活跃状态：\n  - 当可用交换页 > `num_online_cpus() * THRESHOLD_ACTIVATE_SWAP_SLOTS_CACHE` 时激活缓存\n  - 当可用交换页 < `num_online_cpus() * THRESHOLD_DEACTIVATE_SWAP_SLOTS_CACHE` 时停用缓存\n- 停用时会立即清空所有 CPU 缓存中的交换槽并归还到全局池\n\n### CPU 热插拔支持\n- 使用 `cpuhp_setup_state()` 注册 CPU 热插拔回调：\n  - CPU 上线时调用 `alloc_swap_slot_cache()` 分配缓存\n  - CPU 下线时调用 `free_slot_cache()` 释放缓存\n- 在清空缓存时使用 `for_each_online_cpu()` 遍历，避免与 CPU 热插拔操作死锁\n\n### 锁设计\n- 使用互斥锁（mutex）而非自旋锁，因为分配交换槽可能触发内存回收而睡眠\n- 分离分配锁（`alloc_lock`）和释放锁（`free_lock`），提高并发性\n- 全局操作使用 `swap_slots_cache_mutex` 保护，启用/禁用操作使用独立的 `swap_slots_cache_enable_mutex`\n\n### 安全标记\n- 从全局池分配的交换槽会被标记 `SWAP_HAS_CACHE`，防止被重复分配\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/swap_slots.h>`：定义交换槽缓存接口和数据结构\n  - `<linux/cpu.h>`、`<linux/cpumask.h>`：CPU 热插拔和掩码操作\n  - `<linux/slab.h>`、`<linux/vmalloc.h>`：内存分配\n  - `<linux/mutex.h>`、`<linux/spinlock.h>`：同步原语\n  - `<linux/mm.h>`：内存管理相关函数\n\n- **外部函数依赖**：\n  - `get_swap_pages()`：从全局交换池批量获取交换槽\n  - `swapcache_free_entries()`：将交换槽归还到全局池\n  - `has_usable_swap()`：检查是否存在可用交换设备\n  - `get_nr_swap_pages()`：获取当前可用交换页数量\n  - `zswap_invalidate()`：通知 zswap 无效化交换条目\n\n- **被调用方**：\n  - `folio_alloc_swap()`：在页面分配交换槽时使用此缓存机制\n  - 交换子系统其他组件通过 `free_swap_slot()` 释放交换槽\n\n## 5. 使用场景\n\n1. **页面交换分配**：当内核需要为匿名页分配交换槽时，优先从本地 CPU 缓存获取，避免全局锁竞争\n2. **页面交换释放**：当交换页被换入内存后，其交换槽通过 `free_swap_slot()` 返回到本地缓存\n3. **内存压力场景**：在低内存情况下，系统可能停用交换槽缓存以释放更多交换空间\n4. **交换设备管理**：\n   - `swapon` 时通过 `enable_swap_slots_cache()` 启用缓存\n   - `swapoff` 时通过 `__drain_swap_slots_cache()` 确保所有缓存槽位归还\n5. **CPU 热插拔**：动态为新上线 CPU 分配缓存，为下线 CPU 释放缓存资源\n6. **系统休眠/恢复**：在休眠前确保交换槽缓存被正确清空，避免状态不一致",
      "similarity": 0.6674228310585022,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/swap_slots.c",
          "start_line": 168,
          "end_line": 297,
          "content": [
            "static void drain_slots_cache_cpu(unsigned int cpu, unsigned int type,",
            "\t\t\t\t  bool free_slots)",
            "{",
            "\tstruct swap_slots_cache *cache;",
            "\tswp_entry_t *slots = NULL;",
            "",
            "\tcache = &per_cpu(swp_slots, cpu);",
            "\tif ((type & SLOTS_CACHE) && cache->slots) {",
            "\t\tmutex_lock(&cache->alloc_lock);",
            "\t\tswapcache_free_entries(cache->slots + cache->cur, cache->nr);",
            "\t\tcache->cur = 0;",
            "\t\tcache->nr = 0;",
            "\t\tif (free_slots && cache->slots) {",
            "\t\t\tkvfree(cache->slots);",
            "\t\t\tcache->slots = NULL;",
            "\t\t}",
            "\t\tmutex_unlock(&cache->alloc_lock);",
            "\t}",
            "\tif ((type & SLOTS_CACHE_RET) && cache->slots_ret) {",
            "\t\tspin_lock_irq(&cache->free_lock);",
            "\t\tswapcache_free_entries(cache->slots_ret, cache->n_ret);",
            "\t\tcache->n_ret = 0;",
            "\t\tif (free_slots && cache->slots_ret) {",
            "\t\t\tslots = cache->slots_ret;",
            "\t\t\tcache->slots_ret = NULL;",
            "\t\t}",
            "\t\tspin_unlock_irq(&cache->free_lock);",
            "\t\tkvfree(slots);",
            "\t}",
            "}",
            "static void __drain_swap_slots_cache(unsigned int type)",
            "{",
            "\tunsigned int cpu;",
            "",
            "\t/*",
            "\t * This function is called during",
            "\t *\t1) swapoff, when we have to make sure no",
            "\t *\t   left over slots are in cache when we remove",
            "\t *\t   a swap device;",
            "\t *      2) disabling of swap slot cache, when we run low",
            "\t *\t   on swap slots when allocating memory and need",
            "\t *\t   to return swap slots to global pool.",
            "\t *",
            "\t * We cannot acquire cpu hot plug lock here as",
            "\t * this function can be invoked in the cpu",
            "\t * hot plug path:",
            "\t * cpu_up -> lock cpu_hotplug -> cpu hotplug state callback",
            "\t *   -> memory allocation -> direct reclaim -> folio_alloc_swap",
            "\t *   -> drain_swap_slots_cache",
            "\t *",
            "\t * Hence the loop over current online cpu below could miss cpu that",
            "\t * is being brought online but not yet marked as online.",
            "\t * That is okay as we do not schedule and run anything on a",
            "\t * cpu before it has been marked online. Hence, we will not",
            "\t * fill any swap slots in slots cache of such cpu.",
            "\t * There are no slots on such cpu that need to be drained.",
            "\t */",
            "\tfor_each_online_cpu(cpu)",
            "\t\tdrain_slots_cache_cpu(cpu, type, false);",
            "}",
            "static int free_slot_cache(unsigned int cpu)",
            "{",
            "\tmutex_lock(&swap_slots_cache_mutex);",
            "\tdrain_slots_cache_cpu(cpu, SLOTS_CACHE | SLOTS_CACHE_RET, true);",
            "\tmutex_unlock(&swap_slots_cache_mutex);",
            "\treturn 0;",
            "}",
            "void enable_swap_slots_cache(void)",
            "{",
            "\tmutex_lock(&swap_slots_cache_enable_mutex);",
            "\tif (!swap_slot_cache_initialized) {",
            "\t\tint ret;",
            "",
            "\t\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"swap_slots_cache\",",
            "\t\t\t\t\talloc_swap_slot_cache, free_slot_cache);",
            "\t\tif (WARN_ONCE(ret < 0, \"Cache allocation failed (%s), operating \"",
            "\t\t\t\t       \"without swap slots cache.\\n\", __func__))",
            "\t\t\tgoto out_unlock;",
            "",
            "\t\tswap_slot_cache_initialized = true;",
            "\t}",
            "",
            "\t__reenable_swap_slots_cache();",
            "out_unlock:",
            "\tmutex_unlock(&swap_slots_cache_enable_mutex);",
            "}",
            "static int refill_swap_slots_cache(struct swap_slots_cache *cache)",
            "{",
            "\tif (!use_swap_slot_cache)",
            "\t\treturn 0;",
            "",
            "\tcache->cur = 0;",
            "\tif (swap_slot_cache_active)",
            "\t\tcache->nr = get_swap_pages(SWAP_SLOTS_CACHE_SIZE,",
            "\t\t\t\t\t   cache->slots, 0);",
            "",
            "\treturn cache->nr;",
            "}",
            "void free_swap_slot(swp_entry_t entry)",
            "{",
            "\tstruct swap_slots_cache *cache;",
            "",
            "\t/* Large folio swap slot is not covered. */",
            "\tzswap_invalidate(entry);",
            "",
            "\tcache = raw_cpu_ptr(&swp_slots);",
            "\tif (likely(use_swap_slot_cache && cache->slots_ret)) {",
            "\t\tspin_lock_irq(&cache->free_lock);",
            "\t\t/* Swap slots cache may be deactivated before acquiring lock */",
            "\t\tif (!use_swap_slot_cache || !cache->slots_ret) {",
            "\t\t\tspin_unlock_irq(&cache->free_lock);",
            "\t\t\tgoto direct_free;",
            "\t\t}",
            "\t\tif (cache->n_ret >= SWAP_SLOTS_CACHE_SIZE) {",
            "\t\t\t/*",
            "\t\t\t * Return slots to global pool.",
            "\t\t\t * The current swap_map value is SWAP_HAS_CACHE.",
            "\t\t\t * Set it to 0 to indicate it is available for",
            "\t\t\t * allocation in global pool",
            "\t\t\t */",
            "\t\t\tswapcache_free_entries(cache->slots_ret, cache->n_ret);",
            "\t\t\tcache->n_ret = 0;",
            "\t\t}",
            "\t\tcache->slots_ret[cache->n_ret++] = entry;",
            "\t\tspin_unlock_irq(&cache->free_lock);",
            "\t} else {",
            "direct_free:",
            "\t\tswapcache_free_entries(&entry, 1);",
            "\t}",
            "}"
          ],
          "function_name": "drain_slots_cache_cpu, __drain_swap_slots_cache, free_slot_cache, enable_swap_slots_cache, refill_swap_slots_cache, free_swap_slot",
          "description": "实现swap slots缓存的清理机制，包括CPU本地缓存数据迁移、内存释放及全局池归还操作",
          "similarity": 0.6911815404891968
        },
        {
          "chunk_id": 1,
          "file_path": "mm/swap_slots.c",
          "start_line": 52,
          "end_line": 159,
          "content": [
            "static void deactivate_swap_slots_cache(void)",
            "{",
            "\tmutex_lock(&swap_slots_cache_mutex);",
            "\tswap_slot_cache_active = false;",
            "\t__drain_swap_slots_cache(SLOTS_CACHE|SLOTS_CACHE_RET);",
            "\tmutex_unlock(&swap_slots_cache_mutex);",
            "}",
            "static void reactivate_swap_slots_cache(void)",
            "{",
            "\tmutex_lock(&swap_slots_cache_mutex);",
            "\tswap_slot_cache_active = true;",
            "\tmutex_unlock(&swap_slots_cache_mutex);",
            "}",
            "void disable_swap_slots_cache_lock(void)",
            "{",
            "\tmutex_lock(&swap_slots_cache_enable_mutex);",
            "\tswap_slot_cache_enabled = false;",
            "\tif (swap_slot_cache_initialized) {",
            "\t\t/* serialize with cpu hotplug operations */",
            "\t\tcpus_read_lock();",
            "\t\t__drain_swap_slots_cache(SLOTS_CACHE|SLOTS_CACHE_RET);",
            "\t\tcpus_read_unlock();",
            "\t}",
            "}",
            "static void __reenable_swap_slots_cache(void)",
            "{",
            "\tswap_slot_cache_enabled = has_usable_swap();",
            "}",
            "void reenable_swap_slots_cache_unlock(void)",
            "{",
            "\t__reenable_swap_slots_cache();",
            "\tmutex_unlock(&swap_slots_cache_enable_mutex);",
            "}",
            "static bool check_cache_active(void)",
            "{",
            "\tlong pages;",
            "",
            "\tif (!swap_slot_cache_enabled)",
            "\t\treturn false;",
            "",
            "\tpages = get_nr_swap_pages();",
            "\tif (!swap_slot_cache_active) {",
            "\t\tif (pages > num_online_cpus() *",
            "\t\t    THRESHOLD_ACTIVATE_SWAP_SLOTS_CACHE)",
            "\t\t\treactivate_swap_slots_cache();",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* if global pool of slot caches too low, deactivate cache */",
            "\tif (pages < num_online_cpus() * THRESHOLD_DEACTIVATE_SWAP_SLOTS_CACHE)",
            "\t\tdeactivate_swap_slots_cache();",
            "out:",
            "\treturn swap_slot_cache_active;",
            "}",
            "static int alloc_swap_slot_cache(unsigned int cpu)",
            "{",
            "\tstruct swap_slots_cache *cache;",
            "\tswp_entry_t *slots, *slots_ret;",
            "",
            "\t/*",
            "\t * Do allocation outside swap_slots_cache_mutex",
            "\t * as kvzalloc could trigger reclaim and folio_alloc_swap,",
            "\t * which can lock swap_slots_cache_mutex.",
            "\t */",
            "\tslots = kvcalloc(SWAP_SLOTS_CACHE_SIZE, sizeof(swp_entry_t),",
            "\t\t\t GFP_KERNEL);",
            "\tif (!slots)",
            "\t\treturn -ENOMEM;",
            "",
            "\tslots_ret = kvcalloc(SWAP_SLOTS_CACHE_SIZE, sizeof(swp_entry_t),",
            "\t\t\t     GFP_KERNEL);",
            "\tif (!slots_ret) {",
            "\t\tkvfree(slots);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tmutex_lock(&swap_slots_cache_mutex);",
            "\tcache = &per_cpu(swp_slots, cpu);",
            "\tif (cache->slots || cache->slots_ret) {",
            "\t\t/* cache already allocated */",
            "\t\tmutex_unlock(&swap_slots_cache_mutex);",
            "",
            "\t\tkvfree(slots);",
            "\t\tkvfree(slots_ret);",
            "",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tif (!cache->lock_initialized) {",
            "\t\tmutex_init(&cache->alloc_lock);",
            "\t\tspin_lock_init(&cache->free_lock);",
            "\t\tcache->lock_initialized = true;",
            "\t}",
            "\tcache->nr = 0;",
            "\tcache->cur = 0;",
            "\tcache->n_ret = 0;",
            "\t/*",
            "\t * We initialized alloc_lock and free_lock earlier.  We use",
            "\t * !cache->slots or !cache->slots_ret to know if it is safe to acquire",
            "\t * the corresponding lock and use the cache.  Memory barrier below",
            "\t * ensures the assumption.",
            "\t */",
            "\tmb();",
            "\tcache->slots = slots;",
            "\tcache->slots_ret = slots_ret;",
            "\tmutex_unlock(&swap_slots_cache_mutex);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "deactivate_swap_slots_cache, reactivate_swap_slots_cache, disable_swap_slots_cache_lock, __reenable_swap_slots_cache, reenable_swap_slots_cache_unlock, check_cache_active, alloc_swap_slot_cache",
          "description": "提供swap slots缓存的激活/停用控制接口，通过互斥锁同步状态变更并协调内存分配与回收流程",
          "similarity": 0.673791766166687
        },
        {
          "chunk_id": 0,
          "file_path": "mm/swap_slots.c",
          "start_line": 1,
          "end_line": 51,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Manage cache of swap slots to be used for and returned from",
            " * swap.",
            " *",
            " * Copyright(c) 2016 Intel Corporation.",
            " *",
            " * Author: Tim Chen <tim.c.chen@linux.intel.com>",
            " *",
            " * We allocate the swap slots from the global pool and put",
            " * it into local per cpu caches.  This has the advantage",
            " * of no needing to acquire the swap_info lock every time",
            " * we need a new slot.",
            " *",
            " * There is also opportunity to simply return the slot",
            " * to local caches without needing to acquire swap_info",
            " * lock.  We do not reuse the returned slots directly but",
            " * move them back to the global pool in a batch.  This",
            " * allows the slots to coalesce and reduce fragmentation.",
            " *",
            " * The swap entry allocated is marked with SWAP_HAS_CACHE",
            " * flag in map_count that prevents it from being allocated",
            " * again from the global pool.",
            " *",
            " * The swap slots cache is protected by a mutex instead of",
            " * a spin lock as when we search for slots with scan_swap_map,",
            " * we can possibly sleep.",
            " */",
            "",
            "#include <linux/swap_slots.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "",
            "static DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);",
            "static bool\tswap_slot_cache_active;",
            "bool\tswap_slot_cache_enabled;",
            "static bool\tswap_slot_cache_initialized;",
            "static DEFINE_MUTEX(swap_slots_cache_mutex);",
            "/* Serialize swap slots cache enable/disable operations */",
            "static DEFINE_MUTEX(swap_slots_cache_enable_mutex);",
            "",
            "static void __drain_swap_slots_cache(unsigned int type);",
            "",
            "#define use_swap_slot_cache (swap_slot_cache_active && swap_slot_cache_enabled)",
            "#define SLOTS_CACHE 0x1",
            "#define SLOTS_CACHE_RET 0x2",
            ""
          ],
          "function_name": null,
          "description": "声明swap slots缓存相关的全局变量和宏，用于管理交换槽的本地CPU缓存与全局池切换逻辑",
          "similarity": 0.6617911458015442
        },
        {
          "chunk_id": 3,
          "file_path": "mm/swap_slots.c",
          "start_line": 305,
          "end_line": 353,
          "content": [
            "swp_entry_t folio_alloc_swap(struct folio *folio)",
            "{",
            "\tswp_entry_t entry;",
            "\tstruct swap_slots_cache *cache;",
            "",
            "\tentry.val = 0;",
            "",
            "\tif (folio_test_large(folio)) {",
            "\t\tif (IS_ENABLED(CONFIG_THP_SWAP))",
            "\t\t\tget_swap_pages(1, &entry, folio_order(folio));",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * Preemption is allowed here, because we may sleep",
            "\t * in refill_swap_slots_cache().  But it is safe, because",
            "\t * accesses to the per-CPU data structure are protected by the",
            "\t * mutex cache->alloc_lock.",
            "\t *",
            "\t * The alloc path here does not touch cache->slots_ret",
            "\t * so cache->free_lock is not taken.",
            "\t */",
            "\tcache = raw_cpu_ptr(&swp_slots);",
            "",
            "\tif (likely(check_cache_active() && cache->slots)) {",
            "\t\tmutex_lock(&cache->alloc_lock);",
            "\t\tif (cache->slots) {",
            "repeat:",
            "\t\t\tif (cache->nr) {",
            "\t\t\t\tentry = cache->slots[cache->cur];",
            "\t\t\t\tcache->slots[cache->cur++].val = 0;",
            "\t\t\t\tcache->nr--;",
            "\t\t\t} else if (refill_swap_slots_cache(cache)) {",
            "\t\t\t\tgoto repeat;",
            "\t\t\t}",
            "\t\t}",
            "\t\tmutex_unlock(&cache->alloc_lock);",
            "\t\tif (entry.val)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tget_swap_pages(1, &entry, 0);",
            "out:",
            "\tif (mem_cgroup_try_charge_swap(folio, entry)) {",
            "\t\tput_swap_folio(folio, entry);",
            "\t\tentry.val = 0;",
            "\t}",
            "\treturn entry;",
            "}"
          ],
          "function_name": "folio_alloc_swap",
          "description": "从swap slots缓存或直接全局池分配交换槽，支持并发场景下的缓存预取与资源回收协作",
          "similarity": 0.6390135884284973
        }
      ]
    }
  ]
}