{
  "query": "BPF程序在系统监控中的应用",
  "timestamp": "2025-12-26 01:37:11",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/syscall.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:31:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\syscall.c`\n\n---\n\n# `bpf/syscall.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/syscall.c` 是 Linux 内核中 BPF（Berkeley Packet Filter）子系统的核心实现文件之一，主要负责处理与 BPF 相关的系统调用逻辑。该文件实现了 BPF 程序、映射（map）和链接（link）对象的创建、更新、查询、删除等操作的底层支持，并管理这些对象的生命周期、权限控制、内存布局以及与用户空间的交互。此外，它还包含对 BPF 对象中用户指针（uptr）的内存固定（pinning）机制，确保内核安全访问用户空间内存。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `bpf_map_ops`：定义各类 BPF 映射的操作函数集，通过 `bpf_map_types[]` 数组按类型索引。\n- `bpf_map`：BPF 映射的通用抽象结构，包含类型、键/值大小、操作函数指针等。\n- IDR（Integer ID Allocator）结构：\n  - `prog_idr` / `map_idr` / `link_idr`：分别用于分配和管理 BPF 程序、映射和链接的全局唯一 ID。\n- `btf_record` 与 `btf_field`：用于描述 BPF 对象中包含的 BTF（BPF Type Format）元数据字段，特别是 `BPF_UPTR` 类型字段。\n\n### 主要函数\n- `bpf_check_uarg_tail_zero()`：验证用户传入的结构体尾部未使用字节是否为零，用于向前兼容。\n- `bpf_map_value_size()`：根据映射类型计算实际存储值的大小（如 per-CPU 映射需乘以 CPU 数）。\n- `bpf_map_update_value()`：统一入口，根据映射类型分发到对应的更新实现。\n- `bpf_obj_pin_uptrs()` / `bpf_obj_unpin_uptrs()`：对 BPF 对象中 `BPF_UPTR` 字段指向的用户空间内存进行长期固定（pin）或释放。\n- `maybe_wait_bpf_programs()`：在更新某些映射（如 map-in-map）后同步等待正在运行的 BPF 程序完成。\n- `bpf_map_write_active*()`：提供映射写入活跃状态的原子计数机制。\n\n### 全局变量\n- `sysctl_unprivileged_bpf_disabled`：控制非特权用户是否可使用 BPF 的运行时开关。\n- `bpf_prog_active`（per-CPU）：跟踪当前 CPU 上是否正在执行 BPF 程序。\n- `bpf_map_offload_ops`：用于硬件卸载（offload）场景的映射操作集。\n\n### 宏定义\n- `IS_FD_*` 系列宏：用于快速判断映射是否存储文件描述符（如程序、其他映射等）。\n- `BPF_OBJ_FLAG_MASK`：定义 BPF 对象创建时允许的标志位掩码。\n\n## 3. 关键实现\n\n### 用户参数兼容性检查\n`bpf_check_uarg_tail_zero()` 函数确保当用户空间传递比内核预期更大的结构体时，超出部分必须全为零。这防止新版本用户空间依赖尚未实现的内核特性，保障 ABI 的向前兼容性。该函数区分内核指针和用户指针，分别使用 `memchr_inv()` 和 `check_zeroed_user()` 进行检查。\n\n### BPF 映射值大小计算\n`bpf_map_value_size()` 根据映射类型动态计算实际存储开销：\n- 对于 per-CPU 类型（如 `PERCPU_HASH`、`PERCPU_ARRAY`），值大小需对齐到 8 字节并乘以可能的 CPU 数量。\n- 对于存储文件描述符的映射（如 `PROG_ARRAY`、`ARRAY_OF_MAPS`），值大小固定为 `sizeof(u32)`。\n- 其他类型直接使用 `map->value_size`。\n\n### 用户指针（uptr）内存固定机制\nBPF 支持在映射值或程序上下文中包含指向用户空间内存的指针（`BPF_UPTR`）。为确保内核安全访问：\n1. `bpf_obj_pin_uptrs()` 使用 `pin_user_pages_fast()` 将用户页长期固定（`FOLL_LONGTERM`），防止被换出。\n2. 要求目标结构体不能跨页（避免复杂性），且不支持高端内存（`PageHighMem`）。\n3. 固定成功后，将用户虚拟地址转换为内核线性映射地址存储。\n4. 出错时通过 `__bpf_obj_unpin_uptrs()` 回滚已固定的页。\n\n### 映射更新分发逻辑\n`bpf_map_update_value()` 是映射更新的核心分发函数：\n- 硬件卸载映射调用 `bpf_map_offload_update_elem()`。\n- 特殊映射（如 `CPUMAP`、`SOCKMAP`）调用其专属更新函数。\n- 文件描述符类映射（`PROG_ARRAY`、`ARRAY_OF_MAPS` 等）在 RCU 读锁保护下更新，确保并发安全。\n- per-CPU 映射调用对应的 per-CPU 更新函数。\n- 更新前调用 `bpf_disable_instrumentation()` 避免追踪干扰。\n\n### 同步机制\n- 对于 `HASH_OF_MAPS` 和 `ARRAY_OF_MAPS`，更新后调用 `synchronize_rcu()` 确保所有 CPU 上正在运行的 BPF 程序看到新值。\n- per-CPU 计数器 `bpf_prog_active` 用于检测 BPF 程序递归调用或死锁。\n\n## 4. 依赖关系\n\n- **BPF 子系统内部**：\n  - 依赖 `bpf_map_types.h` 自动生成的映射操作函数表。\n  - 与 `bpf_verifier.c`（验证器）、`bpf_helpers.c`（辅助函数）、各类映射实现（如 `arraymap.c`、`hashtab.c`）紧密协作。\n- **内存管理**：\n  - 使用 `pin_user_pages_fast()` / `unpin_user_page()` 管理用户页固定。\n  - 依赖 `mm/` 子系统的页表和内存分配机制。\n- **RCU 机制**：\n  - 在更新共享映射时使用 RCU 保证并发安全。\n- **BTF（BPF Type Format）**：\n  - 依赖 `btf.c` 提供的类型信息解析 `BPF_UPTR` 字段。\n- **网络子系统**：\n  - 包含 `netfilter/nf_bpf_link.h`、`netkit.h`、`tcx.h` 等头文件，支持网络相关的 BPF 链接类型。\n- **安全模块**：\n  - 与 LSM（`bpf_lsm.h`）、审计（`audit.h`）集成，实施权限检查。\n\n## 5. 使用场景\n\n- **系统调用处理**：作为 `bpf(2)` 系统调用的后端实现，处理 `BPF_MAP_CREATE`、`BPF_MAP_UPDATE_ELEM`、`BPF_PROG_LOAD` 等命令。\n- **eBPF 程序执行**：为运行中的 BPF 程序提供映射访问、程序调用（通过 `PROG_ARRAY`）等运行时支持。\n- **容器与 cgroup 集成**：通过 `CGROUP_ARRAY` 等映射类型实现资源控制策略。\n- **性能监控**：`PERF_EVENT_ARRAY` 映射用于将 BPF 程序与 perf 事件关联。\n- **网络数据平面**：`SOCKMAP`、`XSKMAP` 等用于加速 socket 和 AF_XDP 数据路径。\n- **内核追踪**：与 ftrace、kprobe 等子系统结合，实现动态追踪。\n- **安全策略实施**：通过 BPF LSM 钩子执行自定义安全策略。\n- **用户空间内存安全访问**：在需要内核直接访问用户缓冲区的场景（如某些高级 BPF 程序）中，通过 `BPF_UPTR` 机制安全固定内存。",
      "similarity": 0.6908432841300964,
      "chunks": [
        {
          "chunk_id": 33,
          "file_path": "kernel/bpf/syscall.c",
          "start_line": 5850,
          "end_line": 5961,
          "content": [
            "static bool syscall_prog_is_valid_access(int off, int size,",
            "\t\t\t\t\t enum bpf_access_type type,",
            "\t\t\t\t\t const struct bpf_prog *prog,",
            "\t\t\t\t\t struct bpf_insn_access_aux *info)",
            "{",
            "\tif (off < 0 || off >= U16_MAX)",
            "\t\treturn false;",
            "\tif (off % size != 0)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "int kern_sys_bpf(int cmd, union bpf_attr *attr, unsigned int size)",
            "{",
            "\tstruct bpf_prog * __maybe_unused prog;",
            "\tstruct bpf_tramp_run_ctx __maybe_unused run_ctx;",
            "",
            "\tswitch (cmd) {",
            "#ifdef CONFIG_BPF_JIT /* __bpf_prog_enter_sleepable used by trampoline and JIT */",
            "\tcase BPF_PROG_TEST_RUN:",
            "\t\tif (attr->test.data_in || attr->test.data_out ||",
            "\t\t    attr->test.ctx_out || attr->test.duration ||",
            "\t\t    attr->test.repeat || attr->test.flags)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tprog = bpf_prog_get_type(attr->test.prog_fd, BPF_PROG_TYPE_SYSCALL);",
            "\t\tif (IS_ERR(prog))",
            "\t\t\treturn PTR_ERR(prog);",
            "",
            "\t\tif (attr->test.ctx_size_in < prog->aux->max_ctx_offset ||",
            "\t\t    attr->test.ctx_size_in > U16_MAX) {",
            "\t\t\tbpf_prog_put(prog);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\trun_ctx.bpf_cookie = 0;",
            "\t\tif (!__bpf_prog_enter_sleepable_recur(prog, &run_ctx)) {",
            "\t\t\t/* recursion detected */",
            "\t\t\t__bpf_prog_exit_sleepable_recur(prog, 0, &run_ctx);",
            "\t\t\tbpf_prog_put(prog);",
            "\t\t\treturn -EBUSY;",
            "\t\t}",
            "\t\tattr->test.retval = bpf_prog_run(prog, (void *) (long) attr->test.ctx_in);",
            "\t\t__bpf_prog_exit_sleepable_recur(prog, 0 /* bpf_prog_run does runtime stats */,",
            "\t\t\t\t\t\t&run_ctx);",
            "\t\tbpf_prog_put(prog);",
            "\t\treturn 0;",
            "#endif",
            "\tdefault:",
            "\t\treturn ____bpf_sys_bpf(cmd, attr, size);",
            "\t}",
            "}",
            "static int bpf_stats_handler(struct ctl_table *table, int write,",
            "\t\t\t     void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct static_key *key = (struct static_key *)table->data;",
            "\tstatic int saved_val;",
            "\tint val, ret;",
            "\tstruct ctl_table tmp = {",
            "\t\t.data   = &val,",
            "\t\t.maxlen = sizeof(val),",
            "\t\t.mode   = table->mode,",
            "\t\t.extra1 = SYSCTL_ZERO,",
            "\t\t.extra2 = SYSCTL_ONE,",
            "\t};",
            "",
            "\tif (write && !capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tmutex_lock(&bpf_stats_enabled_mutex);",
            "\tval = saved_val;",
            "\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);",
            "\tif (write && !ret && val != saved_val) {",
            "\t\tif (val)",
            "\t\t\tstatic_key_slow_inc(key);",
            "\t\telse",
            "\t\t\tstatic_key_slow_dec(key);",
            "\t\tsaved_val = val;",
            "\t}",
            "\tmutex_unlock(&bpf_stats_enabled_mutex);",
            "\treturn ret;",
            "}",
            "void __weak unpriv_ebpf_notify(int new_state)",
            "{",
            "}",
            "static int bpf_unpriv_handler(struct ctl_table *table, int write,",
            "\t\t\t      void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tint ret, unpriv_enable = *(int *)table->data;",
            "\tbool locked_state = unpriv_enable == 1;",
            "\tstruct ctl_table tmp = *table;",
            "",
            "\tif (write && !capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\ttmp.data = &unpriv_enable;",
            "\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);",
            "\tif (write && !ret) {",
            "\t\tif (locked_state && unpriv_enable != 1)",
            "\t\t\treturn -EPERM;",
            "\t\tif (!unpriv_enable) {",
            "\t\t\tpr_warn(\"Unprivileged BPF has been enabled, \"",
            "\t\t\t\t\"tainting the kernel\");",
            "\t\t\tadd_taint(TAINT_UNPRIVILEGED_BPF, LOCKDEP_STILL_OK);",
            "\t\t}",
            "\t\t*(int *)table->data = unpriv_enable;",
            "\t}",
            "",
            "\tif (write)",
            "\t\tunpriv_ebpf_notify(unpriv_enable);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "syscall_prog_is_valid_access, kern_sys_bpf, bpf_stats_handler, unpriv_ebpf_notify, bpf_unpriv_handler",
          "description": "验证BPF程序访问合法性，处理特殊系统调用逻辑，管理统计开关状态和非特权模式通知",
          "similarity": 0.7199527621269226
        },
        {
          "chunk_id": 34,
          "file_path": "kernel/bpf/syscall.c",
          "start_line": 6100,
          "end_line": 6104,
          "content": [
            "static int __init bpf_syscall_sysctl_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", bpf_syscall_table);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_syscall_sysctl_init",
          "description": "注册BPF系统调用相关的sysctl控制接口，用于暴露和管理系统级参数配置",
          "similarity": 0.681119441986084
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/syscall.c",
          "start_line": 86,
          "end_line": 220,
          "content": [
            "int bpf_check_uarg_tail_zero(bpfptr_t uaddr,",
            "\t\t\t     size_t expected_size,",
            "\t\t\t     size_t actual_size)",
            "{",
            "\tint res;",
            "",
            "\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */",
            "\t\treturn -E2BIG;",
            "",
            "\tif (actual_size <= expected_size)",
            "\t\treturn 0;",
            "",
            "\tif (uaddr.is_kernel)",
            "\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,",
            "\t\t\t\t actual_size - expected_size) == NULL;",
            "\telse",
            "\t\tres = check_zeroed_user(uaddr.user + expected_size,",
            "\t\t\t\t\tactual_size - expected_size);",
            "\tif (res < 0)",
            "\t\treturn res;",
            "\treturn res ? 0 : -E2BIG;",
            "}",
            "static void bpf_map_write_active_inc(struct bpf_map *map)",
            "{",
            "\tatomic64_inc(&map->writecnt);",
            "}",
            "static void bpf_map_write_active_dec(struct bpf_map *map)",
            "{",
            "\tatomic64_dec(&map->writecnt);",
            "}",
            "bool bpf_map_write_active(const struct bpf_map *map)",
            "{",
            "\treturn atomic64_read(&map->writecnt) != 0;",
            "}",
            "static u32 bpf_map_value_size(const struct bpf_map *map)",
            "{",
            "\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||",
            "\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||",
            "\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||",
            "\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)",
            "\t\treturn round_up(map->value_size, 8) * num_possible_cpus();",
            "\telse if (IS_FD_MAP(map))",
            "\t\treturn sizeof(u32);",
            "\telse",
            "\t\treturn  map->value_size;",
            "}",
            "static void maybe_wait_bpf_programs(struct bpf_map *map)",
            "{",
            "\t/* Wait for any running BPF programs to complete so that",
            "\t * userspace, when we return to it, knows that all programs",
            "\t * that could be running use the new map value.",
            "\t */",
            "\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||",
            "\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)",
            "\t\tsynchronize_rcu();",
            "}",
            "static void unpin_uptr_kaddr(void *kaddr)",
            "{",
            "\tif (kaddr)",
            "\t\tunpin_user_page(virt_to_page(kaddr));",
            "}",
            "static void __bpf_obj_unpin_uptrs(struct btf_record *rec, u32 cnt, void *obj)",
            "{",
            "\tconst struct btf_field *field;",
            "\tvoid **uptr_addr;",
            "\tint i;",
            "",
            "\tfor (i = 0, field = rec->fields; i < cnt; i++, field++) {",
            "\t\tif (field->type != BPF_UPTR)",
            "\t\t\tcontinue;",
            "",
            "\t\tuptr_addr = obj + field->offset;",
            "\t\tunpin_uptr_kaddr(*uptr_addr);",
            "\t}",
            "}",
            "static void bpf_obj_unpin_uptrs(struct btf_record *rec, void *obj)",
            "{",
            "\tif (!btf_record_has_field(rec, BPF_UPTR))",
            "\t\treturn;",
            "",
            "\t__bpf_obj_unpin_uptrs(rec, rec->cnt, obj);",
            "}",
            "static int bpf_obj_pin_uptrs(struct btf_record *rec, void *obj)",
            "{",
            "\tconst struct btf_field *field;",
            "\tconst struct btf_type *t;",
            "\tunsigned long start, end;",
            "\tstruct page *page;",
            "\tvoid **uptr_addr;",
            "\tint i, err;",
            "",
            "\tif (!btf_record_has_field(rec, BPF_UPTR))",
            "\t\treturn 0;",
            "",
            "\tfor (i = 0, field = rec->fields; i < rec->cnt; i++, field++) {",
            "\t\tif (field->type != BPF_UPTR)",
            "\t\t\tcontinue;",
            "",
            "\t\tuptr_addr = obj + field->offset;",
            "\t\tstart = *(unsigned long *)uptr_addr;",
            "\t\tif (!start)",
            "\t\t\tcontinue;",
            "",
            "\t\tt = btf_type_by_id(field->kptr.btf, field->kptr.btf_id);",
            "\t\t/* t->size was checked for zero before */",
            "\t\tif (check_add_overflow(start, t->size - 1, &end)) {",
            "\t\t\terr = -EFAULT;",
            "\t\t\tgoto unpin_all;",
            "\t\t}",
            "",
            "\t\t/* The uptr's struct cannot span across two pages */",
            "\t\tif ((start & PAGE_MASK) != (end & PAGE_MASK)) {",
            "\t\t\terr = -EOPNOTSUPP;",
            "\t\t\tgoto unpin_all;",
            "\t\t}",
            "",
            "\t\terr = pin_user_pages_fast(start, 1, FOLL_LONGTERM | FOLL_WRITE, &page);",
            "\t\tif (err != 1)",
            "\t\t\tgoto unpin_all;",
            "",
            "\t\tif (PageHighMem(page)) {",
            "\t\t\terr = -EOPNOTSUPP;",
            "\t\t\tunpin_user_page(page);",
            "\t\t\tgoto unpin_all;",
            "\t\t}",
            "",
            "\t\t*uptr_addr = page_address(page) + offset_in_page(start);",
            "\t}",
            "",
            "\treturn 0;",
            "",
            "unpin_all:",
            "\t__bpf_obj_unpin_uptrs(rec, i, obj);",
            "\treturn err;",
            "}"
          ],
          "function_name": "bpf_check_uarg_tail_zero, bpf_map_write_active_inc, bpf_map_write_active_dec, bpf_map_write_active, bpf_map_value_size, maybe_wait_bpf_programs, unpin_uptr_kaddr, __bpf_obj_unpin_uptrs, bpf_obj_unpin_uptrs, bpf_obj_pin_uptrs",
          "description": "提供BPF map操作辅助函数，包括参数校验、写活性管理、值大小计算、等待程序同步及用户指针安全绑定",
          "similarity": 0.6766083240509033
        },
        {
          "chunk_id": 14,
          "file_path": "kernel/bpf/syscall.c",
          "start_line": 2300,
          "end_line": 2402,
          "content": [
            "static void __bpf_prog_put_rcu(struct rcu_head *rcu)",
            "{",
            "\tstruct bpf_prog_aux *aux = container_of(rcu, struct bpf_prog_aux, rcu);",
            "",
            "\tkvfree(aux->func_info);",
            "\tkfree(aux->func_info_aux);",
            "\tfree_uid(aux->user);",
            "\tsecurity_bpf_prog_free(aux->prog);",
            "\tbpf_prog_free(aux->prog);",
            "}",
            "static void __bpf_prog_put_noref(struct bpf_prog *prog, bool deferred)",
            "{",
            "\tbpf_prog_kallsyms_del_all(prog);",
            "\tbtf_put(prog->aux->btf);",
            "\tmodule_put(prog->aux->mod);",
            "\tkvfree(prog->aux->jited_linfo);",
            "\tkvfree(prog->aux->linfo);",
            "\tkfree(prog->aux->kfunc_tab);",
            "\tkfree(prog->aux->ctx_arg_info);",
            "\tif (prog->aux->attach_btf)",
            "\t\tbtf_put(prog->aux->attach_btf);",
            "",
            "\tif (deferred) {",
            "\t\tif (prog->sleepable)",
            "\t\t\tcall_rcu_tasks_trace(&prog->aux->rcu, __bpf_prog_put_rcu);",
            "\t\telse",
            "\t\t\tcall_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);",
            "\t} else {",
            "\t\t__bpf_prog_put_rcu(&prog->aux->rcu);",
            "\t}",
            "}",
            "static void bpf_prog_put_deferred(struct work_struct *work)",
            "{",
            "\tstruct bpf_prog_aux *aux;",
            "\tstruct bpf_prog *prog;",
            "",
            "\taux = container_of(work, struct bpf_prog_aux, work);",
            "\tprog = aux->prog;",
            "\tperf_event_bpf_event(prog, PERF_BPF_EVENT_PROG_UNLOAD, 0);",
            "\tbpf_audit_prog(prog, BPF_AUDIT_UNLOAD);",
            "\tbpf_prog_free_id(prog);",
            "\t__bpf_prog_put_noref(prog, true);",
            "}",
            "static void __bpf_prog_put(struct bpf_prog *prog)",
            "{",
            "\tstruct bpf_prog_aux *aux = prog->aux;",
            "",
            "\tif (atomic64_dec_and_test(&aux->refcnt)) {",
            "\t\tif (in_irq() || irqs_disabled()) {",
            "\t\t\tINIT_WORK(&aux->work, bpf_prog_put_deferred);",
            "\t\t\tschedule_work(&aux->work);",
            "\t\t} else {",
            "\t\t\tbpf_prog_put_deferred(&aux->work);",
            "\t\t}",
            "\t}",
            "}",
            "void bpf_prog_put(struct bpf_prog *prog)",
            "{",
            "\t__bpf_prog_put(prog);",
            "}",
            "static int bpf_prog_release(struct inode *inode, struct file *filp)",
            "{",
            "\tstruct bpf_prog *prog = filp->private_data;",
            "",
            "\tbpf_prog_put(prog);",
            "\treturn 0;",
            "}",
            "void notrace bpf_prog_inc_misses_counter(struct bpf_prog *prog)",
            "{",
            "\tstruct bpf_prog_stats *stats;",
            "\tunsigned int flags;",
            "",
            "\tstats = this_cpu_ptr(prog->stats);",
            "\tflags = u64_stats_update_begin_irqsave(&stats->syncp);",
            "\tu64_stats_inc(&stats->misses);",
            "\tu64_stats_update_end_irqrestore(&stats->syncp, flags);",
            "}",
            "static void bpf_prog_get_stats(const struct bpf_prog *prog,",
            "\t\t\t       struct bpf_prog_kstats *stats)",
            "{",
            "\tu64 nsecs = 0, cnt = 0, misses = 0;",
            "\tint cpu;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tconst struct bpf_prog_stats *st;",
            "\t\tunsigned int start;",
            "\t\tu64 tnsecs, tcnt, tmisses;",
            "",
            "\t\tst = per_cpu_ptr(prog->stats, cpu);",
            "\t\tdo {",
            "\t\t\tstart = u64_stats_fetch_begin(&st->syncp);",
            "\t\t\ttnsecs = u64_stats_read(&st->nsecs);",
            "\t\t\ttcnt = u64_stats_read(&st->cnt);",
            "\t\t\ttmisses = u64_stats_read(&st->misses);",
            "\t\t} while (u64_stats_fetch_retry(&st->syncp, start));",
            "\t\tnsecs += tnsecs;",
            "\t\tcnt += tcnt;",
            "\t\tmisses += tmisses;",
            "\t}",
            "\tstats->nsecs = nsecs;",
            "\tstats->cnt = cnt;",
            "\tstats->misses = misses;",
            "}"
          ],
          "function_name": "__bpf_prog_put_rcu, __bpf_prog_put_noref, bpf_prog_put_deferred, __bpf_prog_put, bpf_prog_put, bpf_prog_release, bpf_prog_inc_misses_counter, bpf_prog_get_stats",
          "description": "该代码段实现了BPF程序的资源释放与统计管理，核心功能包括：通过RCU机制安全释放BPF辅助数据结构及关联资源，并支持延迟释放以避免中断上下文直接操作；  \n函数`__bpf_prog_put_noref`清理非引用计数相关资源并调度RCU释放，`bpf_prog_put`通过引用计数控制释放时机，`bpf_prog_release`作为文件操作回调触发程序释放；  \n统计函数`bpf_prog_inc_misses_counter`与`bpf_prog_get_stats`分别用于记录BPF程序命中次数并聚合多CPU统计信息。",
          "similarity": 0.6751395463943481
        },
        {
          "chunk_id": 15,
          "file_path": "kernel/bpf/syscall.c",
          "start_line": 2419,
          "end_line": 2607,
          "content": [
            "static void bpf_prog_show_fdinfo(struct seq_file *m, struct file *filp)",
            "{",
            "\tconst struct bpf_prog *prog = filp->private_data;",
            "\tchar prog_tag[sizeof(prog->tag) * 2 + 1] = { };",
            "\tstruct bpf_prog_kstats stats;",
            "",
            "\tbpf_prog_get_stats(prog, &stats);",
            "\tbin2hex(prog_tag, prog->tag, sizeof(prog->tag));",
            "\tseq_printf(m,",
            "\t\t   \"prog_type:\\t%u\\n\"",
            "\t\t   \"prog_jited:\\t%u\\n\"",
            "\t\t   \"prog_tag:\\t%s\\n\"",
            "\t\t   \"memlock:\\t%llu\\n\"",
            "\t\t   \"prog_id:\\t%u\\n\"",
            "\t\t   \"run_time_ns:\\t%llu\\n\"",
            "\t\t   \"run_cnt:\\t%llu\\n\"",
            "\t\t   \"recursion_misses:\\t%llu\\n\"",
            "\t\t   \"verified_insns:\\t%u\\n\",",
            "\t\t   prog->type,",
            "\t\t   prog->jited,",
            "\t\t   prog_tag,",
            "\t\t   prog->pages * 1ULL << PAGE_SHIFT,",
            "\t\t   prog->aux->id,",
            "\t\t   stats.nsecs,",
            "\t\t   stats.cnt,",
            "\t\t   stats.misses,",
            "\t\t   prog->aux->verified_insns);",
            "}",
            "int bpf_prog_new_fd(struct bpf_prog *prog)",
            "{",
            "\tint ret;",
            "",
            "\tret = security_bpf_prog(prog);",
            "\tif (ret < 0)",
            "\t\treturn ret;",
            "",
            "\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,",
            "\t\t\t\tO_RDWR | O_CLOEXEC);",
            "}",
            "void bpf_prog_add(struct bpf_prog *prog, int i)",
            "{",
            "\tatomic64_add(i, &prog->aux->refcnt);",
            "}",
            "void bpf_prog_sub(struct bpf_prog *prog, int i)",
            "{",
            "\t/* Only to be used for undoing previous bpf_prog_add() in some",
            "\t * error path. We still know that another entity in our call",
            "\t * path holds a reference to the program, thus atomic_sub() can",
            "\t * be safely used in such cases!",
            "\t */",
            "\tWARN_ON(atomic64_sub_return(i, &prog->aux->refcnt) == 0);",
            "}",
            "void bpf_prog_inc(struct bpf_prog *prog)",
            "{",
            "\tatomic64_inc(&prog->aux->refcnt);",
            "}",
            "bool bpf_prog_get_ok(struct bpf_prog *prog,",
            "\t\t\t    enum bpf_prog_type *attach_type, bool attach_drv)",
            "{",
            "\t/* not an attachment, just a refcount inc, always allow */",
            "\tif (!attach_type)",
            "\t\treturn true;",
            "",
            "\tif (prog->type != *attach_type)",
            "\t\treturn false;",
            "\tif (bpf_prog_is_offloaded(prog->aux) && !attach_drv)",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}",
            "static void bpf_prog_load_fixup_attach_type(union bpf_attr *attr)",
            "{",
            "\tswitch (attr->prog_type) {",
            "\tcase BPF_PROG_TYPE_CGROUP_SOCK:",
            "\t\t/* Unfortunately BPF_ATTACH_TYPE_UNSPEC enumeration doesn't",
            "\t\t * exist so checking for non-zero is the way to go here.",
            "\t\t */",
            "\t\tif (!attr->expected_attach_type)",
            "\t\t\tattr->expected_attach_type =",
            "\t\t\t\tBPF_CGROUP_INET_SOCK_CREATE;",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_SK_REUSEPORT:",
            "\t\tif (!attr->expected_attach_type)",
            "\t\t\tattr->expected_attach_type =",
            "\t\t\t\tBPF_SK_REUSEPORT_SELECT;",
            "\t\tbreak;",
            "\t}",
            "}",
            "static int",
            "bpf_prog_load_check_attach(enum bpf_prog_type prog_type,",
            "\t\t\t   enum bpf_attach_type expected_attach_type,",
            "\t\t\t   struct btf *attach_btf, u32 btf_id,",
            "\t\t\t   struct bpf_prog *dst_prog)",
            "{",
            "\tif (btf_id) {",
            "\t\tif (btf_id > BTF_MAX_TYPE)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (!attach_btf && !dst_prog)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tswitch (prog_type) {",
            "\t\tcase BPF_PROG_TYPE_TRACING:",
            "\t\tcase BPF_PROG_TYPE_LSM:",
            "\t\tcase BPF_PROG_TYPE_STRUCT_OPS:",
            "\t\tcase BPF_PROG_TYPE_EXT:",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "",
            "\tif (attach_btf && (!btf_id || dst_prog))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (dst_prog && prog_type != BPF_PROG_TYPE_TRACING &&",
            "\t    prog_type != BPF_PROG_TYPE_EXT)",
            "\t\treturn -EINVAL;",
            "",
            "\tswitch (prog_type) {",
            "\tcase BPF_PROG_TYPE_CGROUP_SOCK:",
            "\t\tswitch (expected_attach_type) {",
            "\t\tcase BPF_CGROUP_INET_SOCK_CREATE:",
            "\t\tcase BPF_CGROUP_INET_SOCK_RELEASE:",
            "\t\tcase BPF_CGROUP_INET4_POST_BIND:",
            "\t\tcase BPF_CGROUP_INET6_POST_BIND:",
            "\t\t\treturn 0;",
            "\t\tdefault:",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:",
            "\t\tswitch (expected_attach_type) {",
            "\t\tcase BPF_CGROUP_INET4_BIND:",
            "\t\tcase BPF_CGROUP_INET6_BIND:",
            "\t\tcase BPF_CGROUP_INET4_CONNECT:",
            "\t\tcase BPF_CGROUP_INET6_CONNECT:",
            "\t\tcase BPF_CGROUP_INET4_GETPEERNAME:",
            "\t\tcase BPF_CGROUP_INET6_GETPEERNAME:",
            "\t\tcase BPF_CGROUP_INET4_GETSOCKNAME:",
            "\t\tcase BPF_CGROUP_INET6_GETSOCKNAME:",
            "\t\tcase BPF_CGROUP_UDP4_SENDMSG:",
            "\t\tcase BPF_CGROUP_UDP6_SENDMSG:",
            "\t\tcase BPF_CGROUP_UDP4_RECVMSG:",
            "\t\tcase BPF_CGROUP_UDP6_RECVMSG:",
            "\t\t\treturn 0;",
            "\t\tdefault:",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\tcase BPF_PROG_TYPE_CGROUP_SKB:",
            "\t\tswitch (expected_attach_type) {",
            "\t\tcase BPF_CGROUP_INET_INGRESS:",
            "\t\tcase BPF_CGROUP_INET_EGRESS:",
            "\t\t\treturn 0;",
            "\t\tdefault:",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:",
            "\t\tswitch (expected_attach_type) {",
            "\t\tcase BPF_CGROUP_SETSOCKOPT:",
            "\t\tcase BPF_CGROUP_GETSOCKOPT:",
            "\t\t\treturn 0;",
            "\t\tdefault:",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\tcase BPF_PROG_TYPE_SK_LOOKUP:",
            "\t\tif (expected_attach_type == BPF_SK_LOOKUP)",
            "\t\t\treturn 0;",
            "\t\treturn -EINVAL;",
            "\tcase BPF_PROG_TYPE_SK_REUSEPORT:",
            "\t\tswitch (expected_attach_type) {",
            "\t\tcase BPF_SK_REUSEPORT_SELECT:",
            "\t\tcase BPF_SK_REUSEPORT_SELECT_OR_MIGRATE:",
            "\t\t\treturn 0;",
            "\t\tdefault:",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\tcase BPF_PROG_TYPE_NETFILTER:",
            "\t\tif (expected_attach_type == BPF_NETFILTER)",
            "\t\t\treturn 0;",
            "\t\treturn -EINVAL;",
            "\tcase BPF_PROG_TYPE_SYSCALL:",
            "\tcase BPF_PROG_TYPE_EXT:",
            "\t\tif (expected_attach_type)",
            "\t\t\treturn -EINVAL;",
            "\t\tfallthrough;",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}"
          ],
          "function_name": "bpf_prog_show_fdinfo, bpf_prog_new_fd, bpf_prog_add, bpf_prog_sub, bpf_prog_inc, bpf_prog_get_ok, bpf_prog_load_fixup_attach_type, bpf_prog_load_check_attach",
          "description": "实现BPF程序文件描述符信息展示，包含程序类型、JIT状态、标签、内存占用等统计信息；通过security_bpf_prog进行安全策略检查，使用anon_inode_getfd创建新的BPF程序文件描述符；提供原子操作修改引用计数以管理程序生命周期；校验程序附加类型兼容性并修复预期附加类型；执行附加类型合法性检查以确保程序与目标对象匹配。",
          "similarity": 0.672598123550415
        }
      ]
    },
    {
      "source_file": "kernel/bpf/cpumask.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:07:30\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\cpumask.c`\n\n---\n\n# `bpf/cpumask.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/cpumask.c` 实现了 BPF（Berkeley Packet Filter）子系统中用于 CPU 掩码（cpumask）操作的一组内核函数（kfuncs）。该文件定义了一个引用计数的 `struct bpf_cpumask` 结构体，并提供了一系列安全、非阻塞的 BPF 可调用接口，用于创建、操作、查询和释放 cpumask 对象。这些接口专为 BPF 程序设计，确保与 BPF 验证器兼容，并通过 BPF 内存分配器实现 RCU 安全的内存管理。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct bpf_cpumask`**  \n  引用计数的 BPF cpumask 包装结构体：\n  - `cpumask_t cpumask`：嵌入的实际 cpumask 位图。\n  - `refcount_t usage`：引用计数器，归零时通过 RCU 回调释放内存。\n\n### 主要函数（BPF kfuncs）\n\n| 函数 | 功能 |\n|------|------|\n| `bpf_cpumask_create()` | 创建一个新的可变 BPF cpumask 对象 |\n| `bpf_cpumask_acquire()` | 增加 cpumask 引用计数 |\n| `bpf_cpumask_release()` | 减少引用计数，归零时异步释放内存 |\n| `bpf_cpumask_first()` | 返回 cpumask 中第一个设置的 CPU 编号 |\n| `bpf_cpumask_first_zero()` | 返回 cpumask 中第一个未设置的 CPU 编号 |\n| `bpf_cpumask_first_and()` | 返回两个 cpumask 按位与后第一个设置的 CPU 编号 |\n| `bpf_cpumask_set_cpu()` | 设置指定 CPU 位 |\n| `bpf_cpumask_clear_cpu()` | 清除指定 CPU 位 |\n| `bpf_cpumask_test_cpu()` | 测试指定 CPU 是否被设置 |\n| `bpf_cpumask_test_and_set_cpu()` | 原子地测试并设置指定 CPU 位 |\n| `bpf_cpumask_test_and_clear_cpu()` | 原子地测试并清除指定 CPU 位 |\n| `bpf_cpumask_setall()` | 设置所有有效 CPU 位 |\n| `bpf_cpumask_clear()` | 清除所有 CPU 位 |\n| `bpf_cpumask_and()` | 对两个 cpumask 执行按位与操作并存入目标 |\n\n> 所有函数均使用 `__bpf_kfunc` 标记，表示其为 BPF 程序可安全调用的内核函数。\n\n## 3. 关键实现\n\n### 内存管理与引用计数\n- 使用 `bpf_mem_alloc` 子系统（`bpf_cpumask_ma`）进行非阻塞内存分配。\n- `bpf_cpumask_release()` 在引用计数归零时调用 `bpf_mem_cache_free_rcu()`，确保在 RCU 宽限期后释放内存，避免并发访问问题。\n- 释放前调用 `migrate_disable()`/`migrate_enable()` 禁用 CPU 迁移，保证 RCU 回调上下文安全。\n\n### 与 cpumask 类型兼容性\n- 显式嵌入 `cpumask_t`（而非 `cpumask_var_t`），避免因 `CONFIG_CPUMASK_OFFSTACK` 配置差异导致 BPF 验证器类型混淆。\n- 通过 `BUILD_BUG_ON(offsetof(...) != 0)` 确保 `cpumask` 成员位于结构体起始位置，允许安全地将 `struct bpf_cpumask *` 强制转换为 `struct cpumask *`。\n\n### CPU 有效性检查\n- 所有涉及 CPU 编号的操作（如 `set_cpu`、`test_cpu` 等）均先调用 `cpu_valid(u32 cpu)` 验证 `cpu < nr_cpu_ids`，防止越界访问。\n\n### BPF 验证器兼容性\n- 所有导出函数使用 `__bpf_kfunc` 宏声明，确保被 BPF 验证器识别为合法调用目标。\n- 参数类型设计（如接受 `const struct cpumask *`）允许 BPF 程序传入 `struct bpf_cpumask *` 指针，利用结构体布局兼容性。\n\n## 4. 依赖关系\n\n- **`<linux/bpf.h>`**：BPF 核心头文件，提供 kfunc 声明宏。\n- **`<linux/bpf_mem_alloc.h>`**：BPF 内存分配器接口，用于 RCU 安全的对象分配与释放。\n- **`<linux/cpumask.h>`**：标准 cpumask 操作函数（如 `cpumask_set_cpu`、`cpumask_first` 等）。\n- **`<linux/refcount.h>`**：引用计数原语（通过 `refcount_t` 和相关操作）。\n- **`<linux/btf.h>` / `<linux/btf_ids.h>`**：支持 BTF（BPF Type Format）类型信息生成，用于 kfunc 元数据。\n\n## 5. 使用场景\n\n- **BPF 程序中的 CPU 亲和性控制**：例如在调度器 BPF 程序中动态构造或修改任务的 CPU 亲和掩码。\n- **资源隔离与负载均衡**：网络或跟踪 BPF 程序可根据系统状态动态生成 CPU 掩码，用于指导工作线程绑定。\n- **安全策略实施**：限制某些 BPF 程序仅在特定 CPU 集合上执行。\n- **与 BPF map 集成**：通过 `kptr`（内核指针）将 `struct bpf_cpumask` 存入 BPF map，实现跨 BPF 程序实例共享或持久化 cpumask 状态。\n- **原子操作支持**：`test_and_set`/`test_and_clear` 等接口适用于需要无锁并发修改 cpumask 的场景。",
      "similarity": 0.6822210550308228,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/cpumask.c",
          "start_line": 374,
          "end_line": 467,
          "content": [
            "__bpf_kfunc bool bpf_cpumask_full(const struct cpumask *cpumask)",
            "{",
            "\treturn cpumask_full(cpumask);",
            "}",
            "__bpf_kfunc void bpf_cpumask_copy(struct bpf_cpumask *dst, const struct cpumask *src)",
            "{",
            "\tcpumask_copy((struct cpumask *)dst, src);",
            "}",
            "__bpf_kfunc u32 bpf_cpumask_any_distribute(const struct cpumask *cpumask)",
            "{",
            "\treturn cpumask_any_distribute(cpumask);",
            "}",
            "__bpf_kfunc u32 bpf_cpumask_any_and_distribute(const struct cpumask *src1,",
            "\t\t\t\t\t       const struct cpumask *src2)",
            "{",
            "\treturn cpumask_any_and_distribute(src1, src2);",
            "}",
            "__bpf_kfunc u32 bpf_cpumask_weight(const struct cpumask *cpumask)",
            "{",
            "\treturn cpumask_weight(cpumask);",
            "}",
            "__bpf_kfunc int bpf_cpumask_populate(struct cpumask *cpumask, void *src, size_t src__sz)",
            "{",
            "\tunsigned long source = (unsigned long)src;",
            "",
            "\t/* The memory region must be large enough to populate the entire CPU mask. */",
            "\tif (src__sz < bitmap_size(nr_cpu_ids))",
            "\t\treturn -EACCES;",
            "",
            "\t/* If avoiding unaligned accesses, the input region must be aligned to the nearest long. */",
            "\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) &&",
            "\t\t!IS_ALIGNED(source, sizeof(long)))",
            "\t\treturn -EINVAL;",
            "",
            "\tbitmap_copy(cpumask_bits(cpumask), src, nr_cpu_ids);",
            "",
            "\treturn 0;",
            "}",
            "BTF_KFUNCS_START(cpumask_kfunc_btf_ids)",
            "BTF_ID_FLAGS(func, bpf_cpumask_create, KF_ACQUIRE | KF_RET_NULL)",
            "BTF_ID_FLAGS(func, bpf_cpumask_release, KF_RELEASE)",
            "BTF_ID_FLAGS(func, bpf_cpumask_acquire, KF_ACQUIRE | KF_TRUSTED_ARGS)",
            "BTF_ID_FLAGS(func, bpf_cpumask_first, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_first_zero, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_first_and, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_set_cpu, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_clear_cpu, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_test_cpu, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_test_and_set_cpu, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_test_and_clear_cpu, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_setall, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_clear, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_and, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_or, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_xor, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_equal, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_intersects, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_subset, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_empty, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_full, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_copy, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_any_distribute, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_any_and_distribute, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_weight, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_populate, KF_RCU)",
            "BTF_KFUNCS_END(cpumask_kfunc_btf_ids)",
            "",
            "static const struct btf_kfunc_id_set cpumask_kfunc_set = {",
            "\t.owner = THIS_MODULE,",
            "\t.set   = &cpumask_kfunc_btf_ids,",
            "};",
            "",
            "BTF_ID_LIST(cpumask_dtor_ids)",
            "BTF_ID(struct, bpf_cpumask)",
            "BTF_ID(func, bpf_cpumask_release)",
            "",
            "static int __init cpumask_kfunc_init(void)",
            "{",
            "\tint ret;",
            "\tconst struct btf_id_dtor_kfunc cpumask_dtors[] = {",
            "\t\t{",
            "\t\t\t.btf_id\t      = cpumask_dtor_ids[0],",
            "\t\t\t.kfunc_btf_id = cpumask_dtor_ids[1]",
            "\t\t},",
            "\t};",
            "",
            "\tret = bpf_mem_alloc_init(&bpf_cpumask_ma, sizeof(struct bpf_cpumask), false);",
            "\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_TRACING, &cpumask_kfunc_set);",
            "\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_STRUCT_OPS, &cpumask_kfunc_set);",
            "\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_SYSCALL, &cpumask_kfunc_set);",
            "\treturn  ret ?: register_btf_id_dtor_kfuncs(cpumask_dtors,",
            "\t\t\t\t\t\t   ARRAY_SIZE(cpumask_dtors),",
            "\t\t\t\t\t\t   THIS_MODULE);",
            "}"
          ],
          "function_name": "bpf_cpumask_full, bpf_cpumask_copy, bpf_cpumask_any_distribute, bpf_cpumask_any_and_distribute, bpf_cpumask_weight, bpf_cpumask_populate, BTF_ID_FLAGS",
          "description": "提供了CPU掩码数据填充、权重计算等扩展功能，并通过BTF ID标注系统注册所有kfunc到指定ID集合，包含内存分配器初始化、KFUNC集注册及析构函数注册逻辑，实现BPF程序对CPU掩码对象的全生命周期管理。",
          "similarity": 0.6928683519363403
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/cpumask.c",
          "start_line": 32,
          "end_line": 134,
          "content": [
            "static bool cpu_valid(u32 cpu)",
            "{",
            "\treturn cpu < nr_cpu_ids;",
            "}",
            "__bpf_kfunc void bpf_cpumask_release(struct bpf_cpumask *cpumask)",
            "{",
            "\tif (!refcount_dec_and_test(&cpumask->usage))",
            "\t\treturn;",
            "",
            "\tmigrate_disable();",
            "\tbpf_mem_cache_free_rcu(&bpf_cpumask_ma, cpumask);",
            "\tmigrate_enable();",
            "}",
            "__bpf_kfunc u32 bpf_cpumask_first(const struct cpumask *cpumask)",
            "{",
            "\treturn cpumask_first(cpumask);",
            "}",
            "__bpf_kfunc u32 bpf_cpumask_first_zero(const struct cpumask *cpumask)",
            "{",
            "\treturn cpumask_first_zero(cpumask);",
            "}",
            "__bpf_kfunc u32 bpf_cpumask_first_and(const struct cpumask *src1,",
            "\t\t\t\t      const struct cpumask *src2)",
            "{",
            "\treturn cpumask_first_and(src1, src2);",
            "}",
            "__bpf_kfunc void bpf_cpumask_set_cpu(u32 cpu, struct bpf_cpumask *cpumask)",
            "{",
            "\tif (!cpu_valid(cpu))",
            "\t\treturn;",
            "",
            "\tcpumask_set_cpu(cpu, (struct cpumask *)cpumask);",
            "}",
            "__bpf_kfunc void bpf_cpumask_clear_cpu(u32 cpu, struct bpf_cpumask *cpumask)",
            "{",
            "\tif (!cpu_valid(cpu))",
            "\t\treturn;",
            "",
            "\tcpumask_clear_cpu(cpu, (struct cpumask *)cpumask);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_test_cpu(u32 cpu, const struct cpumask *cpumask)",
            "{",
            "\tif (!cpu_valid(cpu))",
            "\t\treturn false;",
            "",
            "\treturn cpumask_test_cpu(cpu, (struct cpumask *)cpumask);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_test_and_set_cpu(u32 cpu, struct bpf_cpumask *cpumask)",
            "{",
            "\tif (!cpu_valid(cpu))",
            "\t\treturn false;",
            "",
            "\treturn cpumask_test_and_set_cpu(cpu, (struct cpumask *)cpumask);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_test_and_clear_cpu(u32 cpu, struct bpf_cpumask *cpumask)",
            "{",
            "\tif (!cpu_valid(cpu))",
            "\t\treturn false;",
            "",
            "\treturn cpumask_test_and_clear_cpu(cpu, (struct cpumask *)cpumask);",
            "}",
            "__bpf_kfunc void bpf_cpumask_setall(struct bpf_cpumask *cpumask)",
            "{",
            "\tcpumask_setall((struct cpumask *)cpumask);",
            "}",
            "__bpf_kfunc void bpf_cpumask_clear(struct bpf_cpumask *cpumask)",
            "{",
            "\tcpumask_clear((struct cpumask *)cpumask);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_and(struct bpf_cpumask *dst,",
            "\t\t\t\t const struct cpumask *src1,",
            "\t\t\t\t const struct cpumask *src2)",
            "{",
            "\treturn cpumask_and((struct cpumask *)dst, src1, src2);",
            "}",
            "__bpf_kfunc void bpf_cpumask_or(struct bpf_cpumask *dst,",
            "\t\t\t\tconst struct cpumask *src1,",
            "\t\t\t\tconst struct cpumask *src2)",
            "{",
            "\tcpumask_or((struct cpumask *)dst, src1, src2);",
            "}",
            "__bpf_kfunc void bpf_cpumask_xor(struct bpf_cpumask *dst,",
            "\t\t\t\t const struct cpumask *src1,",
            "\t\t\t\t const struct cpumask *src2)",
            "{",
            "\tcpumask_xor((struct cpumask *)dst, src1, src2);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_equal(const struct cpumask *src1, const struct cpumask *src2)",
            "{",
            "\treturn cpumask_equal(src1, src2);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_intersects(const struct cpumask *src1, const struct cpumask *src2)",
            "{",
            "\treturn cpumask_intersects(src1, src2);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_subset(const struct cpumask *src1, const struct cpumask *src2)",
            "{",
            "\treturn cpumask_subset(src1, src2);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_empty(const struct cpumask *cpumask)",
            "{",
            "\treturn cpumask_empty(cpumask);",
            "}"
          ],
          "function_name": "cpu_valid, bpf_cpumask_release, bpf_cpumask_first, bpf_cpumask_first_zero, bpf_cpumask_first_and, bpf_cpumask_set_cpu, bpf_cpumask_clear_cpu, bpf_cpumask_test_cpu, bpf_cpumask_test_and_set_cpu, bpf_cpumask_test_and_clear_cpu, bpf_cpumask_setall, bpf_cpumask_clear, bpf_cpumask_and, bpf_cpumask_or, bpf_cpumask_xor, bpf_cpumask_equal, bpf_cpumask_intersects, bpf_cpumask_subset, bpf_cpumask_empty",
          "description": "实现了针对bpf_cpumask的各类CPU掩码操作函数，包括引用计数释放、位操作、集合运算及状态查询等功能，所有函数均通过__bpf_kfunc声明为可被BPF程序调用的内核接口，其中release函数负责RCU安全的内存回收。",
          "similarity": 0.6313428282737732
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/cpumask.c",
          "start_line": 1,
          "end_line": 31,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2023 Meta, Inc */",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_mem_alloc.h>",
            "#include <linux/btf.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/cpumask.h>",
            "",
            "/**",
            " * struct bpf_cpumask - refcounted BPF cpumask wrapper structure",
            " * @cpumask:\tThe actual cpumask embedded in the struct.",
            " * @usage:\tObject reference counter. When the refcount goes to 0, the",
            " *\t\tmemory is released back to the BPF allocator, which provides",
            " *\t\tRCU safety.",
            " *",
            " * Note that we explicitly embed a cpumask_t rather than a cpumask_var_t.  This",
            " * is done to avoid confusing the verifier due to the typedef of cpumask_var_t",
            " * changing depending on whether CONFIG_CPUMASK_OFFSTACK is defined or not. See",
            " * the details in <linux/cpumask.h>. The consequence is that this structure is",
            " * likely a bit larger than it needs to be when CONFIG_CPUMASK_OFFSTACK is",
            " * defined due to embedding the whole NR_CPUS-size bitmap, but the extra memory",
            " * overhead is minimal. For the more typical case of CONFIG_CPUMASK_OFFSTACK",
            " * not being defined, the structure is the same size regardless.",
            " */",
            "struct bpf_cpumask {",
            "\tcpumask_t cpumask;",
            "\trefcount_t usage;",
            "};",
            "",
            "static struct bpf_mem_alloc bpf_cpumask_ma;",
            ""
          ],
          "function_name": null,
          "description": "定义了bpf_cpumask结构体，包含cpumask_t类型的cpumask字段和引用计数器usage，用于包装并管理BPF程序中的CPU掩码对象，通过引用计数控制内存生命周期，避免直接使用typedef可能引起的验证器混淆问题。",
          "similarity": 0.5783984661102295
        }
      ]
    },
    {
      "source_file": "kernel/bpf/mprog.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:20:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\mprog.c`\n\n---\n\n# bpf/mprog.c 技术文档\n\n## 1. 文件概述\n\n`bpf/mprog.c` 是 Linux 内核中用于管理 **BPF 多程序（multi-program）挂载点** 的核心实现文件。该文件提供了一套机制，允许在同一个挂载点上按顺序组织多个 BPF 程序（或通过 BPF link 关联的程序），并支持在运行时对这些程序进行 **插入、替换、删除** 等原子操作。此机制主要用于支持 **BPF 程序链（program chains）**，例如在 tc（traffic control）、XDP 或 cgroup 等子系统中实现多个 BPF 程序的有序执行。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct bpf_tuple`：封装一个 BPF 程序及其关联的 link（可选），用于统一表示待操作的目标程序。\n- `struct bpf_mprog_entry`：表示一个多程序挂载点的当前状态，包含程序数组、引用计数、版本号等。\n- `struct bpf_mprog_fp` / `struct bpf_mprog_cp`：分别表示程序的“快路径”（fast path）和“控制路径”（control path）数据，用于 RCU 安全的读写分离。\n\n### 主要函数\n\n| 函数 | 功能 |\n|------|------|\n| `bpf_mprog_link()` | 从 ID 或 FD 解析 BPF link，并验证程序类型 |\n| `bpf_mprog_prog()` | 从 ID 或 FD 解析 BPF program，并验证程序类型 |\n| `bpf_mprog_tuple_relative()` | 根据 flags（如 `BPF_F_ID`, `BPF_F_LINK`）统一解析用户传入的 `id_or_fd` 为 `bpf_tuple` |\n| `bpf_mprog_tuple_put()` | 释放 `bpf_tuple` 中持有的 program 或 link 引用 |\n| `bpf_mprog_replace()` | 在指定索引位置替换现有程序 |\n| `bpf_mprog_insert()` | 在指定位置（支持 `BPF_F_BEFORE` / `BPF_F_AFTER`）插入新程序 |\n| `bpf_mprog_delete()` | 删除指定位置的程序（支持首尾删除：`idx = -1` 或 `idx = total`） |\n| `bpf_mprog_pos_exact()` | 查找与给定 tuple 完全匹配的程序位置 |\n| `bpf_mprog_pos_before()` / `bpf_mprog_pos_after()` | 根据相对位置语义计算插入/删除目标索引 |\n| `bpf_mprog_attach()` | **核心入口函数**：根据用户 flags 执行 attach、replace 或 insert 操作 |\n| `bpf_mprog_fetch()` | （未完整实现）用于获取指定索引处的程序信息 |\n\n## 3. 关键实现\n\n### 3.1 程序与 Link 的统一抽象（`bpf_tuple`）\n通过 `bpf_tuple` 结构，将直接使用 BPF program FD/ID 与通过 BPF link 引用程序两种方式统一处理。`BPF_F_LINK` 标志决定是否从 link 解析，`BPF_F_ID` 决定输入是 ID 还是 FD。\n\n### 3.2 RCU 安全的多程序管理\n- 使用 `bpf_mprog_entry` 的 peer 机制实现 **写时复制（Copy-on-Write）**：\n  - 修改操作（insert/replace/delete）先复制当前 entry 到 peer\n  - 在 peer 上修改，最后原子切换指针\n  - 旧 entry 通过 RCU 回收，确保并发读安全\n- `bpf_mprog_read()` / `bpf_mprog_write()` 封装了对 `fp`（fast path）和 `cp`（control path）的访问\n\n### 3.3 相对位置语义支持\n- `BPF_F_BEFORE` / `BPF_F_AFTER` 允许用户指定相对于某个已有程序的位置\n- `bpf_mprog_pos_before()` / `bpf_mprog_pos_after()` 遍历当前程序列表，查找参考程序位置并返回目标索引\n- 特殊情况：当 `id_or_fd = 0` 且无 flags 时，表示在末尾插入（`idx = total`）\n\n### 3.4 原子性与一致性保障\n- `revision` 参数用于防止并发修改冲突（类似乐观锁）\n- `bpf_mprog_exists()` 检查避免重复添加同一程序\n- 所有修改操作最终通过 `*entry_new` 返回新 entry，由调用者负责发布\n\n### 3.5 边界处理\n- 插入到末尾：`idx == total`\n- 删除首元素：`idx = -1` → 转换为 `0`\n- 删除尾元素：`idx = total` → 转换为 `total - 1`\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/bpf.h>`：BPF 核心定义（`bpf_prog`, `bpf_link` 等）\n  - `<linux/bpf_mprog.h>`：多程序管理相关 API 和数据结构声明\n- **内核子系统依赖**：\n  - BPF 核心子系统（程序/链接生命周期管理）\n  - RCU 机制（用于无锁读取）\n  - 内存管理（`kmalloc`/`kfree` 用于 entry 复制）\n- **被调用方**：\n  - BPF 系统调用处理函数（如 `bpf(BPF_PROG_ATTACH, ...)` 的多程序扩展）\n  - 网络子系统（如 tc BPF 多程序支持）\n\n## 5. 使用场景\n\n1. **tc BPF 多程序链**：在同一个网络 qdisc 上挂载多个 BPF 程序，按顺序执行分类/过滤/修改操作\n2. **cgroup BPF 程序链**：在 cgroup 层级上组合多个安全或资源控制策略\n3. **动态策略更新**：运行时替换某个中间策略程序，而不中断整个链的执行\n4. **模块化 BPF 应用**：将复杂逻辑拆分为多个小程序，通过 attach 顺序组合\n5. **调试与热补丁**：临时插入诊断程序或替换有缺陷的程序版本\n\n该机制为 BPF 提供了类似“插件链”或“中间件栈”的能力，增强了 BPF 程序的组合性和动态管理能力。",
      "similarity": 0.680908203125,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 1,
          "end_line": 6,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Copyright (c) 2023 Isovalent */",
            "",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_mprog.h>",
            ""
          ],
          "function_name": null,
          "description": "声明GPL许可证并包含BPF相关头文件，为后续多程序模块实现提供基础",
          "similarity": 0.6513709425926208
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 297,
          "end_line": 450,
          "content": [
            "static int bpf_mprog_fetch(struct bpf_mprog_entry *entry,",
            "\t\t\t   struct bpf_tuple *tuple, int idx)",
            "{",
            "\tint total = bpf_mprog_total(entry);",
            "\tstruct bpf_mprog_cp *cp;",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_prog *prog;",
            "\tstruct bpf_link *link;",
            "",
            "\tif (idx == -1)",
            "\t\tidx = 0;",
            "\telse if (idx == total)",
            "\t\tidx = total - 1;",
            "\tbpf_mprog_read(entry, idx, &fp, &cp);",
            "\tprog = READ_ONCE(fp->prog);",
            "\tlink = cp->link;",
            "\t/* The deletion request can either be without filled tuple in which",
            "\t * case it gets populated here based on idx, or with filled tuple",
            "\t * where the only thing we end up doing is the WARN_ON_ONCE() assert.",
            "\t * If we hit a BPF link at the given index, it must not be removed",
            "\t * from opts path.",
            "\t */",
            "\tif (link && !tuple->link)",
            "\t\treturn -EBUSY;",
            "\tWARN_ON_ONCE(tuple->prog && tuple->prog != prog);",
            "\tWARN_ON_ONCE(tuple->link && tuple->link != link);",
            "\ttuple->prog = prog;",
            "\ttuple->link = link;",
            "\treturn 0;",
            "}",
            "int bpf_mprog_detach(struct bpf_mprog_entry *entry,",
            "\t\t     struct bpf_mprog_entry **entry_new,",
            "\t\t     struct bpf_prog *prog, struct bpf_link *link,",
            "\t\t     u32 flags, u32 id_or_fd, u64 revision)",
            "{",
            "\tstruct bpf_tuple rtuple, dtuple = {",
            "\t\t.prog = prog,",
            "\t\t.link = link,",
            "\t};",
            "\tint ret, idx = -ERANGE, tidx;",
            "",
            "\tif (flags & BPF_F_REPLACE)",
            "\t\treturn -EINVAL;",
            "\tif (revision && revision != bpf_mprog_revision(entry))",
            "\t\treturn -ESTALE;",
            "\tif (!bpf_mprog_total(entry))",
            "\t\treturn -ENOENT;",
            "\tret = bpf_mprog_tuple_relative(&rtuple, id_or_fd, flags,",
            "\t\t\t\t       prog ? prog->type :",
            "\t\t\t\t       BPF_PROG_TYPE_UNSPEC);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tif (dtuple.prog) {",
            "\t\ttidx = bpf_mprog_pos_exact(entry, &dtuple);",
            "\t\tif (tidx < 0) {",
            "\t\t\tret = tidx;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (flags & BPF_F_BEFORE) {",
            "\t\ttidx = bpf_mprog_pos_before(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < -1 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (flags & BPF_F_AFTER) {",
            "\t\ttidx = bpf_mprog_pos_after(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < 0 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (idx < -1) {",
            "\t\tif (rtuple.prog || flags) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = bpf_mprog_total(entry);",
            "\t\tflags = BPF_F_AFTER;",
            "\t}",
            "\tif (idx >= bpf_mprog_max()) {",
            "\t\tret = -ERANGE;",
            "\t\tgoto out;",
            "\t}",
            "\tret = bpf_mprog_fetch(entry, &dtuple, idx);",
            "\tif (ret)",
            "\t\tgoto out;",
            "\tret = bpf_mprog_delete(entry, entry_new, &dtuple, idx);",
            "out:",
            "\tbpf_mprog_tuple_put(&rtuple);",
            "\treturn ret;",
            "}",
            "int bpf_mprog_query(const union bpf_attr *attr, union bpf_attr __user *uattr,",
            "\t\t    struct bpf_mprog_entry *entry)",
            "{",
            "\tu32 __user *uprog_flags, *ulink_flags;",
            "\tu32 __user *uprog_id, *ulink_id;",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tstruct bpf_prog *prog;",
            "\tconst u32 flags = 0;",
            "\tu32 id, count = 0;",
            "\tu64 revision = 1;",
            "\tint i, ret = 0;",
            "",
            "\tif (attr->query.query_flags || attr->query.attach_flags)",
            "\t\treturn -EINVAL;",
            "\tif (entry) {",
            "\t\trevision = bpf_mprog_revision(entry);",
            "\t\tcount = bpf_mprog_total(entry);",
            "\t}",
            "\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))",
            "\t\treturn -EFAULT;",
            "\tif (copy_to_user(&uattr->query.revision, &revision, sizeof(revision)))",
            "\t\treturn -EFAULT;",
            "\tif (copy_to_user(&uattr->query.count, &count, sizeof(count)))",
            "\t\treturn -EFAULT;",
            "\tuprog_id = u64_to_user_ptr(attr->query.prog_ids);",
            "\tuprog_flags = u64_to_user_ptr(attr->query.prog_attach_flags);",
            "\tulink_id = u64_to_user_ptr(attr->query.link_ids);",
            "\tulink_flags = u64_to_user_ptr(attr->query.link_attach_flags);",
            "\tif (attr->query.count == 0 || !uprog_id || !count)",
            "\t\treturn 0;",
            "\tif (attr->query.count < count) {",
            "\t\tcount = attr->query.count;",
            "\t\tret = -ENOSPC;",
            "\t}",
            "\tfor (i = 0; i < bpf_mprog_max(); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tprog = READ_ONCE(fp->prog);",
            "\t\tif (!prog)",
            "\t\t\tbreak;",
            "\t\tid = prog->aux->id;",
            "\t\tif (copy_to_user(uprog_id + i, &id, sizeof(id)))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (uprog_flags &&",
            "\t\t    copy_to_user(uprog_flags + i, &flags, sizeof(flags)))",
            "\t\t\treturn -EFAULT;",
            "\t\tid = cp->link ? cp->link->id : 0;",
            "\t\tif (ulink_id &&",
            "\t\t    copy_to_user(ulink_id + i, &id, sizeof(id)))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (ulink_flags &&",
            "\t\t    copy_to_user(ulink_flags + i, &flags, sizeof(flags)))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (i + 1 == count)",
            "\t\t\tbreak;",
            "\t}",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpf_mprog_fetch, bpf_mprog_detach, bpf_mprog_query",
          "description": "实现多程序条目查询接口，支持根据索引获取运行时状态、执行删除操作，并向用户空间导出程序ID和链接ID等元信息",
          "similarity": 0.47387802600860596
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 151,
          "end_line": 284,
          "content": [
            "static int bpf_mprog_delete(struct bpf_mprog_entry *entry,",
            "\t\t\t    struct bpf_mprog_entry **entry_new,",
            "\t\t\t    struct bpf_tuple *dtuple, int idx)",
            "{",
            "\tint total = bpf_mprog_total(entry);",
            "\tstruct bpf_mprog_entry *peer;",
            "",
            "\tpeer = bpf_mprog_peer(entry);",
            "\tbpf_mprog_entry_copy(peer, entry);",
            "\tif (idx == -1)",
            "\t\tidx = 0;",
            "\telse if (idx == total)",
            "\t\tidx = total - 1;",
            "\tbpf_mprog_entry_shrink(peer, idx);",
            "\tbpf_mprog_dec(peer);",
            "\tbpf_mprog_mark_for_release(peer, dtuple);",
            "\t*entry_new = peer;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_pos_exact(struct bpf_mprog_entry *entry,",
            "\t\t\t       struct bpf_tuple *tuple)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < bpf_mprog_total(entry); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tif (tuple->prog == READ_ONCE(fp->prog))",
            "\t\t\treturn tuple->link == cp->link ? i : -EBUSY;",
            "\t}",
            "\treturn -ENOENT;",
            "}",
            "static int bpf_mprog_pos_before(struct bpf_mprog_entry *entry,",
            "\t\t\t\tstruct bpf_tuple *tuple)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < bpf_mprog_total(entry); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tif (tuple->prog == READ_ONCE(fp->prog) &&",
            "\t\t    (!tuple->link || tuple->link == cp->link))",
            "\t\t\treturn i - 1;",
            "\t}",
            "\treturn tuple->prog ? -ENOENT : -1;",
            "}",
            "static int bpf_mprog_pos_after(struct bpf_mprog_entry *entry,",
            "\t\t\t       struct bpf_tuple *tuple)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < bpf_mprog_total(entry); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tif (tuple->prog == READ_ONCE(fp->prog) &&",
            "\t\t    (!tuple->link || tuple->link == cp->link))",
            "\t\t\treturn i + 1;",
            "\t}",
            "\treturn tuple->prog ? -ENOENT : bpf_mprog_total(entry);",
            "}",
            "int bpf_mprog_attach(struct bpf_mprog_entry *entry,",
            "\t\t     struct bpf_mprog_entry **entry_new,",
            "\t\t     struct bpf_prog *prog_new, struct bpf_link *link,",
            "\t\t     struct bpf_prog *prog_old,",
            "\t\t     u32 flags, u32 id_or_fd, u64 revision)",
            "{",
            "\tstruct bpf_tuple rtuple, ntuple = {",
            "\t\t.prog = prog_new,",
            "\t\t.link = link,",
            "\t}, otuple = {",
            "\t\t.prog = prog_old,",
            "\t\t.link = link,",
            "\t};",
            "\tint ret, idx = -ERANGE, tidx;",
            "",
            "\tif (revision && revision != bpf_mprog_revision(entry))",
            "\t\treturn -ESTALE;",
            "\tif (bpf_mprog_exists(entry, prog_new))",
            "\t\treturn -EEXIST;",
            "\tret = bpf_mprog_tuple_relative(&rtuple, id_or_fd,",
            "\t\t\t\t       flags & ~BPF_F_REPLACE,",
            "\t\t\t\t       prog_new->type);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tif (flags & BPF_F_REPLACE) {",
            "\t\ttidx = bpf_mprog_pos_exact(entry, &otuple);",
            "\t\tif (tidx < 0) {",
            "\t\t\tret = tidx;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t} else if (bpf_mprog_total(entry) == bpf_mprog_max()) {",
            "\t\tret = -ERANGE;",
            "\t\tgoto out;",
            "\t}",
            "\tif (flags & BPF_F_BEFORE) {",
            "\t\ttidx = bpf_mprog_pos_before(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < -1 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (flags & BPF_F_AFTER) {",
            "\t\ttidx = bpf_mprog_pos_after(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < 0 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (idx < -1) {",
            "\t\tif (rtuple.prog || flags) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = bpf_mprog_total(entry);",
            "\t\tflags = BPF_F_AFTER;",
            "\t}",
            "\tif (idx >= bpf_mprog_max()) {",
            "\t\tret = -ERANGE;",
            "\t\tgoto out;",
            "\t}",
            "\tif (flags & BPF_F_REPLACE)",
            "\t\tret = bpf_mprog_replace(entry, entry_new, &ntuple, idx);",
            "\telse",
            "\t\tret = bpf_mprog_insert(entry, entry_new, &ntuple, idx, flags);",
            "out:",
            "\tbpf_mprog_tuple_put(&rtuple);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpf_mprog_delete, bpf_mprog_pos_exact, bpf_mprog_pos_before, bpf_mprog_pos_after, bpf_mprog_attach",
          "description": "实现多程序条目删除、精确匹配位置查找、前后位置确定等功能，支持基于程序和链接的条件匹配与索引计算",
          "similarity": 0.4640074074268341
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 7,
          "end_line": 116,
          "content": [
            "static int bpf_mprog_link(struct bpf_tuple *tuple,",
            "\t\t\t  u32 id_or_fd, u32 flags,",
            "\t\t\t  enum bpf_prog_type type)",
            "{",
            "\tstruct bpf_link *link = ERR_PTR(-EINVAL);",
            "\tbool id = flags & BPF_F_ID;",
            "",
            "\tif (id)",
            "\t\tlink = bpf_link_by_id(id_or_fd);",
            "\telse if (id_or_fd)",
            "\t\tlink = bpf_link_get_from_fd(id_or_fd);",
            "\tif (IS_ERR(link))",
            "\t\treturn PTR_ERR(link);",
            "\tif (type && link->prog->type != type) {",
            "\t\tbpf_link_put(link);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttuple->link = link;",
            "\ttuple->prog = link->prog;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_prog(struct bpf_tuple *tuple,",
            "\t\t\t  u32 id_or_fd, u32 flags,",
            "\t\t\t  enum bpf_prog_type type)",
            "{",
            "\tstruct bpf_prog *prog = ERR_PTR(-EINVAL);",
            "\tbool id = flags & BPF_F_ID;",
            "",
            "\tif (id)",
            "\t\tprog = bpf_prog_by_id(id_or_fd);",
            "\telse if (id_or_fd)",
            "\t\tprog = bpf_prog_get(id_or_fd);",
            "\tif (IS_ERR(prog))",
            "\t\treturn PTR_ERR(prog);",
            "\tif (type && prog->type != type) {",
            "\t\tbpf_prog_put(prog);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttuple->link = NULL;",
            "\ttuple->prog = prog;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_tuple_relative(struct bpf_tuple *tuple,",
            "\t\t\t\t    u32 id_or_fd, u32 flags,",
            "\t\t\t\t    enum bpf_prog_type type)",
            "{",
            "\tbool link = flags & BPF_F_LINK;",
            "\tbool id = flags & BPF_F_ID;",
            "",
            "\tmemset(tuple, 0, sizeof(*tuple));",
            "\tif (link)",
            "\t\treturn bpf_mprog_link(tuple, id_or_fd, flags, type);",
            "\t/* If no relevant flag is set and no id_or_fd was passed, then",
            "\t * tuple link/prog is just NULLed. This is the case when before/",
            "\t * after selects first/last position without passing fd.",
            "\t */",
            "\tif (!id && !id_or_fd)",
            "\t\treturn 0;",
            "\treturn bpf_mprog_prog(tuple, id_or_fd, flags, type);",
            "}",
            "static void bpf_mprog_tuple_put(struct bpf_tuple *tuple)",
            "{",
            "\tif (tuple->link)",
            "\t\tbpf_link_put(tuple->link);",
            "\telse if (tuple->prog)",
            "\t\tbpf_prog_put(tuple->prog);",
            "}",
            "static int bpf_mprog_replace(struct bpf_mprog_entry *entry,",
            "\t\t\t     struct bpf_mprog_entry **entry_new,",
            "\t\t\t     struct bpf_tuple *ntuple, int idx)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tstruct bpf_prog *oprog;",
            "",
            "\tbpf_mprog_read(entry, idx, &fp, &cp);",
            "\toprog = READ_ONCE(fp->prog);",
            "\tbpf_mprog_write(fp, cp, ntuple);",
            "\tif (!ntuple->link) {",
            "\t\tWARN_ON_ONCE(cp->link);",
            "\t\tbpf_prog_put(oprog);",
            "\t}",
            "\t*entry_new = entry;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_insert(struct bpf_mprog_entry *entry,",
            "\t\t\t    struct bpf_mprog_entry **entry_new,",
            "\t\t\t    struct bpf_tuple *ntuple, int idx, u32 flags)",
            "{",
            "\tint total = bpf_mprog_total(entry);",
            "\tstruct bpf_mprog_entry *peer;",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "",
            "\tpeer = bpf_mprog_peer(entry);",
            "\tbpf_mprog_entry_copy(peer, entry);",
            "\tif (idx == total)",
            "\t\tgoto insert;",
            "\telse if (flags & BPF_F_BEFORE)",
            "\t\tidx += 1;",
            "\tbpf_mprog_entry_grow(peer, idx);",
            "insert:",
            "\tbpf_mprog_read(peer, idx, &fp, &cp);",
            "\tbpf_mprog_write(fp, cp, ntuple);",
            "\tbpf_mprog_inc(peer);",
            "\t*entry_new = peer;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_mprog_link, bpf_mprog_prog, bpf_mprog_tuple_relative, bpf_mprog_tuple_put, bpf_mprog_replace, bpf_mprog_insert",
          "description": "实现多程序链接与程序绑定逻辑，通过不同标志位选择性设置tuple中的link或prog字段，进行类型校验和引用计数管理",
          "similarity": 0.45018529891967773
        }
      ]
    }
  ]
}