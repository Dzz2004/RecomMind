{
  "query": "cgroup资源限制对性能的影响",
  "timestamp": "2025-12-26 01:39:23",
  "retrieved_files": [
    {
      "source_file": "kernel/cgroup/misc.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:48:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\misc.c`\n\n---\n\n# cgroup/misc.c 技术文档\n\n## 文件概述\n\n`cgroup/misc.c` 实现了一个通用的 **miscellaneous cgroup controller（杂项资源控制组控制器）**，用于对系统中非传统类型的资源（如 AMD SEV/SEV-ES ASID 等安全加密虚拟化资源）进行配额管理和使用量跟踪。该控制器采用 **Limits 资源分配模型**，允许为每个 cgroup 设置资源使用上限（max），并确保整个系统的总使用量不超过主机实际容量（capacity）。该模块支持资源的尝试性计费（try-charge）、取消计费（uncharge）、容量设置、使用量查询及事件通知等功能。\n\n## 核心功能\n\n### 主要数据结构\n\n- `struct misc_cg`：表示一个 misc cgroup 实例，包含每种资源类型的 `struct misc_res`。\n- `struct misc_res`（定义在 `<linux/misc_cgroup.h>`）：\n  - `usage`：当前资源使用量（`atomic64_t`）\n  - `max`：该 cgroup 的资源使用上限（`u64`）\n  - `watermark`：历史峰值使用量（`atomic64_t`）\n  - `events` / `events_local`：事件计数器（用于通知）\n- `misc_res_capacity[MISC_CG_RES_TYPES]`：全局数组，记录每种资源在整机上的实际容量。\n- `root_cg`：根 misc cgroup 实例。\n- `misc_res_name[]`：资源类型的字符串名称映射（与 `enum misc_res_type` 同步）。\n\n### 主要导出函数（API）\n\n- `misc_cg_set_capacity(enum misc_res_type type, u64 capacity)`  \n  设置指定资源类型的整机容量。容量为 0 表示该资源不可用。\n- `misc_cg_try_charge(enum misc_res_type type, struct misc_cg *cg, u64 amount)`  \n  尝试对指定 cgroup 计费指定资源量。若超过该 cgroup 的 `max` 限制或整机 `capacity`，则失败并回滚。\n- `misc_cg_uncharge(enum misc_res_type type, struct misc_cg *cg, u64 amount)`  \n  从指定 cgroup 取消指定资源量的计费。\n- `misc_cg_res_total_usage(enum misc_res_type type)`  \n  获取指定资源类型的全局总使用量（即根 cgroup 的 usage）。\n\n### 主要内部函数\n\n- `parent_misc()`：获取 misc cgroup 的父节点。\n- `valid_type()`：验证资源类型是否有效。\n- `misc_cg_cancel_charge()`：原子地减少资源使用量，并检查负值（使用 `WARN_ONCE`）。\n- `misc_cg_update_watermark()`：原子地更新资源使用峰值（watermark）。\n- `misc_cg_event()`：触发资源事件通知（本地及向上传播到祖先）。\n- `misc_cg_max_show/write`：实现 `misc.max` 接口文件的读写。\n- `misc_cg_current_show`：实现 `misc.current` 接口文件的读取。\n- `misc_cg_peak_show`：实现 `misc.peak` 接口文件的读取（代码未完整显示，但可推断）。\n\n## 关键实现\n\n### 资源计费与回滚机制\n- **计费流程**：从目标 cgroup 向上遍历至根 cgroup，依次原子增加各层级的 `usage`。\n- **限制检查**：每层检查 `new_usage <= res->max` 且 `new_usage <= misc_res_capacity[type]`。\n- **失败回滚**：若任一层检查失败，立即触发事件通知，并从目标 cgroup 到失败层（含）逐层原子减少已增加的 `usage`，保证状态一致性。\n\n### 原子操作与并发安全\n- 所有资源使用量（`usage`）、峰值（`watermark`）和事件计数均使用 `atomic64_t` 类型，确保多线程/多 CPU 环境下的安全访问。\n- 容量（`misc_res_capacity`）和上限（`max`）使用 `READ_ONCE`/`WRITE_ONCE` 进行访问，避免编译器优化导致的不一致。\n\n### 接口文件实现\n- **`misc.max`**：\n  - **读**：输出每种已启用资源（`capacity > 0`）的 `max` 值；若为 `U64_MAX` 则显示为 `\"max\"`。\n  - **写**：格式为 `\"<resource_name> <value>\"`，`value` 可为正整数或 `\"max\"`（表示无限制）。\n- **`misc.current`**：输出每种资源（只要 `capacity > 0` 或 `usage > 0`）的当前使用量。\n- **`misc.peak`**（推断）：输出每种资源的历史峰值使用量（`watermark`）。\n\n### 事件通知\n- 当计费失败时，调用 `misc_cg_event()`：\n  - 增加当前 cgroup 的本地事件计数器（`events_local`）并通知 `events_local_file`。\n  - 向上遍历所有祖先 cgroup，增加其全局事件计数器（`events`）并通知 `events_file`。\n\n## 依赖关系\n\n- **内核头文件**：\n  - `<linux/cgroup.h>`：cgroup 核心框架。\n  - `<linux/misc_cgroup.h>`：定义 `struct misc_cg`、`struct misc_res`、`enum misc_res_type` 等关键数据结构和类型。\n  - `<linux/atomic.h>`：提供原子操作。\n  - `<linux/slab.h>`：内存分配。\n- **配置选项**：\n  - `CONFIG_KVM_AMD_SEV`：决定是否启用 `\"sev\"` 和 `\"sev_es\"` 资源类型。\n- **其他模块**：\n  - **KVM 模块**：在启用 AMD SEV/SEV-ES 时，会调用本模块的 API（如 `misc_cg_try_charge`/`misc_cg_uncharge`）来管理 ASID 资源。\n  - **cgroup 核心**：通过 `css_misc()`、`cgroup_file_notify()` 等接口与 cgroup 子系统集成。\n\n## 使用场景\n\n1. **AMD SEV/SEV-ES 资源管理**：\n   - 在支持 AMD 安全加密虚拟化（SEV/SEV-ES）的系统中，ASID（Address Space Identifier）是一种有限的硬件资源。\n   - KVM 模块在创建/销毁 SEV 虚拟机时，通过 `misc_cg_try_charge`/`misc_cg_uncharge` 对当前进程所属的 misc cgroup 进行 ASID 资源计费。\n   - 管理员可通过 `misc.max` 文件为不同 cgroup 设置 ASID 使用上限，防止单个用户或服务耗尽全局 ASID 资源。\n\n2. **通用杂项资源控制框架**：\n   - 该控制器设计为可扩展，未来可支持其他类型的有限系统资源（如特定硬件加速器的上下文、特殊内存区域等）。\n   - 通过 `misc_cg_set_capacity` 在系统初始化时注册资源容量，通过标准 cgroup 接口进行配额分配和监控。\n\n3. **资源监控与告警**：\n   - 用户空间可通过读取 `misc.current` 和 `misc.peak` 监控资源使用情况。\n   - 当资源分配失败（如达到 `max` 限制）时，内核会更新事件计数器，用户空间可通过 `inotify` 或轮询 `misc.events` 文件获取通知，实现自动化告警或扩缩容。",
      "similarity": 0.6105991005897522,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/cgroup/misc.c",
          "start_line": 401,
          "end_line": 408,
          "content": [
            "static int misc_events_local_show(struct seq_file *sf, void *v)",
            "{",
            "\treturn __misc_events_show(sf, true);",
            "}",
            "static void misc_cg_free(struct cgroup_subsys_state *css)",
            "{",
            "\tkfree(css_misc(css));",
            "}"
          ],
          "function_name": "misc_events_local_show, misc_cg_free",
          "description": "实现本地事件统计展示接口和cgroup子系统状态释放函数，用于清理misc控制器相关内存资源",
          "similarity": 0.5697457790374756
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/cgroup/misc.c",
          "start_line": 1,
          "end_line": 64,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Miscellaneous cgroup controller",
            " *",
            " * Copyright 2020 Google LLC",
            " * Author: Vipin Sharma <vipinsh@google.com>",
            " */",
            "",
            "#include <linux/limits.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/errno.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/misc_cgroup.h>",
            "",
            "#define MAX_STR \"max\"",
            "#define MAX_NUM U64_MAX",
            "",
            "/* Miscellaneous res name, keep it in sync with enum misc_res_type */",
            "static const char *const misc_res_name[] = {",
            "#ifdef CONFIG_KVM_AMD_SEV",
            "\t/* AMD SEV ASIDs resource */",
            "\t\"sev\",",
            "\t/* AMD SEV-ES ASIDs resource */",
            "\t\"sev_es\",",
            "#endif",
            "};",
            "",
            "/* Root misc cgroup */",
            "static struct misc_cg root_cg;",
            "",
            "/*",
            " * Miscellaneous resources capacity for the entire machine. 0 capacity means",
            " * resource is not initialized or not present in the host.",
            " *",
            " * root_cg.max and capacity are independent of each other. root_cg.max can be",
            " * more than the actual capacity. We are using Limits resource distribution",
            " * model of cgroup for miscellaneous controller.",
            " */",
            "static u64 misc_res_capacity[MISC_CG_RES_TYPES];",
            "",
            "/**",
            " * parent_misc() - Get the parent of the passed misc cgroup.",
            " * @cgroup: cgroup whose parent needs to be fetched.",
            " *",
            " * Context: Any context.",
            " * Return:",
            " * * struct misc_cg* - Parent of the @cgroup.",
            " * * %NULL - If @cgroup is null or the passed cgroup does not have a parent.",
            " */",
            "static struct misc_cg *parent_misc(struct misc_cg *cgroup)",
            "{",
            "\treturn cgroup ? css_misc(cgroup->css.parent) : NULL;",
            "}",
            "",
            "/**",
            " * valid_type() - Check if @type is valid or not.",
            " * @type: misc res type.",
            " *",
            " * Context: Any context.",
            " * Return:",
            " * * true - If valid type.",
            " * * false - If not valid type.",
            " */"
          ],
          "function_name": null,
          "description": "定义misc控制器的资源名称数组和根cgroup结构，提供父节点查询函数，用于管理杂项资源的层级关系和容量配置",
          "similarity": 0.5364682674407959
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/cgroup/misc.c",
          "start_line": 266,
          "end_line": 368,
          "content": [
            "static ssize_t misc_cg_max_write(struct kernfs_open_file *of, char *buf,",
            "\t\t\t\t size_t nbytes, loff_t off)",
            "{",
            "\tstruct misc_cg *cg;",
            "\tu64 max;",
            "\tint ret = 0, i;",
            "\tenum misc_res_type type = MISC_CG_RES_TYPES;",
            "\tchar *token;",
            "",
            "\tbuf = strstrip(buf);",
            "\ttoken = strsep(&buf, \" \");",
            "",
            "\tif (!token || !buf)",
            "\t\treturn -EINVAL;",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tif (!strcmp(misc_res_name[i], token)) {",
            "\t\t\ttype = i;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tif (type == MISC_CG_RES_TYPES)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!strcmp(MAX_STR, buf)) {",
            "\t\tmax = MAX_NUM;",
            "\t} else {",
            "\t\tret = kstrtou64(buf, 0, &max);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\tcg = css_misc(of_css(of));",
            "",
            "\tif (READ_ONCE(misc_res_capacity[type]))",
            "\t\tWRITE_ONCE(cg->res[type].max, max);",
            "\telse",
            "\t\tret = -EINVAL;",
            "",
            "\treturn ret ? ret : nbytes;",
            "}",
            "static int misc_cg_current_show(struct seq_file *sf, void *v)",
            "{",
            "\tint i;",
            "\tu64 usage;",
            "\tstruct misc_cg *cg = css_misc(seq_css(sf));",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tusage = atomic64_read(&cg->res[i].usage);",
            "\t\tif (READ_ONCE(misc_res_capacity[i]) || usage)",
            "\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i], usage);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int misc_cg_peak_show(struct seq_file *sf, void *v)",
            "{",
            "\tint i;",
            "\tu64 watermark;",
            "\tstruct misc_cg *cg = css_misc(seq_css(sf));",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\twatermark = atomic64_read(&cg->res[i].watermark);",
            "\t\tif (READ_ONCE(misc_res_capacity[i]) || watermark)",
            "\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i], watermark);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int misc_cg_capacity_show(struct seq_file *sf, void *v)",
            "{",
            "\tint i;",
            "\tu64 cap;",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tcap = READ_ONCE(misc_res_capacity[i]);",
            "\t\tif (cap)",
            "\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i], cap);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __misc_events_show(struct seq_file *sf, bool local)",
            "{",
            "\tstruct misc_cg *cg = css_misc(seq_css(sf));",
            "\tu64 events;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tif (local)",
            "\t\t\tevents = atomic64_read(&cg->res[i].events_local);",
            "\t\telse",
            "\t\t\tevents = atomic64_read(&cg->res[i].events);",
            "\t\tif (READ_ONCE(misc_res_capacity[i]) || events)",
            "\t\t\tseq_printf(sf, \"%s.max %llu\\n\", misc_res_name[i], events);",
            "\t}",
            "\treturn 0;",
            "}",
            "static int misc_events_show(struct seq_file *sf, void *v)",
            "{",
            "\treturn __misc_events_show(sf, false);",
            "}"
          ],
          "function_name": "misc_cg_max_write, misc_cg_current_show, misc_cg_peak_show, misc_cg_capacity_show, __misc_events_show, misc_events_show",
          "description": "提供资源最大值写入接口和当前使用量、峰值、容量展示接口，支持通过seq_file接口暴露资源统计信息到用户空间",
          "similarity": 0.47682830691337585
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/misc.c",
          "start_line": 65,
          "end_line": 175,
          "content": [
            "static inline bool valid_type(enum misc_res_type type)",
            "{",
            "\treturn type >= 0 && type < MISC_CG_RES_TYPES;",
            "}",
            "u64 misc_cg_res_total_usage(enum misc_res_type type)",
            "{",
            "\tif (valid_type(type))",
            "\t\treturn atomic64_read(&root_cg.res[type].usage);",
            "",
            "\treturn 0;",
            "}",
            "int misc_cg_set_capacity(enum misc_res_type type, u64 capacity)",
            "{",
            "\tif (!valid_type(type))",
            "\t\treturn -EINVAL;",
            "",
            "\tWRITE_ONCE(misc_res_capacity[type], capacity);",
            "\treturn 0;",
            "}",
            "static void misc_cg_cancel_charge(enum misc_res_type type, struct misc_cg *cg,",
            "\t\t\t\t  u64 amount)",
            "{",
            "\tWARN_ONCE(atomic64_add_negative(-amount, &cg->res[type].usage),",
            "\t\t  \"misc cgroup resource %s became less than 0\",",
            "\t\t  misc_res_name[type]);",
            "}",
            "static void misc_cg_update_watermark(struct misc_res *res, u64 new_usage)",
            "{",
            "\tu64 old;",
            "",
            "\twhile (true) {",
            "\t\told = atomic64_read(&res->watermark);",
            "\t\tif (new_usage <= old)",
            "\t\t\tbreak;",
            "\t\tif (atomic64_cmpxchg(&res->watermark, old, new_usage) == old)",
            "\t\t\tbreak;",
            "\t}",
            "}",
            "static void misc_cg_event(enum misc_res_type type, struct misc_cg *cg)",
            "{",
            "\tatomic64_inc(&cg->res[type].events_local);",
            "\tcgroup_file_notify(&cg->events_local_file);",
            "",
            "\tfor (; parent_misc(cg); cg = parent_misc(cg)) {",
            "\t\tatomic64_inc(&cg->res[type].events);",
            "\t\tcgroup_file_notify(&cg->events_file);",
            "\t}",
            "}",
            "int misc_cg_try_charge(enum misc_res_type type, struct misc_cg *cg, u64 amount)",
            "{",
            "\tstruct misc_cg *i, *j;",
            "\tint ret;",
            "\tstruct misc_res *res;",
            "\tu64 new_usage;",
            "",
            "\tif (!(valid_type(type) && cg && READ_ONCE(misc_res_capacity[type])))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!amount)",
            "\t\treturn 0;",
            "",
            "\tfor (i = cg; i; i = parent_misc(i)) {",
            "\t\tres = &i->res[type];",
            "",
            "\t\tnew_usage = atomic64_add_return(amount, &res->usage);",
            "\t\tif (new_usage > READ_ONCE(res->max) ||",
            "\t\t    new_usage > READ_ONCE(misc_res_capacity[type])) {",
            "\t\t\tret = -EBUSY;",
            "\t\t\tgoto err_charge;",
            "\t\t}",
            "\t\tmisc_cg_update_watermark(res, new_usage);",
            "\t}",
            "\treturn 0;",
            "",
            "err_charge:",
            "\tmisc_cg_event(type, i);",
            "",
            "\tfor (j = cg; j != i; j = parent_misc(j))",
            "\t\tmisc_cg_cancel_charge(type, j, amount);",
            "\tmisc_cg_cancel_charge(type, i, amount);",
            "\treturn ret;",
            "}",
            "void misc_cg_uncharge(enum misc_res_type type, struct misc_cg *cg, u64 amount)",
            "{",
            "\tstruct misc_cg *i;",
            "",
            "\tif (!(amount && valid_type(type) && cg))",
            "\t\treturn;",
            "",
            "\tfor (i = cg; i; i = parent_misc(i))",
            "\t\tmisc_cg_cancel_charge(type, i, amount);",
            "}",
            "static int misc_cg_max_show(struct seq_file *sf, void *v)",
            "{",
            "\tint i;",
            "\tstruct misc_cg *cg = css_misc(seq_css(sf));",
            "\tu64 max;",
            "",
            "\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {",
            "\t\tif (READ_ONCE(misc_res_capacity[i])) {",
            "\t\t\tmax = READ_ONCE(cg->res[i].max);",
            "\t\t\tif (max == MAX_NUM)",
            "\t\t\t\tseq_printf(sf, \"%s max\\n\", misc_res_name[i]);",
            "\t\t\telse",
            "\t\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i],",
            "\t\t\t\t\t   max);",
            "\t\t}",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "valid_type, misc_cg_res_total_usage, misc_cg_set_capacity, misc_cg_cancel_charge, misc_cg_update_watermark, misc_cg_event, misc_cg_try_charge, misc_cg_uncharge, misc_cg_max_show",
          "description": "实现资源类型有效性验证、总使用量查询、容量设置、资源充放电控制及水位更新逻辑，支持递归充电检查与事件通知机制",
          "similarity": 0.42526042461395264
        }
      ]
    },
    {
      "source_file": "kernel/cgroup/rdma.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:50:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\rdma.c`\n\n---\n\n# cgroup/rdma.c 技术文档\n\n## 文件概述\n\n`cgroup/rdma.c` 实现了 RDMA（Remote Direct Memory Access）资源限制控制器，作为 cgroup 子系统的一部分。该模块用于限制 cgroup 层级结构中的进程在达到指定资源上限后无法继续消耗额外的 RDMA 资源。通过为每个 cgroup 和每个 RDMA 设备维护资源池，实现对 RDMA 资源（如 HCA 句柄和对象）的精细化配额管理与层级化计费（charge/uncharge）。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`rdmacg_resource`**  \n  表示单个 RDMA 资源类型的使用情况，包含 `max`（最大限额）和 `usage`（当前使用量）。\n\n- **`rdmacg_resource_pool`**  \n  表示一个 cgroup 在特定 RDMA 设备上的资源池，包含：\n  - 指向 `rdmacg_device` 的指针\n  - 各类资源的 `rdmacg_resource` 数组\n  - 双向链表节点（分别链接到 cgroup 和设备的资源池列表）\n  - `usage_sum`：该池中所有资源的总使用计数\n  - `num_max_cnt`：设置为 `S32_MAX`（即无限制）的资源项数量\n\n- **`rdmacg_resource_names`**  \n  用户可见的资源名称映射表，当前支持：\n  - `\"hca_handle\"` → `RDMACG_RESOURCE_HCA_HANDLE`\n  - `\"hca_object\"` → `RDMACG_RESOURCE_HCA_OBJECT`\n\n### 主要函数\n\n- **`rdmacg_try_charge()`**  \n  尝试在 cgroup 层级中为指定 RDMA 设备和资源类型进行资源计费。从当前 cgroup 向上遍历至根，逐级检查并增加使用量。若任一层级超出限额，则回滚并返回 `-EAGAIN`。\n\n- **`rdmacg_uncharge()`**  \n  在 cgroup 层级中释放指定资源的使用量，从当前 cgroup 向上遍历至根，逐级减少使用量。\n\n- **`rdmacg_uncharge_hierarchy()`**  \n  支持在指定停止点（`stop_cg`）前的层级范围内执行资源释放，用于更灵活的资源回收场景。\n\n- **`get_cg_rpool_locked()` / `find_cg_rpool_locked()`**  \n  在加锁状态下查找或创建指定 cgroup 与设备对应的资源池。\n\n- **`free_cg_rpool_locked()`**  \n  当资源池的 `usage_sum` 为 0 且所有资源均设为 `max`（即未显式限制）时，安全释放该资源池。\n\n## 关键实现\n\n### 层级化资源计费机制\n\nRDMA cgroup 采用**自底向上计费、自顶向下限制**的策略：\n- **计费（charge）**：从当前任务所属 cgroup 开始，逐级向上（至根 cgroup）尝试增加资源使用量。任一祖先 cgroup 超限即失败。\n- **释放（uncharge）**：同样沿层级向上释放，确保资源使用量始终反映实际占用。\n\n### 资源池生命周期管理\n\n- 每个 `(cgroup, device)` 对应一个 `rdmacg_resource_pool`。\n- 资源池在首次计费时按需创建（`get_cg_rpool_locked`）。\n- 当 `usage_sum == 0` 且所有资源项均为 `max`（即无显式限制）时，自动释放资源池以节省内存。\n\n### 限额表示\n\n- 使用 `S32_MAX` 表示“无限制”（即 `max` 值）。\n- `num_max_cnt` 用于快速判断是否所有资源均为无限制状态，从而决定是否可安全释放资源池。\n\n### 并发控制\n\n- 全局互斥锁 `rdmacg_mutex` 保护：\n  - 所有 cgroup 的资源池链表（`cg->rpools`）\n  - 所有 RDMA 设备的资源池链表（`device->rpools`）\n  - 全局设备列表 `rdmacg_devices`\n- 所有资源池操作（创建、查找、释放）均在锁保护下进行。\n\n## 依赖关系\n\n- **内核头文件依赖**：\n  - `<linux/cgroup.h>`：cgroup 核心框架\n  - `<linux/cgroup_rdma.h>`：RDMA cgroup 接口定义（如 `rdma_cgroup`、`rdmacg_device` 等）\n  - `<linux/ib_verbs.h>`（隐含）：RDMA 资源类型定义（如 `RDMACG_RESOURCE_HCA_HANDLE`）\n- **导出符号**：\n  - `rdmacg_uncharge()`：供 RDMA 驱动（如 InfiniBand、RoCE 驱动）在释放资源时调用\n- **cgroup 子系统集成**：\n  - 通过 `rdma_cgrp_id` 获取当前任务的 cgroup 上下文\n  - 依赖 cgroup 的层级遍历机制（`css.parent`）\n\n## 使用场景\n\n1. **RDMA 驱动资源分配**  \n   当用户空间应用通过 verbs API 创建 QP、CQ、MR 等对象时，底层驱动调用 `rdmacg_try_charge()` 检查是否允许分配。若成功，则在对象销毁时调用 `rdmacg_uncharge()` 释放配额。\n\n2. **多租户 RDMA 资源隔离**  \n   在容器化或虚拟化环境中，管理员可通过 cgroup v1/v2 接口为不同租户设置 RDMA 资源上限（如最大 HCA 对象数），防止资源耗尽攻击。\n\n3. **动态资源回收**  \n   当 cgroup 中所有任务退出且无 RDMA 资源占用时，自动清理对应的资源池，避免内存泄漏。\n\n4. **层级配额继承**  \n   子 cgroup 的资源使用量计入所有祖先 cgroup，确保父级配额对整个子树生效，实现严格的资源隔离。",
      "similarity": 0.6086151003837585,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/cgroup/rdma.c",
          "start_line": 494,
          "end_line": 562,
          "content": [
            "static void print_rpool_values(struct seq_file *sf,",
            "\t\t\t       struct rdmacg_resource_pool *rpool)",
            "{",
            "\tenum rdmacg_file_type sf_type;",
            "\tint i;",
            "\tu32 value;",
            "",
            "\tsf_type = seq_cft(sf)->private;",
            "",
            "\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++) {",
            "\t\tseq_puts(sf, rdmacg_resource_names[i]);",
            "\t\tseq_putc(sf, '=');",
            "\t\tif (sf_type == RDMACG_RESOURCE_TYPE_MAX) {",
            "\t\t\tif (rpool)",
            "\t\t\t\tvalue = rpool->resources[i].max;",
            "\t\t\telse",
            "\t\t\t\tvalue = S32_MAX;",
            "\t\t} else {",
            "\t\t\tif (rpool)",
            "\t\t\t\tvalue = rpool->resources[i].usage;",
            "\t\t\telse",
            "\t\t\t\tvalue = 0;",
            "\t\t}",
            "",
            "\t\tif (value == S32_MAX)",
            "\t\t\tseq_puts(sf, RDMACG_MAX_STR);",
            "\t\telse",
            "\t\t\tseq_printf(sf, \"%d\", value);",
            "\t\tseq_putc(sf, ' ');",
            "\t}",
            "}",
            "static int rdmacg_resource_read(struct seq_file *sf, void *v)",
            "{",
            "\tstruct rdmacg_device *device;",
            "\tstruct rdmacg_resource_pool *rpool;",
            "\tstruct rdma_cgroup *cg = css_rdmacg(seq_css(sf));",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "",
            "\tlist_for_each_entry(device, &rdmacg_devices, dev_node) {",
            "\t\tseq_printf(sf, \"%s \", device->name);",
            "",
            "\t\trpool = find_cg_rpool_locked(cg, device);",
            "\t\tprint_rpool_values(sf, rpool);",
            "",
            "\t\tseq_putc(sf, '\\n');",
            "\t}",
            "",
            "\tmutex_unlock(&rdmacg_mutex);",
            "\treturn 0;",
            "}",
            "static void rdmacg_css_free(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct rdma_cgroup *cg = css_rdmacg(css);",
            "",
            "\tkfree(cg);",
            "}",
            "static void rdmacg_css_offline(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct rdma_cgroup *cg = css_rdmacg(css);",
            "\tstruct rdmacg_resource_pool *rpool;",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "",
            "\tlist_for_each_entry(rpool, &cg->rpools, cg_node)",
            "\t\tset_all_resource_max_limit(rpool);",
            "",
            "\tmutex_unlock(&rdmacg_mutex);",
            "}"
          ],
          "function_name": "print_rpool_values, rdmacg_resource_read, rdmacg_css_free, rdmacg_css_offline",
          "description": "实现资源状态序列化输出、CSS销毁时资源强制设为最大及子系统离线处理，包含资源使用量打印函数和cgroup子系统状态清理逻辑。",
          "similarity": 0.5931914448738098
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/cgroup/rdma.c",
          "start_line": 316,
          "end_line": 464,
          "content": [
            "void rdmacg_register_device(struct rdmacg_device *device)",
            "{",
            "\tINIT_LIST_HEAD(&device->dev_node);",
            "\tINIT_LIST_HEAD(&device->rpools);",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "\tlist_add_tail(&device->dev_node, &rdmacg_devices);",
            "\tmutex_unlock(&rdmacg_mutex);",
            "}",
            "void rdmacg_unregister_device(struct rdmacg_device *device)",
            "{",
            "\tstruct rdmacg_resource_pool *rpool, *tmp;",
            "",
            "\t/*",
            "\t * Synchronize with any active resource settings,",
            "\t * usage query happening via configfs.",
            "\t */",
            "\tmutex_lock(&rdmacg_mutex);",
            "\tlist_del_init(&device->dev_node);",
            "",
            "\t/*",
            "\t * Now that this device is off the cgroup list, its safe to free",
            "\t * all the rpool resources.",
            "\t */",
            "\tlist_for_each_entry_safe(rpool, tmp, &device->rpools, dev_node)",
            "\t\tfree_cg_rpool_locked(rpool);",
            "",
            "\tmutex_unlock(&rdmacg_mutex);",
            "}",
            "static int parse_resource(char *c, int *intval)",
            "{",
            "\tsubstring_t argstr;",
            "\tchar *name, *value = c;",
            "\tsize_t len;",
            "\tint ret, i;",
            "",
            "\tname = strsep(&value, \"=\");",
            "\tif (!name || !value)",
            "\t\treturn -EINVAL;",
            "",
            "\ti = match_string(rdmacg_resource_names, RDMACG_RESOURCE_MAX, name);",
            "\tif (i < 0)",
            "\t\treturn i;",
            "",
            "\tlen = strlen(value);",
            "",
            "\targstr.from = value;",
            "\targstr.to = value + len;",
            "",
            "\tret = match_int(&argstr, intval);",
            "\tif (ret >= 0) {",
            "\t\tif (*intval < 0)",
            "\t\t\treturn -EINVAL;",
            "\t\treturn i;",
            "\t}",
            "\tif (strncmp(value, RDMACG_MAX_STR, len) == 0) {",
            "\t\t*intval = S32_MAX;",
            "\t\treturn i;",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "static int rdmacg_parse_limits(char *options,",
            "\t\t\t       int *new_limits, unsigned long *enables)",
            "{",
            "\tchar *c;",
            "\tint err = -EINVAL;",
            "",
            "\t/* parse resource options */",
            "\twhile ((c = strsep(&options, \" \")) != NULL) {",
            "\t\tint index, intval;",
            "",
            "\t\tindex = parse_resource(c, &intval);",
            "\t\tif (index < 0)",
            "\t\t\tgoto err;",
            "",
            "\t\tnew_limits[index] = intval;",
            "\t\t*enables |= BIT(index);",
            "\t}",
            "\treturn 0;",
            "",
            "err:",
            "\treturn err;",
            "}",
            "static ssize_t rdmacg_resource_set_max(struct kernfs_open_file *of,",
            "\t\t\t\t       char *buf, size_t nbytes, loff_t off)",
            "{",
            "\tstruct rdma_cgroup *cg = css_rdmacg(of_css(of));",
            "\tconst char *dev_name;",
            "\tstruct rdmacg_resource_pool *rpool;",
            "\tstruct rdmacg_device *device;",
            "\tchar *options = strstrip(buf);",
            "\tint *new_limits;",
            "\tunsigned long enables = 0;",
            "\tint i = 0, ret = 0;",
            "",
            "\t/* extract the device name first */",
            "\tdev_name = strsep(&options, \" \");",
            "\tif (!dev_name) {",
            "\t\tret = -EINVAL;",
            "\t\tgoto err;",
            "\t}",
            "",
            "\tnew_limits = kcalloc(RDMACG_RESOURCE_MAX, sizeof(int), GFP_KERNEL);",
            "\tif (!new_limits) {",
            "\t\tret = -ENOMEM;",
            "\t\tgoto err;",
            "\t}",
            "",
            "\tret = rdmacg_parse_limits(options, new_limits, &enables);",
            "\tif (ret)",
            "\t\tgoto parse_err;",
            "",
            "\t/* acquire lock to synchronize with hot plug devices */",
            "\tmutex_lock(&rdmacg_mutex);",
            "",
            "\tdevice = rdmacg_get_device_locked(dev_name);",
            "\tif (!device) {",
            "\t\tret = -ENODEV;",
            "\t\tgoto dev_err;",
            "\t}",
            "",
            "\trpool = get_cg_rpool_locked(cg, device);",
            "\tif (IS_ERR(rpool)) {",
            "\t\tret = PTR_ERR(rpool);",
            "\t\tgoto dev_err;",
            "\t}",
            "",
            "\t/* now set the new limits of the rpool */",
            "\tfor_each_set_bit(i, &enables, RDMACG_RESOURCE_MAX)",
            "\t\tset_resource_limit(rpool, i, new_limits[i]);",
            "",
            "\tif (rpool->usage_sum == 0 &&",
            "\t    rpool->num_max_cnt == RDMACG_RESOURCE_MAX) {",
            "\t\t/*",
            "\t\t * No user of the rpool and all entries are set to max, so",
            "\t\t * safe to delete this rpool.",
            "\t\t */",
            "\t\tfree_cg_rpool_locked(rpool);",
            "\t}",
            "",
            "dev_err:",
            "\tmutex_unlock(&rdmacg_mutex);",
            "",
            "parse_err:",
            "\tkfree(new_limits);",
            "",
            "err:",
            "\treturn ret ?: nbytes;",
            "}"
          ],
          "function_name": "rdmacg_register_device, rdmacg_unregister_device, parse_resource, rdmacg_parse_limits, rdmacg_resource_set_max",
          "description": "实现设备注册注销流程、资源参数解析及限制设置功能，通过parse_resource解析资源名与数值，rdmacg_parse_limits组织限制定义，rdmacg_resource_set_max应用新限制并触发资源池清理。",
          "similarity": 0.524526834487915
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/rdma.c",
          "start_line": 82,
          "end_line": 214,
          "content": [
            "static void set_resource_limit(struct rdmacg_resource_pool *rpool,",
            "\t\t\t       int index, int new_max)",
            "{",
            "\tif (new_max == S32_MAX) {",
            "\t\tif (rpool->resources[index].max != S32_MAX)",
            "\t\t\trpool->num_max_cnt++;",
            "\t} else {",
            "\t\tif (rpool->resources[index].max == S32_MAX)",
            "\t\t\trpool->num_max_cnt--;",
            "\t}",
            "\trpool->resources[index].max = new_max;",
            "}",
            "static void set_all_resource_max_limit(struct rdmacg_resource_pool *rpool)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++)",
            "\t\tset_resource_limit(rpool, i, S32_MAX);",
            "}",
            "static void free_cg_rpool_locked(struct rdmacg_resource_pool *rpool)",
            "{",
            "\tlockdep_assert_held(&rdmacg_mutex);",
            "",
            "\tlist_del(&rpool->cg_node);",
            "\tlist_del(&rpool->dev_node);",
            "\tkfree(rpool);",
            "}",
            "static void",
            "uncharge_cg_locked(struct rdma_cgroup *cg,",
            "\t\t   struct rdmacg_device *device,",
            "\t\t   enum rdmacg_resource_type index)",
            "{",
            "\tstruct rdmacg_resource_pool *rpool;",
            "",
            "\trpool = find_cg_rpool_locked(cg, device);",
            "",
            "\t/*",
            "\t * rpool cannot be null at this stage. Let kernel operate in case",
            "\t * if there a bug in IB stack or rdma controller, instead of crashing",
            "\t * the system.",
            "\t */",
            "\tif (unlikely(!rpool)) {",
            "\t\tpr_warn(\"Invalid device %p or rdma cgroup %p\\n\", cg, device);",
            "\t\treturn;",
            "\t}",
            "",
            "\trpool->resources[index].usage--;",
            "",
            "\t/*",
            "\t * A negative count (or overflow) is invalid,",
            "\t * it indicates a bug in the rdma controller.",
            "\t */",
            "\tWARN_ON_ONCE(rpool->resources[index].usage < 0);",
            "\trpool->usage_sum--;",
            "\tif (rpool->usage_sum == 0 &&",
            "\t    rpool->num_max_cnt == RDMACG_RESOURCE_MAX) {",
            "\t\t/*",
            "\t\t * No user of the rpool and all entries are set to max, so",
            "\t\t * safe to delete this rpool.",
            "\t\t */",
            "\t\tfree_cg_rpool_locked(rpool);",
            "\t}",
            "}",
            "static void rdmacg_uncharge_hierarchy(struct rdma_cgroup *cg,",
            "\t\t\t\t     struct rdmacg_device *device,",
            "\t\t\t\t     struct rdma_cgroup *stop_cg,",
            "\t\t\t\t     enum rdmacg_resource_type index)",
            "{",
            "\tstruct rdma_cgroup *p;",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "",
            "\tfor (p = cg; p != stop_cg; p = parent_rdmacg(p))",
            "\t\tuncharge_cg_locked(p, device, index);",
            "",
            "\tmutex_unlock(&rdmacg_mutex);",
            "",
            "\tcss_put(&cg->css);",
            "}",
            "void rdmacg_uncharge(struct rdma_cgroup *cg,",
            "\t\t     struct rdmacg_device *device,",
            "\t\t     enum rdmacg_resource_type index)",
            "{",
            "\tif (index >= RDMACG_RESOURCE_MAX)",
            "\t\treturn;",
            "",
            "\trdmacg_uncharge_hierarchy(cg, device, NULL, index);",
            "}",
            "int rdmacg_try_charge(struct rdma_cgroup **rdmacg,",
            "\t\t      struct rdmacg_device *device,",
            "\t\t      enum rdmacg_resource_type index)",
            "{",
            "\tstruct rdma_cgroup *cg, *p;",
            "\tstruct rdmacg_resource_pool *rpool;",
            "\ts64 new;",
            "\tint ret = 0;",
            "",
            "\tif (index >= RDMACG_RESOURCE_MAX)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * hold on to css, as cgroup can be removed but resource",
            "\t * accounting happens on css.",
            "\t */",
            "\tcg = get_current_rdmacg();",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "\tfor (p = cg; p; p = parent_rdmacg(p)) {",
            "\t\trpool = get_cg_rpool_locked(p, device);",
            "\t\tif (IS_ERR(rpool)) {",
            "\t\t\tret = PTR_ERR(rpool);",
            "\t\t\tgoto err;",
            "\t\t} else {",
            "\t\t\tnew = rpool->resources[index].usage + 1;",
            "\t\t\tif (new > rpool->resources[index].max) {",
            "\t\t\t\tret = -EAGAIN;",
            "\t\t\t\tgoto err;",
            "\t\t\t} else {",
            "\t\t\t\trpool->resources[index].usage = new;",
            "\t\t\t\trpool->usage_sum++;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&rdmacg_mutex);",
            "",
            "\t*rdmacg = cg;",
            "\treturn 0;",
            "",
            "err:",
            "\tmutex_unlock(&rdmacg_mutex);",
            "\trdmacg_uncharge_hierarchy(cg, device, p, index);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "set_resource_limit, set_all_resource_max_limit, free_cg_rpool_locked, uncharge_cg_locked, rdmacg_uncharge_hierarchy, rdmacg_uncharge, rdmacg_try_charge",
          "description": "实现资源限制调整、资源释放及充电逻辑，包含设置资源上限、释放资源池、递归层级资源释放、尝试充电检查及错误恢复机制，维护资源使用计数和最大值统计。",
          "similarity": 0.5151788592338562
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/cgroup/rdma.c",
          "start_line": 1,
          "end_line": 81,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * RDMA resource limiting controller for cgroups.",
            " *",
            " * Used to allow a cgroup hierarchy to stop processes from consuming",
            " * additional RDMA resources after a certain limit is reached.",
            " *",
            " * Copyright (C) 2016 Parav Pandit <pandit.parav@gmail.com>",
            " */",
            "",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup_rdma.h>",
            "",
            "#define RDMACG_MAX_STR \"max\"",
            "",
            "/*",
            " * Protects list of resource pools maintained on per cgroup basis",
            " * and rdma device list.",
            " */",
            "static DEFINE_MUTEX(rdmacg_mutex);",
            "static LIST_HEAD(rdmacg_devices);",
            "",
            "enum rdmacg_file_type {",
            "\tRDMACG_RESOURCE_TYPE_MAX,",
            "\tRDMACG_RESOURCE_TYPE_STAT,",
            "};",
            "",
            "/*",
            " * resource table definition as to be seen by the user.",
            " * Need to add entries to it when more resources are",
            " * added/defined at IB verb/core layer.",
            " */",
            "static char const *rdmacg_resource_names[] = {",
            "\t[RDMACG_RESOURCE_HCA_HANDLE]\t= \"hca_handle\",",
            "\t[RDMACG_RESOURCE_HCA_OBJECT]\t= \"hca_object\",",
            "};",
            "",
            "/* resource tracker for each resource of rdma cgroup */",
            "struct rdmacg_resource {",
            "\tint max;",
            "\tint usage;",
            "};",
            "",
            "/*",
            " * resource pool object which represents per cgroup, per device",
            " * resources. There are multiple instances of this object per cgroup,",
            " * therefore it cannot be embedded within rdma_cgroup structure. It",
            " * is maintained as list.",
            " */",
            "struct rdmacg_resource_pool {",
            "\tstruct rdmacg_device\t*device;",
            "\tstruct rdmacg_resource\tresources[RDMACG_RESOURCE_MAX];",
            "",
            "\tstruct list_head\tcg_node;",
            "\tstruct list_head\tdev_node;",
            "",
            "\t/* count active user tasks of this pool */",
            "\tu64\t\t\tusage_sum;",
            "\t/* total number counts which are set to max */",
            "\tint\t\t\tnum_max_cnt;",
            "};",
            "",
            "static struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)",
            "{",
            "\treturn container_of(css, struct rdma_cgroup, css);",
            "}",
            "",
            "static struct rdma_cgroup *parent_rdmacg(struct rdma_cgroup *cg)",
            "{",
            "\treturn css_rdmacg(cg->css.parent);",
            "}",
            "",
            "static inline struct rdma_cgroup *get_current_rdmacg(void)",
            "{",
            "\treturn css_rdmacg(task_get_css(current, rdma_cgrp_id));",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义RDMA cgroup资源管理的基础结构，包括互斥锁保护的设备列表、资源类型枚举、资源名称映射及rdmacg_resource_pool结构体，提供从css获取rdma_cgroup的辅助函数。",
          "similarity": 0.4918235242366791
        }
      ]
    },
    {
      "source_file": "kernel/cgroup/dmem.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:45:21\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\dmem.c`\n\n---\n\n# cgroup/dmem.c 技术文档\n\n## 文件概述\n\n`cgroup/dmem.c` 实现了一个名为 **dmem（device memory）** 的 cgroup 子系统，用于对设备内存（如 GPU、NPU 或其他专用硬件内存）的使用进行资源控制和配额管理。该子系统通过 `page_counter` 机制跟踪每个 cgroup 在特定设备内存区域（region）上的用量，并支持设置 `min`、`low` 和 `max` 三种资源限制级别，以实现分级内存保护和回收策略。文件还提供了内存回收时的“是否可驱逐”判断逻辑，用于指导设备驱动在内存压力下选择合适的 cgroup 进行释放。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct dmem_cgroup_region`**  \n  表示一个设备内存区域（如某块 GPU 显存），包含：\n  - `ref`：引用计数，配合 RCU 管理生命周期\n  - `region_node`：全局区域链表节点（`dmem_cgroup_regions`）\n  - `pools`：关联到该区域的所有 cgroup 内存池列表\n  - `size`：区域总大小（字节）\n  - `name`：区域名称\n  - `unregistered`：标记区域是否已注销，防止新池加入\n\n- **`struct dmemcg_state`**  \n  cgroup 子系统状态（CSS），每个 cgroup 实例对应一个，包含：\n  - `css`：标准 cgroup_subsys_state 基类\n  - `pools`：该 cgroup 下所有设备内存池的链表\n\n- **`struct dmem_cgroup_pool_state`**  \n  表示某个 cgroup 在特定设备内存区域上的使用状态，包含：\n  - `region`：指向所属的 `dmem_cgroup_region`\n  - `cs`：指向所属的 `dmemcg_state`\n  - `css_node`：挂载到 cgroup 的 `pools` 链表（RCU 保护）\n  - `region_node`：挂载到 region 的 `pools` 链表（自旋锁保护）\n  - `cnt`：`page_counter` 实例，记录当前用量及限制\n  - `inited`：初始化标志\n\n### 主要函数\n\n- **资源限制操作函数**  \n  - `set_resource_min/low/max()`：设置 min/low/max 限制\n  - `get_resource_current/min/low/max()`：获取当前用量或限制值\n  - `reset_all_resource_limits()`：重置所有限制为默认值\n\n- **cgroup 生命周期回调**  \n  - `dmemcs_alloc()`：分配 cgroup 状态\n  - `dmemcs_offline()`：cgroup 下线时重置所有池的限制\n  - `dmemcs_free()`：释放 cgroup 状态及关联的池\n\n- **内存回收辅助函数**  \n  - `dmem_cgroup_state_evict_valuable()`：判断某内存池是否可被驱逐（核心回收逻辑）\n  - `dmem_cgroup_calculate_protection()`：计算子树中各池的有效保护值（emin/elow）\n\n- **辅助函数**  \n  - `find_cg_pool_locked()`：在指定 cgroup 中查找特定 region 的池（需持锁）\n  - `pool_parent()`：获取池的父池（基于 page_counter 层级）\n\n## 关键实现\n\n### 并发控制策略\n\n- **全局自旋锁 `dmemcg_lock`**：保护以下操作：\n  - 全局区域列表 `dmem_cgroup_regions` 的增删\n  - cgroup 的 `pools` 链表与 region 的 `pools` 链表的修改\n- **RCU 机制**：用于无锁读取 cgroup 的 `pools` 链表（如 `dmemcs_offline()` 和 `find_cg_pool_locked()`）\n- **`page_counter`**：本身是无锁的原子计数器，用于高效跟踪内存用量\n\n### 内存保护与回收逻辑\n\n- **三级保护机制**：\n  - `min`：硬性保证，用量 ≤ min 时不可驱逐\n  - `low`：软性保护，用量 > low 时可驱逐；用量 ≤ low 时需特殊处理（如设置 `ret_hit_low`）\n  - `max`：硬性上限，用量不可超过\n- **`dmem_cgroup_state_evict_valuable()` 工作流程**：\n  1. 若 `limit_pool == test_pool`，直接允许驱逐（自身超限）\n  2. 若 `limit_pool` 无父 cgroup（即根 cgroup），允许驱逐\n  3. 检查 `test_pool` 是否在 `limit_pool` 的子树中（通过 `pool_parent` 遍历）\n  4. 调用 `dmem_cgroup_calculate_protection()` 计算子树中各池的有效保护值\n  5. 比较 `test_pool` 的当前用量与 `emin`/`elow`：\n     - 用量 ≤ `emin` → 不可驱逐\n     - 用量 > `elow` → 可驱逐\n     - 用量 ≤ `elow` 且 `ignore_low=false` → 不可驱逐，但设置 `ret_hit_low=true` 建议重试\n\n### 层级关系维护\n\n- **池的父子关系**：通过 `page_counter` 的 `parent` 字段隐式建立，`pool_parent()` 用于向上遍历\n- **保护值传播**：`dmem_cgroup_calculate_protection()` 遍历 `limit_pool` 的整个子树，调用 `page_counter_calculate_protection()` 更新各子池的 `emin`/`elow`\n\n## 依赖关系\n\n- **核心依赖**：\n  - `<linux/cgroup.h>`：cgroup 子系统框架\n  - `<linux/page_counter.h>`：内存用量计数与保护机制\n  - `<linux/rcupdate.h>`（隐式）：RCU 读写锁\n  - `<linux/spinlock.h>`：自旋锁实现\n- **头文件依赖**：\n  - `<linux/cgroup_dmem.h>`：dmem cgroup 的公共接口定义（如 `dmem_cgrp_id`）\n- **与其他子系统关系**：\n  - 类似 `rdma` 和 `misc` cgroup 控制器的设计模式\n  - 为设备驱动（如 GPU/NPU 驱动）提供内存配额管理接口\n\n## 使用场景\n\n- **设备内存资源隔离**：在多租户或容器化环境中，限制不同 cgroup 对专用设备内存（如 GPU 显存）的使用量。\n- **分级内存回收**：当设备内存不足时，驱动调用 `dmem_cgroup_state_evict_valuable()` 判断哪些 cgroup 的内存可安全释放，优先驱逐超出 `low` 限制的 cgroup，保护 `min` 限制内的关键任务。\n- **动态配额调整**：管理员可通过 cgroup 接口（如 `memory.dmem.*` 文件）动态调整各 cgroup 的 `min`/`low`/`max` 限制，实现灵活的资源调度。\n- **根 cgroup 默认行为**：未显式设置限制的 cgroup 继承根 cgroup 的默认策略（`max=PAGE_COUNTER_MAX`，无硬限制）。",
      "similarity": 0.6066948771476746,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/dmem.c",
          "start_line": 106,
          "end_line": 209,
          "content": [
            "static void free_cg_pool(struct dmem_cgroup_pool_state *pool)",
            "{",
            "\tlist_del(&pool->region_node);",
            "\tkfree(pool);",
            "}",
            "static void",
            "set_resource_min(struct dmem_cgroup_pool_state *pool, u64 val)",
            "{",
            "\tpage_counter_set_min(&pool->cnt, val);",
            "}",
            "static void",
            "set_resource_low(struct dmem_cgroup_pool_state *pool, u64 val)",
            "{",
            "\tpage_counter_set_low(&pool->cnt, val);",
            "}",
            "static void",
            "set_resource_max(struct dmem_cgroup_pool_state *pool, u64 val)",
            "{",
            "\tpage_counter_set_max(&pool->cnt, val);",
            "}",
            "static u64 get_resource_low(struct dmem_cgroup_pool_state *pool)",
            "{",
            "\treturn pool ? READ_ONCE(pool->cnt.low) : 0;",
            "}",
            "static u64 get_resource_min(struct dmem_cgroup_pool_state *pool)",
            "{",
            "\treturn pool ? READ_ONCE(pool->cnt.min) : 0;",
            "}",
            "static u64 get_resource_max(struct dmem_cgroup_pool_state *pool)",
            "{",
            "\treturn pool ? READ_ONCE(pool->cnt.max) : PAGE_COUNTER_MAX;",
            "}",
            "static u64 get_resource_current(struct dmem_cgroup_pool_state *pool)",
            "{",
            "\treturn pool ? page_counter_read(&pool->cnt) : 0;",
            "}",
            "static void reset_all_resource_limits(struct dmem_cgroup_pool_state *rpool)",
            "{",
            "\tset_resource_min(rpool, 0);",
            "\tset_resource_low(rpool, 0);",
            "\tset_resource_max(rpool, PAGE_COUNTER_MAX);",
            "}",
            "static void dmemcs_offline(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct dmemcg_state *dmemcs = css_to_dmemcs(css);",
            "\tstruct dmem_cgroup_pool_state *pool;",
            "",
            "\trcu_read_lock();",
            "\tlist_for_each_entry_rcu(pool, &dmemcs->pools, css_node)",
            "\t\treset_all_resource_limits(pool);",
            "\trcu_read_unlock();",
            "}",
            "static void dmemcs_free(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct dmemcg_state *dmemcs = css_to_dmemcs(css);",
            "\tstruct dmem_cgroup_pool_state *pool, *next;",
            "",
            "\tspin_lock(&dmemcg_lock);",
            "\tlist_for_each_entry_safe(pool, next, &dmemcs->pools, css_node) {",
            "\t\t/*",
            "\t\t *The pool is dead and all references are 0,",
            "\t\t * no need for RCU protection with list_del_rcu or freeing.",
            "\t\t */",
            "\t\tlist_del(&pool->css_node);",
            "\t\tfree_cg_pool(pool);",
            "\t}",
            "\tspin_unlock(&dmemcg_lock);",
            "",
            "\tkfree(dmemcs);",
            "}",
            "static void",
            "dmem_cgroup_calculate_protection(struct dmem_cgroup_pool_state *limit_pool,",
            "\t\t\t\t struct dmem_cgroup_pool_state *test_pool)",
            "{",
            "\tstruct page_counter *climit;",
            "\tstruct cgroup_subsys_state *css;",
            "\tstruct dmemcg_state *dmemcg_iter;",
            "\tstruct dmem_cgroup_pool_state *pool, *found_pool;",
            "",
            "\tclimit = &limit_pool->cnt;",
            "",
            "\trcu_read_lock();",
            "",
            "\tcss_for_each_descendant_pre(css, &limit_pool->cs->css) {",
            "\t\tdmemcg_iter = container_of(css, struct dmemcg_state, css);",
            "\t\tfound_pool = NULL;",
            "",
            "\t\tlist_for_each_entry_rcu(pool, &dmemcg_iter->pools, css_node) {",
            "\t\t\tif (pool->region == limit_pool->region) {",
            "\t\t\t\tfound_pool = pool;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (!found_pool)",
            "\t\t\tcontinue;",
            "",
            "\t\tpage_counter_calculate_protection(",
            "\t\t\tclimit, &found_pool->cnt, true);",
            "",
            "\t\tif (found_pool == test_pool)",
            "\t\t\tbreak;",
            "\t}",
            "\trcu_read_unlock();",
            "}"
          ],
          "function_name": "free_cg_pool, set_resource_min, set_resource_low, set_resource_max, get_resource_low, get_resource_min, get_resource_max, get_resource_current, reset_all_resource_limits, dmemcs_offline, dmemcs_free, dmem_cgroup_calculate_protection",
          "description": "实现内存池释放逻辑（free_cg_pool）及资源限制设置/获取接口（set_resource_* / get_resource_*）；通过RCU和自旋锁保护池生命周期管理；处理cgroup卸载时的资源重置（dmemcs_offline）和彻底销毁（dmemcs_free）；计算层级保护策略（dmem_cgroup_calculate_protection）",
          "similarity": 0.5892584919929504
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/cgroup/dmem.c",
          "start_line": 572,
          "end_line": 704,
          "content": [
            "void dmem_cgroup_uncharge(struct dmem_cgroup_pool_state *pool, u64 size)",
            "{",
            "\tif (!pool)",
            "\t\treturn;",
            "",
            "\tpage_counter_uncharge(&pool->cnt, size);",
            "\tcss_put(&pool->cs->css);",
            "}",
            "int dmem_cgroup_try_charge(struct dmem_cgroup_region *region, u64 size,",
            "\t\t\t  struct dmem_cgroup_pool_state **ret_pool,",
            "\t\t\t  struct dmem_cgroup_pool_state **ret_limit_pool)",
            "{",
            "\tstruct dmemcg_state *cg;",
            "\tstruct dmem_cgroup_pool_state *pool;",
            "\tstruct page_counter *fail;",
            "\tint ret;",
            "",
            "\t*ret_pool = NULL;",
            "\tif (ret_limit_pool)",
            "\t\t*ret_limit_pool = NULL;",
            "",
            "\t/*",
            "\t * hold on to css, as cgroup can be removed but resource",
            "\t * accounting happens on css.",
            "\t */",
            "\tcg = get_current_dmemcs();",
            "",
            "\tpool = get_cg_pool_unlocked(cg, region);",
            "\tif (IS_ERR(pool)) {",
            "\t\tret = PTR_ERR(pool);",
            "\t\tgoto err;",
            "\t}",
            "",
            "\tif (!page_counter_try_charge(&pool->cnt, size, &fail)) {",
            "\t\tif (ret_limit_pool) {",
            "\t\t\t*ret_limit_pool = container_of(fail, struct dmem_cgroup_pool_state, cnt);",
            "\t\t\tcss_get(&(*ret_limit_pool)->cs->css);",
            "\t\t}",
            "\t\tret = -EAGAIN;",
            "\t\tgoto err;",
            "\t}",
            "",
            "\t/* On success, reference from get_current_dmemcs is transferred to *ret_pool */",
            "\t*ret_pool = pool;",
            "\treturn 0;",
            "",
            "err:",
            "\tcss_put(&cg->css);",
            "\treturn ret;",
            "}",
            "static int dmem_cgroup_region_capacity_show(struct seq_file *sf, void *v)",
            "{",
            "\tstruct dmem_cgroup_region *region;",
            "",
            "\trcu_read_lock();",
            "\tlist_for_each_entry_rcu(region, &dmem_cgroup_regions, region_node) {",
            "\t\tseq_puts(sf, region->name);",
            "\t\tseq_printf(sf, \" %llu\\n\", region->size);",
            "\t}",
            "\trcu_read_unlock();",
            "\treturn 0;",
            "}",
            "static int dmemcg_parse_limit(char *options, struct dmem_cgroup_region *region,",
            "\t\t\t      u64 *new_limit)",
            "{",
            "\tchar *end;",
            "",
            "\tif (!strcmp(options, \"max\")) {",
            "\t\t*new_limit = PAGE_COUNTER_MAX;",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t*new_limit = memparse(options, &end);",
            "\tif (*end != '\\0')",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static ssize_t dmemcg_limit_write(struct kernfs_open_file *of,",
            "\t\t\t\t char *buf, size_t nbytes, loff_t off,",
            "\t\t\t\t void (*apply)(struct dmem_cgroup_pool_state *, u64))",
            "{",
            "\tstruct dmemcg_state *dmemcs = css_to_dmemcs(of_css(of));",
            "\tint err = 0;",
            "",
            "\twhile (buf && !err) {",
            "\t\tstruct dmem_cgroup_pool_state *pool = NULL;",
            "\t\tchar *options, *region_name;",
            "\t\tstruct dmem_cgroup_region *region;",
            "\t\tu64 new_limit;",
            "",
            "\t\toptions = buf;",
            "\t\tbuf = strchr(buf, '\\n');",
            "\t\tif (buf)",
            "\t\t\t*buf++ = '\\0';",
            "",
            "\t\toptions = strstrip(options);",
            "",
            "\t\t/* eat empty lines */",
            "\t\tif (!options[0])",
            "\t\t\tcontinue;",
            "",
            "\t\tregion_name = strsep(&options, \" \\t\");",
            "\t\tif (!region_name[0])",
            "\t\t\tcontinue;",
            "",
            "\t\trcu_read_lock();",
            "\t\tregion = dmemcg_get_region_by_name(region_name);",
            "\t\trcu_read_unlock();",
            "",
            "\t\tif (!region)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\terr = dmemcg_parse_limit(options, region, &new_limit);",
            "\t\tif (err < 0)",
            "\t\t\tgoto out_put;",
            "",
            "\t\tpool = get_cg_pool_unlocked(dmemcs, region);",
            "\t\tif (IS_ERR(pool)) {",
            "\t\t\terr = PTR_ERR(pool);",
            "\t\t\tgoto out_put;",
            "\t\t}",
            "",
            "\t\t/* And commit */",
            "\t\tapply(pool, new_limit);",
            "",
            "out_put:",
            "\t\tkref_put(&region->ref, dmemcg_free_region);",
            "\t}",
            "",
            "",
            "\treturn err ?: nbytes;",
            "}"
          ],
          "function_name": "dmem_cgroup_uncharge, dmem_cgroup_try_charge, dmem_cgroup_region_capacity_show, dmemcg_parse_limit, dmemcg_limit_write",
          "description": "实现内存扣费操作（dmem_cgroup_uncharge）及带检查的扣费尝试（dmem_cgroup_try_charge）；提供区域容量展示接口（dmem_cgroup_region_capacity_show）；解析限制参数（dmemcg_parse_limit）并应用到指定区域池（dmemcg_limit_write）",
          "similarity": 0.5413765907287598
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/cgroup/dmem.c",
          "start_line": 731,
          "end_line": 784,
          "content": [
            "static int dmemcg_limit_show(struct seq_file *sf, void *v,",
            "\t\t\t    u64 (*fn)(struct dmem_cgroup_pool_state *))",
            "{",
            "\tstruct dmemcg_state *dmemcs = css_to_dmemcs(seq_css(sf));",
            "\tstruct dmem_cgroup_region *region;",
            "",
            "\trcu_read_lock();",
            "\tlist_for_each_entry_rcu(region, &dmem_cgroup_regions, region_node) {",
            "\t\tstruct dmem_cgroup_pool_state *pool = find_cg_pool_locked(dmemcs, region);",
            "\t\tu64 val;",
            "",
            "\t\tseq_puts(sf, region->name);",
            "",
            "\t\tval = fn(pool);",
            "\t\tif (val < PAGE_COUNTER_MAX)",
            "\t\t\tseq_printf(sf, \" %lld\\n\", val);",
            "\t\telse",
            "\t\t\tseq_puts(sf, \" max\\n\");",
            "\t}",
            "\trcu_read_unlock();",
            "",
            "\treturn 0;",
            "}",
            "static int dmem_cgroup_region_current_show(struct seq_file *sf, void *v)",
            "{",
            "\treturn dmemcg_limit_show(sf, v, get_resource_current);",
            "}",
            "static int dmem_cgroup_region_min_show(struct seq_file *sf, void *v)",
            "{",
            "\treturn dmemcg_limit_show(sf, v, get_resource_min);",
            "}",
            "static ssize_t dmem_cgroup_region_min_write(struct kernfs_open_file *of,",
            "\t\t\t\t      char *buf, size_t nbytes, loff_t off)",
            "{",
            "\treturn dmemcg_limit_write(of, buf, nbytes, off, set_resource_min);",
            "}",
            "static int dmem_cgroup_region_low_show(struct seq_file *sf, void *v)",
            "{",
            "\treturn dmemcg_limit_show(sf, v, get_resource_low);",
            "}",
            "static ssize_t dmem_cgroup_region_low_write(struct kernfs_open_file *of,",
            "\t\t\t\t      char *buf, size_t nbytes, loff_t off)",
            "{",
            "\treturn dmemcg_limit_write(of, buf, nbytes, off, set_resource_low);",
            "}",
            "static int dmem_cgroup_region_max_show(struct seq_file *sf, void *v)",
            "{",
            "\treturn dmemcg_limit_show(sf, v, get_resource_max);",
            "}",
            "static ssize_t dmem_cgroup_region_max_write(struct kernfs_open_file *of,",
            "\t\t\t\t      char *buf, size_t nbytes, loff_t off)",
            "{",
            "\treturn dmemcg_limit_write(of, buf, nbytes, off, set_resource_max);",
            "}"
          ],
          "function_name": "dmemcg_limit_show, dmem_cgroup_region_current_show, dmem_cgroup_region_min_show, dmem_cgroup_region_min_write, dmem_cgroup_region_low_show, dmem_cgroup_region_low_write, dmem_cgroup_region_max_show, dmem_cgroup_region_max_write",
          "description": "实现内存限制属性展示接口（dmemcg_limit_show系列）用于序列化输出；通过统一接口暴露当前值（get_resource_current）、最小值（get_resource_min）、低水位（get_resource_low）和最大值（get_resource_max）；提供限制参数写入接口（dmem_cgroup_region_min_write等）支持动态调整",
          "similarity": 0.5369514226913452
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/cgroup/dmem.c",
          "start_line": 267,
          "end_line": 367,
          "content": [
            "bool dmem_cgroup_state_evict_valuable(struct dmem_cgroup_pool_state *limit_pool,",
            "\t\t\t\t      struct dmem_cgroup_pool_state *test_pool,",
            "\t\t\t\t      bool ignore_low, bool *ret_hit_low)",
            "{",
            "\tstruct dmem_cgroup_pool_state *pool = test_pool;",
            "\tstruct page_counter *climit, *ctest;",
            "\tu64 used, min, low;",
            "",
            "\t/* Can always evict from current pool, despite limits */",
            "\tif (limit_pool == test_pool)",
            "\t\treturn true;",
            "",
            "\tif (limit_pool) {",
            "\t\tif (!parent_dmemcs(limit_pool->cs))",
            "\t\t\treturn true;",
            "",
            "\t\tfor (pool = test_pool; pool && limit_pool != pool; pool = pool_parent(pool))",
            "\t\t\t{}",
            "",
            "\t\tif (!pool)",
            "\t\t\treturn false;",
            "\t} else {",
            "\t\t/*",
            "\t\t * If there is no cgroup limiting memory usage, use the root",
            "\t\t * cgroup instead for limit calculations.",
            "\t\t */",
            "\t\tfor (limit_pool = test_pool; pool_parent(limit_pool); limit_pool = pool_parent(limit_pool))",
            "\t\t\t{}",
            "\t}",
            "",
            "\tclimit = &limit_pool->cnt;",
            "\tctest = &test_pool->cnt;",
            "",
            "\tdmem_cgroup_calculate_protection(limit_pool, test_pool);",
            "",
            "\tused = page_counter_read(ctest);",
            "\tmin = READ_ONCE(ctest->emin);",
            "",
            "\tif (used <= min)",
            "\t\treturn false;",
            "",
            "\tif (!ignore_low) {",
            "\t\tlow = READ_ONCE(ctest->elow);",
            "\t\tif (used > low)",
            "\t\t\treturn true;",
            "",
            "\t\t*ret_hit_low = true;",
            "\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static void dmemcg_free_rcu(struct rcu_head *rcu)",
            "{",
            "\tstruct dmem_cgroup_region *region = container_of(rcu, typeof(*region), rcu);",
            "\tstruct dmem_cgroup_pool_state *pool, *next;",
            "",
            "\tlist_for_each_entry_safe(pool, next, &region->pools, region_node)",
            "\t\tfree_cg_pool(pool);",
            "\tkfree(region->name);",
            "\tkfree(region);",
            "}",
            "static void dmemcg_free_region(struct kref *ref)",
            "{",
            "\tstruct dmem_cgroup_region *cgregion = container_of(ref, typeof(*cgregion), ref);",
            "",
            "\tcall_rcu(&cgregion->rcu, dmemcg_free_rcu);",
            "}",
            "void dmem_cgroup_unregister_region(struct dmem_cgroup_region *region)",
            "{",
            "\tstruct list_head *entry;",
            "",
            "\tif (!region)",
            "\t\treturn;",
            "",
            "\tspin_lock(&dmemcg_lock);",
            "",
            "\t/* Remove from global region list */",
            "\tlist_del_rcu(&region->region_node);",
            "",
            "\tlist_for_each_rcu(entry, &region->pools) {",
            "\t\tstruct dmem_cgroup_pool_state *pool =",
            "\t\t\tcontainer_of(entry, typeof(*pool), region_node);",
            "",
            "\t\tlist_del_rcu(&pool->css_node);",
            "\t}",
            "",
            "\t/*",
            "\t * Ensure any RCU based lookups fail. Additionally,",
            "\t * no new pools should be added to the dead region",
            "\t * by get_cg_pool_unlocked.",
            "\t */",
            "\tregion->unregistered = true;",
            "\tspin_unlock(&dmemcg_lock);",
            "",
            "\tkref_put(&region->ref, dmemcg_free_region);",
            "}",
            "void dmem_cgroup_pool_state_put(struct dmem_cgroup_pool_state *pool)",
            "{",
            "\tif (pool)",
            "\t\tcss_put(&pool->cs->css);",
            "}"
          ],
          "function_name": "dmem_cgroup_state_evict_valuable, dmemcg_free_rcu, dmemcg_free_region, dmem_cgroup_unregister_region, dmem_cgroup_pool_state_put",
          "description": "实现内存可驱逐性判定（dmem_cgroup_state_evict_valuable）；通过RCU异步释放内存区域相关资源（dmemcg_free_rcu/dmemcg_free_region）；提供区域注销接口（dmem_cgroup_unregister_region）标记区域无效并触发动态清理；实现池状态引用计数管理（dmem_cgroup_pool_state_put）",
          "similarity": 0.5266731977462769
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/cgroup/dmem.c",
          "start_line": 1,
          "end_line": 105,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright 2023-2024 Intel Corporation (Maarten Lankhorst <dev@lankhorst.se>)",
            " * Copyright 2024 Red Hat (Maxime Ripard <mripard@kernel.org>)",
            " * Partially based on the rdma and misc controllers, which bear the following copyrights:",
            " *",
            " * Copyright 2020 Google LLC",
            " * Copyright (C) 2016 Parav Pandit <pandit.parav@gmail.com>",
            " */",
            "",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroup_dmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "",
            "struct dmem_cgroup_region {",
            "\t/**",
            "\t * @ref: References keeping the region alive.",
            "\t * Keeps the region reference alive after a succesful RCU lookup.",
            "\t */",
            "\tstruct kref ref;",
            "",
            "\t/** @rcu: RCU head for freeing */",
            "\tstruct rcu_head rcu;",
            "",
            "\t/**",
            "\t * @region_node: Linked into &dmem_cgroup_regions list.",
            "\t * Protected by RCU and global spinlock.",
            "\t */",
            "\tstruct list_head region_node;",
            "",
            "\t/**",
            "\t * @pools: List of pools linked to this region.",
            "\t * Protected by global spinlock only",
            "\t */",
            "\tstruct list_head pools;",
            "",
            "\t/** @size: Size of region, in bytes */",
            "\tu64 size;",
            "",
            "\t/** @name: Name describing the node, set by dmem_cgroup_register_region */",
            "\tchar *name;",
            "",
            "\t/**",
            "\t * @unregistered: Whether the region is unregistered by its caller.",
            "\t * No new pools should be added to the region afterwards.",
            "\t */",
            "\tbool unregistered;",
            "};",
            "",
            "struct dmemcg_state {",
            "\tstruct cgroup_subsys_state css;",
            "",
            "\tstruct list_head pools;",
            "};",
            "",
            "struct dmem_cgroup_pool_state {",
            "\tstruct dmem_cgroup_region *region;",
            "\tstruct dmemcg_state *cs;",
            "",
            "\t/* css node, RCU protected against region teardown */",
            "\tstruct list_head\tcss_node;",
            "",
            "\t/* dev node, no RCU protection required */",
            "\tstruct list_head\tregion_node;",
            "",
            "\tstruct rcu_head rcu;",
            "",
            "\tstruct page_counter cnt;",
            "",
            "\tbool inited;",
            "};",
            "",
            "/*",
            " * 3 operations require locking protection:",
            " * - Registering and unregistering region to/from list, requires global lock.",
            " * - Adding a dmem_cgroup_pool_state to a CSS, removing when CSS is freed.",
            " * - Adding a dmem_cgroup_pool_state to a region list.",
            " *",
            " * Since for the most common operations RCU provides enough protection, I",
            " * do not think more granular locking makes sense. Most protection is offered",
            " * by RCU and the lockless operating page_counter.",
            " */",
            "static DEFINE_SPINLOCK(dmemcg_lock);",
            "static LIST_HEAD(dmem_cgroup_regions);",
            "",
            "static inline struct dmemcg_state *",
            "css_to_dmemcs(struct cgroup_subsys_state *css)",
            "{",
            "\treturn container_of(css, struct dmemcg_state, css);",
            "}",
            "",
            "static inline struct dmemcg_state *get_current_dmemcs(void)",
            "{",
            "\treturn css_to_dmemcs(task_get_css(current, dmem_cgrp_id));",
            "}",
            "",
            "static struct dmemcg_state *parent_dmemcs(struct dmemcg_state *cg)",
            "{",
            "\treturn cg->css.parent ? css_to_dmemcs(cg->css.parent) : NULL;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义dmem_cgroup_region结构体，用于管理内存区域及其关联的池列表、大小、名称和注册状态；定义dmemcg_state结构体，作为cgroup子系统状态扩展；定义dmem_cgroup_pool_state结构体，保存池状态、计数器及链接节点；声明全局锁和链表头以协调多线程访问；提供css到dmemcg_state的转换函数",
          "similarity": 0.47723841667175293
        }
      ]
    }
  ]
}