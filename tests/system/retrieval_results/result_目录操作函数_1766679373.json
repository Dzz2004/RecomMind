{
  "query": "目录操作函数",
  "timestamp": "2025-12-26 00:16:13",
  "retrieved_files": [
    {
      "source_file": "kernel/pid_sysctl.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:17:36\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `pid_sysctl.h`\n\n---\n\n# `pid_sysctl.h` 技术文档\n\n## 1. 文件概述\n\n`pid_sysctl.h` 是 Linux 内核中用于定义与 PID 命名空间（`pid_namespace`）相关的系统控制（sysctl）接口的头文件。其核心功能是提供对 `memfd_noexec` 系统策略的运行时配置支持，该策略用于控制通过 `memfd_create()` 创建的内存文件是否允许执行代码。该配置具有层级继承语义：子 PID 命名空间的策略不能比其父命名空间更宽松，以确保安全策略的向下兼容性和强制性。\n\n## 2. 核心功能\n\n### 函数\n\n- **`pid_mfd_noexec_dointvec_minmax`**  \n  自定义的 sysctl 处理函数，用于读写 `memfd_noexec` 策略值。在写入时执行权限检查和策略继承约束验证。\n\n- **`register_pid_ns_sysctl_table_vm`**  \n  内联函数，用于向内核 sysctl 子系统注册 `vm.memfd_noexec` 控制项（仅在 `CONFIG_SYSCTL` 和 `CONFIG_MEMFD_CREATE` 同时启用时有效）。\n\n### 数据结构\n\n- **`pid_ns_ctl_table_vm`**  \n  `ctl_table` 类型的静态数组，定义了 `vm.memfd_noexec` sysctl 条目，包括其名称、数据指针、访问权限、处理函数及取值范围（0 到 2）。\n\n## 3. 关键实现\n\n- **权限控制**：  \n  在写入 `memfd_noexec` 值时，调用 `ns_capable(ns->user_ns, CAP_SYS_ADMIN)` 检查当前任务是否在对应用户命名空间中拥有 `CAP_SYS_ADMIN` 能力，防止非特权用户修改安全策略。\n\n- **策略继承约束**：  \n  通过 `pidns_memfd_noexec_scope(ns->parent)` 获取父 PID 命名空间的策略值 `parent_scope`，并确保当前命名空间的策略值 `scope` 不小于父策略（即不能更宽松）。实际写入前使用 `max(READ_ONCE(ns->memfd_noexec_scope), parent_scope)` 保证该约束。\n\n- **原子读写**：  \n  使用 `READ_ONCE()` 和 `WRITE_ONCE()` 对 `ns->memfd_noexec_scope` 进行访问，确保在并发环境下内存访问的可见性和顺序性。\n\n- **sysctl 注册**：  \n  通过 `register_sysctl(\"vm\", pid_ns_ctl_table_vm)` 将控制项注册到 `/proc/sys/vm/memfd_noexec` 路径下，供用户空间通过标准 sysctl 接口访问。\n\n- **条件编译**：  \n  整个功能仅在 `CONFIG_SYSCTL`（启用 sysctl 支持）和 `CONFIG_MEMFD_CREATE`（启用 memfd_create 系统调用）同时配置时编译，否则 `register_pid_ns_sysctl_table_vm` 为空内联函数，避免代码膨胀。\n\n## 4. 依赖关系\n\n- **`<linux/pid_namespace.h>`**：  \n  提供 `struct pid_namespace` 定义及辅助函数如 `task_active_pid_ns()` 和 `pidns_memfd_noexec_scope()`。\n\n- **`CONFIG_SYSCTL`**：  \n  内核配置选项，启用 sysctl 框架支持，提供 `register_sysctl`、`proc_dointvec_minmax` 等接口。\n\n- **`CONFIG_MEMFD_CREATE`**：  \n  内核配置选项，启用 `memfd_create()` 系统调用及相关功能（如 `memfd_noexec_scope` 字段）。\n\n- **能力子系统（Capabilities）**：  \n  依赖 `ns_capable()` 进行命名空间感知的权限检查。\n\n## 5. 使用场景\n\n- **安全策略配置**：  \n  系统管理员或容器运行时可通过写入 `/proc/sys/vm/memfd_noexec` 设置当前 PID 命名空间中 `memfd` 文件的执行限制级别（0=允许执行，1=禁止执行但可覆盖，2=严格禁止执行），用于防御基于内存文件的代码注入攻击。\n\n- **容器隔离**：  \n  在容器化环境中，不同容器运行在独立的 PID 命名空间中。父命名空间（如宿主机）可设置较严格的 `memfd_noexec` 策略，子容器无法降低该策略级别，从而实现自上而下的安全策略强制。\n\n- **运行时动态调整**：  \n  允许在系统运行期间动态调整 `memfd` 执行策略，无需重启或重新加载内核模块，提升系统灵活性与安全性。",
      "similarity": 0.5799378156661987,
      "chunks": []
    },
    {
      "source_file": "kernel/audit_tree.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:51:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `audit_tree.c`\n\n---\n\n# audit_tree.c 技术文档\n\n## 1. 文件概述\n\n`audit_tree.c` 是 Linux 内核审计子系统中用于实现**目录树监控**（audit tree watching）的核心模块。该文件提供了对整个目录树（而不仅仅是单个 inode）进行审计监控的能力，通过将审计规则与目录路径关联，并在文件系统事件（如创建、删除、重命名等）发生时高效匹配规则。其核心机制基于 `fsnotify` 框架，在 inode 级别挂载通知标记（mark），并通过引用计数、RCU（Read-Copy-Update）和哈希表等技术保证高并发下的安全性和性能。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct audit_tree`**  \n  表示一个被监控的目录树。包含路径名、引用计数、关联的规则列表、关联的 chunk 列表等。\n  \n- **`struct audit_chunk`**  \n  表示与一个或多个 inode 关联的监控单元。每个 chunk 通过 `fsnotify_mark` 附加到 inode 上，并维护多个 `audit_tree` 的所有者关系（`owners[]` 数组）。\n\n- **`struct audit_tree_mark`**  \n  封装 `fsnotify_mark`，作为 chunk 与 inode 之间的桥梁，属于 `fsnotify` 框架的扩展标记类型。\n\n- **`struct audit_node`**  \n  嵌入在 `audit_chunk` 中，表示 chunk 与某个 `audit_tree` 的关联关系，包含 owner 指针和索引。\n\n### 主要函数\n\n- **`alloc_tree(const char *s)`**  \n  分配并初始化一个新的 `audit_tree` 实例。\n\n- **`get_tree()` / `put_tree()`**  \n  对 `audit_tree` 进行引用计数管理，`put_tree` 在引用归零时使用 RCU 安全释放。\n\n- **`audit_tree_lookup(const struct inode *inode)`**  \n  在 RCU 读临界区内，根据 inode 查找对应的 `audit_chunk`，并增加其引用计数。\n\n- **`audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)`**  \n  检查给定 chunk 是否属于指定的 audit tree。\n\n- **`alloc_chunk(int count)`**  \n  分配包含指定数量 `audit_node` 的 chunk。\n\n- **`insert_hash(struct audit_chunk *chunk)`**  \n  将 chunk 插入全局哈希表，用于快速查找。\n\n- **`audit_mark_put_chunk()` / `audit_put_chunk()`**  \n  安全释放 chunk 的引用，结合 RCU 机制确保并发安全。\n\n- **`replace_mark_chunk()` / `replace_chunk()`**  \n  在标记或 chunk 更新时进行原子替换（代码片段中 `replace_chunk` 未完整）。\n\n## 3. 关键实现\n\n### 哈希与查找机制\n- 使用 `inode->i_fsnotify_marks` 的地址作为哈希键（`inode_to_key`），确保每个 inode 对应唯一键。\n- 全局哈希表 `chunk_hash_heads[HASH_SIZE]`（大小为 128）配合 `hash_lock` 自旋锁保护写操作。\n- 查找操作（`audit_tree_lookup`）在 RCU 读锁下进行，通过 `READ_ONCE()` 和 `smp_wmb()` 保证内存可见性。\n\n### 引用计数与生命周期管理\n- `audit_tree` 使用 `refcount_t` 管理引用，来源包括：关联的审计规则、chunk 中的 owner 引用。\n- `audit_chunk` 使用 `atomic_long_t refs`，其中一份引用由 `fsnotify_mark` 持有。\n- 所有释放操作均通过 RCU（`call_rcu` / `kfree_rcu`）延迟执行，确保并发读取安全。\n\n### 与 fsnotify 集成\n- 每个被监控的 inode 通过 `audit_tree_mark`（继承 `fsnotify_mark`）关联一个 `audit_chunk`。\n- 当 inode 被删除或 untag 时，`fsnotify` 框架回调 `audit_tree_destroy_watch` 释放 mark。\n- `mark->mask = FS_IN_IGNORED` 表示仅用于内部结构关联，不主动监听事件（实际事件由审计规则触发匹配）。\n\n### 循环链表组织\n- `tree->chunks`：链接所有包含该 tree 的 chunk 中的 `audit_node.list`。\n- `chunk->trees`：链接所有以该 chunk 为根的 tree 的 `same_root` 链表。\n- `tree->rules`：链接所有引用该 tree 的审计规则。\n- 这些链表分别由 `hash_lock` 或 `audit_filter_mutex` 保护。\n\n### 索引位标记\n- `audit_node.index` 的最高位（MSB）用于标记“可能需要回滚”的临时状态，辅助复杂操作（如树重构）的清理逻辑。\n\n## 4. 依赖关系\n\n- **`<linux/fsnotify_backend.h>`**：依赖 fsnotify 框架实现 inode 级别事件通知和标记管理。\n- **`<linux/namei.h>` / `<linux/mount.h>`**：用于路径解析和挂载点处理（虽未在片段中直接调用，但 audit 树需处理跨挂载点语义）。\n- **`audit.h`**：与审计核心模块交互，提供 `audit_tree_path()` 等接口供规则匹配使用。\n- **`<linux/rcupdate.h>`**：使用 RCU 机制保证并发安全。\n- **`<linux/slab.h>`**：使用 `kmem_cache` 高效分配 `audit_tree_mark` 对象。\n\n## 5. 使用场景\n\n- **审计规则匹配**：当用户通过 `auditctl` 添加 `-w /path/to/dir -p wa -k key` 类型规则时，内核将 `/path/to/dir` 注册为 `audit_tree`。\n- **路径遍历监控**：在 `audit_inode()` 和 `audit_inode_child()` 中，内核收集路径上所有 inode 对应的 `audit_chunk`，用于后续与 `AUDIT_TREE` 类型规则匹配。\n- **动态目录结构变更**：当目录树内发生文件创建、删除、重命名或 inode 删除时，通过 fsnotify 机制触发 chunk 更新或 prune（修剪）操作，由专用内核线程 `prune_thread` 处理延迟清理。\n- **资源回收**：当审计规则被删除或监控目录被移除时，相关 `audit_tree` 和 `audit_chunk` 通过引用计数和 RCU 安全释放，避免内存泄漏。",
      "similarity": 0.560624897480011,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/audit_tree.c",
          "start_line": 1,
          "end_line": 110,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include \"audit.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/refcount.h>",
            "#include <linux/slab.h>",
            "",
            "struct audit_tree;",
            "struct audit_chunk;",
            "",
            "struct audit_tree {",
            "\trefcount_t count;",
            "\tint goner;",
            "\tstruct audit_chunk *root;",
            "\tstruct list_head chunks;",
            "\tstruct list_head rules;",
            "\tstruct list_head list;",
            "\tstruct list_head same_root;",
            "\tstruct rcu_head head;",
            "\tchar pathname[];",
            "};",
            "",
            "struct audit_chunk {",
            "\tstruct list_head hash;",
            "\tunsigned long key;",
            "\tstruct fsnotify_mark *mark;",
            "\tstruct list_head trees;\t\t/* with root here */",
            "\tint count;",
            "\tatomic_long_t refs;",
            "\tstruct rcu_head head;",
            "\tstruct audit_node {",
            "\t\tstruct list_head list;",
            "\t\tstruct audit_tree *owner;",
            "\t\tunsigned index;\t\t/* index; upper bit indicates 'will prune' */",
            "\t} owners[];",
            "};",
            "",
            "struct audit_tree_mark {",
            "\tstruct fsnotify_mark mark;",
            "\tstruct audit_chunk *chunk;",
            "};",
            "",
            "static LIST_HEAD(tree_list);",
            "static LIST_HEAD(prune_list);",
            "static struct task_struct *prune_thread;",
            "",
            "/*",
            " * One struct chunk is attached to each inode of interest through",
            " * audit_tree_mark (fsnotify mark). We replace struct chunk on tagging /",
            " * untagging, the mark is stable as long as there is chunk attached. The",
            " * association between mark and chunk is protected by hash_lock and",
            " * audit_tree_group->mark_mutex. Thus as long as we hold",
            " * audit_tree_group->mark_mutex and check that the mark is alive by",
            " * FSNOTIFY_MARK_FLAG_ATTACHED flag check, we are sure the mark points to",
            " * the current chunk.",
            " *",
            " * Rules have pointer to struct audit_tree.",
            " * Rules have struct list_head rlist forming a list of rules over",
            " * the same tree.",
            " * References to struct chunk are collected at audit_inode{,_child}()",
            " * time and used in AUDIT_TREE rule matching.",
            " * These references are dropped at the same time we are calling",
            " * audit_free_names(), etc.",
            " *",
            " * Cyclic lists galore:",
            " * tree.chunks anchors chunk.owners[].list\t\t\thash_lock",
            " * tree.rules anchors rule.rlist\t\t\t\taudit_filter_mutex",
            " * chunk.trees anchors tree.same_root\t\t\t\thash_lock",
            " * chunk.hash is a hash with middle bits of watch.inode as",
            " * a hash function.\t\t\t\t\t\tRCU, hash_lock",
            " *",
            " * tree is refcounted; one reference for \"some rules on rules_list refer to",
            " * it\", one for each chunk with pointer to it.",
            " *",
            " * chunk is refcounted by embedded .refs. Mark associated with the chunk holds",
            " * one chunk reference. This reference is dropped either when a mark is going",
            " * to be freed (corresponding inode goes away) or when chunk attached to the",
            " * mark gets replaced. This reference must be dropped using",
            " * audit_mark_put_chunk() to make sure the reference is dropped only after RCU",
            " * grace period as it protects RCU readers of the hash table.",
            " *",
            " * node.index allows to get from node.list to containing chunk.",
            " * MSB of that sucker is stolen to mark taggings that we might have to",
            " * revert - several operations have very unpleasant cleanup logics and",
            " * that makes a difference.  Some.",
            " */",
            "",
            "static struct fsnotify_group *audit_tree_group __ro_after_init;",
            "static struct kmem_cache *audit_tree_mark_cachep __ro_after_init;",
            "",
            "static struct audit_tree *alloc_tree(const char *s)",
            "{",
            "\tstruct audit_tree *tree;",
            "",
            "\ttree = kmalloc(struct_size(tree, pathname, strlen(s) + 1), GFP_KERNEL);",
            "\tif (tree) {",
            "\t\trefcount_set(&tree->count, 1);",
            "\t\ttree->goner = 0;",
            "\t\tINIT_LIST_HEAD(&tree->chunks);",
            "\t\tINIT_LIST_HEAD(&tree->rules);",
            "\t\tINIT_LIST_HEAD(&tree->list);",
            "\t\tINIT_LIST_HEAD(&tree->same_root);",
            "\t\ttree->root = NULL;",
            "\t\tstrcpy(tree->pathname, s);",
            "\t}",
            "\treturn tree;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了审计树和chunk的数据结构，用于跟踪文件系统事件。audit_tree包含规则列表和路径名，audit_chunk管理与文件节点的关联。全局变量和辅助函数用于初始化、引用计数及哈希表操作，支持审计规则匹配和事件追踪。",
          "similarity": 0.4973548948764801
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/audit_tree.c",
          "start_line": 325,
          "end_line": 451,
          "content": [
            "static void remove_chunk_node(struct audit_chunk *chunk, struct audit_node *p)",
            "{",
            "\tstruct audit_tree *owner = p->owner;",
            "",
            "\tif (owner->root == chunk) {",
            "\t\tlist_del_init(&owner->same_root);",
            "\t\towner->root = NULL;",
            "\t}",
            "\tlist_del_init(&p->list);",
            "\tp->owner = NULL;",
            "\tput_tree(owner);",
            "}",
            "static int chunk_count_trees(struct audit_chunk *chunk)",
            "{",
            "\tint i;",
            "\tint ret = 0;",
            "",
            "\tfor (i = 0; i < chunk->count; i++)",
            "\t\tif (chunk->owners[i].owner)",
            "\t\t\tret++;",
            "\treturn ret;",
            "}",
            "static void untag_chunk(struct audit_chunk *chunk, struct fsnotify_mark *mark)",
            "{",
            "\tstruct audit_chunk *new;",
            "\tint size;",
            "",
            "\tfsnotify_group_lock(audit_tree_group);",
            "\t/*",
            "\t * mark_mutex stabilizes chunk attached to the mark so we can check",
            "\t * whether it didn't change while we've dropped hash_lock.",
            "\t */",
            "\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED) ||",
            "\t    mark_chunk(mark) != chunk)",
            "\t\tgoto out_mutex;",
            "",
            "\tsize = chunk_count_trees(chunk);",
            "\tif (!size) {",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_del_init(&chunk->trees);",
            "\t\tlist_del_rcu(&chunk->hash);",
            "\t\treplace_mark_chunk(mark, NULL);",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_detach_mark(mark);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\taudit_mark_put_chunk(chunk);",
            "\t\tfsnotify_free_mark(mark);",
            "\t\treturn;",
            "\t}",
            "",
            "\tnew = alloc_chunk(size);",
            "\tif (!new)",
            "\t\tgoto out_mutex;",
            "",
            "\tspin_lock(&hash_lock);",
            "\t/*",
            "\t * This has to go last when updating chunk as once replace_chunk() is",
            "\t * called, new RCU readers can see the new chunk.",
            "\t */",
            "\treplace_chunk(new, chunk);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\taudit_mark_put_chunk(chunk);",
            "\treturn;",
            "",
            "out_mutex:",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "}",
            "static int create_chunk(struct inode *inode, struct audit_tree *tree)",
            "{",
            "\tstruct fsnotify_mark *mark;",
            "\tstruct audit_chunk *chunk = alloc_chunk(1);",
            "",
            "\tif (!chunk) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tmark = alloc_mark();",
            "\tif (!mark) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tkfree(chunk);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\tif (fsnotify_add_inode_mark_locked(mark, inode, 0)) {",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn -ENOSPC;",
            "\t}",
            "",
            "\tspin_lock(&hash_lock);",
            "\tif (tree->goner) {",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tfsnotify_detach_mark(mark);",
            "\t\tfsnotify_group_unlock(audit_tree_group);",
            "\t\tfsnotify_free_mark(mark);",
            "\t\tfsnotify_put_mark(mark);",
            "\t\tkfree(chunk);",
            "\t\treturn 0;",
            "\t}",
            "\treplace_mark_chunk(mark, chunk);",
            "\tchunk->owners[0].index = (1U << 31);",
            "\tchunk->owners[0].owner = tree;",
            "\tget_tree(tree);",
            "\tlist_add(&chunk->owners[0].list, &tree->chunks);",
            "\tif (!tree->root) {",
            "\t\ttree->root = chunk;",
            "\t\tlist_add(&tree->same_root, &chunk->trees);",
            "\t}",
            "\tchunk->key = inode_to_key(inode);",
            "\t/*",
            "\t * Inserting into the hash table has to go last as once we do that RCU",
            "\t * readers can see the chunk.",
            "\t */",
            "\tinsert_hash(chunk);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(audit_tree_group);",
            "\t/*",
            "\t * Drop our initial reference. When mark we point to is getting freed,",
            "\t * we get notification through ->freeing_mark callback and cleanup",
            "\t * chunk pointing to this mark.",
            "\t */",
            "\tfsnotify_put_mark(mark);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "remove_chunk_node, chunk_count_trees, untag_chunk, create_chunk",
          "description": "实现文件节点标记的增删改查逻辑，包含chunk创建、旧chunk清理及哈希表更新。通过锁保护确保操作原子性，处理标记失效场景并释放无效资源，维持审计系统状态有效性。",
          "similarity": 0.4798435568809509
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/audit_tree.c",
          "start_line": 569,
          "end_line": 709,
          "content": [
            "static void prune_tree_chunks(struct audit_tree *victim, bool tagged)",
            "{",
            "\tspin_lock(&hash_lock);",
            "\twhile (!list_empty(&victim->chunks)) {",
            "\t\tstruct audit_node *p;",
            "\t\tstruct audit_chunk *chunk;",
            "\t\tstruct fsnotify_mark *mark;",
            "",
            "\t\tp = list_first_entry(&victim->chunks, struct audit_node, list);",
            "\t\t/* have we run out of marked? */",
            "\t\tif (tagged && !(p->index & (1U<<31)))",
            "\t\t\tbreak;",
            "\t\tchunk = find_chunk(p);",
            "\t\tmark = chunk->mark;",
            "\t\tremove_chunk_node(chunk, p);",
            "\t\t/* Racing with audit_tree_freeing_mark()? */",
            "\t\tif (!mark)",
            "\t\t\tcontinue;",
            "\t\tfsnotify_get_mark(mark);",
            "\t\tspin_unlock(&hash_lock);",
            "",
            "\t\tuntag_chunk(chunk, mark);",
            "\t\tfsnotify_put_mark(mark);",
            "",
            "\t\tspin_lock(&hash_lock);",
            "\t}",
            "\tspin_unlock(&hash_lock);",
            "}",
            "static void prune_one(struct audit_tree *victim)",
            "{",
            "\tprune_tree_chunks(victim, false);",
            "\tput_tree(victim);",
            "}",
            "static void trim_marked(struct audit_tree *tree)",
            "{",
            "\tstruct list_head *p, *q;",
            "\tspin_lock(&hash_lock);",
            "\tif (tree->goner) {",
            "\t\tspin_unlock(&hash_lock);",
            "\t\treturn;",
            "\t}",
            "\t/* reorder */",
            "\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {",
            "\t\tstruct audit_node *node = list_entry(p, struct audit_node, list);",
            "\t\tq = p->next;",
            "\t\tif (node->index & (1U<<31)) {",
            "\t\t\tlist_del_init(p);",
            "\t\t\tlist_add(p, &tree->chunks);",
            "\t\t}",
            "\t}",
            "\tspin_unlock(&hash_lock);",
            "",
            "\tprune_tree_chunks(tree, true);",
            "",
            "\tspin_lock(&hash_lock);",
            "\tif (!tree->root && !tree->goner) {",
            "\t\ttree->goner = 1;",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t\tkill_rules(audit_context(), tree);",
            "\t\tlist_del_init(&tree->list);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "\t\tprune_one(tree);",
            "\t} else {",
            "\t\tspin_unlock(&hash_lock);",
            "\t}",
            "}",
            "int audit_remove_tree_rule(struct audit_krule *rule)",
            "{",
            "\tstruct audit_tree *tree;",
            "\ttree = rule->tree;",
            "\tif (tree) {",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_del_init(&rule->rlist);",
            "\t\tif (list_empty(&tree->rules) && !tree->goner) {",
            "\t\t\ttree->root = NULL;",
            "\t\t\tlist_del_init(&tree->same_root);",
            "\t\t\ttree->goner = 1;",
            "\t\t\tlist_move(&tree->list, &prune_list);",
            "\t\t\trule->tree = NULL;",
            "\t\t\tspin_unlock(&hash_lock);",
            "\t\t\taudit_schedule_prune();",
            "\t\t\treturn 1;",
            "\t\t}",
            "\t\trule->tree = NULL;",
            "\t\tspin_unlock(&hash_lock);",
            "\t\treturn 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "void audit_trim_trees(void)",
            "{",
            "\tstruct list_head cursor;",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tlist_add(&cursor, &tree_list);",
            "\twhile (cursor.next != &tree_list) {",
            "\t\tstruct audit_tree *tree;",
            "\t\tstruct path path;",
            "\t\tstruct audit_node *node;",
            "\t\tstruct path *paths;",
            "\t\tstruct path array[16];",
            "\t\tint err;",
            "",
            "\t\ttree = container_of(cursor.next, struct audit_tree, list);",
            "\t\tget_tree(tree);",
            "\t\tlist_move(&cursor, &tree->list);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\terr = kern_path(tree->pathname, 0, &path);",
            "\t\tif (err)",
            "\t\t\tgoto skip_it;",
            "",
            "\t\tpaths = collect_paths(&path, array, 16);",
            "\t\tpath_put(&path);",
            "\t\tif (IS_ERR(paths))",
            "\t\t\tgoto skip_it;",
            "",
            "\t\tspin_lock(&hash_lock);",
            "\t\tlist_for_each_entry(node, &tree->chunks, list) {",
            "\t\t\tstruct audit_chunk *chunk = find_chunk(node);",
            "\t\t\t/* this could be NULL if the watch is dying else where... */",
            "\t\t\tnode->index |= 1U<<31;",
            "\t\t\tfor (struct path *p = paths; p->dentry; p++) {",
            "\t\t\t\tstruct inode *inode = p->dentry->d_inode;",
            "\t\t\t\tif (inode_to_key(inode) == chunk->key) {",
            "\t\t\t\t\tnode->index &= ~(1U<<31);",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tspin_unlock(&hash_lock);",
            "\t\ttrim_marked(tree);",
            "\t\tdrop_collected_paths(paths, array);",
            "skip_it:",
            "\t\tput_tree(tree);",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t}",
            "\tlist_del(&cursor);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "}"
          ],
          "function_name": "prune_tree_chunks, prune_one, trim_marked, audit_remove_tree_rule, audit_trim_trees",
          "description": "实现审计树的周期性清理机制，扫描并移除冗余chunk，通过标记位判断是否保留。结合路径收集和哈希表遍历，确保审计数据及时回收，防止内存泄露和性能下降。",
          "similarity": 0.4798310399055481
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/audit_tree.c",
          "start_line": 874,
          "end_line": 993,
          "content": [
            "int audit_tag_tree(char *old, char *new)",
            "{",
            "\tstruct list_head cursor, barrier;",
            "\tint failed = 0;",
            "\tstruct path path1, path2;",
            "\tstruct path array[16];",
            "\tstruct path *paths;",
            "\tint err;",
            "",
            "\terr = kern_path(new, 0, &path2);",
            "\tif (err)",
            "\t\treturn err;",
            "\tpaths = collect_paths(&path2, array, 16);",
            "\tpath_put(&path2);",
            "\tif (IS_ERR(paths))",
            "\t\treturn PTR_ERR(paths);",
            "",
            "\terr = kern_path(old, 0, &path1);",
            "\tif (err) {",
            "\t\tdrop_collected_paths(paths, array);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tlist_add(&barrier, &tree_list);",
            "\tlist_add(&cursor, &barrier);",
            "",
            "\twhile (cursor.next != &tree_list) {",
            "\t\tstruct audit_tree *tree;",
            "\t\tint good_one = 0;",
            "",
            "\t\ttree = container_of(cursor.next, struct audit_tree, list);",
            "\t\tget_tree(tree);",
            "\t\tlist_move(&cursor, &tree->list);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\terr = kern_path(tree->pathname, 0, &path2);",
            "\t\tif (!err) {",
            "\t\t\tgood_one = path_is_under(&path1, &path2);",
            "\t\t\tpath_put(&path2);",
            "\t\t}",
            "",
            "\t\tif (!good_one) {",
            "\t\t\tput_tree(tree);",
            "\t\t\tmutex_lock(&audit_filter_mutex);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tfailed = tag_mounts(paths, tree);",
            "\t\tif (failed) {",
            "\t\t\tput_tree(tree);",
            "\t\t\tmutex_lock(&audit_filter_mutex);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t\tspin_lock(&hash_lock);",
            "\t\tif (!tree->goner) {",
            "\t\t\tlist_move(&tree->list, &tree_list);",
            "\t\t}",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tput_tree(tree);",
            "\t}",
            "",
            "\twhile (barrier.prev != &tree_list) {",
            "\t\tstruct audit_tree *tree;",
            "",
            "\t\ttree = container_of(barrier.prev, struct audit_tree, list);",
            "\t\tget_tree(tree);",
            "\t\tlist_move(&tree->list, &barrier);",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\tif (!failed) {",
            "\t\t\tstruct audit_node *node;",
            "\t\t\tspin_lock(&hash_lock);",
            "\t\t\tlist_for_each_entry(node, &tree->chunks, list)",
            "\t\t\t\tnode->index &= ~(1U<<31);",
            "\t\t\tspin_unlock(&hash_lock);",
            "\t\t} else {",
            "\t\t\ttrim_marked(tree);",
            "\t\t}",
            "",
            "\t\tput_tree(tree);",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t}",
            "\tlist_del(&barrier);",
            "\tlist_del(&cursor);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\tpath_put(&path1);",
            "\tdrop_collected_paths(paths, array);",
            "\treturn failed;",
            "}",
            "static void audit_schedule_prune(void)",
            "{",
            "\twake_up_process(prune_thread);",
            "}",
            "void audit_kill_trees(struct audit_context *context)",
            "{",
            "\tstruct list_head *list = &context->killed_trees;",
            "",
            "\taudit_ctl_lock();",
            "\tmutex_lock(&audit_filter_mutex);",
            "",
            "\twhile (!list_empty(list)) {",
            "\t\tstruct audit_tree *victim;",
            "",
            "\t\tvictim = list_entry(list->next, struct audit_tree, list);",
            "\t\tkill_rules(context, victim);",
            "\t\tlist_del_init(&victim->list);",
            "",
            "\t\tmutex_unlock(&audit_filter_mutex);",
            "",
            "\t\tprune_one(victim);",
            "",
            "\t\tmutex_lock(&audit_filter_mutex);",
            "\t}",
            "",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\taudit_ctl_unlock();",
            "}"
          ],
          "function_name": "audit_tag_tree, audit_schedule_prune, audit_kill_trees",
          "description": "提供审计树状态同步与清理机制，audit_tag_tree用于路径变更时同步树结构，audit_schedule_prune唤醒修剪线程，audit_kill_trees处理上下文中被终止的审计树，通过互斥锁保护并发访问并执行规则清理。",
          "similarity": 0.47875872254371643
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/audit_tree.c",
          "start_line": 1006,
          "end_line": 1081,
          "content": [
            "static void evict_chunk(struct audit_chunk *chunk)",
            "{",
            "\tstruct audit_tree *owner;",
            "\tstruct list_head *postponed = audit_killed_trees();",
            "\tint need_prune = 0;",
            "\tint n;",
            "",
            "\tmutex_lock(&audit_filter_mutex);",
            "\tspin_lock(&hash_lock);",
            "\twhile (!list_empty(&chunk->trees)) {",
            "\t\towner = list_entry(chunk->trees.next,",
            "\t\t\t\t   struct audit_tree, same_root);",
            "\t\towner->goner = 1;",
            "\t\towner->root = NULL;",
            "\t\tlist_del_init(&owner->same_root);",
            "\t\tspin_unlock(&hash_lock);",
            "\t\tif (!postponed) {",
            "\t\t\tkill_rules(audit_context(), owner);",
            "\t\t\tlist_move(&owner->list, &prune_list);",
            "\t\t\tneed_prune = 1;",
            "\t\t} else {",
            "\t\t\tlist_move(&owner->list, postponed);",
            "\t\t}",
            "\t\tspin_lock(&hash_lock);",
            "\t}",
            "\tlist_del_rcu(&chunk->hash);",
            "\tfor (n = 0; n < chunk->count; n++)",
            "\t\tlist_del_init(&chunk->owners[n].list);",
            "\tspin_unlock(&hash_lock);",
            "\tmutex_unlock(&audit_filter_mutex);",
            "\tif (need_prune)",
            "\t\taudit_schedule_prune();",
            "}",
            "static int audit_tree_handle_event(struct fsnotify_mark *mark, u32 mask,",
            "\t\t\t\t   struct inode *inode, struct inode *dir,",
            "\t\t\t\t   const struct qstr *file_name, u32 cookie)",
            "{",
            "\treturn 0;",
            "}",
            "static void audit_tree_freeing_mark(struct fsnotify_mark *mark,",
            "\t\t\t\t    struct fsnotify_group *group)",
            "{",
            "\tstruct audit_chunk *chunk;",
            "",
            "\tfsnotify_group_lock(mark->group);",
            "\tspin_lock(&hash_lock);",
            "\tchunk = mark_chunk(mark);",
            "\treplace_mark_chunk(mark, NULL);",
            "\tspin_unlock(&hash_lock);",
            "\tfsnotify_group_unlock(mark->group);",
            "\tif (chunk) {",
            "\t\tevict_chunk(chunk);",
            "\t\taudit_mark_put_chunk(chunk);",
            "\t}",
            "",
            "\t/*",
            "\t * We are guaranteed to have at least one reference to the mark from",
            "\t * either the inode or the caller of fsnotify_destroy_mark().",
            "\t */",
            "\tBUG_ON(refcount_read(&mark->refcnt) < 1);",
            "}",
            "static int __init audit_tree_init(void)",
            "{",
            "\tint i;",
            "",
            "\taudit_tree_mark_cachep = KMEM_CACHE(audit_tree_mark, SLAB_PANIC);",
            "",
            "\taudit_tree_group = fsnotify_alloc_group(&audit_tree_ops, 0);",
            "\tif (IS_ERR(audit_tree_group))",
            "\t\taudit_panic(\"cannot initialize fsnotify group for rectree watches\");",
            "",
            "\tfor (i = 0; i < HASH_SIZE; i++)",
            "\t\tINIT_LIST_HEAD(&chunk_hash_heads[i]);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "evict_chunk, audit_tree_handle_event, audit_tree_freeing_mark, audit_tree_init",
          "description": "实现审计块管理与初始化，evict_chunk负责移除失效块关联的树结构并触发展开修剪，audit_tree_handle_event处理文件系统事件但当前无实际逻辑，audit_tree_freeing_mark在释放标记时触发块回收，audit_tree_init初始化缓存与fsnotify组结构。",
          "similarity": 0.47705313563346863
        }
      ]
    },
    {
      "source_file": "kernel/range.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:37:53\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `range.c`\n\n---\n\n# range.c 技术文档\n\n## 1. 文件概述\n\n`range.c` 是 Linux 内核中用于管理地址范围（range）集合的核心工具文件。它提供了一组操作函数，用于动态地添加、合并、删除和排序不连续的地址区间（通常表示物理内存或 I/O 地址范围）。这些操作在内存管理、资源分配、NUMA 拓扑构建等场景中被广泛使用，尤其适用于需要维护非重叠、有序地址区间的子系统。\n\n## 2. 核心功能\n\n### 数据结构\n- `struct range`：表示一个地址区间，包含 `start`（起始地址）和 `end`（结束地址，不包含）两个 `u64` 字段。\n\n### 主要函数\n- `int add_range(struct range *range, int az, int nr_range, u64 start, u64 end)`  \n  向范围数组中添加一个新的区间，不进行合并。\n- `int add_range_with_merge(struct range *range, int az, int nr_range, u64 start, u64 end)`  \n  添加新区间，并自动与已有区间合并重叠或相邻的部分。\n- `void subtract_range(struct range *range, int az, u64 start, u64 end)`  \n  从现有范围中减去指定区间，可能将一个区间拆分为两个。\n- `int clean_sort_range(struct range *range, int az)`  \n  清理数组中无效（`end == 0`）的条目，压缩有效区间到数组前端，并按起始地址排序，返回有效区间数量。\n- `void sort_range(struct range *range, int nr_range)`  \n  对指定数量的区间按起始地址进行排序。\n\n## 3. 关键实现\n\n### 区间合并逻辑（`add_range_with_merge`）\n1. 首先检查输入区间是否有效（`start < end`）。\n2. 遍历现有所有有效区间，查找与新区间有交集的部分：\n   - 若存在交集，则扩展新区间的 `start` 和 `end` 以覆盖合并后的范围。\n   - 将被合并的旧区间从数组中移除（通过 `memmove` 前移后续元素，并将末尾置零）。\n   - 由于移除了元素，需将索引 `i` 减 1 以重新检查当前位置。\n3. 最终将合并后的新区间通过 `add_range` 添加到数组末尾。\n\n### 区间相减逻辑（`subtract_range`）\n处理四种相交情况：\n1. **完全覆盖**：待减区间完全包含目标区间 → 将目标区间置为无效（`start = end = 0`）。\n2. **左覆盖**：待减区间覆盖目标区间的左部 → 将目标区间起始地址更新为 `end`。\n3. **右覆盖**：待减区间覆盖目标区间的右部 → 将目标区间结束地址更新为 `start`。\n4. **中间挖洞**：待减区间位于目标区间内部 → 将原区间拆分为两段：\n   - 原区间保留左段（`[start, subtract_start)`）。\n   - 在数组中寻找空闲槽位（`end == 0`），插入右段（`[subtract_end, original_end)`）。\n   - 若无空闲槽位，打印错误日志。\n\n### 数组清理与排序（`clean_sort_range`）\n- 采用双指针法：从前往后找无效项，从后往前找有效项，进行交换，将所有有效区间压缩到数组前端。\n- 遍历压缩后的数组，统计有效区间数量（首个 `end == 0` 的位置）。\n- 使用内核 `sort()` 函数按 `start` 升序排列有效区间。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/range.h>`：定义 `struct range`。\n  - `<linux/sort.h>`：提供 `sort()` 排序函数。\n  - `<linux/minmax.h>`：提供 `min()`/`max()` 宏。\n  - `<linux/printk.h>`：用于错误日志输出。\n  - `<linux/string.h>`：提供 `memmove()`。\n  - `<linux/init.h>`：可能用于初始化上下文（尽管本文件未直接使用初始化宏）。\n- **无外部模块依赖**：该文件为通用工具库，被多个内核子系统（如 `e820`、`memblock`、`ACPI`、`NUMA` 初始化等）直接调用。\n\n## 5. 使用场景\n\n- **物理内存布局管理**：在启动早期，通过 `e820` 或 `EFI` 获取物理内存范围后，使用 `add_range_with_merge` 合并连续内存块。\n- **内存热插拔/热移除**：动态调整可用内存范围时，使用 `subtract_range` 移除故障或离线内存区域。\n- **I/O 资源分配**：管理 PCI 或平台设备的 I/O 地址空间，避免冲突。\n- **NUMA 节点拓扑构建**：在解析 SRAT 表时，合并属于同一节点的内存范围。\n- **内核参数处理**：如 `mem=` 或 `memmap=` 参数指定的内存保留/排除区域，需与系统内存范围进行加减运算。\n- **资源冲突检测**：在设备枚举过程中，通过区间运算判断资源是否重叠。",
      "similarity": 0.5584911704063416,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/range.c",
          "start_line": 12,
          "end_line": 121,
          "content": [
            "int add_range(struct range *range, int az, int nr_range, u64 start, u64 end)",
            "{",
            "\tif (start >= end)",
            "\t\treturn nr_range;",
            "",
            "\t/* Out of slots: */",
            "\tif (nr_range >= az)",
            "\t\treturn nr_range;",
            "",
            "\trange[nr_range].start = start;",
            "\trange[nr_range].end = end;",
            "",
            "\tnr_range++;",
            "",
            "\treturn nr_range;",
            "}",
            "int add_range_with_merge(struct range *range, int az, int nr_range,",
            "\t\t     u64 start, u64 end)",
            "{",
            "\tint i;",
            "",
            "\tif (start >= end)",
            "\t\treturn nr_range;",
            "",
            "\t/* get new start/end: */",
            "\tfor (i = 0; i < nr_range; i++) {",
            "\t\tu64 common_start, common_end;",
            "",
            "\t\tif (!range[i].end)",
            "\t\t\tcontinue;",
            "",
            "\t\tcommon_start = max(range[i].start, start);",
            "\t\tcommon_end = min(range[i].end, end);",
            "\t\tif (common_start > common_end)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* new start/end, will add it back at last */",
            "\t\tstart = min(range[i].start, start);",
            "\t\tend = max(range[i].end, end);",
            "",
            "\t\tmemmove(&range[i], &range[i + 1],",
            "\t\t\t(nr_range - (i + 1)) * sizeof(range[i]));",
            "\t\trange[nr_range - 1].start = 0;",
            "\t\trange[nr_range - 1].end   = 0;",
            "\t\tnr_range--;",
            "\t\ti--;",
            "\t}",
            "",
            "\t/* Need to add it: */",
            "\treturn add_range(range, az, nr_range, start, end);",
            "}",
            "void subtract_range(struct range *range, int az, u64 start, u64 end)",
            "{",
            "\tint i, j;",
            "",
            "\tif (start >= end)",
            "\t\treturn;",
            "",
            "\tfor (j = 0; j < az; j++) {",
            "\t\tif (!range[j].end)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (start <= range[j].start && end >= range[j].end) {",
            "\t\t\trange[j].start = 0;",
            "\t\t\trange[j].end = 0;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (start <= range[j].start && end < range[j].end &&",
            "\t\t    range[j].start < end) {",
            "\t\t\trange[j].start = end;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "",
            "\t\tif (start > range[j].start && end >= range[j].end &&",
            "\t\t    range[j].end > start) {",
            "\t\t\trange[j].end = start;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (start > range[j].start && end < range[j].end) {",
            "\t\t\t/* Find the new spare: */",
            "\t\t\tfor (i = 0; i < az; i++) {",
            "\t\t\t\tif (range[i].end == 0)",
            "\t\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tif (i < az) {",
            "\t\t\t\trange[i].end = range[j].end;",
            "\t\t\t\trange[i].start = end;",
            "\t\t\t} else {",
            "\t\t\t\tpr_err(\"%s: run out of slot in ranges\\n\",",
            "\t\t\t\t\t__func__);",
            "\t\t\t}",
            "\t\t\trange[j].end = start;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t}",
            "}",
            "static int cmp_range(const void *x1, const void *x2)",
            "{",
            "\tconst struct range *r1 = x1;",
            "\tconst struct range *r2 = x2;",
            "",
            "\tif (r1->start < r2->start)",
            "\t\treturn -1;",
            "\tif (r1->start > r2->start)",
            "\t\treturn 1;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "add_range, add_range_with_merge, subtract_range, cmp_range",
          "description": "实现范围添加与合并操作，add_range将新区间追加至数组，add_range_with_merge合并重叠区间并通过memmove优化存储，subtract_range执行区间差集计算，cmp_range用于范围排序比较。",
          "similarity": 0.49976786971092224
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/range.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Range add and subtract",
            " */",
            "#include <linux/init.h>",
            "#include <linux/minmax.h>",
            "#include <linux/printk.h>",
            "#include <linux/sort.h>",
            "#include <linux/string.h>",
            "#include <linux/range.h>",
            ""
          ],
          "function_name": null,
          "description": "定义范围操作模块的头文件，包含GPL-2.0许可证声明及基础依赖项，为后续范围运算提供类型和宏定义支持。",
          "similarity": 0.47579795122146606
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/range.c",
          "start_line": 126,
          "end_line": 164,
          "content": [
            "int clean_sort_range(struct range *range, int az)",
            "{",
            "\tint i, j, k = az - 1, nr_range = az;",
            "",
            "\tfor (i = 0; i < k; i++) {",
            "\t\tif (range[i].end)",
            "\t\t\tcontinue;",
            "\t\tfor (j = k; j > i; j--) {",
            "\t\t\tif (range[j].end) {",
            "\t\t\t\tk = j;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (j == i)",
            "\t\t\tbreak;",
            "\t\trange[i].start = range[k].start;",
            "\t\trange[i].end   = range[k].end;",
            "\t\trange[k].start = 0;",
            "\t\trange[k].end   = 0;",
            "\t\tk--;",
            "\t}",
            "\t/* count it */",
            "\tfor (i = 0; i < az; i++) {",
            "\t\tif (!range[i].end) {",
            "\t\t\tnr_range = i;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\t/* sort them */",
            "\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);",
            "",
            "\treturn nr_range;",
            "}",
            "void sort_range(struct range *range, int nr_range)",
            "{",
            "\t/* sort them */",
            "\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);",
            "}"
          ],
          "function_name": "clean_sort_range, sort_range",
          "description": "clean_sort_range清理空闲范围槽位并排序有效区间，sort_range直接对有效范围数组进行排序，通过cmp_range保证区间按起始地址升序排列。",
          "similarity": 0.4355669915676117
        }
      ]
    }
  ]
}