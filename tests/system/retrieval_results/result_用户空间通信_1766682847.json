{
  "query": "用户空间通信",
  "timestamp": "2025-12-26 01:14:07",
  "retrieved_files": [
    {
      "source_file": "kernel/power/user.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:28:21\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `power\\user.c`\n\n---\n\n# power/user.c 技术文档\n\n## 1. 文件概述\n\n`power/user.c` 是 Linux 内核中实现用户空间与休眠（Hibernate）/恢复（Resume）功能交互的核心接口文件。该文件通过字符设备 `/dev/snapshot` 向用户空间提供对系统内存快照的读写能力，支持创建休眠镜像（保存系统状态）和从镜像恢复系统状态。它实现了软件休眠机制的用户态控制路径，是 hibernation 子系统的关键组成部分。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`struct snapshot_data`**：保存当前快照操作的上下文状态，包括：\n  - `handle`：快照操作句柄（`struct snapshot_handle`）\n  - `swap`：使用的交换分区类型索引\n  - `mode`：打开模式（`O_RDONLY` 表示休眠，`O_WRONLY` 表示恢复）\n  - `frozen`：是否已冻结用户进程\n  - `ready`：快照是否准备就绪\n  - `platform_support`：是否启用平台特定的休眠支持（如 ACPI S4）\n  - `free_bitmaps`：是否需要释放内存位图\n  - `dev`：恢复所用的设备号\n\n- **`static bool need_wait`**：标志是否需要等待设备探测完成（用于恢复流程）\n\n### 主要函数\n- **`snapshot_open()`**：设备打开函数，初始化快照上下文，根据打开模式（读/写）执行休眠或恢复的前期准备。\n- **`snapshot_release()`**：设备关闭函数，清理资源，释放内存位图，解冻进程，发送 PM 通知。\n- **`snapshot_read()`**：从内存快照中读取数据到用户空间（用于休眠时保存镜像）。\n- **`snapshot_write()`**：从用户空间写入数据到内存快照（用于恢复时加载镜像）。\n- **`snapshot_ioctl()`**：设备控制接口，支持多种休眠/恢复控制命令。\n- **`snapshot_set_swap_area()`**：设置恢复时使用的交换区域（兼容 32/64 位系统调用）。\n- **`is_hibernate_resume_dev()`**：判断指定设备是否为当前休眠恢复设备。\n\n### 关键 ioctl 命令\n- `SNAPSHOT_FREEZE`：冻结用户空间进程。\n- `SNAPSHOT_UNFREEZE`：解冻用户空间进程。\n- `SNAPSHOT_CREATE_IMAGE`：创建内存快照镜像（休眠）。\n- `SNAPSHOT_ATOMIC_RESTORE`：原子性地从镜像恢复系统。\n- `SNAPSHOT_FREE`：释放快照相关内存。\n- `SNAPSHOT_PREF_IMAGE_SIZE` / `SNAPSHOT_GET_IMAGE_SIZE`：设置/获取镜像大小。\n- `SNAPSHOT_AVAIL_SWAP_SIZE` / `SNAPSHOT_ALLOC_SWAP_PAGE`：管理交换空间分配。\n\n## 3. 关键实现\n\n### 休眠（Suspend-to-Disk）流程\n1. 用户空间以 `O_RDONLY` 打开 `/dev/snapshot`。\n2. 调用 `SNAPSHOT_FREEZE` 冻结所有用户进程。\n3. 调用 `SNAPSHOT_CREATE_IMAGE` 创建内存快照，内核将可恢复的内存页信息组织成镜像。\n4. 用户空间通过 `read()` 系统调用从设备读取镜像数据，并写入交换分区。\n5. 系统关机。\n\n### 恢复（Resume）流程\n1. 启动时内核检测到休眠镜像，但用户空间需主动参与恢复。\n2. 用户空间以 `O_WRONLY` 打开 `/dev/snapshot`。\n3. 通过 `ioctl(SNAPSHOT_SET_SWAP_AREA)` 指定镜像所在的交换设备。\n4. 用户空间从交换分区读取镜像数据，通过 `write()` 写入 `/dev/snapshot`。\n5. 调用 `SNAPSHOT_FREEZE` 冻结当前进程（为恢复做准备）。\n6. 调用 `SNAPSHOT_ATOMIC_RESTORE` 触发内核原子恢复，跳转回休眠时的执行上下文。\n\n### 内存管理\n- 使用 `create_basic_memory_bitmaps()` / `free_basic_memory_bitmaps()` 管理内存页的位图，标记哪些页需要保存/恢复。\n- 通过 `swsusp_free()` 释放休眠专用的内存缓冲区。\n- `alloc_swapdev_block()` 用于在休眠过程中分配交换页。\n\n### 同步与锁机制\n- 使用 `lock_system_sleep()` / `unlock_system_sleep()` 确保休眠操作的原子性。\n- 通过 `mutex_trylock(&system_transition_mutex)` 防止并发的系统状态转换。\n- `lock_device_hotplug()` 防止设备热插拔干扰休眠过程。\n\n### 兼容性处理\n- 通过 `in_compat_syscall()` 区分 32 位和 64 位系统调用，使用 `compat_resume_swap_area` 结构保证 ABI 兼容。\n\n## 4. 依赖关系\n\n- **`<linux/suspend.h>` / `power.h`**：休眠核心逻辑和数据结构定义。\n- **`<linux/swap.h>` / `<linux/swapops.h>`**：交换子系统接口，用于管理休眠镜像的存储。\n- **`<linux/freezer.h>`**：进程冻结/解冻机制。\n- **`<linux/pm.h>`**：电源管理通知链（`pm_notifier_call_chain`）。\n- **`<linux/miscdevice.h>`**：注册 `/dev/snapshot` 字符设备。\n- **`<linux/uaccess.h>`**：用户空间内存访问（`copy_from_user` 等）。\n- **`<linux/compat.h>`**：32/64 位系统调用兼容层。\n- **`hibernate.c`**：依赖 `hibernate_acquire()` / `hibernate_release()` 管理休眠资源。\n\n## 5. 使用场景\n\n- **系统休眠（Hibernation）**：当用户执行 `systemctl hibernate` 或类似命令时，用户空间工具（如 `uswsusp` 或 `systemd-hibernate`) 通过此接口保存系统状态到交换分区。\n- **系统恢复（Resume）**：在内核启动早期，initramfs 中的恢复工具（如 `resume` 脚本）通过此接口从交换分区加载镜像并触发恢复。\n- **调试与测试**：开发人员可通过直接操作 `/dev/snapshot` 设备测试休眠/恢复逻辑。\n- **定制休眠方案**：嵌入式或特殊用途系统可基于此接口实现自定义的休眠存储后端（如存储到文件而非交换分区）。",
      "similarity": 0.5779919028282166,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/power/user.c",
          "start_line": 1,
          "end_line": 41,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * linux/kernel/power/user.c",
            " *",
            " * This file provides the user space interface for software suspend/resume.",
            " *",
            " * Copyright (C) 2006 Rafael J. Wysocki <rjw@sisk.pl>",
            " */",
            "",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/swap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pm.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/console.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "#include \"power.h\"",
            "",
            "static bool need_wait;",
            "",
            "static struct snapshot_data {",
            "\tstruct snapshot_handle handle;",
            "\tint swap;",
            "\tint mode;",
            "\tbool frozen;",
            "\tbool ready;",
            "\tbool platform_support;",
            "\tbool free_bitmaps;",
            "\tdev_t dev;",
            "} snapshot_state;",
            ""
          ],
          "function_name": null,
          "description": "定义了支持软件挂起/恢复的用户空间接口所需的全局变量和辅助结构体，包括用于跟踪快照状态的snapshot_state结构体及need_wait标志位。",
          "similarity": 0.5386003255844116
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/power/user.c",
          "start_line": 424,
          "end_line": 444,
          "content": [
            "static long",
            "snapshot_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)",
            "{",
            "\tBUILD_BUG_ON(sizeof(loff_t) != sizeof(compat_loff_t));",
            "",
            "\tswitch (cmd) {",
            "\tcase SNAPSHOT_GET_IMAGE_SIZE:",
            "\tcase SNAPSHOT_AVAIL_SWAP_SIZE:",
            "\tcase SNAPSHOT_ALLOC_SWAP_PAGE:",
            "\tcase SNAPSHOT_CREATE_IMAGE:",
            "\tcase SNAPSHOT_SET_SWAP_AREA:",
            "\t\treturn snapshot_ioctl(file, cmd,",
            "\t\t\t\t      (unsigned long) compat_ptr(arg));",
            "\tdefault:",
            "\t\treturn snapshot_ioctl(file, cmd, arg);",
            "\t}",
            "}",
            "static int __init snapshot_device_init(void)",
            "{",
            "\treturn misc_register(&snapshot_device);",
            "};"
          ],
          "function_name": "snapshot_compat_ioctl, snapshot_device_init",
          "description": "提供32位兼容性的ioctl处理函数和设备初始化函数，注册快照字符设备驱动以实现用户空间与内核电源管理子系统的交互。",
          "similarity": 0.5274056792259216
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/power/user.c",
          "start_line": 168,
          "end_line": 414,
          "content": [
            "static ssize_t snapshot_write(struct file *filp, const char __user *buf,",
            "                              size_t count, loff_t *offp)",
            "{",
            "\tloff_t pg_offp = *offp & ~PAGE_MASK;",
            "\tstruct snapshot_data *data;",
            "\tunsigned long sleep_flags;",
            "\tssize_t res;",
            "",
            "\tif (need_wait) {",
            "\t\twait_for_device_probe();",
            "\t\tneed_wait = false;",
            "\t}",
            "",
            "\tsleep_flags = lock_system_sleep();",
            "",
            "\tdata = filp->private_data;",
            "",
            "\tif (!pg_offp) {",
            "\t\tres = snapshot_write_next(&data->handle);",
            "\t\tif (res <= 0)",
            "\t\t\tgoto unlock;",
            "\t} else {",
            "\t\tres = PAGE_SIZE;",
            "\t}",
            "",
            "\tif (!data_of(data->handle)) {",
            "\t\tres = -EINVAL;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\tres = simple_write_to_buffer(data_of(data->handle), res, &pg_offp,",
            "\t\t\tbuf, count);",
            "\tif (res > 0)",
            "\t\t*offp += res;",
            "unlock:",
            "\tunlock_system_sleep(sleep_flags);",
            "",
            "\treturn res;",
            "}",
            "static int snapshot_set_swap_area(struct snapshot_data *data,",
            "\t\tvoid __user *argp)",
            "{",
            "\tsector_t offset;",
            "\tdev_t swdev;",
            "",
            "\tif (swsusp_swap_in_use())",
            "\t\treturn -EPERM;",
            "",
            "\tif (in_compat_syscall()) {",
            "\t\tstruct compat_resume_swap_area swap_area;",
            "",
            "\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))",
            "\t\t\treturn -EFAULT;",
            "\t\tswdev = new_decode_dev(swap_area.dev);",
            "\t\toffset = swap_area.offset;",
            "\t} else {",
            "\t\tstruct resume_swap_area swap_area;",
            "",
            "\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))",
            "\t\t\treturn -EFAULT;",
            "\t\tswdev = new_decode_dev(swap_area.dev);",
            "\t\toffset = swap_area.offset;",
            "\t}",
            "",
            "\t/*",
            "\t * User space encodes device types as two-byte values,",
            "\t * so we need to recode them",
            "\t */",
            "\tdata->swap = swap_type_of(swdev, offset);",
            "\tif (data->swap < 0)",
            "\t\treturn swdev ? -ENODEV : -EINVAL;",
            "\tdata->dev = swdev;",
            "\treturn 0;",
            "}",
            "static long snapshot_ioctl(struct file *filp, unsigned int cmd,",
            "\t\t\t\t\t\t\tunsigned long arg)",
            "{",
            "\tint error = 0;",
            "\tstruct snapshot_data *data;",
            "\tloff_t size;",
            "\tsector_t offset;",
            "",
            "\tif (need_wait) {",
            "\t\twait_for_device_probe();",
            "\t\tneed_wait = false;",
            "\t}",
            "",
            "\tif (_IOC_TYPE(cmd) != SNAPSHOT_IOC_MAGIC)",
            "\t\treturn -ENOTTY;",
            "\tif (_IOC_NR(cmd) > SNAPSHOT_IOC_MAXNR)",
            "\t\treturn -ENOTTY;",
            "\tif (!capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tif (!mutex_trylock(&system_transition_mutex))",
            "\t\treturn -EBUSY;",
            "",
            "\tlock_device_hotplug();",
            "\tdata = filp->private_data;",
            "",
            "\tswitch (cmd) {",
            "",
            "\tcase SNAPSHOT_FREEZE:",
            "\t\tif (data->frozen)",
            "\t\t\tbreak;",
            "",
            "\t\tksys_sync_helper();",
            "",
            "\t\terror = freeze_processes();",
            "\t\tif (error)",
            "\t\t\tbreak;",
            "",
            "\t\terror = create_basic_memory_bitmaps();",
            "\t\tif (error)",
            "\t\t\tthaw_processes();",
            "\t\telse",
            "\t\t\tdata->frozen = true;",
            "",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_UNFREEZE:",
            "\t\tif (!data->frozen || data->ready)",
            "\t\t\tbreak;",
            "\t\tpm_restore_gfp_mask();",
            "\t\tfree_basic_memory_bitmaps();",
            "\t\tdata->free_bitmaps = false;",
            "\t\tthaw_processes();",
            "\t\tdata->frozen = false;",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_CREATE_IMAGE:",
            "\t\tif (data->mode != O_RDONLY || !data->frozen  || data->ready) {",
            "\t\t\terror = -EPERM;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tpm_restore_gfp_mask();",
            "\t\terror = hibernation_snapshot(data->platform_support);",
            "\t\tif (!error) {",
            "\t\t\terror = put_user(in_suspend, (int __user *)arg);",
            "\t\t\tdata->ready = !freezer_test_done && !error;",
            "\t\t\tfreezer_test_done = false;",
            "\t\t}",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_ATOMIC_RESTORE:",
            "\t\tsnapshot_write_finalize(&data->handle);",
            "\t\tif (data->mode != O_WRONLY || !data->frozen ||",
            "\t\t    !snapshot_image_loaded(&data->handle)) {",
            "\t\t\terror = -EPERM;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\terror = hibernation_restore(data->platform_support);",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_FREE:",
            "\t\tswsusp_free();",
            "\t\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));",
            "\t\tdata->ready = false;",
            "\t\t/*",
            "\t\t * It is necessary to thaw kernel threads here, because",
            "\t\t * SNAPSHOT_CREATE_IMAGE may be invoked directly after",
            "\t\t * SNAPSHOT_FREE.  In that case, if kernel threads were not",
            "\t\t * thawed, the preallocation of memory carried out by",
            "\t\t * hibernation_snapshot() might run into problems (i.e. it",
            "\t\t * might fail or even deadlock).",
            "\t\t */",
            "\t\tthaw_kernel_threads();",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_PREF_IMAGE_SIZE:",
            "\t\timage_size = arg;",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_GET_IMAGE_SIZE:",
            "\t\tif (!data->ready) {",
            "\t\t\terror = -ENODATA;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tsize = snapshot_get_image_size();",
            "\t\tsize <<= PAGE_SHIFT;",
            "\t\terror = put_user(size, (loff_t __user *)arg);",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_AVAIL_SWAP_SIZE:",
            "\t\tsize = count_swap_pages(data->swap, 1);",
            "\t\tsize <<= PAGE_SHIFT;",
            "\t\terror = put_user(size, (loff_t __user *)arg);",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_ALLOC_SWAP_PAGE:",
            "\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {",
            "\t\t\terror = -ENODEV;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\toffset = alloc_swapdev_block(data->swap);",
            "\t\tif (offset) {",
            "\t\t\toffset <<= PAGE_SHIFT;",
            "\t\t\terror = put_user(offset, (loff_t __user *)arg);",
            "\t\t} else {",
            "\t\t\terror = -ENOSPC;",
            "\t\t}",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_FREE_SWAP_PAGES:",
            "\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {",
            "\t\t\terror = -ENODEV;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tfree_all_swap_pages(data->swap);",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_S2RAM:",
            "\t\tif (!data->frozen) {",
            "\t\t\terror = -EPERM;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t/*",
            "\t\t * Tasks are frozen and the notifiers have been called with",
            "\t\t * PM_HIBERNATION_PREPARE",
            "\t\t */",
            "\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);",
            "\t\tdata->ready = false;",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_PLATFORM_SUPPORT:",
            "\t\tdata->platform_support = !!arg;",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_POWER_OFF:",
            "\t\tif (data->platform_support)",
            "\t\t\terror = hibernation_platform_enter();",
            "\t\tbreak;",
            "",
            "\tcase SNAPSHOT_SET_SWAP_AREA:",
            "\t\terror = snapshot_set_swap_area(data, (void __user *)arg);",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\terror = -ENOTTY;",
            "",
            "\t}",
            "",
            "\tunlock_device_hotplug();",
            "\tmutex_unlock(&system_transition_mutex);",
            "",
            "\treturn error;",
            "}"
          ],
          "function_name": "snapshot_write, snapshot_set_swap_area, snapshot_ioctl",
          "description": "实现快照设备的写入、交换区设置和通用控制命令处理，包含对内存镜像创建、恢复、页面分配等关键操作的支持，并通过ioctl接口暴露多种系统控制功能。",
          "similarity": 0.4884992241859436
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/power/user.c",
          "start_line": 42,
          "end_line": 163,
          "content": [
            "int is_hibernate_resume_dev(dev_t dev)",
            "{",
            "\treturn hibernation_available() && snapshot_state.dev == dev;",
            "}",
            "static int snapshot_open(struct inode *inode, struct file *filp)",
            "{",
            "\tstruct snapshot_data *data;",
            "\tunsigned int sleep_flags;",
            "\tint error;",
            "",
            "\tif (!hibernation_available())",
            "\t\treturn -EPERM;",
            "",
            "\tsleep_flags = lock_system_sleep();",
            "",
            "\tif (!hibernate_acquire()) {",
            "\t\terror = -EBUSY;",
            "\t\tgoto Unlock;",
            "\t}",
            "",
            "\tif ((filp->f_flags & O_ACCMODE) == O_RDWR) {",
            "\t\thibernate_release();",
            "\t\terror = -ENOSYS;",
            "\t\tgoto Unlock;",
            "\t}",
            "\tnonseekable_open(inode, filp);",
            "\tdata = &snapshot_state;",
            "\tfilp->private_data = data;",
            "\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));",
            "\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY) {",
            "\t\t/* Hibernating.  The image device should be accessible. */",
            "\t\tdata->swap = swap_type_of(swsusp_resume_device, 0);",
            "\t\tdata->mode = O_RDONLY;",
            "\t\tdata->free_bitmaps = false;",
            "\t\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);",
            "\t} else {",
            "\t\t/*",
            "\t\t * Resuming.  We may need to wait for the image device to",
            "\t\t * appear.",
            "\t\t */",
            "\t\tneed_wait = true;",
            "",
            "\t\tdata->swap = -1;",
            "\t\tdata->mode = O_WRONLY;",
            "\t\terror = pm_notifier_call_chain_robust(PM_RESTORE_PREPARE, PM_POST_RESTORE);",
            "\t\tif (!error) {",
            "\t\t\terror = create_basic_memory_bitmaps();",
            "\t\t\tdata->free_bitmaps = !error;",
            "\t\t}",
            "\t}",
            "\tif (error)",
            "\t\thibernate_release();",
            "",
            "\tdata->frozen = false;",
            "\tdata->ready = false;",
            "\tdata->platform_support = false;",
            "\tdata->dev = 0;",
            "",
            " Unlock:",
            "\tunlock_system_sleep(sleep_flags);",
            "",
            "\treturn error;",
            "}",
            "static int snapshot_release(struct inode *inode, struct file *filp)",
            "{",
            "\tstruct snapshot_data *data;",
            "\tunsigned int sleep_flags;",
            "",
            "\tsleep_flags = lock_system_sleep();",
            "",
            "\tswsusp_free();",
            "\tdata = filp->private_data;",
            "\tdata->dev = 0;",
            "\tfree_all_swap_pages(data->swap);",
            "\tif (data->frozen) {",
            "\t\tpm_restore_gfp_mask();",
            "\t\tfree_basic_memory_bitmaps();",
            "\t\tthaw_processes();",
            "\t} else if (data->free_bitmaps) {",
            "\t\tfree_basic_memory_bitmaps();",
            "\t}",
            "\tpm_notifier_call_chain(data->mode == O_RDONLY ?",
            "\t\t\tPM_POST_HIBERNATION : PM_POST_RESTORE);",
            "\thibernate_release();",
            "",
            "\tunlock_system_sleep(sleep_flags);",
            "",
            "\treturn 0;",
            "}",
            "static ssize_t snapshot_read(struct file *filp, char __user *buf,",
            "                             size_t count, loff_t *offp)",
            "{",
            "\tloff_t pg_offp = *offp & ~PAGE_MASK;",
            "\tstruct snapshot_data *data;",
            "\tunsigned int sleep_flags;",
            "\tssize_t res;",
            "",
            "\tsleep_flags = lock_system_sleep();",
            "",
            "\tdata = filp->private_data;",
            "\tif (!data->ready) {",
            "\t\tres = -ENODATA;",
            "\t\tgoto Unlock;",
            "\t}",
            "\tif (!pg_offp) { /* on page boundary? */",
            "\t\tres = snapshot_read_next(&data->handle);",
            "\t\tif (res <= 0)",
            "\t\t\tgoto Unlock;",
            "\t} else {",
            "\t\tres = PAGE_SIZE - pg_offp;",
            "\t}",
            "",
            "\tres = simple_read_from_buffer(buf, count, &pg_offp,",
            "\t\t\tdata_of(data->handle), res);",
            "\tif (res > 0)",
            "\t\t*offp += res;",
            "",
            " Unlock:",
            "\tunlock_system_sleep(sleep_flags);",
            "",
            "\treturn res;",
            "}"
          ],
          "function_name": "is_hibernate_resume_dev, snapshot_open, snapshot_release, snapshot_read",
          "description": "实现快照设备的打开、释放和读取操作，其中snapshot_open初始化快照状态并配置设备参数，snapshot_read从快照设备中分页读取数据。",
          "similarity": 0.4159134030342102
        }
      ]
    },
    {
      "source_file": "kernel/user_namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:46:37\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user_namespace.c`\n\n---\n\n# user_namespace.c 技术文档\n\n## 1. 文件概述\n\n`user_namespace.c` 是 Linux 内核中实现用户命名空间（User Namespace）核心功能的源文件。用户命名空间是 Linux 命名空间机制的一部分，用于隔离用户和组 ID（UID/GID），使得不同命名空间中的相同 UID 可以映射到宿主系统中的不同实际 UID/GID。该文件负责用户命名空间的创建、销毁、引用计数管理、ID 映射查找以及与凭证（credentials）的集成，是容器化技术（如 Docker、LXC）实现非特权容器和用户隔离的关键组件。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`create_user_ns(struct cred *new)`**  \n  创建一个新的用户命名空间，设置其父命名空间、层级、所有者、资源限制，并初始化凭证中的命名空间指针。\n\n- **`unshare_userns(unsigned long unshare_flags, struct cred **new_cred)`**  \n  为当前进程创建新的用户命名空间（通过 `unshare(CLONE_NEWUSER)` 系统调用触发），并返回新的凭证结构。\n\n- **`free_user_ns(struct work_struct *work)`**  \n  异步释放用户命名空间及其关联资源（如 ID 映射、sysctl 表、密钥环等），通过工作队列延迟执行以避免死锁。\n\n- **`__put_user_ns(struct user_namespace *ns)`**  \n  减少用户命名空间引用计数，若引用计数归零则调度 `free_user_ns` 工作项进行释放。\n\n- **`map_id_range_down_base()` / `map_id_range_down_max()`**  \n  在 UID/GID 映射表中查找指定 ID 范围对应的映射条目，分别处理小规模（≤4 条）和大规模（>4 条）映射。\n\n- **`cmp_map_id()`**  \n  用于二分查找的比较函数，支持正向（内核 ID → 用户 ID）和反向（用户 ID → 内核 ID）映射查询。\n\n- **`set_cred_user_ns()`**  \n  初始化新凭证中的用户命名空间相关字段，包括能力集（capabilities）、安全位（securebits）和密钥认证上下文。\n\n- **`enforced_nproc_rlimit()`**  \n  根据当前用户是否为全局 root 以及是否处于初始用户命名空间，决定是否对 `RLIMIT_NPROC` 施加限制。\n\n### 主要数据结构\n\n- **`struct user_namespace`**  \n  用户命名空间的核心结构体，包含父命名空间指针、层级、所有者 UID/GID、ID 映射表（uid_map、gid_map、projid_map）、资源使用计数器（ucounts）、引用计数、标志位、密钥环列表等。\n\n- **`struct idmap_key`**  \n  用于 ID 映射查找的辅助结构，封装待查找的 ID、范围长度及映射方向（向上/向下）。\n\n- **`struct uid_gid_extent`**  \n  表示单个 UID/GID 映射区间的结构，包含起始内核 ID、起始用户 ID 和映射长度。\n\n## 3. 关键实现\n\n### 用户命名空间创建流程\n1. **层级限制检查**：防止命名空间嵌套过深（最大 32 层）。\n2. **资源计数**：通过 `inc_user_namespaces()` 增加父命名空间中创建者的用户命名空间使用计数。\n3. **安全策略验证**：\n   - 禁止在 chroot 环境中创建新用户命名空间。\n   - 确保创建者的 UID/GID 在父命名空间中有有效映射。\n4. **安全模块回调**：调用 LSM（如 SELinux、AppArmor）的 `security_create_user_ns()` 钩子进行权限检查。\n5. **初始化新命名空间**：\n   - 分配内存并设置层级、所有者、父指针。\n   - 初始化资源限制（如进程数、消息队列大小等）。\n   - 继承父命名空间的标志（如 `USERNS_SETGROUPS_ALLOWED`）。\n   - 设置凭证中的用户命名空间指针并重置能力集。\n\n### ID 映射查找算法\n- **小规模映射（≤4 条）**：使用线性遍历（`map_id_range_down_base`）。\n- **大规模映射（>4 条）**：使用二分查找（`map_id_range_down_max` + `bsearch`），映射表按 `first` 字段排序。\n- **双向映射支持**：通过 `idmap_key.map_up` 标志区分内核 ID → 用户 ID（map down）和用户 ID → 内核 ID（map up）。\n\n### 异步释放机制\n- 使用 `INIT_WORK()` 将释放操作注册为工作队列任务。\n- 在 `free_user_ns()` 中循环释放命名空间链（处理引用计数级联归零的情况）。\n- 释放动态分配的映射表内存、sysctl 表、密钥环资源，并减少资源使用计数。\n\n### 能力与安全上下文初始化\n- 新命名空间的初始凭证拥有 `CAP_FULL_SET`，但这些能力仅在新命名空间内有效。\n- 清除请求密钥认证（`request_key_auth`）上下文，防止跨命名空间密钥泄露。\n- 重置安全位（`securebits`）为默认值。\n\n## 4. 依赖关系\n\n- **命名空间基础设施**：依赖 `<linux/nsproxy.h>` 和 `ns_common` 结构，与 `proc_ns.c` 协作提供 `/proc/<pid>/ns/user` 接口。\n- **凭证管理**：与 `<linux/cred.h>` 紧密集成，通过 `prepare_creds()`/`put_cred()` 管理凭证生命周期。\n- **资源计数**：使用 `<linux/user_namespace.h>` 中的 `ucounts` 机制跟踪用户命名空间、进程数等资源使用。\n- **安全模块**：通过 LSM 接口（`security_create_user_ns()`）与安全子系统交互。\n- **密钥管理**：依赖 `<keys/user-type.h>` 实现命名空间隔离的用户密钥环。\n- **内存管理**：使用 SLAB 分配器（`kmem_cache`）高效分配 `user_namespace` 结构。\n- **ID 映射**：与 `uidgid.c` 协同实现 UID/GID 映射的设置与查询。\n\n## 5. 使用场景\n\n- **容器运行时**：Docker、Podman、LXC 等通过 `unshare(CLONE_NEWUSER)` 创建非特权容器，实现用户隔离。\n- **用户态命名空间管理**：`unshare(1)` 命令或 `clone(2)` 系统调用创建独立用户上下文。\n- **特权降级**：进程在创建用户命名空间后映射自身为新命名空间的 root，获得有限特权。\n- **安全沙箱**：浏览器、应用沙箱利用用户命名空间限制潜在攻击面。\n- **ID 映射服务**：`newuidmap`/`newgidmap` 工具通过写入 `/proc/<pid>/uid_map` 配置映射，内核通过本文件中的查找函数解析映射关系。\n- **资源隔离**：结合 `ucounts` 机制限制单个用户可创建的用户命名空间数量，防止资源耗尽攻击。",
      "similarity": 0.5768723487854004,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/user_namespace.c",
          "start_line": 1,
          "end_line": 40,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "#include <linux/export.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/highuid.h>",
            "#include <linux/cred.h>",
            "#include <linux/securebits.h>",
            "#include <linux/security.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ctype.h>",
            "#include <linux/projid.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/sort.h>",
            "#ifdef CONFIG_CREDP",
            "#include <asm/iee-cred.h>",
            "#endif",
            "",
            "static struct kmem_cache *user_ns_cachep __ro_after_init;",
            "static DEFINE_MUTEX(userns_state_mutex);",
            "",
            "static bool new_idmap_permitted(const struct file *file,",
            "\t\t\t\tstruct user_namespace *ns, int cap_setid,",
            "\t\t\t\tstruct uid_gid_map *map);",
            "static void free_user_ns(struct work_struct *work);",
            "",
            "static struct ucounts *inc_user_namespaces(struct user_namespace *ns, kuid_t uid)",
            "{",
            "\treturn inc_ucount(ns, uid, UCOUNT_USER_NAMESPACES);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义用户命名空间相关全局变量和缓存，声明辅助函数及用户命名空间操作的通用接口。",
          "similarity": 0.6500383615493774
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/user_namespace.c",
          "start_line": 41,
          "end_line": 180,
          "content": [
            "static void dec_user_namespaces(struct ucounts *ucounts)",
            "{",
            "\treturn dec_ucount(ucounts, UCOUNT_USER_NAMESPACES);",
            "}",
            "static void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)",
            "{",
            "\t/* Start with the same capabilities as init but useless for doing",
            "\t * anything as the capabilities are bound to the new user namespace.",
            "\t */",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_securebits(cred, SECUREBITS_DEFAULT);",
            "\tiee_set_cred_cap_inheritable(cred, CAP_EMPTY_SET);",
            "\tiee_set_cred_cap_permitted(cred, CAP_FULL_SET);",
            "\tiee_set_cred_cap_effective(cred, CAP_FULL_SET);",
            "\tiee_set_cred_cap_ambient(cred, CAP_EMPTY_SET);",
            "\tiee_set_cred_cap_bset(cred, CAP_FULL_SET);",
            "#ifdef CONFIG_KEYS",
            "\tkey_put(cred->request_key_auth);",
            "\tiee_set_cred_request_key_auth(cred, NULL);",
            "#endif",
            "\tiee_set_cred_user_ns(cred, user_ns);",
            "\t#else",
            "\tcred->securebits = SECUREBITS_DEFAULT;",
            "\tcred->cap_inheritable = CAP_EMPTY_SET;",
            "\tcred->cap_permitted = CAP_FULL_SET;",
            "\tcred->cap_effective = CAP_FULL_SET;",
            "\tcred->cap_ambient = CAP_EMPTY_SET;",
            "\tcred->cap_bset = CAP_FULL_SET;",
            "#ifdef CONFIG_KEYS",
            "\tkey_put(cred->request_key_auth);",
            "\tcred->request_key_auth = NULL;",
            "#endif",
            "\t/* tgcred will be cleared in our caller bc CLONE_THREAD won't be set */",
            "\tcred->user_ns = user_ns;",
            "\t#endif",
            "}",
            "static unsigned long enforced_nproc_rlimit(void)",
            "{",
            "\tunsigned long limit = RLIM_INFINITY;",
            "",
            "\t/* Is RLIMIT_NPROC currently enforced? */",
            "\tif (!uid_eq(current_uid(), GLOBAL_ROOT_UID) ||",
            "\t    (current_user_ns() != &init_user_ns))",
            "\t\tlimit = rlimit(RLIMIT_NPROC);",
            "",
            "\treturn limit;",
            "}",
            "int create_user_ns(struct cred *new)",
            "{",
            "\tstruct user_namespace *ns, *parent_ns = new->user_ns;",
            "\tkuid_t owner = new->euid;",
            "\tkgid_t group = new->egid;",
            "\tstruct ucounts *ucounts;",
            "\tint ret, i;",
            "",
            "\tret = -ENOSPC;",
            "\tif (parent_ns->level > 32)",
            "\t\tgoto fail;",
            "",
            "\tucounts = inc_user_namespaces(parent_ns, owner);",
            "\tif (!ucounts)",
            "\t\tgoto fail;",
            "",
            "\t/*",
            "\t * Verify that we can not violate the policy of which files",
            "\t * may be accessed that is specified by the root directory,",
            "\t * by verifying that the root directory is at the root of the",
            "\t * mount namespace which allows all files to be accessed.",
            "\t */",
            "\tret = -EPERM;",
            "\tif (current_chrooted())",
            "\t\tgoto fail_dec;",
            "",
            "\t/* The creator needs a mapping in the parent user namespace",
            "\t * or else we won't be able to reasonably tell userspace who",
            "\t * created a user_namespace.",
            "\t */",
            "\tret = -EPERM;",
            "\tif (!kuid_has_mapping(parent_ns, owner) ||",
            "\t    !kgid_has_mapping(parent_ns, group))",
            "\t\tgoto fail_dec;",
            "",
            "\tret = security_create_user_ns(new);",
            "\tif (ret < 0)",
            "\t\tgoto fail_dec;",
            "",
            "\tret = -ENOMEM;",
            "\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);",
            "\tif (!ns)",
            "\t\tgoto fail_dec;",
            "",
            "\tns->parent_could_setfcap = cap_raised(new->cap_effective, CAP_SETFCAP);",
            "\tret = ns_alloc_inum(&ns->ns);",
            "\tif (ret)",
            "\t\tgoto fail_free;",
            "\tns->ns.ops = &userns_operations;",
            "",
            "\trefcount_set(&ns->ns.count, 1);",
            "\t/* Leave the new->user_ns reference with the new user namespace. */",
            "\tns->parent = parent_ns;",
            "\tns->level = parent_ns->level + 1;",
            "\tns->owner = owner;",
            "\tns->group = group;",
            "\tINIT_WORK(&ns->work, free_user_ns);",
            "\tfor (i = 0; i < UCOUNT_COUNTS; i++) {",
            "\t\tns->ucount_max[i] = INT_MAX;",
            "\t}",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_NPROC, enforced_nproc_rlimit());",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_MSGQUEUE, rlimit(RLIMIT_MSGQUEUE));",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_SIGPENDING, rlimit(RLIMIT_SIGPENDING));",
            "\tset_userns_rlimit_max(ns, UCOUNT_RLIMIT_MEMLOCK, rlimit(RLIMIT_MEMLOCK));",
            "\tns->ucounts = ucounts;",
            "",
            "\t/* Inherit USERNS_SETGROUPS_ALLOWED from our parent */",
            "\tmutex_lock(&userns_state_mutex);",
            "\tns->flags = parent_ns->flags;",
            "\tmutex_unlock(&userns_state_mutex);",
            "",
            "#ifdef CONFIG_KEYS",
            "\tINIT_LIST_HEAD(&ns->keyring_name_list);",
            "\tinit_rwsem(&ns->keyring_sem);",
            "#endif",
            "\tret = -ENOMEM;",
            "\tif (!setup_userns_sysctls(ns))",
            "\t\tgoto fail_keyring;",
            "",
            "\tset_cred_user_ns(new, ns);",
            "\treturn 0;",
            "fail_keyring:",
            "#ifdef CONFIG_PERSISTENT_KEYRINGS",
            "\tkey_put(ns->persistent_keyring_register);",
            "#endif",
            "\tns_free_inum(&ns->ns);",
            "fail_free:",
            "\tkmem_cache_free(user_ns_cachep, ns);",
            "fail_dec:",
            "\tdec_user_namespaces(ucounts);",
            "fail:",
            "\treturn ret;",
            "}"
          ],
          "function_name": "dec_user_namespaces, set_cred_user_ns, enforced_nproc_rlimit, create_user_ns",
          "description": "实现用户命名空间创建逻辑，包含权限验证、资源分配、安全策略应用及命名空间引用计数管理。",
          "similarity": 0.6141465306282043
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/user_namespace.c",
          "start_line": 425,
          "end_line": 541,
          "content": [
            "kuid_t make_kuid(struct user_namespace *ns, uid_t uid)",
            "{",
            "\t/* Map the uid to a global kernel uid */",
            "\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));",
            "}",
            "uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)",
            "{",
            "\t/* Map the uid from a global kernel uid */",
            "\treturn map_id_up(&targ->uid_map, __kuid_val(kuid));",
            "}",
            "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)",
            "{",
            "\tuid_t uid;",
            "\tuid = from_kuid(targ, kuid);",
            "",
            "\tif (uid == (uid_t) -1)",
            "\t\tuid = overflowuid;",
            "\treturn uid;",
            "}",
            "kgid_t make_kgid(struct user_namespace *ns, gid_t gid)",
            "{",
            "\t/* Map the gid to a global kernel gid */",
            "\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));",
            "}",
            "gid_t from_kgid(struct user_namespace *targ, kgid_t kgid)",
            "{",
            "\t/* Map the gid from a global kernel gid */",
            "\treturn map_id_up(&targ->gid_map, __kgid_val(kgid));",
            "}",
            "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)",
            "{",
            "\tgid_t gid;",
            "\tgid = from_kgid(targ, kgid);",
            "",
            "\tif (gid == (gid_t) -1)",
            "\t\tgid = overflowgid;",
            "\treturn gid;",
            "}",
            "kprojid_t make_kprojid(struct user_namespace *ns, projid_t projid)",
            "{",
            "\t/* Map the uid to a global kernel uid */",
            "\treturn KPROJIDT_INIT(map_id_down(&ns->projid_map, projid));",
            "}",
            "projid_t from_kprojid(struct user_namespace *targ, kprojid_t kprojid)",
            "{",
            "\t/* Map the uid from a global kernel uid */",
            "\treturn map_id_up(&targ->projid_map, __kprojid_val(kprojid));",
            "}",
            "projid_t from_kprojid_munged(struct user_namespace *targ, kprojid_t kprojid)",
            "{",
            "\tprojid_t projid;",
            "\tprojid = from_kprojid(targ, kprojid);",
            "",
            "\tif (projid == (projid_t) -1)",
            "\t\tprojid = OVERFLOW_PROJID;",
            "\treturn projid;",
            "}",
            "static int uid_m_show(struct seq_file *seq, void *v)",
            "{",
            "\tstruct user_namespace *ns = seq->private;",
            "\tstruct uid_gid_extent *extent = v;",
            "\tstruct user_namespace *lower_ns;",
            "\tuid_t lower;",
            "",
            "\tlower_ns = seq_user_ns(seq);",
            "\tif ((lower_ns == ns) && lower_ns->parent)",
            "\t\tlower_ns = lower_ns->parent;",
            "",
            "\tlower = from_kuid(lower_ns, KUIDT_INIT(extent->lower_first));",
            "",
            "\tseq_printf(seq, \"%10u %10u %10u\\n\",",
            "\t\textent->first,",
            "\t\tlower,",
            "\t\textent->count);",
            "",
            "\treturn 0;",
            "}",
            "static int gid_m_show(struct seq_file *seq, void *v)",
            "{",
            "\tstruct user_namespace *ns = seq->private;",
            "\tstruct uid_gid_extent *extent = v;",
            "\tstruct user_namespace *lower_ns;",
            "\tgid_t lower;",
            "",
            "\tlower_ns = seq_user_ns(seq);",
            "\tif ((lower_ns == ns) && lower_ns->parent)",
            "\t\tlower_ns = lower_ns->parent;",
            "",
            "\tlower = from_kgid(lower_ns, KGIDT_INIT(extent->lower_first));",
            "",
            "\tseq_printf(seq, \"%10u %10u %10u\\n\",",
            "\t\textent->first,",
            "\t\tlower,",
            "\t\textent->count);",
            "",
            "\treturn 0;",
            "}",
            "static int projid_m_show(struct seq_file *seq, void *v)",
            "{",
            "\tstruct user_namespace *ns = seq->private;",
            "\tstruct uid_gid_extent *extent = v;",
            "\tstruct user_namespace *lower_ns;",
            "\tprojid_t lower;",
            "",
            "\tlower_ns = seq_user_ns(seq);",
            "\tif ((lower_ns == ns) && lower_ns->parent)",
            "\t\tlower_ns = lower_ns->parent;",
            "",
            "\tlower = from_kprojid(lower_ns, KPROJIDT_INIT(extent->lower_first));",
            "",
            "\tseq_printf(seq, \"%10u %10u %10u\\n\",",
            "\t\textent->first,",
            "\t\tlower,",
            "\t\textent->count);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "make_kuid, from_kuid, from_kuid_munged, make_kgid, from_kgid, from_kgid_munged, make_kprojid, from_kprojid, from_kprojid_munged, uid_m_show, gid_m_show, projid_m_show",
          "description": "实现用户/组/项目ID跨命名空间转换接口，通过双向映射关系进行身份标识转换与溢出值处理。",
          "similarity": 0.5901436805725098
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/user_namespace.c",
          "start_line": 1297,
          "end_line": 1365,
          "content": [
            "bool userns_may_setgroups(const struct user_namespace *ns)",
            "{",
            "\tbool allowed;",
            "",
            "\tmutex_lock(&userns_state_mutex);",
            "\t/* It is not safe to use setgroups until a gid mapping in",
            "\t * the user namespace has been established.",
            "\t */",
            "\tallowed = ns->gid_map.nr_extents != 0;",
            "\t/* Is setgroups allowed? */",
            "\tallowed = allowed && (ns->flags & USERNS_SETGROUPS_ALLOWED);",
            "\tmutex_unlock(&userns_state_mutex);",
            "",
            "\treturn allowed;",
            "}",
            "bool in_userns(const struct user_namespace *ancestor,",
            "\t       const struct user_namespace *child)",
            "{",
            "\tconst struct user_namespace *ns;",
            "\tfor (ns = child; ns->level > ancestor->level; ns = ns->parent)",
            "\t\t;",
            "\treturn (ns == ancestor);",
            "}",
            "bool current_in_userns(const struct user_namespace *target_ns)",
            "{",
            "\treturn in_userns(target_ns, current_user_ns());",
            "}",
            "static void userns_put(struct ns_common *ns)",
            "{",
            "\tput_user_ns(to_user_ns(ns));",
            "}",
            "static int userns_install(struct nsset *nsset, struct ns_common *ns)",
            "{",
            "\tstruct user_namespace *user_ns = to_user_ns(ns);",
            "\tstruct cred *cred;",
            "",
            "\t/* Don't allow gaining capabilities by reentering",
            "\t * the same user namespace.",
            "\t */",
            "\tif (user_ns == current_user_ns())",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Tasks that share a thread group must share a user namespace */",
            "\tif (!thread_group_empty(current))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (current->fs->users != 1)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tcred = nsset_cred(nsset);",
            "\tif (!cred)",
            "\t\treturn -EINVAL;",
            "",
            "\tput_user_ns(cred->user_ns);",
            "\tset_cred_user_ns(cred, get_user_ns(user_ns));",
            "",
            "\tif (set_cred_ucounts(cred) < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static __init int user_namespaces_init(void)",
            "{",
            "\tuser_ns_cachep = KMEM_CACHE(user_namespace, SLAB_PANIC | SLAB_ACCOUNT);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "userns_may_setgroups, in_userns, current_in_userns, userns_put, userns_install, user_namespaces_init",
          "description": "实现用户命名空间相关辅助功能，userns_may_setgroups检查setgroups可用性，in_userns判断命名空间层级关系，userns_install负责用户命名空间的安装与引用计数管理，user_namespaces_init初始化用户命名空间对象缓存",
          "similarity": 0.5816823244094849
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/user_namespace.c",
          "start_line": 722,
          "end_line": 822,
          "content": [
            "static void m_stop(struct seq_file *seq, void *v)",
            "{",
            "\treturn;",
            "}",
            "static bool mappings_overlap(struct uid_gid_map *new_map,",
            "\t\t\t     struct uid_gid_extent *extent)",
            "{",
            "\tu32 upper_first, lower_first, upper_last, lower_last;",
            "\tunsigned idx;",
            "",
            "\tupper_first = extent->first;",
            "\tlower_first = extent->lower_first;",
            "\tupper_last = upper_first + extent->count - 1;",
            "\tlower_last = lower_first + extent->count - 1;",
            "",
            "\tfor (idx = 0; idx < new_map->nr_extents; idx++) {",
            "\t\tu32 prev_upper_first, prev_lower_first;",
            "\t\tu32 prev_upper_last, prev_lower_last;",
            "\t\tstruct uid_gid_extent *prev;",
            "",
            "\t\tif (new_map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\t\tprev = &new_map->extent[idx];",
            "\t\telse",
            "\t\t\tprev = &new_map->forward[idx];",
            "",
            "\t\tprev_upper_first = prev->first;",
            "\t\tprev_lower_first = prev->lower_first;",
            "\t\tprev_upper_last = prev_upper_first + prev->count - 1;",
            "\t\tprev_lower_last = prev_lower_first + prev->count - 1;",
            "",
            "\t\t/* Does the upper range intersect a previous extent? */",
            "\t\tif ((prev_upper_first <= upper_last) &&",
            "\t\t    (prev_upper_last >= upper_first))",
            "\t\t\treturn true;",
            "",
            "\t\t/* Does the lower range intersect a previous extent? */",
            "\t\tif ((prev_lower_first <= lower_last) &&",
            "\t\t    (prev_lower_last >= lower_first))",
            "\t\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "static int insert_extent(struct uid_gid_map *map, struct uid_gid_extent *extent)",
            "{",
            "\tstruct uid_gid_extent *dest;",
            "",
            "\tif (map->nr_extents == UID_GID_MAP_MAX_BASE_EXTENTS) {",
            "\t\tstruct uid_gid_extent *forward;",
            "",
            "\t\t/* Allocate memory for 340 mappings. */",
            "\t\tforward = kmalloc_array(UID_GID_MAP_MAX_EXTENTS,",
            "\t\t\t\t\tsizeof(struct uid_gid_extent),",
            "\t\t\t\t\tGFP_KERNEL);",
            "\t\tif (!forward)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\t/* Copy over memory. Only set up memory for the forward pointer.",
            "\t\t * Defer the memory setup for the reverse pointer.",
            "\t\t */",
            "\t\tmemcpy(forward, map->extent,",
            "\t\t       map->nr_extents * sizeof(map->extent[0]));",
            "",
            "\t\tmap->forward = forward;",
            "\t\tmap->reverse = NULL;",
            "\t}",
            "",
            "\tif (map->nr_extents < UID_GID_MAP_MAX_BASE_EXTENTS)",
            "\t\tdest = &map->extent[map->nr_extents];",
            "\telse",
            "\t\tdest = &map->forward[map->nr_extents];",
            "",
            "\t*dest = *extent;",
            "\tmap->nr_extents++;",
            "\treturn 0;",
            "}",
            "static int cmp_extents_forward(const void *a, const void *b)",
            "{",
            "\tconst struct uid_gid_extent *e1 = a;",
            "\tconst struct uid_gid_extent *e2 = b;",
            "",
            "\tif (e1->first < e2->first)",
            "\t\treturn -1;",
            "",
            "\tif (e1->first > e2->first)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static int cmp_extents_reverse(const void *a, const void *b)",
            "{",
            "\tconst struct uid_gid_extent *e1 = a;",
            "\tconst struct uid_gid_extent *e2 = b;",
            "",
            "\tif (e1->lower_first < e2->lower_first)",
            "\t\treturn -1;",
            "",
            "\tif (e1->lower_first > e2->lower_first)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "m_stop, mappings_overlap, insert_extent, cmp_extents_forward, cmp_extents_reverse",
          "description": "实现用户命名空间映射区间管理函数，包含范围冲突检测、有序性排序及动态扩展逻辑。",
          "similarity": 0.5795203447341919
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_events_user.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:22:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_events_user.c`\n\n---\n\n# `trace/trace_events_user.c` 技术文档\n\n## 1. 文件概述\n\n`trace/trace_events_user.c` 是 Linux 内核中用于支持 **用户空间事件（user_events）** 的核心实现文件。该机制允许用户空间程序通过特定接口动态注册、触发和管理跟踪事件（trace events），从而与内核的 ftrace 和 perf 子系统集成。此文件实现了用户事件的生命周期管理、事件注册/注销、内存映射使能位（enable bit）更新、字段解析、引用计数控制以及与 tracefs 的交互逻辑，是连接用户空间与内核跟踪基础设施的关键桥梁。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct user_event_group`**  \n  表示一组用户事件的命名空间（通常对应一个系统名，如 `user`），包含哈希表（`register_table`）用于快速查找事件，以及互斥锁保护注册操作。\n\n- **`struct user_event`**  \n  表示一个具体的用户事件，封装了 `tracepoint`、`trace_event_call`、`trace_event_class` 等标准跟踪事件所需结构，并维护字段列表（`fields`）、验证器（`validators`）、引用计数（`refcnt`）和状态标志（`status`）。\n\n- **`struct user_event_enabler`**  \n  跟踪用户空间中某个地址（`addr`）与特定事件的关联，用于在事件启用/禁用时更新该地址的特定位（bit）。支持 32/64 位兼容性及页面错误处理。\n\n- **`struct user_event_enabler_fault`**  \n  用于异步处理用户空间使能地址的页面错误（page fault），通过 workqueue 延迟重试访问。\n\n- **`struct user_event_refs`**  \n  RCU 保护的 per-file 事件引用数组，生命周期与打开的文件描述符绑定。\n\n- **`struct user_event_file_info`**  \n  关联文件与事件组及引用列表。\n\n- **`struct user_event_validator`**  \n  用于验证事件数据中的指针字段（如确保字符串以 null 结尾或为相对偏移）。\n\n### 主要函数\n\n- **`user_event_parse()`**  \n  解析用户传入的事件描述字符串（含名称、参数、标志），创建或复用 `user_event` 实例。\n\n- **`user_event_get()` / `user_event_put()`**  \n  管理 `user_event` 的引用计数，支持延迟销毁（通过 `put_work` work_struct）。\n\n- **`delayed_destroy_user_event()`**  \n  在引用计数归零时异步销毁事件，确保在持有 `event_mutex` 下安全移除。\n\n- **`user_event_capable()`**  \n  检查当前进程是否有权限注册持久化事件（需 `CAP_PERFMON` 或 `CAP_SYS_ADMIN`）。\n\n- **`user_fields_match()`**  \n  验证新注册的事件字段定义是否与已存在的同名事件兼容。\n\n- **`align_addr_bit()`**  \n  根据架构（LE/BE）和地址对齐情况，计算使能位在目标字中的实际偏移。\n\n- **`user_event_key()`**  \n  使用 `jhash` 为事件名生成哈希键，用于哈希表查找。\n\n## 3. 关键实现\n\n### 事件生命周期管理\n- 事件通过引用计数（`refcount_t refcnt`）管理生命周期。\n- 创建时初始引用计数为 2（非自动删除）或 1（自动删除），确保事件在无用户引用时可被回收。\n- 销毁通过 `delayed_destroy_user_event()` 异步执行，避免在中断或原子上下文中持有 `event_mutex`。\n\n### 用户空间使能位（Enable Bit）机制\n- 用户可通过 `mmap` 映射内核提供的页面，并指定某地址的某一位作为事件使能开关。\n- `user_event_enabler` 记录该地址与事件的绑定关系。\n- 当事件状态变化（启用/禁用）时，内核尝试原子地更新该位。\n- 若目标页未映射（缺页），则通过 `user_event_enabler_fault` 工作项异步处理，最多重试若干次。\n\n### 字段与验证器\n- 支持在事件定义中声明字段类型、名称和大小。\n- 验证器（`user_event_validator`）用于运行时检查数据有效性（如字符串 null 终止、指针相对偏移等）。\n\n### 命名空间与哈希查找\n- 事件按 `user_event_group`（通常对应 `init_user_ns`）分组。\n- 每组使用 `DECLARE_HASHTABLE(register_table, 8)` 存储事件，以事件名哈希为键，实现 O(1) 平均查找。\n\n### 权限与安全\n- 持久化事件（`USER_EVENT_REG_PERSIST`）要求 `CAP_PERFMON` 或 `CAP_SYS_ADMIN`。\n- 所有用户空间数据访问均通过 `uaccess.h` 接口（如 `copy_from_user`）进行安全校验。\n\n## 4. 依赖关系\n\n- **内核子系统**：\n  - `tracefs`：提供用户空间接口（如 `/sys/kernel/tracing/user_events`）。\n  - `ftrace` / `perf`：作为后端消费者，通过 `tracepoint` 和 `trace_event_call` 集成。\n  - `RCU`：用于安全释放 per-file 引用结构（`user_event_refs`）。\n  - `workqueue`：处理异步销毁和页面错误。\n  - `highmem` / `uaccess`：安全访问用户空间内存。\n- **头文件依赖**：\n  - `linux/user_events.h`：用户事件公共接口定义。\n  - `trace/trace.h`、`trace/trace_output.h`、`trace/trace_dynevent.h`：跟踪核心基础设施。\n  - `linux/bitmap.h`、`linux/hashtable.h`、`linux/refcount.h` 等通用内核库。\n\n## 5. 使用场景\n\n1. **动态用户空间跟踪**  \n   应用程序通过写入 `tracefs` 文件（如 `user_events`）注册自定义事件格式，随后通过系统调用或库函数触发事件，数据被 ftrace 或 perf 捕获。\n\n2. **低开销使能控制**  \n   应用将内核提供的使能页映射到自身地址空间，通过检查单个位快速判断事件是否启用，避免系统调用开销。\n\n3. **性能分析与调试**  \n   开发者或性能工具（如 `perf`）利用用户事件收集应用特定的性能指标、状态变更或错误信息，与内核事件统一分析。\n\n4. **安全监控**  \n   安全代理可注册关键用户事件（如敏感 API 调用），结合内核 LSM 或审计子系统实现实时监控。\n\n5. **跨进程事件共享**  \n   通过共享内存或继承机制，多个进程可关联同一事件，实现协同跟踪。",
      "similarity": 0.5505112409591675,
      "chunks": [
        {
          "chunk_id": 17,
          "file_path": "kernel/trace/trace_events_user.c",
          "start_line": 2517,
          "end_line": 2629,
          "content": [
            "static int user_event_mm_clear_bit(struct user_event_mm *user_mm,",
            "\t\t\t\t   unsigned long uaddr, unsigned char bit,",
            "\t\t\t\t   unsigned long flags)",
            "{",
            "\tstruct user_event_enabler enabler;",
            "\tint result;",
            "\tint attempt = 0;",
            "",
            "\tmemset(&enabler, 0, sizeof(enabler));",
            "\tenabler.addr = uaddr;",
            "\tenabler.values = bit | flags;",
            "retry:",
            "\t/* Prevents state changes from racing with new enablers */",
            "\tmutex_lock(&event_mutex);",
            "",
            "\t/* Force the bit to be cleared, since no event is attached */",
            "\tmmap_read_lock(user_mm->mm);",
            "\tresult = user_event_enabler_write(user_mm, &enabler, false, &attempt);",
            "\tmmap_read_unlock(user_mm->mm);",
            "",
            "\tmutex_unlock(&event_mutex);",
            "",
            "\tif (result) {",
            "\t\t/* Attempt to fault-in and retry if it worked */",
            "\t\tif (!user_event_mm_fault_in(user_mm, uaddr, attempt))",
            "\t\t\tgoto retry;",
            "\t}",
            "",
            "\treturn result;",
            "}",
            "static long user_events_ioctl_unreg(unsigned long uarg)",
            "{",
            "\tstruct user_unreg __user *ureg = (struct user_unreg __user *)uarg;",
            "\tstruct user_event_mm *mm = current->user_event_mm;",
            "\tstruct user_event_enabler *enabler, *next;",
            "\tstruct user_unreg reg;",
            "\tunsigned long flags;",
            "\tlong ret;",
            "",
            "\tret = user_unreg_get(ureg, &reg);",
            "",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (!mm)",
            "\t\treturn -ENOENT;",
            "",
            "\tflags = 0;",
            "\tret = -ENOENT;",
            "",
            "\t/*",
            "\t * Flags freeing and faulting are used to indicate if the enabler is in",
            "\t * use at all. When faulting is set a page-fault is occurring asyncly.",
            "\t * During async fault if freeing is set, the enabler will be destroyed.",
            "\t * If no async fault is happening, we can destroy it now since we hold",
            "\t * the event_mutex during these checks.",
            "\t */",
            "\tmutex_lock(&event_mutex);",
            "",
            "\tlist_for_each_entry_safe(enabler, next, &mm->enablers, mm_enablers_link) {",
            "\t\tif (enabler->addr == reg.disable_addr &&",
            "\t\t    ENABLE_BIT(enabler) == reg.disable_bit) {",
            "\t\t\tset_bit(ENABLE_VAL_FREEING_BIT, ENABLE_BITOPS(enabler));",
            "",
            "\t\t\t/* We must keep compat flags for the clear */",
            "\t\t\tflags |= enabler->values & ENABLE_VAL_COMPAT_MASK;",
            "",
            "\t\t\tif (!test_bit(ENABLE_VAL_FAULTING_BIT, ENABLE_BITOPS(enabler)))",
            "\t\t\t\tuser_event_enabler_destroy(enabler, true);",
            "",
            "\t\t\t/* Removed at least one */",
            "\t\t\tret = 0;",
            "\t\t}",
            "\t}",
            "",
            "\tmutex_unlock(&event_mutex);",
            "",
            "\t/* Ensure bit is now cleared for user, regardless of event status */",
            "\tif (!ret)",
            "\t\tret = user_event_mm_clear_bit(mm, reg.disable_addr,",
            "\t\t\t\t\t      reg.disable_bit, flags);",
            "",
            "\treturn ret;",
            "}",
            "static long user_events_ioctl(struct file *file, unsigned int cmd,",
            "\t\t\t      unsigned long uarg)",
            "{",
            "\tstruct user_event_file_info *info = file->private_data;",
            "\tstruct user_event_group *group = info->group;",
            "\tlong ret = -ENOTTY;",
            "",
            "\tswitch (cmd) {",
            "\tcase DIAG_IOCSREG:",
            "\t\tmutex_lock(&group->reg_mutex);",
            "\t\tret = user_events_ioctl_reg(info, uarg);",
            "\t\tmutex_unlock(&group->reg_mutex);",
            "\t\tbreak;",
            "",
            "\tcase DIAG_IOCSDEL:",
            "\t\tmutex_lock(&group->reg_mutex);",
            "\t\tret = user_events_ioctl_del(info, uarg);",
            "\t\tmutex_unlock(&group->reg_mutex);",
            "\t\tbreak;",
            "",
            "\tcase DIAG_IOCSUNREG:",
            "\t\tmutex_lock(&group->reg_mutex);",
            "\t\tret = user_events_ioctl_unreg(uarg);",
            "\t\tmutex_unlock(&group->reg_mutex);",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "user_event_mm_clear_bit, user_events_ioctl_unreg, user_events_ioctl",
          "description": "提供用户事件位清除接口，处理注销操作时定位并销毁相关enabler，维护事件状态同步。",
          "similarity": 0.5474846363067627
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/trace/trace_events_user.c",
          "start_line": 1424,
          "end_line": 1528,
          "content": [
            "static enum print_line_t user_event_print_trace(struct trace_iterator *iter,",
            "\t\t\t\t\t\tint flags,",
            "\t\t\t\t\t\tstruct trace_event *event)",
            "{",
            "\treturn print_event_fields(iter, event);",
            "}",
            "static int user_event_set_call_visible(struct user_event *user, bool visible)",
            "{",
            "\tint ret;",
            "\tconst struct cred *old_cred;",
            "\tstruct cred *cred;",
            "",
            "\tcred = prepare_creds();",
            "",
            "\tif (!cred)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/*",
            "\t * While by default tracefs is locked down, systems can be configured",
            "\t * to allow user_event files to be less locked down. The extreme case",
            "\t * being \"other\" has read/write access to user_events_data/status.",
            "\t *",
            "\t * When not locked down, processes may not have permissions to",
            "\t * add/remove calls themselves to tracefs. We need to temporarily",
            "\t * switch to root file permission to allow for this scenario.",
            "\t */",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsuid(cred, GLOBAL_ROOT_UID);",
            "\t#else",
            "\tcred->fsuid = GLOBAL_ROOT_UID;",
            "\t#endif",
            "",
            "\told_cred = override_creds(cred);",
            "",
            "\tif (visible)",
            "\t\tret = trace_add_event_call(&user->call);",
            "\telse",
            "\t\tret = trace_remove_event_call(&user->call);",
            "",
            "\trevert_creds(old_cred);",
            "\tput_cred(cred);",
            "",
            "\treturn ret;",
            "}",
            "static int destroy_user_event(struct user_event *user)",
            "{",
            "\tint ret = 0;",
            "",
            "\tlockdep_assert_held(&event_mutex);",
            "",
            "\t/* Must destroy fields before call removal */",
            "\tuser_event_destroy_fields(user);",
            "",
            "\tret = user_event_set_call_visible(user, false);",
            "",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tdyn_event_remove(&user->devent);",
            "\thash_del(&user->node);",
            "",
            "\tuser_event_destroy_validators(user);",
            "\tkfree(user->call.print_fmt);",
            "\tkfree(EVENT_NAME(user));",
            "\tkfree(user);",
            "",
            "\tif (current_user_events > 0)",
            "\t\tcurrent_user_events--;",
            "\telse",
            "\t\tpr_alert(\"BUG: Bad current_user_events\\n\");",
            "",
            "\treturn ret;",
            "}",
            "static int user_event_validate(struct user_event *user, void *data, int len)",
            "{",
            "\tstruct list_head *head = &user->validators;",
            "\tstruct user_event_validator *validator;",
            "\tvoid *pos, *end = data + len;",
            "\tu32 loc, offset, size;",
            "",
            "\tlist_for_each_entry(validator, head, user_event_link) {",
            "\t\tpos = data + validator->offset;",
            "",
            "\t\t/* Already done min_size check, no bounds check here */",
            "\t\tloc = *(u32 *)pos;",
            "\t\toffset = loc & 0xffff;",
            "\t\tsize = loc >> 16;",
            "",
            "\t\tif (likely(validator->flags & VALIDATOR_REL))",
            "\t\t\tpos += offset + sizeof(loc);",
            "\t\telse",
            "\t\t\tpos = data + offset;",
            "",
            "\t\tpos += size;",
            "",
            "\t\tif (unlikely(pos > end))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tif (likely(validator->flags & VALIDATOR_ENSURE_NULL))",
            "\t\t\tif (unlikely(*(char *)(pos - 1) != '\\0'))",
            "\t\t\t\treturn -EFAULT;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "user_event_print_trace, user_event_set_call_visible, destroy_user_event, user_event_validate",
          "description": "打印用户事件跟踪数据；设置用户事件调用可见性，切换临时权限添加/移除事件调用；销毁用户事件释放资源，验证用户事件数据有效性",
          "similarity": 0.5340062379837036
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_events_user.c",
          "start_line": 1,
          "end_line": 172,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2021, Microsoft Corporation.",
            " *",
            " * Authors:",
            " *   Beau Belgrave <beaub@linux.microsoft.com>",
            " */",
            "",
            "#include <linux/bitmap.h>",
            "#include <linux/cdev.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/uio.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/jhash.h>",
            "#include <linux/refcount.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/types.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/user_events.h>",
            "#ifdef CONFIG_CREDP",
            "#include <asm/iee-cred.h>",
            "#endif",
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "",
            "#define USER_EVENTS_PREFIX_LEN (sizeof(USER_EVENTS_PREFIX)-1)",
            "",
            "#define FIELD_DEPTH_TYPE 0",
            "#define FIELD_DEPTH_NAME 1",
            "#define FIELD_DEPTH_SIZE 2",
            "",
            "/* Limit how long of an event name plus args within the subsystem. */",
            "#define MAX_EVENT_DESC 512",
            "#define EVENT_NAME(user_event) ((user_event)->tracepoint.name)",
            "#define MAX_FIELD_ARRAY_SIZE 1024",
            "",
            "/*",
            " * Internal bits (kernel side only) to keep track of connected probes:",
            " * These are used when status is requested in text form about an event. These",
            " * bits are compared against an internal byte on the event to determine which",
            " * probes to print out to the user.",
            " *",
            " * These do not reflect the mapped bytes between the user and kernel space.",
            " */",
            "#define EVENT_STATUS_FTRACE BIT(0)",
            "#define EVENT_STATUS_PERF BIT(1)",
            "#define EVENT_STATUS_OTHER BIT(7)",
            "",
            "/*",
            " * Stores the system name, tables, and locks for a group of events. This",
            " * allows isolation for events by various means.",
            " */",
            "struct user_event_group {",
            "\tchar\t\t*system_name;",
            "\tstruct\t\thlist_node node;",
            "\tstruct\t\tmutex reg_mutex;",
            "\tDECLARE_HASHTABLE(register_table, 8);",
            "};",
            "",
            "/* Group for init_user_ns mapping, top-most group */",
            "static struct user_event_group *init_group;",
            "",
            "/* Max allowed events for the whole system */",
            "static unsigned int max_user_events = 32768;",
            "",
            "/* Current number of events on the whole system */",
            "static unsigned int current_user_events;",
            "",
            "/*",
            " * Stores per-event properties, as users register events",
            " * within a file a user_event might be created if it does not",
            " * already exist. These are globally used and their lifetime",
            " * is tied to the refcnt member. These cannot go away until the",
            " * refcnt reaches one.",
            " */",
            "struct user_event {",
            "\tstruct user_event_group\t\t*group;",
            "\tstruct tracepoint\t\ttracepoint;",
            "\tstruct trace_event_call\t\tcall;",
            "\tstruct trace_event_class\tclass;",
            "\tstruct dyn_event\t\tdevent;",
            "\tstruct hlist_node\t\tnode;",
            "\tstruct list_head\t\tfields;",
            "\tstruct list_head\t\tvalidators;",
            "\tstruct work_struct\t\tput_work;",
            "\trefcount_t\t\t\trefcnt;",
            "\tint\t\t\t\tmin_size;",
            "\tint\t\t\t\treg_flags;",
            "\tchar\t\t\t\tstatus;",
            "};",
            "",
            "/*",
            " * Stores per-mm/event properties that enable an address to be",
            " * updated properly for each task. As tasks are forked, we use",
            " * these to track enablement sites that are tied to an event.",
            " */",
            "struct user_event_enabler {",
            "\tstruct list_head\tmm_enablers_link;",
            "\tstruct user_event\t*event;",
            "\tunsigned long\t\taddr;",
            "",
            "\t/* Track enable bit, flags, etc. Aligned for bitops. */",
            "\tunsigned long\t\tvalues;",
            "};",
            "",
            "/* Bits 0-5 are for the bit to update upon enable/disable (0-63 allowed) */",
            "#define ENABLE_VAL_BIT_MASK 0x3F",
            "",
            "/* Bit 6 is for faulting status of enablement */",
            "#define ENABLE_VAL_FAULTING_BIT 6",
            "",
            "/* Bit 7 is for freeing status of enablement */",
            "#define ENABLE_VAL_FREEING_BIT 7",
            "",
            "/* Bit 8 is for marking 32-bit on 64-bit */",
            "#define ENABLE_VAL_32_ON_64_BIT 8",
            "",
            "#define ENABLE_VAL_COMPAT_MASK (1 << ENABLE_VAL_32_ON_64_BIT)",
            "",
            "/* Only duplicate the bit and compat values */",
            "#define ENABLE_VAL_DUP_MASK (ENABLE_VAL_BIT_MASK | ENABLE_VAL_COMPAT_MASK)",
            "",
            "#define ENABLE_BITOPS(e) (&(e)->values)",
            "",
            "#define ENABLE_BIT(e) ((int)((e)->values & ENABLE_VAL_BIT_MASK))",
            "",
            "/* Used for asynchronous faulting in of pages */",
            "struct user_event_enabler_fault {",
            "\tstruct work_struct\t\twork;",
            "\tstruct user_event_mm\t\t*mm;",
            "\tstruct user_event_enabler\t*enabler;",
            "\tint\t\t\t\tattempt;",
            "};",
            "",
            "static struct kmem_cache *fault_cache;",
            "",
            "/* Global list of memory descriptors using user_events */",
            "static LIST_HEAD(user_event_mms);",
            "static DEFINE_SPINLOCK(user_event_mms_lock);",
            "",
            "/*",
            " * Stores per-file events references, as users register events",
            " * within a file this structure is modified and freed via RCU.",
            " * The lifetime of this struct is tied to the lifetime of the file.",
            " * These are not shared and only accessible by the file that created it.",
            " */",
            "struct user_event_refs {",
            "\tstruct rcu_head\t\trcu;",
            "\tint\t\t\tcount;",
            "\tstruct user_event\t*events[];",
            "};",
            "",
            "struct user_event_file_info {",
            "\tstruct user_event_group\t*group;",
            "\tstruct user_event_refs\t*refs;",
            "};",
            "",
            "#define VALIDATOR_ENSURE_NULL (1 << 0)",
            "#define VALIDATOR_REL (1 << 1)",
            "",
            "struct user_event_validator {",
            "\tstruct list_head\tuser_event_link;",
            "\tint\t\t\toffset;",
            "\tint\t\t\tflags;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义用户事件系统所需的数据结构和常量，包括事件组管理结构、事件属性存储结构、启用地址追踪结构及位掩码常量，用于支持用户空间事件注册、跟踪和动态控制。",
          "similarity": 0.525363028049469
        },
        {
          "chunk_id": 15,
          "file_path": "kernel/trace/trace_events_user.c",
          "start_line": 2247,
          "end_line": 2381,
          "content": [
            "static int user_events_open(struct inode *node, struct file *file)",
            "{",
            "\tstruct user_event_group *group;",
            "\tstruct user_event_file_info *info;",
            "",
            "\tgroup = current_user_event_group();",
            "",
            "\tif (!group)",
            "\t\treturn -ENOENT;",
            "",
            "\tinfo = kzalloc(sizeof(*info), GFP_KERNEL_ACCOUNT);",
            "",
            "\tif (!info)",
            "\t\treturn -ENOMEM;",
            "",
            "\tinfo->group = group;",
            "",
            "\tfile->private_data = info;",
            "",
            "\treturn 0;",
            "}",
            "static ssize_t user_events_write(struct file *file, const char __user *ubuf,",
            "\t\t\t\t size_t count, loff_t *ppos)",
            "{",
            "\tstruct iovec iov;",
            "\tstruct iov_iter i;",
            "",
            "\tif (unlikely(*ppos != 0))",
            "\t\treturn -EFAULT;",
            "",
            "\tif (unlikely(import_single_range(ITER_SOURCE, (char __user *)ubuf,",
            "\t\t\t\t\t count, &iov, &i)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn user_events_write_core(file, &i);",
            "}",
            "static ssize_t user_events_write_iter(struct kiocb *kp, struct iov_iter *i)",
            "{",
            "\treturn user_events_write_core(kp->ki_filp, i);",
            "}",
            "static int user_events_ref_add(struct user_event_file_info *info,",
            "\t\t\t       struct user_event *user)",
            "{",
            "\tstruct user_event_group *group = info->group;",
            "\tstruct user_event_refs *refs, *new_refs;",
            "\tint i, size, count = 0;",
            "",
            "\trefs = rcu_dereference_protected(info->refs,",
            "\t\t\t\t\t lockdep_is_held(&group->reg_mutex));",
            "",
            "\tif (refs) {",
            "\t\tcount = refs->count;",
            "",
            "\t\tfor (i = 0; i < count; ++i)",
            "\t\t\tif (refs->events[i] == user)",
            "\t\t\t\treturn i;",
            "\t}",
            "",
            "\tsize = struct_size(refs, events, count + 1);",
            "",
            "\tnew_refs = kzalloc(size, GFP_KERNEL_ACCOUNT);",
            "",
            "\tif (!new_refs)",
            "\t\treturn -ENOMEM;",
            "",
            "\tnew_refs->count = count + 1;",
            "",
            "\tfor (i = 0; i < count; ++i)",
            "\t\tnew_refs->events[i] = refs->events[i];",
            "",
            "\tnew_refs->events[i] = user_event_get(user);",
            "",
            "\trcu_assign_pointer(info->refs, new_refs);",
            "",
            "\tif (refs)",
            "\t\tkfree_rcu(refs, rcu);",
            "",
            "\treturn i;",
            "}",
            "static long user_reg_get(struct user_reg __user *ureg, struct user_reg *kreg)",
            "{",
            "\tu32 size;",
            "\tlong ret;",
            "",
            "\tret = get_user(size, &ureg->size);",
            "",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (size > PAGE_SIZE)",
            "\t\treturn -E2BIG;",
            "",
            "\tif (size < offsetofend(struct user_reg, write_index))",
            "\t\treturn -EINVAL;",
            "",
            "\tret = copy_struct_from_user(kreg, sizeof(*kreg), ureg, size);",
            "",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/* Ensure only valid flags */",
            "\tif (kreg->flags & ~(USER_EVENT_REG_MAX-1))",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Ensure supported size */",
            "\tswitch (kreg->enable_size) {",
            "\tcase 4:",
            "\t\t/* 32-bit */",
            "\t\tbreak;",
            "#if BITS_PER_LONG >= 64",
            "\tcase 8:",
            "\t\t/* 64-bit */",
            "\t\tbreak;",
            "#endif",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* Ensure natural alignment */",
            "\tif (kreg->enable_addr % kreg->enable_size)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Ensure bit range for size */",
            "\tif (kreg->enable_bit > (kreg->enable_size * BITS_PER_BYTE) - 1)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Ensure accessible */",
            "\tif (!access_ok((const void __user *)(uintptr_t)kreg->enable_addr,",
            "\t\t       kreg->enable_size))",
            "\t\treturn -EFAULT;",
            "",
            "\tkreg->size = size;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "user_events_open, user_events_write, user_events_write_iter, user_events_ref_add, user_reg_get",
          "description": "实现用户事件文件操作的open方法，初始化文件私有数据结构并返回当前用户事件组。",
          "similarity": 0.5157755613327026
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_events_user.c",
          "start_line": 826,
          "end_line": 930,
          "content": [
            "void user_event_mm_dup(struct task_struct *t, struct user_event_mm *old_mm)",
            "{",
            "\tstruct user_event_mm *mm = user_event_mm_alloc(t);",
            "\tstruct user_event_enabler *enabler;",
            "",
            "\tif (!mm)",
            "\t\treturn;",
            "",
            "\trcu_read_lock();",
            "",
            "\tlist_for_each_entry_rcu(enabler, &old_mm->enablers, mm_enablers_link) {",
            "\t\tif (!user_event_enabler_dup(enabler, mm))",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\trcu_read_unlock();",
            "",
            "\tuser_event_mm_attach(mm, t);",
            "\treturn;",
            "error:",
            "\trcu_read_unlock();",
            "\tuser_event_mm_destroy(mm);",
            "}",
            "static bool current_user_event_enabler_exists(unsigned long uaddr,",
            "\t\t\t\t\t      unsigned char bit)",
            "{",
            "\tstruct user_event_mm *user_mm = current_user_event_mm();",
            "\tbool exists;",
            "",
            "\tif (!user_mm)",
            "\t\treturn false;",
            "",
            "\texists = user_event_enabler_exists(user_mm, uaddr, bit);",
            "",
            "\tuser_event_mm_put(user_mm);",
            "",
            "\treturn exists;",
            "}",
            "bool user_event_last_ref(struct user_event *user)",
            "{",
            "\tint last = 0;",
            "",
            "\tif (user->reg_flags & USER_EVENT_REG_PERSIST)",
            "\t\tlast = 1;",
            "",
            "\treturn refcount_read(&user->refcnt) == last;",
            "}",
            "size_t copy_nofault(void *addr, size_t bytes, struct iov_iter *i)",
            "{",
            "\tsize_t ret;",
            "",
            "\tpagefault_disable();",
            "",
            "\tret = copy_from_iter_nocache(addr, bytes, i);",
            "",
            "\tpagefault_enable();",
            "",
            "\treturn ret;",
            "}",
            "static int user_event_parse_cmd(struct user_event_group *group,",
            "\t\t\t\tchar *raw_command, struct user_event **newuser,",
            "\t\t\t\tint reg_flags)",
            "{",
            "\tchar *name = raw_command;",
            "\tchar *args = strpbrk(name, \" \");",
            "\tchar *flags;",
            "",
            "\tif (args)",
            "\t\t*args++ = '\\0';",
            "",
            "\tflags = strpbrk(name, \":\");",
            "",
            "\tif (flags)",
            "\t\t*flags++ = '\\0';",
            "",
            "\treturn user_event_parse(group, name, args, flags, newuser, reg_flags);",
            "}",
            "static int user_field_array_size(const char *type)",
            "{",
            "\tconst char *start = strchr(type, '[');",
            "\tchar val[8];",
            "\tchar *bracket;",
            "\tint size = 0;",
            "",
            "\tif (start == NULL)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (strscpy(val, start + 1, sizeof(val)) <= 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tbracket = strchr(val, ']');",
            "",
            "\tif (!bracket)",
            "\t\treturn -EINVAL;",
            "",
            "\t*bracket = '\\0';",
            "",
            "\tif (kstrtouint(val, 0, &size))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (size > MAX_FIELD_ARRAY_SIZE)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn size;",
            "}"
          ],
          "function_name": "user_event_mm_dup, current_user_event_enabler_exists, user_event_last_ref, copy_nofault, user_event_parse_cmd, user_field_array_size",
          "description": "实现用户事件内存结构的复制，遍历旧enablers创建新副本，并处理失败情况；检查当前进程是否存在指定地址位的启用器；判断用户事件引用计数是否为最后引用；安全复制数据到目标地址；解析用户事件命令字符串分割名称与参数；计算用户字段数组类型大小",
          "similarity": 0.5105030536651611
        }
      ]
    }
  ]
}