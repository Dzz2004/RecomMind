{
  "query": "encryption",
  "timestamp": "2025-12-26 01:28:28",
  "retrieved_files": [
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.5840100049972534,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.5482752323150635
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.494637668132782
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.49383097887039185
        }
      ]
    },
    {
      "source_file": "kernel/locking/lockdep_internals.h",
      "md_summary": "> 自动生成时间: 2025-10-25 14:38:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\lockdep_internals.h`\n\n---\n\n# `locking/lockdep_internals.h` 技术文档\n\n## 1. 文件概述\n\n`lockdep_internals.h` 是 Linux 内核锁依赖（Lock Dependency，简称 lockdep）子系统的内部头文件，定义了 lockdep 运行时验证器所依赖的核心数据结构、枚举、宏和全局变量。该文件不对外暴露 API，仅供 lockdep 子系统内部使用，用于跟踪锁的使用状态、依赖关系、调用链以及统计信息，以检测潜在的死锁、锁顺序违规和中断上下文不一致等问题。\n\n## 2. 核心功能\n\n### 枚举与宏定义\n- `enum lock_usage_bit`：定义锁类（lock class）在不同上下文中的使用状态位（如 IRQ、softirq、hardirq 等）。\n- `LOCK_USAGE_*_MASK`：用于解析锁使用状态位的掩码（读/写方向、上下文类型）。\n- `LOCKF_*` 系列宏与常量：将使用状态位转换为位掩码，便于位运算操作，如 `LOCKF_ENABLED_IRQ`、`LOCKF_USED_IN_IRQ_READ` 等。\n- `LOCKF_IRQ` 与 `LOCKF_IRQ_READ`：组合宏，用于快速判断锁是否在中断上下文中被启用或使用。\n\n### 配置相关宏（内存优化）\n- `CONFIG_LOCKDEP_SMALL`：针对内存受限架构（如 SPARC）启用的小内存配置，限制 lockdep 数据结构的最大规模。\n- `MAX_LOCKDEP_ENTRIES`、`MAX_LOCKDEP_CHAINS_BITS`、`MAX_STACK_TRACE_ENTRIES`、`STACK_TRACE_HASH_SIZE`：定义 lockdep 跟踪能力的上限。\n\n### 锁链（Lock Chain）上下文标志\n- `LOCK_CHAIN_SOFTIRQ_CONTEXT` / `LOCK_CHAIN_HARDIRQ_CONTEXT`：标识锁链所处的中断上下文类型。\n\n### 全局变量声明\n- `lock_classes[]`：所有锁类的静态数组。\n- `lock_chains[]`：所有锁依赖链的静态数组。\n- 各类计数器：如 `nr_lock_classes`、`max_lockdep_depth`、`nr_stack_trace_entries` 等，用于跟踪 lockdep 运行状态。\n- 中断/软中断/进程上下文链数量统计：`nr_hardirq_chains`、`nr_softirq_chains`、`nr_process_chains`。\n- 内存使用统计：`nr_lost_chain_hlocks`、`nr_large_chain_blocks` 等。\n\n### 函数声明\n- `get_usage_chars()`：将锁类的使用状态转换为可读字符串。\n- `__get_key_name()`：获取锁子类键的名称。\n- `lock_chain_get_class()`：从锁链中获取第 i 个锁类。\n- `lockdep_next_lockchain()` / `lock_chain_count()`：遍历和统计锁链。\n- `lockdep_count_forward_deps()` / `lockdep_count_backward_deps()`（仅在 `CONFIG_PROVE_LOCKING` 下有效）：计算锁类的前向/后向依赖数量。\n- `lockdep_stack_trace_count()` / `lockdep_stack_hash_count()`（仅在 `CONFIG_TRACE_IRQFLAGS` 下有效）：返回栈跟踪相关统计。\n\n### 调试统计结构（`CONFIG_DEBUG_LOCKDEP`）\n- `struct lockdep_stats`：每 CPU 的 lockdep 调试统计信息，包括：\n  - 链查找命中/未命中次数\n  - 中断开关事件计数（含冗余事件）\n  - 各类检查次数（循环、前向/后向使用查找等）\n  - 每个锁类的操作计数（`lock_class_ops`）\n- 提供原子操作宏：`debug_atomic_inc/dec/read` 和 `debug_class_ops_inc/read`，用于安全更新和读取统计值。\n\n## 3. 关键实现\n\n### 锁使用状态编码\n- 使用 `lockdep_states.h` 中定义的状态（如 IRQ、SOFTIRQ、HARDIRQ 等）通过宏展开生成两组状态位：\n  - `USED_IN_*`：表示锁在该上下文中被实际使用（加锁）。\n  - `ENABLED_*`：表示锁在该上下文中被启用（即允许在该上下文中获取）。\n- 每个状态同时存在普通（写）和 `_READ`（读）版本，支持读写锁语义。\n- 状态位总数由 `LOCK_USAGE_STATES` 表示，并通过 `static_assert` 确保与 `LOCK_TRACE_STATES` 一致。\n\n### 位掩码构建\n- 利用 C 预处理器的 `#include` 技巧，在枚举和常量定义中重复包含 `lockdep_states.h`，动态生成所有状态对应的位掩码常量（如 `LOCKF_ENABLED_IRQ` 是所有 `LOCKF_ENABLED_*` 的按位或）。\n- 这种设计避免了手动维护大量状态组合，提高了可扩展性和一致性。\n\n### 内存布局优化\n- 通过 `CONFIG_LOCKDEP_SMALL` 宏，为资源受限平台（如 SPARC）提供较小的静态数组尺寸，确保内核镜像不超过 32MB 限制。\n- 默认配置则通过 Kconfig 选项（如 `CONFIG_LOCKDEP_BITS`）动态设定数据结构大小，以平衡内存占用与跟踪能力。\n\n### 调试统计的每 CPU 设计\n- 在 `CONFIG_DEBUG_LOCKDEP` 启用时，统计信息存储在 per-CPU 变量中，避免在 fast path 中因全局锁或缓存行竞争导致性能下降。\n- 提供封装宏确保在中断关闭上下文中更新统计（通过 `WARN_ON_ONCE(!irqs_disabled())` 强制约束）。\n\n## 4. 依赖关系\n\n- **依赖头文件**：\n  - `\"lockdep_states.h\"`：定义 lockdep 支持的上下文状态列表。\n  - `<asm/local.h>`：提供 per-CPU 变量操作原语（仅在 `CONFIG_DEBUG_LOCKDEP` 下）。\n- **被依赖模块**：\n  - `kernel/lockdep.c`：lockdep 主逻辑实现，大量使用本文件定义的数据结构和宏。\n  - `kernel/lockdep_proc.c`：通过本文件声明的全局变量和函数生成 `/proc/lockdep*` 调试信息。\n- **配置依赖**：\n  - `CONFIG_LOCKDEP`：启用 lockdep 子系统。\n  - `CONFIG_PROVE_LOCKING`：启用锁正确性证明（依赖前向/后向依赖计数）。\n  - `CONFIG_TRACE_IRQFLAGS`：启用中断状态跟踪（影响栈跟踪统计）。\n  - `CONFIG_DEBUG_LOCKDEP`：启用详细调试统计。\n\n## 5. 使用场景\n\n- **死锁检测**：通过 `lock_classes` 和 `lock_chains` 构建锁依赖图，运行时检测循环依赖。\n- **锁顺序验证**：记录锁获取顺序，防止违反既定顺序导致的潜在死锁。\n- **中断上下文一致性检查**：利用 `LOCKF_ENABLED_*` 和 `LOCKF_USED_IN_*` 位，确保锁不会在不允许的中断上下文中被获取（如在 hardirq 中获取仅在进程上下文启用的锁）。\n- **性能分析与调试**：通过 `lockdep_stats` 统计 lockdep 自身开销（如链查找效率、冗余检查次数），辅助优化。\n- **内核调试接口**：为 `/proc/lockdep`、`/proc/lockdep_chains` 等提供底层数据支持，供开发者分析锁行为。\n- **内存受限系统适配**：在 SPARC 等平台上，通过 `CONFIG_LOCKDEP_SMALL` 保证 lockdep 功能可用而不突破内存限制。",
      "similarity": 0.5762107372283936,
      "chunks": []
    },
    {
      "source_file": "kernel/bpf/crypto.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:08:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\crypto.c`\n\n---\n\n# `bpf/crypto.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/crypto.c` 是 Linux 内核中为 BPF（Berkeley Packet Filter）程序提供加密功能支持的核心实现文件。该文件定义了 BPF 加密上下文（`bpf_crypto_ctx`）的创建、引用管理、加解密操作等接口，并通过可扩展的类型注册机制（`bpf_crypto_type`）支持多种加密算法后端。所有接口均以 `__bpf_kfunc` 标记，供 sleepable BPF 程序在内核态安全调用。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bpf_crypto_params`**  \n  BPF 程序传入的加密初始化参数结构体，包含：\n  - `type`：加密操作类型（如 \"skcipher\"）\n  - `algo`：具体算法名称（如 \"aes-gcm\"）\n  - `key` / `key_len`：密钥及其长度\n  - `authsize`：认证标签长度（用于 AEAD 算法）\n\n- **`struct bpf_crypto_ctx`**  \n  引用计数的 BPF 加密上下文，封装了底层 crypto API 的变换对象（`tfm`），包含：\n  - `type`：指向注册的加密类型操作集\n  - `tfm`：由 `alloc_tfm()` 创建的 crypto 变换实例\n  - `siv_len`：IV（初始向量）与状态存储总大小\n  - `usage`：引用计数器，支持多 BPF 程序共享\n  - `rcu`：用于 RCU 安全释放资源\n\n- **`struct bpf_crypto_type_list`**  \n  全局加密类型注册链表节点，用于管理所有已注册的 `bpf_crypto_type`。\n\n### 主要函数\n\n- **`bpf_crypto_register_type()` / `bpf_crypto_unregister_type()`**  \n  向全局链表注册/注销一种 BPF 加密类型（如对称加密、AEAD 等），支持模块动态加载。\n\n- **`bpf_crypto_ctx_create()`**  \n  根据 `bpf_crypto_params` 创建并初始化加密上下文，执行密钥设置、认证大小配置等操作。\n\n- **`bpf_crypto_ctx_acquire()` / `bpf_crypto_ctx_release()`**  \n  实现引用计数管理，支持 BPF 程序安全地共享和释放上下文。\n\n- **`bpf_crypto_decrypt()` / `bpf_crypto_encrypt()`（隐含于 `bpf_crypto_crypt()`）**  \n  执行实际的加解密操作，通过 `bpf_dynptr_kern` 安全访问源/目标缓冲区及 IV/状态数据。\n\n## 3. 关键实现\n\n- **类型注册机制**  \n  使用读写信号量 `bpf_crypto_types_sem` 保护全局类型链表 `bpf_crypto_types`，确保并发安全。注册时检查名称唯一性，卸载时自动清理。\n\n- **模块引用管理**  \n  在 `bpf_crypto_get_type()` 中调用 `try_module_get()` 获取模块引用，在上下文释放时通过 `module_put()` 释放，防止模块卸载时使用悬空指针。\n\n- **内存与资源安全释放**  \n  上下文释放采用 RCU 机制：当引用计数归零时，通过 `call_rcu()` 异步调用 `crypto_free_cb()`，确保在所有 CPU 完成读取后再释放 `tfm` 和结构体内存。\n\n- **参数校验严格性**  \n  `bpf_crypto_ctx_create()` 对输入参数进行多层校验：\n  - 检查 `reserved` 字段是否为零（预留扩展）\n  - 验证 `params__sz` 是否匹配结构体大小\n  - 确保 `authsize` 与算法能力匹配（有/无 `setauthsize` 回调）\n  - 密钥长度合法性检查\n\n- **动态指针（dynptr）集成**  \n  加解密操作通过 `bpf_dynptr_kern` 接口访问数据，确保源/目标缓冲区权限正确（目标必须可写），并验证 IV 长度与上下文 `siv_len` 一致。\n\n## 4. 依赖关系\n\n- **BPF 子系统**  \n  依赖 `bpf_mem_alloc.h`（BPF 内存分配）、`filter.h`（BPF 程序基础）、`btf_ids.h`（BTF 类型信息）及 `__bpf_kfunc` 基础设施。\n\n- **Crypto API**  \n  通过 `crypto/skcipher.h` 等头文件调用内核加密框架，具体算法由 `bpf_crypto_type` 的回调函数（如 `alloc_tfm`, `encrypt`）桥接。\n\n- **内核通用机制**  \n  使用 `refcount_t`（引用计数）、`RCU`（安全释放）、`GFP_KERNEL`（睡眠分配）等标准内核原语。\n\n- **网络子系统**（间接）  \n  可能与 `skbuff.h` 交互（如处理网络包加密），但当前代码未直接操作 `sk_buff`。\n\n## 5. 使用场景\n\n- **BPF 程序内加密操作**  \n  Sleepable BPF 程序（如 LSM、syscall hook）可调用 `bpf_crypto_ctx_create()` 初始化 AES-GCM 等上下文，对用户数据进行加解密。\n\n- **安全协议实现**  \n  在 BPF 中实现 TLS/DTLS 记录层、IPsec ESP 等协议的加解密逻辑，利用内核 crypto API 的硬件加速能力。\n\n- **密钥管理集成**  \n  与 BPF map 结合，将加密上下文作为 `kptr` 存储，实现密钥轮换、会话管理等高级功能。\n\n- **模块化扩展**  \n  第三方模块可通过 `bpf_crypto_register_type()` 注册自定义加密类型（如国密算法），扩展 BPF 加密能力。",
      "similarity": 0.5684227347373962,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/crypto.c",
          "start_line": 60,
          "end_line": 167,
          "content": [
            "int bpf_crypto_register_type(const struct bpf_crypto_type *type)",
            "{",
            "\tstruct bpf_crypto_type_list *node;",
            "\tint err = -EEXIST;",
            "",
            "\tdown_write(&bpf_crypto_types_sem);",
            "\tlist_for_each_entry(node, &bpf_crypto_types, list) {",
            "\t\tif (!strcmp(node->type->name, type->name))",
            "\t\t\tgoto unlock;",
            "\t}",
            "",
            "\tnode = kmalloc(sizeof(*node), GFP_KERNEL);",
            "\terr = -ENOMEM;",
            "\tif (!node)",
            "\t\tgoto unlock;",
            "",
            "\tnode->type = type;",
            "\tlist_add(&node->list, &bpf_crypto_types);",
            "\terr = 0;",
            "",
            "unlock:",
            "\tup_write(&bpf_crypto_types_sem);",
            "",
            "\treturn err;",
            "}",
            "int bpf_crypto_unregister_type(const struct bpf_crypto_type *type)",
            "{",
            "\tstruct bpf_crypto_type_list *node;",
            "\tint err = -ENOENT;",
            "",
            "\tdown_write(&bpf_crypto_types_sem);",
            "\tlist_for_each_entry(node, &bpf_crypto_types, list) {",
            "\t\tif (strcmp(node->type->name, type->name))",
            "\t\t\tcontinue;",
            "",
            "\t\tlist_del(&node->list);",
            "\t\tkfree(node);",
            "\t\terr = 0;",
            "\t\tbreak;",
            "\t}",
            "\tup_write(&bpf_crypto_types_sem);",
            "",
            "\treturn err;",
            "}",
            "static void crypto_free_cb(struct rcu_head *head)",
            "{",
            "\tstruct bpf_crypto_ctx *ctx;",
            "",
            "\tctx = container_of(head, struct bpf_crypto_ctx, rcu);",
            "\tctx->type->free_tfm(ctx->tfm);",
            "\tmodule_put(ctx->type->owner);",
            "\tkfree(ctx);",
            "}",
            "__bpf_kfunc void bpf_crypto_ctx_release(struct bpf_crypto_ctx *ctx)",
            "{",
            "\tif (refcount_dec_and_test(&ctx->usage))",
            "\t\tcall_rcu(&ctx->rcu, crypto_free_cb);",
            "}",
            "static int bpf_crypto_crypt(const struct bpf_crypto_ctx *ctx,",
            "\t\t\t    const struct bpf_dynptr_kern *src,",
            "\t\t\t    const struct bpf_dynptr_kern *dst,",
            "\t\t\t    const struct bpf_dynptr_kern *siv,",
            "\t\t\t    bool decrypt)",
            "{",
            "\tu32 src_len, dst_len, siv_len;",
            "\tconst u8 *psrc;",
            "\tu8 *pdst, *piv;",
            "\tint err;",
            "",
            "\tif (__bpf_dynptr_is_rdonly(dst))",
            "\t\treturn -EINVAL;",
            "",
            "\tsiv_len = siv ? __bpf_dynptr_size(siv) : 0;",
            "\tsrc_len = __bpf_dynptr_size(src);",
            "\tdst_len = __bpf_dynptr_size(dst);",
            "\tif (!src_len || !dst_len || src_len > dst_len)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (siv_len != ctx->siv_len)",
            "\t\treturn -EINVAL;",
            "",
            "\tpsrc = __bpf_dynptr_data(src, src_len);",
            "\tif (!psrc)",
            "\t\treturn -EINVAL;",
            "\tpdst = __bpf_dynptr_data_rw(dst, dst_len);",
            "\tif (!pdst)",
            "\t\treturn -EINVAL;",
            "",
            "\tpiv = siv_len ? __bpf_dynptr_data_rw(siv, siv_len) : NULL;",
            "\tif (siv_len && !piv)",
            "\t\treturn -EINVAL;",
            "",
            "\terr = decrypt ? ctx->type->decrypt(ctx->tfm, psrc, pdst, src_len, piv)",
            "\t\t      : ctx->type->encrypt(ctx->tfm, psrc, pdst, src_len, piv);",
            "",
            "\treturn err;",
            "}",
            "__bpf_kfunc int bpf_crypto_decrypt(struct bpf_crypto_ctx *ctx,",
            "\t\t\t\t   const struct bpf_dynptr *src,",
            "\t\t\t\t   const struct bpf_dynptr *dst,",
            "\t\t\t\t   const struct bpf_dynptr *siv__nullable)",
            "{",
            "\tconst struct bpf_dynptr_kern *src_kern = (struct bpf_dynptr_kern *)src;",
            "\tconst struct bpf_dynptr_kern *dst_kern = (struct bpf_dynptr_kern *)dst;",
            "\tconst struct bpf_dynptr_kern *siv_kern = (struct bpf_dynptr_kern *)siv__nullable;",
            "",
            "\treturn bpf_crypto_crypt(ctx, src_kern, dst_kern, siv_kern, true);",
            "}"
          ],
          "function_name": "bpf_crypto_register_type, bpf_crypto_unregister_type, crypto_free_cb, bpf_crypto_ctx_release, bpf_crypto_crypt, bpf_crypto_decrypt",
          "description": "实现了BPF加密类型的注册/注销、上下文释放及加密解密操作，包含类型注册检查、上下文引用计数管理、动态指针数据操作和加密算法调用逻辑。",
          "similarity": 0.5602161884307861
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/crypto.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2024 Meta, Inc */",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_crypto.h>",
            "#include <linux/bpf_mem_alloc.h>",
            "#include <linux/btf.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/skbuff.h>",
            "#include <crypto/skcipher.h>",
            "",
            "struct bpf_crypto_type_list {",
            "\tconst struct bpf_crypto_type *type;",
            "\tstruct list_head list;",
            "};",
            "",
            "/* BPF crypto initialization parameters struct */",
            "/**",
            " * struct bpf_crypto_params - BPF crypto initialization parameters structure",
            " * @type:\tThe string of crypto operation type.",
            " * @reserved:\tReserved member, will be reused for more options in future",
            " *\t\tValues:",
            " *\t\t  0",
            " * @algo:\tThe string of algorithm to initialize.",
            " * @key:\tThe cipher key used to init crypto algorithm.",
            " * @key_len:\tThe length of cipher key.",
            " * @authsize:\tThe length of authentication tag used by algorithm.",
            " */",
            "struct bpf_crypto_params {",
            "\tchar type[14];",
            "\tu8 reserved[2];",
            "\tchar algo[128];",
            "\tu8 key[256];",
            "\tu32 key_len;",
            "\tu32 authsize;",
            "};",
            "",
            "static LIST_HEAD(bpf_crypto_types);",
            "static DECLARE_RWSEM(bpf_crypto_types_sem);",
            "",
            "/**",
            " * struct bpf_crypto_ctx - refcounted BPF crypto context structure",
            " * @type:\tThe pointer to bpf crypto type",
            " * @tfm:\tThe pointer to instance of crypto API struct.",
            " * @siv_len:    Size of IV and state storage for cipher",
            " * @rcu:\tThe RCU head used to free the crypto context with RCU safety.",
            " * @usage:\tObject reference counter. When the refcount goes to 0, the",
            " *\t\tmemory is released back to the BPF allocator, which provides",
            " *\t\tRCU safety.",
            " */",
            "struct bpf_crypto_ctx {",
            "\tconst struct bpf_crypto_type *type;",
            "\tvoid *tfm;",
            "\tu32 siv_len;",
            "\tstruct rcu_head rcu;",
            "\trefcount_t usage;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义了BPF加密相关结构体和全局变量，包括加密参数结构体bpf_crypto_params、加密上下文结构体bpf_crypto_ctx，以及用于管理加密类型的链表和读写信号量。",
          "similarity": 0.5221948027610779
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/crypto.c",
          "start_line": 334,
          "end_line": 388,
          "content": [
            "__bpf_kfunc int bpf_crypto_encrypt(struct bpf_crypto_ctx *ctx,",
            "\t\t\t\t   const struct bpf_dynptr *src,",
            "\t\t\t\t   const struct bpf_dynptr *dst,",
            "\t\t\t\t   const struct bpf_dynptr *siv__nullable)",
            "{",
            "\tconst struct bpf_dynptr_kern *src_kern = (struct bpf_dynptr_kern *)src;",
            "\tconst struct bpf_dynptr_kern *dst_kern = (struct bpf_dynptr_kern *)dst;",
            "\tconst struct bpf_dynptr_kern *siv_kern = (struct bpf_dynptr_kern *)siv__nullable;",
            "",
            "\treturn bpf_crypto_crypt(ctx, src_kern, dst_kern, siv_kern, false);",
            "}",
            "BTF_KFUNCS_START(crypt_init_kfunc_btf_ids)",
            "BTF_ID_FLAGS(func, bpf_crypto_ctx_create, KF_ACQUIRE | KF_RET_NULL | KF_SLEEPABLE)",
            "BTF_ID_FLAGS(func, bpf_crypto_ctx_release, KF_RELEASE)",
            "BTF_ID_FLAGS(func, bpf_crypto_ctx_acquire, KF_ACQUIRE | KF_RCU | KF_RET_NULL)",
            "BTF_KFUNCS_END(crypt_init_kfunc_btf_ids)",
            "",
            "static const struct btf_kfunc_id_set crypt_init_kfunc_set = {",
            "\t.owner = THIS_MODULE,",
            "\t.set   = &crypt_init_kfunc_btf_ids,",
            "};",
            "",
            "BTF_KFUNCS_START(crypt_kfunc_btf_ids)",
            "BTF_ID_FLAGS(func, bpf_crypto_decrypt, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_crypto_encrypt, KF_RCU)",
            "BTF_KFUNCS_END(crypt_kfunc_btf_ids)",
            "",
            "static const struct btf_kfunc_id_set crypt_kfunc_set = {",
            "\t.owner = THIS_MODULE,",
            "\t.set   = &crypt_kfunc_btf_ids,",
            "};",
            "",
            "BTF_ID_LIST(bpf_crypto_dtor_ids)",
            "BTF_ID(struct, bpf_crypto_ctx)",
            "BTF_ID(func, bpf_crypto_ctx_release)",
            "",
            "static int __init crypto_kfunc_init(void)",
            "{",
            "\tint ret;",
            "\tconst struct btf_id_dtor_kfunc bpf_crypto_dtors[] = {",
            "\t\t{",
            "\t\t\t.btf_id\t      = bpf_crypto_dtor_ids[0],",
            "\t\t\t.kfunc_btf_id = bpf_crypto_dtor_ids[1]",
            "\t\t},",
            "\t};",
            "",
            "\tret = register_btf_kfunc_id_set(BPF_PROG_TYPE_SCHED_CLS, &crypt_kfunc_set);",
            "\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_SCHED_ACT, &crypt_kfunc_set);",
            "\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_XDP, &crypt_kfunc_set);",
            "\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_SYSCALL,",
            "\t\t\t\t\t       &crypt_init_kfunc_set);",
            "\treturn  ret ?: register_btf_id_dtor_kfuncs(bpf_crypto_dtors,",
            "\t\t\t\t\t\t   ARRAY_SIZE(bpf_crypto_dtors),",
            "\t\t\t\t\t\t   THIS_MODULE);",
            "}"
          ],
          "function_name": "bpf_crypto_encrypt, BTF_ID_FLAGS",
          "description": "定义了BPF加密函数的BTF标识符及其属性，注册了加密操作的KFUNC集合，并初始化BTF析构函数关联，用于程序类型匹配和元数据解析。",
          "similarity": 0.5075588822364807
        }
      ]
    }
  ]
}