{
  "query": "如何通过资源有序分配实现死锁预防",
  "timestamp": "2025-12-26 01:07:05",
  "retrieved_files": [
    {
      "source_file": "kernel/locking/ww_mutex.h",
      "md_summary": "> 自动生成时间: 2025-10-25 14:56:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\ww_mutex.h`\n\n---\n\n# `locking/ww_mutex.h` 技术文档\n\n## 1. 文件概述\n\n`ww_mutex.h` 是 Linux 内核中用于实现 **Wound-Wait (WW) 互斥锁**（`ww_mutex`）的头文件。该机制主要用于解决 **死锁问题**，特别是在图形子系统（如 DRM/KMS）和资源管理场景中，多个事务（transactions）需要以特定顺序获取多个锁时。  \nWW 互斥锁通过为每个锁请求关联一个 **获取上下文**（`ww_acquire_ctx`），并基于事务的优先级或时间戳实现 **Wait-Die** 或 **Wound-Wait** 死锁避免策略。\n\n该文件通过条件编译（`WW_RT` 宏）支持两种底层锁实现：\n- **普通互斥锁**（`mutex`）：用于非实时（non-RT）内核配置。\n- **实时互斥锁**（`rt_mutex`）：用于实时（RT）内核补丁配置，支持优先级继承。\n\n## 2. 核心功能\n\n### 2.1 主要宏定义\n- `MUTEX` / `MUTEX_WAITER`：根据 `WW_RT` 宏分别映射到 `mutex`/`rt_mutex` 及其等待者结构。\n\n### 2.2 等待者链表/红黑树操作函数（抽象接口）\n- `__ww_waiter_first()`：获取等待队列中的第一个等待者。\n- `__ww_waiter_next()` / `__ww_waiter_prev()`：获取下一个/上一个等待者。\n- `__ww_waiter_last()`：获取等待队列中的最后一个等待者。\n- `__ww_waiter_add()`：将等待者插入到指定位置（普通 mutex 使用链表，RT 使用红黑树）。\n\n### 2.3 锁状态查询函数\n- `__ww_mutex_owner()`：获取当前锁的持有者任务。\n- `__ww_mutex_has_waiters()`：检查锁是否有等待者。\n- `lock_wait_lock()` / `unlock_wait_lock()`：获取/释放锁的等待队列自旋锁（`wait_lock`）。\n- `lockdep_assert_wait_lock_held()`：调试时断言 `wait_lock` 已被持有。\n\n### 2.4 WW 互斥锁核心逻辑函数\n- `ww_mutex_lock_acquired()`：在成功获取 `ww_mutex` 后，将其与获取上下文（`ww_ctx`）关联，并执行调试检查。\n- `__ww_ctx_less()`：比较两个获取上下文的优先级（用于决定谁应“等待”或“死亡/被抢占”）。\n- `__ww_mutex_die()`：**Wait-Die 策略**实现：若当前请求者（新事务）发现等待队列中有更老的事务持有其他锁，则唤醒该老事务使其“死亡”（回滚）。\n- `__ww_mutex_wound()`：**Wound-Wait 策略**实现：若当前请求者（老事务）发现锁持有者是更年轻的事务，则“刺伤”（标记 `wounded=1`）该年轻事务，迫使其回滚。\n\n## 3. 关键实现\n\n### 3.1 死锁避免策略\n- **Wait-Die**（`is_wait_die=1`）：\n  - **新事务**请求**老事务**持有的锁 → **新事务等待**。\n  - **新事务**请求**老事务**等待的锁 → **新事务死亡**（回滚）。\n- **Wound-Wait**（`is_wait_die=0`）：\n  - **老事务**请求**新事务**持有的锁 → **新事务被刺伤**（回滚）。\n  - **老事务**请求**新事务**等待的锁 → **老事务等待**。\n\n### 3.2 上下文比较 (`__ww_ctx_less`)\n- **非 RT 模式**：仅基于时间戳（`stamp`），值越大表示事务越新。\n- **RT 模式**：\n  1. 优先比较 **实时优先级**（`prio`），数值越小优先级越高。\n  2. 若均为 **Deadline 调度类**，比较 **截止时间**（`deadline`），越早截止优先级越高。\n  3. 若优先级相同，回退到时间戳比较。\n\n### 3.3 RT 与非 RT 差异\n- **数据结构**：\n  - 非 RT：等待者使用 **双向链表**（`list_head`）。\n  - RT：等待者使用 **红黑树**（`rb_root`），按优先级排序。\n- **插入逻辑**：\n  - 非 RT：`__ww_waiter_add` 显式插入到指定位置。\n  - RT：`__ww_waiter_add` 为空（RT 互斥锁内部自动处理插入）。\n\n### 3.4 调试支持 (`DEBUG_WW_MUTEXES`)\n- 检查 `ww_mutex` 是否被错误地用普通 `mutex_unlock` 释放。\n- 验证上下文一致性（如 `ww_class` 匹配、`contending_lock` 状态等）。\n\n## 4. 依赖关系\n\n- **基础锁机制**：\n  - 非 RT 模式依赖 `<linux/mutex.h>`。\n  - RT 模式依赖 `<linux/rtmutex.h>`。\n- **调度器**：依赖任务结构（`task_struct`）、优先级（`prio`）、调度类（如 `dl_prio`）。\n- **调试框架**：依赖 `lockdep`（`lockdep_assert_held`）和 `DEBUG_LOCKS_WARN_ON`。\n- **原子操作**：使用 `atomic_long_read` 检查锁状态标志（`MUTEX_FLAG_WAITERS`）。\n\n## 5. 使用场景\n\n- **图形子系统**（DRM/KMS）：  \n  多个 GPU 作业（如渲染、合成）需按顺序获取多个缓冲区（buffer）或 CRTC 锁，避免死锁。\n- **资源分配器**：  \n  当多个客户端竞争一组有限资源（如内存区域、I/O 端口）时，通过 WW 互斥锁确保无死锁的分配顺序。\n- **实时系统**（RT 补丁）：  \n  在需要确定性延迟的场景中，结合优先级继承（PI）避免优先级反转，同时通过 WW 策略解决多锁死锁。\n- **文件系统**：  \n  某些文件系统（如 Btrfs）在元数据操作中使用 WW 互斥锁管理多个 extent 锁。",
      "similarity": 0.5662933588027954,
      "chunks": []
    },
    {
      "source_file": "kernel/locking/osq_lock.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:43:41\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\osq_lock.c`\n\n---\n\n# `locking/osq_lock.c` 技术文档\n\n## 1. 文件概述\n\n`osq_lock.c` 实现了一种专为**乐观自旋（Optimistic Spinning）**设计的轻量级排队自旋锁机制，称为 **OSQ（Optimistic Spin Queue）锁**。该机制主要用于支持如互斥锁（mutex）、读写信号量（rwsem）等**可睡眠锁**在争用时进行乐观自旋，以避免不必要的上下文切换和调度开销。OSQ 锁基于 MCS（Mellor-Crummey and Scott）锁的思想，但针对 Linux 内核的调度和抢占模型进行了优化，利用每个 CPU 的静态 per-CPU 节点结构，确保在禁用抢占的自旋上下文中安全使用。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct optimistic_spin_node`：每个 CPU 对应一个静态节点，包含：\n  - `cpu`：编码后的 CPU 编号（实际值 = CPU ID + 1）\n  - `locked`：布尔标志，表示是否已获得锁\n  - `next`：指向队列中下一个节点的指针\n  - `prev`：指向前一个节点的指针\n- `struct optimistic_spin_queue`：OSQ 锁结构体，仅包含一个原子变量 `tail`，用于指向队列尾部（编码后的 CPU 编号），`OSQ_UNLOCKED_VAL`（值为 0）表示无锁。\n\n### 主要函数\n- `bool osq_lock(struct optimistic_spin_queue *lock)`  \n  尝试获取 OSQ 锁。若成功获得锁或决定放弃自旋（如需要调度或前驱被抢占），返回 `true`；若成功排队但未获得锁且需继续等待，则返回 `false`（实际逻辑中，失败路径最终也返回 `false` 表示未获得锁）。\n  \n- `void osq_unlock(struct optimistic_spin_queue *lock)`  \n  释放 OSQ 锁，唤醒队列中的下一个等待者（若存在）。\n\n- `static inline struct optimistic_spin_node *osq_wait_next(...)`  \n  辅助函数，用于在解锁或取消排队时安全地获取下一个节点，并处理队列尾部的原子更新。\n\n- `encode_cpu()` / `decode_cpu()` / `node_cpu()`  \n  用于在 CPU 编号与 per-CPU 节点指针之间进行编码/解码转换，其中 CPU 编号 0 被编码为 1，以 0 表示“无 CPU”（即锁空闲）。\n\n## 3. 关键实现\n\n### Per-CPU 静态节点设计\n- 每个 CPU 拥有一个静态的 `osq_node`（通过 `DEFINE_PER_CPU_SHARED_ALIGNED` 定义），避免动态分配开销。\n- 由于 OSQ 仅在**禁用抢占**的上下文中使用（如 mutex 的乐观自旋阶段），且**不可在中断上下文调用**，因此 per-CPU 节点的生命周期安全。\n\n### 锁获取流程 (`osq_lock`)\n1. **初始化本地节点**：设置 `locked=0`、`next=NULL`，并确保 `cpu` 字段为当前 CPU 编码值。\n2. **原子交换尾指针**：通过 `atomic_xchg(&lock->tail, curr)` 尝试入队。若原值为 `OSQ_UNLOCKED_VAL`，直接获得锁。\n3. **链接到前驱**：若已有前驱（`prev`），通过 `smp_wmb()` 确保内存顺序后，设置 `prev->next = node`。\n4. **自旋等待**：使用 `smp_cond_load_relaxed()` 等待 `node->locked` 变为 1，或满足退出条件（`need_resched()` 或前驱 CPU 被抢占 `vcpu_is_preempted()`）。\n5. **取消排队（Unqueue）**：若需退出自旋：\n   - **Step A**：尝试将 `prev->next` 置为 `NULL`，断开链接。\n   - **Step B**：调用 `osq_wait_next()` 确定下一个节点，并可能将锁尾指针回退。\n   - **Step C**：若存在 `next`，将其与 `prev` 直接链接，完成队列修复。\n\n### 锁释放流程 (`osq_unlock`)\n1. **快速路径**：若当前 CPU 是唯一持有者（`tail == curr`），直接将 `tail` 设为 `OSQ_UNLOCKED_VAL`。\n2. **慢速路径**：\n   - 若本地节点的 `next` 非空，直接设置 `next->locked = 1` 唤醒后继。\n   - 否则调用 `osq_wait_next()` 获取下一个节点（处理并发取消排队的情况），再唤醒。\n\n### 内存屏障与原子操作\n- 使用 `atomic_xchg`、`atomic_cmpxchg_acquire/release` 确保对 `lock->tail` 的操作具有适当的内存序。\n- `smp_wmb()` 保证在设置 `prev->next` 前，本地节点的初始化对其他 CPU 可见。\n- `WRITE_ONCE`/`READ_ONCE` 防止编译器优化破坏并发访问语义。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/percpu.h>`：提供 per-CPU 变量支持（`this_cpu_ptr`, `per_cpu_ptr`）。\n  - `<linux/sched.h>`：提供调度相关函数（`need_resched()`）和虚拟 CPU 抢占检测（`vcpu_is_preempted()`）。\n  - `<linux/osq_lock.h>`：定义 `struct optimistic_spin_queue`、`struct optimistic_spin_node` 及 `OSQ_UNLOCKED_VAL`。\n- **架构依赖**：依赖底层架构的原子操作（`atomic_*`）、内存屏障（`smp_wmb`, `smp_load_acquire`）和 CPU ID 获取（`smp_processor_id()`）。\n- **调度器集成**：与内核调度器紧密协作，通过 `need_resched()` 和 `vcpu_is_preempted()` 决定是否继续自旋。\n\n## 5. 使用场景\n\nOSQ 锁主要用于**可睡眠锁的乐观自旋优化**，典型场景包括：\n- **Mutex（互斥锁）**：在 `mutex_spin_on_owner()` 中，若锁持有者正在运行，当前 CPU 会尝试 OSQ 自旋而非立即睡眠。\n- **Rwsem（读写信号量）**：在写者争用时，若满足条件，会使用 OSQ 进行乐观自旋。\n- **其他睡眠锁**：任何希望在锁争用时避免立即进入睡眠、以降低延迟的同步原语。\n\n其核心价值在于：当锁持有者很可能在**另一个 CPU 上运行且未被抢占**时，通过短暂自旋可避免昂贵的上下文切换，提升性能；同时通过 `vcpu_is_preempted()` 检测虚拟化环境中的抢占，避免在持有者已让出 CPU 时无效自旋。",
      "similarity": 0.54390549659729,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/osq_lock.c",
          "start_line": 213,
          "end_line": 238,
          "content": [
            "void osq_unlock(struct optimistic_spin_queue *lock)",
            "{",
            "\tstruct optimistic_spin_node *node, *next;",
            "\tint curr = encode_cpu(smp_processor_id());",
            "",
            "\t/*",
            "\t * Fast path for the uncontended case.",
            "\t */",
            "\tif (likely(atomic_cmpxchg_release(&lock->tail, curr,",
            "\t\t\t\t\t  OSQ_UNLOCKED_VAL) == curr))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Second most likely case.",
            "\t */",
            "\tnode = this_cpu_ptr(&osq_node);",
            "\tnext = xchg(&node->next, NULL);",
            "\tif (next) {",
            "\t\tWRITE_ONCE(next->locked, 1);",
            "\t\treturn;",
            "\t}",
            "",
            "\tnext = osq_wait_next(lock, node, NULL);",
            "\tif (next)",
            "\t\tWRITE_ONCE(next->locked, 1);",
            "}"
          ],
          "function_name": "osq_unlock",
          "description": "实现osq_unlock函数，处理锁的释放。通过原子比较交换操作快速处理无竞争情况，否则查找并唤醒下一个等待节点，确保锁状态的正确性与线程安全。",
          "similarity": 0.5612870454788208
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/osq_lock.c",
          "start_line": 20,
          "end_line": 149,
          "content": [
            "static inline int encode_cpu(int cpu_nr)",
            "{",
            "\treturn cpu_nr + 1;",
            "}",
            "static inline int node_cpu(struct optimistic_spin_node *node)",
            "{",
            "\treturn node->cpu - 1;",
            "}",
            "bool osq_lock(struct optimistic_spin_queue *lock)",
            "{",
            "\tstruct optimistic_spin_node *node = this_cpu_ptr(&osq_node);",
            "\tstruct optimistic_spin_node *prev, *next;",
            "\tint curr = encode_cpu(smp_processor_id());",
            "\tint old;",
            "",
            "\tnode->locked = 0;",
            "\tnode->next = NULL;",
            "\t/*",
            "\t * After this cpu member is initialized for the first time, it",
            "\t * would no longer change in fact. That could avoid cache misses",
            "\t * when spin and access the cpu member by other CPUs.",
            "\t */",
            "\tif (node->cpu != curr)",
            "\t\tnode->cpu = curr;",
            "",
            "\t/*",
            "\t * We need both ACQUIRE (pairs with corresponding RELEASE in",
            "\t * unlock() uncontended, or fastpath) and RELEASE (to publish",
            "\t * the node fields we just initialised) semantics when updating",
            "\t * the lock tail.",
            "\t */",
            "\told = atomic_xchg(&lock->tail, curr);",
            "\tif (old == OSQ_UNLOCKED_VAL)",
            "\t\treturn true;",
            "",
            "\tprev = decode_cpu(old);",
            "\tnode->prev = prev;",
            "",
            "\t/*",
            "\t * osq_lock()\t\t\tunqueue",
            "\t *",
            "\t * node->prev = prev\t\tosq_wait_next()",
            "\t * WMB\t\t\t\tMB",
            "\t * prev->next = node\t\tnext->prev = prev // unqueue-C",
            "\t *",
            "\t * Here 'node->prev' and 'next->prev' are the same variable and we need",
            "\t * to ensure these stores happen in-order to avoid corrupting the list.",
            "\t */",
            "\tsmp_wmb();",
            "",
            "\tWRITE_ONCE(prev->next, node);",
            "",
            "\t/*",
            "\t * Normally @prev is untouchable after the above store; because at that",
            "\t * moment unlock can proceed and wipe the node element from stack.",
            "\t *",
            "\t * However, since our nodes are static per-cpu storage, we're",
            "\t * guaranteed their existence -- this allows us to apply",
            "\t * cmpxchg in an attempt to undo our queueing.",
            "\t */",
            "",
            "\t/*",
            "\t * Wait to acquire the lock or cancellation. Note that need_resched()",
            "\t * will come with an IPI, which will wake smp_cond_load_relaxed() if it",
            "\t * is implemented with a monitor-wait. vcpu_is_preempted() relies on",
            "\t * polling, be careful.",
            "\t */",
            "\tif (smp_cond_load_relaxed(&node->locked, VAL || need_resched() ||",
            "\t\t\t\t  vcpu_is_preempted(node_cpu(node->prev))))",
            "\t\treturn true;",
            "",
            "\t/* unqueue */",
            "\t/*",
            "\t * Step - A  -- stabilize @prev",
            "\t *",
            "\t * Undo our @prev->next assignment; this will make @prev's",
            "\t * unlock()/unqueue() wait for a next pointer since @lock points to us",
            "\t * (or later).",
            "\t */",
            "",
            "\tfor (;;) {",
            "\t\t/*",
            "\t\t * cpu_relax() below implies a compiler barrier which would",
            "\t\t * prevent this comparison being optimized away.",
            "\t\t */",
            "\t\tif (data_race(prev->next) == node &&",
            "\t\t    cmpxchg(&prev->next, node, NULL) == node)",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * We can only fail the cmpxchg() racing against an unlock(),",
            "\t\t * in which case we should observe @node->locked becoming",
            "\t\t * true.",
            "\t\t */",
            "\t\tif (smp_load_acquire(&node->locked))",
            "\t\t\treturn true;",
            "",
            "\t\tcpu_relax();",
            "",
            "\t\t/*",
            "\t\t * Or we race against a concurrent unqueue()'s step-B, in which",
            "\t\t * case its step-C will write us a new @node->prev pointer.",
            "\t\t */",
            "\t\tprev = READ_ONCE(node->prev);",
            "\t}",
            "",
            "\t/*",
            "\t * Step - B -- stabilize @next",
            "\t *",
            "\t * Similar to unlock(), wait for @node->next or move @lock from @node",
            "\t * back to @prev.",
            "\t */",
            "",
            "\tnext = osq_wait_next(lock, node, prev);",
            "\tif (!next)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Step - C -- unlink",
            "\t *",
            "\t * @prev is stable because its still waiting for a new @prev->next",
            "\t * pointer, @next is stable because our @node->next pointer is NULL and",
            "\t * it will wait in Step-A.",
            "\t */",
            "",
            "\tWRITE_ONCE(next->prev, prev);",
            "\tWRITE_ONCE(prev->next, next);",
            "",
            "\treturn false;",
            "}"
          ],
          "function_name": "encode_cpu, node_cpu, osq_lock",
          "description": "实现osq_lock函数，负责获取乐观自旋锁。通过原子操作将当前节点插入队列，利用内存屏障保证顺序一致性，并通过循环等待条件满足或被唤醒，最终完成锁的获取过程。",
          "similarity": 0.5275454521179199
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/osq_lock.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/percpu.h>",
            "#include <linux/sched.h>",
            "#include <linux/osq_lock.h>",
            "",
            "/*",
            " * An MCS like lock especially tailored for optimistic spinning for sleeping",
            " * lock implementations (mutex, rwsem, etc).",
            " *",
            " * Using a single mcs node per CPU is safe because sleeping locks should not be",
            " * called from interrupt context and we have preemption disabled while",
            " * spinning.",
            " */",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct optimistic_spin_node, osq_node);",
            "",
            "/*",
            " * We use the value 0 to represent \"no CPU\", thus the encoded value",
            " * will be the CPU number incremented by 1.",
            " */"
          ],
          "function_name": null,
          "description": "定义全局的per-CPU乐观自旋节点osq_node，用于支持多CPU环境下乐观自旋锁的实现。通过encode_cpu和node_cpu函数处理CPU编号转换，为后续锁操作提供基础设施。",
          "similarity": 0.4707271456718445
        }
      ]
    },
    {
      "source_file": "kernel/power/wakelock.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:29:10\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `power\\wakelock.c`\n\n---\n\n# `power/wakelock.c` 技术文档\n\n## 1. 文件概述\n\n`power/wakelock.c` 实现了 Linux 内核中面向用户空间的 **wakelock（唤醒锁）机制**，允许用户空间程序通过 sysfs 接口创建、激活和释放唤醒锁，以防止系统在特定任务执行期间进入低功耗状态（如 suspend）。该实现借鉴了 Android 系统中的 wakelock 接口，但基于标准 Linux 内核的 `wakeup_source` 基础设施，提供更安全、可配置的用户空间电源管理能力。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct wakelock`**  \n  表示一个用户空间可操作的唤醒锁对象：\n  - `name`：唤醒锁名称（用户指定）\n  - `node`：用于在红黑树 `wakelocks_tree` 中组织所有 wakelock\n  - `ws`：指向内核 `wakeup_source` 对象，实际执行电源管理逻辑\n  - `lru`（条件编译）：用于垃圾回收（GC）机制的 LRU 链表节点（当 `CONFIG_PM_WAKELOCKS_GC` 启用时）\n\n### 主要函数\n\n- **`pm_show_wakelocks(char *buf, bool show_active)`**  \n  将当前所有（活跃或非活跃）wakelock 名称输出到缓冲区，供 sysfs 读取（如 `/sys/power/wake_lock` 或 `/sys/power/wake_unlock`）。\n\n- **`pm_wake_lock(const char *buf)`**  \n  用户空间通过写入 `/sys/power/wake_lock` 触发此函数，用于**获取**指定名称的 wakelock。支持可选超时参数（单位：纳秒）。\n\n- **`pm_wake_unlock(const char *buf)`**  \n  用户空间通过写入 `/sys/power/wake_unlock` 触发此函数，用于**释放**指定名称的 wakelock。\n\n- **`wakelock_lookup_add(const char *name, size_t len, bool add_if_not_found)`**  \n  在全局红黑树中查找或创建 wakelock 对象，是 `pm_wake_lock` 和 `pm_wake_unlock` 的核心辅助函数。\n\n- **`__wakelocks_gc(struct work_struct *work)`**（条件编译）  \n  垃圾回收工作函数，定期清理长时间未使用且非活跃的 wakelock 对象（当 `CONFIG_PM_WAKELOCKS_GC` 启用时）。\n\n### 辅助机制\n\n- **数量限制**：通过 `CONFIG_PM_WAKELOCKS_LIMIT` 控制系统中 wakelock 的最大数量。\n- **LRU 管理**：通过 `wakelocks_lru_add` / `wakelocks_lru_most_recent` 维护最近使用顺序。\n- **自动回收**：通过 `wakelocks_gc()` 触发异步 GC 工作队列。\n\n## 3. 关键实现\n\n### 红黑树管理\n所有 `wakelock` 对象通过名称作为键，存储在全局红黑树 `wakelocks_tree` 中，确保 O(log n) 时间复杂度的查找、插入和删除操作。\n\n### 唤醒源集成\n每个 `wakelock` 封装一个 `wakeup_source`（通过 `wakeup_source_register()` 创建），实际的电源阻止逻辑由内核 PM 子系统的 `wakeup_source` 机制处理：\n- `__pm_stay_awake(ws)`：永久保持唤醒（直到显式释放）\n- `__pm_wakeup_event(ws, timeout_ms)`：带超时的唤醒\n- `__pm_relax(ws)`：释放唤醒锁\n\n### 安全与权限控制\n- 仅具备 `CAP_BLOCK_SUSPEND` 能力的进程可操作 wakelock（防止普通用户滥用导致无法休眠）。\n- 名称解析严格处理空格和换行符，防止注入或解析错误。\n\n### 垃圾回收机制（可选）\n当启用 `CONFIG_PM_WAKELOCKS_GC`：\n- 每次访问 wakelock 时将其移至 LRU 链表头部（`wakelocks_lru_most_recent`）。\n- 每进行 `WL_GC_COUNT_MAX`（默认 100）次操作后，调度 GC 工作。\n- GC 遍历 LRU 链表（从最旧开始），删除满足以下条件的对象：\n  - 非活跃（`!active`）\n  - 空闲时间超过 `WL_GC_TIME_SEC`（默认 300 秒）\n\n### 数量限制（可选）\n当 `CONFIG_PM_WAKELOCKS_LIMIT > 0` 时，系统维护 `number_of_wakelocks` 计数器，防止用户空间创建过多 wakelock 耗尽内存。\n\n## 4. 依赖关系\n\n- **内核头文件**：\n  - `<linux/wakeup_source.h>`（通过 `\"power.h\"` 间接包含）：提供 `wakeup_source` 相关 API\n  - `<linux/sysfs.h>`：通过 `sysfs_emit_at` 实现 sysfs 输出\n  - `<linux/workqueue.h>`：用于 GC 异步任务调度\n  - `<linux/rbtree.h>`：红黑树数据结构支持\n  - `<linux/capability.h>`：权限检查\n\n- **内核子系统**：\n  - **电源管理 (PM) 子系统**：依赖 `wakeup_source` 基础设施实现实际的 suspend 阻止逻辑。\n  - **sysfs**：通过 sysfs 文件（如 `/sys/power/wake_lock`）暴露用户接口。\n  - **内存管理**：使用 `kzalloc`/`kstrndup`/`kfree` 管理动态内存。\n\n- **配置选项**：\n  - `CONFIG_PM_WAKELOCKS`：主开关\n  - `CONFIG_PM_WAKELOCKS_LIMIT`：限制最大数量\n  - `CONFIG_PM_WAKELOCKS_GC`：启用自动垃圾回收\n\n## 5. 使用场景\n\n- **Android 兼容层**：为基于 Android 的系统提供标准 Linux 内核上的 wakelock 支持，无需修改用户空间应用。\n- **用户空间电源控制**：允许特权应用（如媒体播放器、下载管理器）在执行关键任务时阻止系统休眠。\n- **调试与监控**：通过读取 `/sys/power/wake_lock` 查看当前活跃的 wakelock，辅助电源问题诊断。\n- **资源受限设备**：通过 `CONFIG_PM_WAKELOCKS_LIMIT` 和 GC 机制防止内存泄漏，适用于嵌入式或移动设备。",
      "similarity": 0.5428935289382935,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/power/wakelock.c",
          "start_line": 254,
          "end_line": 288,
          "content": [
            "int pm_wake_unlock(const char *buf)",
            "{",
            "\tstruct wakelock *wl;",
            "\tsize_t len;",
            "\tint ret = 0;",
            "",
            "\tif (!capable(CAP_BLOCK_SUSPEND))",
            "\t\treturn -EPERM;",
            "",
            "\tlen = strlen(buf);",
            "\tif (!len)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (buf[len-1] == '\\n')",
            "\t\tlen--;",
            "",
            "\tif (!len)",
            "\t\treturn -EINVAL;",
            "",
            "\tmutex_lock(&wakelocks_lock);",
            "",
            "\twl = wakelock_lookup_add(buf, len, false);",
            "\tif (IS_ERR(wl)) {",
            "\t\tret = PTR_ERR(wl);",
            "\t\tgoto out;",
            "\t}",
            "\t__pm_relax(wl->ws);",
            "",
            "\twakelocks_lru_most_recent(wl);",
            "\twakelocks_gc();",
            "",
            " out:",
            "\tmutex_unlock(&wakelocks_lock);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "pm_wake_unlock",
          "description": "提供唤醒锁解除接口，通过名称匹配目标唤醒锁并调用__pm_relax释放，同步更新LRU顺序并触发动态垃圾回收机制",
          "similarity": 0.532091498374939
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/power/wakelock.c",
          "start_line": 38,
          "end_line": 172,
          "content": [
            "ssize_t pm_show_wakelocks(char *buf, bool show_active)",
            "{",
            "\tstruct rb_node *node;",
            "\tstruct wakelock *wl;",
            "\tint len = 0;",
            "",
            "\tmutex_lock(&wakelocks_lock);",
            "",
            "\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {",
            "\t\twl = rb_entry(node, struct wakelock, node);",
            "\t\tif (wl->ws->active == show_active)",
            "\t\t\tlen += sysfs_emit_at(buf, len, \"%s \", wl->name);",
            "\t}",
            "",
            "\tif (len > 0)",
            "\t\t--len;",
            "",
            "\tlen += sysfs_emit_at(buf, len, \"\\n\");",
            "",
            "\tmutex_unlock(&wakelocks_lock);",
            "\treturn len;",
            "}",
            "static inline bool wakelocks_limit_exceeded(void)",
            "{",
            "\treturn number_of_wakelocks > CONFIG_PM_WAKELOCKS_LIMIT;",
            "}",
            "static inline void increment_wakelocks_number(void)",
            "{",
            "\tnumber_of_wakelocks++;",
            "}",
            "static inline void decrement_wakelocks_number(void)",
            "{",
            "\tnumber_of_wakelocks--;",
            "}",
            "static inline bool wakelocks_limit_exceeded(void) { return false; }",
            "static inline void increment_wakelocks_number(void) {}",
            "static inline void decrement_wakelocks_number(void) {}",
            "static inline void wakelocks_lru_add(struct wakelock *wl)",
            "{",
            "\tlist_add(&wl->lru, &wakelocks_lru_list);",
            "}",
            "static inline void wakelocks_lru_most_recent(struct wakelock *wl)",
            "{",
            "\tlist_move(&wl->lru, &wakelocks_lru_list);",
            "}",
            "static void __wakelocks_gc(struct work_struct *work)",
            "{",
            "\tstruct wakelock *wl, *aux;",
            "\tktime_t now;",
            "",
            "\tmutex_lock(&wakelocks_lock);",
            "",
            "\tnow = ktime_get();",
            "\tlist_for_each_entry_safe_reverse(wl, aux, &wakelocks_lru_list, lru) {",
            "\t\tu64 idle_time_ns;",
            "\t\tbool active;",
            "",
            "\t\tspin_lock_irq(&wl->ws->lock);",
            "\t\tidle_time_ns = ktime_to_ns(ktime_sub(now, wl->ws->last_time));",
            "\t\tactive = wl->ws->active;",
            "\t\tspin_unlock_irq(&wl->ws->lock);",
            "",
            "\t\tif (idle_time_ns < ((u64)WL_GC_TIME_SEC * NSEC_PER_SEC))",
            "\t\t\tbreak;",
            "",
            "\t\tif (!active) {",
            "\t\t\twakeup_source_unregister(wl->ws);",
            "\t\t\trb_erase(&wl->node, &wakelocks_tree);",
            "\t\t\tlist_del(&wl->lru);",
            "\t\t\tkfree(wl->name);",
            "\t\t\tkfree(wl);",
            "\t\t\tdecrement_wakelocks_number();",
            "\t\t}",
            "\t}",
            "\twakelocks_gc_count = 0;",
            "",
            "\tmutex_unlock(&wakelocks_lock);",
            "}",
            "static void wakelocks_gc(void)",
            "{",
            "\tif (++wakelocks_gc_count <= WL_GC_COUNT_MAX)",
            "\t\treturn;",
            "",
            "\tschedule_work(&wakelock_work);",
            "}",
            "static inline void wakelocks_lru_add(struct wakelock *wl) {}",
            "static inline void wakelocks_lru_most_recent(struct wakelock *wl) {}",
            "static inline void wakelocks_gc(void) {}",
            "int pm_wake_lock(const char *buf)",
            "{",
            "\tconst char *str = buf;",
            "\tstruct wakelock *wl;",
            "\tu64 timeout_ns = 0;",
            "\tsize_t len;",
            "\tint ret = 0;",
            "",
            "\tif (!capable(CAP_BLOCK_SUSPEND))",
            "\t\treturn -EPERM;",
            "",
            "\twhile (*str && !isspace(*str))",
            "\t\tstr++;",
            "",
            "\tlen = str - buf;",
            "\tif (!len)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (*str && *str != '\\n') {",
            "\t\t/* Find out if there's a valid timeout string appended. */",
            "\t\tret = kstrtou64(skip_spaces(str), 10, &timeout_ns);",
            "\t\tif (ret)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tmutex_lock(&wakelocks_lock);",
            "",
            "\twl = wakelock_lookup_add(buf, len, true);",
            "\tif (IS_ERR(wl)) {",
            "\t\tret = PTR_ERR(wl);",
            "\t\tgoto out;",
            "\t}",
            "\tif (timeout_ns) {",
            "\t\tu64 timeout_ms = timeout_ns + NSEC_PER_MSEC - 1;",
            "",
            "\t\tdo_div(timeout_ms, NSEC_PER_MSEC);",
            "\t\t__pm_wakeup_event(wl->ws, timeout_ms);",
            "\t} else {",
            "\t\t__pm_stay_awake(wl->ws);",
            "\t}",
            "",
            "\twakelocks_lru_most_recent(wl);",
            "",
            " out:",
            "\tmutex_unlock(&wakelocks_lock);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "pm_show_wakelocks, wakelocks_limit_exceeded, increment_wakelocks_number, decrement_wakelocks_number, wakelocks_limit_exceeded, increment_wakelocks_number, decrement_wakelocks_number, wakelocks_lru_add, wakelocks_lru_most_recent, __wakelocks_gc, wakelocks_gc, wakelocks_lru_add, wakelocks_lru_most_recent, wakelocks_gc, pm_wake_lock",
          "description": "实现唤醒锁状态展示、计数控制、LRU列表维护及垃圾回收逻辑，包含唤醒锁激活/释放接口，通过工作队列异步清理闲置唤醒源",
          "similarity": 0.514365017414093
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/power/wakelock.c",
          "start_line": 1,
          "end_line": 37,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * kernel/power/wakelock.c",
            " *",
            " * User space wakeup sources support.",
            " *",
            " * Copyright (C) 2012 Rafael J. Wysocki <rjw@sisk.pl>",
            " *",
            " * This code is based on the analogous interface allowing user space to",
            " * manipulate wakelocks on Android.",
            " */",
            "",
            "#include <linux/capability.h>",
            "#include <linux/ctype.h>",
            "#include <linux/device.h>",
            "#include <linux/err.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/list.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "",
            "#include \"power.h\"",
            "",
            "static DEFINE_MUTEX(wakelocks_lock);",
            "",
            "struct wakelock {",
            "\tchar\t\t\t*name;",
            "\tstruct rb_node\t\tnode;",
            "\tstruct wakeup_source\t*ws;",
            "#ifdef CONFIG_PM_WAKELOCKS_GC",
            "\tstruct list_head\tlru;",
            "#endif",
            "};",
            "",
            "static struct rb_root wakelocks_tree = RB_ROOT;",
            ""
          ],
          "function_name": null,
          "description": "定义唤醒锁数据结构及其红黑树管理基础，包含名称字段、RB节点、唤醒源指针及LRU链表节点（CONFIG_PM_WAKELOCKS_GC启用时），并初始化红黑树根节点",
          "similarity": 0.4787994623184204
        }
      ]
    }
  ]
}