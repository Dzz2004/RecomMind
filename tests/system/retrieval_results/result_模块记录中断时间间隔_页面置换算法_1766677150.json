{
  "query": "模块记录中断时间间隔 页面置换算法",
  "timestamp": "2025-12-25 23:39:10",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/timings.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:10:35\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\timings.c`\n\n---\n\n# irq/timings.c 技术文档\n\n## 1. 文件概述\n\n`irq/timings.c` 是 Linux 内核中用于中断时间预测的核心模块。该文件实现了基于历史中断时间戳的预测算法，旨在通过分析中断发生的周期性模式，预测下一次中断可能发生的时间。此功能主要用于低功耗场景（如 CPU 空闲状态管理），帮助调度器或电源管理子系统更精确地设置唤醒时间，从而在保证响应性的同时减少不必要的唤醒开销。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct irq_timings`：每个 CPU 私有的中断时间记录结构，包含一个循环缓冲区，用于存储 `<中断号, 时间戳>` 元组。\n- `irqt_stats`：全局 IDR（整数到指针映射）结构，用于按中断号索引中断统计信息。\n- `irq_timing_enabled`：静态分支键（`static_key`），用于在运行时动态启用/禁用中断时间跟踪功能，避免性能开销。\n\n### 主要函数\n\n- `irq_timings_enable(void)`：启用中断时间跟踪功能，激活静态分支。\n- `irq_timings_disable(void)`：禁用中断时间跟踪功能，关闭静态分支。\n- （注：实际的预测算法逻辑虽未在代码片段中完整展示，但文档详细描述了其实现原理）\n\n## 3. 关键实现\n\n### 中断时间预测算法\n\n该模块采用三阶段算法预测中断周期：\n\n#### 1) 后缀数组（Suffix Array）模式识别\n- 将中断间隔（经 `ilog2` 映射后的索引值）序列视为字符串。\n- 构建长度为 2 到 5 的后缀（受限于实际设备周期经验）。\n- 在最近 `3 × max_period`（即 15）个索引中搜索后缀的重复出现。\n- 若某后缀连续出现 3 次，则认为发现有效周期模式，其长度即为预测周期。\n\n#### 2) 对数间隔桶（Log Interval Bucketing）\n- 使用 `ilog2(interval)` 将原始时间间隔映射到 0~63 的桶索引（因 `u64` 最大为 2^64）。\n- 该方法将大范围的时间值压缩到小数组中，例如值 1123 映射到索引 10（因 2^10 = 1024 ≤ 1123 < 2048 = 2^11）。\n\n#### 3) 指数移动平均（Exponential Moving Average, EMA）\n- 每个桶维护一个 EMA 值，用于平滑同一数量级间隔的波动。\n- EMA 公式使平均值对新数据具有可调的响应速度（通过 alpha 参数隐式控制）。\n- 预测时，根据识别出的周期模式中的桶索引，返回对应桶的 EMA 值作为预测间隔。\n\n### 工作流程\n1. 中断发生时，若 `irq_timing_enabled` 为真，则将 `<irq, timestamp>` 记录到 per-CPU 的循环缓冲区。\n2. 当需要预测某中断的下次发生时间时：\n   - 清空并处理循环缓冲区，将间隔数据分发到各中断的统计结构中。\n   - 对每个中断的间隔序列执行上述三阶段算法。\n   - 若找到重复模式，则用 EMA 值计算预测时间；否则返回未预测。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/percpu.h>`：实现 per-CPU 变量 `irq_timings`。\n  - `<linux/static_key.h>`：提供静态分支优化，避免未启用时的条件判断开销。\n  - `<linux/math64.h>` 和 `<linux/log2.h>`：用于 `ilog2` 等数学运算。\n  - `<trace/events/irq.h>`：可能用于跟踪事件（虽未在片段中调用）。\n  - `\"internals.h\"`：内核中断子系统内部头文件。\n- **子系统依赖**：\n  - 通用中断子系统（`<linux/irq.h>`, `<linux/interrupt.h>`）。\n  - 内存管理（`<linux/slab.h>`）用于动态分配统计结构。\n  - IDR 机制（`<linux/idr.h>`）用于中断号到统计结构的映射。\n\n## 5. 使用场景\n\n- **CPU 空闲状态管理（cpuidle）**：在进入深度 C-state 前，预测下一次中断时间以设置精确的唤醒定时器，避免过早或过晚唤醒。\n- **实时系统调度**：辅助调度器预判周期性中断（如 tickless 系统中的高精度定时器），优化任务调度时机。\n- **电源管理**：结合设备驱动的中断模式，动态调整设备或 CPU 的电源状态。\n- **性能分析**：通过跟踪中断时间模式，诊断中断风暴或异常周期行为。\n\n该功能默认关闭，仅在需要时通过 `irq_timings_enable()` 动态启用，确保对常规系统性能无影响。",
      "similarity": 0.6330841183662415,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/timings.c",
          "start_line": 435,
          "end_line": 563,
          "content": [
            "static __always_inline int irq_timings_interval_index(u64 interval)",
            "{",
            "\t/*",
            "\t * The PREDICTION_FACTOR increase the interval size for the",
            "\t * array of exponential average.",
            "\t */",
            "\tu64 interval_us = (interval >> 10) / PREDICTION_FACTOR;",
            "",
            "\treturn likely(interval_us) ? ilog2(interval_us) : 0;",
            "}",
            "static __always_inline void __irq_timings_store(int irq, struct irqt_stat *irqs,",
            "\t\t\t\t\t\tu64 interval)",
            "{",
            "\tint index;",
            "",
            "\t/*",
            "\t * Get the index in the ema table for this interrupt.",
            "\t */",
            "\tindex = irq_timings_interval_index(interval);",
            "",
            "\tif (index > PREDICTION_BUFFER_SIZE - 1) {",
            "\t\tirqs->count = 0;",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * Store the index as an element of the pattern in another",
            "\t * circular array.",
            "\t */",
            "\tirqs->circ_timings[irqs->count & IRQ_TIMINGS_MASK] = index;",
            "",
            "\tirqs->ema_time[index] = irq_timings_ema_new(interval,",
            "\t\t\t\t\t\t    irqs->ema_time[index]);",
            "",
            "\tirqs->count++;",
            "}",
            "static inline void irq_timings_store(int irq, struct irqt_stat *irqs, u64 ts)",
            "{",
            "\tu64 old_ts = irqs->last_ts;",
            "\tu64 interval;",
            "",
            "\t/*",
            "\t * The timestamps are absolute time values, we need to compute",
            "\t * the timing interval between two interrupts.",
            "\t */",
            "\tirqs->last_ts = ts;",
            "",
            "\t/*",
            "\t * The interval type is u64 in order to deal with the same",
            "\t * type in our computation, that prevent mindfuck issues with",
            "\t * overflow, sign and division.",
            "\t */",
            "\tinterval = ts - old_ts;",
            "",
            "\t/*",
            "\t * The interrupt triggered more than one second apart, that",
            "\t * ends the sequence as predictable for our purpose. In this",
            "\t * case, assume we have the beginning of a sequence and the",
            "\t * timestamp is the first value. As it is impossible to",
            "\t * predict anything at this point, return.",
            "\t *",
            "\t * Note the first timestamp of the sequence will always fall",
            "\t * in this test because the old_ts is zero. That is what we",
            "\t * want as we need another timestamp to compute an interval.",
            "\t */",
            "\tif (interval >= NSEC_PER_SEC) {",
            "\t\tirqs->count = 0;",
            "\t\treturn;",
            "\t}",
            "",
            "\t__irq_timings_store(irq, irqs, interval);",
            "}",
            "u64 irq_timings_next_event(u64 now)",
            "{",
            "\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);",
            "\tstruct irqt_stat *irqs;",
            "\tstruct irqt_stat __percpu *s;",
            "\tu64 ts, next_evt = U64_MAX;",
            "\tint i, irq = 0;",
            "",
            "\t/*",
            "\t * This function must be called with the local irq disabled in",
            "\t * order to prevent the timings circular buffer to be updated",
            "\t * while we are reading it.",
            "\t */",
            "\tlockdep_assert_irqs_disabled();",
            "",
            "\tif (!irqts->count)",
            "\t\treturn next_evt;",
            "",
            "\t/*",
            "\t * Number of elements in the circular buffer: If it happens it",
            "\t * was flushed before, then the number of elements could be",
            "\t * smaller than IRQ_TIMINGS_SIZE, so the count is used,",
            "\t * otherwise the array size is used as we wrapped. The index",
            "\t * begins from zero when we did not wrap. That could be done",
            "\t * in a nicer way with the proper circular array structure",
            "\t * type but with the cost of extra computation in the",
            "\t * interrupt handler hot path. We choose efficiency.",
            "\t *",
            "\t * Inject measured irq/timestamp to the pattern prediction",
            "\t * model while decrementing the counter because we consume the",
            "\t * data from our circular buffer.",
            "\t */",
            "\tfor_each_irqts(i, irqts) {",
            "\t\tirq = irq_timing_decode(irqts->values[i], &ts);",
            "\t\ts = idr_find(&irqt_stats, irq);",
            "\t\tif (s)",
            "\t\t\tirq_timings_store(irq, this_cpu_ptr(s), ts);",
            "\t}",
            "",
            "\t/*",
            "\t * Look in the list of interrupts' statistics, the earliest",
            "\t * next event.",
            "\t */",
            "\tidr_for_each_entry(&irqt_stats, s, i) {",
            "",
            "\t\tirqs = this_cpu_ptr(s);",
            "",
            "\t\tts = __irq_timings_next_event(irqs, i, now);",
            "\t\tif (ts <= now)",
            "\t\t\treturn now;",
            "",
            "\t\tif (ts < next_evt)",
            "\t\t\tnext_evt = ts;",
            "\t}",
            "",
            "\treturn next_evt;",
            "}"
          ],
          "function_name": "irq_timings_interval_index, __irq_timings_store, irq_timings_store, irq_timings_next_event",
          "description": "提供时间间隔转索引的映射函数，实现环形缓冲区数据存储及主事件预测函数",
          "similarity": 0.6484848260879517
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/timings.c",
          "start_line": 26,
          "end_line": 165,
          "content": [
            "void irq_timings_enable(void)",
            "{",
            "\tstatic_branch_enable(&irq_timing_enabled);",
            "}",
            "void irq_timings_disable(void)",
            "{",
            "\tstatic_branch_disable(&irq_timing_enabled);",
            "}",
            "static u64 irq_timings_ema_new(u64 value, u64 ema_old)",
            "{",
            "\ts64 diff;",
            "",
            "\tif (unlikely(!ema_old))",
            "\t\treturn value;",
            "",
            "\tdiff = (value - ema_old) * EMA_ALPHA_VAL;",
            "\t/*",
            "\t * We can use a s64 type variable to be added with the u64",
            "\t * ema_old variable as this one will never have its topmost",
            "\t * bit set, it will be always smaller than 2^63 nanosec",
            "\t * interrupt interval (292 years).",
            "\t */",
            "\treturn ema_old + (diff >> EMA_ALPHA_SHIFT);",
            "}",
            "static int irq_timings_next_event_index(int *buffer, size_t len, int period_max)",
            "{",
            "\tint period;",
            "",
            "\t/*",
            "\t * Move the beginning pointer to the end minus the max period x 3.",
            "\t * We are at the point we can begin searching the pattern",
            "\t */",
            "\tbuffer = &buffer[len - (period_max * 3)];",
            "",
            "\t/* Adjust the length to the maximum allowed period x 3 */",
            "\tlen = period_max * 3;",
            "",
            "\t/*",
            "\t * The buffer contains the suite of intervals, in a ilog2",
            "\t * basis, we are looking for a repetition. We point the",
            "\t * beginning of the search three times the length of the",
            "\t * period beginning at the end of the buffer. We do that for",
            "\t * each suffix.",
            "\t */",
            "\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {",
            "",
            "\t\t/*",
            "\t\t * The first comparison always succeed because the",
            "\t\t * suffix is deduced from the first n-period bytes of",
            "\t\t * the buffer and we compare the initial suffix with",
            "\t\t * itself, so we can skip the first iteration.",
            "\t\t */",
            "\t\tint idx = period;",
            "\t\tsize_t size = period;",
            "",
            "\t\t/*",
            "\t\t * We look if the suite with period 'i' repeat",
            "\t\t * itself. If it is truncated at the end, as it",
            "\t\t * repeats we can use the period to find out the next",
            "\t\t * element with the modulo.",
            "\t\t */",
            "\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {",
            "",
            "\t\t\t/*",
            "\t\t\t * Move the index in a period basis",
            "\t\t\t */",
            "\t\t\tidx += size;",
            "",
            "\t\t\t/*",
            "\t\t\t * If this condition is reached, all previous",
            "\t\t\t * memcmp were successful, so the period is",
            "\t\t\t * found.",
            "\t\t\t */",
            "\t\t\tif (idx == len)",
            "\t\t\t\treturn buffer[len % period];",
            "",
            "\t\t\t/*",
            "\t\t\t * If the remaining elements to compare are",
            "\t\t\t * smaller than the period, readjust the size",
            "\t\t\t * of the comparison for the last iteration.",
            "\t\t\t */",
            "\t\t\tif (len - idx < period)",
            "\t\t\t\tsize = len - idx;",
            "\t\t}",
            "\t}",
            "",
            "\treturn -1;",
            "}",
            "static u64 __irq_timings_next_event(struct irqt_stat *irqs, int irq, u64 now)",
            "{",
            "\tint index, i, period_max, count, start, min = INT_MAX;",
            "",
            "\tif ((now - irqs->last_ts) >= NSEC_PER_SEC) {",
            "\t\tirqs->count = irqs->last_ts = 0;",
            "\t\treturn U64_MAX;",
            "\t}",
            "",
            "\t/*",
            "\t * As we want to find three times the repetition, we need a",
            "\t * number of intervals greater or equal to three times the",
            "\t * maximum period, otherwise we truncate the max period.",
            "\t */",
            "\tperiod_max = irqs->count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : irqs->count / 3;",
            "",
            "\t/*",
            "\t * If we don't have enough irq timings for this prediction,",
            "\t * just bail out.",
            "\t */",
            "\tif (period_max <= PREDICTION_PERIOD_MIN)",
            "\t\treturn U64_MAX;",
            "",
            "\t/*",
            "\t * 'count' will depends if the circular buffer wrapped or not",
            "\t */",
            "\tcount = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\tirqs->count : IRQ_TIMINGS_SIZE;",
            "",
            "\tstart = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\t0 : (irqs->count & IRQ_TIMINGS_MASK);",
            "",
            "\t/*",
            "\t * Copy the content of the circular buffer into another buffer",
            "\t * in order to linearize the buffer instead of dealing with",
            "\t * wrapping indexes and shifted array which will be prone to",
            "\t * error and extremely difficult to debug.",
            "\t */",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "",
            "\t\tirqs->timings[i] = irqs->circ_timings[index];",
            "\t\tmin = min_t(int, irqs->timings[i], min);",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(irqs->timings, count, period_max);",
            "\tif (index < 0)",
            "\t\treturn irqs->last_ts + irqs->ema_time[min];",
            "",
            "\treturn irqs->last_ts + irqs->ema_time[index];",
            "}"
          ],
          "function_name": "irq_timings_enable, irq_timings_disable, irq_timings_ema_new, irq_timings_next_event_index, __irq_timings_next_event",
          "description": "实现中断计时功能的启用/禁用控制，EMA计算算法及基于模式匹配的周期预测核心逻辑",
          "similarity": 0.6258493661880493
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/timings.c",
          "start_line": 1,
          "end_line": 25,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright (C) 2016, Linaro Ltd - Daniel Lezcano <daniel.lezcano@linaro.org>",
            "#define pr_fmt(fmt) \"irq_timings: \" fmt",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/static_key.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/idr.h>",
            "#include <linux/irq.h>",
            "#include <linux/math64.h>",
            "#include <linux/log2.h>",
            "",
            "#include <trace/events/irq.h>",
            "",
            "#include \"internals.h\"",
            "",
            "DEFINE_STATIC_KEY_FALSE(irq_timing_enabled);",
            "",
            "DEFINE_PER_CPU(struct irq_timings, irq_timings);",
            "",
            "static DEFINE_IDR(irqt_stats);",
            ""
          ],
          "function_name": null,
          "description": "定义中断计时模块的静态键开关和PER-CPU结构体，声明IDR管理器用于动态分配中断统计实例",
          "similarity": 0.6249920129776001
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/timings.c",
          "start_line": 821,
          "end_line": 923,
          "content": [
            "static int __init irq_timings_irqs_selftest(void)",
            "{",
            "\tint i, ret;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {",
            "\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",",
            "\t\t\ti, tis[i].count);",
            "\t\tret = irq_timings_test_irqs(&tis[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __init irq_timings_test_irqts(struct irq_timings *irqts,",
            "\t\t\t\t\t unsigned count)",
            "{",
            "\tint start = count >= IRQ_TIMINGS_SIZE ? count - IRQ_TIMINGS_SIZE : 0;",
            "\tint i, irq, oirq = 0xBEEF;",
            "\tu64 ots = 0xDEAD, ts;",
            "",
            "\t/*",
            "\t * Fill the circular buffer by using the dedicated function.",
            "\t */",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tpr_debug(\"%d: index=%d, ts=%llX irq=%X\\n\",",
            "\t\t\t i, i & IRQ_TIMINGS_MASK, ots + i, oirq + i);",
            "",
            "\t\tirq_timings_push(ots + i, oirq + i);",
            "\t}",
            "",
            "\t/*",
            "\t * Compute the first elements values after the index wrapped",
            "\t * up or not.",
            "\t */",
            "\tots += start;",
            "\toirq += start;",
            "",
            "\t/*",
            "\t * Test the circular buffer count is correct.",
            "\t */",
            "\tpr_debug(\"---> Checking timings array count (%d) is right\\n\", count);",
            "\tif (WARN_ON(irqts->count != count))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Test the macro allowing to browse all the irqts.",
            "\t */",
            "\tpr_debug(\"---> Checking the for_each_irqts() macro\\n\");",
            "\tfor_each_irqts(i, irqts) {",
            "",
            "\t\tirq = irq_timing_decode(irqts->values[i], &ts);",
            "",
            "\t\tpr_debug(\"index=%d, ts=%llX / %llX, irq=%X / %X\\n\",",
            "\t\t\t i, ts, ots, irq, oirq);",
            "",
            "\t\tif (WARN_ON(ts != ots || irq != oirq))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tots++; oirq++;",
            "\t}",
            "",
            "\t/*",
            "\t * The circular buffer should have be flushed when browsed",
            "\t * with for_each_irqts",
            "\t */",
            "\tpr_debug(\"---> Checking timings array is empty after browsing it\\n\");",
            "\tif (WARN_ON(irqts->count))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_irqts_selftest(void)",
            "{",
            "\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);",
            "\tint i, ret;",
            "",
            "\t/*",
            "\t * Test the circular buffer with different number of",
            "\t * elements. The purpose is to test at the limits (empty, half",
            "\t * full, full, wrapped with the cursor at the boundaries,",
            "\t * wrapped several times, etc ...",
            "\t */",
            "\tint count[] = { 0,",
            "\t\t\tIRQ_TIMINGS_SIZE >> 1,",
            "\t\t\tIRQ_TIMINGS_SIZE,",
            "\t\t\tIRQ_TIMINGS_SIZE + (IRQ_TIMINGS_SIZE >> 1),",
            "\t\t\t2 * IRQ_TIMINGS_SIZE,",
            "\t\t\t(2 * IRQ_TIMINGS_SIZE) + 3,",
            "\t};",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(count); i++) {",
            "",
            "\t\tpr_info(\"---> Checking the timings with %d/%d values\\n\",",
            "\t\t\tcount[i], IRQ_TIMINGS_SIZE);",
            "",
            "\t\tret = irq_timings_test_irqts(irqts, count[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_irqs_selftest, irq_timings_test_irqts, irq_timings_irqts_selftest",
          "description": "包含完整的中断计时模块自检框架，验证环形缓冲区操作和for_each_irqts宏的正确性",
          "similarity": 0.5949450731277466
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/timings.c",
          "start_line": 594,
          "end_line": 739,
          "content": [
            "void irq_timings_free(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s) {",
            "\t\tfree_percpu(s);",
            "\t\tidr_remove(&irqt_stats, irq);",
            "\t}",
            "}",
            "int irq_timings_alloc(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tint id;",
            "",
            "\t/*",
            "\t * Some platforms can have the same private interrupt per cpu,",
            "\t * so this function may be called several times with the",
            "\t * same interrupt number. Just bail out in case the per cpu",
            "\t * stat structure is already allocated.",
            "\t */",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s)",
            "\t\treturn 0;",
            "",
            "\ts = alloc_percpu(*s);",
            "\tif (!s)",
            "\t\treturn -ENOMEM;",
            "",
            "\tidr_preload(GFP_KERNEL);",
            "\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);",
            "\tidr_preload_end();",
            "",
            "\tif (id < 0) {",
            "\t\tfree_percpu(s);",
            "\t\treturn id;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_test_next_index(struct timings_intervals *ti)",
            "{",
            "\tint _buffer[IRQ_TIMINGS_SIZE];",
            "\tint buffer[IRQ_TIMINGS_SIZE];",
            "\tint index, start, i, count, period_max;",
            "",
            "\tcount = ti->count - 1;",
            "",
            "\tperiod_max = count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : count / 3;",
            "",
            "\t/*",
            "\t * Inject all values except the last one which will be used",
            "\t * to compare with the next index result.",
            "\t */",
            "\tpr_debug(\"index suite: \");",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\t_buffer[i & IRQ_TIMINGS_MASK] = index;",
            "\t\tpr_cont(\"%d \", index);",
            "\t}",
            "",
            "\tstart = count < IRQ_TIMINGS_SIZE ? 0 :",
            "\t\tcount & IRQ_TIMINGS_MASK;",
            "",
            "\tcount = min_t(int, count, IRQ_TIMINGS_SIZE);",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "\t\tbuffer[i] = _buffer[index];",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(buffer, count, period_max);",
            "\ti = irq_timings_interval_index(ti->intervals[ti->count - 1]);",
            "",
            "\tif (index != i) {",
            "\t\tpr_err(\"Expected (%d) and computed (%d) next indexes differ\\n\",",
            "\t\t       i, index);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_next_index_selftest(void)",
            "{",
            "\tint i, ret;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {",
            "",
            "\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",",
            "\t\t\ti, tis[i].count);",
            "",
            "\t\tret = irq_timings_test_next_index(&tis[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __init irq_timings_test_irqs(struct timings_intervals *ti)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tstruct irqt_stat *irqs;",
            "\tint i, index, ret, irq = 0xACE5;",
            "",
            "\tret = irq_timings_alloc(irq);",
            "\tif (ret) {",
            "\t\tpr_err(\"Failed to allocate irq timings\\n\");",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (!s) {",
            "\t\tret = -EIDRM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tirqs = this_cpu_ptr(s);",
            "",
            "\tfor (i = 0; i < ti->count; i++) {",
            "",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\tpr_debug(\"%d: interval=%llu ema_index=%d\\n\",",
            "\t\t\t i, ti->intervals[i], index);",
            "",
            "\t\t__irq_timings_store(irq, irqs, ti->intervals[i]);",
            "\t\tif (irqs->circ_timings[i & IRQ_TIMINGS_MASK] != index) {",
            "\t\t\tret = -EBADSLT;",
            "\t\t\tpr_err(\"Failed to store in the circular buffer\\n\");",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tif (irqs->count != ti->count) {",
            "\t\tret = -ERANGE;",
            "\t\tpr_err(\"Count differs\\n\");",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = 0;",
            "out:",
            "\tirq_timings_free(irq);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_free, irq_timings_alloc, irq_timings_test_next_index, irq_timings_next_index_selftest, irq_timings_test_irqs",
          "description": "实现中断统计结构的动态分配/释放机制，包含预测算法的自检测试函数",
          "similarity": 0.594629168510437
        }
      ]
    },
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.6039561629295349,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.5561550259590149
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.5480425357818604
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.5167064666748047
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_irqsoff.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:26:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_irqsoff.c`\n\n---\n\n# `trace_irqsoff.c` 技术文档\n\n## 1. 文件概述\n\n`trace_irqsoff.c` 是 Linux 内核中用于追踪 **中断关闭（IRQs-off）** 和 **抢占关闭（preempt-off）** 关键路径延迟的核心模块。该文件实现了 `irqsoff` 和 `preemptoff` 两种延迟追踪器（tracer），用于检测系统中因长时间关闭中断或禁止抢占而导致的延迟问题，是内核延迟分析（latency tracing）的重要组成部分。\n\n该模块通过监控中断和抢占状态的变化，记录最长的关闭时间（即“关键路径”），帮助开发者识别潜在的实时性瓶颈。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `irqsoff_trace`：全局 `trace_array` 指针，代表当前激活的追踪实例。\n- `tracer_enabled`：追踪器是否启用的全局标志。\n- `tracing_cpu`（per-CPU）：标记当前 CPU 是否处于被追踪状态。\n- `max_trace_lock`：保护最大延迟记录的原始自旋锁。\n- `trace_type`：指示当前追踪类型（`TRACER_IRQS_OFF` 或 `TRACER_PREEMPT_OFF`）。\n- `max_sequence`：用于避免并发最大值更新干扰的序列计数器（cache-line 对齐）。\n\n### 主要函数\n\n- `irq_trace()` / `preempt_trace()`：判断当前是否应追踪中断或抢占关闭状态。\n- `func_prolog_dec()`：函数追踪的通用前置处理，检查是否应记录当前调用。\n- `irqsoff_tracer_call()`：函数追踪回调，记录函数调用事件。\n- `irqsoff_graph_entry()` / `irqsoff_graph_return()`：函数图追踪（function graph tracer）的入口和返回回调。\n- `check_critical_timing()`：检查当前关闭时间是否构成新的最大延迟（未完整显示，但为关键逻辑）。\n- `report_latency()`：判断是否应报告或记录当前延迟（基于阈值或历史最大值）。\n- `irqsoff_display_graph()`：切换函数图显示模式。\n- `irqsoff_print_line()` / `irqsoff_print_header()`：格式化输出追踪结果。\n\n## 3. 关键实现\n\n### 延迟检测机制\n\n- 模块通过 `preemptirq:preempt_disable/enable` 和 `irq_disable/enable` 等 tracepoint（来自 `trace/events/preemptirq.h`）感知中断/抢占状态变化。\n- 当进入关闭状态时开始计时，恢复时计算持续时间（`delta`）。\n- 使用 `report_latency()` 判断该 `delta` 是否值得记录：若设置了 `tracing_thresh`，则只记录超过阈值的延迟；否则只记录超过当前 `max_latency` 的延迟。\n\n### 并发安全与准确性\n\n- 使用 per-CPU 变量 `tracing_cpu` 标记正在追踪的 CPU，避免跨 CPU 干扰。\n- 通过 `max_sequence` 序列号机制防止多个 CPU 同时更新最大延迟时互相覆盖或受串扰（如控制台输出）影响。\n- 使用 `atomic_inc_return(&data->disabled)` 确保同一 CPU 上追踪回调不会嵌套执行，避免重复记录。\n\n### 函数追踪集成\n\n- 若启用 `CONFIG_FUNCTION_TRACER`，使用自定义的 `irqsoff_tracer_call` 作为 ftrace 回调，仅在关键路径期间记录函数调用。\n- 若启用 `CONFIG_FUNCTION_GRAPH_TRACER`，则进一步支持函数调用图（call graph）追踪，通过 `fgraph_ops` 注册入口/返回钩子。\n- 通过 `is_graph(tr)` 动态判断是否使用图模式输出，并调用相应的格式化函数（如 `print_graph_function_flags`）。\n\n### 模式切换与资源管理\n\n- `start_irqsoff_tracer()` / `stop_irqsoff_tracer()`（声明但未在片段中定义）负责启用/禁用底层追踪机制（如注册 ftrace ops）。\n- 切换图模式时会重置追踪状态（清零 `tracing_cpu`、`max_latency` 并重置缓冲区）。\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `trace.h`：提供通用追踪基础设施（`trace_array`, `trace_function` 等）。\n  - `trace/events/preemptirq.h`：提供中断/抢占状态变化的 tracepoint。\n  - `ftrace.h` / `kprobes.h`：支持动态函数追踪。\n- **条件编译依赖**：\n  - `CONFIG_IRQSOFF_TRACER`：启用中断关闭追踪。\n  - `CONFIG_PREEMPT_TRACER`：启用抢占关闭追踪。\n  - `CONFIG_FUNCTION_TRACER`：启用函数级追踪。\n  - `CONFIG_FUNCTION_GRAPH_TRACER`：启用函数调用图追踪。\n- **运行时依赖**：依赖内核的 per-CPU 数据、原子操作、自旋锁等同步原语。\n\n## 5. 使用场景\n\n- **实时系统调试**：在实时内核（如 PREEMPT_RT）开发中，用于定位导致调度延迟的长关键路径。\n- **性能分析**：通过 `/sys/kernel/debug/tracing/` 接口启用 `irqsoff` 或 `preemptoff` 追踪器，分析系统最大中断/抢占关闭时间。\n- **阈值告警**：结合 `tracing_thresh` 设置延迟阈值，仅记录超限事件，减少日志噪音。\n- **函数路径分析**：配合函数图追踪，可视化导致长延迟的具体函数调用链。\n- **内核开发与测试**：在提交可能影响中断/抢占延迟的补丁前，使用该追踪器验证性能影响。",
      "similarity": 0.5932446718215942,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_irqsoff.c",
          "start_line": 44,
          "end_line": 167,
          "content": [
            "static inline int",
            "preempt_trace(int pc)",
            "{",
            "\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);",
            "}",
            "static inline int",
            "irq_trace(void)",
            "{",
            "\treturn ((trace_type & TRACER_IRQS_OFF) &&",
            "\t\tirqs_disabled());",
            "}",
            "static inline int irqsoff_display_graph(struct trace_array *tr, int set)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "static int func_prolog_dec(struct trace_array *tr,",
            "\t\t\t   struct trace_array_cpu **data,",
            "\t\t\t   unsigned long *flags)",
            "{",
            "\tlong disabled;",
            "\tint cpu;",
            "",
            "\t/*",
            "\t * Does not matter if we preempt. We test the flags",
            "\t * afterward, to see if irqs are disabled or not.",
            "\t * If we preempt and get a false positive, the flags",
            "\t * test will fail.",
            "\t */",
            "\tcpu = raw_smp_processor_id();",
            "\tif (likely(!per_cpu(tracing_cpu, cpu)))",
            "\t\treturn 0;",
            "",
            "\tlocal_save_flags(*flags);",
            "\t/*",
            "\t * Slight chance to get a false positive on tracing_cpu,",
            "\t * although I'm starting to think there isn't a chance.",
            "\t * Leave this for now just to be paranoid.",
            "\t */",
            "\tif (!irqs_disabled_flags(*flags) && !preempt_count())",
            "\t\treturn 0;",
            "",
            "\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);",
            "\tdisabled = atomic_inc_return(&(*data)->disabled);",
            "",
            "\tif (likely(disabled == 1))",
            "\t\treturn 1;",
            "",
            "\tatomic_dec(&(*data)->disabled);",
            "",
            "\treturn 0;",
            "}",
            "static void",
            "irqsoff_tracer_call(unsigned long ip, unsigned long parent_ip,",
            "\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs)",
            "{",
            "\tstruct trace_array *tr = irqsoff_trace;",
            "\tstruct trace_array_cpu *data;",
            "\tunsigned long flags;",
            "\tunsigned int trace_ctx;",
            "",
            "\tif (!func_prolog_dec(tr, &data, &flags))",
            "\t\treturn;",
            "",
            "\ttrace_ctx = tracing_gen_ctx_flags(flags);",
            "",
            "\ttrace_function(tr, ip, parent_ip, trace_ctx);",
            "",
            "\tatomic_dec(&data->disabled);",
            "}",
            "static int irqsoff_display_graph(struct trace_array *tr, int set)",
            "{",
            "\tint cpu;",
            "",
            "\tif (!(is_graph(tr) ^ set))",
            "\t\treturn 0;",
            "",
            "\tstop_irqsoff_tracer(irqsoff_trace, !set);",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tper_cpu(tracing_cpu, cpu) = 0;",
            "",
            "\ttr->max_latency = 0;",
            "\ttracing_reset_online_cpus(&irqsoff_trace->array_buffer);",
            "",
            "\treturn start_irqsoff_tracer(irqsoff_trace, set);",
            "}",
            "static int irqsoff_graph_entry(struct ftrace_graph_ent *trace,",
            "\t\t\t       struct fgraph_ops *gops,",
            "\t\t\t       struct ftrace_regs *fregs)",
            "{",
            "\tstruct trace_array *tr = irqsoff_trace;",
            "\tstruct trace_array_cpu *data;",
            "\tunsigned long flags;",
            "\tunsigned int trace_ctx;",
            "\tu64 *calltime;",
            "\tint ret;",
            "",
            "\tif (ftrace_graph_ignore_func(gops, trace))",
            "\t\treturn 0;",
            "\t/*",
            "\t * Do not trace a function if it's filtered by set_graph_notrace.",
            "\t * Make the index of ret stack negative to indicate that it should",
            "\t * ignore further functions.  But it needs its own ret stack entry",
            "\t * to recover the original index in order to continue tracing after",
            "\t * returning from the function.",
            "\t */",
            "\tif (ftrace_graph_notrace_addr(trace->func))",
            "\t\treturn 1;",
            "",
            "\tif (!func_prolog_dec(tr, &data, &flags))",
            "\t\treturn 0;",
            "",
            "\tcalltime = fgraph_reserve_data(gops->idx, sizeof(*calltime));",
            "\tif (!calltime)",
            "\t\treturn 0;",
            "",
            "\t*calltime = trace_clock_local();",
            "",
            "\ttrace_ctx = tracing_gen_ctx_flags(flags);",
            "\tret = __trace_graph_entry(tr, trace, trace_ctx);",
            "\tatomic_dec(&data->disabled);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "preempt_trace, irq_trace, irqsoff_display_graph, func_prolog_dec, irqsoff_tracer_call, irqsoff_display_graph, irqsoff_graph_entry",
          "description": "实现抢占/中断关闭状态检测及跟踪点标记逻辑，包含函数用于识别中断禁用状态、管理跟踪数据流及图模式下的事件记录",
          "similarity": 0.6309981346130371
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_irqsoff.c",
          "start_line": 217,
          "end_line": 355,
          "content": [
            "static void irqsoff_graph_return(struct ftrace_graph_ret *trace,",
            "\t\t\t\t struct fgraph_ops *gops,",
            "\t\t\t\t struct ftrace_regs *fregs)",
            "{",
            "\tstruct trace_array *tr = irqsoff_trace;",
            "\tstruct trace_array_cpu *data;",
            "\tunsigned long flags;",
            "\tunsigned int trace_ctx;",
            "\tu64 *calltime;",
            "\tint size;",
            "",
            "\tftrace_graph_addr_finish(gops, trace);",
            "",
            "\tif (!func_prolog_dec(tr, &data, &flags))",
            "\t\treturn;",
            "",
            "\tcalltime = fgraph_retrieve_data(gops->idx, &size);",
            "\tif (!calltime)",
            "\t\treturn;",
            "\ttrace->calltime = *calltime;",
            "",
            "\ttrace_ctx = tracing_gen_ctx_flags(flags);",
            "\t__trace_graph_return(tr, trace, trace_ctx);",
            "\tatomic_dec(&data->disabled);",
            "}",
            "static void irqsoff_trace_open(struct trace_iterator *iter)",
            "{",
            "\tif (is_graph(iter->tr))",
            "\t\tgraph_trace_open(iter);",
            "}",
            "static void irqsoff_trace_close(struct trace_iterator *iter)",
            "{",
            "\tif (iter->private)",
            "\t\tgraph_trace_close(iter);",
            "}",
            "static enum print_line_t irqsoff_print_line(struct trace_iterator *iter)",
            "{",
            "\t/*",
            "\t * In graph mode call the graph tracer output function,",
            "\t * otherwise go with the TRACE_FN event handler",
            "\t */",
            "\tif (is_graph(iter->tr))",
            "\t\treturn print_graph_function_flags(iter, GRAPH_TRACER_FLAGS);",
            "",
            "\treturn TRACE_TYPE_UNHANDLED;",
            "}",
            "static void irqsoff_print_header(struct seq_file *s)",
            "{",
            "\tstruct trace_array *tr = irqsoff_trace;",
            "",
            "\tif (is_graph(tr))",
            "\t\tprint_graph_headers_flags(s, GRAPH_TRACER_FLAGS);",
            "\telse",
            "\t\ttrace_default_header(s);",
            "}",
            "static void",
            "__trace_function(struct trace_array *tr,",
            "\t\t unsigned long ip, unsigned long parent_ip,",
            "\t\t unsigned int trace_ctx)",
            "{",
            "\tif (is_graph(tr))",
            "\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);",
            "\telse",
            "\t\ttrace_function(tr, ip, parent_ip, trace_ctx);",
            "}",
            "static enum print_line_t irqsoff_print_line(struct trace_iterator *iter)",
            "{",
            "\treturn TRACE_TYPE_UNHANDLED;",
            "}",
            "static void irqsoff_trace_open(struct trace_iterator *iter) { }",
            "static void irqsoff_trace_close(struct trace_iterator *iter) { }",
            "static void irqsoff_print_header(struct seq_file *s)",
            "{",
            "\ttrace_default_header(s);",
            "}",
            "static void irqsoff_print_header(struct seq_file *s)",
            "{",
            "\ttrace_latency_header(s);",
            "}",
            "static bool report_latency(struct trace_array *tr, u64 delta)",
            "{",
            "\tif (tracing_thresh) {",
            "\t\tif (delta < tracing_thresh)",
            "\t\t\treturn false;",
            "\t} else {",
            "\t\tif (delta <= tr->max_latency)",
            "\t\t\treturn false;",
            "\t}",
            "\treturn true;",
            "}",
            "static void",
            "check_critical_timing(struct trace_array *tr,",
            "\t\t      struct trace_array_cpu *data,",
            "\t\t      unsigned long parent_ip,",
            "\t\t      int cpu)",
            "{",
            "\tu64 T0, T1, delta;",
            "\tunsigned long flags;",
            "\tunsigned int trace_ctx;",
            "",
            "\tT0 = data->preempt_timestamp;",
            "\tT1 = ftrace_now(cpu);",
            "\tdelta = T1-T0;",
            "",
            "\ttrace_ctx = tracing_gen_ctx();",
            "",
            "\tif (!report_latency(tr, delta))",
            "\t\tgoto out;",
            "",
            "\traw_spin_lock_irqsave(&max_trace_lock, flags);",
            "",
            "\t/* check if we are still the max latency */",
            "\tif (!report_latency(tr, delta))",
            "\t\tgoto out_unlock;",
            "",
            "\t__trace_function(tr, CALLER_ADDR0, parent_ip, trace_ctx);",
            "\t/* Skip 5 functions to get to the irq/preempt enable function */",
            "\t__trace_stack(tr, trace_ctx, 5);",
            "",
            "\tif (data->critical_sequence != max_sequence)",
            "\t\tgoto out_unlock;",
            "",
            "\tdata->critical_end = parent_ip;",
            "",
            "\tif (likely(!is_tracing_stopped())) {",
            "\t\ttr->max_latency = delta;",
            "\t\tupdate_max_tr_single(tr, current, cpu);",
            "\t}",
            "",
            "\tmax_sequence++;",
            "",
            "out_unlock:",
            "\traw_spin_unlock_irqrestore(&max_trace_lock, flags);",
            "",
            "out:",
            "\tdata->critical_sequence = max_sequence;",
            "\tdata->preempt_timestamp = ftrace_now(cpu);",
            "\t__trace_function(tr, CALLER_ADDR0, parent_ip, trace_ctx);",
            "}"
          ],
          "function_name": "irqsoff_graph_return, irqsoff_trace_open, irqsoff_trace_close, irqsoff_print_line, irqsoff_print_header, __trace_function, irqsoff_print_line, irqsoff_trace_open, irqsoff_trace_close, irqsoff_print_header, irqsoff_print_header, report_latency, check_critical_timing",
          "description": "提供跟踪事件输出格式化支持，包含关键路径延迟检测逻辑，通过时间差计算确定是否记录异常延迟事件",
          "similarity": 0.6283434629440308
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_irqsoff.c",
          "start_line": 625,
          "end_line": 688,
          "content": [
            "void tracer_hardirqs_on(unsigned long a0, unsigned long a1)",
            "{",
            "\tif (!preempt_trace(preempt_count()) && irq_trace())",
            "\t\tstop_critical_timing(a0, a1);",
            "}",
            "void tracer_hardirqs_off(unsigned long a0, unsigned long a1)",
            "{",
            "\tif (!preempt_trace(preempt_count()) && irq_trace())",
            "\t\tstart_critical_timing(a0, a1);",
            "}",
            "static int irqsoff_tracer_init(struct trace_array *tr)",
            "{",
            "\ttrace_type = TRACER_IRQS_OFF;",
            "",
            "\treturn __irqsoff_tracer_init(tr);",
            "}",
            "static void irqsoff_tracer_reset(struct trace_array *tr)",
            "{",
            "\t__irqsoff_tracer_reset(tr);",
            "}",
            "void tracer_preempt_on(unsigned long a0, unsigned long a1)",
            "{",
            "\tif (preempt_trace(preempt_count()) && !irq_trace())",
            "\t\tstop_critical_timing(a0, a1);",
            "}",
            "void tracer_preempt_off(unsigned long a0, unsigned long a1)",
            "{",
            "\tif (preempt_trace(preempt_count()) && !irq_trace())",
            "\t\tstart_critical_timing(a0, a1);",
            "}",
            "static int preemptoff_tracer_init(struct trace_array *tr)",
            "{",
            "\ttrace_type = TRACER_PREEMPT_OFF;",
            "",
            "\treturn __irqsoff_tracer_init(tr);",
            "}",
            "static void preemptoff_tracer_reset(struct trace_array *tr)",
            "{",
            "\t__irqsoff_tracer_reset(tr);",
            "}",
            "static int preemptirqsoff_tracer_init(struct trace_array *tr)",
            "{",
            "\ttrace_type = TRACER_IRQS_OFF | TRACER_PREEMPT_OFF;",
            "",
            "\treturn __irqsoff_tracer_init(tr);",
            "}",
            "static void preemptirqsoff_tracer_reset(struct trace_array *tr)",
            "{",
            "\t__irqsoff_tracer_reset(tr);",
            "}",
            "__init static int init_irqsoff_tracer(void)",
            "{",
            "#ifdef CONFIG_IRQSOFF_TRACER",
            "\tregister_tracer(&irqsoff_tracer);",
            "#endif",
            "#ifdef CONFIG_PREEMPT_TRACER",
            "\tregister_tracer(&preemptoff_tracer);",
            "#endif",
            "#if defined(CONFIG_IRQSOFF_TRACER) && defined(CONFIG_PREEMPT_TRACER)",
            "\tregister_tracer(&preemptirqsoff_tracer);",
            "#endif",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "tracer_hardirqs_on, tracer_hardirqs_off, irqsoff_tracer_init, irqsoff_tracer_reset, tracer_preempt_on, tracer_preempt_off, preemptoff_tracer_init, preemptoff_tracer_reset, preemptirqsoff_tracer_init, preemptirqsoff_tracer_reset, init_irqsoff_tracer",
          "description": "该代码段实现了对硬中断和抢占状态变化的跟踪逻辑，提供三种跟踪模式（仅中断禁用、仅抢占禁用、两者均禁用）。各函数通过判断当前上下文是否处于中断/抢占禁用状态，调用`start_critical_timing`/`stop_critical_timing`记录关键时间点，具体实现依赖未展示的底层函数。代码通过条件编译注册对应跟踪器，但因上下文不完整无法确认全部细节。",
          "similarity": 0.6178925037384033
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/trace_irqsoff.c",
          "start_line": 387,
          "end_line": 490,
          "content": [
            "static nokprobe_inline void",
            "start_critical_timing(unsigned long ip, unsigned long parent_ip)",
            "{",
            "\tint cpu;",
            "\tstruct trace_array *tr = irqsoff_trace;",
            "\tstruct trace_array_cpu *data;",
            "",
            "\tif (!tracer_enabled || !tracing_is_enabled())",
            "\t\treturn;",
            "",
            "\tcpu = raw_smp_processor_id();",
            "",
            "\tif (per_cpu(tracing_cpu, cpu))",
            "\t\treturn;",
            "",
            "\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);",
            "",
            "\tif (unlikely(!data) || atomic_read(&data->disabled))",
            "\t\treturn;",
            "",
            "\tatomic_inc(&data->disabled);",
            "",
            "\tdata->critical_sequence = max_sequence;",
            "\tdata->preempt_timestamp = ftrace_now(cpu);",
            "\tdata->critical_start = parent_ip ? : ip;",
            "",
            "\t__trace_function(tr, ip, parent_ip, tracing_gen_ctx());",
            "",
            "\tper_cpu(tracing_cpu, cpu) = 1;",
            "",
            "\tatomic_dec(&data->disabled);",
            "}",
            "static nokprobe_inline void",
            "stop_critical_timing(unsigned long ip, unsigned long parent_ip)",
            "{",
            "\tint cpu;",
            "\tstruct trace_array *tr = irqsoff_trace;",
            "\tstruct trace_array_cpu *data;",
            "\tunsigned int trace_ctx;",
            "",
            "\tcpu = raw_smp_processor_id();",
            "\t/* Always clear the tracing cpu on stopping the trace */",
            "\tif (unlikely(per_cpu(tracing_cpu, cpu)))",
            "\t\tper_cpu(tracing_cpu, cpu) = 0;",
            "\telse",
            "\t\treturn;",
            "",
            "\tif (!tracer_enabled || !tracing_is_enabled())",
            "\t\treturn;",
            "",
            "\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);",
            "",
            "\tif (unlikely(!data) ||",
            "\t    !data->critical_start || atomic_read(&data->disabled))",
            "\t\treturn;",
            "",
            "\tatomic_inc(&data->disabled);",
            "",
            "\ttrace_ctx = tracing_gen_ctx();",
            "\t__trace_function(tr, ip, parent_ip, trace_ctx);",
            "\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);",
            "\tdata->critical_start = 0;",
            "\tatomic_dec(&data->disabled);",
            "}",
            "void start_critical_timings(void)",
            "{",
            "\tif (preempt_trace(preempt_count()) || irq_trace())",
            "\t\tstart_critical_timing(CALLER_ADDR0, CALLER_ADDR1);",
            "}",
            "void stop_critical_timings(void)",
            "{",
            "\tif (preempt_trace(preempt_count()) || irq_trace())",
            "\t\tstop_critical_timing(CALLER_ADDR0, CALLER_ADDR1);",
            "}",
            "static int register_irqsoff_function(struct trace_array *tr, int graph, int set)",
            "{",
            "\tint ret;",
            "",
            "\t/* 'set' is set if TRACE_ITER_FUNCTION is about to be set */",
            "\tif (function_enabled || (!set && !(tr->trace_flags & TRACE_ITER_FUNCTION)))",
            "\t\treturn 0;",
            "",
            "\tif (graph)",
            "\t\tret = register_ftrace_graph(&fgraph_ops);",
            "\telse",
            "\t\tret = register_ftrace_function(tr->ops);",
            "",
            "\tif (!ret)",
            "\t\tfunction_enabled = true;",
            "",
            "\treturn ret;",
            "}",
            "static void unregister_irqsoff_function(struct trace_array *tr, int graph)",
            "{",
            "\tif (!function_enabled)",
            "\t\treturn;",
            "",
            "\tif (graph)",
            "\t\tunregister_ftrace_graph(&fgraph_ops);",
            "\telse",
            "\t\tunregister_ftrace_function(tr->ops);",
            "",
            "\tfunction_enabled = false;",
            "}"
          ],
          "function_name": "start_critical_timing, stop_critical_timing, start_critical_timings, stop_critical_timings, register_irqsoff_function, unregister_irqsoff_function",
          "description": "实现中断关闭时间段的起止标记功能，管理跟踪器注册/注销流程，协调FTrace图形跟踪与普通函数跟踪模式",
          "similarity": 0.5968317985534668
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_irqsoff.c",
          "start_line": 1,
          "end_line": 43,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * trace irqs off critical timings",
            " *",
            " * Copyright (C) 2007-2008 Steven Rostedt <srostedt@redhat.com>",
            " * Copyright (C) 2008 Ingo Molnar <mingo@redhat.com>",
            " *",
            " * From code in the latency_tracer, that is:",
            " *",
            " *  Copyright (C) 2004-2006 Ingo Molnar",
            " *  Copyright (C) 2004 Nadia Yvette Chambers",
            " */",
            "#include <linux/kallsyms.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kprobes.h>",
            "",
            "#include \"trace.h\"",
            "",
            "#include <trace/events/preemptirq.h>",
            "",
            "#if defined(CONFIG_IRQSOFF_TRACER) || defined(CONFIG_PREEMPT_TRACER)",
            "static struct trace_array\t\t*irqsoff_trace __read_mostly;",
            "static int\t\t\t\ttracer_enabled __read_mostly;",
            "",
            "static DEFINE_PER_CPU(int, tracing_cpu);",
            "",
            "static DEFINE_RAW_SPINLOCK(max_trace_lock);",
            "",
            "enum {",
            "\tTRACER_IRQS_OFF\t\t= (1 << 1),",
            "\tTRACER_PREEMPT_OFF\t= (1 << 2),",
            "};",
            "",
            "static int trace_type __read_mostly;",
            "",
            "static int save_flags;",
            "",
            "static void stop_irqsoff_tracer(struct trace_array *tr, int graph);",
            "static int start_irqsoff_tracer(struct trace_array *tr, int graph);",
            "",
            "#ifdef CONFIG_PREEMPT_TRACER"
          ],
          "function_name": null,
          "description": "定义中断关闭跟踪器的全局变量和常量，用于控制抢占和中断关闭状态的追踪功能，上下文不完整",
          "similarity": 0.5463494658470154
        }
      ]
    }
  ]
}