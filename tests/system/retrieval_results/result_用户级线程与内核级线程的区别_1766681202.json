{
  "query": "用户级线程与内核级线程的区别",
  "timestamp": "2025-12-26 00:46:42",
  "retrieved_files": [
    {
      "source_file": "kernel/user-return-notifier.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:45:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user-return-notifier.c`\n\n---\n\n# user-return-notifier.c 技术文档\n\n## 1. 文件概述\n\n`user-return-notifier.c` 实现了用户态返回通知机制（User Return Notifier），允许内核子系统在当前 CPU 即将从内核态返回用户态时注册回调函数。该机制用于在特定内核事件（如安全策略更新、性能监控等）发生后，延迟执行某些操作，直到进程真正返回用户空间，从而避免在关键内核路径中引入额外开销或竞态条件。\n\n## 2. 核心功能\n\n### 数据结构\n- `return_notifier_list`：每 CPU 变量（per-CPU variable），类型为 `struct hlist_head`，用于存储当前 CPU 上注册的所有用户返回通知器链表。\n\n### 主要函数\n- `user_return_notifier_register(struct user_return_notifier *urn)`  \n  注册一个用户返回通知器，将其加入当前 CPU 的通知链表，并设置当前任务的 `TIF_USER_RETURN_NOTIFY` 标志位。\n\n- `user_return_notifier_unregister(struct user_return_notifier *urn)`  \n  从当前 CPU 的通知链表中移除指定的通知器；若链表变为空，则清除当前任务的 `TIF_USER_RETURN_NOTIFY` 标志位。\n\n- `fire_user_return_notifiers(void)`  \n  遍历并调用当前 CPU 上所有已注册的通知器的回调函数 `on_user_return`，通常在内核即将返回用户态前由调度或系统调用退出路径调用。\n\n## 3. 关键实现\n\n- **每 CPU 链表设计**：使用 `DEFINE_PER_CPU` 定义 per-CPU 的哈希链表头，确保每个 CPU 维护独立的通知器列表，避免跨 CPU 同步开销。\n  \n- **原子上下文要求**：注册和注销操作必须在原子上下文中执行（不可睡眠），因为它们操作 per-CPU 数据且可能在中断或调度关键路径中被调用。\n\n- **线程标志位控制**：通过设置/清除任务结构体中的 `TIF_USER_RETURN_NOTIFY` 标志位（`TIF_` 表示 Thread Info Flag），通知内核在返回用户态前需调用 `fire_user_return_notifiers()`。\n\n- **安全遍历与调用**：`fire_user_return_notifiers()` 使用 `hlist_for_each_entry_safe` 安全遍历链表，允许回调函数在执行过程中注销自身或其他通知器。\n\n- **CPU 变量访问**：使用 `get_cpu_var()` 和 `put_cpu_var()` 保证在访问 per-CPU 变量期间禁止内核抢占，确保操作的 CPU 一致性。\n\n## 4. 依赖关系\n\n- `<linux/user-return-notifier.h>`：定义 `struct user_return_notifier` 及相关 API。\n- `<linux/percpu.h>`：提供 per-CPU 变量支持。\n- `<linux/sched.h>`：提供任务结构体（`current`）和线程标志位操作函数（如 `set_tsk_thread_flag`）。\n- `<linux/export.h>`：导出符号供其他内核模块使用（`EXPORT_SYMBOL_GPL`）。\n- 依赖架构相关的线程信息标志（`TIF_USER_RETURN_NOTIFY`）在 `thread_info` 中的定义。\n\n## 5. 使用场景\n\n- **安全模块**：如 SELinux 或 LSM 框架在策略更新后，需通知用户态进程重新评估权限，可延迟到返回用户态时触发。\n- **性能监控与跟踪**：在系统调用或中断处理完成后，于返回用户态前收集上下文切换或延迟信息。\n- **延迟工作调度**：某些不适合在中断或原子上下文中执行的操作，可注册为用户返回通知，在安全的用户态切换点执行。\n- **虚拟化与容器**：在客户机或容器退出内核时同步状态或注入事件。\n\n该机制是内核“延迟通知”模式的典型实现，确保高优先级内核路径不受回调逻辑影响，同时保证通知在正确的执行上下文中触发。",
      "similarity": 0.6279830932617188,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/user-return-notifier.c",
          "start_line": 15,
          "end_line": 36,
          "content": [
            "void user_return_notifier_register(struct user_return_notifier *urn)",
            "{",
            "\tset_tsk_thread_flag(current, TIF_USER_RETURN_NOTIFY);",
            "\thlist_add_head(&urn->link, this_cpu_ptr(&return_notifier_list));",
            "}",
            "void user_return_notifier_unregister(struct user_return_notifier *urn)",
            "{",
            "\thlist_del(&urn->link);",
            "\tif (hlist_empty(this_cpu_ptr(&return_notifier_list)))",
            "\t\tclear_tsk_thread_flag(current, TIF_USER_RETURN_NOTIFY);",
            "}",
            "void fire_user_return_notifiers(void)",
            "{",
            "\tstruct user_return_notifier *urn;",
            "\tstruct hlist_node *tmp2;",
            "\tstruct hlist_head *head;",
            "",
            "\thead = &get_cpu_var(return_notifier_list);",
            "\thlist_for_each_entry_safe(urn, tmp2, head, link)",
            "\t\turn->on_user_return(urn);",
            "\tput_cpu_var(return_notifier_list);",
            "}"
          ],
          "function_name": "user_return_notifier_register, user_return_notifier_unregister, fire_user_return_notifiers",
          "description": "实现用户态返回通知器的注册/注销与触发机制。register 函数将通知器链接到当前 CPU 的链表并设置 TIF_USER_RETURN_NOTIFY 标志；unregister 函数移除节点并清理标志；fire 函数遍历当前 CPU 链表执行所有注册的 on_user_return 回调函数。",
          "similarity": 0.5147660374641418
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/user-return-notifier.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "",
            "static DEFINE_PER_CPU(struct hlist_head, return_notifier_list);",
            "",
            "/*",
            " * Request a notification when the current cpu returns to userspace.  Must be",
            " * called in atomic context.  The notifier will also be called in atomic",
            " * context.",
            " */"
          ],
          "function_name": null,
          "description": "定义了一个 per-CPU 的哈希列表头结构 return_notifier_list，用于存储用户态返回通知器注册项。该结构通过 DEFINE_PER_CPU 宏为每个 CPU 创建独立的链表头，支持多 CPU 环境下的并发访问。",
          "similarity": 0.5014989376068115
        }
      ]
    },
    {
      "source_file": "mm/memory-tiers.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:41:40\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memory-tiers.c`\n\n---\n\n# memory-tiers.c 技术文档\n\n## 1. 文件概述\n\n`memory-tiers.c` 是 Linux 内核中实现 **内存层级（Memory Tiering）** 功能的核心模块。该文件负责根据抽象距离（abstract distance, adistance）对 NUMA 节点进行分层管理，支持将不同性能特性的内存（如 DRAM、PMEM、HBM 等）组织成层级结构，并为页面迁移（demotion/promotion）和 NUMA 平衡提供基础支持。通过 sysfs 暴露内存层级信息，便于用户空间监控和策略配置。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct memory_tier`  \n  表示一个内存层级，包含：\n  - `adistance_start`：该层级的起始抽象距离（按 `MEMTIER_CHUNK_SIZE` 对齐）\n  - `memory_types`：属于该层级的所有内存设备类型（`memory_dev_type`）链表\n  - `lower_tier_mask`：所有更低层级（更高延迟/更低性能）节点的位掩码\n  - `dev`：对应的 sysfs 设备对象\n\n- `struct demotion_nodes`  \n  用于记录每个节点在页面降级（demotion）时的首选目标节点集合。\n\n- `struct node_memory_type_map`  \n  每个 NUMA 节点到其内存设备类型的映射及引用计数。\n\n- `node_demotion[]`（仅 `CONFIG_MIGRATION`）  \n  全局数组，存储每个节点的降级目标偏好。\n\n### 主要函数与接口\n\n- `find_create_memory_tier()`  \n  根据给定内存设备类型的抽象距离，查找或创建对应的 `memory_tier` 实例，并将其加入全局层级链表（按 `adistance_start` 升序排列）。\n\n- `__node_get_memory_tier()` / `node_is_toptier()`  \n  查询指定 NUMA 节点所属的内存层级；`node_is_toptier()` 判断节点是否属于顶层（最高性能）内存层级。\n\n- `node_get_allowed_targets()`  \n  获取指定节点在页面迁移时允许的目标节点集合（即其所在层级之下的所有节点）。\n\n- `next_demotion_node()`（未完整展示）  \n  返回从给定节点出发，在降级路径中的下一个目标节点 ID。\n\n- `folio_use_access_time()`（仅 `CONFIG_NUMA_BALANCING`）  \n  在启用内存层级模式的 NUMA 平衡中，判断是否将 folio 的 `_last_cpupid` 字段复用为访问时间戳（仅适用于非顶层内存节点）。\n\n- `nodelist_show()`  \n  sysfs 属性回调，输出当前内存层级包含的所有 NUMA 节点列表。\n\n## 3. 关键实现\n\n### 内存层级构建逻辑\n- 所有内存设备类型（`memory_dev_type`）通过其 `adistance` 值被归入特定层级。\n- 层级按 `adistance_start = round_down(adistance, MEMTIER_CHUNK_SIZE)` 分组，确保同一层级内设备具有相近的性能特征。\n- 全局链表 `memory_tiers` 维护层级顺序（从低 `adistance` 到高），反映从高性能到低性能的层级结构。\n\n### 层级间依赖关系\n- 每个 `memory_tier` 的 `lower_tier_mask` 记录了所有比它性能更低（`adistance` 更高）的层级所包含的节点集合，用于快速确定迁移目标范围。\n- 顶层层级由全局变量 `top_tier_adistance` 定义，通常对应最低 `adistance` 值的层级（如 CPU 本地 DRAM）。\n\n### RCU 与锁机制\n- 使用 `memory_tier_lock`（互斥锁）保护全局层级结构和设备注册。\n- 节点到层级的映射（`pgdat->memtier`）通过 RCU 机制更新和读取，确保在无锁路径（如页面访问）中的高效性。\n- `synchronize_rcu()` 用于在释放 `memory_tier` 前确保无并发 RCU 读者。\n\n### sysfs 集成\n- 每个 `memory_tier` 注册为 `memory_tiering` 子系统下的设备（`memory_tierX`）。\n- 通过 `nodelist` 属性暴露该层级包含的 NUMA 节点，格式为位图字符串（如 `\"0-3,8-11\"`）。\n\n## 4. 依赖关系\n\n- **核心依赖**：\n  - `<linux/memory.h>`：NUMA 节点和内存管理基础\n  - `<linux/memory-tiers.h>`：内存层级公共接口定义\n  - `\"internal.h\"`：内部辅助函数\n- **可选依赖**：\n  - `CONFIG_NUMA_BALANCING`：提供 `folio_use_access_time()`，支持基于访问时间的页面迁移\n  - `CONFIG_MIGRATION`：提供 `node_demotion` 结构和 `next_demotion_node()` 等迁移相关功能\n- **子系统交互**：\n  - 与内存热插拔（`memory_hotplug`）协同，动态更新层级结构\n  - 为自动 NUMA 平衡（AutoNUMA）和页面迁移框架提供层级拓扑信息\n\n## 5. 使用场景\n\n- **异构内存系统管理**：在包含 DRAM、PMEM、CXL 内存等多类型内存的系统中，自动构建性能层级视图。\n- **智能页面迁移**：作为 `migrate_pages()` 和后台 demotion daemon 的决策依据，将冷页从高性能内存迁移到大容量低速内存。\n- **NUMA 负载均衡优化**：在 `CONFIG_NUMA_BALANCING` 启用时，结合访问时间戳和层级信息，优先将热页保留在顶层内存。\n- **用户空间监控与调优**：通过 `/sys/devices/memory_tiering/memory_tier*/nodelist` 查看各层级节点分布，辅助制定应用部署策略。",
      "similarity": 0.6110971570014954,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "mm/memory-tiers.c",
          "start_line": 688,
          "end_line": 801,
          "content": [
            "int mt_perf_to_adistance(struct access_coordinate *perf, int *adist)",
            "{",
            "\tif (default_dram_perf_error)",
            "\t\treturn -EIO;",
            "",
            "\tif (default_dram_perf_ref_nid == NUMA_NO_NODE)",
            "\t\treturn -ENOENT;",
            "",
            "\tif (perf->read_latency + perf->write_latency == 0 ||",
            "\t    perf->read_bandwidth + perf->write_bandwidth == 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tmutex_lock(&memory_tier_lock);",
            "\t/*",
            "\t * The abstract distance of a memory node is in direct proportion to",
            "\t * its memory latency (read + write) and inversely proportional to its",
            "\t * memory bandwidth (read + write).  The abstract distance, memory",
            "\t * latency, and memory bandwidth of the default DRAM nodes are used as",
            "\t * the base.",
            "\t */",
            "\t*adist = MEMTIER_ADISTANCE_DRAM *",
            "\t\t(perf->read_latency + perf->write_latency) /",
            "\t\t(default_dram_perf.read_latency + default_dram_perf.write_latency) *",
            "\t\t(default_dram_perf.read_bandwidth + default_dram_perf.write_bandwidth) /",
            "\t\t(perf->read_bandwidth + perf->write_bandwidth);",
            "\tmutex_unlock(&memory_tier_lock);",
            "",
            "\treturn 0;",
            "}",
            "int register_mt_adistance_algorithm(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&mt_adistance_algorithms, nb);",
            "}",
            "int unregister_mt_adistance_algorithm(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&mt_adistance_algorithms, nb);",
            "}",
            "int mt_calc_adistance(int node, int *adist)",
            "{",
            "\treturn blocking_notifier_call_chain(&mt_adistance_algorithms, node, adist);",
            "}",
            "static int __meminit memtier_hotplug_callback(struct notifier_block *self,",
            "\t\t\t\t\t      unsigned long action, void *_arg)",
            "{",
            "\tstruct memory_tier *memtier;",
            "\tstruct memory_notify *arg = _arg;",
            "",
            "\t/*",
            "\t * Only update the node migration order when a node is",
            "\t * changing status, like online->offline.",
            "\t */",
            "\tif (arg->status_change_nid < 0)",
            "\t\treturn notifier_from_errno(0);",
            "",
            "\tswitch (action) {",
            "\tcase MEM_OFFLINE:",
            "\t\tmutex_lock(&memory_tier_lock);",
            "\t\tif (clear_node_memory_tier(arg->status_change_nid))",
            "\t\t\testablish_demotion_targets();",
            "\t\tmutex_unlock(&memory_tier_lock);",
            "\t\tbreak;",
            "\tcase MEM_ONLINE:",
            "\t\tmutex_lock(&memory_tier_lock);",
            "\t\tmemtier = set_node_memory_tier(arg->status_change_nid);",
            "\t\tif (!IS_ERR(memtier))",
            "\t\t\testablish_demotion_targets();",
            "\t\tmutex_unlock(&memory_tier_lock);",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn notifier_from_errno(0);",
            "}",
            "static int __init memory_tier_init(void)",
            "{",
            "\tint ret, node;",
            "\tstruct memory_tier *memtier;",
            "",
            "\tret = subsys_virtual_register(&memory_tier_subsys, NULL);",
            "\tif (ret)",
            "\t\tpanic(\"%s() failed to register memory tier subsystem\\n\", __func__);",
            "",
            "#ifdef CONFIG_MIGRATION",
            "\tnode_demotion = kcalloc(nr_node_ids, sizeof(struct demotion_nodes),",
            "\t\t\t\tGFP_KERNEL);",
            "\tWARN_ON(!node_demotion);",
            "#endif",
            "\tmutex_lock(&memory_tier_lock);",
            "\t/*",
            "\t * For now we can have 4 faster memory tiers with smaller adistance",
            "\t * than default DRAM tier.",
            "\t */",
            "\tdefault_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);",
            "\tif (IS_ERR(default_dram_type))",
            "\t\tpanic(\"%s() failed to allocate default DRAM tier\\n\", __func__);",
            "",
            "\t/*",
            "\t * Look at all the existing N_MEMORY nodes and add them to",
            "\t * default memory tier or to a tier if we already have memory",
            "\t * types assigned.",
            "\t */",
            "\tfor_each_node_state(node, N_MEMORY) {",
            "\t\tmemtier = set_node_memory_tier(node);",
            "\t\tif (IS_ERR(memtier))",
            "\t\t\t/*",
            "\t\t\t * Continue with memtiers we are able to setup",
            "\t\t\t */",
            "\t\t\tbreak;",
            "\t}",
            "\testablish_demotion_targets();",
            "\tmutex_unlock(&memory_tier_lock);",
            "",
            "\thotplug_memory_notifier(memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "mt_perf_to_adistance, register_mt_adistance_algorithm, unregister_mt_adistance_algorithm, mt_calc_adistance, memtier_hotplug_callback, memory_tier_init",
          "description": "提供抽象距离计算接口和内存分层热插拔回调。初始化内存分层子系统，分配默认DRAM类型，遍历所有节点建立初始内存分层结构，并注册内存状态变化通知处理函数。",
          "similarity": 0.5537299513816833
        },
        {
          "chunk_id": 0,
          "file_path": "mm/memory-tiers.c",
          "start_line": 1,
          "end_line": 58,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/memory.h>",
            "#include <linux/memory-tiers.h>",
            "#include <linux/notifier.h>",
            "#include <linux/sched/sysctl.h>",
            "",
            "#include \"internal.h\"",
            "",
            "struct memory_tier {",
            "\t/* hierarchy of memory tiers */",
            "\tstruct list_head list;",
            "\t/* list of all memory types part of this tier */",
            "\tstruct list_head memory_types;",
            "\t/*",
            "\t * start value of abstract distance. memory tier maps",
            "\t * an abstract distance  range,",
            "\t * adistance_start .. adistance_start + MEMTIER_CHUNK_SIZE",
            "\t */",
            "\tint adistance_start;",
            "\tstruct device dev;",
            "\t/* All the nodes that are part of all the lower memory tiers. */",
            "\tnodemask_t lower_tier_mask;",
            "};",
            "",
            "struct demotion_nodes {",
            "\tnodemask_t preferred;",
            "};",
            "",
            "struct node_memory_type_map {",
            "\tstruct memory_dev_type *memtype;",
            "\tint map_count;",
            "};",
            "",
            "static DEFINE_MUTEX(memory_tier_lock);",
            "static LIST_HEAD(memory_tiers);",
            "static struct node_memory_type_map node_memory_types[MAX_NUMNODES];",
            "struct memory_dev_type *default_dram_type;",
            "",
            "static struct bus_type memory_tier_subsys = {",
            "\t.name = \"memory_tiering\",",
            "\t.dev_name = \"memory_tier\",",
            "};",
            "",
            "#ifdef CONFIG_NUMA_BALANCING",
            "/**",
            " * folio_use_access_time - check if a folio reuses cpupid for page access time",
            " * @folio: folio to check",
            " *",
            " * folio's _last_cpupid field is repurposed by memory tiering. In memory",
            " * tiering mode, cpupid of slow memory folio (not toptier memory) is used to",
            " * record page access time.",
            " *",
            " * Return: the folio _last_cpupid is used to record page access time",
            " */"
          ],
          "function_name": null,
          "description": "定义memory_tier结构体及辅助数据结构，用于管理内存分层体系。声明全局锁和链表头，注册内存分层子系统，并定义默认DRAM类型指针。包含用于内存分层的抽象距离相关内联函数原型。",
          "similarity": 0.5510345697402954
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memory-tiers.c",
          "start_line": 59,
          "end_line": 170,
          "content": [
            "bool folio_use_access_time(struct folio *folio)",
            "{",
            "\treturn (sysctl_numa_balancing_mode & NUMA_BALANCING_MEMORY_TIERING) &&",
            "\t       !node_is_toptier(folio_nid(folio));",
            "}",
            "static __always_inline nodemask_t get_memtier_nodemask(struct memory_tier *memtier)",
            "{",
            "\tnodemask_t nodes = NODE_MASK_NONE;",
            "\tstruct memory_dev_type *memtype;",
            "",
            "\tlist_for_each_entry(memtype, &memtier->memory_types, tier_sibling)",
            "\t\tnodes_or(nodes, nodes, memtype->nodes);",
            "",
            "\treturn nodes;",
            "}",
            "static void memory_tier_device_release(struct device *dev)",
            "{",
            "\tstruct memory_tier *tier = to_memory_tier(dev);",
            "\t/*",
            "\t * synchronize_rcu in clear_node_memory_tier makes sure",
            "\t * we don't have rcu access to this memory tier.",
            "\t */",
            "\tkfree(tier);",
            "}",
            "static ssize_t nodelist_show(struct device *dev,",
            "\t\t\t     struct device_attribute *attr, char *buf)",
            "{",
            "\tint ret;",
            "\tnodemask_t nmask;",
            "",
            "\tmutex_lock(&memory_tier_lock);",
            "\tnmask = get_memtier_nodemask(to_memory_tier(dev));",
            "\tret = sysfs_emit(buf, \"%*pbl\\n\", nodemask_pr_args(&nmask));",
            "\tmutex_unlock(&memory_tier_lock);",
            "\treturn ret;",
            "}",
            "bool node_is_toptier(int node)",
            "{",
            "\tbool toptier;",
            "\tpg_data_t *pgdat;",
            "\tstruct memory_tier *memtier;",
            "",
            "\tpgdat = NODE_DATA(node);",
            "\tif (!pgdat)",
            "\t\treturn false;",
            "",
            "\trcu_read_lock();",
            "\tmemtier = rcu_dereference(pgdat->memtier);",
            "\tif (!memtier) {",
            "\t\ttoptier = true;",
            "\t\tgoto out;",
            "\t}",
            "\tif (memtier->adistance_start <= top_tier_adistance)",
            "\t\ttoptier = true;",
            "\telse",
            "\t\ttoptier = false;",
            "out:",
            "\trcu_read_unlock();",
            "\treturn toptier;",
            "}",
            "void node_get_allowed_targets(pg_data_t *pgdat, nodemask_t *targets)",
            "{",
            "\tstruct memory_tier *memtier;",
            "",
            "\t/*",
            "\t * pg_data_t.memtier updates includes a synchronize_rcu()",
            "\t * which ensures that we either find NULL or a valid memtier",
            "\t * in NODE_DATA. protect the access via rcu_read_lock();",
            "\t */",
            "\trcu_read_lock();",
            "\tmemtier = rcu_dereference(pgdat->memtier);",
            "\tif (memtier)",
            "\t\t*targets = memtier->lower_tier_mask;",
            "\telse",
            "\t\t*targets = NODE_MASK_NONE;",
            "\trcu_read_unlock();",
            "}",
            "int next_demotion_node(int node)",
            "{",
            "\tstruct demotion_nodes *nd;",
            "\tint target;",
            "",
            "\tif (!node_demotion)",
            "\t\treturn NUMA_NO_NODE;",
            "",
            "\tnd = &node_demotion[node];",
            "",
            "\t/*",
            "\t * node_demotion[] is updated without excluding this",
            "\t * function from running.",
            "\t *",
            "\t * Make sure to use RCU over entire code blocks if",
            "\t * node_demotion[] reads need to be consistent.",
            "\t */",
            "\trcu_read_lock();",
            "\t/*",
            "\t * If there are multiple target nodes, just select one",
            "\t * target node randomly.",
            "\t *",
            "\t * In addition, we can also use round-robin to select",
            "\t * target node, but we should introduce another variable",
            "\t * for node_demotion[] to record last selected target node,",
            "\t * that may cause cache ping-pong due to the changing of",
            "\t * last target node. Or introducing per-cpu data to avoid",
            "\t * caching issue, which seems more complicated. So selecting",
            "\t * target node randomly seems better until now.",
            "\t */",
            "\ttarget = node_random(&nd->preferred);",
            "\trcu_read_unlock();",
            "",
            "\treturn target;",
            "}"
          ],
          "function_name": "folio_use_access_time, get_memtier_nodemask, memory_tier_device_release, nodelist_show, node_is_toptier, node_get_allowed_targets, next_demotion_node",
          "description": "实现内存分层核心功能，包括判断页是否使用访问时间、获取内存分层节点掩码、设备释放、节点列表展示、判断是否为顶层节点、获取允许目标节点以及选择下一个降级节点的算法实现。",
          "similarity": 0.5402694940567017
        },
        {
          "chunk_id": 2,
          "file_path": "mm/memory-tiers.c",
          "start_line": 357,
          "end_line": 472,
          "content": [
            "static void disable_all_demotion_targets(void)",
            "{",
            "\tstruct memory_tier *memtier;",
            "\tint node;",
            "",
            "\tfor_each_node_state(node, N_MEMORY) {",
            "\t\tnode_demotion[node].preferred = NODE_MASK_NONE;",
            "\t\t/*",
            "\t\t * We are holding memory_tier_lock, it is safe",
            "\t\t * to access pgda->memtier.",
            "\t\t */",
            "\t\tmemtier = __node_get_memory_tier(node);",
            "\t\tif (memtier)",
            "\t\t\tmemtier->lower_tier_mask = NODE_MASK_NONE;",
            "\t}",
            "\t/*",
            "\t * Ensure that the \"disable\" is visible across the system.",
            "\t * Readers will see either a combination of before+disable",
            "\t * state or disable+after.  They will never see before and",
            "\t * after state together.",
            "\t */",
            "\tsynchronize_rcu();",
            "}",
            "static void establish_demotion_targets(void)",
            "{",
            "\tstruct memory_tier *memtier;",
            "\tstruct demotion_nodes *nd;",
            "\tint target = NUMA_NO_NODE, node;",
            "\tint distance, best_distance;",
            "\tnodemask_t tier_nodes, lower_tier;",
            "",
            "\tlockdep_assert_held_once(&memory_tier_lock);",
            "",
            "\tif (!node_demotion)",
            "\t\treturn;",
            "",
            "\tdisable_all_demotion_targets();",
            "",
            "\tfor_each_node_state(node, N_MEMORY) {",
            "\t\tbest_distance = -1;",
            "\t\tnd = &node_demotion[node];",
            "",
            "\t\tmemtier = __node_get_memory_tier(node);",
            "\t\tif (!memtier || list_is_last(&memtier->list, &memory_tiers))",
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * Get the lower memtier to find the  demotion node list.",
            "\t\t */",
            "\t\tmemtier = list_next_entry(memtier, list);",
            "\t\ttier_nodes = get_memtier_nodemask(memtier);",
            "\t\t/*",
            "\t\t * find_next_best_node, use 'used' nodemask as a skip list.",
            "\t\t * Add all memory nodes except the selected memory tier",
            "\t\t * nodelist to skip list so that we find the best node from the",
            "\t\t * memtier nodelist.",
            "\t\t */",
            "\t\tnodes_andnot(tier_nodes, node_states[N_MEMORY], tier_nodes);",
            "",
            "\t\t/*",
            "\t\t * Find all the nodes in the memory tier node list of same best distance.",
            "\t\t * add them to the preferred mask. We randomly select between nodes",
            "\t\t * in the preferred mask when allocating pages during demotion.",
            "\t\t */",
            "\t\tdo {",
            "\t\t\ttarget = find_next_best_node(node, &tier_nodes);",
            "\t\t\tif (target == NUMA_NO_NODE)",
            "\t\t\t\tbreak;",
            "",
            "\t\t\tdistance = node_distance(node, target);",
            "\t\t\tif (distance == best_distance || best_distance == -1) {",
            "\t\t\t\tbest_distance = distance;",
            "\t\t\t\tnode_set(target, nd->preferred);",
            "\t\t\t} else {",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t} while (1);",
            "\t}",
            "\t/*",
            "\t * Promotion is allowed from a memory tier to higher",
            "\t * memory tier only if the memory tier doesn't include",
            "\t * compute. We want to skip promotion from a memory tier,",
            "\t * if any node that is part of the memory tier have CPUs.",
            "\t * Once we detect such a memory tier, we consider that tier",
            "\t * as top tiper from which promotion is not allowed.",
            "\t */",
            "\tlist_for_each_entry_reverse(memtier, &memory_tiers, list) {",
            "\t\ttier_nodes = get_memtier_nodemask(memtier);",
            "\t\tnodes_and(tier_nodes, node_states[N_CPU], tier_nodes);",
            "\t\tif (!nodes_empty(tier_nodes)) {",
            "\t\t\t/*",
            "\t\t\t * abstract distance below the max value of this memtier",
            "\t\t\t * is considered toptier.",
            "\t\t\t */",
            "\t\t\ttop_tier_adistance = memtier->adistance_start +",
            "\t\t\t\t\t\tMEMTIER_CHUNK_SIZE - 1;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\t/*",
            "\t * Now build the lower_tier mask for each node collecting node mask from",
            "\t * all memory tier below it. This allows us to fallback demotion page",
            "\t * allocation to a set of nodes that is closer the above selected",
            "\t * perferred node.",
            "\t */",
            "\tlower_tier = node_states[N_MEMORY];",
            "\tlist_for_each_entry(memtier, &memory_tiers, list) {",
            "\t\t/*",
            "\t\t * Keep removing current tier from lower_tier nodes,",
            "\t\t * This will remove all nodes in current and above",
            "\t\t * memory tier from the lower_tier mask.",
            "\t\t */",
            "\t\ttier_nodes = get_memtier_nodemask(memtier);",
            "\t\tnodes_andnot(lower_tier, lower_tier, tier_nodes);",
            "\t\tmemtier->lower_tier_mask = lower_tier;",
            "\t}",
            "}"
          ],
          "function_name": "disable_all_demotion_targets, establish_demotion_targets",
          "description": "负责维护内存分层间的降级目标关系，通过遍历所有节点计算最佳距离并更新lower_tier_mask。同步RCU保证内存分层变更的可见性，最终构建各节点的下层内存掩码供后续页面迁移使用。",
          "similarity": 0.5360438227653503
        },
        {
          "chunk_id": 3,
          "file_path": "mm/memory-tiers.c",
          "start_line": 481,
          "end_line": 635,
          "content": [
            "static inline void establish_demotion_targets(void) {}",
            "static inline void __init_node_memory_type(int node, struct memory_dev_type *memtype)",
            "{",
            "\tif (!node_memory_types[node].memtype)",
            "\t\tnode_memory_types[node].memtype = memtype;",
            "\t/*",
            "\t * for each device getting added in the same NUMA node",
            "\t * with this specific memtype, bump the map count. We",
            "\t * Only take memtype device reference once, so that",
            "\t * changing a node memtype can be done by droping the",
            "\t * only reference count taken here.",
            "\t */",
            "",
            "\tif (node_memory_types[node].memtype == memtype) {",
            "\t\tif (!node_memory_types[node].map_count++)",
            "\t\t\tkref_get(&memtype->kref);",
            "\t}",
            "}",
            "static void destroy_memory_tier(struct memory_tier *memtier)",
            "{",
            "\tlist_del(&memtier->list);",
            "\tdevice_unregister(&memtier->dev);",
            "}",
            "static bool clear_node_memory_tier(int node)",
            "{",
            "\tbool cleared = false;",
            "\tpg_data_t *pgdat;",
            "\tstruct memory_tier *memtier;",
            "",
            "\tpgdat = NODE_DATA(node);",
            "\tif (!pgdat)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Make sure that anybody looking at NODE_DATA who finds",
            "\t * a valid memtier finds memory_dev_types with nodes still",
            "\t * linked to the memtier. We achieve this by waiting for",
            "\t * rcu read section to finish using synchronize_rcu.",
            "\t * This also enables us to free the destroyed memory tier",
            "\t * with kfree instead of kfree_rcu",
            "\t */",
            "\tmemtier = __node_get_memory_tier(node);",
            "\tif (memtier) {",
            "\t\tstruct memory_dev_type *memtype;",
            "",
            "\t\trcu_assign_pointer(pgdat->memtier, NULL);",
            "\t\tsynchronize_rcu();",
            "\t\tmemtype = node_memory_types[node].memtype;",
            "\t\tnode_clear(node, memtype->nodes);",
            "\t\tif (nodes_empty(memtype->nodes)) {",
            "\t\t\tlist_del_init(&memtype->tier_sibling);",
            "\t\t\tif (list_empty(&memtier->memory_types))",
            "\t\t\t\tdestroy_memory_tier(memtier);",
            "\t\t}",
            "\t\tcleared = true;",
            "\t}",
            "\treturn cleared;",
            "}",
            "static void release_memtype(struct kref *kref)",
            "{",
            "\tstruct memory_dev_type *memtype;",
            "",
            "\tmemtype = container_of(kref, struct memory_dev_type, kref);",
            "\tkfree(memtype);",
            "}",
            "void put_memory_type(struct memory_dev_type *memtype)",
            "{",
            "\tkref_put(&memtype->kref, release_memtype);",
            "}",
            "void init_node_memory_type(int node, struct memory_dev_type *memtype)",
            "{",
            "",
            "\tmutex_lock(&memory_tier_lock);",
            "\t__init_node_memory_type(node, memtype);",
            "\tmutex_unlock(&memory_tier_lock);",
            "}",
            "void clear_node_memory_type(int node, struct memory_dev_type *memtype)",
            "{",
            "\tmutex_lock(&memory_tier_lock);",
            "\tif (node_memory_types[node].memtype == memtype || !memtype)",
            "\t\tnode_memory_types[node].map_count--;",
            "\t/*",
            "\t * If we umapped all the attached devices to this node,",
            "\t * clear the node memory type.",
            "\t */",
            "\tif (!node_memory_types[node].map_count) {",
            "\t\tmemtype = node_memory_types[node].memtype;",
            "\t\tnode_memory_types[node].memtype = NULL;",
            "\t\tput_memory_type(memtype);",
            "\t}",
            "\tmutex_unlock(&memory_tier_lock);",
            "}",
            "static void dump_hmem_attrs(struct access_coordinate *coord, const char *prefix)",
            "{",
            "\tpr_info(",
            "\"%sread_latency: %u, write_latency: %u, read_bandwidth: %u, write_bandwidth: %u\\n\",",
            "\t\tprefix, coord->read_latency, coord->write_latency,",
            "\t\tcoord->read_bandwidth, coord->write_bandwidth);",
            "}",
            "int mt_set_default_dram_perf(int nid, struct access_coordinate *perf,",
            "\t\t\t     const char *source)",
            "{",
            "\tint rc = 0;",
            "",
            "\tmutex_lock(&memory_tier_lock);",
            "\tif (default_dram_perf_error) {",
            "\t\trc = -EIO;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (perf->read_latency + perf->write_latency == 0 ||",
            "\t    perf->read_bandwidth + perf->write_bandwidth == 0) {",
            "\t\trc = -EINVAL;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (default_dram_perf_ref_nid == NUMA_NO_NODE) {",
            "\t\tdefault_dram_perf = *perf;",
            "\t\tdefault_dram_perf_ref_nid = nid;",
            "\t\tdefault_dram_perf_ref_source = kstrdup(source, GFP_KERNEL);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * The performance of all default DRAM nodes is expected to be",
            "\t * same (that is, the variation is less than 10%).  And it",
            "\t * will be used as base to calculate the abstract distance of",
            "\t * other memory nodes.",
            "\t */",
            "\tif (abs(perf->read_latency - default_dram_perf.read_latency) * 10 >",
            "\t    default_dram_perf.read_latency ||",
            "\t    abs(perf->write_latency - default_dram_perf.write_latency) * 10 >",
            "\t    default_dram_perf.write_latency ||",
            "\t    abs(perf->read_bandwidth - default_dram_perf.read_bandwidth) * 10 >",
            "\t    default_dram_perf.read_bandwidth ||",
            "\t    abs(perf->write_bandwidth - default_dram_perf.write_bandwidth) * 10 >",
            "\t    default_dram_perf.write_bandwidth) {",
            "\t\tpr_info(",
            "\"memory-tiers: the performance of DRAM node %d mismatches that of the reference\\n\"",
            "\"DRAM node %d.\\n\", nid, default_dram_perf_ref_nid);",
            "\t\tpr_info(\"  performance of reference DRAM node %d:\\n\",",
            "\t\t\tdefault_dram_perf_ref_nid);",
            "\t\tdump_hmem_attrs(&default_dram_perf, \"    \");",
            "\t\tpr_info(\"  performance of DRAM node %d:\\n\", nid);",
            "\t\tdump_hmem_attrs(perf, \"    \");",
            "\t\tpr_info(",
            "\"  disable default DRAM node performance based abstract distance algorithm.\\n\");",
            "\t\tdefault_dram_perf_error = true;",
            "\t\trc = -EINVAL;",
            "\t}",
            "",
            "out:",
            "\tmutex_unlock(&memory_tier_lock);",
            "\treturn rc;",
            "}"
          ],
          "function_name": "establish_demotion_targets, __init_node_memory_type, destroy_memory_tier, clear_node_memory_tier, release_memtype, put_memory_type, init_node_memory_type, clear_node_memory_type, dump_hmem_attrs, mt_set_default_dram_perf",
          "description": "实现内存类型管理系统，包含初始化/清除节点内存类型、引用计数管理、性能属性打印、默认DRAM性能设置等功能。通过kref机制跟踪内存类型引用，确保内存分层结构的正确释放。",
          "similarity": 0.5202090740203857
        }
      ]
    },
    {
      "source_file": "kernel/user.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:45:58\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user.c`\n\n---\n\n# user.c 技术文档\n\n## 1. 文件概述\n\n`user.c` 实现了 Linux 内核中的 **用户缓存（user cache）** 机制，用于跟踪每个用户（以 UID 标识）所占用的系统资源（如进程数、打开文件数等），从而支持基于用户的资源限制（per-user limits）。该文件维护了一个全局的哈希表，用于快速查找和管理 `user_struct` 结构体实例，并提供了用户结构的分配、引用计数管理和释放接口。此外，文件还定义了初始用户命名空间 `init_user_ns` 和根用户结构 `root_user`，为系统启动和用户命名空间功能提供基础支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`init_user_ns`**：全局初始用户命名空间（`struct user_namespace`），作为所有用户命名空间的根，包含完整的 UID/GID/ProjID 映射（0~2³²-1），引用计数初始化为 3。\n- **`root_user`**：代表 UID 为 0 的根用户的 `struct user_struct` 实例，引用计数初始化为 1（供 init 进程使用）。\n- **`uidhash_table`**：大小为 `2^UIDHASH_BITS`（通常为 128）的哈希表，用于存储 `user_struct` 实例，实现 O(1) 平均查找复杂度。\n- **`uid_cachep`**：SLAB 缓存，用于高效分配和释放 `struct user_struct` 对象。\n\n### 主要函数\n\n- **`alloc_uid(kuid_t uid)`**：根据 UID 查找或创建对应的 `user_struct`。若不存在则分配新结构体，初始化资源计数器（如 epoll watches），并插入哈希表；若已存在则增加引用计数。处理并发创建的竞争条件。\n- **`find_user(kuid_t uid)`**：在哈希表中查找指定 UID 的 `user_struct`，若找到则增加引用计数并返回，否则返回 NULL。\n- **`free_uid(struct user_struct *up)`**：减少 `user_struct` 的引用计数，若计数归零则调用 `free_user` 释放资源。\n- **`free_user(struct user_struct *up, unsigned long flags)`**：内部函数，从哈希表中移除用户结构，释放 epoll 计数器，并通过 SLAB 缓存回收内存。\n- **`uid_cache_init(void)`**：初始化函数（通过 `subsys_initcall` 注册），创建 SLAB 缓存、初始化哈希表、为 `root_user` 分配 epoll 计数器，并将 `root_user` 插入哈希表。\n\n### 辅助函数\n\n- **`uid_hash_insert/remove/find`**：哈希表操作的内部封装，必须在持有 `uidhash_lock` 自旋锁时调用。\n- **`user_epoll_alloc/free`**：条件编译函数，用于初始化/销毁 `user_struct` 中的 epoll watches per-CPU 计数器（仅当 `CONFIG_EPOLL` 启用时有效）。\n\n## 3. 关键实现\n\n### 哈希表设计与并发控制\n\n- **哈希函数**：使用 `__uidhashfn(uid) = ((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK`，将 32 位 UID 映射到 `UIDHASH_SZ`（默认 128）个桶中，减少冲突。\n- **锁机制**：使用 `DEFINE_SPINLOCK(uidhash_lock)` 保护哈希表操作。该锁需 **软中断安全（softirq-safe）**，因为 `free_uid()` 可能在 RCU 回调（软中断上下文）中被调用。\n- **中断处理**：所有哈希表操作均使用 `spin_lock_irqsave/restore` 或 `spin_lock_irq/unlock`，确保在中断上下文和进程上下文间的正确同步。\n\n### 引用计数与资源管理\n\n- **引用计数**：`user_struct.__count` 使用 `refcount_t` 类型，确保原子操作。`alloc_uid` 返回时已持有引用，调用者必须通过 `free_uid` 释放。\n- **延迟释放**：`free_uid` 使用 `refcount_dec_and_lock_irqsave` 原子地减少计数并在归零时获取锁，避免竞态条件。\n- **资源初始化**：新创建的 `user_struct` 会初始化速率限制器（`ratelimit`）和 epoll watches 计数器（若启用）。\n\n### 初始化与竞态处理\n\n- **`root_user` 预置**：在 `uid_cache_init` 中预先将 `root_user` 插入哈希表，确保 init 进程可直接使用。\n- **双重检查**：`alloc_uid` 在分配新结构后再次检查哈希表，防止多线程同时创建同一 UID 的 `user_struct`，确保唯一性。\n\n### 用户命名空间支持\n\n- **`init_user_ns`**：作为初始用户命名空间，其 UID/GID 映射覆盖全范围（0 到 2³²-1），标志位 `USERNS_INIT_FLAGS` 启用特定行为（如允许 setgroups）。\n- **密钥环支持**：若启用 `CONFIG_KEYS`，`init_user_ns` 包含密钥环名称列表和读写信号量。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/sched/user.h>`：定义 `struct user_struct`。\n  - `<linux/user_namespace.h>`：定义 `struct user_namespace` 和相关操作。\n  - `<linux/key.h>`：提供密钥环支持（条件编译）。\n  - `<linux/percpu_counter.h>`（隐含）：用于 epoll watches 计数（通过 `CONFIG_EPOLL`）。\n- **内核配置依赖**：\n  - `CONFIG_EPOLL`：控制 epoll watches 计数器的编译。\n  - `CONFIG_USER_NS`：控制用户命名空间操作函数的绑定。\n  - `CONFIG_KEYS`：控制密钥环相关字段的初始化。\n- **子系统依赖**：\n  - **进程调度子系统**：`user_struct` 被嵌入到进程凭证（`cred`）中，用于资源统计。\n  - **用户命名空间子系统**：`init_user_ns` 是用户命名空间层次结构的根。\n  - **内存管理子系统**：依赖 SLAB 分配器管理 `user_struct` 对象。\n\n## 5. 使用场景\n\n- **进程凭证管理**：当进程通过 `setuid()`、`setreuid()` 等系统调用切换用户身份时，内核调用 `alloc_uid` 获取目标 UID 的 `user_struct`，并更新进程凭证中的用户引用。\n- **资源限制实施**：内核在创建进程、打开文件、分配内存等操作时，通过 `current_uid()` 获取当前用户的 `user_struct`，检查并更新资源使用计数（如 `processes`、`files` 字段），确保不超过 `ulimit` 限制。\n- **用户命名空间创建**：新用户命名空间的创建依赖 `init_user_ns` 作为父命名空间，并继承其映射逻辑。\n- **系统初始化**：在内核启动早期（`subsys_initcall` 阶段），初始化用户缓存和根用户结构，为 init 进程（PID 1）提供用户上下文。\n- **资源回收**：当进程退出或切换用户时，通过 `free_uid` 释放不再需要的 `user_struct` 引用，最终在引用计数归零时回收内存和相关资源（如 epoll 计数器）。",
      "similarity": 0.6100228428840637,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/user.c",
          "start_line": 1,
          "end_line": 107,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * The \"user cache\".",
            " *",
            " * (C) Copyright 1991-2000 Linus Torvalds",
            " *",
            " * We have a per-user structure to keep track of how many",
            " * processes, files etc the user has claimed, in order to be",
            " * able to have per-user limits for system resources. ",
            " */",
            "",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/proc_ns.h>",
            "",
            "/*",
            " * userns count is 1 for root user, 1 for init_uts_ns,",
            " * and 1 for... ?",
            " */",
            "struct user_namespace init_user_ns = {",
            "\t.uid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.gid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.projid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.ns.count = REFCOUNT_INIT(3),",
            "\t.owner = GLOBAL_ROOT_UID,",
            "\t.group = GLOBAL_ROOT_GID,",
            "\t.ns.inum = PROC_USER_INIT_INO,",
            "#ifdef CONFIG_USER_NS",
            "\t.ns.ops = &userns_operations,",
            "#endif",
            "\t.flags = USERNS_INIT_FLAGS,",
            "#ifdef CONFIG_KEYS",
            "\t.keyring_name_list = LIST_HEAD_INIT(init_user_ns.keyring_name_list),",
            "\t.keyring_sem = __RWSEM_INITIALIZER(init_user_ns.keyring_sem),",
            "#endif",
            "};",
            "EXPORT_SYMBOL_GPL(init_user_ns);",
            "",
            "/*",
            " * UID task count cache, to get fast user lookup in \"alloc_uid\"",
            " * when changing user ID's (ie setuid() and friends).",
            " */",
            "",
            "#define UIDHASH_BITS\t(CONFIG_BASE_SMALL ? 3 : 7)",
            "#define UIDHASH_SZ\t(1 << UIDHASH_BITS)",
            "#define UIDHASH_MASK\t\t(UIDHASH_SZ - 1)",
            "#define __uidhashfn(uid)\t(((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK)",
            "#define uidhashentry(uid)\t(uidhash_table + __uidhashfn((__kuid_val(uid))))",
            "",
            "static struct kmem_cache *uid_cachep;",
            "static struct hlist_head uidhash_table[UIDHASH_SZ];",
            "",
            "/*",
            " * The uidhash_lock is mostly taken from process context, but it is",
            " * occasionally also taken from softirq/tasklet context, when",
            " * task-structs get RCU-freed. Hence all locking must be softirq-safe.",
            " * But free_uid() is also called with local interrupts disabled, and running",
            " * local_bh_enable() with local interrupts disabled is an error - we'll run",
            " * softirq callbacks, and they can unconditionally enable interrupts, and",
            " * the caller of free_uid() didn't expect that..",
            " */",
            "static DEFINE_SPINLOCK(uidhash_lock);",
            "",
            "/* root_user.__count is 1, for init task cred */",
            "struct user_struct root_user = {",
            "\t.__count\t= REFCOUNT_INIT(1),",
            "\t.uid\t\t= GLOBAL_ROOT_UID,",
            "\t.ratelimit\t= RATELIMIT_STATE_INIT(root_user.ratelimit, 0, 0),",
            "};",
            "",
            "/*",
            " * These routines must be called with the uidhash spinlock held!",
            " */"
          ],
          "function_name": null,
          "description": "定义初始用户命名空间init_user_ns，配置UID/GID/PROJID映射关系并初始化引用计数，建立全局根用户user_struct结构，通过uidhash_table构建基于哈希的UID快速查找表，设置UID哈希锁及缓存参数",
          "similarity": 0.49780040979385376
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/user.c",
          "start_line": 108,
          "end_line": 167,
          "content": [
            "static void uid_hash_insert(struct user_struct *up, struct hlist_head *hashent)",
            "{",
            "\thlist_add_head(&up->uidhash_node, hashent);",
            "}",
            "static void uid_hash_remove(struct user_struct *up)",
            "{",
            "\thlist_del_init(&up->uidhash_node);",
            "}",
            "static int user_epoll_alloc(struct user_struct *up)",
            "{",
            "#ifdef CONFIG_EPOLL",
            "\treturn percpu_counter_init(&up->epoll_watches, 0, GFP_KERNEL);",
            "#else",
            "\treturn 0;",
            "#endif",
            "}",
            "static void user_epoll_free(struct user_struct *up)",
            "{",
            "#ifdef CONFIG_EPOLL",
            "\tpercpu_counter_destroy(&up->epoll_watches);",
            "#endif",
            "}",
            "static void free_user(struct user_struct *up, unsigned long flags)",
            "\t__releases(&uidhash_lock)",
            "{",
            "\tuid_hash_remove(up);",
            "\tspin_unlock_irqrestore(&uidhash_lock, flags);",
            "\tuser_epoll_free(up);",
            "\tkmem_cache_free(uid_cachep, up);",
            "}",
            "void free_uid(struct user_struct *up)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (!up)",
            "\t\treturn;",
            "",
            "\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))",
            "\t\tfree_user(up, flags);",
            "}",
            "static int __init uid_cache_init(void)",
            "{",
            "\tint n;",
            "",
            "\tuid_cachep = kmem_cache_create(\"uid_cache\", sizeof(struct user_struct),",
            "\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);",
            "",
            "\tfor(n = 0; n < UIDHASH_SZ; ++n)",
            "\t\tINIT_HLIST_HEAD(uidhash_table + n);",
            "",
            "\tif (user_epoll_alloc(&root_user))",
            "\t\tpanic(\"root_user epoll percpu counter alloc failed\");",
            "",
            "\t/* Insert the root user immediately (init already runs as root) */",
            "\tspin_lock_irq(&uidhash_lock);",
            "\tuid_hash_insert(&root_user, uidhashentry(GLOBAL_ROOT_UID));",
            "\tspin_unlock_irq(&uidhash_lock);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "uid_hash_insert, uid_hash_remove, user_epoll_alloc, user_epoll_free, free_user, free_uid, uid_cache_init",
          "description": "实现用户结构体在UID哈希表中的增删操作，管理epoll计数器资源分配释放，提供free_user/free_uid接口完成用户结构销毁流程，初始化uid_cache缓存及哈希表基础结构并注册根用户",
          "similarity": 0.47705575823783875
        }
      ]
    }
  ]
}