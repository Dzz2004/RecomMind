{
  "query": "timer_interrupt",
  "timestamp": "2025-12-26 02:16:48",
  "retrieved_files": [
    {
      "source_file": "kernel/time/alarmtimer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:35:01\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\alarmtimer.c`\n\n---\n\n# `time/alarmtimer.c` 技术文档\n\n## 1. 文件概述\n\n`alarmtimer.c` 实现了 Linux 内核中的 **Alarm Timer（闹钟定时器）** 接口。该接口提供了一种类似于高精度定时器（hrtimer）的机制，但关键区别在于：**当系统进入挂起（suspend）状态时，alarmtimer 能够通过 RTC（实时时钟）硬件触发唤醒事件**，从而在指定时间唤醒系统。\n\n该机制主要用于支持需要在系统休眠期间仍能按时触发的定时任务，例如 Android 系统中的闹钟服务、电源管理中的定时唤醒等场景。其设计受到 Android RTC Alarm Timer 接口的影响。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct alarm_base`**  \n  表示一种类型的 alarm timer 基础结构，系统支持 `ALARM_NUMTYPE` 种类型（通常包括 `CLOCK_REALTIME` 和 `CLOCK_BOOTTIME`）。\n  - `lock`：自旋锁，用于同步访问\n  - `timerqueue`：基于红黑树的定时器队列，管理所有待触发的 alarm\n  - `get_ktime` / `get_timespec`：获取当前时间的函数指针\n  - `base_clockid`：对应的 POSIX 时钟 ID（如 `CLOCK_REALTIME`）\n\n- **`struct alarm`**  \n  用户定义的 alarm 实例，包含：\n  - `timer`：底层 hrtimer\n  - `node`：在 timerqueue 中的节点\n  - `function`：超时回调函数\n  - `type`：所属的 alarm_base 类型\n  - `state`：状态标志（如 `ALARMTIMER_STATE_ENQUEUED`）\n\n### 主要函数\n\n- **`alarmtimer_enqueue()` / `alarmtimer_dequeue()`**  \n  将 alarm 加入或移出对应 alarm_base 的 timerqueue。\n\n- **`alarmtimer_fired()`**  \n  hrtimer 超时回调函数，负责执行用户注册的 alarm 回调，并根据返回值决定是否重新调度。\n\n- **`alarm_expires_remaining()`**  \n  计算指定 alarm 距离到期还剩多长时间（导出给其他模块使用）。\n\n- **`alarmtimer_get_rtcdev()`**  \n  获取当前用于 suspend 唤醒的 RTC 设备（导出符号）。\n\n- **`alarmtimer_suspend()`**  \n  系统挂起前的回调，查找最近的 alarm 并通过 RTC 设置硬件唤醒。\n\n- **`alarmtimer_rtc_add_device()`**  \n  RTC 设备注册回调，选择第一个支持 alarm 和 wakeup 功能的 RTC 作为 alarmtimer 的后端。\n\n## 3. 关键实现\n\n### Alarm Timer 与 hrtimer 集成\n每个 `alarm` 内嵌一个 `hrtimer`。当系统处于运行状态时，alarm 完全依赖 hrtimer 触发；当系统挂起时，alarmtimer 会将最近的到期时间转换为 RTC alarm，利用硬件 RTC 在 suspend 期间计时并唤醒系统。\n\n### 多时钟域支持\n通过 `alarm_bases[]` 数组支持多种时钟类型（如 `CLOCK_REALTIME` 受系统时间调整影响，`CLOCK_BOOTTIME` 不受影响但包含 suspend 时间）。每种类型有独立的 timerqueue 和时间获取函数。\n\n### Suspend/Wakeup 机制\n在 `alarmtimer_suspend()` 中：\n1. 遍历所有 alarm_base，找出最早到期的 alarm。\n2. 若到期时间距离当前不足 2 秒，则拒绝 suspend（避免频繁唤醒）。\n3. 否则，将该时间转换为 RTC 时间，并通过 `rtc_timer_start()` 设置 RTC alarm。\n4. 系统被 RTC 唤醒后，内核会重新调度相应的 alarm。\n\n### Freezer 支持\n为支持 `clock_nanosleep()` 等在 freeze 过程中触发的唤醒，引入了 `freezer_delta` 机制，临时记录 freezer 触发的 alarm 信息，确保 suspend 时能正确处理。\n\n### RTC 设备自动绑定\n通过 `class_interface` 机制监听 RTC 设备注册事件，自动选择第一个支持 `RTC_FEATURE_ALARM` 且父设备支持 wakeup 的 RTC 作为 alarmtimer 的硬件后端，并创建对应的 platform device。\n\n## 4. 依赖关系\n\n- **`<linux/hrtimer.h>`**：底层高精度定时器实现\n- **`<linux/rtc.h>`**：RTC 设备驱动接口，用于 suspend 唤醒\n- **`<linux/posix-timers.h>`**：POSIX 定时器支持，alarmtimer 是其底层实现之一\n- **`<linux/time_namespace.h>`**：时间命名空间支持（用于容器化环境）\n- **`CONFIG_RTC_CLASS`**：RTC 子系统，决定是否启用 suspend 唤醒功能\n- **`CONFIG_POSIX_TIMERS`**：决定是否启用 freezer 相关逻辑\n\n## 5. 使用场景\n\n1. **Android 系统闹钟服务**：应用设置的闹钟即使在设备休眠时也能准时触发。\n2. **电源管理**：内核或用户空间需要在特定时间唤醒系统执行任务（如网络同步、传感器采样）。\n3. **POSIX 定时器**：`timer_create()` 使用 `CLOCK_REALTIME_ALARM` 或 `CLOCK_BOOTTIME_ALARM` 时，底层由 alarmtimer 实现。\n4. **用户空间 `clock_nanosleep()`**：当使用 `TIMER_ABSTIME` 和 alarm 时钟时，可在 suspend 期间唤醒。\n5. **内核模块定时唤醒**：需要在系统挂起后仍能触发事件的驱动或子系统。",
      "similarity": 0.5701568126678467,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/time/alarmtimer.c",
          "start_line": 84,
          "end_line": 188,
          "content": [
            "static int alarmtimer_rtc_add_device(struct device *dev)",
            "{",
            "\tunsigned long flags;",
            "\tstruct rtc_device *rtc = to_rtc_device(dev);",
            "\tstruct platform_device *pdev;",
            "\tint ret = 0;",
            "",
            "\tif (rtcdev)",
            "\t\treturn -EBUSY;",
            "",
            "\tif (!test_bit(RTC_FEATURE_ALARM, rtc->features))",
            "\t\treturn -1;",
            "\tif (!device_may_wakeup(rtc->dev.parent))",
            "\t\treturn -1;",
            "",
            "\tpdev = platform_device_register_data(dev, \"alarmtimer\",",
            "\t\t\t\t\t     PLATFORM_DEVID_AUTO, NULL, 0);",
            "\tif (!IS_ERR(pdev))",
            "\t\tdevice_init_wakeup(&pdev->dev, true);",
            "",
            "\tspin_lock_irqsave(&rtcdev_lock, flags);",
            "\tif (!IS_ERR(pdev) && !rtcdev) {",
            "\t\tif (!try_module_get(rtc->owner)) {",
            "\t\t\tret = -1;",
            "\t\t\tgoto unlock;",
            "\t\t}",
            "",
            "\t\trtcdev = rtc;",
            "\t\t/* hold a reference so it doesn't go away */",
            "\t\tget_device(dev);",
            "\t\tpdev = NULL;",
            "\t} else {",
            "\t\tret = -1;",
            "\t}",
            "unlock:",
            "\tspin_unlock_irqrestore(&rtcdev_lock, flags);",
            "",
            "\tplatform_device_unregister(pdev);",
            "",
            "\treturn ret;",
            "}",
            "static inline void alarmtimer_rtc_timer_init(void)",
            "{",
            "\trtc_timer_init(&rtctimer, NULL, NULL);",
            "}",
            "static int alarmtimer_rtc_interface_setup(void)",
            "{",
            "\talarmtimer_rtc_interface.class = rtc_class;",
            "\treturn class_interface_register(&alarmtimer_rtc_interface);",
            "}",
            "static void alarmtimer_rtc_interface_remove(void)",
            "{",
            "\tclass_interface_unregister(&alarmtimer_rtc_interface);",
            "}",
            "static inline int alarmtimer_rtc_interface_setup(void) { return 0; }",
            "static inline void alarmtimer_rtc_interface_remove(void) { }",
            "static inline void alarmtimer_rtc_timer_init(void) { }",
            "static void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)",
            "{",
            "\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)",
            "\t\ttimerqueue_del(&base->timerqueue, &alarm->node);",
            "",
            "\ttimerqueue_add(&base->timerqueue, &alarm->node);",
            "\talarm->state |= ALARMTIMER_STATE_ENQUEUED;",
            "}",
            "static void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)",
            "{",
            "\tif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))",
            "\t\treturn;",
            "",
            "\ttimerqueue_del(&base->timerqueue, &alarm->node);",
            "\talarm->state &= ~ALARMTIMER_STATE_ENQUEUED;",
            "}",
            "static enum hrtimer_restart alarmtimer_fired(struct hrtimer *timer)",
            "{",
            "\tstruct alarm *alarm = container_of(timer, struct alarm, timer);",
            "\tstruct alarm_base *base = &alarm_bases[alarm->type];",
            "\tunsigned long flags;",
            "\tint ret = HRTIMER_NORESTART;",
            "\tint restart = ALARMTIMER_NORESTART;",
            "",
            "\tspin_lock_irqsave(&base->lock, flags);",
            "\talarmtimer_dequeue(base, alarm);",
            "\tspin_unlock_irqrestore(&base->lock, flags);",
            "",
            "\tif (alarm->function)",
            "\t\trestart = alarm->function(alarm, base->get_ktime());",
            "",
            "\tspin_lock_irqsave(&base->lock, flags);",
            "\tif (restart != ALARMTIMER_NORESTART) {",
            "\t\thrtimer_set_expires(&alarm->timer, alarm->node.expires);",
            "\t\talarmtimer_enqueue(base, alarm);",
            "\t\tret = HRTIMER_RESTART;",
            "\t}",
            "\tspin_unlock_irqrestore(&base->lock, flags);",
            "",
            "\ttrace_alarmtimer_fired(alarm, base->get_ktime());",
            "\treturn ret;",
            "",
            "}",
            "ktime_t alarm_expires_remaining(const struct alarm *alarm)",
            "{",
            "\tstruct alarm_base *base = &alarm_bases[alarm->type];",
            "\treturn ktime_sub(alarm->node.expires, base->get_ktime());",
            "}"
          ],
          "function_name": "alarmtimer_rtc_add_device, alarmtimer_rtc_timer_init, alarmtimer_rtc_interface_setup, alarmtimer_rtc_interface_remove, alarmtimer_rtc_interface_setup, alarmtimer_rtc_interface_remove, alarmtimer_rtc_timer_init, alarmtimer_enqueue, alarmtimer_dequeue, alarmtimer_fired, alarm_expires_remaining",
          "description": "实现了RTC报警计时器的设备注册、定时器初始化、事件入队出队操作及触发回调。包含对定时器超时时的处理逻辑，通过hrtimer重启或移除节点控制报警流程。",
          "similarity": 0.5654171705245972
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/time/alarmtimer.c",
          "start_line": 676,
          "end_line": 784,
          "content": [
            "static int alarm_clock_getres(const clockid_t which_clock, struct timespec64 *tp)",
            "{",
            "\tif (!alarmtimer_get_rtcdev())",
            "\t\treturn -EINVAL;",
            "",
            "\ttp->tv_sec = 0;",
            "\ttp->tv_nsec = hrtimer_resolution;",
            "\treturn 0;",
            "}",
            "static int alarm_clock_get_timespec(clockid_t which_clock, struct timespec64 *tp)",
            "{",
            "\tstruct alarm_base *base = &alarm_bases[clock2alarm(which_clock)];",
            "",
            "\tif (!alarmtimer_get_rtcdev())",
            "\t\treturn -EINVAL;",
            "",
            "\tbase->get_timespec(tp);",
            "",
            "\treturn 0;",
            "}",
            "static ktime_t alarm_clock_get_ktime(clockid_t which_clock)",
            "{",
            "\tstruct alarm_base *base = &alarm_bases[clock2alarm(which_clock)];",
            "",
            "\tif (!alarmtimer_get_rtcdev())",
            "\t\treturn -EINVAL;",
            "",
            "\treturn base->get_ktime();",
            "}",
            "static int alarm_timer_create(struct k_itimer *new_timer)",
            "{",
            "\tenum  alarmtimer_type type;",
            "",
            "\tif (!alarmtimer_get_rtcdev())",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\tif (!capable(CAP_WAKE_ALARM))",
            "\t\treturn -EPERM;",
            "",
            "\ttype = clock2alarm(new_timer->it_clock);",
            "\talarm_init(&new_timer->it.alarm.alarmtimer, type, alarm_handle_timer);",
            "\treturn 0;",
            "}",
            "static enum alarmtimer_restart alarmtimer_nsleep_wakeup(struct alarm *alarm,",
            "\t\t\t\t\t\t\t\tktime_t now)",
            "{",
            "\tstruct task_struct *task = alarm->data;",
            "",
            "\talarm->data = NULL;",
            "\tif (task)",
            "\t\twake_up_process(task);",
            "\treturn ALARMTIMER_NORESTART;",
            "}",
            "static int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,",
            "\t\t\t\tenum alarmtimer_type type)",
            "{",
            "\tstruct restart_block *restart;",
            "\talarm->data = (void *)current;",
            "\tdo {",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\talarm_start(alarm, absexp);",
            "\t\tif (likely(alarm->data))",
            "\t\t\tschedule();",
            "",
            "\t\talarm_cancel(alarm);",
            "\t} while (alarm->data && !signal_pending(current));",
            "",
            "\t__set_current_state(TASK_RUNNING);",
            "",
            "\tdestroy_hrtimer_on_stack(&alarm->timer);",
            "",
            "\tif (!alarm->data)",
            "\t\treturn 0;",
            "",
            "\tif (freezing(current))",
            "\t\talarmtimer_freezerset(absexp, type);",
            "\trestart = &current->restart_block;",
            "\tif (restart->nanosleep.type != TT_NONE) {",
            "\t\tstruct timespec64 rmt;",
            "\t\tktime_t rem;",
            "",
            "\t\trem = ktime_sub(absexp, alarm_bases[type].get_ktime());",
            "",
            "\t\tif (rem <= 0)",
            "\t\t\treturn 0;",
            "\t\trmt = ktime_to_timespec64(rem);",
            "",
            "\t\treturn nanosleep_copyout(restart, &rmt);",
            "\t}",
            "\treturn -ERESTART_RESTARTBLOCK;",
            "}",
            "static void",
            "alarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,",
            "\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))",
            "{",
            "\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,",
            "\t\t\t      HRTIMER_MODE_ABS);",
            "\t__alarm_init(alarm, type, function);",
            "}",
            "static long __sched alarm_timer_nsleep_restart(struct restart_block *restart)",
            "{",
            "\tenum  alarmtimer_type type = restart->nanosleep.clockid;",
            "\tktime_t exp = restart->nanosleep.expires;",
            "\tstruct alarm alarm;",
            "",
            "\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);",
            "",
            "\treturn alarmtimer_do_nsleep(&alarm, exp, type);",
            "}"
          ],
          "function_name": "alarm_clock_getres, alarm_clock_get_timespec, alarm_clock_get_ktime, alarm_timer_create, alarmtimer_nsleep_wakeup, alarmtimer_do_nsleep, alarm_init_on_stack, alarm_timer_nsleep_restart",
          "description": "该代码段实现了基于高精度定时器（HRTIMER）的闹钟子系统，主要处理时钟分辨率查询、时间戳获取、定时器创建及睡眠中断逻辑。  \n`alarm_clock_getres`/`alarm_clock_get_timespec`/`alarm_clock_get_ktime`用于获取不同闹钟类型的时间属性和当前时间值，依赖`alarm_base`结构体的接口；`alarm_timer_create`初始化定时器并绑定唤醒回调函数，需RTC设备支持；`alarmtimer_do_nsleep`和相关函数处理睡眠中断逻辑，包含调度、超时检测及重启块恢复机制。  \n注：部分函数依赖未展示的`alarm_bases`数组和`clock2alarm`转换逻辑，上下文存在缺失。",
          "similarity": 0.5508379936218262
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/time/alarmtimer.c",
          "start_line": 843,
          "end_line": 922,
          "content": [
            "static int alarm_timer_nsleep(const clockid_t which_clock, int flags,",
            "\t\t\t      const struct timespec64 *tsreq)",
            "{",
            "\tenum  alarmtimer_type type = clock2alarm(which_clock);",
            "\tstruct restart_block *restart = &current->restart_block;",
            "\tstruct alarm alarm;",
            "\tktime_t exp;",
            "\tint ret;",
            "",
            "\tif (!alarmtimer_get_rtcdev())",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\tif (flags & ~TIMER_ABSTIME)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!capable(CAP_WAKE_ALARM))",
            "\t\treturn -EPERM;",
            "",
            "\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);",
            "",
            "\texp = timespec64_to_ktime(*tsreq);",
            "\t/* Convert (if necessary) to absolute time */",
            "\tif (flags != TIMER_ABSTIME) {",
            "\t\tktime_t now = alarm_bases[type].get_ktime();",
            "",
            "\t\texp = ktime_add_safe(now, exp);",
            "\t} else {",
            "\t\texp = timens_ktime_to_host(which_clock, exp);",
            "\t}",
            "",
            "\tret = alarmtimer_do_nsleep(&alarm, exp, type);",
            "\tif (ret != -ERESTART_RESTARTBLOCK)",
            "\t\treturn ret;",
            "",
            "\t/* abs timers don't set remaining time or restart */",
            "\tif (flags == TIMER_ABSTIME)",
            "\t\treturn -ERESTARTNOHAND;",
            "",
            "\trestart->nanosleep.clockid = type;",
            "\trestart->nanosleep.expires = exp;",
            "\tset_restart_fn(restart, alarm_timer_nsleep_restart);",
            "\treturn ret;",
            "}",
            "static void get_boottime_timespec(struct timespec64 *tp)",
            "{",
            "\tktime_get_boottime_ts64(tp);",
            "\ttimens_add_boottime(tp);",
            "}",
            "static int __init alarmtimer_init(void)",
            "{",
            "\tint error;",
            "\tint i;",
            "",
            "\talarmtimer_rtc_timer_init();",
            "",
            "\t/* Initialize alarm bases */",
            "\talarm_bases[ALARM_REALTIME].base_clockid = CLOCK_REALTIME;",
            "\talarm_bases[ALARM_REALTIME].get_ktime = &ktime_get_real;",
            "\talarm_bases[ALARM_REALTIME].get_timespec = ktime_get_real_ts64;",
            "\talarm_bases[ALARM_BOOTTIME].base_clockid = CLOCK_BOOTTIME;",
            "\talarm_bases[ALARM_BOOTTIME].get_ktime = &ktime_get_boottime;",
            "\talarm_bases[ALARM_BOOTTIME].get_timespec = get_boottime_timespec;",
            "\tfor (i = 0; i < ALARM_NUMTYPE; i++) {",
            "\t\ttimerqueue_init_head(&alarm_bases[i].timerqueue);",
            "\t\tspin_lock_init(&alarm_bases[i].lock);",
            "\t}",
            "",
            "\terror = alarmtimer_rtc_interface_setup();",
            "\tif (error)",
            "\t\treturn error;",
            "",
            "\terror = platform_driver_register(&alarmtimer_driver);",
            "\tif (error)",
            "\t\tgoto out_if;",
            "",
            "\treturn 0;",
            "out_if:",
            "\talarmtimer_rtc_interface_remove();",
            "\treturn error;",
            "}"
          ],
          "function_name": "alarm_timer_nsleep, get_boottime_timespec, alarmtimer_init",
          "description": "该代码段实现了基于RTC的高精度闹钟定时器功能，包含三个关键部分：  \n1. `alarm_timer_nsleep`负责将用户空间的时间请求转换为内核时间戳并触发闹钟唤醒，支持相对/绝对时间模式，且需具备WAKE_ALARM权限；  \n2. `get_boottime_timespec`用于获取系统启动时间对应的timespec64结构；  \n3. `alarmtimer_init`初始化了多种闹钟基准时间源（如CLOCK_REALTIME/CLOCK_BOOTTIME），并注册平台驱动，但部分辅助函数（如`alarmtimer_do_nsleep`）及数据结构定义缺失，上下文不完整。",
          "similarity": 0.5380276441574097
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/time/alarmtimer.c",
          "start_line": 375,
          "end_line": 475,
          "content": [
            "void alarm_start_relative(struct alarm *alarm, ktime_t start)",
            "{",
            "\tstruct alarm_base *base = &alarm_bases[alarm->type];",
            "",
            "\tstart = ktime_add_safe(start, base->get_ktime());",
            "\talarm_start(alarm, start);",
            "}",
            "void alarm_restart(struct alarm *alarm)",
            "{",
            "\tstruct alarm_base *base = &alarm_bases[alarm->type];",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&base->lock, flags);",
            "\thrtimer_set_expires(&alarm->timer, alarm->node.expires);",
            "\thrtimer_restart(&alarm->timer);",
            "\talarmtimer_enqueue(base, alarm);",
            "\tspin_unlock_irqrestore(&base->lock, flags);",
            "}",
            "int alarm_try_to_cancel(struct alarm *alarm)",
            "{",
            "\tstruct alarm_base *base = &alarm_bases[alarm->type];",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\tspin_lock_irqsave(&base->lock, flags);",
            "\tret = hrtimer_try_to_cancel(&alarm->timer);",
            "\tif (ret >= 0)",
            "\t\talarmtimer_dequeue(base, alarm);",
            "\tspin_unlock_irqrestore(&base->lock, flags);",
            "",
            "\ttrace_alarmtimer_cancel(alarm, base->get_ktime());",
            "\treturn ret;",
            "}",
            "int alarm_cancel(struct alarm *alarm)",
            "{",
            "\tfor (;;) {",
            "\t\tint ret = alarm_try_to_cancel(alarm);",
            "\t\tif (ret >= 0)",
            "\t\t\treturn ret;",
            "\t\thrtimer_cancel_wait_running(&alarm->timer);",
            "\t}",
            "}",
            "u64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)",
            "{",
            "\tu64 overrun = 1;",
            "\tktime_t delta;",
            "",
            "\tdelta = ktime_sub(now, alarm->node.expires);",
            "",
            "\tif (delta < 0)",
            "\t\treturn 0;",
            "",
            "\tif (unlikely(delta >= interval)) {",
            "\t\ts64 incr = ktime_to_ns(interval);",
            "",
            "\t\toverrun = ktime_divns(delta, incr);",
            "",
            "\t\talarm->node.expires = ktime_add_ns(alarm->node.expires,",
            "\t\t\t\t\t\t\tincr*overrun);",
            "",
            "\t\tif (alarm->node.expires > now)",
            "\t\t\treturn overrun;",
            "\t\t/*",
            "\t\t * This (and the ktime_add() below) is the",
            "\t\t * correction for exact:",
            "\t\t */",
            "\t\toverrun++;",
            "\t}",
            "",
            "\talarm->node.expires = ktime_add_safe(alarm->node.expires, interval);",
            "\treturn overrun;",
            "}",
            "static u64 __alarm_forward_now(struct alarm *alarm, ktime_t interval, bool throttle)",
            "{",
            "\tstruct alarm_base *base = &alarm_bases[alarm->type];",
            "\tktime_t now = base->get_ktime();",
            "",
            "\tif (IS_ENABLED(CONFIG_HIGH_RES_TIMERS) && throttle) {",
            "\t\t/*",
            "\t\t * Same issue as with posix_timer_fn(). Timers which are",
            "\t\t * periodic but the signal is ignored can starve the system",
            "\t\t * with a very small interval. The real fix which was",
            "\t\t * promised in the context of posix_timer_fn() never",
            "\t\t * materialized, but someone should really work on it.",
            "\t\t *",
            "\t\t * To prevent DOS fake @now to be 1 jiffie out which keeps",
            "\t\t * the overrun accounting correct but creates an",
            "\t\t * inconsistency vs. timer_gettime(2).",
            "\t\t */",
            "\t\tktime_t kj = NSEC_PER_SEC / HZ;",
            "",
            "\t\tif (interval < kj)",
            "\t\t\tnow = ktime_add(now, kj);",
            "\t}",
            "",
            "\treturn alarm_forward(alarm, now, interval);",
            "}",
            "u64 alarm_forward_now(struct alarm *alarm, ktime_t interval)",
            "{",
            "\treturn __alarm_forward_now(alarm, interval, false);",
            "}"
          ],
          "function_name": "alarm_start_relative, alarm_restart, alarm_try_to_cancel, alarm_cancel, alarm_forward, __alarm_forward_now, alarm_forward_now",
          "description": "实现相对时间启动、重新启动、取消报警计时器的功能，包含时间偏移计算、定时器重排及过期时间调整。通过alarm_forward系列函数处理周期性定时器的精确控制。",
          "similarity": 0.5238626599311829
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/time/alarmtimer.c",
          "start_line": 506,
          "end_line": 613,
          "content": [
            "static void alarmtimer_freezerset(ktime_t absexp, enum alarmtimer_type type)",
            "{",
            "\tstruct alarm_base *base;",
            "\tunsigned long flags;",
            "\tktime_t delta;",
            "",
            "\tswitch(type) {",
            "\tcase ALARM_REALTIME:",
            "\t\tbase = &alarm_bases[ALARM_REALTIME];",
            "\t\ttype = ALARM_REALTIME_FREEZER;",
            "\t\tbreak;",
            "\tcase ALARM_BOOTTIME:",
            "\t\tbase = &alarm_bases[ALARM_BOOTTIME];",
            "\t\ttype = ALARM_BOOTTIME_FREEZER;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tWARN_ONCE(1, \"Invalid alarm type: %d\\n\", type);",
            "\t\treturn;",
            "\t}",
            "",
            "\tdelta = ktime_sub(absexp, base->get_ktime());",
            "",
            "\tspin_lock_irqsave(&freezer_delta_lock, flags);",
            "\tif (!freezer_delta || (delta < freezer_delta)) {",
            "\t\tfreezer_delta = delta;",
            "\t\tfreezer_expires = absexp;",
            "\t\tfreezer_alarmtype = type;",
            "\t}",
            "\tspin_unlock_irqrestore(&freezer_delta_lock, flags);",
            "}",
            "static enum alarmtimer_type clock2alarm(clockid_t clockid)",
            "{",
            "\tif (clockid == CLOCK_REALTIME_ALARM)",
            "\t\treturn ALARM_REALTIME;",
            "\tif (clockid == CLOCK_BOOTTIME_ALARM)",
            "\t\treturn ALARM_BOOTTIME;",
            "\treturn -1;",
            "}",
            "static enum alarmtimer_restart alarm_handle_timer(struct alarm *alarm,",
            "\t\t\t\t\t\t\tktime_t now)",
            "{",
            "\tstruct k_itimer *ptr = container_of(alarm, struct k_itimer,",
            "\t\t\t\t\t    it.alarm.alarmtimer);",
            "\tenum alarmtimer_restart result = ALARMTIMER_NORESTART;",
            "\tunsigned long flags;",
            "\tint si_private = 0;",
            "",
            "\tspin_lock_irqsave(&ptr->it_lock, flags);",
            "",
            "\tptr->it_active = 0;",
            "\tif (ptr->it_interval)",
            "\t\tsi_private = ++ptr->it_requeue_pending;",
            "",
            "\tif (posix_timer_event(ptr, si_private) && ptr->it_interval) {",
            "\t\t/*",
            "\t\t * Handle ignored signals and rearm the timer. This will go",
            "\t\t * away once we handle ignored signals proper. Ensure that",
            "\t\t * small intervals cannot starve the system.",
            "\t\t */",
            "\t\tptr->it_overrun += __alarm_forward_now(alarm, ptr->it_interval, true);",
            "\t\t++ptr->it_requeue_pending;",
            "\t\tptr->it_active = 1;",
            "\t\tresult = ALARMTIMER_RESTART;",
            "\t}",
            "\tspin_unlock_irqrestore(&ptr->it_lock, flags);",
            "",
            "\treturn result;",
            "}",
            "static void alarm_timer_rearm(struct k_itimer *timr)",
            "{",
            "\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;",
            "",
            "\ttimr->it_overrun += alarm_forward_now(alarm, timr->it_interval);",
            "\talarm_start(alarm, alarm->node.expires);",
            "}",
            "static s64 alarm_timer_forward(struct k_itimer *timr, ktime_t now)",
            "{",
            "\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;",
            "",
            "\treturn alarm_forward(alarm, timr->it_interval, now);",
            "}",
            "static ktime_t alarm_timer_remaining(struct k_itimer *timr, ktime_t now)",
            "{",
            "\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;",
            "",
            "\treturn ktime_sub(alarm->node.expires, now);",
            "}",
            "static int alarm_timer_try_to_cancel(struct k_itimer *timr)",
            "{",
            "\treturn alarm_try_to_cancel(&timr->it.alarm.alarmtimer);",
            "}",
            "static void alarm_timer_wait_running(struct k_itimer *timr)",
            "{",
            "\thrtimer_cancel_wait_running(&timr->it.alarm.alarmtimer.timer);",
            "}",
            "static void alarm_timer_arm(struct k_itimer *timr, ktime_t expires,",
            "\t\t\t    bool absolute, bool sigev_none)",
            "{",
            "\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;",
            "\tstruct alarm_base *base = &alarm_bases[alarm->type];",
            "",
            "\tif (!absolute)",
            "\t\texpires = ktime_add_safe(expires, base->get_ktime());",
            "\tif (sigev_none)",
            "\t\talarm->node.expires = expires;",
            "\telse",
            "\t\talarm_start(&timr->it.alarm.alarmtimer, expires);",
            "}"
          ],
          "function_name": "alarmtimer_freezerset, clock2alarm, alarm_handle_timer, alarm_timer_rearm, alarm_timer_forward, alarm_timer_remaining, alarm_timer_try_to_cancel, alarm_timer_wait_running, alarm_timer_arm",
          "description": "处理冷冻状态下的报警计时器管理，实现系统时间到报警类型的转换，处理POSIX定时器信号事件，包含定时器重排、时间推进、剩余时间查询及安全取消等核心逻辑。",
          "similarity": 0.5096704959869385
        }
      ]
    },
    {
      "source_file": "kernel/time/itimer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:39:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\itimer.c`\n\n---\n\n# `time/itimer.c` 技术文档\n\n## 1. 文件概述\n\n`time/itimer.c` 是 Linux 内核中实现 POSIX 间隔定时器（interval timers，简称 itimers）的核心文件。该文件提供了对三种经典 Unix 间隔定时器的支持：\n\n- **ITIMER_REAL**：基于真实时间（墙上时钟）的定时器，到期时发送 `SIGALRM` 信号\n- **ITIMER_VIRTUAL**：基于进程用户态 CPU 时间的定时器，到期时发送 `SIGVTALRM` 信号\n- **ITIMER_PROF**：基于进程总 CPU 时间（用户态+内核态）的定时器，到期时发送 `SIGPROF` 信号\n\n该文件实现了 `getitimer()`、`setitimer()` 系统调用以及 `alarm()` 系统调用（在架构支持的情况下），为用户空间程序提供间隔定时器功能。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`itimer_get_remtime()`**：获取高精度实时定时器的剩余时间\n- **`get_cpu_itimer()`**：获取 CPU 时间相关的定时器（虚拟/性能）状态\n- **`do_getitimer()`**：内部实现获取指定类型定时器状态的逻辑\n- **`put_itimerval()`**：将内核内部的 `itimerspec64` 格式转换为用户空间的 `old_itimerval` 格式\n- **`getitimer()` 系统调用**：用户空间获取定时器状态的入口\n- **`it_real_fn()`**：ITIMER_REAL 定时器到期时的回调函数\n- **`set_cpu_itimer()`**：设置 CPU 时间相关的定时器\n- **`do_setitimer()`**：内部实现设置指定类型定时器的逻辑\n- **`clear_itimer()`**：在 SELinux 环境下清除所有定时器（安全相关）\n- **`alarm_setitimer()`**：实现 `alarm()` 系统调用的内部函数\n- **`alarm()` 系统调用**：设置单次实时定时器的简化接口\n\n### 数据结构\n\n- **`struct cpu_itimer`**：存储 CPU 时间定时器的状态（在 `signal_struct` 中）\n- **`struct hrtimer`**：高精度定时器，用于实现 ITIMER_REAL\n- **`struct itimerspec64`**：64 位时间规格结构，内核内部使用\n- **`struct __kernel_old_itimerval`**：用户空间兼容的定时器值结构\n\n## 3. 关键实现\n\n### 定时器类型实现差异\n\n- **ITIMER_REAL**：使用高精度定时器（`hrtimer`）实现，基于真实时间，通过 `hrtimer_start()` 启动，到期时调用 `it_real_fn()` 发送 `SIGALRM` 信号\n- **ITIMER_VIRTUAL/ITIMER_PROF**：基于 CPU 时间采样实现，通过 `thread_group_sample_cputime()` 获取当前进程组的 CPU 时间，与设定的过期时间比较来判断是否到期\n\n### 时间精度处理\n\n- 使用纳秒级精度的 `ktime_t` 和 `timespec64` 进行内部计算\n- 用户空间接口使用微秒精度（`tv_usec`），通过 `NSEC_PER_USEC` 进行单位转换\n- 对于即将到期的定时器，返回 `TICK_NSEC`（1 微秒）作为剩余时间，避免返回 0 导致用户误判\n\n### 并发安全\n\n- 使用 `siglock` 自旋锁保护信号结构体中的定时器状态\n- ITIMER_REAL 的设置操作需要处理定时器可能正在执行的竞态条件，通过 `hrtimer_try_to_cancel()` 和重试机制确保安全\n- CPU 定时器操作在 `siglock` 保护下进行，确保线程组内的一致性\n\n### 兼容性支持\n\n- 提供 32 位兼容接口（`COMPAT_SYSCALL_DEFINE2`）\n- 支持 `alarm()` 系统调用（在 `__ARCH_WANT_SYS_ALARM` 定义时）\n- 处理 32 位系统上的时间值溢出问题（限制为 `INT_MAX`）\n\n## 4. 依赖关系\n\n### 头文件依赖\n\n- **`<linux/hrtimer.h>`**：高精度定时器框架，用于 ITIMER_REAL 实现\n- **`<linux/sched/cputime.h>`**：CPU 时间采样功能，用于虚拟和性能定时器\n- **`<linux/posix-timers.h>`**：POSIX 定时器相关定义\n- **`<linux/sched/signal.h>`**：信号处理和 `signal_struct` 结构定义\n- **`<linux/time.h>`**：时间转换和操作函数\n- **`<trace/events/timer.h>`**：定时器事件跟踪支持\n\n### 内核子系统依赖\n\n- **调度子系统**：通过 `current` 获取当前任务，使用 `thread_group_sample_cputime()` 采样 CPU 时间\n- **信号子系统**：通过 `kill_pid_info()` 发送信号，使用 `siglock` 进行同步\n- **高精度定时器子系统**：ITIMER_REAL 的底层实现依赖 hrtimer 框架\n- **安全子系统**：SELinux 相关的 `clear_itimer()` 函数\n\n## 5. 使用场景\n\n### 用户空间编程\n\n- **定时任务**：应用程序使用 `setitimer()` 设置周期性或一次性定时器\n- **超时控制**：网络编程中设置 I/O 操作超时\n- **性能监控**：使用 ITIMER_PROF 监控程序 CPU 使用情况\n- **简单定时**：使用 `alarm()` 系统调用设置简单的秒级定时器\n\n### 内核内部使用\n\n- **进程管理**：在进程退出或权限变更时清除定时器（SELinux 场景）\n- **信号处理**：定时器到期时向进程发送相应信号\n- **时间跟踪**：通过 tracepoint 记录定时器状态变化和到期事件\n- **兼容层**：为不同架构和位数提供统一的定时器接口\n\n### 系统调用路径\n\n- **`getitimer()`** → `do_getitimer()` → 对应定时器类型的具体获取函数\n- **`setitimer()`** → `do_setitimer()` → 对应定时器类型的具体设置函数  \n- **`alarm()`** → `alarm_setitimer()` → `do_setitimer(ITIMER_REAL, ...)`\n\n该文件是 Linux 内核 POSIX 定时器功能的重要组成部分，为用户空间提供了经典的 Unix 间隔定时器接口。",
      "similarity": 0.5581051111221313,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/time/itimer.c",
          "start_line": 168,
          "end_line": 275,
          "content": [
            "static void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,",
            "\t\t\t   const struct itimerspec64 *const value,",
            "\t\t\t   struct itimerspec64 *const ovalue)",
            "{",
            "\tu64 oval, nval, ointerval, ninterval;",
            "\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];",
            "",
            "\tnval = timespec64_to_ns(&value->it_value);",
            "\tninterval = timespec64_to_ns(&value->it_interval);",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "",
            "\toval = it->expires;",
            "\tointerval = it->incr;",
            "\tif (oval || nval) {",
            "\t\tif (nval > 0)",
            "\t\t\tnval += TICK_NSEC;",
            "\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);",
            "\t}",
            "\tit->expires = nval;",
            "\tit->incr = ninterval;",
            "\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?",
            "\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);",
            "",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\tif (ovalue) {",
            "\t\tovalue->it_value = ns_to_timespec64(oval);",
            "\t\tovalue->it_interval = ns_to_timespec64(ointerval);",
            "\t}",
            "}",
            "static int do_setitimer(int which, struct itimerspec64 *value,",
            "\t\t\tstruct itimerspec64 *ovalue)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tstruct hrtimer *timer;",
            "\tktime_t expires;",
            "",
            "\tswitch (which) {",
            "\tcase ITIMER_REAL:",
            "again:",
            "\t\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t\ttimer = &tsk->signal->real_timer;",
            "\t\tif (ovalue) {",
            "\t\t\tovalue->it_value = itimer_get_remtime(timer);",
            "\t\t\tovalue->it_interval",
            "\t\t\t\t= ktime_to_timespec64(tsk->signal->it_real_incr);",
            "\t\t}",
            "\t\t/* We are sharing ->siglock with it_real_fn() */",
            "\t\tif (hrtimer_try_to_cancel(timer) < 0) {",
            "\t\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\t\thrtimer_cancel_wait_running(timer);",
            "\t\t\tgoto again;",
            "\t\t}",
            "\t\texpires = timespec64_to_ktime(value->it_value);",
            "\t\tif (expires != 0) {",
            "\t\t\ttsk->signal->it_real_incr =",
            "\t\t\t\ttimespec64_to_ktime(value->it_interval);",
            "\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);",
            "\t\t} else",
            "\t\t\ttsk->signal->it_real_incr = 0;",
            "",
            "\t\ttrace_itimer_state(ITIMER_REAL, value, 0);",
            "\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\tbreak;",
            "\tcase ITIMER_VIRTUAL:",
            "\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);",
            "\t\tbreak;",
            "\tcase ITIMER_PROF:",
            "\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}",
            "void clear_itimer(void)",
            "{",
            "\tstruct itimerspec64 v = {};",
            "\tint i;",
            "",
            "\tfor (i = 0; i < 3; i++)",
            "\t\tdo_setitimer(i, &v, NULL);",
            "}",
            "static unsigned int alarm_setitimer(unsigned int seconds)",
            "{",
            "\tstruct itimerspec64 it_new, it_old;",
            "",
            "#if BITS_PER_LONG < 64",
            "\tif (seconds > INT_MAX)",
            "\t\tseconds = INT_MAX;",
            "#endif",
            "\tit_new.it_value.tv_sec = seconds;",
            "\tit_new.it_value.tv_nsec = 0;",
            "\tit_new.it_interval.tv_sec = it_new.it_interval.tv_nsec = 0;",
            "",
            "\tdo_setitimer(ITIMER_REAL, &it_new, &it_old);",
            "",
            "\t/*",
            "\t * We can't return 0 if we have an alarm pending ...  And we'd",
            "\t * better return too much than too little anyway",
            "\t */",
            "\tif ((!it_old.it_value.tv_sec && it_old.it_value.tv_nsec) ||",
            "\t      it_old.it_value.tv_nsec >= (NSEC_PER_SEC / 2))",
            "\t\tit_old.it_value.tv_sec++;",
            "",
            "\treturn it_old.it_value.tv_sec;",
            "}"
          ],
          "function_name": "set_cpu_itimer, do_setitimer, clear_itimer, alarm_setitimer",
          "description": "包含set_cpu_itimer设置CPU定时器参数、do_setitimer根据时钟类型配置定时器、clear_itimer清除所有定时器、alarm_setitimer设置一次性闹钟，其中do_setitimer处理实时时钟的启动和取消操作",
          "similarity": 0.5462613105773926
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/time/itimer.c",
          "start_line": 313,
          "end_line": 348,
          "content": [
            "static int get_itimerval(struct itimerspec64 *o, const struct __kernel_old_itimerval __user *i)",
            "{",
            "\tstruct __kernel_old_itimerval v;",
            "",
            "\tif (copy_from_user(&v, i, sizeof(struct __kernel_old_itimerval)))",
            "\t\treturn -EFAULT;",
            "",
            "\t/* Validate the timevals in value. */",
            "\tif (!timeval_valid(&v.it_value) ||",
            "\t    !timeval_valid(&v.it_interval))",
            "\t\treturn -EINVAL;",
            "",
            "\to->it_interval.tv_sec = v.it_interval.tv_sec;",
            "\to->it_interval.tv_nsec = v.it_interval.tv_usec * NSEC_PER_USEC;",
            "\to->it_value.tv_sec = v.it_value.tv_sec;",
            "\to->it_value.tv_nsec = v.it_value.tv_usec * NSEC_PER_USEC;",
            "\treturn 0;",
            "}",
            "static int get_old_itimerval32(struct itimerspec64 *o, const struct old_itimerval32 __user *i)",
            "{",
            "\tstruct old_itimerval32 v32;",
            "",
            "\tif (copy_from_user(&v32, i, sizeof(struct old_itimerval32)))",
            "\t\treturn -EFAULT;",
            "",
            "\t/* Validate the timevals in value.  */",
            "\tif (!timeval_valid(&v32.it_value) ||",
            "\t    !timeval_valid(&v32.it_interval))",
            "\t\treturn -EINVAL;",
            "",
            "\to->it_interval.tv_sec = v32.it_interval.tv_sec;",
            "\to->it_interval.tv_nsec = v32.it_interval.tv_usec * NSEC_PER_USEC;",
            "\to->it_value.tv_sec = v32.it_value.tv_sec;",
            "\to->it_value.tv_nsec = v32.it_value.tv_usec * NSEC_PER_USEC;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_itimerval, get_old_itimerval32",
          "description": "实现get_itimerval/get_old_itimerval32将用户态时间值转换为内核时间结构体，执行有效性校验，确保输入时间值在合法范围内",
          "similarity": 0.5385067462921143
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/itimer.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992 Darren Senn",
            " */",
            "",
            "/* These are all the functions necessary to implement itimers */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/time.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/hrtimer.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/compat.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "/**",
            " * itimer_get_remtime - get remaining time for the timer",
            " *",
            " * @timer: the timer to read",
            " *",
            " * Returns the delta between the expiry time and now, which can be",
            " * less than zero or 1usec for an pending expired timer",
            " */"
          ],
          "function_name": null,
          "description": "该代码块定义了itimer_get_remtime函数的原型，用于获取高精度定时器的剩余时间，通过计算当前时间与定时器到期时间的差值得到剩余时间，但未提供完整实现，上下文不完整",
          "similarity": 0.5304408073425293
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/itimer.c",
          "start_line": 29,
          "end_line": 129,
          "content": [
            "static struct timespec64 itimer_get_remtime(struct hrtimer *timer)",
            "{",
            "\tktime_t rem = __hrtimer_get_remaining(timer, true);",
            "",
            "\t/*",
            "\t * Racy but safe: if the itimer expires after the above",
            "\t * hrtimer_get_remtime() call but before this condition",
            "\t * then we return 0 - which is correct.",
            "\t */",
            "\tif (hrtimer_active(timer)) {",
            "\t\tif (rem <= 0)",
            "\t\t\trem = NSEC_PER_USEC;",
            "\t} else",
            "\t\trem = 0;",
            "",
            "\treturn ktime_to_timespec64(rem);",
            "}",
            "static void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,",
            "\t\t\t   struct itimerspec64 *const value)",
            "{",
            "\tu64 val, interval;",
            "\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "",
            "\tval = it->expires;",
            "\tinterval = it->incr;",
            "\tif (val) {",
            "\t\tu64 t, samples[CPUCLOCK_MAX];",
            "",
            "\t\tthread_group_sample_cputime(tsk, samples);",
            "\t\tt = samples[clock_id];",
            "",
            "\t\tif (val < t)",
            "\t\t\t/* about to fire */",
            "\t\t\tval = TICK_NSEC;",
            "\t\telse",
            "\t\t\tval -= t;",
            "\t}",
            "",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\tvalue->it_value = ns_to_timespec64(val);",
            "\tvalue->it_interval = ns_to_timespec64(interval);",
            "}",
            "static int do_getitimer(int which, struct itimerspec64 *value)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "",
            "\tswitch (which) {",
            "\tcase ITIMER_REAL:",
            "\t\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t\tvalue->it_value = itimer_get_remtime(&tsk->signal->real_timer);",
            "\t\tvalue->it_interval =",
            "\t\t\tktime_to_timespec64(tsk->signal->it_real_incr);",
            "\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\tbreak;",
            "\tcase ITIMER_VIRTUAL:",
            "\t\tget_cpu_itimer(tsk, CPUCLOCK_VIRT, value);",
            "\t\tbreak;",
            "\tcase ITIMER_PROF:",
            "\t\tget_cpu_itimer(tsk, CPUCLOCK_PROF, value);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn(-EINVAL);",
            "\t}",
            "\treturn 0;",
            "}",
            "static int put_itimerval(struct __kernel_old_itimerval __user *o,",
            "\t\t\t const struct itimerspec64 *i)",
            "{",
            "\tstruct __kernel_old_itimerval v;",
            "",
            "\tv.it_interval.tv_sec = i->it_interval.tv_sec;",
            "\tv.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;",
            "\tv.it_value.tv_sec = i->it_value.tv_sec;",
            "\tv.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;",
            "\treturn copy_to_user(o, &v, sizeof(struct __kernel_old_itimerval)) ? -EFAULT : 0;",
            "}",
            "static int put_old_itimerval32(struct old_itimerval32 __user *o,",
            "\t\t\t       const struct itimerspec64 *i)",
            "{",
            "\tstruct old_itimerval32 v32;",
            "",
            "\tv32.it_interval.tv_sec = i->it_interval.tv_sec;",
            "\tv32.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;",
            "\tv32.it_value.tv_sec = i->it_value.tv_sec;",
            "\tv32.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;",
            "\treturn copy_to_user(o, &v32, sizeof(struct old_itimerval32)) ? -EFAULT : 0;",
            "}",
            "enum hrtimer_restart it_real_fn(struct hrtimer *timer)",
            "{",
            "\tstruct signal_struct *sig =",
            "\t\tcontainer_of(timer, struct signal_struct, real_timer);",
            "\tstruct pid *leader_pid = sig->pids[PIDTYPE_TGID];",
            "",
            "\ttrace_itimer_expire(ITIMER_REAL, leader_pid, 0);",
            "\tkill_pid_info(SIGALRM, SEND_SIG_PRIV, leader_pid);",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}"
          ],
          "function_name": "itimer_get_remtime, get_cpu_itimer, do_getitimer, put_itimerval, put_old_itimerval32, it_real_fn",
          "description": "实现了itimer_get_remtime获取剩余时间、get_cpu_itimer读取CPU定时器信息、do_getitimer根据时钟类型获取定时器状态、put_itimerval/put_old_itimerval32转换并复制时间值到用户空间，以及it_real_fn作为实时时钟的超时处理函数",
          "similarity": 0.5289062261581421
        }
      ]
    },
    {
      "source_file": "kernel/time/tick-broadcast-hrtimer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:47:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\tick-broadcast-hrtimer.c`\n\n---\n\n# `time/tick-broadcast-hrtimer.c` 技术文档\n\n## 1. 文件概述\n\n该文件实现了基于高分辨率定时器（hrtimer）的广播时钟事件设备（tick broadcast device）模拟机制。在某些系统（如无本地 APIC 或本地时钟事件设备不支持唤醒 CPU 的平台）中，当 CPU 进入深度空闲状态时，无法接收本地定时器中断，此时需要一个全局的“广播”定时器来代替本地时钟事件设备，在需要时唤醒所有等待广播事件的 CPU。本文件通过一个全局的 hrtimer 实例，模拟出一个虚拟的广播时钟事件设备，用于在单 CPU 或多 CPU 系统中提供统一的广播定时服务。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`bctimer`**：全局静态的 `hrtimer` 实例，作为广播定时器的核心实现。\n- **`ce_broadcast_hrtimer`**：`clock_event_device` 类型的结构体，代表一个虚拟的广播时钟事件设备，注册到内核时钟事件子系统中。\n\n### 主要函数\n\n- **`bc_shutdown()`**：实现广播设备的关闭操作，调用 `hrtimer_try_to_cancel()` 尝试取消定时器，避免死锁。\n- **`bc_set_next()`**：设置下一次广播事件的到期时间，调用 `hrtimer_start()` 启动高分辨率定时器，并更新设备绑定的 CPU（`bound_on` 字段）。\n- **`bc_handler()`**：hrtimer 到期时的回调函数，触发广播设备的事件处理函数（`event_handler`），进而调用通用的广播处理逻辑（如 `tick_handle_oneshot_broadcast()`）。\n- **`tick_setup_hrtimer_broadcast()`**：初始化广播 hrtimer 并注册虚拟时钟事件设备到内核。\n\n## 3. 关键实现\n\n- **避免死锁的设计**：  \n  在 `bc_shutdown()` 和 `bc_set_next()` 中，均避免直接调用 `hrtimer_cancel()`，因为该函数可能等待回调执行完毕，而回调函数（`bc_handler`）内部会尝试获取 `tick_broadcast_lock`，若调用者已持有该锁，则会导致死锁。因此使用非阻塞的 `hrtimer_try_to_cancel()`。\n\n- **CPU 绑定机制**：  \n  `bc_set_next()` 在启动 hrtimer 时使用 `HRTIMER_MODE_ABS_PINNED_HARD` 模式，确保定时器在当前 CPU 上执行（若回调未运行）。随后通过读取 `bctimer.base->cpu_base->cpu` 设置 `ce_broadcast_hrtimer.bound_on`，告知 tick 广播子系统该广播定时器当前绑定在哪个 CPU 上，防止该 CPU 进入无法被唤醒的深度空闲状态。\n\n- **线程安全性**：  \n  所有对 `bctimer` 的操作（如 `hrtimer_start` 和 `hrtimer_try_to_cancel`）均在持有 `tick_broadcast_lock` 的上下文中执行，保证了对广播设备状态修改的原子性。同时，由于该锁的存在，`bound_on` 的读取无需额外加锁。\n\n- **事件分发**：  \n  hrtimer 到期后，`bc_handler()` 调用 `ce_broadcast_hrtimer.event_handler()`，该回调由 tick 广播子系统在注册设备时设置（通常指向 `tick_handle_oneshot_broadcast`），负责唤醒所有等待广播事件的 CPU 并处理 pending 的 tick。\n\n## 4. 依赖关系\n\n- **`<linux/hrtimer.h>`**：依赖高分辨率定时器子系统，用于实现精确的单次广播事件。\n- **`<linux/clockchips.h>`**：依赖时钟事件设备框架，用于注册虚拟的广播设备。\n- **`\"tick-internal.h\"`**：依赖内核 tick 管理内部接口，特别是广播 tick 相关的锁和处理函数。\n- **`tick-broadcast.c`**：与通用 tick 广播逻辑紧密耦合，本设备作为其后备实现之一，由 `tick_broadcast_setup_hrtimer()` 调用 `tick_setup_hrtimer_broadcast()` 进行初始化。\n\n## 5. 使用场景\n\n- **无本地时钟事件设备的系统**：在某些嵌入式或虚拟化环境中，CPU 可能缺乏支持唤醒的本地定时器，此时必须依赖广播机制维持系统 tick。\n- **深度 C-state 电源管理**：当 CPU 进入 C3 或更深的空闲状态时，本地 APIC 定时器可能被关闭，需由广播设备代替其功能。\n- **单 CPU 系统的简化实现**：在单核系统中，可直接使用此 hrtimer 广播设备作为 tick 源，无需复杂的多 CPU 同步逻辑。\n- **作为通用广播后备方案**：当系统未配置硬件广播设备（如 HPET 或 IO-APIC）时，内核可回退到此基于 hrtimer 的软件实现。",
      "similarity": 0.5400243997573853,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/time/tick-broadcast-hrtimer.c",
          "start_line": 20,
          "end_line": 81,
          "content": [
            "static int bc_shutdown(struct clock_event_device *evt)",
            "{",
            "\t/*",
            "\t * Note, we cannot cancel the timer here as we might",
            "\t * run into the following live lock scenario:",
            "\t *",
            "\t * cpu 0\t\tcpu1",
            "\t * lock(broadcast_lock);",
            "\t *\t\t\thrtimer_interrupt()",
            "\t *\t\t\tbc_handler()",
            "\t *\t\t\t   tick_handle_oneshot_broadcast();",
            "\t *\t\t\t    lock(broadcast_lock);",
            "\t * hrtimer_cancel()",
            "\t *  wait_for_callback()",
            "\t */",
            "\thrtimer_try_to_cancel(&bctimer);",
            "\treturn 0;",
            "}",
            "static int bc_set_next(ktime_t expires, struct clock_event_device *bc)",
            "{",
            "\t/*",
            "\t * This is called either from enter/exit idle code or from the",
            "\t * broadcast handler. In all cases tick_broadcast_lock is held.",
            "\t *",
            "\t * hrtimer_cancel() cannot be called here neither from the",
            "\t * broadcast handler nor from the enter/exit idle code. The idle",
            "\t * code can run into the problem described in bc_shutdown() and the",
            "\t * broadcast handler cannot wait for itself to complete for obvious",
            "\t * reasons.",
            "\t *",
            "\t * Each caller tries to arm the hrtimer on its own CPU, but if the",
            "\t * hrtimer callback function is currently running, then",
            "\t * hrtimer_start() cannot move it and the timer stays on the CPU on",
            "\t * which it is assigned at the moment.",
            "\t */",
            "\thrtimer_start(&bctimer, expires, HRTIMER_MODE_ABS_PINNED_HARD);",
            "\t/*",
            "\t * The core tick broadcast mode expects bc->bound_on to be set",
            "\t * correctly to prevent a CPU which has the broadcast hrtimer",
            "\t * armed from going deep idle.",
            "\t *",
            "\t * As tick_broadcast_lock is held, nothing can change the cpu",
            "\t * base which was just established in hrtimer_start() above. So",
            "\t * the below access is safe even without holding the hrtimer",
            "\t * base lock.",
            "\t */",
            "\tbc->bound_on = bctimer.base->cpu_base->cpu;",
            "",
            "\treturn 0;",
            "}",
            "static enum hrtimer_restart bc_handler(struct hrtimer *t)",
            "{",
            "\tce_broadcast_hrtimer.event_handler(&ce_broadcast_hrtimer);",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}",
            "void tick_setup_hrtimer_broadcast(void)",
            "{",
            "\thrtimer_init(&bctimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD);",
            "\tbctimer.function = bc_handler;",
            "\tclockevents_register_device(&ce_broadcast_hrtimer);",
            "}"
          ],
          "function_name": "bc_shutdown, bc_set_next, bc_handler, tick_setup_hrtimer_broadcast",
          "description": "实现广播定时器控制逻辑，包含关闭定时器防止死锁、设置下次超时时间、处理中断回调及初始化广播定时器设备的函数集合",
          "similarity": 0.5105270147323608
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/tick-broadcast-hrtimer.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Emulate a local clock event device via a pseudo clock device.",
            " */",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/clockchips.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "",
            "#include \"tick-internal.h\"",
            "",
            "static struct hrtimer bctimer;",
            ""
          ],
          "function_name": null,
          "description": "定义用于广播式高精度定时器的全局hrtimer结构体实例，作为伪时钟设备实现基础",
          "similarity": 0.49583563208580017
        }
      ]
    }
  ]
}