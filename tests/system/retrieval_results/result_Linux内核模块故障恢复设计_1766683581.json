{
  "query": "Linux内核模块故障恢复设计",
  "timestamp": "2025-12-26 01:26:21",
  "retrieved_files": [
    {
      "source_file": "mm/memory-failure.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:40:57\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memory-failure.c`\n\n---\n\n# memory-failure.c 技术文档\n\n## 1. 文件概述\n\n`memory-failure.c` 是 Linux 内核中用于处理硬件报告的内存故障（如多比特 ECC 错误）的核心模块。该文件实现了对已损坏物理页的检测、隔离和恢复机制，支持两种主要操作模式：\n- **硬离线（Hard Offline）**：处理已被硬件标记为损坏的页面，通常会导致使用该页的进程被终止\n- **软离线（Soft Offline）**：主动隔离可疑但尚未损坏的页面，避免潜在故障而不杀死进程\n\n该模块需要在不违反虚拟内存子系统正常锁定规则的前提下，异步安全地处理内存错误，确保系统稳定性。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `sysctl_memory_failure_early_kill`：控制是否立即杀死使用损坏页面的进程（0=延迟处理，1=立即杀死）\n- `sysctl_memory_failure_recovery`：启用/禁用内存故障恢复功能（默认启用）\n- `num_poisoned_pages`：原子计数器，记录已标记为有毒（poisoned）的页面数量\n- `hw_memory_failure`：标识是否由硬件直接报告的内存故障\n- `mf_mutex`：保护内存故障处理操作的互斥锁\n\n### 主要函数\n- `num_poisoned_pages_inc()` / `num_poisoned_pages_sub()`：管理有毒页面计数\n- `__page_handle_poison()`：处理大页或空闲页的溶解和从伙伴系统移除\n- `page_handle_poison()`：通用页面毒化处理函数，设置 HWPoison 标志并更新计数\n- `hwpoison_filter_dev()`：基于设备号过滤硬件毒化页面（用于测试）\n- `hwpoison_filter_flags()`：基于页面标志过滤硬件毒化页面（用于测试）\n\n### Sysfs 接口\n通过 `MF_ATTR_RO` 宏定义的只读属性，提供每个 NUMA 节点的内存故障统计信息：\n- `total`：总处理的内存故障数\n- `ignored`：被忽略的故障数\n- `failed`：处理失败的故障数  \n- `delayed`：延迟处理的故障数\n- `recovered`：成功恢复的故障数\n\n## 3. 关键实现\n\n### 页面毒化处理流程\n1. **页面状态识别**：区分大页（hugepage）、空闲页（freepage）和其他类型页面\n2. **大页处理**：调用 `dissolve_free_huge_page()` 溶解大页，然后通过 `drain_all_pages()` 和 `take_page_off_buddy()` 确保页面从伙伴系统移除\n3. **标志设置**：使用 `SetPageHWPoison()` 标记页面为硬件毒化状态\n4. **引用计数管理**：增加页面引用计数并更新全局有毒页面计数器\n\n### 锁定策略\n- 避免使用 `zone_pcp_disable()` 以防止与 CPU 热插拔锁产生死锁\n- 采用标准 VM 锁定规则，即使这意味着错误处理可能耗时较长\n- 使用 `mf_mutex` 保护关键的内存故障处理路径\n\n### 复杂度考量\n- 由于 VM 数据结构的限制，某些操作（如通过 RMAP 反向映射查找进程）具有非线性时间复杂度\n- 基于内存故障的稀有性，接受这种性能开销以避免影响核心 VM 性能\n\n### 开发约束\n新增处理逻辑必须满足：\n- 具备可测试性\n- 能够集成到 mce-test 测试套件\n- 在真实工作负载中属于常见页面状态（page-types 工具 top 10）\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n- **内存管理**：`<linux/mm.h>`, `<linux/page-flags.h>`, `<linux/pagemap.h>`, `<linux/swap.h>`\n- **进程管理**：`<linux/sched/signal.h>`, `<linux/sched/task.h>`\n- **特殊内存类型**：`<linux/hugetlb.h>`, `<linux/dax.h>`, `<linux/ksm.h>`, `<linux/shmem_fs.h>`\n- **系统架构**：`<linux/ras/ras_event.h>`, `<linux/memremap.h>`\n- **内核内部**：`\"swap.h\"`, `\"internal.h\"`\n\n### 功能依赖\n- **RAS（Reliability, Availability, Serviceability）**：通过 ras_event 提供事件通知\n- **内存热插拔**：`memblk_nr_poison_inc/sub` 用于内存块级统计\n- **cgroup 内存控制**：CONFIG_MEMCG 支持基于 memcg 的故障页面过滤\n- **硬件毒化注入**：CONFIG_HWPOISON_INJECT 提供测试框架\n\n## 5. 使用场景\n\n### 硬件内存故障处理\n- 当硬件检测到多比特 ECC 内存错误时，通过 Machine Check Exception (MCE) 机制调用此模块\n- 自动隔离损坏页面，防止数据损坏扩散\n\n### 主动内存维护\n- 系统管理员可通过 `/sys` 接口触发软离线操作，主动替换可疑内存页\n- 用于内存压力测试和预防性维护\n\n### 故障注入测试\n- 通过 `hwpoison_inject` 模块模拟硬件内存故障\n- 支持基于设备号、页面标志和 memcg 的精细过滤，用于针对性测试\n\n### 系统监控和诊断\n- 通过 sysfs 接口提供详细的内存故障统计信息\n- 便于系统管理员监控内存健康状况和故障恢复效果\n\n### 企业级可靠性保障\n- 在高可用服务器环境中，确保单个内存故障不会导致整个系统崩溃\n- 通过可配置的策略（early_kill, recovery）平衡服务连续性和数据完整性",
      "similarity": 0.6512289047241211,
      "chunks": [
        {
          "chunk_id": 8,
          "file_path": "mm/memory-failure.c",
          "start_line": 1288,
          "end_line": 1404,
          "content": [
            "static void update_per_node_mf_stats(unsigned long pfn,",
            "\t\t\t\t     enum mf_result result)",
            "{",
            "\tint nid = MAX_NUMNODES;",
            "\tstruct memory_failure_stats *mf_stats = NULL;",
            "",
            "\tnid = pfn_to_nid(pfn);",
            "\tif (unlikely(nid < 0 || nid >= MAX_NUMNODES)) {",
            "\t\tWARN_ONCE(1, \"Memory failure: pfn=%#lx, invalid nid=%d\", pfn, nid);",
            "\t\treturn;",
            "\t}",
            "",
            "\tmf_stats = &NODE_DATA(nid)->mf_stats;",
            "\tswitch (result) {",
            "\tcase MF_IGNORED:",
            "\t\t++mf_stats->ignored;",
            "\t\tbreak;",
            "\tcase MF_FAILED:",
            "\t\t++mf_stats->failed;",
            "\t\tbreak;",
            "\tcase MF_DELAYED:",
            "\t\t++mf_stats->delayed;",
            "\t\tbreak;",
            "\tcase MF_RECOVERED:",
            "\t\t++mf_stats->recovered;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tWARN_ONCE(1, \"Memory failure: mf_result=%d is not properly handled\", result);",
            "\t\tbreak;",
            "\t}",
            "\t++mf_stats->total;",
            "}",
            "static int action_result(unsigned long pfn, enum mf_action_page_type type,",
            "\t\t\t enum mf_result result)",
            "{",
            "\ttrace_memory_failure_event(pfn, type, result);",
            "",
            "\tnum_poisoned_pages_inc(pfn);",
            "",
            "\tupdate_per_node_mf_stats(pfn, result);",
            "",
            "\tpr_err(\"%#lx: recovery action for %s: %s\\n\",",
            "\t\tpfn, action_page_types[type], action_name[result]);",
            "",
            "\treturn (result == MF_RECOVERED || result == MF_DELAYED) ? 0 : -EBUSY;",
            "}",
            "static int page_action(struct page_state *ps, struct page *p,",
            "\t\t\tunsigned long pfn)",
            "{",
            "\tint result;",
            "",
            "\t/* page p should be unlocked after returning from ps->action().  */",
            "\tresult = ps->action(ps, p);",
            "",
            "\t/* Could do more checks here if page looks ok */",
            "\t/*",
            "\t * Could adjust zone counters here to correct for the missing page.",
            "\t */",
            "",
            "\treturn action_result(pfn, ps->type, result);",
            "}",
            "static inline bool PageHWPoisonTakenOff(struct page *page)",
            "{",
            "\treturn PageHWPoison(page) && page_private(page) == MAGIC_HWPOISON;",
            "}",
            "void SetPageHWPoisonTakenOff(struct page *page)",
            "{",
            "\tset_page_private(page, MAGIC_HWPOISON);",
            "}",
            "void ClearPageHWPoisonTakenOff(struct page *page)",
            "{",
            "\tif (PageHWPoison(page))",
            "\t\tset_page_private(page, 0);",
            "}",
            "static inline bool HWPoisonHandlable(struct page *page, unsigned long flags)",
            "{",
            "\t/* Soft offline could migrate non-LRU movable pages */",
            "\tif ((flags & MF_SOFT_OFFLINE) && __PageMovable(page))",
            "\t\treturn true;",
            "",
            "\treturn PageLRU(page) || is_free_buddy_page(page);",
            "}",
            "static int __get_hwpoison_page(struct page *page, unsigned long flags)",
            "{",
            "\tstruct folio *folio = page_folio(page);",
            "\tint ret = 0;",
            "\tbool hugetlb = false;",
            "",
            "\tret = get_hwpoison_hugetlb_folio(folio, &hugetlb, false);",
            "\tif (hugetlb) {",
            "\t\t/* Make sure hugetlb demotion did not happen from under us. */",
            "\t\tif (folio == page_folio(page))",
            "\t\t\treturn ret;",
            "\t\tif (ret > 0) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\tfolio = page_folio(page);",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * This check prevents from calling folio_try_get() for any",
            "\t * unsupported type of folio in order to reduce the risk of unexpected",
            "\t * races caused by taking a folio refcount.",
            "\t */",
            "\tif (!HWPoisonHandlable(&folio->page, flags))",
            "\t\treturn -EBUSY;",
            "",
            "\tif (folio_try_get(folio)) {",
            "\t\tif (folio == page_folio(page))",
            "\t\t\treturn 1;",
            "",
            "\t\tpr_info(\"%#lx cannot catch tail\\n\", page_to_pfn(page));",
            "\t\tfolio_put(folio);",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "update_per_node_mf_stats, action_result, page_action, PageHWPoisonTakenOff, SetPageHWPoisonTakenOff, ClearPageHWPoisonTakenOff, HWPoisonHandlable, __get_hwpoison_page",
          "description": "维护内存故障统计信息并处理页面操作结果，包含状态转换控制与硬件中毒标记管理",
          "similarity": 0.6180030703544617
        },
        {
          "chunk_id": 6,
          "file_path": "mm/memory-failure.c",
          "start_line": 919,
          "end_line": 1050,
          "content": [
            "static int delete_from_lru_cache(struct page *p)",
            "{",
            "\tif (isolate_lru_page(p)) {",
            "\t\t/*",
            "\t\t * Clear sensible page flags, so that the buddy system won't",
            "\t\t * complain when the page is unpoison-and-freed.",
            "\t\t */",
            "\t\tClearPageActive(p);",
            "\t\tClearPageUnevictable(p);",
            "",
            "\t\t/*",
            "\t\t * Poisoned page might never drop its ref count to 0 so we have",
            "\t\t * to uncharge it manually from its memcg.",
            "\t\t */",
            "\t\tmem_cgroup_uncharge(page_folio(p));",
            "",
            "\t\t/*",
            "\t\t * drop the page count elevated by isolate_lru_page()",
            "\t\t */",
            "\t\tput_page(p);",
            "\t\treturn 0;",
            "\t}",
            "\treturn -EIO;",
            "}",
            "static int truncate_error_page(struct page *p, unsigned long pfn,",
            "\t\t\t\tstruct address_space *mapping)",
            "{",
            "\tstruct folio *folio = page_folio(p);",
            "\tint ret = MF_FAILED;",
            "",
            "\tif (mapping->a_ops->error_remove_page) {",
            "\t\tint err = mapping->a_ops->error_remove_page(mapping, p);",
            "",
            "\t\tif (err != 0)",
            "\t\t\tpr_info(\"%#lx: Failed to punch page: %d\\n\", pfn, err);",
            "\t\telse if (!filemap_release_folio(folio, GFP_NOIO))",
            "\t\t\tpr_info(\"%#lx: failed to release buffers\\n\", pfn);",
            "\t\telse",
            "\t\t\tret = MF_RECOVERED;",
            "\t} else {",
            "\t\t/*",
            "\t\t * If the file system doesn't support it just invalidate",
            "\t\t * This fails on dirty or anything with private pages",
            "\t\t */",
            "\t\tif (mapping_evict_folio(mapping, folio))",
            "\t\t\tret = MF_RECOVERED;",
            "\t\telse",
            "\t\t\tpr_info(\"%#lx: Failed to invalidate\\n\",\tpfn);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static bool has_extra_refcount(struct page_state *ps, struct page *p,",
            "\t\t\t       bool extra_pins)",
            "{",
            "\tint count = page_count(p) - 1;",
            "",
            "\tif (extra_pins)",
            "\t\tcount -= folio_nr_pages(page_folio(p));",
            "",
            "\tif (count > 0) {",
            "\t\tpr_err(\"%#lx: %s still referenced by %d users\\n\",",
            "\t\t       page_to_pfn(p), action_page_types[ps->type], count);",
            "\t\treturn true;",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static int me_kernel(struct page_state *ps, struct page *p)",
            "{",
            "\tunlock_page(p);",
            "\treturn MF_IGNORED;",
            "}",
            "static int me_unknown(struct page_state *ps, struct page *p)",
            "{",
            "\tpr_err(\"%#lx: Unknown page state\\n\", page_to_pfn(p));",
            "\tunlock_page(p);",
            "\treturn MF_FAILED;",
            "}",
            "static int me_pagecache_clean(struct page_state *ps, struct page *p)",
            "{",
            "\tint ret;",
            "\tstruct address_space *mapping;",
            "\tbool extra_pins;",
            "",
            "\tdelete_from_lru_cache(p);",
            "",
            "\t/*",
            "\t * For anonymous pages we're done the only reference left",
            "\t * should be the one m_f() holds.",
            "\t */",
            "\tif (PageAnon(p)) {",
            "\t\tret = MF_RECOVERED;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * Now truncate the page in the page cache. This is really",
            "\t * more like a \"temporary hole punch\"",
            "\t * Don't do this for block devices when someone else",
            "\t * has a reference, because it could be file system metadata",
            "\t * and that's not safe to truncate.",
            "\t */",
            "\tmapping = page_mapping(p);",
            "\tif (!mapping) {",
            "\t\t/*",
            "\t\t * Page has been teared down in the meanwhile",
            "\t\t */",
            "\t\tret = MF_FAILED;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * The shmem page is kept in page cache instead of truncating",
            "\t * so is expected to have an extra refcount after error-handling.",
            "\t */",
            "\textra_pins = shmem_mapping(mapping);",
            "",
            "\t/*",
            "\t * Truncation is a bit tricky. Enable it per file system for now.",
            "\t *",
            "\t * Open: to take i_rwsem or not for this? Right now we don't.",
            "\t */",
            "\tret = truncate_error_page(p, page_to_pfn(p), mapping);",
            "\tif (has_extra_refcount(ps, p, extra_pins))",
            "\t\tret = MF_FAILED;",
            "",
            "out:",
            "\tunlock_page(p);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "delete_from_lru_cache, truncate_error_page, has_extra_refcount, me_kernel, me_unknown, me_pagecache_clean",
          "description": "提供内存故障页面清理流程，包括从LRU列表移除、截断页面缓存及检查引用计数的辅助函数",
          "similarity": 0.6058629751205444
        },
        {
          "chunk_id": 0,
          "file_path": "mm/memory-failure.c",
          "start_line": 1,
          "end_line": 76,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (C) 2008, 2009 Intel Corporation",
            " * Authors: Andi Kleen, Fengguang Wu",
            " *",
            " * High level machine check handler. Handles pages reported by the",
            " * hardware as being corrupted usually due to a multi-bit ECC memory or cache",
            " * failure.",
            " *",
            " * In addition there is a \"soft offline\" entry point that allows stop using",
            " * not-yet-corrupted-by-suspicious pages without killing anything.",
            " *",
            " * Handles page cache pages in various states.\tThe tricky part",
            " * here is that we can access any page asynchronously in respect to",
            " * other VM users, because memory failures could happen anytime and",
            " * anywhere. This could violate some of their assumptions. This is why",
            " * this code has to be extremely careful. Generally it tries to use",
            " * normal locking rules, as in get the standard locks, even if that means",
            " * the error handling takes potentially a long time.",
            " *",
            " * It can be very tempting to add handling for obscure cases here.",
            " * In general any code for handling new cases should only be added iff:",
            " * - You know how to test it.",
            " * - You have a test that can be added to mce-test",
            " *   https://git.kernel.org/cgit/utils/cpu/mce/mce-test.git/",
            " * - The case actually shows up as a frequent (top 10) page state in",
            " *   tools/mm/page-types when running a real workload.",
            " *",
            " * There are several operations here with exponential complexity because",
            " * of unsuitable VM data structures. For example the operation to map back",
            " * from RMAP chains to processes has to walk the complete process list and",
            " * has non linear complexity with the number. But since memory corruptions",
            " * are rare we hope to get away with this. This avoids impacting the core",
            " * VM.",
            " */",
            "",
            "#define pr_fmt(fmt) \"Memory failure: \" fmt",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dax.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memremap.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagewalk.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sysctl.h>",
            "#include \"swap.h\"",
            "#include \"internal.h\"",
            "#include \"ras/ras_event.h\"",
            "",
            "static int sysctl_memory_failure_early_kill __read_mostly;",
            "",
            "static int sysctl_memory_failure_recovery __read_mostly = 1;",
            "",
            "atomic_long_t num_poisoned_pages __read_mostly = ATOMIC_LONG_INIT(0);",
            "",
            "static bool hw_memory_failure __read_mostly = false;",
            "",
            "static DEFINE_MUTEX(mf_mutex);",
            ""
          ],
          "function_name": null,
          "description": "定义内存故障处理模块的全局变量和互斥锁，用于跟踪被污染的页面数量（num_poisoned_pages）、硬件内存故障标志（hw_memory_failure）及控制内存故障恢复行为的sysctl参数。",
          "similarity": 0.593451738357544
        },
        {
          "chunk_id": 2,
          "file_path": "mm/memory-failure.c",
          "start_line": 278,
          "end_line": 378,
          "content": [
            "static int hwpoison_filter_task(struct page *p) { return 0; }",
            "int hwpoison_filter(struct page *p)",
            "{",
            "\tif (!hwpoison_filter_enable)",
            "\t\treturn 0;",
            "",
            "\tif (hwpoison_filter_dev(p))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (hwpoison_filter_flags(p))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (hwpoison_filter_task(p))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "int hwpoison_filter(struct page *p)",
            "{",
            "\treturn 0;",
            "}",
            "static int kill_proc(struct to_kill *tk, unsigned long pfn, int flags)",
            "{",
            "\tstruct task_struct *t = tk->tsk;",
            "\tshort addr_lsb = tk->size_shift;",
            "\tint ret = 0;",
            "",
            "\tpr_err(\"%#lx: Sending SIGBUS to %s:%d due to hardware memory corruption\\n\",",
            "\t\t\tpfn, t->comm, task_pid_nr(t));",
            "",
            "\tif ((flags & MF_ACTION_REQUIRED) && (t == current))",
            "\t\tret = force_sig_mceerr(BUS_MCEERR_AR,",
            "\t\t\t\t (void __user *)tk->addr, addr_lsb);",
            "\telse",
            "\t\t/*",
            "\t\t * Signal other processes sharing the page if they have",
            "\t\t * PF_MCE_EARLY set.",
            "\t\t * Don't use force here, it's convenient if the signal",
            "\t\t * can be temporarily blocked.",
            "\t\t */",
            "\t\tret = send_sig_mceerr(BUS_MCEERR_AO, (void __user *)tk->addr,",
            "\t\t\t\t      addr_lsb, t);",
            "\tif (ret < 0)",
            "\t\tpr_info(\"Error sending signal to %s:%d: %d\\n\",",
            "\t\t\tt->comm, task_pid_nr(t), ret);",
            "\treturn ret;",
            "}",
            "void shake_folio(struct folio *folio)",
            "{",
            "\tif (folio_test_hugetlb(folio))",
            "\t\treturn;",
            "\t/*",
            "\t * TODO: Could shrink slab caches here if a lightweight range-based",
            "\t * shrinker will be available.",
            "\t */",
            "\tif (folio_test_slab(folio))",
            "\t\treturn;",
            "",
            "\tlru_add_drain_all();",
            "}",
            "static void shake_page(struct page *page)",
            "{",
            "\tshake_folio(page_folio(page));",
            "}",
            "static unsigned long dev_pagemap_mapping_shift(struct vm_area_struct *vma,",
            "\t\tunsigned long address)",
            "{",
            "\tunsigned long ret = 0;",
            "\tpgd_t *pgd;",
            "\tp4d_t *p4d;",
            "\tpud_t *pud;",
            "\tpmd_t *pmd;",
            "\tpte_t *pte;",
            "\tpte_t ptent;",
            "",
            "\tVM_BUG_ON_VMA(address == -EFAULT, vma);",
            "\tpgd = pgd_offset(vma->vm_mm, address);",
            "\tif (!pgd_present(*pgd))",
            "\t\treturn 0;",
            "\tp4d = p4d_offset(pgd, address);",
            "\tif (!p4d_present(*p4d))",
            "\t\treturn 0;",
            "\tpud = pud_offset(p4d, address);",
            "\tif (!pud_present(*pud))",
            "\t\treturn 0;",
            "\tif (pud_devmap(*pud))",
            "\t\treturn PUD_SHIFT;",
            "\tpmd = pmd_offset(pud, address);",
            "\tif (!pmd_present(*pmd))",
            "\t\treturn 0;",
            "\tif (pmd_devmap(*pmd))",
            "\t\treturn PMD_SHIFT;",
            "\tpte = pte_offset_map(pmd, address);",
            "\tif (!pte)",
            "\t\treturn 0;",
            "\tptent = ptep_get(pte);",
            "\tif (pte_present(ptent) && pte_devmap(ptent))",
            "\t\tret = PAGE_SHIFT;",
            "\tpte_unmap(pte);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "hwpoison_filter_task, hwpoison_filter, hwpoison_filter, kill_proc, shake_folio, shake_page, dev_pagemap_mapping_shift",
          "description": "实现内存故障过滤和进程终止逻辑，包含验证页面映射有效性、向进程发送SIGBUS/SIGKILL信号的函数，以及用于页面抖动的辅助函数。",
          "similarity": 0.559917688369751
        },
        {
          "chunk_id": 14,
          "file_path": "mm/memory-failure.c",
          "start_line": 2186,
          "end_line": 2390,
          "content": [
            "int memory_failure(unsigned long pfn, int flags)",
            "{",
            "\tstruct page *p;",
            "\tstruct folio *folio;",
            "\tstruct dev_pagemap *pgmap;",
            "\tint res = 0;",
            "\tunsigned long page_flags;",
            "\tbool retry = true;",
            "\tint hugetlb = 0;",
            "",
            "\tif (!sysctl_memory_failure_recovery)",
            "\t\tpanic(\"Memory failure on page %lx\", pfn);",
            "",
            "\tmutex_lock(&mf_mutex);",
            "",
            "\tif (!(flags & MF_SW_SIMULATED))",
            "\t\thw_memory_failure = true;",
            "",
            "\tp = pfn_to_online_page(pfn);",
            "\tif (!p) {",
            "\t\tres = arch_memory_failure(pfn, flags);",
            "\t\tif (res == 0)",
            "\t\t\tgoto unlock_mutex;",
            "",
            "\t\tif (pfn_valid(pfn)) {",
            "\t\t\tpgmap = get_dev_pagemap(pfn, NULL);",
            "\t\t\tput_ref_page(pfn, flags);",
            "\t\t\tif (pgmap) {",
            "\t\t\t\tres = memory_failure_dev_pagemap(pfn, flags,",
            "\t\t\t\t\t\t\t\t pgmap);",
            "\t\t\t\tgoto unlock_mutex;",
            "\t\t\t}",
            "\t\t}",
            "\t\tpr_err(\"%#lx: memory outside kernel control\\n\", pfn);",
            "\t\tres = -ENXIO;",
            "\t\tgoto unlock_mutex;",
            "\t}",
            "",
            "try_again:",
            "\tres = try_memory_failure_hugetlb(pfn, flags, &hugetlb);",
            "\tif (hugetlb)",
            "\t\tgoto unlock_mutex;",
            "",
            "\tif (TestSetPageHWPoison(p)) {",
            "\t\tpr_err(\"%#lx: already hardware poisoned\\n\", pfn);",
            "\t\tres = -EHWPOISON;",
            "\t\tif (flags & MF_ACTION_REQUIRED)",
            "\t\t\tres = kill_accessing_process(current, pfn, flags);",
            "\t\tif (flags & MF_COUNT_INCREASED)",
            "\t\t\tput_page(p);",
            "\t\tgoto unlock_mutex;",
            "\t}",
            "",
            "\t/*",
            "\t * We need/can do nothing about count=0 pages.",
            "\t * 1) it's a free page, and therefore in safe hand:",
            "\t *    check_new_page() will be the gate keeper.",
            "\t * 2) it's part of a non-compound high order page.",
            "\t *    Implies some kernel user: cannot stop them from",
            "\t *    R/W the page; let's pray that the page has been",
            "\t *    used and will be freed some time later.",
            "\t * In fact it's dangerous to directly bump up page count from 0,",
            "\t * that may make page_ref_freeze()/page_ref_unfreeze() mismatch.",
            "\t */",
            "\tif (!(flags & MF_COUNT_INCREASED)) {",
            "\t\tres = get_hwpoison_page(p, flags);",
            "\t\tif (!res) {",
            "\t\t\tif (is_free_buddy_page(p)) {",
            "\t\t\t\tif (take_page_off_buddy(p)) {",
            "\t\t\t\t\tpage_ref_inc(p);",
            "\t\t\t\t\tres = MF_RECOVERED;",
            "\t\t\t\t} else {",
            "\t\t\t\t\t/* We lost the race, try again */",
            "\t\t\t\t\tif (retry) {",
            "\t\t\t\t\t\tClearPageHWPoison(p);",
            "\t\t\t\t\t\tretry = false;",
            "\t\t\t\t\t\tgoto try_again;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tres = MF_FAILED;",
            "\t\t\t\t}",
            "\t\t\t\tres = action_result(pfn, MF_MSG_BUDDY, res);",
            "\t\t\t} else {",
            "\t\t\t\tres = action_result(pfn, MF_MSG_KERNEL_HIGH_ORDER, MF_IGNORED);",
            "\t\t\t}",
            "\t\t\tgoto unlock_mutex;",
            "\t\t} else if (res < 0) {",
            "\t\t\tres = action_result(pfn, MF_MSG_UNKNOWN, MF_IGNORED);",
            "\t\t\tgoto unlock_mutex;",
            "\t\t}",
            "\t}",
            "",
            "\tfolio = page_folio(p);",
            "\tif (folio_test_large(folio)) {",
            "\t\t/*",
            "\t\t * The flag must be set after the refcount is bumped",
            "\t\t * otherwise it may race with THP split.",
            "\t\t * And the flag can't be set in get_hwpoison_page() since",
            "\t\t * it is called by soft offline too and it is just called",
            "\t\t * for !MF_COUNT_INCREASED.  So here seems to be the best",
            "\t\t * place.",
            "\t\t *",
            "\t\t * Don't need care about the above error handling paths for",
            "\t\t * get_hwpoison_page() since they handle either free page",
            "\t\t * or unhandlable page.  The refcount is bumped iff the",
            "\t\t * page is a valid handlable page.",
            "\t\t */",
            "\t\tfolio_set_has_hwpoisoned(folio);",
            "\t\tif (try_to_split_thp_page(p) < 0) {",
            "\t\t\tres = action_result(pfn, MF_MSG_UNSPLIT_THP, MF_IGNORED);",
            "\t\t\tgoto unlock_mutex;",
            "\t\t}",
            "\t\tVM_BUG_ON_PAGE(!page_count(p), p);",
            "\t\tfolio = page_folio(p);",
            "\t}",
            "",
            "\t/*",
            "\t * We ignore non-LRU pages for good reasons.",
            "\t * - PG_locked is only well defined for LRU pages and a few others",
            "\t * - to avoid races with __SetPageLocked()",
            "\t * - to avoid races with __SetPageSlab*() (and more non-atomic ops)",
            "\t * The check (unnecessarily) ignores LRU pages being isolated and",
            "\t * walked by the page reclaim code, however that's not a big loss.",
            "\t */",
            "\tshake_folio(folio);",
            "",
            "\tfolio_lock(folio);",
            "",
            "\t/*",
            "\t * We're only intended to deal with the non-Compound page here.",
            "\t * However, the page could have changed compound pages due to",
            "\t * race window. If this happens, we could try again to hopefully",
            "\t * handle the page next round.",
            "\t */",
            "\tif (folio_test_large(folio)) {",
            "\t\tif (retry) {",
            "\t\t\tClearPageHWPoison(p);",
            "\t\t\tfolio_unlock(folio);",
            "\t\t\tfolio_put(folio);",
            "\t\t\tflags &= ~MF_COUNT_INCREASED;",
            "\t\t\tretry = false;",
            "\t\t\tgoto try_again;",
            "\t\t}",
            "\t\tres = action_result(pfn, MF_MSG_DIFFERENT_COMPOUND, MF_IGNORED);",
            "\t\tgoto unlock_page;",
            "\t}",
            "",
            "\t/*",
            "\t * We use page flags to determine what action should be taken, but",
            "\t * the flags can be modified by the error containment action.  One",
            "\t * example is an mlocked page, where PG_mlocked is cleared by",
            "\t * folio_remove_rmap_*() in try_to_unmap_one(). So to determine page",
            "\t * status correctly, we save a copy of the page flags at this time.",
            "\t */",
            "\tpage_flags = folio->flags;",
            "",
            "\tif (hwpoison_filter(p)) {",
            "\t\tClearPageHWPoison(p);",
            "\t\tfolio_unlock(folio);",
            "\t\tfolio_put(folio);",
            "\t\tres = -EOPNOTSUPP;",
            "\t\tgoto unlock_mutex;",
            "\t}",
            "",
            "\t/*",
            "\t * __munlock_folio() may clear a writeback folio's LRU flag without",
            "\t * the folio lock. We need to wait for writeback completion for this",
            "\t * folio or it may trigger a vfs BUG while evicting inode.",
            "\t */",
            "\tif (!folio_test_lru(folio) && !folio_test_writeback(folio))",
            "\t\tgoto identify_page_state;",
            "",
            "\t/*",
            "\t * It's very difficult to mess with pages currently under IO",
            "\t * and in many cases impossible, so we just avoid it here.",
            "\t */",
            "\tfolio_wait_writeback(folio);",
            "",
            "\t/*",
            "\t * Now take care of user space mappings.",
            "\t * Abort on fail: __filemap_remove_folio() assumes unmapped page.",
            "\t */",
            "\tif (!hwpoison_user_mappings(folio, p, pfn, flags)) {",
            "\t\tres = action_result(pfn, MF_MSG_UNMAP_FAILED, MF_IGNORED);",
            "\t\tgoto unlock_page;",
            "\t}",
            "",
            "\t/*",
            "\t * Torn down by someone else?",
            "\t */",
            "\tif (folio_test_lru(folio) && !folio_test_swapcache(folio) &&",
            "\t    folio->mapping == NULL) {",
            "\t\tres = action_result(pfn, MF_MSG_TRUNCATED_LRU, MF_IGNORED);",
            "\t\tgoto unlock_page;",
            "\t}",
            "",
            "identify_page_state:",
            "\tres = identify_page_state(pfn, p, page_flags);",
            "\tmutex_unlock(&mf_mutex);",
            "\treturn res;",
            "unlock_page:",
            "\tfolio_unlock(folio);",
            "unlock_mutex:",
            "\tmutex_unlock(&mf_mutex);",
            "\treturn res;",
            "}"
          ],
          "function_name": "memory_failure",
          "description": "memory_failure主函数处理内存故障，检查页面有效性，通过不同路径处理普通页、大页和设备页，调用相应处理函数并返回结果",
          "similarity": 0.5446929931640625
        }
      ]
    },
    {
      "source_file": "kernel/module/internal.h",
      "md_summary": "> 自动生成时间: 2025-10-25 15:01:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\internal.h`\n\n---\n\n# `module/internal.h` 技术文档\n\n## 1. 文件概述\n\n`module/internal.h` 是 Linux 内核模块子系统的核心内部头文件，定义了模块加载、符号解析、内存布局、调试统计等关键内部数据结构和辅助函数。该文件仅供内核模块子系统内部使用，不对外暴露给模块开发者。它封装了模块加载过程中的中间状态、符号查找逻辑、内存管理细节以及与架构相关的重定位处理，并集成了模块压缩、热补丁（livepatch）、污点追踪（taint tracking）和调试统计等可选功能的支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct kernel_symbol`**  \n  内核符号的内部表示，支持两种模式：  \n  - 普通模式：直接存储符号值（`value`）、名称（`name`）和命名空间（`namespace`）指针。  \n  - `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 模式：使用偏移量（`value_offset` 等）以节省内存并支持位置无关代码。\n\n- **`struct load_info`**  \n  模块加载过程中的临时信息容器，包含 ELF 头、节头表、字符串表、符号表、各节偏移、签名状态、解压页信息等，贯穿整个 `load_module()` 流程。\n\n- **`struct find_symbol_arg`**  \n  符号查找的输入/输出参数结构，用于 `find_symbol()` 函数，支持按名称、GPL 许可限制进行符号搜索。\n\n- **`enum fail_dup_mod_reason`**  \n  定义重复模块加载失败的两种场景：`FAIL_DUP_MOD_BECOMING`（早期检查阶段发现重复）和 `FAIL_DUP_MOD_LOAD`（分配内存后发现重复）。\n\n- **`struct mod_fail_load`**（仅当 `CONFIG_MODULE_STATS` 启用）  \n  用于统计重复加载失败的模块信息。\n\n- **`struct mod_unload_taint`**（仅当 `CONFIG_MODULE_UNLOAD_TAINT_TRACKING` 启用）  \n  记录卸载时带有污点（taint）的模块信息。\n\n### 主要函数\n\n- **符号管理**  \n  - `find_symbol()`：在全局符号表中查找指定名称的符号。  \n  - `kernel_symbol_value()`：获取 `kernel_symbol` 结构中符号的实际地址。\n\n- **模块加载辅助**  \n  - `mod_verify_sig()`：验证模块签名。  \n  - `try_to_force_load()`：在特定条件下强制加载被拒绝的模块（如 taint 原因）。  \n  - `module_get_offset_and_type()`：计算模块节在目标内存布局中的偏移和内存类型。  \n  - `module_flags()` / `module_flags_taint()`：生成模块状态或污点标志的字符串表示。\n\n- **模块信息解析**  \n  - `module_next_tag_pair()`：解析模块信息（modinfo）中的键值对。  \n  - `for_each_modinfo_entry`：遍历指定名称的 modinfo 条目。\n\n- **热补丁支持**（`CONFIG_LIVEPATCH`）  \n  - `copy_module_elf()` / `free_module_elf()`：复制或释放模块的 ELF 原始数据，供 livepatch 使用。  \n  - `set_livepatch_module()`：标记模块为 livepatch 模块。\n\n- **统计与调试**（条件编译）  \n  - `try_add_failed_module()`：记录重复加载失败事件。  \n  - `mod_stat_bump_invalid()` / `mod_stat_bump_becoming()`：更新无效或正在加载的模块统计。  \n  - `try_add_tainted_module()` / `print_unloaded_tainted_modules()`：跟踪并打印卸载时带污点的模块。  \n  - `kmod_dup_request_exists_wait()` / `kmod_dup_request_announce()`：用于调试自动加载重复请求。\n\n- **解压支持**（`CONFIG_MODULE_DECOMPRESS`）  \n  - `module_decompress()` / `module_decompress_cleanup()`：解压压缩的模块镜像。\n\n### 全局变量\n\n- `module_mutex`：保护模块列表和状态的全局互斥锁。  \n- `modules`：已加载模块的全局链表。  \n- `modinfo_attrs[]` / `modinfo_attrs_count`：模块信息属性数组及其数量。  \n- `__start___ksymtab[]` 等：链接器生成的内核符号表起止标记。  \n- 各类统计计数器（如 `total_mod_size`, `modcount` 等，仅当 `CONFIG_MODULE_STATS` 启用）。\n\n## 3. 关键实现\n\n### 符号表与重定位优化\n- 通过 `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 支持使用 32 位相对偏移代替 64 位绝对指针，显著减少符号表内存占用，尤其在 64 位系统上。\n- `kernel_symbol_value()` 宏根据配置自动选择解析方式，对上层透明。\n\n### 节类型编码\n- 利用 ELF 节头 `sh_entsize` 的高 4 位存储 `mod_mem_type`（内存类型），低 28/60 位存储偏移量。\n- 定义了 `SH_ENTSIZE_TYPE_BITS`、`SH_ENTSIZE_TYPE_MASK` 等宏进行位操作，确保在 32/64 位系统上正确分离类型与偏移。\n\n### 模块加载状态保护\n- `module_assert_mutex_or_preempt()` 利用 `lockdep` 和 `rcu_read_lock_sched_held()` 确保关键操作在持有 `module_mutex` 或处于 RCU 读临界区中执行，防止并发错误。\n\n### 重复模块检测\n- `enum fail_dup_mod_reason` 精确区分重复模块在加载流程中被发现的两个关键点，有助于分析资源浪费（如 vmap 空间）和竞态条件。\n\n### 条件编译功能集成\n- 通过 `#ifdef CONFIG_XXX` 将模块统计、污点追踪、自动加载调试、解压、热补丁等功能模块化，保持核心逻辑简洁，按需启用。\n\n## 4. 依赖关系\n\n- **内核核心头文件**：  \n  - `<linux/elf.h>`：ELF 格式定义。  \n  - `<linux/module.h>`：模块公共接口。  \n  - `<linux/mutex.h>`, `<linux/rculist.h>`, `<linux/rcupdate.h>`：同步原语。  \n  - `<linux/mm.h>`：内存管理相关定义。\n\n- **架构相关**：  \n  - `ARCH_SHF_SMALL`：架构特定的节标志，用于小内存模型。\n\n- **可选子系统**：  \n  - `CONFIG_KALLSYMS`：内核符号表支持。  \n  - `CONFIG_LIVEPATCH`：内核热补丁。  \n  - `CONFIG_MODULE_DECOMPRESS`：模块解压。  \n  - `CONFIG_MODULE_STATS` / `CONFIG_MODULE_DEBUGFS` / `CONFIG_MODULE_UNLOAD_TAINT_TRACKING` / `CONFIG_MODULE_DEBUG_AUTOLOAD_DUPS`：各类调试与统计功能。\n\n- **链接器脚本**：  \n  - 依赖链接器生成的 `__start___ksymtab`、`__stop___ksymtab_gpl` 等符号，用于遍历内建符号表。\n\n## 5. 使用场景\n\n- **模块加载流程**：`load_module()` 及其辅助函数使用 `struct load_info` 传递解析后的 ELF 信息，并调用 `mod_verify_sig()`、`module_decompress()` 等进行预处理。\n- **符号解析**：`find_symbol()` 被 `kernel/module.c` 中的符号导出/导入机制调用，实现模块间及内核与模块间的符号链接。\n- **内存布局**：`module_get_offset_and_type()` 在 `layout_and_allocate()` 阶段确定各节在模块内存映像中的位置。\n- **调试与监控**：  \n  - `module_flags()` 用于 `/sys/module/<name>/taint` 等接口显示模块状态。  \n  - 统计功能（`CONFIG_MODULE_STATS`）帮助分析模块加载性能与失败原因。  \n  - 污点追踪（`CONFIG_MODULE_UNLOAD_TAINT_TRACKING`）记录可能导致系统不稳定模块的卸载信息。\n- **热补丁**：livepatch 子系统通过 `copy_module_elf()` 保留原始 ELF 用于补丁验证和回滚。\n- **并发控制**：所有修改全局模块列表或状态的操作必须通过 `module_mutex` 保护，`module_assert_mutex_or_preempt()` 用于运行时检查。",
      "similarity": 0.6435766220092773,
      "chunks": []
    },
    {
      "source_file": "kernel/module/main.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:04:44\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\main.c`\n\n---\n\n# `module/main.c` 技术文档\n\n## 1. 文件概述\n\n`module/main.c` 是 Linux 内核模块子系统的核心实现文件，负责模块的加载、卸载、符号解析、内存管理、状态跟踪以及模块间依赖关系的维护。该文件实现了内核模块机制的基础框架，包括模块列表管理、模块内存布局控制、符号查找、模块通知机制、模块引用计数等关键功能，是内核动态加载模块能力的核心支撑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct mod_tree_root mod_tree`**：用于加速地址到模块映射的全局模块地址范围树，包含 `addr_min`/`addr_max`（及可选的 `data_addr_min`/`data_addr_max`）。\n- **`LIST_HEAD(modules)`**：全局模块链表，存储所有已加载模块。\n- **`DEFINE_MUTEX(module_mutex)`**：保护模块列表、模块使用关系及地址边界的关键互斥锁。\n- **`struct symsearch`**：用于描述符号搜索范围，包含符号起止位置、CRC 校验数组及许可证类型。\n- **`struct find_symbol_arg`**：符号查找的参数结构体，用于传递查找目标及接收结果（所有者、符号指针、CRC、许可证等）。\n\n### 主要函数与接口\n\n- **模块注册/注销通知**：\n  - `register_module_notifier()` / `unregister_module_notifier()`：注册/注销模块生命周期事件通知回调。\n- **模块引用管理**：\n  - `strong_try_module_get()`：强引用获取，拒绝处于 `COMING` 状态的模块。\n  - `__module_put_and_kthread_exit()`：专用于内核线程在退出前释放模块引用。\n- **模块内存边界管理**：\n  - `__mod_update_bounds()` / `mod_update_bounds()`：更新全局模块地址范围，用于加速 `__module_address()`。\n- **ELF 节区辅助函数**：\n  - `find_sec()` / `find_any_sec()`：根据名称查找 ELF 节区索引。\n  - `section_addr()` / `section_objs()`：获取节区地址及对象数量。\n- **符号查找**：\n  - `find_symbol()`：在内核及已加载模块中查找导出符号。\n  - `find_exported_symbol_in_section()`：在指定符号段中二分查找符号。\n- **模块状态与安全**：\n  - `add_taint_module()`：为模块添加污点标记（taint flag）。\n- **全局控制**：\n  - `modules_disabled`：通过 `nomodule` 内核参数控制是否禁用模块加载。\n\n### 全局变量与工作队列\n\n- **`init_free_wq`**：用于异步释放模块初始化段（`.init`）内存的工作队列。\n- **`init_free_list`**：待释放初始化内存的无锁链表。\n- **`module_wq`**：等待模块初始化完成的等待队列。\n\n## 3. 关键实现\n\n### 模块地址范围加速\n\n通过 `mod_tree` 全局结构维护所有模块（或核心数据）的最小/最大虚拟地址。`__module_address()` 可先检查目标地址是否落在 `[addr_min, addr_max]` 范围内，若不在则直接返回 `NULL`，避免遍历整个模块链表，显著提升性能。\n\n### 符号查找机制\n\n- 使用 `bsearch()` 在已排序的导出符号表中进行二分查找，时间复杂度为 O(log n)。\n- 支持符号命名空间（namespace）和 GPL 许可证检查：非 GPL 模块无法使用 `GPL_ONLY` 符号。\n- 通过 `symsearch` 数组统一管理内核及各模块的符号段，实现统一查找接口。\n\n### 模块内存管理\n\n- 模块内存按 `mod_mem_type`（如代码、只读数据、可写数据、初始化段等）分类管理。\n- 初始化段（`.init`）在模块初始化成功后通过工作队列异步释放，节省内存。\n- 支持 `CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC` 架构选项，将模块数据段单独纳入地址范围管理。\n\n### 模块状态与引用安全\n\n- `strong_try_module_get()` 确保不会对处于 `MODULE_STATE_COMING`（正在初始化）或 `MODULE_STATE_UNFORMED`（未形成）状态的模块增加引用，防止竞态。\n- `__module_put_and_kthread_exit()` 为内核线程提供安全退出路径，在释放模块引用后终止线程。\n\n### 模块通知机制\n\n基于 `blocking_notifier_chain` 实现模块生命周期事件（如加载、卸载、初始化完成等）的通知，允许其他子系统（如 livepatch、ftrace）监听并响应模块状态变化。\n\n### 构建标识与版本校验\n\n- 通过 `INCLUDE_VERMAGIC` 宏包含模块魔数（vermagic）信息，用于加载时内核版本兼容性检查。\n- 支持 `CONFIG_MODVERSIONS`，在符号查找时返回 CRC 校验值，确保符号 ABI 兼容性。\n\n## 4. 依赖关系\n\n- **架构相关**：\n  - 依赖 `asm/cacheflush.h`、`asm/mmu_context.h`、`asm/sections.h` 等架构头文件，处理指令缓存刷新、内存映射等。\n  - 使用 `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 优化符号字符串存储。\n- **内核子系统**：\n  - **内存管理**：`vmalloc`、`slab` 用于模块内存分配。\n  - **安全机制**：`capability`、`audit`、`module_signature` 用于模块加载权限和签名验证。\n  - **调试与追踪**：`kallsyms`、`trace_events`、`ftrace`、`dynamic_debug`、`debugfs` 提供模块调试支持。\n  - **并发控制**：`RCU`、`mutex`、`percpu` 用于同步。\n  - **文件系统**：`fs.h`、`kernel_read_file.h` 用于从文件加载模块。\n- **内部依赖**：\n  - 依赖同目录下的 `internal.h`，包含模块子系统内部数据结构和函数声明。\n  - 使用 `uapi/linux/module.h` 定义用户空间接口常量。\n\n## 5. 使用场景\n\n- **动态加载内核模块**：通过 `init_module()` 或 `finit_module()` 系统调用加载 `.ko` 文件时，该文件中的函数负责解析 ELF、重定位、符号解析、执行初始化函数。\n- **模块卸载**：通过 `delete_module()` 系统调用卸载模块时，管理模块引用计数、执行清理函数、释放内存。\n- **内核符号解析**：当模块或内核其他部分调用 `symbol_get()` 或通过 `EXPORT_SYMBOL` 机制访问符号时，`find_symbol()` 被调用。\n- **运行时模块查询**：`/proc/modules`、`/sys/module/` 等接口依赖此文件维护的模块列表和状态信息。\n- **内核热补丁（Livepatch）**：依赖模块通知机制和符号查找功能实现函数替换。\n- **内核调试与性能分析**：ftrace、kprobes 等工具依赖模块地址范围和符号信息进行函数跟踪。",
      "similarity": 0.6333834528923035,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/main.c",
          "start_line": 96,
          "end_line": 202,
          "content": [
            "static void __mod_update_bounds(enum mod_mem_type type __maybe_unused, void *base,",
            "\t\t\t\tunsigned int size, struct mod_tree_root *tree)",
            "{",
            "\tunsigned long min = (unsigned long)base;",
            "\tunsigned long max = min + size;",
            "",
            "#ifdef CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC",
            "\tif (mod_mem_type_is_core_data(type)) {",
            "\t\tif (min < tree->data_addr_min)",
            "\t\t\ttree->data_addr_min = min;",
            "\t\tif (max > tree->data_addr_max)",
            "\t\t\ttree->data_addr_max = max;",
            "\t\treturn;",
            "\t}",
            "#endif",
            "\tif (min < tree->addr_min)",
            "\t\ttree->addr_min = min;",
            "\tif (max > tree->addr_max)",
            "\t\ttree->addr_max = max;",
            "}",
            "static void mod_update_bounds(struct module *mod)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tstruct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (mod_mem->size)",
            "\t\t\t__mod_update_bounds(type, mod_mem->base, mod_mem->size, &mod_tree);",
            "\t}",
            "}",
            "int register_module_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&module_notify_list, nb);",
            "}",
            "int unregister_module_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);",
            "}",
            "static inline int strong_try_module_get(struct module *mod)",
            "{",
            "\tBUG_ON(mod && mod->state == MODULE_STATE_UNFORMED);",
            "\tif (mod && mod->state == MODULE_STATE_COMING)",
            "\t\treturn -EBUSY;",
            "\tif (try_module_get(mod))",
            "\t\treturn 0;",
            "\telse",
            "\t\treturn -ENOENT;",
            "}",
            "static inline void add_taint_module(struct module *mod, unsigned flag,",
            "\t\t\t\t    enum lockdep_ok lockdep_ok)",
            "{",
            "\tadd_taint(flag, lockdep_ok);",
            "\tset_bit(flag, &mod->taints);",
            "}",
            "void __noreturn __module_put_and_kthread_exit(struct module *mod, long code)",
            "{",
            "\tmodule_put(mod);",
            "\tkthread_exit(code);",
            "}",
            "static unsigned int find_sec(const struct load_info *info, const char *name)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\t/* Alloc bit cleared means \"ignore it.\" */",
            "\t\tif ((shdr->sh_flags & SHF_ALLOC)",
            "\t\t    && strcmp(info->secstrings + shdr->sh_name, name) == 0)",
            "\t\t\treturn i;",
            "\t}",
            "\treturn 0;",
            "}",
            "static unsigned int find_any_sec(const struct load_info *info, const char *name)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\tif (strcmp(info->secstrings + shdr->sh_name, name) == 0)",
            "\t\t\treturn i;",
            "\t}",
            "\treturn 0;",
            "}",
            "int cmp_name(const void *name, const void *sym)",
            "{",
            "\treturn strcmp(name, kernel_symbol_name(sym));",
            "}",
            "static bool find_exported_symbol_in_section(const struct symsearch *syms,",
            "\t\t\t\t\t    struct module *owner,",
            "\t\t\t\t\t    struct find_symbol_arg *fsa)",
            "{",
            "\tstruct kernel_symbol *sym;",
            "",
            "\tif (!fsa->gplok && syms->license == GPL_ONLY)",
            "\t\treturn false;",
            "",
            "\tsym = bsearch(fsa->name, syms->start, syms->stop - syms->start,",
            "\t\t\tsizeof(struct kernel_symbol), cmp_name);",
            "\tif (!sym)",
            "\t\treturn false;",
            "",
            "\tfsa->owner = owner;",
            "\tfsa->crc = symversion(syms->crcs, sym - syms->start);",
            "\tfsa->sym = sym;",
            "\tfsa->license = syms->license;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "__mod_update_bounds, mod_update_bounds, register_module_notifier, unregister_module_notifier, strong_try_module_get, add_taint_module, __module_put_and_kthread_exit, find_sec, find_any_sec, cmp_name, find_exported_symbol_in_section",
          "description": "实现模块内存边界更新逻辑、模块状态变更通知注册与注销接口，以及强引用获取检查函数，用于维护模块内存范围并控制模块生命周期事件。",
          "similarity": 0.6221859455108643
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/module/main.c",
          "start_line": 1925,
          "end_line": 2029,
          "content": [
            "static int copy_chunked_from_user(void *dst, const void __user *usrc, unsigned long len)",
            "{",
            "\tdo {",
            "\t\tunsigned long n = min(len, COPY_CHUNK_SIZE);",
            "",
            "\t\tif (copy_from_user(dst, usrc, n) != 0)",
            "\t\t\treturn -EFAULT;",
            "\t\tcond_resched();",
            "\t\tdst += n;",
            "\t\tusrc += n;",
            "\t\tlen -= n;",
            "\t} while (len);",
            "\treturn 0;",
            "}",
            "static int check_modinfo_livepatch(struct module *mod, struct load_info *info)",
            "{",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (!get_modinfo(info, \"livepatch\")) {",
            "\t\tset_mod_klp_rel_state(mod, MODULE_KLP_REL_NONE);",
            "\t\treturn 0;",
            "\t}",
            "\tset_mod_klp_rel_state(mod, MODULE_KLP_REL_UNDO);",
            "#else /* !CONFIG_LIVEPATCH_WO_FTRACE */",
            "\tif (!get_modinfo(info, \"livepatch\"))",
            "\t\t/* Nothing more to do */",
            "\t\treturn 0;",
            "#endif /* CONFIG_LIVEPATCH_WO_FTRACE */",
            "",
            "\tif (set_livepatch_module(mod))",
            "\t\treturn 0;",
            "",
            "\tpr_err(\"%s: module is marked as livepatch module, but livepatch support is disabled\",",
            "\t       mod->name);",
            "\treturn -ENOEXEC;",
            "}",
            "static void check_modinfo_retpoline(struct module *mod, struct load_info *info)",
            "{",
            "\tif (retpoline_module_ok(get_modinfo(info, \"retpoline\")))",
            "\t\treturn;",
            "",
            "\tpr_warn(\"%s: loading module not compiled with retpoline compiler.\\n\",",
            "\t\tmod->name);",
            "}",
            "static int copy_module_from_user(const void __user *umod, unsigned long len,",
            "\t\t\t\t  struct load_info *info)",
            "{",
            "\tint err;",
            "",
            "\tinfo->len = len;",
            "\tif (info->len < sizeof(*(info->hdr)))",
            "\t\treturn -ENOEXEC;",
            "",
            "\terr = security_kernel_load_data(LOADING_MODULE, true);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\t/* Suck in entire file: we'll want most of it. */",
            "\tinfo->hdr = __vmalloc(info->len, GFP_KERNEL | __GFP_NOWARN);",
            "\tif (!info->hdr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (copy_chunked_from_user(info->hdr, umod, info->len) != 0) {",
            "\t\terr = -EFAULT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\terr = security_kernel_post_load_data((char *)info->hdr, info->len,",
            "\t\t\t\t\t     LOADING_MODULE, \"init_module\");",
            "out:",
            "\tif (err)",
            "\t\tvfree(info->hdr);",
            "",
            "\treturn err;",
            "}",
            "static void free_copy(struct load_info *info, int flags)",
            "{",
            "\tif (flags & MODULE_INIT_COMPRESSED_FILE)",
            "\t\tmodule_decompress_cleanup(info);",
            "\telse",
            "\t\tvfree(info->hdr);",
            "}",
            "static int rewrite_section_headers(struct load_info *info, int flags)",
            "{",
            "\tunsigned int i;",
            "",
            "\t/* This should always be true, but let's be sure. */",
            "\tinfo->sechdrs[0].sh_addr = 0;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "",
            "\t\t/*",
            "\t\t * Mark all sections sh_addr with their address in the",
            "\t\t * temporary image.",
            "\t\t */",
            "\t\tshdr->sh_addr = (size_t)info->hdr + shdr->sh_offset;",
            "",
            "\t}",
            "",
            "\t/* Track but don't keep modinfo and version sections. */",
            "\tinfo->sechdrs[info->index.vers].sh_flags &= ~(unsigned long)SHF_ALLOC;",
            "\tinfo->sechdrs[info->index.info].sh_flags &= ~(unsigned long)SHF_ALLOC;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "copy_chunked_from_user, check_modinfo_livepatch, check_modinfo_retpoline, copy_module_from_user, free_copy, rewrite_section_headers",
          "description": "实现分块从用户空间复制数据到内核缓冲区，检查模块livepatch属性，校验retpoline标志，复制模块元信息到内核，释放动态分配的模块数据，重写ELF节头地址以匹配实际内存布局",
          "similarity": 0.6122609376907349
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/module/main.c",
          "start_line": 2256,
          "end_line": 2359,
          "content": [
            "static int move_module(struct module *mod, struct load_info *info)",
            "{",
            "\tint i;",
            "\tvoid *ptr;",
            "\tenum mod_mem_type t = 0;",
            "\tint ret = -ENOMEM;",
            "",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tif (!mod->mem[type].size) {",
            "\t\t\tmod->mem[type].base = NULL;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tmod->mem[type].size = PAGE_ALIGN(mod->mem[type].size);",
            "\t\tptr = module_memory_alloc(mod->mem[type].size, type);",
            "\t\t/*",
            "                 * The pointer to these blocks of memory are stored on the module",
            "                 * structure and we keep that around so long as the module is",
            "                 * around. We only free that memory when we unload the module.",
            "                 * Just mark them as not being a leak then. The .init* ELF",
            "                 * sections *do* get freed after boot so we *could* treat them",
            "                 * slightly differently with kmemleak_ignore() and only grey",
            "                 * them out as they work as typical memory allocations which",
            "                 * *do* eventually get freed, but let's just keep things simple",
            "                 * and avoid *any* false positives.",
            "\t\t */",
            "\t\tkmemleak_not_leak(ptr);",
            "\t\tif (!ptr) {",
            "\t\t\tt = type;",
            "\t\t\tgoto out_enomem;",
            "\t\t}",
            "\t\tmemset(ptr, 0, mod->mem[type].size);",
            "\t\tmod->mem[type].base = ptr;",
            "\t}",
            "",
            "\t/* Transfer each section which specifies SHF_ALLOC */",
            "\tpr_debug(\"Final section addresses for %s:\\n\", mod->name);",
            "\tfor (i = 0; i < info->hdr->e_shnum; i++) {",
            "\t\tvoid *dest;",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\tenum mod_mem_type type = shdr->sh_entsize >> SH_ENTSIZE_TYPE_SHIFT;",
            "",
            "\t\tif (!(shdr->sh_flags & SHF_ALLOC))",
            "\t\t\tcontinue;",
            "",
            "\t\tdest = mod->mem[type].base + (shdr->sh_entsize & SH_ENTSIZE_OFFSET_MASK);",
            "",
            "\t\tif (shdr->sh_type != SHT_NOBITS) {",
            "\t\t\t/*",
            "\t\t\t * Our ELF checker already validated this, but let's",
            "\t\t\t * be pedantic and make the goal clearer. We actually",
            "\t\t\t * end up copying over all modifications made to the",
            "\t\t\t * userspace copy of the entire struct module.",
            "\t\t\t */",
            "\t\t\tif (i == info->index.mod &&",
            "\t\t\t   (WARN_ON_ONCE(shdr->sh_size != sizeof(struct module)))) {",
            "\t\t\t\tret = -ENOEXEC;",
            "\t\t\t\tgoto out_enomem;",
            "\t\t\t}",
            "\t\t\tmemcpy(dest, (void *)shdr->sh_addr, shdr->sh_size);",
            "\t\t}",
            "\t\t/*",
            "\t\t * Update the userspace copy's ELF section address to point to",
            "\t\t * our newly allocated memory as a pure convenience so that",
            "\t\t * users of info can keep taking advantage and using the newly",
            "\t\t * minted official memory area.",
            "\t\t */",
            "\t\tshdr->sh_addr = (unsigned long)dest;",
            "\t\tpr_debug(\"\\t0x%lx 0x%.8lx %s\\n\", (long)shdr->sh_addr,",
            "\t\t\t (long)shdr->sh_size, info->secstrings + shdr->sh_name);",
            "\t}",
            "",
            "\treturn 0;",
            "out_enomem:",
            "\tfor (t--; t >= 0; t--)",
            "\t\tmodule_memory_free(mod->mem[t].base, t, true);",
            "\treturn ret;",
            "}",
            "static int check_export_symbol_versions(struct module *mod)",
            "{",
            "#ifdef CONFIG_MODVERSIONS",
            "\tif ((mod->num_syms && !mod->crcs) ||",
            "\t    (mod->num_gpl_syms && !mod->gpl_crcs)) {",
            "\t\treturn try_to_force_load(mod,",
            "\t\t\t\t\t \"no versions for exported symbols\");",
            "\t}",
            "#endif",
            "\treturn 0;",
            "}",
            "void flush_module_icache(const struct module *mod)",
            "{",
            "\t/*",
            "\t * Flush the instruction cache, since we've played with text.",
            "\t * Do it before processing of module parameters, so the module",
            "\t * can provide parameter accessor functions of its own.",
            "\t */",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tconst struct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (mod_mem->size) {",
            "\t\t\tflush_icache_range((unsigned long)mod_mem->base,",
            "\t\t\t\t\t   (unsigned long)mod_mem->base + mod_mem->size);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "move_module, check_export_symbol_versions, flush_module_icache",
          "description": "为模块各内存类型分配物理页框，将ELF节区内容拷贝至对应内存区域，检查导出符号版本一致性，刷新指令高速缓存以确保新代码可见",
          "similarity": 0.5721275806427002
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/module/main.c",
          "start_line": 303,
          "end_line": 412,
          "content": [
            "bool find_symbol(struct find_symbol_arg *fsa)",
            "{",
            "\tstatic const struct symsearch arr[] = {",
            "\t\t{ __start___ksymtab, __stop___ksymtab, __start___kcrctab,",
            "\t\t  NOT_GPL_ONLY },",
            "\t\t{ __start___ksymtab_gpl, __stop___ksymtab_gpl,",
            "\t\t  __start___kcrctab_gpl,",
            "\t\t  GPL_ONLY },",
            "\t};",
            "\tstruct module *mod;",
            "\tunsigned int i;",
            "",
            "\tmodule_assert_mutex_or_preempt();",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(arr); i++)",
            "\t\tif (find_exported_symbol_in_section(&arr[i], NULL, fsa))",
            "\t\t\treturn true;",
            "",
            "\tlist_for_each_entry_rcu(mod, &modules, list,",
            "\t\t\t\tlockdep_is_held(&module_mutex)) {",
            "\t\tstruct symsearch arr[] = {",
            "\t\t\t{ mod->syms, mod->syms + mod->num_syms, mod->crcs,",
            "\t\t\t  NOT_GPL_ONLY },",
            "\t\t\t{ mod->gpl_syms, mod->gpl_syms + mod->num_gpl_syms,",
            "\t\t\t  mod->gpl_crcs,",
            "\t\t\t  GPL_ONLY },",
            "\t\t};",
            "",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (i = 0; i < ARRAY_SIZE(arr); i++)",
            "\t\t\tif (find_exported_symbol_in_section(&arr[i], mod, fsa))",
            "\t\t\t\treturn true;",
            "\t}",
            "",
            "\tpr_debug(\"Failed to find symbol %s\\n\", fsa->name);",
            "\treturn false;",
            "}",
            "static int percpu_modalloc(struct module *mod, struct load_info *info)",
            "{",
            "\tElf_Shdr *pcpusec = &info->sechdrs[info->index.pcpu];",
            "\tunsigned long align = pcpusec->sh_addralign;",
            "",
            "\tif (!pcpusec->sh_size)",
            "\t\treturn 0;",
            "",
            "\tif (align > PAGE_SIZE) {",
            "\t\tpr_warn(\"%s: per-cpu alignment %li > %li\\n\",",
            "\t\t\tmod->name, align, PAGE_SIZE);",
            "\t\talign = PAGE_SIZE;",
            "\t}",
            "",
            "\tmod->percpu = __alloc_reserved_percpu(pcpusec->sh_size, align);",
            "\tif (!mod->percpu) {",
            "\t\tpr_warn(\"%s: Could not allocate %lu bytes percpu data\\n\",",
            "\t\t\tmod->name, (unsigned long)pcpusec->sh_size);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\tmod->percpu_size = pcpusec->sh_size;",
            "\treturn 0;",
            "}",
            "static void percpu_modfree(struct module *mod)",
            "{",
            "\tfree_percpu(mod->percpu);",
            "}",
            "static unsigned int find_pcpusec(struct load_info *info)",
            "{",
            "\treturn find_sec(info, \".data..percpu\");",
            "}",
            "static void percpu_modcopy(struct module *mod,",
            "\t\t\t   const void *from, unsigned long size)",
            "{",
            "\tint cpu;",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tmemcpy(per_cpu_ptr(mod->percpu, cpu), from, size);",
            "}",
            "bool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)",
            "{",
            "\tstruct module *mod;",
            "\tunsigned int cpu;",
            "",
            "\tpreempt_disable();",
            "",
            "\tlist_for_each_entry_rcu(mod, &modules, list) {",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "\t\tif (!mod->percpu_size)",
            "\t\t\tcontinue;",
            "\t\tfor_each_possible_cpu(cpu) {",
            "\t\t\tvoid *start = per_cpu_ptr(mod->percpu, cpu);",
            "\t\t\tvoid *va = (void *)addr;",
            "",
            "\t\t\tif (va >= start && va < start + mod->percpu_size) {",
            "\t\t\t\tif (can_addr) {",
            "\t\t\t\t\t*can_addr = (unsigned long) (va - start);",
            "\t\t\t\t\t*can_addr += (unsigned long)",
            "\t\t\t\t\t\tper_cpu_ptr(mod->percpu,",
            "\t\t\t\t\t\t\t    get_boot_cpu_id());",
            "\t\t\t\t}",
            "\t\t\t\tpreempt_enable();",
            "\t\t\t\treturn true;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tpreempt_enable();",
            "\treturn false;",
            "}"
          ],
          "function_name": "find_symbol, percpu_modalloc, percpu_modfree, find_pcpusec, percpu_modcopy, __is_module_percpu_address",
          "description": "提供符号查找核心实现，通过遍历内核符号表和模块符号表定位目标符号；实现Per-CPU数据区的动态分配、复制和释放机制，确保多CPU环境下模块数据的正确访问。",
          "similarity": 0.5663670301437378
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/module/main.c",
          "start_line": 1071,
          "end_line": 1218,
          "content": [
            "static int verify_namespace_is_imported(const struct load_info *info,",
            "\t\t\t\t\tconst struct kernel_symbol *sym,",
            "\t\t\t\t\tstruct module *mod)",
            "{",
            "\tconst char *namespace;",
            "\tchar *imported_namespace;",
            "",
            "\tnamespace = kernel_symbol_namespace(sym);",
            "\tif (namespace && namespace[0]) {",
            "\t\tfor_each_modinfo_entry(imported_namespace, info, \"import_ns\") {",
            "\t\t\tif (strcmp(namespace, imported_namespace) == 0)",
            "\t\t\t\treturn 0;",
            "\t\t}",
            "#ifdef CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS",
            "\t\tpr_warn(",
            "#else",
            "\t\tpr_err(",
            "#endif",
            "\t\t\t\"%s: module uses symbol (%s) from namespace %s, but does not import it.\\n\",",
            "\t\t\tmod->name, kernel_symbol_name(sym), namespace);",
            "#ifndef CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS",
            "\t\treturn -EINVAL;",
            "#endif",
            "\t}",
            "\treturn 0;",
            "}",
            "static bool inherit_taint(struct module *mod, struct module *owner, const char *name)",
            "{",
            "\tif (!owner || !test_bit(TAINT_PROPRIETARY_MODULE, &owner->taints))",
            "\t\treturn true;",
            "",
            "\tif (mod->using_gplonly_symbols) {",
            "\t\tpr_err(\"%s: module using GPL-only symbols uses symbols %s from proprietary module %s.\\n\",",
            "\t\t\tmod->name, name, owner->name);",
            "\t\treturn false;",
            "\t}",
            "",
            "\tif (!test_bit(TAINT_PROPRIETARY_MODULE, &mod->taints)) {",
            "\t\tpr_warn(\"%s: module uses symbols %s from proprietary module %s, inheriting taint.\\n\",",
            "\t\t\tmod->name, name, owner->name);",
            "\t\tset_bit(TAINT_PROPRIETARY_MODULE, &mod->taints);",
            "\t}",
            "\treturn true;",
            "}",
            "void __weak module_memfree(void *module_region)",
            "{",
            "\t/*",
            "\t * This memory may be RO, and freeing RO memory in an interrupt is not",
            "\t * supported by vmalloc.",
            "\t */",
            "\tWARN_ON(in_interrupt());",
            "\tvfree(module_region);",
            "}",
            "void __weak module_arch_cleanup(struct module *mod)",
            "{",
            "}",
            "void __weak module_arch_freeing_init(struct module *mod)",
            "{",
            "}",
            "static bool mod_mem_use_vmalloc(enum mod_mem_type type)",
            "{",
            "\treturn IS_ENABLED(CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC) &&",
            "\t\tmod_mem_type_is_core_data(type);",
            "}",
            "static void module_memory_free(void *ptr, enum mod_mem_type type,",
            "\t\t\t       bool unload_codetags)",
            "{",
            "\tif (!unload_codetags && mod_mem_type_is_core_data(type))",
            "\t\treturn;",
            "",
            "\tif (mod_mem_use_vmalloc(type))",
            "\t\tvfree(ptr);",
            "\telse",
            "\t\tmodule_memfree(ptr);",
            "}",
            "static void free_mod_mem(struct module *mod, bool unload_codetags)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tstruct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (type == MOD_DATA)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Free lock-classes; relies on the preceding sync_rcu(). */",
            "\t\tlockdep_free_key_range(mod_mem->base, mod_mem->size);",
            "\t\tif (mod_mem->size)",
            "\t\t\tmodule_memory_free(mod_mem->base, type,",
            "\t\t\t\t\t   unload_codetags);",
            "\t}",
            "",
            "\t/* MOD_DATA hosts mod, so free it at last */",
            "\tlockdep_free_key_range(mod->mem[MOD_DATA].base, mod->mem[MOD_DATA].size);",
            "\tmodule_memory_free(mod->mem[MOD_DATA].base, MOD_DATA, unload_codetags);",
            "}",
            "static void free_module(struct module *mod)",
            "{",
            "\tbool unload_codetags;",
            "",
            "\ttrace_module_free(mod);",
            "",
            "\tunload_codetags = codetag_unload_module(mod);",
            "\tif (!unload_codetags)",
            "\t\tpr_warn(\"%s: memory allocation(s) from the module still alive, cannot unload cleanly\\n\",",
            "\t\t\tmod->name);",
            "",
            "\tmod_sysfs_teardown(mod);",
            "",
            "\t/*",
            "\t * We leave it in list to prevent duplicate loads, but make sure",
            "\t * that noone uses it while it's being deconstructed.",
            "\t */",
            "\tmutex_lock(&module_mutex);",
            "\tmod->state = MODULE_STATE_UNFORMED;",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\t/* Arch-specific cleanup. */",
            "\tmodule_arch_cleanup(mod);",
            "",
            "\t/* Module unload stuff */",
            "\tmodule_unload_free(mod);",
            "",
            "\t/* Free any allocated parameters. */",
            "\tdestroy_params(mod->kp, mod->num_kp);",
            "",
            "\tif (is_livepatch_module(mod))",
            "\t\tfree_module_elf(mod);",
            "",
            "\t/* Now we can delete it from the lists */",
            "\tmutex_lock(&module_mutex);",
            "\t/* Unlink carefully: kallsyms could be walking list. */",
            "\tlist_del_rcu(&mod->list);",
            "\tmod_tree_remove(mod);",
            "\t/* Remove this module from bug list, this uses list_del_rcu */",
            "\tmodule_bug_cleanup(mod);",
            "\t/* Wait for RCU-sched synchronizing before releasing mod->list and buglist. */",
            "\tsynchronize_rcu();",
            "\tif (try_add_tainted_module(mod))",
            "\t\tpr_err(\"%s: adding tainted module to the unloaded tainted modules list failed.\\n\",",
            "\t\t       mod->name);",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\t/* This may be empty, but that's OK */",
            "\tmodule_arch_freeing_init(mod);",
            "\tkfree(mod->args);",
            "\tpercpu_modfree(mod);",
            "",
            "\tfree_mod_mem(mod, unload_codetags);",
            "}"
          ],
          "function_name": "verify_namespace_is_imported, inherit_taint, module_memfree, module_arch_cleanup, module_arch_freeing_init, mod_mem_use_vmalloc, module_memory_free, free_mod_mem, free_module",
          "description": "实现模块符号命名空间验证(verify_namespace_is_imported)、污点继承逻辑(herit_taint)、内存释放(module_memory_free/free_mod_mem)及架构特定清理(module_arch_cleanup/module_arch_freeing_init)，包含弱符号声明供架构扩展。",
          "similarity": 0.5633002519607544
        }
      ]
    }
  ]
}