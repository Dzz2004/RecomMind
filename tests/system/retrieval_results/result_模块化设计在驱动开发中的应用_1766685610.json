{
  "query": "模块化设计在驱动开发中的应用",
  "timestamp": "2025-12-26 02:00:10",
  "retrieved_files": [
    {
      "source_file": "kernel/usermode_driver.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:47:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `usermode_driver.c`\n\n---\n\n# usermode_driver.c 技术文档\n\n## 文件概述\n\n`usermode_driver.c` 实现了 Linux 内核中用户态驱动（User Mode Driver, UMD）的支持机制。该文件提供了一套 API，允许内核模块将一段可执行的二进制数据（blob）加载为临时文件系统中的可执行文件，并以此为基础 fork 出一个用户态进程作为驱动程序运行。该机制常用于需要在用户空间执行复杂逻辑但又需与内核紧密协作的驱动场景（如某些固件加载器、安全模块或虚拟设备驱动）。\n\n## 核心功能\n\n### 主要函数\n\n- `blob_to_mnt(const void *data, size_t len, const char *name)`  \n  将二进制数据写入 tmpfs 文件系统中，返回挂载点（vfsmount）。\n\n- `umd_load_blob(struct umd_info *info, const void *data, size_t len)`  \n  将给定的二进制 blob 加载为可执行文件，并关联到 `umd_info` 结构中。\n\n- `umd_unload_blob(struct umd_info *info)`  \n  卸载之前加载的 blob，释放相关文件系统资源。\n\n- `fork_usermode_driver(struct umd_info *info)`  \n  基于已加载的 blob fork 并执行一个用户态驱动进程。\n\n- `umd_setup(struct subprocess_info *info, struct cred *new)`  \n  在子进程中设置执行环境，包括创建通信管道、设置工作目录等。\n\n- `umd_cleanup(struct subprocess_info *info)`  \n  子进程执行失败时的清理回调。\n\n- `umd_cleanup_helper(struct umd_info *info)`  \n  释放 `umd_setup` 中分配的资源（管道、PID 等）。\n\n### 关键数据结构\n\n- `struct umd_info`  \n  描述用户态驱动的上下文信息，包含：\n  - `wd`：工作目录（`struct path`），指向 tmpfs 中的可执行文件所在目录\n  - `driver_name`：驱动程序在 tmpfs 中的文件名\n  - `pipe_to_umh` / `pipe_from_umh`：与用户态进程通信的双向管道\n  - `tgid`：用户态驱动进程的线程组 ID（用于后续管理）\n\n## 关键实现\n\n### Blob 到可执行文件的转换\n\n`blob_to_mnt()` 函数通过以下步骤将内存中的二进制数据转换为可执行文件：\n\n1. 挂载 `tmpfs` 文件系统（使用 `kern_mount()`）\n2. 在挂载点根目录下以指定名称创建文件（权限 `0700`）\n3. 使用 `kernel_write()` 将数据写入文件\n4. 调用 `flush_delayed_fput()` 和 `task_work_run()` 确保文件描述符延迟释放完成，以便后续 `exec` 能以只读方式打开该文件\n\n此机制避免了将驱动二进制写入磁盘，提高了安全性和灵活性。\n\n### 用户态驱动进程的启动\n\n`fork_usermode_driver()` 利用内核的 `call_usermodehelper` 机制：\n\n- 使用 `call_usermodehelper_setup()` 注册 `umd_setup` 作为子进程初始化回调\n- 在 `umd_setup` 中：\n  - 创建两个匿名管道：一个用于内核向用户态发送数据（stdin 重定向），一个用于用户态向内核返回数据（stdout 重定向）\n  - 使用 `replace_fd()` 将标准输入/输出重定向到管道端点\n  - 设置当前进程的 pwd（工作目录）为 tmpfs 挂载点，使 `exec` 能直接以相对路径执行驱动文件\n  - 保存管道文件指针和子进程 TGID 到 `umd_info`\n- 执行 `call_usermodehelper_exec()` 启动进程\n\n### 资源管理与错误处理\n\n- `umd_load_blob()` 和 `umd_unload_blob()` 通过 `WARN_ON_ONCE` 确保状态一致性（避免重复加载/卸载）\n- 若 `exec` 失败，`umd_cleanup` 回调会调用 `umd_cleanup_helper` 释放管道和 PID\n- 所有资源（vfsmount、file、pipe、pid）均通过内核标准接口分配和释放，确保无泄漏\n\n## 依赖关系\n\n- **文件系统**：依赖 `tmpfs`（通过 `get_fs_type(\"tmpfs\")`），用于临时存储可执行 blob\n- **进程管理**：依赖 `call_usermodehelper` 子系统（`linux/kmod.h` 隐式包含），用于 fork/exec 用户态进程\n- **VFS 层**：使用 `kern_mount`/`kern_unmount`、`file_open_root_mnt`、`kernel_write` 等 VFS 接口\n- **IPC 机制**：依赖管道（`create_pipe_files`）实现内核与用户态驱动的双向通信\n- **内存管理**：依赖 `shmem_fs.h`（tmpfs 底层基于共享内存）\n- **任务工作队列**：调用 `task_work_run()` 确保文件描述符及时释放\n\n## 使用场景\n\n1. **动态用户态驱动加载**  \n   内核模块可将嵌入的 ELF 二进制或脚本作为 blob 加载，无需预先安装到文件系统。\n\n2. **安全隔离驱动**  \n   将可能含漏洞的驱动逻辑移至用户空间运行，通过管道与内核通信，降低内核攻击面。\n\n3. **固件或微码加载器**  \n   某些设备需要复杂的固件初始化逻辑，可通过 UMD 在用户态执行，避免内核复杂性。\n\n4. **虚拟设备后端**  \n   如 virtio-user、vhost-user 等场景，内核前端通过 UMD 与用户态后端进程协作。\n\n5. **测试与原型开发**  \n   快速验证驱动逻辑，无需频繁编译内核模块，提高开发效率。\n\n> **注意**：调用者需负责用户态进程的生命周期管理（健康检查、信号终止、管道关闭等）。",
      "similarity": 0.5708872079849243,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 60,
          "end_line": 161,
          "content": [
            "int umd_load_blob(struct umd_info *info, const void *data, size_t len)",
            "{",
            "\tstruct vfsmount *mnt;",
            "",
            "\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))",
            "\t\treturn -EBUSY;",
            "",
            "\tmnt = blob_to_mnt(data, len, info->driver_name);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn PTR_ERR(mnt);",
            "",
            "\tinfo->wd.mnt = mnt;",
            "\tinfo->wd.dentry = mnt->mnt_root;",
            "\treturn 0;",
            "}",
            "int umd_unload_blob(struct umd_info *info)",
            "{",
            "\tif (WARN_ON_ONCE(!info->wd.mnt ||",
            "\t\t\t !info->wd.dentry ||",
            "\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))",
            "\t\treturn -EINVAL;",
            "",
            "\tkern_unmount(info->wd.mnt);",
            "\tinfo->wd.mnt = NULL;",
            "\tinfo->wd.dentry = NULL;",
            "\treturn 0;",
            "}",
            "static int umd_setup(struct subprocess_info *info, struct cred *new)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "\tstruct file *from_umh[2];",
            "\tstruct file *to_umh[2];",
            "\tint err;",
            "",
            "\t/* create pipe to send data to umh */",
            "\terr = create_pipe_files(to_umh, 0);",
            "\tif (err)",
            "\t\treturn err;",
            "\terr = replace_fd(0, to_umh[0], 0);",
            "\tfput(to_umh[0]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\t/* create pipe to receive data from umh */",
            "\terr = create_pipe_files(from_umh, 0);",
            "\tif (err) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\treturn err;",
            "\t}",
            "\terr = replace_fd(1, from_umh[1], 0);",
            "\tfput(from_umh[1]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\tfput(from_umh[0]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tset_fs_pwd(current->fs, &umd_info->wd);",
            "\tumd_info->pipe_to_umh = to_umh[1];",
            "\tumd_info->pipe_from_umh = from_umh[0];",
            "\tumd_info->tgid = get_pid(task_tgid(current));",
            "\treturn 0;",
            "}",
            "static void umd_cleanup(struct subprocess_info *info)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "",
            "\t/* cleanup if umh_setup() was successful but exec failed */",
            "\tif (info->retval)",
            "\t\tumd_cleanup_helper(umd_info);",
            "}",
            "void umd_cleanup_helper(struct umd_info *info)",
            "{",
            "\tfput(info->pipe_to_umh);",
            "\tfput(info->pipe_from_umh);",
            "\tput_pid(info->tgid);",
            "\tinfo->tgid = NULL;",
            "}",
            "int fork_usermode_driver(struct umd_info *info)",
            "{",
            "\tstruct subprocess_info *sub_info;",
            "\tconst char *argv[] = { info->driver_name, NULL };",
            "\tint err;",
            "",
            "\tif (WARN_ON_ONCE(info->tgid))",
            "\t\treturn -EBUSY;",
            "",
            "\terr = -ENOMEM;",
            "\tsub_info = call_usermodehelper_setup(info->driver_name,",
            "\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,",
            "\t\t\t\t\t     umd_setup, umd_cleanup, info);",
            "\tif (!sub_info)",
            "\t\tgoto out;",
            "",
            "\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);",
            "out:",
            "\treturn err;",
            "}"
          ],
          "function_name": "umd_load_blob, umd_unload_blob, umd_setup, umd_cleanup, umd_cleanup_helper, fork_usermode_driver",
          "description": "提供用户模式驱动程序的数据加载/卸载及子进程管理功能，包括挂载tmpfs、建立进程间管道通信、设置工作目录及清理资源，最终通过call_usermodehelper启动用户态驱动程序",
          "similarity": 0.5502430200576782
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * umd - User mode driver support",
            " */",
            "#include <linux/shmem_fs.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/usermode_driver.h>",
            "",
            "static struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)",
            "{",
            "\tstruct file_system_type *type;",
            "\tstruct vfsmount *mnt;",
            "\tstruct file *file;",
            "\tssize_t written;",
            "\tloff_t pos = 0;",
            "",
            "\ttype = get_fs_type(\"tmpfs\");",
            "\tif (!type)",
            "\t\treturn ERR_PTR(-ENODEV);",
            "",
            "\tmnt = kern_mount(type);",
            "\tput_filesystem(type);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn mnt;",
            "",
            "\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);",
            "\tif (IS_ERR(file)) {",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_CAST(file);",
            "\t}",
            "",
            "\twritten = kernel_write(file, data, len, &pos);",
            "\tif (written != len) {",
            "\t\tint err = written;",
            "\t\tif (err >= 0)",
            "\t\t\terr = -ENOMEM;",
            "\t\tfilp_close(file, NULL);",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_PTR(err);",
            "\t}",
            "",
            "\tfput(file);",
            "",
            "\t/* Flush delayed fput so exec can open the file read-only */",
            "\tflush_delayed_fput();",
            "\ttask_work_run();",
            "\treturn mnt;",
            "}",
            "",
            "/**",
            " * umd_load_blob - Remember a blob of bytes for fork_usermode_driver",
            " * @info: information about usermode driver",
            " * @data: a blob of bytes that can be executed as a file",
            " * @len:  The lentgh of the blob",
            " *",
            " */"
          ],
          "function_name": null,
          "description": "创建并挂载tmpfs文件系统以存储二进制数据，通过文件操作将输入数据写入新挂载点的指定名称文件，返回对应的vfsmount结构指针",
          "similarity": 0.42960020899772644
        }
      ]
    },
    {
      "source_file": "mm/zpool.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:37:17\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `zpool.c`\n\n---\n\n# zpool.c 技术文档\n\n## 文件概述\n\n`zpool.c` 是 Linux 内核中用于提供通用内存池抽象接口的实现文件。它作为压缩内存存储（如 zswap、zram）后端的统一前端，允许不同底层内存池实现（如 zbud、zsmalloc）通过标准接口被上层模块使用。该文件实现了驱动注册/注销、池创建/销毁、内存分配/释放等核心功能，并支持运行时动态加载对应的内存池模块。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct zpool`**  \n  表示一个具体的内存池实例，包含指向驱动和底层池对象的指针。\n  ```c\n  struct zpool {\n      struct zpool_driver *driver;  // 指向注册的驱动\n      void *pool;                   // 底层驱动管理的实际池对象\n  };\n  ```\n\n- **`drivers_head` 和 `drivers_lock`**  \n  全局链表和自旋锁，用于管理所有已注册的 `zpool_driver` 实例。\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|----------|\n| `zpool_register_driver()` | 注册一个新的 zpool 驱动实现 |\n| `zpool_unregister_driver()` | 注销 zpool 驱动（需确保未被使用） |\n| `zpool_has_pool()` | 检查指定类型的内存池是否可用（可触发模块加载） |\n| `zpool_create_pool()` | 创建指定类型和名称的新内存池 |\n| `zpool_destroy_pool()` | 销毁已存在的内存池 |\n| `zpool_get_type()` | 获取内存池的类型字符串 |\n| `zpool_malloc_support_movable()` | 查询池是否支持可移动内存分配 |\n| `zpool_malloc()` | 从池中分配指定大小的内存 |\n| `zpool_free()` | 释放通过 handle 分配的内存 |\n| `zpool_map_handle()` | 将 handle 映射为可访问的虚拟地址（代码截断，但声明存在） |\n\n## 关键实现\n\n### 驱动注册与引用计数\n- 使用全局链表 `drivers_head` 管理所有已注册的 `zpool_driver`。\n- 通过 `atomic_t refcount` 跟踪驱动使用次数，防止在使用中被卸载。\n- `zpool_get_driver()` 在获取驱动时增加引用计数并调用 `try_module_get()` 增加模块引用。\n- `zpool_put_driver()` 在释放时减少引用计数并调用 `module_put()`。\n\n### 动态模块加载\n- `zpool_has_pool()` 和 `zpool_create_pool()` 在找不到驱动时会调用 `request_module(\"zpool-%s\", type)` 尝试加载对应内核模块（如 `zpool-zbud`）。\n- 模块加载成功后再次尝试获取驱动，提高灵活性。\n\n### 内存池生命周期管理\n- `zpool_create_pool()`：分配 `struct zpool` 结构体，调用驱动的 `create()` 方法初始化底层池。\n- `zpool_destroy_pool()`：调用驱动的 `destroy()` 方法清理资源，释放结构体内存，并减少驱动引用。\n- 所有操作均保证线程安全（由底层驱动实现保证）。\n\n### GFP 标志传递\n- 创建池和分配内存时传入 `gfp_t` 标志，允许上层控制内存分配行为（如是否可睡眠、是否使用高端内存等）。\n- 底层驱动可根据自身能力选择是否使用这些标志。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/zpool.h>`：定义了 `zpool_driver`、`zpool` 等核心接口结构。\n  - `<linux/module.h>`：提供模块加载/卸载和引用计数支持。\n  - `<linux/slab.h>`：用于 `kmalloc/kfree` 分配 `struct zpool`。\n  - `<linux/spinlock.h>`：保护驱动注册链表的并发访问。\n  - `<linux/mm.h>`：提供内存管理相关定义（如 `gfp_t`）。\n\n- **模块依赖**：\n  - 依赖具体的 zpool 实现模块（如 `zbud.ko`、`zsmalloc.ko`），这些模块通过 `zpool_register_driver()` 注册自身。\n  - 通过 `request_module()` 机制动态加载后端实现模块。\n\n## 使用场景\n\n- **zswap**：作为透明页交换压缩缓存的后端存储，使用 zpool 接口分配/释放压缩页内存。\n- **zram**：作为基于 RAM 的块设备，使用 zpool 管理压缩数据的存储空间。\n- **其他需要统一内存池接口的子系统**：任何需要将压缩数据暂存于内存且希望支持多种后端分配器的场景。\n\n该文件通过抽象层解耦了上层使用者与底层内存分配实现，使得内核可以灵活切换不同的压缩内存管理策略（如 zbud 的 buddy-like 算法 vs zsmalloc 的 slab-like 算法），同时保持上层代码不变。",
      "similarity": 0.5530152916908264,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "mm/zpool.c",
          "start_line": 1,
          "end_line": 32,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * zpool memory storage api",
            " *",
            " * Copyright (C) 2014 Dan Streetman",
            " *",
            " * This is a common frontend for memory storage pool implementations.",
            " * Typically, this is used to store compressed memory.",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/list.h>",
            "#include <linux/types.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/zpool.h>",
            "",
            "struct zpool {",
            "\tstruct zpool_driver *driver;",
            "\tvoid *pool;",
            "};",
            "",
            "static LIST_HEAD(drivers_head);",
            "static DEFINE_SPINLOCK(drivers_lock);",
            "",
            "/**",
            " * zpool_register_driver() - register a zpool implementation.",
            " * @driver:\tdriver to register",
            " */"
          ],
          "function_name": null,
          "description": "定义zpool模块框架，包含zpool结构体及驱动程序管理相关数据结构，提供驱动注册接口但未完成完整实现",
          "similarity": 0.5760870575904846
        },
        {
          "chunk_id": 1,
          "file_path": "mm/zpool.c",
          "start_line": 33,
          "end_line": 107,
          "content": [
            "void zpool_register_driver(struct zpool_driver *driver)",
            "{",
            "\tspin_lock(&drivers_lock);",
            "\tatomic_set(&driver->refcount, 0);",
            "\tlist_add(&driver->list, &drivers_head);",
            "\tspin_unlock(&drivers_lock);",
            "}",
            "int zpool_unregister_driver(struct zpool_driver *driver)",
            "{",
            "\tint ret = 0, refcount;",
            "",
            "\tspin_lock(&drivers_lock);",
            "\trefcount = atomic_read(&driver->refcount);",
            "\tWARN_ON(refcount < 0);",
            "\tif (refcount > 0)",
            "\t\tret = -EBUSY;",
            "\telse",
            "\t\tlist_del(&driver->list);",
            "\tspin_unlock(&drivers_lock);",
            "",
            "\treturn ret;",
            "}",
            "static void zpool_put_driver(struct zpool_driver *driver)",
            "{",
            "\tatomic_dec(&driver->refcount);",
            "\tmodule_put(driver->owner);",
            "}",
            "bool zpool_has_pool(char *type)",
            "{",
            "\tstruct zpool_driver *driver = zpool_get_driver(type);",
            "",
            "\tif (!driver) {",
            "\t\trequest_module(\"zpool-%s\", type);",
            "\t\tdriver = zpool_get_driver(type);",
            "\t}",
            "",
            "\tif (!driver)",
            "\t\treturn false;",
            "",
            "\tzpool_put_driver(driver);",
            "\treturn true;",
            "}",
            "void zpool_destroy_pool(struct zpool *zpool)",
            "{",
            "\tpr_debug(\"destroying pool type %s\\n\", zpool->driver->type);",
            "",
            "\tzpool->driver->destroy(zpool->pool);",
            "\tzpool_put_driver(zpool->driver);",
            "\tkfree(zpool);",
            "}",
            "bool zpool_malloc_support_movable(struct zpool *zpool)",
            "{",
            "\treturn zpool->driver->malloc_support_movable;",
            "}",
            "int zpool_malloc(struct zpool *zpool, size_t size, gfp_t gfp,",
            "\t\t\tunsigned long *handle)",
            "{",
            "\treturn zpool->driver->malloc(zpool->pool, size, gfp, handle);",
            "}",
            "void zpool_free(struct zpool *zpool, unsigned long handle)",
            "{",
            "\tzpool->driver->free(zpool->pool, handle);",
            "}",
            "void zpool_unmap_handle(struct zpool *zpool, unsigned long handle)",
            "{",
            "\tzpool->driver->unmap(zpool->pool, handle);",
            "}",
            "u64 zpool_get_total_size(struct zpool *zpool)",
            "{",
            "\treturn zpool->driver->total_size(zpool->pool);",
            "}",
            "bool zpool_can_sleep_mapped(struct zpool *zpool)",
            "{",
            "\treturn zpool->driver->sleep_mapped;",
            "}"
          ],
          "function_name": "zpool_register_driver, zpool_unregister_driver, zpool_put_driver, zpool_has_pool, zpool_destroy_pool, zpool_malloc_support_movable, zpool_malloc, zpool_free, zpool_unmap_handle, zpool_get_total_size, zpool_can_sleep_mapped",
          "description": "实现zpool驱动程序的注册/注销逻辑，管理内存池生命周期，封装底层驱动接口供上层调用，包含内存分配/释放/unmap等核心操作函数",
          "similarity": 0.5676511526107788
        }
      ]
    },
    {
      "source_file": "kernel/module/main.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:04:44\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\main.c`\n\n---\n\n# `module/main.c` 技术文档\n\n## 1. 文件概述\n\n`module/main.c` 是 Linux 内核模块子系统的核心实现文件，负责模块的加载、卸载、符号解析、内存管理、状态跟踪以及模块间依赖关系的维护。该文件实现了内核模块机制的基础框架，包括模块列表管理、模块内存布局控制、符号查找、模块通知机制、模块引用计数等关键功能，是内核动态加载模块能力的核心支撑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct mod_tree_root mod_tree`**：用于加速地址到模块映射的全局模块地址范围树，包含 `addr_min`/`addr_max`（及可选的 `data_addr_min`/`data_addr_max`）。\n- **`LIST_HEAD(modules)`**：全局模块链表，存储所有已加载模块。\n- **`DEFINE_MUTEX(module_mutex)`**：保护模块列表、模块使用关系及地址边界的关键互斥锁。\n- **`struct symsearch`**：用于描述符号搜索范围，包含符号起止位置、CRC 校验数组及许可证类型。\n- **`struct find_symbol_arg`**：符号查找的参数结构体，用于传递查找目标及接收结果（所有者、符号指针、CRC、许可证等）。\n\n### 主要函数与接口\n\n- **模块注册/注销通知**：\n  - `register_module_notifier()` / `unregister_module_notifier()`：注册/注销模块生命周期事件通知回调。\n- **模块引用管理**：\n  - `strong_try_module_get()`：强引用获取，拒绝处于 `COMING` 状态的模块。\n  - `__module_put_and_kthread_exit()`：专用于内核线程在退出前释放模块引用。\n- **模块内存边界管理**：\n  - `__mod_update_bounds()` / `mod_update_bounds()`：更新全局模块地址范围，用于加速 `__module_address()`。\n- **ELF 节区辅助函数**：\n  - `find_sec()` / `find_any_sec()`：根据名称查找 ELF 节区索引。\n  - `section_addr()` / `section_objs()`：获取节区地址及对象数量。\n- **符号查找**：\n  - `find_symbol()`：在内核及已加载模块中查找导出符号。\n  - `find_exported_symbol_in_section()`：在指定符号段中二分查找符号。\n- **模块状态与安全**：\n  - `add_taint_module()`：为模块添加污点标记（taint flag）。\n- **全局控制**：\n  - `modules_disabled`：通过 `nomodule` 内核参数控制是否禁用模块加载。\n\n### 全局变量与工作队列\n\n- **`init_free_wq`**：用于异步释放模块初始化段（`.init`）内存的工作队列。\n- **`init_free_list`**：待释放初始化内存的无锁链表。\n- **`module_wq`**：等待模块初始化完成的等待队列。\n\n## 3. 关键实现\n\n### 模块地址范围加速\n\n通过 `mod_tree` 全局结构维护所有模块（或核心数据）的最小/最大虚拟地址。`__module_address()` 可先检查目标地址是否落在 `[addr_min, addr_max]` 范围内，若不在则直接返回 `NULL`，避免遍历整个模块链表，显著提升性能。\n\n### 符号查找机制\n\n- 使用 `bsearch()` 在已排序的导出符号表中进行二分查找，时间复杂度为 O(log n)。\n- 支持符号命名空间（namespace）和 GPL 许可证检查：非 GPL 模块无法使用 `GPL_ONLY` 符号。\n- 通过 `symsearch` 数组统一管理内核及各模块的符号段，实现统一查找接口。\n\n### 模块内存管理\n\n- 模块内存按 `mod_mem_type`（如代码、只读数据、可写数据、初始化段等）分类管理。\n- 初始化段（`.init`）在模块初始化成功后通过工作队列异步释放，节省内存。\n- 支持 `CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC` 架构选项，将模块数据段单独纳入地址范围管理。\n\n### 模块状态与引用安全\n\n- `strong_try_module_get()` 确保不会对处于 `MODULE_STATE_COMING`（正在初始化）或 `MODULE_STATE_UNFORMED`（未形成）状态的模块增加引用，防止竞态。\n- `__module_put_and_kthread_exit()` 为内核线程提供安全退出路径，在释放模块引用后终止线程。\n\n### 模块通知机制\n\n基于 `blocking_notifier_chain` 实现模块生命周期事件（如加载、卸载、初始化完成等）的通知，允许其他子系统（如 livepatch、ftrace）监听并响应模块状态变化。\n\n### 构建标识与版本校验\n\n- 通过 `INCLUDE_VERMAGIC` 宏包含模块魔数（vermagic）信息，用于加载时内核版本兼容性检查。\n- 支持 `CONFIG_MODVERSIONS`，在符号查找时返回 CRC 校验值，确保符号 ABI 兼容性。\n\n## 4. 依赖关系\n\n- **架构相关**：\n  - 依赖 `asm/cacheflush.h`、`asm/mmu_context.h`、`asm/sections.h` 等架构头文件，处理指令缓存刷新、内存映射等。\n  - 使用 `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 优化符号字符串存储。\n- **内核子系统**：\n  - **内存管理**：`vmalloc`、`slab` 用于模块内存分配。\n  - **安全机制**：`capability`、`audit`、`module_signature` 用于模块加载权限和签名验证。\n  - **调试与追踪**：`kallsyms`、`trace_events`、`ftrace`、`dynamic_debug`、`debugfs` 提供模块调试支持。\n  - **并发控制**：`RCU`、`mutex`、`percpu` 用于同步。\n  - **文件系统**：`fs.h`、`kernel_read_file.h` 用于从文件加载模块。\n- **内部依赖**：\n  - 依赖同目录下的 `internal.h`，包含模块子系统内部数据结构和函数声明。\n  - 使用 `uapi/linux/module.h` 定义用户空间接口常量。\n\n## 5. 使用场景\n\n- **动态加载内核模块**：通过 `init_module()` 或 `finit_module()` 系统调用加载 `.ko` 文件时，该文件中的函数负责解析 ELF、重定位、符号解析、执行初始化函数。\n- **模块卸载**：通过 `delete_module()` 系统调用卸载模块时，管理模块引用计数、执行清理函数、释放内存。\n- **内核符号解析**：当模块或内核其他部分调用 `symbol_get()` 或通过 `EXPORT_SYMBOL` 机制访问符号时，`find_symbol()` 被调用。\n- **运行时模块查询**：`/proc/modules`、`/sys/module/` 等接口依赖此文件维护的模块列表和状态信息。\n- **内核热补丁（Livepatch）**：依赖模块通知机制和符号查找功能实现函数替换。\n- **内核调试与性能分析**：ftrace、kprobes 等工具依赖模块地址范围和符号信息进行函数跟踪。",
      "similarity": 0.5478307008743286,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/module/main.c",
          "start_line": 1,
          "end_line": 95,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Copyright (C) 2002 Richard Henderson",
            " * Copyright (C) 2001 Rusty Russell, 2002, 2010 Rusty Russell IBM.",
            " * Copyright (C) 2023 Luis Chamberlain <mcgrof@kernel.org>",
            " */",
            "",
            "#define INCLUDE_VERMAGIC",
            "",
            "#include <linux/export.h>",
            "#include <linux/extable.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buildid.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kstrtox.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/elf.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/cpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/notifier.h>",
            "#include <linux/sched.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/license.h>",
            "#include <asm/sections.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/async.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/pfn.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/audit.h>",
            "#include <linux/cfi.h>",
            "#include <linux/codetag.h>",
            "#include <linux/debugfs.h>",
            "#include <uapi/linux/module.h>",
            "#include \"internal.h\"",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/module.h>",
            "",
            "/*",
            " * Mutex protects:",
            " * 1) List of modules (also safely readable with preempt_disable),",
            " * 2) module_use links,",
            " * 3) mod_tree.addr_min/mod_tree.addr_max.",
            " * (delete and add uses RCU list operations).",
            " */",
            "DEFINE_MUTEX(module_mutex);",
            "LIST_HEAD(modules);",
            "",
            "/* Work queue for freeing init sections in success case */",
            "static void do_free_init(struct work_struct *w);",
            "static DECLARE_WORK(init_free_wq, do_free_init);",
            "static LLIST_HEAD(init_free_list);",
            "",
            "struct mod_tree_root mod_tree __cacheline_aligned = {",
            "\t.addr_min = -1UL,",
            "};",
            "",
            "struct symsearch {",
            "\tconst struct kernel_symbol *start, *stop;",
            "\tconst s32 *crcs;",
            "\tenum mod_license license;",
            "};",
            "",
            "/*",
            " * Bounds of module memory, for speeding up __module_address.",
            " * Protected by module_mutex.",
            " */"
          ],
          "function_name": null,
          "description": "定义模块加载器的基础结构，包括模块互斥锁（module_mutex）、模块链表（modules）及用于记录模块内存范围的mod_tree结构体，为后续模块管理和地址查询提供数据支撑。",
          "similarity": 0.5608412027359009
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/main.c",
          "start_line": 96,
          "end_line": 202,
          "content": [
            "static void __mod_update_bounds(enum mod_mem_type type __maybe_unused, void *base,",
            "\t\t\t\tunsigned int size, struct mod_tree_root *tree)",
            "{",
            "\tunsigned long min = (unsigned long)base;",
            "\tunsigned long max = min + size;",
            "",
            "#ifdef CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC",
            "\tif (mod_mem_type_is_core_data(type)) {",
            "\t\tif (min < tree->data_addr_min)",
            "\t\t\ttree->data_addr_min = min;",
            "\t\tif (max > tree->data_addr_max)",
            "\t\t\ttree->data_addr_max = max;",
            "\t\treturn;",
            "\t}",
            "#endif",
            "\tif (min < tree->addr_min)",
            "\t\ttree->addr_min = min;",
            "\tif (max > tree->addr_max)",
            "\t\ttree->addr_max = max;",
            "}",
            "static void mod_update_bounds(struct module *mod)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tstruct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (mod_mem->size)",
            "\t\t\t__mod_update_bounds(type, mod_mem->base, mod_mem->size, &mod_tree);",
            "\t}",
            "}",
            "int register_module_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&module_notify_list, nb);",
            "}",
            "int unregister_module_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);",
            "}",
            "static inline int strong_try_module_get(struct module *mod)",
            "{",
            "\tBUG_ON(mod && mod->state == MODULE_STATE_UNFORMED);",
            "\tif (mod && mod->state == MODULE_STATE_COMING)",
            "\t\treturn -EBUSY;",
            "\tif (try_module_get(mod))",
            "\t\treturn 0;",
            "\telse",
            "\t\treturn -ENOENT;",
            "}",
            "static inline void add_taint_module(struct module *mod, unsigned flag,",
            "\t\t\t\t    enum lockdep_ok lockdep_ok)",
            "{",
            "\tadd_taint(flag, lockdep_ok);",
            "\tset_bit(flag, &mod->taints);",
            "}",
            "void __noreturn __module_put_and_kthread_exit(struct module *mod, long code)",
            "{",
            "\tmodule_put(mod);",
            "\tkthread_exit(code);",
            "}",
            "static unsigned int find_sec(const struct load_info *info, const char *name)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\t/* Alloc bit cleared means \"ignore it.\" */",
            "\t\tif ((shdr->sh_flags & SHF_ALLOC)",
            "\t\t    && strcmp(info->secstrings + shdr->sh_name, name) == 0)",
            "\t\t\treturn i;",
            "\t}",
            "\treturn 0;",
            "}",
            "static unsigned int find_any_sec(const struct load_info *info, const char *name)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\tif (strcmp(info->secstrings + shdr->sh_name, name) == 0)",
            "\t\t\treturn i;",
            "\t}",
            "\treturn 0;",
            "}",
            "int cmp_name(const void *name, const void *sym)",
            "{",
            "\treturn strcmp(name, kernel_symbol_name(sym));",
            "}",
            "static bool find_exported_symbol_in_section(const struct symsearch *syms,",
            "\t\t\t\t\t    struct module *owner,",
            "\t\t\t\t\t    struct find_symbol_arg *fsa)",
            "{",
            "\tstruct kernel_symbol *sym;",
            "",
            "\tif (!fsa->gplok && syms->license == GPL_ONLY)",
            "\t\treturn false;",
            "",
            "\tsym = bsearch(fsa->name, syms->start, syms->stop - syms->start,",
            "\t\t\tsizeof(struct kernel_symbol), cmp_name);",
            "\tif (!sym)",
            "\t\treturn false;",
            "",
            "\tfsa->owner = owner;",
            "\tfsa->crc = symversion(syms->crcs, sym - syms->start);",
            "\tfsa->sym = sym;",
            "\tfsa->license = syms->license;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "__mod_update_bounds, mod_update_bounds, register_module_notifier, unregister_module_notifier, strong_try_module_get, add_taint_module, __module_put_and_kthread_exit, find_sec, find_any_sec, cmp_name, find_exported_symbol_in_section",
          "description": "实现模块内存边界更新逻辑、模块状态变更通知注册与注销接口，以及强引用获取检查函数，用于维护模块内存范围并控制模块生命周期事件。",
          "similarity": 0.5573874711990356
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/module/main.c",
          "start_line": 460,
          "end_line": 567,
          "content": [
            "bool is_module_percpu_address(unsigned long addr)",
            "{",
            "\treturn __is_module_percpu_address(addr, NULL);",
            "}",
            "static int percpu_modalloc(struct module *mod, struct load_info *info)",
            "{",
            "\t/* UP modules shouldn't have this section: ENOMEM isn't quite right */",
            "\tif (info->sechdrs[info->index.pcpu].sh_size != 0)",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "static inline void percpu_modfree(struct module *mod)",
            "{",
            "}",
            "static unsigned int find_pcpusec(struct load_info *info)",
            "{",
            "\treturn 0;",
            "}",
            "static inline void percpu_modcopy(struct module *mod,",
            "\t\t\t\t  const void *from, unsigned long size)",
            "{",
            "\t/* pcpusec should be 0, and size of that section should be 0. */",
            "\tBUG_ON(size != 0);",
            "}",
            "bool is_module_percpu_address(unsigned long addr)",
            "{",
            "\treturn false;",
            "}",
            "bool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)",
            "{",
            "\treturn false;",
            "}",
            "static int module_unload_init(struct module *mod)",
            "{",
            "\t/*",
            "\t * Initialize reference counter to MODULE_REF_BASE.",
            "\t * refcnt == 0 means module is going.",
            "\t */",
            "\tatomic_set(&mod->refcnt, MODULE_REF_BASE);",
            "",
            "\tINIT_LIST_HEAD(&mod->source_list);",
            "\tINIT_LIST_HEAD(&mod->target_list);",
            "",
            "\t/* Hold reference count during initialization. */",
            "\tatomic_inc(&mod->refcnt);",
            "",
            "\treturn 0;",
            "}",
            "static int already_uses(struct module *a, struct module *b)",
            "{",
            "\tstruct module_use *use;",
            "",
            "\tlist_for_each_entry(use, &b->source_list, source_list) {",
            "\t\tif (use->source == a)",
            "\t\t\treturn 1;",
            "\t}",
            "\tpr_debug(\"%s does not use %s!\\n\", a->name, b->name);",
            "\treturn 0;",
            "}",
            "static int add_module_usage(struct module *a, struct module *b)",
            "{",
            "\tstruct module_use *use;",
            "",
            "\tpr_debug(\"Allocating new usage for %s.\\n\", a->name);",
            "\tuse = kmalloc(sizeof(*use), GFP_ATOMIC);",
            "\tif (!use)",
            "\t\treturn -ENOMEM;",
            "",
            "\tuse->source = a;",
            "\tuse->target = b;",
            "\tlist_add(&use->source_list, &b->source_list);",
            "\tlist_add(&use->target_list, &a->target_list);",
            "\treturn 0;",
            "}",
            "static int ref_module(struct module *a, struct module *b)",
            "{",
            "\tint err;",
            "",
            "\tif (b == NULL || already_uses(a, b))",
            "\t\treturn 0;",
            "",
            "\t/* If module isn't available, we fail. */",
            "\terr = strong_try_module_get(b);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = add_module_usage(a, b);",
            "\tif (err) {",
            "\t\tmodule_put(b);",
            "\t\treturn err;",
            "\t}",
            "\treturn 0;",
            "}",
            "static void module_unload_free(struct module *mod)",
            "{",
            "\tstruct module_use *use, *tmp;",
            "",
            "\tmutex_lock(&module_mutex);",
            "\tlist_for_each_entry_safe(use, tmp, &mod->target_list, target_list) {",
            "\t\tstruct module *i = use->target;",
            "\t\tpr_debug(\"%s unusing %s\\n\", mod->name, i->name);",
            "\t\tmodule_put(i);",
            "\t\tlist_del(&use->source_list);",
            "\t\tlist_del(&use->target_list);",
            "\t\tkfree(use);",
            "\t}",
            "\tmutex_unlock(&module_mutex);",
            "}"
          ],
          "function_name": "is_module_percpu_address, percpu_modalloc, percpu_modfree, find_pcpusec, percpu_modcopy, is_module_percpu_address, __is_module_percpu_address, module_unload_init, already_uses, add_module_usage, ref_module, module_unload_free",
          "description": "包含模块卸载初始化逻辑，管理模块间依赖关系（通过module_use结构），实现模块引用计数调整及依赖链清理，在模块卸载时安全解除其他模块对其的依赖。",
          "similarity": 0.5539695024490356
        },
        {
          "chunk_id": 16,
          "file_path": "kernel/module/main.c",
          "start_line": 3116,
          "end_line": 3223,
          "content": [
            "static bool idempotent(struct idempotent *u, const void *cookie)",
            "{",
            "\tint hash = hash_ptr(cookie, IDEM_HASH_BITS);",
            "\tstruct hlist_head *head = idem_hash + hash;",
            "\tstruct idempotent *existing;",
            "\tbool first;",
            "",
            "\tu->ret = -EINTR;",
            "\tu->cookie = cookie;",
            "\tinit_completion(&u->complete);",
            "",
            "\tspin_lock(&idem_lock);",
            "\tfirst = true;",
            "\thlist_for_each_entry(existing, head, entry) {",
            "\t\tif (existing->cookie != cookie)",
            "\t\t\tcontinue;",
            "\t\tfirst = false;",
            "\t\tbreak;",
            "\t}",
            "\thlist_add_head(&u->entry, idem_hash + hash);",
            "\tspin_unlock(&idem_lock);",
            "",
            "\treturn !first;",
            "}",
            "static int idempotent_complete(struct idempotent *u, int ret)",
            "{",
            "\tconst void *cookie = u->cookie;",
            "\tint hash = hash_ptr(cookie, IDEM_HASH_BITS);",
            "\tstruct hlist_head *head = idem_hash + hash;",
            "\tstruct hlist_node *next;",
            "\tstruct idempotent *pos;",
            "",
            "\tspin_lock(&idem_lock);",
            "\thlist_for_each_entry_safe(pos, next, head, entry) {",
            "\t\tif (pos->cookie != cookie)",
            "\t\t\tcontinue;",
            "\t\thlist_del_init(&pos->entry);",
            "\t\tpos->ret = ret;",
            "\t\tcomplete(&pos->complete);",
            "\t}",
            "\tspin_unlock(&idem_lock);",
            "\treturn ret;",
            "}",
            "static int idempotent_wait_for_completion(struct idempotent *u)",
            "{",
            "\tif (wait_for_completion_interruptible(&u->complete)) {",
            "\t\tspin_lock(&idem_lock);",
            "\t\tif (!hlist_unhashed(&u->entry))",
            "\t\t\thlist_del(&u->entry);",
            "\t\tspin_unlock(&idem_lock);",
            "\t}",
            "\treturn u->ret;",
            "}",
            "static int init_module_from_file(struct file *f, const char __user * uargs, int flags)",
            "{",
            "\tstruct load_info info = { };",
            "\tvoid *buf = NULL;",
            "\tint len;",
            "",
            "\tlen = kernel_read_file(f, 0, &buf, INT_MAX, NULL, READING_MODULE);",
            "\tif (len < 0) {",
            "\t\tmod_stat_inc(&failed_kreads);",
            "\t\treturn len;",
            "\t}",
            "",
            "\tif (flags & MODULE_INIT_COMPRESSED_FILE) {",
            "\t\tint err = module_decompress(&info, buf, len);",
            "\t\tvfree(buf); /* compressed data is no longer needed */",
            "\t\tif (err) {",
            "\t\t\tmod_stat_inc(&failed_decompress);",
            "\t\t\tmod_stat_add_long(len, &invalid_decompress_bytes);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t} else {",
            "\t\tinfo.hdr = buf;",
            "\t\tinfo.len = len;",
            "\t}",
            "",
            "\treturn load_module(&info, uargs, flags);",
            "}",
            "static int idempotent_init_module(struct file *f, const char __user * uargs, int flags)",
            "{",
            "\tstruct idempotent idem;",
            "",
            "\tif (!(f->f_mode & FMODE_READ))",
            "\t\treturn -EBADF;",
            "",
            "\t/* Are we the winners of the race and get to do this? */",
            "\tif (!idempotent(&idem, file_inode(f))) {",
            "\t\tint ret = init_module_from_file(f, uargs, flags);",
            "\t\treturn idempotent_complete(&idem, ret);",
            "\t}",
            "",
            "\t/*",
            "\t * Somebody else won the race and is loading the module.",
            "\t */",
            "\treturn idempotent_wait_for_completion(&idem);",
            "}",
            "bool is_module_address(unsigned long addr)",
            "{",
            "\tbool ret;",
            "",
            "\tpreempt_disable();",
            "\tret = __module_address(addr) != NULL;",
            "\tpreempt_enable();",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "idempotent, idempotent_complete, idempotent_wait_for_completion, init_module_from_file, idempotent_init_module, is_module_address",
          "description": "idempotent 系列函数实现幂等性控制，通过哈希表防止重复模块加载；init_module_from_file 解析模块文件并调用load_module加载",
          "similarity": 0.5474182963371277
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/module/main.c",
          "start_line": 1925,
          "end_line": 2029,
          "content": [
            "static int copy_chunked_from_user(void *dst, const void __user *usrc, unsigned long len)",
            "{",
            "\tdo {",
            "\t\tunsigned long n = min(len, COPY_CHUNK_SIZE);",
            "",
            "\t\tif (copy_from_user(dst, usrc, n) != 0)",
            "\t\t\treturn -EFAULT;",
            "\t\tcond_resched();",
            "\t\tdst += n;",
            "\t\tusrc += n;",
            "\t\tlen -= n;",
            "\t} while (len);",
            "\treturn 0;",
            "}",
            "static int check_modinfo_livepatch(struct module *mod, struct load_info *info)",
            "{",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (!get_modinfo(info, \"livepatch\")) {",
            "\t\tset_mod_klp_rel_state(mod, MODULE_KLP_REL_NONE);",
            "\t\treturn 0;",
            "\t}",
            "\tset_mod_klp_rel_state(mod, MODULE_KLP_REL_UNDO);",
            "#else /* !CONFIG_LIVEPATCH_WO_FTRACE */",
            "\tif (!get_modinfo(info, \"livepatch\"))",
            "\t\t/* Nothing more to do */",
            "\t\treturn 0;",
            "#endif /* CONFIG_LIVEPATCH_WO_FTRACE */",
            "",
            "\tif (set_livepatch_module(mod))",
            "\t\treturn 0;",
            "",
            "\tpr_err(\"%s: module is marked as livepatch module, but livepatch support is disabled\",",
            "\t       mod->name);",
            "\treturn -ENOEXEC;",
            "}",
            "static void check_modinfo_retpoline(struct module *mod, struct load_info *info)",
            "{",
            "\tif (retpoline_module_ok(get_modinfo(info, \"retpoline\")))",
            "\t\treturn;",
            "",
            "\tpr_warn(\"%s: loading module not compiled with retpoline compiler.\\n\",",
            "\t\tmod->name);",
            "}",
            "static int copy_module_from_user(const void __user *umod, unsigned long len,",
            "\t\t\t\t  struct load_info *info)",
            "{",
            "\tint err;",
            "",
            "\tinfo->len = len;",
            "\tif (info->len < sizeof(*(info->hdr)))",
            "\t\treturn -ENOEXEC;",
            "",
            "\terr = security_kernel_load_data(LOADING_MODULE, true);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\t/* Suck in entire file: we'll want most of it. */",
            "\tinfo->hdr = __vmalloc(info->len, GFP_KERNEL | __GFP_NOWARN);",
            "\tif (!info->hdr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (copy_chunked_from_user(info->hdr, umod, info->len) != 0) {",
            "\t\terr = -EFAULT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\terr = security_kernel_post_load_data((char *)info->hdr, info->len,",
            "\t\t\t\t\t     LOADING_MODULE, \"init_module\");",
            "out:",
            "\tif (err)",
            "\t\tvfree(info->hdr);",
            "",
            "\treturn err;",
            "}",
            "static void free_copy(struct load_info *info, int flags)",
            "{",
            "\tif (flags & MODULE_INIT_COMPRESSED_FILE)",
            "\t\tmodule_decompress_cleanup(info);",
            "\telse",
            "\t\tvfree(info->hdr);",
            "}",
            "static int rewrite_section_headers(struct load_info *info, int flags)",
            "{",
            "\tunsigned int i;",
            "",
            "\t/* This should always be true, but let's be sure. */",
            "\tinfo->sechdrs[0].sh_addr = 0;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "",
            "\t\t/*",
            "\t\t * Mark all sections sh_addr with their address in the",
            "\t\t * temporary image.",
            "\t\t */",
            "\t\tshdr->sh_addr = (size_t)info->hdr + shdr->sh_offset;",
            "",
            "\t}",
            "",
            "\t/* Track but don't keep modinfo and version sections. */",
            "\tinfo->sechdrs[info->index.vers].sh_flags &= ~(unsigned long)SHF_ALLOC;",
            "\tinfo->sechdrs[info->index.info].sh_flags &= ~(unsigned long)SHF_ALLOC;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "copy_chunked_from_user, check_modinfo_livepatch, check_modinfo_retpoline, copy_module_from_user, free_copy, rewrite_section_headers",
          "description": "实现分块从用户空间复制数据到内核缓冲区，检查模块livepatch属性，校验retpoline标志，复制模块元信息到内核，释放动态分配的模块数据，重写ELF节头地址以匹配实际内存布局",
          "similarity": 0.5437132120132446
        }
      ]
    }
  ]
}