{
  "query": "Buddy System 与 Page Fragmentation 关联分析",
  "timestamp": "2025-12-26 00:08:34",
  "retrieved_files": [
    {
      "source_file": "mm/z3fold.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:35:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `z3fold.c`\n\n---\n\n# z3fold.c 技术文档\n\n## 1. 文件概述\n\n`z3fold.c` 实现了一个专用于存储压缩页面的特殊用途内存分配器——**z3fold**。该分配器继承自 `zbud` 的设计理念，但进行了优化：每个物理页最多可容纳**三个**压缩对象（而 zbud 仅支持两个），从而提升了压缩密度，同时保留了“每页存储整数个对象”的确定性特性。这种设计在需要高效内存回收（reclaim）的场景下，相比无固定对象数量限制的高密度方案更具优势。z3fold 不直接对外暴露 API，而是通过 **zpool** 接口被上层（如 zswap、zram）调用。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`struct z3fold_header`**: 存储在每个 z3fold 页面起始位置的元数据结构（HEADLESS 页除外）。包含：\n  - 页面引用计数 (`refcount`) 和自旋锁 (`page_lock`)\n  - 指向所属池 (`pool`) 和 CPU 亲和性 (`cpu`)\n  - 三个 buddy 区域（first, middle, last）的大小及起始位置\n  - 状态标志（如映射计数 `mapped_count`、外部句柄标记 `foreign_handles`）\n  - 用于后台优化的工作队列项 (`work`)\n- **`struct z3fold_buddy_slots`**: 管理页面内对象句柄的槽位结构，包含读写锁 (`lock`) 和指向所属池的反向链接。\n- **`struct z3fold_pool`**: 代表一个 z3fold 内存池，包含：\n  - 每 CPU 的 `unbuddied` 列表数组（按空闲区域大小分类）\n  - 待释放的 `stale` 页面列表\n  - 专用 slab 缓存 (`c_handle`) 用于分配 `buddy_slots`\n  - 后台工作队列 (`compact_wq`, `release_wq`) 用于页面整理和安全释放\n\n### 关键枚举与宏\n- **`enum buddy`**: 定义页面内对象的三种类型：`FIRST`（页首）、`MIDDLE`（中间）、`LAST`（页尾），以及特殊的 `HEADLESS`（无头部元数据页）。\n- **`NCHUNKS_ORDER`**: 核心配置参数（默认为 6），决定内部分配粒度为 `PAGE_SIZE / 64`。\n- **页面标志 (`enum z3fold_page_flags`)**: 如 `PAGE_HEADLESS`、`NEEDS_COMPACTING`、`PAGE_STALE` 等，用于管理页面状态。\n- **句柄标志 (`enum z3fold_handle_flags`)**: 控制句柄行为（如 `HANDLES_NOFREE`）。\n\n### 核心辅助函数\n- **`size_to_chunks()`**: 将字节大小转换为 chunk 单位。\n- **`alloc_slots()` / `slots_to_pool()`**: 管理 `buddy_slots` 的分配与池关联。\n- **`handle_to_slots()` / `get_z3fold_header()`**: 从用户句柄解析出底层元数据结构，并处理并发访问与迁移。\n- **`z3fold_page_lock/unlock/trylock()`**: 提供页面级细粒度锁操作。\n\n## 3. 关键实现\n\n### 内存布局与分配策略\n- **Chunk 粒度**: 页面被划分为 `TOTAL_CHUNKS = PAGE_SIZE / CHUNK_SIZE` 个固定大小的 chunk（默认 64 字节）。前 `ZHDR_CHUNKS` 个 chunk 被 `z3fold_header` 占用，剩余 `NCHUNKS`（约 62-63）个用于存储数据。\n- **三 Buddy 设计**: \n  - **First Buddy**: 从 `header` 之后开始分配。\n  - **Last Buddy**: 从页面末尾向前分配。\n  - **Middle Buddy**: 在 First 和 Last 之间动态分配，最大化利用碎片空间。\n- **HEADLESS 页**: 当对象大小接近整个页面时，跳过 header 直接使用整页，减少元数据开销。\n\n### 并发与迁移安全\n- **双层锁机制**: \n  - `z3fold_header.page_lock` 保护单个页面的元数据修改。\n  - `z3fold_buddy_slots.lock` (rwlock) 保护句柄到地址的映射，支持高并发读取。\n- **迁移处理**: 在 `get_z3fold_header()` 中检查 `PAGE_MIGRATED` 标志，若页面正在迁移则重试获取锁，确保访问安全。\n\n### 后台优化\n- **页面整理 (`compact_page_work`)**: 通过工作队列异步移动 Middle Buddy 对象，尝试合并空闲区域以容纳更大对象。\n- **安全释放**: 使用独立工作队列 (`release_wq`) 延迟释放被标记为 `PAGE_STALE` 的页面，避免在中断上下文或持有锁时执行高开销操作。\n\n### 句柄编码\n- 用户句柄 (`handle`) 是一个 `unsigned long`，其低 2 位 (`HANDLE_FLAG_MASK`) 用于存储标志（如 `PAGE_HEADLESS`），其余位编码 `buddy_slots` 地址或直接指向页面。这允许在不解引用的情况下快速判断页面类型。\n\n## 4. 依赖关系\n\n- **核心依赖**: \n  - `<linux/zpool.h>`: 作为 zpool 驱动注册，提供 `zpool_ops` 接口。\n  - `<linux/slab.h>`: 使用 kmem_cache 分配 `z3fold_buddy_slots`。\n  - `<linux/workqueue.h>`: 依赖内核工作队列机制执行后台任务。\n- **内存管理子系统**: \n  - 依赖 `alloc_pages()`/`__free_pages()` 进行底层页分配。\n  - 使用 `page->private` 存储页面标志位。\n  - 与内存压缩 (`compaction.h`) 和迁移 (`migrate.h`) 机制交互。\n- **同步原语**: 大量使用 `spinlock_t` 和 `rwlock_t` 保证 SMP 安全。\n\n## 5. 使用场景\n\nz3fold 主要作为 **zpool** 的后端分配器，服务于需要高效压缩内存的子系统：\n- **zswap**: 作为交换页的压缩缓存，z3fold 的高密度存储可显著减少实际交换 I/O。\n- **zram**: 作为基于 RAM 的块设备，z3fold 提升其有效存储容量。\n- **其他内存压缩框架**: 任何需要将变长小对象（尤其是压缩数据）高效打包进物理页的场景。\n\n其**确定性回收特性**（每页对象数固定、布局简单）使其在内存压力大时能快速找到可回收页面，优于更复杂的分配器（如 zsmalloc），特别适合嵌入式或实时系统。",
      "similarity": 0.5718769431114197,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "mm/z3fold.c",
          "start_line": 1092,
          "end_line": 1219,
          "content": [
            "static void z3fold_free(struct z3fold_pool *pool, unsigned long handle)",
            "{",
            "\tstruct z3fold_header *zhdr;",
            "\tstruct page *page;",
            "\tenum buddy bud;",
            "\tbool page_claimed;",
            "",
            "\tzhdr = get_z3fold_header(handle);",
            "\tpage = virt_to_page(zhdr);",
            "\tpage_claimed = test_and_set_bit(PAGE_CLAIMED, &page->private);",
            "",
            "\tif (test_bit(PAGE_HEADLESS, &page->private)) {",
            "\t\t/* if a headless page is under reclaim, just leave.",
            "\t\t * NB: we use test_and_set_bit for a reason: if the bit",
            "\t\t * has not been set before, we release this page",
            "\t\t * immediately so we don't care about its value any more.",
            "\t\t */",
            "\t\tif (!page_claimed) {",
            "\t\t\tput_z3fold_header(zhdr);",
            "\t\t\tfree_z3fold_page(page, true);",
            "\t\t\tatomic64_dec(&pool->pages_nr);",
            "\t\t}",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* Non-headless case */",
            "\tbud = handle_to_buddy(handle);",
            "",
            "\tswitch (bud) {",
            "\tcase FIRST:",
            "\t\tzhdr->first_chunks = 0;",
            "\t\tbreak;",
            "\tcase MIDDLE:",
            "\t\tzhdr->middle_chunks = 0;",
            "\t\tbreak;",
            "\tcase LAST:",
            "\t\tzhdr->last_chunks = 0;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tpr_err(\"%s: unknown bud %d\\n\", __func__, bud);",
            "\t\tWARN_ON(1);",
            "\t\tput_z3fold_header(zhdr);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (!page_claimed)",
            "\t\tfree_handle(handle, zhdr);",
            "\tif (put_z3fold_locked_list(zhdr))",
            "\t\treturn;",
            "\tif (page_claimed) {",
            "\t\t/* the page has not been claimed by us */",
            "\t\tput_z3fold_header(zhdr);",
            "\t\treturn;",
            "\t}",
            "\tif (test_and_set_bit(NEEDS_COMPACTING, &page->private)) {",
            "\t\tclear_bit(PAGE_CLAIMED, &page->private);",
            "\t\tput_z3fold_header(zhdr);",
            "\t\treturn;",
            "\t}",
            "\tif (zhdr->cpu < 0 || !cpu_online(zhdr->cpu)) {",
            "\t\tzhdr->cpu = -1;",
            "\t\tkref_get(&zhdr->refcount);",
            "\t\tclear_bit(PAGE_CLAIMED, &page->private);",
            "\t\tdo_compact_page(zhdr, true);",
            "\t\treturn;",
            "\t}",
            "\tkref_get(&zhdr->refcount);",
            "\tclear_bit(PAGE_CLAIMED, &page->private);",
            "\tqueue_work_on(zhdr->cpu, pool->compact_wq, &zhdr->work);",
            "\tput_z3fold_header(zhdr);",
            "}",
            "static void z3fold_unmap(struct z3fold_pool *pool, unsigned long handle)",
            "{",
            "\tstruct z3fold_header *zhdr;",
            "\tstruct page *page;",
            "\tenum buddy buddy;",
            "",
            "\tzhdr = get_z3fold_header(handle);",
            "\tpage = virt_to_page(zhdr);",
            "",
            "\tif (test_bit(PAGE_HEADLESS, &page->private))",
            "\t\treturn;",
            "",
            "\tbuddy = handle_to_buddy(handle);",
            "\tif (buddy == MIDDLE)",
            "\t\tclear_bit(MIDDLE_CHUNK_MAPPED, &page->private);",
            "\tzhdr->mapped_count--;",
            "\tput_z3fold_header(zhdr);",
            "}",
            "static u64 z3fold_get_pool_size(struct z3fold_pool *pool)",
            "{",
            "\treturn atomic64_read(&pool->pages_nr);",
            "}",
            "static bool z3fold_page_isolate(struct page *page, isolate_mode_t mode)",
            "{",
            "\tstruct z3fold_header *zhdr;",
            "\tstruct z3fold_pool *pool;",
            "",
            "\tVM_BUG_ON_PAGE(PageIsolated(page), page);",
            "",
            "\tif (test_bit(PAGE_HEADLESS, &page->private))",
            "\t\treturn false;",
            "",
            "\tzhdr = page_address(page);",
            "\tz3fold_page_lock(zhdr);",
            "\tif (test_bit(NEEDS_COMPACTING, &page->private) ||",
            "\t    test_bit(PAGE_STALE, &page->private))",
            "\t\tgoto out;",
            "",
            "\tif (zhdr->mapped_count != 0 || zhdr->foreign_handles != 0)",
            "\t\tgoto out;",
            "",
            "\tif (test_and_set_bit(PAGE_CLAIMED, &page->private))",
            "\t\tgoto out;",
            "\tpool = zhdr_to_pool(zhdr);",
            "\tspin_lock(&pool->lock);",
            "\tif (!list_empty(&zhdr->buddy))",
            "\t\tlist_del_init(&zhdr->buddy);",
            "\tspin_unlock(&pool->lock);",
            "",
            "\tkref_get(&zhdr->refcount);",
            "\tz3fold_page_unlock(zhdr);",
            "\treturn true;",
            "",
            "out:",
            "\tz3fold_page_unlock(zhdr);",
            "\treturn false;",
            "}"
          ],
          "function_name": "z3fold_free, z3fold_unmap, z3fold_get_pool_size, z3fold_page_isolate",
          "description": "z3fold_free处理Z3Fold页面释放逻辑，根据headless或非headless情况区分处理，清除buddy类型计数并触发页压缩或直接回收。z3fold_unmap减少映射计数并清除中间块映射标志。z3fold_get_pool_size返回当前池中页面总数。z3fold_page_isolate尝试将页面隔离至Z3Fold结构，检查是否满足条件并将其加入buddy链表。",
          "similarity": 0.5378752946853638
        },
        {
          "chunk_id": 2,
          "file_path": "mm/z3fold.c",
          "start_line": 402,
          "end_line": 513,
          "content": [
            "static unsigned short handle_to_chunks(unsigned long handle)",
            "{",
            "\tstruct z3fold_buddy_slots *slots = handle_to_slots(handle);",
            "\tunsigned long addr;",
            "",
            "\tread_lock(&slots->lock);",
            "\taddr = *(unsigned long *)handle;",
            "\tread_unlock(&slots->lock);",
            "\treturn (addr & ~PAGE_MASK) >> BUDDY_SHIFT;",
            "}",
            "static enum buddy handle_to_buddy(unsigned long handle)",
            "{",
            "\tstruct z3fold_header *zhdr;",
            "\tstruct z3fold_buddy_slots *slots = handle_to_slots(handle);",
            "\tunsigned long addr;",
            "",
            "\tread_lock(&slots->lock);",
            "\tWARN_ON(handle & (1 << PAGE_HEADLESS));",
            "\taddr = *(unsigned long *)handle;",
            "\tread_unlock(&slots->lock);",
            "\tzhdr = (struct z3fold_header *)(addr & PAGE_MASK);",
            "\treturn (addr - zhdr->first_num) & BUDDY_MASK;",
            "}",
            "static void __release_z3fold_page(struct z3fold_header *zhdr, bool locked)",
            "{",
            "\tstruct page *page = virt_to_page(zhdr);",
            "\tstruct z3fold_pool *pool = zhdr_to_pool(zhdr);",
            "",
            "\tWARN_ON(!list_empty(&zhdr->buddy));",
            "\tset_bit(PAGE_STALE, &page->private);",
            "\tclear_bit(NEEDS_COMPACTING, &page->private);",
            "\tspin_lock(&pool->lock);",
            "\tspin_unlock(&pool->lock);",
            "",
            "\tif (locked)",
            "\t\tz3fold_page_unlock(zhdr);",
            "",
            "\tspin_lock(&pool->stale_lock);",
            "\tlist_add(&zhdr->buddy, &pool->stale);",
            "\tqueue_work(pool->release_wq, &pool->work);",
            "\tspin_unlock(&pool->stale_lock);",
            "",
            "\tatomic64_dec(&pool->pages_nr);",
            "}",
            "static void release_z3fold_page_locked(struct kref *ref)",
            "{",
            "\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,",
            "\t\t\t\t\t\trefcount);",
            "\tWARN_ON(z3fold_page_trylock(zhdr));",
            "\t__release_z3fold_page(zhdr, true);",
            "}",
            "static void release_z3fold_page_locked_list(struct kref *ref)",
            "{",
            "\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,",
            "\t\t\t\t\t       refcount);",
            "\tstruct z3fold_pool *pool = zhdr_to_pool(zhdr);",
            "",
            "\tspin_lock(&pool->lock);",
            "\tlist_del_init(&zhdr->buddy);",
            "\tspin_unlock(&pool->lock);",
            "",
            "\tWARN_ON(z3fold_page_trylock(zhdr));",
            "\t__release_z3fold_page(zhdr, true);",
            "}",
            "static inline int put_z3fold_locked(struct z3fold_header *zhdr)",
            "{",
            "\treturn kref_put(&zhdr->refcount, release_z3fold_page_locked);",
            "}",
            "static inline int put_z3fold_locked_list(struct z3fold_header *zhdr)",
            "{",
            "\treturn kref_put(&zhdr->refcount, release_z3fold_page_locked_list);",
            "}",
            "static void free_pages_work(struct work_struct *w)",
            "{",
            "\tstruct z3fold_pool *pool = container_of(w, struct z3fold_pool, work);",
            "",
            "\tspin_lock(&pool->stale_lock);",
            "\twhile (!list_empty(&pool->stale)) {",
            "\t\tstruct z3fold_header *zhdr = list_first_entry(&pool->stale,",
            "\t\t\t\t\t\tstruct z3fold_header, buddy);",
            "\t\tstruct page *page = virt_to_page(zhdr);",
            "",
            "\t\tlist_del(&zhdr->buddy);",
            "\t\tif (WARN_ON(!test_bit(PAGE_STALE, &page->private)))",
            "\t\t\tcontinue;",
            "\t\tspin_unlock(&pool->stale_lock);",
            "\t\tcancel_work_sync(&zhdr->work);",
            "\t\tfree_z3fold_page(page, false);",
            "\t\tcond_resched();",
            "\t\tspin_lock(&pool->stale_lock);",
            "\t}",
            "\tspin_unlock(&pool->stale_lock);",
            "}",
            "static int num_free_chunks(struct z3fold_header *zhdr)",
            "{",
            "\tint nfree;",
            "\t/*",
            "\t * If there is a middle object, pick up the bigger free space",
            "\t * either before or after it. Otherwise just subtract the number",
            "\t * of chunks occupied by the first and the last objects.",
            "\t */",
            "\tif (zhdr->middle_chunks != 0) {",
            "\t\tint nfree_before = zhdr->first_chunks ?",
            "\t\t\t0 : zhdr->start_middle - ZHDR_CHUNKS;",
            "\t\tint nfree_after = zhdr->last_chunks ?",
            "\t\t\t0 : TOTAL_CHUNKS -",
            "\t\t\t\t(zhdr->start_middle + zhdr->middle_chunks);",
            "\t\tnfree = max(nfree_before, nfree_after);",
            "\t} else",
            "\t\tnfree = NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;",
            "\treturn nfree;",
            "}"
          ],
          "function_name": "handle_to_chunks, handle_to_buddy, __release_z3fold_page, release_z3fold_page_locked, release_z3fold_page_locked_list, put_z3fold_locked, put_z3fold_locked_list, free_pages_work, num_free_chunks",
          "description": "实现页面回收流程和空闲块统计功能，通过标记STALE状态、从链表移除并触发后台释放工作，计算页面中可用块数量以支持压缩决策。",
          "similarity": 0.49561357498168945
        },
        {
          "chunk_id": 1,
          "file_path": "mm/z3fold.c",
          "start_line": 186,
          "end_line": 288,
          "content": [
            "static int size_to_chunks(size_t size)",
            "{",
            "\treturn (size + CHUNK_SIZE - 1) >> CHUNK_SHIFT;",
            "}",
            "static inline void z3fold_page_lock(struct z3fold_header *zhdr)",
            "{",
            "\tspin_lock(&zhdr->page_lock);",
            "}",
            "static inline int z3fold_page_trylock(struct z3fold_header *zhdr)",
            "{",
            "\treturn spin_trylock(&zhdr->page_lock);",
            "}",
            "static inline void z3fold_page_unlock(struct z3fold_header *zhdr)",
            "{",
            "\tspin_unlock(&zhdr->page_lock);",
            "}",
            "static inline void put_z3fold_header(struct z3fold_header *zhdr)",
            "{",
            "\tstruct page *page = virt_to_page(zhdr);",
            "",
            "\tif (!test_bit(PAGE_HEADLESS, &page->private))",
            "\t\tz3fold_page_unlock(zhdr);",
            "}",
            "static inline void free_handle(unsigned long handle, struct z3fold_header *zhdr)",
            "{",
            "\tstruct z3fold_buddy_slots *slots;",
            "\tint i;",
            "\tbool is_free;",
            "",
            "\tif (WARN_ON(*(unsigned long *)handle == 0))",
            "\t\treturn;",
            "",
            "\tslots = handle_to_slots(handle);",
            "\twrite_lock(&slots->lock);",
            "\t*(unsigned long *)handle = 0;",
            "",
            "\tif (test_bit(HANDLES_NOFREE, &slots->pool)) {",
            "\t\twrite_unlock(&slots->lock);",
            "\t\treturn; /* simple case, nothing else to do */",
            "\t}",
            "",
            "\tif (zhdr->slots != slots)",
            "\t\tzhdr->foreign_handles--;",
            "",
            "\tis_free = true;",
            "\tfor (i = 0; i <= BUDDY_MASK; i++) {",
            "\t\tif (slots->slot[i]) {",
            "\t\t\tis_free = false;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\twrite_unlock(&slots->lock);",
            "",
            "\tif (is_free) {",
            "\t\tstruct z3fold_pool *pool = slots_to_pool(slots);",
            "",
            "\t\tif (zhdr->slots == slots)",
            "\t\t\tzhdr->slots = NULL;",
            "\t\tkmem_cache_free(pool->c_handle, slots);",
            "\t}",
            "}",
            "static void free_z3fold_page(struct page *page, bool headless)",
            "{",
            "\tif (!headless) {",
            "\t\tlock_page(page);",
            "\t\t__ClearPageMovable(page);",
            "\t\tunlock_page(page);",
            "\t}",
            "\t__free_page(page);",
            "}",
            "static inline int __idx(struct z3fold_header *zhdr, enum buddy bud)",
            "{",
            "\treturn (bud + zhdr->first_num) & BUDDY_MASK;",
            "}",
            "static unsigned long __encode_handle(struct z3fold_header *zhdr,",
            "\t\t\t\tstruct z3fold_buddy_slots *slots,",
            "\t\t\t\tenum buddy bud)",
            "{",
            "\tunsigned long h = (unsigned long)zhdr;",
            "\tint idx = 0;",
            "",
            "\t/*",
            "\t * For a headless page, its handle is its pointer with the extra",
            "\t * PAGE_HEADLESS bit set",
            "\t */",
            "\tif (bud == HEADLESS)",
            "\t\treturn h | (1 << PAGE_HEADLESS);",
            "",
            "\t/* otherwise, return pointer to encoded handle */",
            "\tidx = __idx(zhdr, bud);",
            "\th += idx;",
            "\tif (bud == LAST)",
            "\t\th |= (zhdr->last_chunks << BUDDY_SHIFT);",
            "",
            "\twrite_lock(&slots->lock);",
            "\tslots->slot[idx] = h;",
            "\twrite_unlock(&slots->lock);",
            "\treturn (unsigned long)&slots->slot[idx];",
            "}",
            "static unsigned long encode_handle(struct z3fold_header *zhdr, enum buddy bud)",
            "{",
            "\treturn __encode_handle(zhdr, zhdr->slots, bud);",
            "}"
          ],
          "function_name": "size_to_chunks, z3fold_page_lock, z3fold_page_trylock, z3fold_page_unlock, put_z3fold_header, free_handle, free_z3fold_page, __idx, __encode_handle, encode_handle",
          "description": "实现页面锁操作、句柄管理及页面释放逻辑，包含将物理页转换为压缩块、跟踪空闲块、处理句柄与槽位映射等关键辅助函数。",
          "similarity": 0.49131810665130615
        },
        {
          "chunk_id": 3,
          "file_path": "mm/z3fold.c",
          "start_line": 538,
          "end_line": 668,
          "content": [
            "static inline void add_to_unbuddied(struct z3fold_pool *pool,",
            "\t\t\t\tstruct z3fold_header *zhdr)",
            "{",
            "\tif (zhdr->first_chunks == 0 || zhdr->last_chunks == 0 ||",
            "\t\t\tzhdr->middle_chunks == 0) {",
            "\t\tstruct list_head *unbuddied;",
            "\t\tint freechunks = num_free_chunks(zhdr);",
            "",
            "\t\tmigrate_disable();",
            "\t\tunbuddied = this_cpu_ptr(pool->unbuddied);",
            "\t\tspin_lock(&pool->lock);",
            "\t\tlist_add(&zhdr->buddy, &unbuddied[freechunks]);",
            "\t\tspin_unlock(&pool->lock);",
            "\t\tzhdr->cpu = smp_processor_id();",
            "\t\tmigrate_enable();",
            "\t}",
            "}",
            "static inline enum buddy get_free_buddy(struct z3fold_header *zhdr, int chunks)",
            "{",
            "\tenum buddy bud = HEADLESS;",
            "",
            "\tif (zhdr->middle_chunks) {",
            "\t\tif (!zhdr->first_chunks &&",
            "\t\t    chunks <= zhdr->start_middle - ZHDR_CHUNKS)",
            "\t\t\tbud = FIRST;",
            "\t\telse if (!zhdr->last_chunks)",
            "\t\t\tbud = LAST;",
            "\t} else {",
            "\t\tif (!zhdr->first_chunks)",
            "\t\t\tbud = FIRST;",
            "\t\telse if (!zhdr->last_chunks)",
            "\t\t\tbud = LAST;",
            "\t\telse",
            "\t\t\tbud = MIDDLE;",
            "\t}",
            "",
            "\treturn bud;",
            "}",
            "static inline bool buddy_single(struct z3fold_header *zhdr)",
            "{",
            "\treturn !((zhdr->first_chunks && zhdr->middle_chunks) ||",
            "\t\t\t(zhdr->first_chunks && zhdr->last_chunks) ||",
            "\t\t\t(zhdr->middle_chunks && zhdr->last_chunks));",
            "}",
            "static int z3fold_compact_page(struct z3fold_header *zhdr)",
            "{",
            "\tstruct page *page = virt_to_page(zhdr);",
            "",
            "\tif (test_bit(MIDDLE_CHUNK_MAPPED, &page->private))",
            "\t\treturn 0; /* can't move middle chunk, it's used */",
            "",
            "\tif (unlikely(PageIsolated(page)))",
            "\t\treturn 0;",
            "",
            "\tif (zhdr->middle_chunks == 0)",
            "\t\treturn 0; /* nothing to compact */",
            "",
            "\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {",
            "\t\t/* move to the beginning */",
            "\t\tmchunk_memmove(zhdr, ZHDR_CHUNKS);",
            "\t\tzhdr->first_chunks = zhdr->middle_chunks;",
            "\t\tzhdr->middle_chunks = 0;",
            "\t\tzhdr->start_middle = 0;",
            "\t\tzhdr->first_num++;",
            "\t\treturn 1;",
            "\t}",
            "",
            "\t/*",
            "\t * moving data is expensive, so let's only do that if",
            "\t * there's substantial gain (at least BIG_CHUNK_GAP chunks)",
            "\t */",
            "\tif (zhdr->first_chunks != 0 && zhdr->last_chunks == 0 &&",
            "\t    zhdr->start_middle - (zhdr->first_chunks + ZHDR_CHUNKS) >=",
            "\t\t\tBIG_CHUNK_GAP) {",
            "\t\tmchunk_memmove(zhdr, zhdr->first_chunks + ZHDR_CHUNKS);",
            "\t\tzhdr->start_middle = zhdr->first_chunks + ZHDR_CHUNKS;",
            "\t\treturn 1;",
            "\t} else if (zhdr->last_chunks != 0 && zhdr->first_chunks == 0 &&",
            "\t\t   TOTAL_CHUNKS - (zhdr->last_chunks + zhdr->start_middle",
            "\t\t\t\t\t+ zhdr->middle_chunks) >=",
            "\t\t\tBIG_CHUNK_GAP) {",
            "\t\tunsigned short new_start = TOTAL_CHUNKS - zhdr->last_chunks -",
            "\t\t\tzhdr->middle_chunks;",
            "\t\tmchunk_memmove(zhdr, new_start);",
            "\t\tzhdr->start_middle = new_start;",
            "\t\treturn 1;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void do_compact_page(struct z3fold_header *zhdr, bool locked)",
            "{",
            "\tstruct z3fold_pool *pool = zhdr_to_pool(zhdr);",
            "\tstruct page *page;",
            "",
            "\tpage = virt_to_page(zhdr);",
            "\tif (locked)",
            "\t\tWARN_ON(z3fold_page_trylock(zhdr));",
            "\telse",
            "\t\tz3fold_page_lock(zhdr);",
            "\tif (WARN_ON(!test_and_clear_bit(NEEDS_COMPACTING, &page->private))) {",
            "\t\tz3fold_page_unlock(zhdr);",
            "\t\treturn;",
            "\t}",
            "\tspin_lock(&pool->lock);",
            "\tlist_del_init(&zhdr->buddy);",
            "\tspin_unlock(&pool->lock);",
            "",
            "\tif (put_z3fold_locked(zhdr))",
            "\t\treturn;",
            "",
            "\tif (test_bit(PAGE_STALE, &page->private) ||",
            "\t    test_and_set_bit(PAGE_CLAIMED, &page->private)) {",
            "\t\tz3fold_page_unlock(zhdr);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (!zhdr->foreign_handles && buddy_single(zhdr) &&",
            "\t    zhdr->mapped_count == 0 && compact_single_buddy(zhdr)) {",
            "\t\tif (!put_z3fold_locked(zhdr)) {",
            "\t\t\tclear_bit(PAGE_CLAIMED, &page->private);",
            "\t\t\tz3fold_page_unlock(zhdr);",
            "\t\t}",
            "\t\treturn;",
            "\t}",
            "",
            "\tz3fold_compact_page(zhdr);",
            "\tadd_to_unbuddied(pool, zhdr);",
            "\tclear_bit(PAGE_CLAIMED, &page->private);",
            "\tz3fold_page_unlock(zhdr);",
            "}"
          ],
          "function_name": "add_to_unbuddied, get_free_buddy, buddy_single, z3fold_compact_page, do_compact_page",
          "description": "实现页面迁移优化算法，通过检测可移动块位置、执行块数据迁移、维护未分块页面列表等机制提升空间利用率。",
          "similarity": 0.48590531945228577
        },
        {
          "chunk_id": 6,
          "file_path": "mm/z3fold.c",
          "start_line": 1285,
          "end_line": 1393,
          "content": [
            "static int z3fold_page_migrate(struct page *newpage, struct page *page,",
            "\t\tenum migrate_mode mode)",
            "{",
            "\tstruct z3fold_header *zhdr, *new_zhdr;",
            "\tstruct z3fold_pool *pool;",
            "",
            "\tVM_BUG_ON_PAGE(!PageIsolated(page), page);",
            "\tVM_BUG_ON_PAGE(!test_bit(PAGE_CLAIMED, &page->private), page);",
            "\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);",
            "",
            "\tzhdr = page_address(page);",
            "\tpool = zhdr_to_pool(zhdr);",
            "",
            "\tif (!z3fold_page_trylock(zhdr))",
            "\t\treturn -EAGAIN;",
            "\tif (zhdr->mapped_count != 0 || zhdr->foreign_handles != 0) {",
            "\t\tclear_bit(PAGE_CLAIMED, &page->private);",
            "\t\tz3fold_page_unlock(zhdr);",
            "\t\treturn -EBUSY;",
            "\t}",
            "\tif (work_pending(&zhdr->work)) {",
            "\t\tz3fold_page_unlock(zhdr);",
            "\t\treturn -EAGAIN;",
            "\t}",
            "\tnew_zhdr = page_address(newpage);",
            "\tmemcpy(new_zhdr, zhdr, PAGE_SIZE);",
            "\tnewpage->private = page->private;",
            "\tset_bit(PAGE_MIGRATED, &page->private);",
            "\tz3fold_page_unlock(zhdr);",
            "\tspin_lock_init(&new_zhdr->page_lock);",
            "\tINIT_WORK(&new_zhdr->work, compact_page_work);",
            "\t/*",
            "\t * z3fold_page_isolate() ensures that new_zhdr->buddy is empty,",
            "\t * so we only have to reinitialize it.",
            "\t */",
            "\tINIT_LIST_HEAD(&new_zhdr->buddy);",
            "\t__ClearPageMovable(page);",
            "",
            "\tget_page(newpage);",
            "\tz3fold_page_lock(new_zhdr);",
            "\tif (new_zhdr->first_chunks)",
            "\t\tencode_handle(new_zhdr, FIRST);",
            "\tif (new_zhdr->last_chunks)",
            "\t\tencode_handle(new_zhdr, LAST);",
            "\tif (new_zhdr->middle_chunks)",
            "\t\tencode_handle(new_zhdr, MIDDLE);",
            "\tset_bit(NEEDS_COMPACTING, &newpage->private);",
            "\tnew_zhdr->cpu = smp_processor_id();",
            "\t__SetPageMovable(newpage, &z3fold_mops);",
            "\tz3fold_page_unlock(new_zhdr);",
            "",
            "\tqueue_work_on(new_zhdr->cpu, pool->compact_wq, &new_zhdr->work);",
            "",
            "\t/* PAGE_CLAIMED and PAGE_MIGRATED are cleared now. */",
            "\tpage->private = 0;",
            "\tput_page(page);",
            "\treturn 0;",
            "}",
            "static void z3fold_page_putback(struct page *page)",
            "{",
            "\tstruct z3fold_header *zhdr;",
            "\tstruct z3fold_pool *pool;",
            "",
            "\tzhdr = page_address(page);",
            "\tpool = zhdr_to_pool(zhdr);",
            "",
            "\tz3fold_page_lock(zhdr);",
            "\tif (!list_empty(&zhdr->buddy))",
            "\t\tlist_del_init(&zhdr->buddy);",
            "\tINIT_LIST_HEAD(&page->lru);",
            "\tif (put_z3fold_locked(zhdr))",
            "\t\treturn;",
            "\tif (list_empty(&zhdr->buddy))",
            "\t\tadd_to_unbuddied(pool, zhdr);",
            "\tclear_bit(PAGE_CLAIMED, &page->private);",
            "\tz3fold_page_unlock(zhdr);",
            "}",
            "static void z3fold_zpool_destroy(void *pool)",
            "{",
            "\tz3fold_destroy_pool(pool);",
            "}",
            "static int z3fold_zpool_malloc(void *pool, size_t size, gfp_t gfp,",
            "\t\t\tunsigned long *handle)",
            "{",
            "\treturn z3fold_alloc(pool, size, gfp, handle);",
            "}",
            "static void z3fold_zpool_free(void *pool, unsigned long handle)",
            "{",
            "\tz3fold_free(pool, handle);",
            "}",
            "static void z3fold_zpool_unmap(void *pool, unsigned long handle)",
            "{",
            "\tz3fold_unmap(pool, handle);",
            "}",
            "static u64 z3fold_zpool_total_size(void *pool)",
            "{",
            "\treturn z3fold_get_pool_size(pool) * PAGE_SIZE;",
            "}",
            "static int __init init_z3fold(void)",
            "{",
            "\t/*",
            "\t * Make sure the z3fold header is not larger than the page size and",
            "\t * there has remaining spaces for its buddy.",
            "\t */",
            "\tBUILD_BUG_ON(ZHDR_SIZE_ALIGNED > PAGE_SIZE - CHUNK_SIZE);",
            "\tzpool_register_driver(&z3fold_zpool_driver);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "z3fold_page_migrate, z3fold_page_putback, z3fold_zpool_destroy, z3fold_zpool_malloc, z3fold_zpool_free, z3fold_zpool_unmap, z3fold_zpool_total_size, init_z3fold",
          "description": "z3fold_page_migrate执行页面迁移，复制页头信息并更新新页面状态。z3fold_page_putback将页面从buddy列表移除并重新插入LRU列表。z3fold_zpool_*系列函数实现内存池的销毁、分配、释放、解映射和总大小查询。init_z3fold注册Z3Fold内存池驱动。",
          "similarity": 0.48329171538352966
        }
      ]
    },
    {
      "source_file": "mm/zbud.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:36:35\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `zbud.c`\n\n---\n\n# zbud.c 技术文档\n\n## 1. 文件概述\n\n`zbud.c` 实现了一个专用于存储压缩页面（compressed pages）的特殊用途内存分配器——**zbud**。尽管名称中包含“buddy”，但它并非传统的伙伴系统分配器，而是通过将两个压缩页面（称为“zpages”）配对存放在同一个物理内存页（称为“zbud page”）中来实现高效管理。\n\n该设计在牺牲一定存储密度的前提下，提供了简单且可预测的内存回收特性，特别适用于需要频繁进行内存回收（reclaim）的场景（如 zswap、zcache 等压缩交换子系统）。zbud 保证其空间利用率不会低于 1:1（即不会比直接使用未压缩页面占用更多物理页），从而确保“不会造成损害”。\n\n此外，zbud 的 API 与传统分配器不同：`zbud_alloc()` 返回一个不透明句柄（handle），用户必须通过 `zbud_map()` 映射该句柄才能获得可访问的数据指针，并在操作完成后调用 `zbud_unmap()` 解除映射。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct zbud_pool`**  \n  表示一个 zbud 内存池，包含：\n  - `lock`：自旋锁，保护池内所有字段及其中 zbud 页面的元数据。\n  - `unbuddied[NCHUNKS]`：数组，每个元素是一个链表头，用于管理仅包含一个 buddy（单配对）的 zbud 页面；索引表示页面中空闲块的数量。\n  - `buddied`：链表头，管理已包含两个 buddy（满配对）的 zbud 页面（复用 `unbuddied[0]`）。\n  - `pages_nr`：池中 zbud 页面的总数。\n\n- **`struct zbud_header`**  \n  位于每个 zbud 页面的第一个 chunk 中，作为页面元数据，包含：\n  - `buddy`：用于将页面链接到 `unbuddied` 或 `buddied` 链表。\n  - `first_chunks`：第一个 buddy 占用的 chunk 数（为 0 表示空闲）。\n  - `last_chunks`：最后一个 buddy 占用的 chunk 数（为 0 表示空闲）。\n\n### 主要函数\n\n- **`zbud_create_pool(gfp_t gfp)`**  \n  创建并初始化一个新的 zbud 内存池。\n\n- **`zbud_destroy_pool(struct zbud_pool *pool)`**  \n  销毁指定的 zbud 内存池（要求池已清空）。\n\n- **`zbud_alloc(struct zbud_pool *pool, size_t size, gfp_t gfp, unsigned long *handle)`**  \n  在池中分配指定大小的内存区域，返回不透明句柄。\n\n- **`zbud_free(struct zbud_pool *pool, unsigned long handle)`**  \n  释放由句柄标识的分配区域。\n\n- **`zbud_map(struct zbud_pool *pool, unsigned long handle)`**  \n  将句柄映射为可访问的虚拟地址指针。\n\n- **`zbud_unmap(struct zbud_pool *pool, unsigned long handle)`**  \n  解除句柄的映射。\n\n- **辅助函数**：\n  - `size_to_chunks()`：将字节大小转换为 chunk 数量。\n  - `init_zbud_page()` / `free_zbud_page()`：初始化/释放 zbud 页面。\n  - `encode_handle()` / `handle_to_zbud_header()`：句柄编码与解码。\n  - `num_free_chunks()`：计算 zbud 页面中的空闲 chunk 数。\n\n## 3. 关键实现\n\n### 内存布局与配对机制\n\n- 每个 **zbud 页面**（物理页）被划分为固定大小的 **chunks**（默认 `PAGE_SIZE / 64`，由 `NCHUNKS_ORDER=6` 决定）。\n- 第一个 chunk 被 `zbud_header` 占用，剩余 `NCHUNKS = 63` 个 chunks 可用于存储数据。\n- **First buddy** 从页面起始位置（跳过 header）向右分配（左对齐）。\n- **Last buddy** 从页面末尾向左分配（右对齐）。\n- 当任一 buddy 被释放时，其空间会与中间的 slack space 合并，形成页面内最大的连续空闲区域，便于后续分配。\n\n### 空闲管理策略\n\n- 使用 **`unbuddied[NCHUNKS]` 数组** 管理单配对页面：\n  - 索引 `i` 对应空闲 chunk 数为 `i` 的页面。\n  - 分配时优先遍历满足需求的最小空闲列表（best-fit 策略）。\n- **`buddied` 链表** 管理已满（双配对）的页面，无法再分配。\n\n### 句柄机制\n\n- 句柄本质是数据在页面内的虚拟地址，但通过 `encode_handle()` 封装：\n  - First buddy 句柄 = `zhdr 地址 + ZHDR_SIZE_ALIGNED`\n  - Last buddy 句柄 = `页面起始地址 + PAGE_SIZE - (last_chunks << CHUNK_SHIFT)`\n- 通过 `handle & PAGE_MASK` 可快速还原出 `zbud_header` 指针。\n\n### 密度保证\n\n- 由于每个 zbud 页面至少可容纳一个压缩页，因此 **zpages : zbud pages ≥ 1**，确保不会因压缩反而增加内存消耗。\n\n## 4. 依赖关系\n\n- **内核头文件**：\n  - `<linux/atomic.h>`、`<linux/spinlock.h>`：提供原子操作和自旋锁支持。\n  - `<linux/list.h>`：链表操作。\n  - `<linux/mm.h>`、`<linux/slab.h>`：内存页和 slab 分配器接口。\n  - `<linux/zpool.h>`：zbud 作为 zpool API 的一种后端实现，需符合其接口规范。\n- **架构依赖**：使用 `PAGE_SHIFT`、`PAGE_MASK` 等与页大小相关的宏，依赖体系结构定义。\n- **内存属性限制**：分配时禁止使用 `__GFP_HIGHMEM`，因高内存页无法直接映射访问。\n\n## 5. 使用场景\n\n- **zswap**：Linux 内核的交换页压缩缓存机制，使用 zbud（或 z3fold/zsmalloc）作为后端分配器存储压缩后的交换页。\n- **zcache**（历史项目）：早期基于 transcendent memory 的压缩缓存，zbud 最初为其设计。\n- **其他需要确定性回收行为的压缩内存池**：适用于对内存回收延迟敏感、且能接受较低存储密度的场景。\n- **作为 zpool 的注册后端**：通过 `zpool_register_driver()` 注册，供上层子系统按需选择。",
      "similarity": 0.559265673160553,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/zbud.c",
          "start_line": 127,
          "end_line": 252,
          "content": [
            "static int size_to_chunks(size_t size)",
            "{",
            "\treturn (size + CHUNK_SIZE - 1) >> CHUNK_SHIFT;",
            "}",
            "static void free_zbud_page(struct zbud_header *zhdr)",
            "{",
            "\t__free_page(virt_to_page(zhdr));",
            "}",
            "static unsigned long encode_handle(struct zbud_header *zhdr, enum buddy bud)",
            "{",
            "\tunsigned long handle;",
            "",
            "\t/*",
            "\t * For now, the encoded handle is actually just the pointer to the data",
            "\t * but this might not always be the case.  A little information hiding.",
            "\t * Add CHUNK_SIZE to the handle if it is the first allocation to jump",
            "\t * over the zbud header in the first chunk.",
            "\t */",
            "\thandle = (unsigned long)zhdr;",
            "\tif (bud == FIRST)",
            "\t\t/* skip over zbud header */",
            "\t\thandle += ZHDR_SIZE_ALIGNED;",
            "\telse /* bud == LAST */",
            "\t\thandle += PAGE_SIZE - (zhdr->last_chunks  << CHUNK_SHIFT);",
            "\treturn handle;",
            "}",
            "static int num_free_chunks(struct zbud_header *zhdr)",
            "{",
            "\t/*",
            "\t * Rather than branch for different situations, just use the fact that",
            "\t * free buddies have a length of zero to simplify everything.",
            "\t */",
            "\treturn NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;",
            "}",
            "static void zbud_destroy_pool(struct zbud_pool *pool)",
            "{",
            "\tkfree(pool);",
            "}",
            "static int zbud_alloc(struct zbud_pool *pool, size_t size, gfp_t gfp,",
            "\t\t\tunsigned long *handle)",
            "{",
            "\tint chunks, i, freechunks;",
            "\tstruct zbud_header *zhdr = NULL;",
            "\tenum buddy bud;",
            "\tstruct page *page;",
            "",
            "\tif (!size || (gfp & __GFP_HIGHMEM))",
            "\t\treturn -EINVAL;",
            "\tif (size > PAGE_SIZE - ZHDR_SIZE_ALIGNED - CHUNK_SIZE)",
            "\t\treturn -ENOSPC;",
            "\tchunks = size_to_chunks(size);",
            "\tspin_lock(&pool->lock);",
            "",
            "\t/* First, try to find an unbuddied zbud page. */",
            "\tfor_each_unbuddied_list(i, chunks) {",
            "\t\tif (!list_empty(&pool->unbuddied[i])) {",
            "\t\t\tzhdr = list_first_entry(&pool->unbuddied[i],",
            "\t\t\t\t\tstruct zbud_header, buddy);",
            "\t\t\tlist_del(&zhdr->buddy);",
            "\t\t\tif (zhdr->first_chunks == 0)",
            "\t\t\t\tbud = FIRST;",
            "\t\t\telse",
            "\t\t\t\tbud = LAST;",
            "\t\t\tgoto found;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Couldn't find unbuddied zbud page, create new one */",
            "\tspin_unlock(&pool->lock);",
            "\tpage = alloc_page(gfp);",
            "\tif (!page)",
            "\t\treturn -ENOMEM;",
            "\tspin_lock(&pool->lock);",
            "\tpool->pages_nr++;",
            "\tzhdr = init_zbud_page(page);",
            "\tbud = FIRST;",
            "",
            "found:",
            "\tif (bud == FIRST)",
            "\t\tzhdr->first_chunks = chunks;",
            "\telse",
            "\t\tzhdr->last_chunks = chunks;",
            "",
            "\tif (zhdr->first_chunks == 0 || zhdr->last_chunks == 0) {",
            "\t\t/* Add to unbuddied list */",
            "\t\tfreechunks = num_free_chunks(zhdr);",
            "\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);",
            "\t} else {",
            "\t\t/* Add to buddied list */",
            "\t\tlist_add(&zhdr->buddy, &pool->buddied);",
            "\t}",
            "",
            "\t*handle = encode_handle(zhdr, bud);",
            "\tspin_unlock(&pool->lock);",
            "",
            "\treturn 0;",
            "}",
            "static void zbud_free(struct zbud_pool *pool, unsigned long handle)",
            "{",
            "\tstruct zbud_header *zhdr;",
            "\tint freechunks;",
            "",
            "\tspin_lock(&pool->lock);",
            "\tzhdr = handle_to_zbud_header(handle);",
            "",
            "\t/* If first buddy, handle will be page aligned */",
            "\tif ((handle - ZHDR_SIZE_ALIGNED) & ~PAGE_MASK)",
            "\t\tzhdr->last_chunks = 0;",
            "\telse",
            "\t\tzhdr->first_chunks = 0;",
            "",
            "\t/* Remove from existing buddy list */",
            "\tlist_del(&zhdr->buddy);",
            "",
            "\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {",
            "\t\t/* zbud page is empty, free */",
            "\t\tfree_zbud_page(zhdr);",
            "\t\tpool->pages_nr--;",
            "\t} else {",
            "\t\t/* Add to unbuddied list */",
            "\t\tfreechunks = num_free_chunks(zhdr);",
            "\t\tlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);",
            "\t}",
            "",
            "\tspin_unlock(&pool->lock);",
            "}"
          ],
          "function_name": "size_to_chunks, free_zbud_page, encode_handle, num_free_chunks, zbud_destroy_pool, zbud_alloc, zbud_free",
          "description": "实现了zbud分配器的关键功能，包含大小转块计算、页面释放、句柄编码、空闲块统计等辅助函数，核心函数zbud_alloc尝试从空闲列表获取页或新建页面并分割存储，zbud_free处理释放逻辑并重新加入空闲列表。",
          "similarity": 0.5162346363067627
        },
        {
          "chunk_id": 0,
          "file_path": "mm/zbud.c",
          "start_line": 1,
          "end_line": 126,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * zbud.c",
            " *",
            " * Copyright (C) 2013, Seth Jennings, IBM",
            " *",
            " * Concepts based on zcache internal zbud allocator by Dan Magenheimer.",
            " *",
            " * zbud is an special purpose allocator for storing compressed pages.  Contrary",
            " * to what its name may suggest, zbud is not a buddy allocator, but rather an",
            " * allocator that \"buddies\" two compressed pages together in a single memory",
            " * page.",
            " *",
            " * While this design limits storage density, it has simple and deterministic",
            " * reclaim properties that make it preferable to a higher density approach when",
            " * reclaim will be used.",
            " *",
            " * zbud works by storing compressed pages, or \"zpages\", together in pairs in a",
            " * single memory page called a \"zbud page\".  The first buddy is \"left",
            " * justified\" at the beginning of the zbud page, and the last buddy is \"right",
            " * justified\" at the end of the zbud page.  The benefit is that if either",
            " * buddy is freed, the freed buddy space, coalesced with whatever slack space",
            " * that existed between the buddies, results in the largest possible free region",
            " * within the zbud page.",
            " *",
            " * zbud also provides an attractive lower bound on density. The ratio of zpages",
            " * to zbud pages can not be less than 1.  This ensures that zbud can never \"do",
            " * harm\" by using more pages to store zpages than the uncompressed zpages would",
            " * have used on their own.",
            " *",
            " * zbud pages are divided into \"chunks\".  The size of the chunks is fixed at",
            " * compile time and determined by NCHUNKS_ORDER below.  Dividing zbud pages",
            " * into chunks allows organizing unbuddied zbud pages into a manageable number",
            " * of unbuddied lists according to the number of free chunks available in the",
            " * zbud page.",
            " *",
            " * The zbud API differs from that of conventional allocators in that the",
            " * allocation function, zbud_alloc(), returns an opaque handle to the user,",
            " * not a dereferenceable pointer.  The user must map the handle using",
            " * zbud_map() in order to get a usable pointer by which to access the",
            " * allocation data and unmap the handle with zbud_unmap() when operations",
            " * on the allocation data are complete.",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/atomic.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/preempt.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/zpool.h>",
            "",
            "/*****************",
            " * Structures",
            "*****************/",
            "/*",
            " * NCHUNKS_ORDER determines the internal allocation granularity, effectively",
            " * adjusting internal fragmentation.  It also determines the number of",
            " * freelists maintained in each pool. NCHUNKS_ORDER of 6 means that the",
            " * allocation granularity will be in chunks of size PAGE_SIZE/64. As one chunk",
            " * in allocated page is occupied by zbud header, NCHUNKS will be calculated to",
            " * 63 which shows the max number of free chunks in zbud page, also there will be",
            " * 63 freelists per pool.",
            " */",
            "#define NCHUNKS_ORDER\t6",
            "",
            "#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)",
            "#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)",
            "#define ZHDR_SIZE_ALIGNED CHUNK_SIZE",
            "#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)",
            "",
            "struct zbud_pool;",
            "",
            "/**",
            " * struct zbud_pool - stores metadata for each zbud pool",
            " * @lock:\tprotects all pool fields and first|last_chunk fields of any",
            " *\t\tzbud page in the pool",
            " * @unbuddied:\tarray of lists tracking zbud pages that only contain one buddy;",
            " *\t\tthe lists each zbud page is added to depends on the size of",
            " *\t\tits free region.",
            " * @buddied:\tlist tracking the zbud pages that contain two buddies;",
            " *\t\tthese zbud pages are full",
            " * @pages_nr:\tnumber of zbud pages in the pool.",
            " *",
            " * This structure is allocated at pool creation time and maintains metadata",
            " * pertaining to a particular zbud pool.",
            " */",
            "struct zbud_pool {",
            "\tspinlock_t lock;",
            "\tunion {",
            "\t\t/*",
            "\t\t * Reuse unbuddied[0] as buddied on the ground that",
            "\t\t * unbuddied[0] is unused.",
            "\t\t */",
            "\t\tstruct list_head buddied;",
            "\t\tstruct list_head unbuddied[NCHUNKS];",
            "\t};",
            "\tu64 pages_nr;",
            "};",
            "",
            "/*",
            " * struct zbud_header - zbud page metadata occupying the first chunk of each",
            " *\t\t\tzbud page.",
            " * @buddy:\tlinks the zbud page into the unbuddied/buddied lists in the pool",
            " * @first_chunks:\tthe size of the first buddy in chunks, 0 if free",
            " * @last_chunks:\tthe size of the last buddy in chunks, 0 if free",
            " */",
            "struct zbud_header {",
            "\tstruct list_head buddy;",
            "\tunsigned int first_chunks;",
            "\tunsigned int last_chunks;",
            "};",
            "",
            "/*****************",
            " * Helpers",
            "*****************/",
            "/* Just to make the code easier to read */",
            "enum buddy {",
            "\tFIRST,",
            "\tLAST",
            "};",
            "",
            "/* Converts an allocation size in bytes to size in zbud chunks */"
          ],
          "function_name": null,
          "description": "定义了zbud内存分配器的核心结构体和宏，其中NCHUNKS_ORDER决定分配粒度，struct zbud_pool维护池元数据及空闲列表，struct zbud_header存储页元信息，为后续分配和回收提供基础数据结构。",
          "similarity": 0.4356805682182312
        },
        {
          "chunk_id": 2,
          "file_path": "mm/zbud.c",
          "start_line": 363,
          "end_line": 405,
          "content": [
            "static void zbud_unmap(struct zbud_pool *pool, unsigned long handle)",
            "{",
            "}",
            "static u64 zbud_get_pool_size(struct zbud_pool *pool)",
            "{",
            "\treturn pool->pages_nr;",
            "}",
            "static void zbud_zpool_destroy(void *pool)",
            "{",
            "\tzbud_destroy_pool(pool);",
            "}",
            "static int zbud_zpool_malloc(void *pool, size_t size, gfp_t gfp,",
            "\t\t\tunsigned long *handle)",
            "{",
            "\treturn zbud_alloc(pool, size, gfp, handle);",
            "}",
            "static void zbud_zpool_free(void *pool, unsigned long handle)",
            "{",
            "\tzbud_free(pool, handle);",
            "}",
            "static void zbud_zpool_unmap(void *pool, unsigned long handle)",
            "{",
            "\tzbud_unmap(pool, handle);",
            "}",
            "static u64 zbud_zpool_total_size(void *pool)",
            "{",
            "\treturn zbud_get_pool_size(pool) * PAGE_SIZE;",
            "}",
            "static int __init init_zbud(void)",
            "{",
            "\t/* Make sure the zbud header will fit in one chunk */",
            "\tBUILD_BUG_ON(sizeof(struct zbud_header) > ZHDR_SIZE_ALIGNED);",
            "\tpr_info(\"loaded\\n\");",
            "",
            "\tzpool_register_driver(&zbud_zpool_driver);",
            "",
            "\treturn 0;",
            "}",
            "static void __exit exit_zbud(void)",
            "{",
            "\tzpool_unregister_driver(&zbud_zpool_driver);",
            "\tpr_info(\"unloaded\\n\");",
            "}"
          ],
          "function_name": "zbud_unmap, zbud_get_pool_size, zbud_zpool_destroy, zbud_zpool_malloc, zbud_zpool_free, zbud_zpool_unmap, zbud_zpool_total_size, init_zbud, exit_zbud",
          "description": "提供了zpool驱动接口实现，包含池大小查询、内存释放、句柄解码等操作，通过zpool_register_driver注册驱动，init_zbud和exit_zbud分别负责模块加载时的初始化和卸载清理工作。",
          "similarity": 0.39465224742889404
        }
      ]
    },
    {
      "source_file": "mm/compaction.c",
      "md_summary": "> 自动生成时间: 2025-12-07 15:44:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `compaction.c`\n\n---\n\n# compaction.c 技术文档\n\n## 1. 文件概述\n\n`compaction.c` 是 Linux 内核内存管理子系统中实现**内存压缩（Memory Compaction）**功能的核心文件。其主要目标是**减少外部碎片（external fragmentation）**，通过迁移可移动页面，将物理内存中的空闲页聚集形成连续的大块内存区域，从而满足高阶（high-order）内存分配请求（如透明大页 THP 或 HugeTLB）。该机制高度依赖页面迁移（page migration）来完成实际的页面移动工作。\n\n## 2. 核心功能\n\n### 主要函数\n- **`PageMovable()` / `__SetPageMovable()` / `__ClearPageMovable()`**: 管理页面的可移动性标记，用于标识页面是否可通过注册的 `movable_operations` 进行迁移。\n- **`defer_compaction()` / `compaction_deferred()` / `compaction_defer_reset()`**: 实现**压缩延迟（deferred compaction）**机制，避免在压缩失败后频繁重试，提升系统性能。\n- **`compaction_restarting()`**: 判断是否因多次失败后重新启动压缩流程。\n- **`isolation_suitable()`**: 检查指定 pageblock 是否适合进行页面隔离（用于迁移）。\n- **`reset_cached_positions()`**: 重置压缩控制结构中缓存的扫描位置（迁移源和空闲目标页的起始 PFN）。\n- **`release_free_list()`**: 将临时空闲页面列表中的页面释放回伙伴系统。\n- **`skip_offline_sections()` / `skip_offline_sections_reverse()`**: 在 SPARSEMEM 内存模型下跳过离线内存段。\n\n### 关键数据结构与宏\n- **`struct compact_control`**: 压缩操作的控制上下文（定义在 `internal.h` 中），包含扫描范围、迁移/空闲页面列表等。\n- **`COMPACTION_HPAGE_ORDER`**: 用于计算节点/区域“碎片分数（fragmentation score）”的参考阶数，通常为透明大页或 HugeTLB 的阶数。\n- **`COMPACT_MAX_DEFER_SHIFT`**: 压缩延迟的最大次数（64 次）。\n- **`zone->compact_*` 字段**: 包括 `compact_considered`, `compact_defer_shift`, `compact_order_failed`, `compact_cached_*_pfn` 等，用于跟踪压缩状态和优化扫描。\n\n## 3. 关键实现\n\n### 内存压缩流程\n1. **扫描阶段**：从区域两端向中间扫描：\n   - **迁移源扫描器（migrate scanner）**：从低地址向高地址扫描，寻找可迁移的页面。\n   - **空闲目标扫描器（free scanner）**：从高地址向低地址扫描，寻找空闲页面块。\n2. **页面隔离**：将找到的可迁移页面加入迁移列表，空闲页面加入空闲列表。\n3. **页面迁移**：调用 `migrate_pages()` 将迁移列表中的页面移动到空闲列表提供的目标位置。\n4. **结果处理**：迁移成功后，原位置变为空闲，可能形成更大的连续空闲块；失败则回滚。\n\n### 压缩延迟机制（Deferred Compaction）\n- 当压缩未能成功分配指定 `order` 的页面时，调用 `defer_compaction()` 增加延迟计数器 `compact_defer_shift`。\n- 后续分配请求会通过 `compaction_deferred()` 检查是否应跳过压缩（基于 `compact_considered` 计数和 `defer_limit = 1 << compact_defer_shift`）。\n- 若分配成功或预期成功，则通过 `compaction_defer_reset()` 重置延迟状态。\n- 当延迟达到最大值（`COMPACT_MAX_DEFER_SHIFT`）且考虑次数足够多时，`compaction_restarting()` 返回 true，强制重启完整压缩流程。\n\n### 碎片分数与主动压缩\n- 通过 `COMPACTION_HPAGE_ORDER` 定义的阶数评估区域的外部碎片程度。\n- 主动压缩（proactive compaction）定期（`HPAGE_FRAG_CHECK_INTERVAL_MSEC = 500ms`）检查碎片分数，并在需要时触发后台压缩。\n- `is_via_compact_memory()` 用于识别通过 `/proc/sys/vm/compact_memory` 等接口发起的全量压缩请求（`order = -1`）。\n\n### 页面可移动性管理\n- `__SetPageMovable()` 将 `movable_operations` 指针编码到 `page->mapping` 中，并设置 `PAGE_MAPPING_MOVABLE` 标志。\n- `PageMovable()` 验证页面是否被正确标记为可移动，并确保其操作集有效。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`, `internal.h`, `mm_inline.h` 提供的伙伴系统、页面分配/释放、zone 管理等基础功能。\n- **页面迁移**：紧密集成 `<linux/migrate.h>`，压缩的核心操作由 `migrate_pages()` 完成。\n- **内存模型**：针对 `CONFIG_SPARSEMEM` 提供离线内存段跳过逻辑。\n- **大页支持**：根据 `CONFIG_TRANSPARENT_HUGEPAGE` 或 `CONFIG_HUGETLBFS` 确定 `COMPACTION_HPAGE_ORDER`。\n- **调试与追踪**：使用 `kasan.h`, `page_owner.h` 进行调试；通过 `trace/events/compaction.h` 提供 ftrace 事件。\n- **系统调用与接口**：通过 sysctl (`/proc/sys/vm/`) 和 sysfs (`/sys/devices/system/node/`) 暴露用户空间控制接口。\n- **进程与调度**：使用 `kthread.h`, `freezer.h` 管理后台压缩线程；`psi.h` 用于压力状态监控。\n\n## 5. 使用场景\n\n1. **高阶内存分配失败时**：当 `alloc_pages()` 请求高阶页面（如 order ≥ 3）失败时，内核会尝试同步内存压缩以满足请求。\n2. **透明大页（THP）分配**：THP 需要连续的 2MB 物理内存，压缩是满足此类请求的关键机制。\n3. **主动后台压缩**：通过 `vm.compaction_proactiveness` sysctl 参数配置，内核定期评估内存碎片并主动压缩，预防分配延迟。\n4. **用户空间触发**：管理员可通过写入 `/proc/sys/vm/compact_memory` 或特定 NUMA 节点的 `compact` sysfs 文件，手动触发全量内存压缩。\n5. **CMA（Contiguous Memory Allocator）**：在 CMA 区域分配大块连续内存前，使用压缩机制迁移占用页面以腾出空间（需 `CONFIG_CMA`）。",
      "similarity": 0.5356088876724243,
      "chunks": [
        {
          "chunk_id": 14,
          "file_path": "mm/compaction.c",
          "start_line": 2489,
          "end_line": 2740,
          "content": [
            "static enum compact_result",
            "compaction_suit_allocation_order(struct zone *zone, unsigned int order,",
            "\t\t\t\t int highest_zoneidx, unsigned int alloc_flags)",
            "{",
            "\tunsigned long watermark;",
            "",
            "\twatermark = wmark_pages(zone, alloc_flags & ALLOC_WMARK_MASK);",
            "\tif (zone_watermark_ok(zone, order, watermark, highest_zoneidx,",
            "\t\t\t      alloc_flags))",
            "\t\treturn COMPACT_SUCCESS;",
            "",
            "\tif (!compaction_suitable(zone, order, highest_zoneidx))",
            "\t\treturn COMPACT_SKIPPED;",
            "",
            "\treturn COMPACT_CONTINUE;",
            "}",
            "static enum compact_result",
            "compact_zone(struct compact_control *cc, struct capture_control *capc)",
            "{",
            "\tenum compact_result ret;",
            "\tunsigned long start_pfn = cc->zone->zone_start_pfn;",
            "\tunsigned long end_pfn = zone_end_pfn(cc->zone);",
            "\tunsigned long last_migrated_pfn;",
            "\tconst bool sync = cc->mode != MIGRATE_ASYNC;",
            "\tbool update_cached;",
            "\tunsigned int nr_succeeded = 0, nr_migratepages;",
            "\tint order;",
            "",
            "\t/*",
            "\t * These counters track activities during zone compaction.  Initialize",
            "\t * them before compacting a new zone.",
            "\t */",
            "\tcc->total_migrate_scanned = 0;",
            "\tcc->total_free_scanned = 0;",
            "\tcc->nr_migratepages = 0;",
            "\tcc->nr_freepages = 0;",
            "\tfor (order = 0; order < NR_PAGE_ORDERS; order++)",
            "\t\tINIT_LIST_HEAD(&cc->freepages[order]);",
            "\tINIT_LIST_HEAD(&cc->migratepages);",
            "",
            "\tcc->migratetype = gfp_migratetype(cc->gfp_mask);",
            "",
            "\tif (!is_via_compact_memory(cc->order)) {",
            "\t\tret = compaction_suit_allocation_order(cc->zone, cc->order,",
            "\t\t\t\t\t\t       cc->highest_zoneidx,",
            "\t\t\t\t\t\t       cc->alloc_flags);",
            "\t\tif (ret != COMPACT_CONTINUE)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * Clear pageblock skip if there were failures recently and compaction",
            "\t * is about to be retried after being deferred.",
            "\t */",
            "\tif (compaction_restarting(cc->zone, cc->order))",
            "\t\t__reset_isolation_suitable(cc->zone);",
            "",
            "\t/*",
            "\t * Setup to move all movable pages to the end of the zone. Used cached",
            "\t * information on where the scanners should start (unless we explicitly",
            "\t * want to compact the whole zone), but check that it is initialised",
            "\t * by ensuring the values are within zone boundaries.",
            "\t */",
            "\tcc->fast_start_pfn = 0;",
            "\tif (cc->whole_zone) {",
            "\t\tcc->migrate_pfn = start_pfn;",
            "\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);",
            "\t} else {",
            "\t\tcc->migrate_pfn = cc->zone->compact_cached_migrate_pfn[sync];",
            "\t\tcc->free_pfn = cc->zone->compact_cached_free_pfn;",
            "\t\tif (cc->free_pfn < start_pfn || cc->free_pfn >= end_pfn) {",
            "\t\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);",
            "\t\t\tcc->zone->compact_cached_free_pfn = cc->free_pfn;",
            "\t\t}",
            "\t\tif (cc->migrate_pfn < start_pfn || cc->migrate_pfn >= end_pfn) {",
            "\t\t\tcc->migrate_pfn = start_pfn;",
            "\t\t\tcc->zone->compact_cached_migrate_pfn[0] = cc->migrate_pfn;",
            "\t\t\tcc->zone->compact_cached_migrate_pfn[1] = cc->migrate_pfn;",
            "\t\t}",
            "",
            "\t\tif (cc->migrate_pfn <= cc->zone->compact_init_migrate_pfn)",
            "\t\t\tcc->whole_zone = true;",
            "\t}",
            "",
            "\tlast_migrated_pfn = 0;",
            "",
            "\t/*",
            "\t * Migrate has separate cached PFNs for ASYNC and SYNC* migration on",
            "\t * the basis that some migrations will fail in ASYNC mode. However,",
            "\t * if the cached PFNs match and pageblocks are skipped due to having",
            "\t * no isolation candidates, then the sync state does not matter.",
            "\t * Until a pageblock with isolation candidates is found, keep the",
            "\t * cached PFNs in sync to avoid revisiting the same blocks.",
            "\t */",
            "\tupdate_cached = !sync &&",
            "\t\tcc->zone->compact_cached_migrate_pfn[0] == cc->zone->compact_cached_migrate_pfn[1];",
            "",
            "\ttrace_mm_compaction_begin(cc, start_pfn, end_pfn, sync);",
            "",
            "\t/* lru_add_drain_all could be expensive with involving other CPUs */",
            "\tlru_add_drain();",
            "",
            "\twhile ((ret = compact_finished(cc)) == COMPACT_CONTINUE) {",
            "\t\tint err;",
            "\t\tunsigned long iteration_start_pfn = cc->migrate_pfn;",
            "",
            "\t\t/*",
            "\t\t * Avoid multiple rescans of the same pageblock which can",
            "\t\t * happen if a page cannot be isolated (dirty/writeback in",
            "\t\t * async mode) or if the migrated pages are being allocated",
            "\t\t * before the pageblock is cleared.  The first rescan will",
            "\t\t * capture the entire pageblock for migration. If it fails,",
            "\t\t * it'll be marked skip and scanning will proceed as normal.",
            "\t\t */",
            "\t\tcc->finish_pageblock = false;",
            "\t\tif (pageblock_start_pfn(last_migrated_pfn) ==",
            "\t\t    pageblock_start_pfn(iteration_start_pfn)) {",
            "\t\t\tcc->finish_pageblock = true;",
            "\t\t}",
            "",
            "rescan:",
            "\t\tswitch (isolate_migratepages(cc)) {",
            "\t\tcase ISOLATE_ABORT:",
            "\t\t\tret = COMPACT_CONTENDED;",
            "\t\t\tputback_movable_pages(&cc->migratepages);",
            "\t\t\tcc->nr_migratepages = 0;",
            "\t\t\tgoto out;",
            "\t\tcase ISOLATE_NONE:",
            "\t\t\tif (update_cached) {",
            "\t\t\t\tcc->zone->compact_cached_migrate_pfn[1] =",
            "\t\t\t\t\tcc->zone->compact_cached_migrate_pfn[0];",
            "\t\t\t}",
            "",
            "\t\t\t/*",
            "\t\t\t * We haven't isolated and migrated anything, but",
            "\t\t\t * there might still be unflushed migrations from",
            "\t\t\t * previous cc->order aligned block.",
            "\t\t\t */",
            "\t\t\tgoto check_drain;",
            "\t\tcase ISOLATE_SUCCESS:",
            "\t\t\tupdate_cached = false;",
            "\t\t\tlast_migrated_pfn = max(cc->zone->zone_start_pfn,",
            "\t\t\t\tpageblock_start_pfn(cc->migrate_pfn - 1));",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Record the number of pages to migrate since the",
            "\t\t * compaction_alloc/free() will update cc->nr_migratepages",
            "\t\t * properly.",
            "\t\t */",
            "\t\tnr_migratepages = cc->nr_migratepages;",
            "\t\terr = migrate_pages(&cc->migratepages, compaction_alloc,",
            "\t\t\t\tcompaction_free, (unsigned long)cc, cc->mode,",
            "\t\t\t\tMR_COMPACTION, &nr_succeeded);",
            "",
            "\t\ttrace_mm_compaction_migratepages(nr_migratepages, nr_succeeded);",
            "",
            "\t\t/* All pages were either migrated or will be released */",
            "\t\tcc->nr_migratepages = 0;",
            "\t\tif (err) {",
            "\t\t\tputback_movable_pages(&cc->migratepages);",
            "\t\t\t/*",
            "\t\t\t * migrate_pages() may return -ENOMEM when scanners meet",
            "\t\t\t * and we want compact_finished() to detect it",
            "\t\t\t */",
            "\t\t\tif (err == -ENOMEM && !compact_scanners_met(cc)) {",
            "\t\t\t\tret = COMPACT_CONTENDED;",
            "\t\t\t\tgoto out;",
            "\t\t\t}",
            "\t\t\t/*",
            "\t\t\t * If an ASYNC or SYNC_LIGHT fails to migrate a page",
            "\t\t\t * within the pageblock_order-aligned block and",
            "\t\t\t * fast_find_migrateblock may be used then scan the",
            "\t\t\t * remainder of the pageblock. This will mark the",
            "\t\t\t * pageblock \"skip\" to avoid rescanning in the near",
            "\t\t\t * future. This will isolate more pages than necessary",
            "\t\t\t * for the request but avoid loops due to",
            "\t\t\t * fast_find_migrateblock revisiting blocks that were",
            "\t\t\t * recently partially scanned.",
            "\t\t\t */",
            "\t\t\tif (!pageblock_aligned(cc->migrate_pfn) &&",
            "\t\t\t    !cc->ignore_skip_hint && !cc->finish_pageblock &&",
            "\t\t\t    (cc->mode < MIGRATE_SYNC)) {",
            "\t\t\t\tcc->finish_pageblock = true;",
            "",
            "\t\t\t\t/*",
            "\t\t\t\t * Draining pcplists does not help THP if",
            "\t\t\t\t * any page failed to migrate. Even after",
            "\t\t\t\t * drain, the pageblock will not be free.",
            "\t\t\t\t */",
            "\t\t\t\tif (cc->order == COMPACTION_HPAGE_ORDER)",
            "\t\t\t\t\tlast_migrated_pfn = 0;",
            "",
            "\t\t\t\tgoto rescan;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\t/* Stop if a page has been captured */",
            "\t\tif (capc && capc->page) {",
            "\t\t\tret = COMPACT_SUCCESS;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "check_drain:",
            "\t\t/*",
            "\t\t * Has the migration scanner moved away from the previous",
            "\t\t * cc->order aligned block where we migrated from? If yes,",
            "\t\t * flush the pages that were freed, so that they can merge and",
            "\t\t * compact_finished() can detect immediately if allocation",
            "\t\t * would succeed.",
            "\t\t */",
            "\t\tif (cc->order > 0 && last_migrated_pfn) {",
            "\t\t\tunsigned long current_block_start =",
            "\t\t\t\tblock_start_pfn(cc->migrate_pfn, cc->order);",
            "",
            "\t\t\tif (last_migrated_pfn < current_block_start) {",
            "\t\t\t\tlru_add_drain_cpu_zone(cc->zone);",
            "\t\t\t\t/* No more flushing until we migrate again */",
            "\t\t\t\tlast_migrated_pfn = 0;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "out:",
            "\t/*",
            "\t * Release free pages and update where the free scanner should restart,",
            "\t * so we don't leave any returned pages behind in the next attempt.",
            "\t */",
            "\tif (cc->nr_freepages > 0) {",
            "\t\tunsigned long free_pfn = release_free_list(cc->freepages);",
            "",
            "\t\tcc->nr_freepages = 0;",
            "\t\tVM_BUG_ON(free_pfn == 0);",
            "\t\t/* The cached pfn is always the first in a pageblock */",
            "\t\tfree_pfn = pageblock_start_pfn(free_pfn);",
            "\t\t/*",
            "\t\t * Only go back, not forward. The cached pfn might have been",
            "\t\t * already reset to zone end in compact_finished()",
            "\t\t */",
            "\t\tif (free_pfn > cc->zone->compact_cached_free_pfn)",
            "\t\t\tcc->zone->compact_cached_free_pfn = free_pfn;",
            "\t}",
            "",
            "\tcount_compact_events(COMPACTMIGRATE_SCANNED, cc->total_migrate_scanned);",
            "\tcount_compact_events(COMPACTFREE_SCANNED, cc->total_free_scanned);",
            "",
            "\ttrace_mm_compaction_end(cc, start_pfn, end_pfn, sync, ret);",
            "",
            "\tVM_BUG_ON(!list_empty(&cc->migratepages));",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "compaction_suit_allocation_order, compact_zone",
          "description": "compaction_suit_allocation_order检查分配顺序兼容性，compact_zone执行核心压缩流程，迁移页面并调整缓存扫描起点，处理页块扫描和迁移结果",
          "similarity": 0.5252944231033325
        },
        {
          "chunk_id": 5,
          "file_path": "mm/compaction.c",
          "start_line": 725,
          "end_line": 837,
          "content": [
            "unsigned long",
            "isolate_freepages_range(struct compact_control *cc,",
            "\t\t\tunsigned long start_pfn, unsigned long end_pfn)",
            "{",
            "\tunsigned long isolated, pfn, block_start_pfn, block_end_pfn;",
            "\tint order;",
            "",
            "\tfor (order = 0; order < NR_PAGE_ORDERS; order++)",
            "\t\tINIT_LIST_HEAD(&cc->freepages[order]);",
            "",
            "\tpfn = start_pfn;",
            "\tblock_start_pfn = pageblock_start_pfn(pfn);",
            "\tif (block_start_pfn < cc->zone->zone_start_pfn)",
            "\t\tblock_start_pfn = cc->zone->zone_start_pfn;",
            "\tblock_end_pfn = pageblock_end_pfn(pfn);",
            "",
            "\tfor (; pfn < end_pfn; pfn += isolated,",
            "\t\t\t\tblock_start_pfn = block_end_pfn,",
            "\t\t\t\tblock_end_pfn += pageblock_nr_pages) {",
            "\t\t/* Protect pfn from changing by isolate_freepages_block */",
            "\t\tunsigned long isolate_start_pfn = pfn;",
            "",
            "\t\t/*",
            "\t\t * pfn could pass the block_end_pfn if isolated freepage",
            "\t\t * is more than pageblock order. In this case, we adjust",
            "\t\t * scanning range to right one.",
            "\t\t */",
            "\t\tif (pfn >= block_end_pfn) {",
            "\t\t\tblock_start_pfn = pageblock_start_pfn(pfn);",
            "\t\t\tblock_end_pfn = pageblock_end_pfn(pfn);",
            "\t\t}",
            "",
            "\t\tblock_end_pfn = min(block_end_pfn, end_pfn);",
            "",
            "\t\tif (!pageblock_pfn_to_page(block_start_pfn,",
            "\t\t\t\t\tblock_end_pfn, cc->zone))",
            "\t\t\tbreak;",
            "",
            "\t\tisolated = isolate_freepages_block(cc, &isolate_start_pfn,",
            "\t\t\t\t\tblock_end_pfn, cc->freepages, 0, true);",
            "",
            "\t\t/*",
            "\t\t * In strict mode, isolate_freepages_block() returns 0 if",
            "\t\t * there are any holes in the block (ie. invalid PFNs or",
            "\t\t * non-free pages).",
            "\t\t */",
            "\t\tif (!isolated)",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * If we managed to isolate pages, it is always (1 << n) *",
            "\t\t * pageblock_nr_pages for some non-negative n.  (Max order",
            "\t\t * page may span two pageblocks).",
            "\t\t */",
            "\t}",
            "",
            "\tif (pfn < end_pfn) {",
            "\t\t/* Loop terminated early, cleanup. */",
            "\t\trelease_free_list(cc->freepages);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/* We don't use freelists for anything. */",
            "\treturn pfn;",
            "}",
            "static bool too_many_isolated(struct compact_control *cc)",
            "{",
            "\tpg_data_t *pgdat = cc->zone->zone_pgdat;",
            "\tbool too_many;",
            "",
            "\tunsigned long active, inactive, isolated;",
            "",
            "\tinactive = node_page_state(pgdat, NR_INACTIVE_FILE) +",
            "\t\t\tnode_page_state(pgdat, NR_INACTIVE_ANON);",
            "\tactive = node_page_state(pgdat, NR_ACTIVE_FILE) +",
            "\t\t\tnode_page_state(pgdat, NR_ACTIVE_ANON);",
            "\tisolated = node_page_state(pgdat, NR_ISOLATED_FILE) +",
            "\t\t\tnode_page_state(pgdat, NR_ISOLATED_ANON);",
            "",
            "\t/*",
            "\t * Allow GFP_NOFS to isolate past the limit set for regular",
            "\t * compaction runs. This prevents an ABBA deadlock when other",
            "\t * compactors have already isolated to the limit, but are",
            "\t * blocked on filesystem locks held by the GFP_NOFS thread.",
            "\t */",
            "\tif (cc->gfp_mask & __GFP_FS) {",
            "\t\tinactive >>= 3;",
            "\t\tactive >>= 3;",
            "\t}",
            "",
            "\ttoo_many = isolated > (inactive + active) / 2;",
            "\tif (!too_many)",
            "\t\twake_throttle_isolated(pgdat);",
            "",
            "\treturn too_many;",
            "}",
            "static bool skip_isolation_on_order(int order, int target_order)",
            "{",
            "\t/*",
            "\t * Unless we are performing global compaction (i.e.,",
            "\t * is_via_compact_memory), skip any folios that are larger than the",
            "\t * target order: we wouldn't be here if we'd have a free folio with",
            "\t * the desired target_order, so migrating this folio would likely fail",
            "\t * later.",
            "\t */",
            "\tif (!is_via_compact_memory(target_order) && order >= target_order)",
            "\t\treturn true;",
            "\t/*",
            "\t * We limit memory compaction to pageblocks and won't try",
            "\t * creating free blocks of memory that are larger than that.",
            "\t */",
            "\treturn order >= pageblock_order;",
            "}"
          ],
          "function_name": "isolate_freepages_range, too_many_isolated, skip_isolation_on_order",
          "description": "isolate_freepages_range扫描指定PFN范围内的页面块，隔离空闲页至freepages数组；too_many_isolated检测当前系统是否已隔离过多页面以避免死锁；skip_isolation_on_order判断是否跳过大于目标顺序的页面",
          "similarity": 0.5231034159660339
        },
        {
          "chunk_id": 1,
          "file_path": "mm/compaction.c",
          "start_line": 34,
          "end_line": 141,
          "content": [
            "static inline void count_compact_event(enum vm_event_item item)",
            "{",
            "\tcount_vm_event(item);",
            "}",
            "static inline void count_compact_events(enum vm_event_item item, long delta)",
            "{",
            "\tcount_vm_events(item, delta);",
            "}",
            "static inline bool is_via_compact_memory(int order)",
            "{",
            "\treturn order == -1;",
            "}",
            "static inline bool is_via_compact_memory(int order) { return false; }",
            "static unsigned long release_free_list(struct list_head *freepages)",
            "{",
            "\tint order;",
            "\tunsigned long high_pfn = 0;",
            "",
            "\tfor (order = 0; order < NR_PAGE_ORDERS; order++) {",
            "\t\tstruct page *page, *next;",
            "",
            "\t\tlist_for_each_entry_safe(page, next, &freepages[order], lru) {",
            "\t\t\tunsigned long pfn = page_to_pfn(page);",
            "",
            "\t\t\tlist_del(&page->lru);",
            "\t\t\t/*",
            "\t\t\t * Convert free pages into post allocation pages, so",
            "\t\t\t * that we can free them via __free_page.",
            "\t\t\t */",
            "\t\t\tmark_allocated(page, order, __GFP_MOVABLE);",
            "\t\t\t__free_pages(page, order);",
            "\t\t\tif (pfn > high_pfn)",
            "\t\t\t\thigh_pfn = pfn;",
            "\t\t}",
            "\t}",
            "\treturn high_pfn;",
            "}",
            "bool PageMovable(struct page *page)",
            "{",
            "\tconst struct movable_operations *mops;",
            "",
            "\tVM_BUG_ON_PAGE(!PageLocked(page), page);",
            "\tif (!__PageMovable(page))",
            "\t\treturn false;",
            "",
            "\tmops = page_movable_ops(page);",
            "\tif (mops)",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "void __SetPageMovable(struct page *page, const struct movable_operations *mops)",
            "{",
            "\tVM_BUG_ON_PAGE(!PageLocked(page), page);",
            "\tVM_BUG_ON_PAGE((unsigned long)mops & PAGE_MAPPING_MOVABLE, page);",
            "\tpage->mapping = (void *)((unsigned long)mops | PAGE_MAPPING_MOVABLE);",
            "}",
            "void __ClearPageMovable(struct page *page)",
            "{",
            "\tVM_BUG_ON_PAGE(!PageMovable(page), page);",
            "\t/*",
            "\t * This page still has the type of a movable page, but it's",
            "\t * actually not movable any more.",
            "\t */",
            "\tpage->mapping = (void *)PAGE_MAPPING_MOVABLE;",
            "}",
            "static void defer_compaction(struct zone *zone, int order)",
            "{",
            "\tzone->compact_considered = 0;",
            "\tzone->compact_defer_shift++;",
            "",
            "\tif (order < zone->compact_order_failed)",
            "\t\tzone->compact_order_failed = order;",
            "",
            "\tif (zone->compact_defer_shift > COMPACT_MAX_DEFER_SHIFT)",
            "\t\tzone->compact_defer_shift = COMPACT_MAX_DEFER_SHIFT;",
            "",
            "\ttrace_mm_compaction_defer_compaction(zone, order);",
            "}",
            "static bool compaction_deferred(struct zone *zone, int order)",
            "{",
            "\tunsigned long defer_limit = 1UL << zone->compact_defer_shift;",
            "",
            "\tif (order < zone->compact_order_failed)",
            "\t\treturn false;",
            "",
            "\t/* Avoid possible overflow */",
            "\tif (++zone->compact_considered >= defer_limit) {",
            "\t\tzone->compact_considered = defer_limit;",
            "\t\treturn false;",
            "\t}",
            "",
            "\ttrace_mm_compaction_deferred(zone, order);",
            "",
            "\treturn true;",
            "}",
            "void compaction_defer_reset(struct zone *zone, int order,",
            "\t\tbool alloc_success)",
            "{",
            "\tif (alloc_success) {",
            "\t\tzone->compact_considered = 0;",
            "\t\tzone->compact_defer_shift = 0;",
            "\t}",
            "\tif (order >= zone->compact_order_failed)",
            "\t\tzone->compact_order_failed = order + 1;",
            "",
            "\ttrace_mm_compaction_defer_reset(zone, order);",
            "}"
          ],
          "function_name": "count_compact_event, count_compact_events, is_via_compact_memory, is_via_compact_memory, release_free_list, PageMovable, __SetPageMovable, __ClearPageMovable, defer_compaction, compaction_deferred, compaction_defer_reset",
          "description": "提供内存压缩事件计数、页面可移动性检测、空闲列表释放、延迟压缩逻辑及页面块隔离辅助函数，包含重复定义可能导致冲突",
          "similarity": 0.5217821598052979
        },
        {
          "chunk_id": 2,
          "file_path": "mm/compaction.c",
          "start_line": 209,
          "end_line": 347,
          "content": [
            "static bool compaction_restarting(struct zone *zone, int order)",
            "{",
            "\tif (order < zone->compact_order_failed)",
            "\t\treturn false;",
            "",
            "\treturn zone->compact_defer_shift == COMPACT_MAX_DEFER_SHIFT &&",
            "\t\tzone->compact_considered >= 1UL << zone->compact_defer_shift;",
            "}",
            "static inline bool isolation_suitable(struct compact_control *cc,",
            "\t\t\t\t\tstruct page *page)",
            "{",
            "\tif (cc->ignore_skip_hint)",
            "\t\treturn true;",
            "",
            "\treturn !get_pageblock_skip(page);",
            "}",
            "static void reset_cached_positions(struct zone *zone)",
            "{",
            "\tzone->compact_cached_migrate_pfn[0] = zone->zone_start_pfn;",
            "\tzone->compact_cached_migrate_pfn[1] = zone->zone_start_pfn;",
            "\tzone->compact_cached_free_pfn =",
            "\t\t\t\tpageblock_start_pfn(zone_end_pfn(zone) - 1);",
            "}",
            "static unsigned long skip_offline_sections(unsigned long start_pfn)",
            "{",
            "\tunsigned long start_nr = pfn_to_section_nr(start_pfn);",
            "",
            "\tif (online_section_nr(start_nr))",
            "\t\treturn 0;",
            "",
            "\twhile (++start_nr <= __highest_present_section_nr) {",
            "\t\tif (online_section_nr(start_nr))",
            "\t\t\treturn section_nr_to_pfn(start_nr);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static unsigned long skip_offline_sections_reverse(unsigned long start_pfn)",
            "{",
            "\tunsigned long start_nr = pfn_to_section_nr(start_pfn);",
            "",
            "\tif (!start_nr || online_section_nr(start_nr))",
            "\t\treturn 0;",
            "",
            "\twhile (start_nr-- > 0) {",
            "\t\tif (online_section_nr(start_nr))",
            "\t\t\treturn section_nr_to_pfn(start_nr) + PAGES_PER_SECTION;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static unsigned long skip_offline_sections(unsigned long start_pfn)",
            "{",
            "\treturn 0;",
            "}",
            "static unsigned long skip_offline_sections_reverse(unsigned long start_pfn)",
            "{",
            "\treturn 0;",
            "}",
            "static bool pageblock_skip_persistent(struct page *page)",
            "{",
            "\tif (!PageCompound(page))",
            "\t\treturn false;",
            "",
            "\tpage = compound_head(page);",
            "",
            "\tif (compound_order(page) >= pageblock_order)",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "static bool",
            "__reset_isolation_pfn(struct zone *zone, unsigned long pfn, bool check_source,",
            "\t\t\t\t\t\t\tbool check_target)",
            "{",
            "\tstruct page *page = pfn_to_online_page(pfn);",
            "\tstruct page *block_page;",
            "\tstruct page *end_page;",
            "\tunsigned long block_pfn;",
            "",
            "\tif (!page)",
            "\t\treturn false;",
            "\tif (zone != page_zone(page))",
            "\t\treturn false;",
            "\tif (pageblock_skip_persistent(page))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * If skip is already cleared do no further checking once the",
            "\t * restart points have been set.",
            "\t */",
            "\tif (check_source && check_target && !get_pageblock_skip(page))",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * If clearing skip for the target scanner, do not select a",
            "\t * non-movable pageblock as the starting point.",
            "\t */",
            "\tif (!check_source && check_target &&",
            "\t    get_pageblock_migratetype(page) != MIGRATE_MOVABLE)",
            "\t\treturn false;",
            "",
            "\t/* Ensure the start of the pageblock or zone is online and valid */",
            "\tblock_pfn = pageblock_start_pfn(pfn);",
            "\tblock_pfn = max(block_pfn, zone->zone_start_pfn);",
            "\tblock_page = pfn_to_online_page(block_pfn);",
            "\tif (block_page) {",
            "\t\tpage = block_page;",
            "\t\tpfn = block_pfn;",
            "\t}",
            "",
            "\t/* Ensure the end of the pageblock or zone is online and valid */",
            "\tblock_pfn = pageblock_end_pfn(pfn) - 1;",
            "\tblock_pfn = min(block_pfn, zone_end_pfn(zone) - 1);",
            "\tend_page = pfn_to_online_page(block_pfn);",
            "\tif (!end_page)",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Only clear the hint if a sample indicates there is either a",
            "\t * free page or an LRU page in the block. One or other condition",
            "\t * is necessary for the block to be a migration source/target.",
            "\t */",
            "\tdo {",
            "\t\tif (check_source && PageLRU(page)) {",
            "\t\t\tclear_pageblock_skip(page);",
            "\t\t\treturn true;",
            "\t\t}",
            "",
            "\t\tif (check_target && PageBuddy(page)) {",
            "\t\t\tclear_pageblock_skip(page);",
            "\t\t\treturn true;",
            "\t\t}",
            "",
            "\t\tpage += (1 << PAGE_ALLOC_COSTLY_ORDER);",
            "\t} while (page <= end_page);",
            "",
            "\treturn false;",
            "}"
          ],
          "function_name": "compaction_restarting, isolation_suitable, reset_cached_positions, skip_offline_sections, skip_offline_sections_reverse, skip_offline_sections, skip_offline_sections_reverse, pageblock_skip_persistent, __reset_isolation_pfn",
          "description": "实现压缩重启条件判定、隔离兼容性检查、跳过离线section、页面块持久性跳过标记及隔离信息更新功能",
          "similarity": 0.5157123804092407
        },
        {
          "chunk_id": 4,
          "file_path": "mm/compaction.c",
          "start_line": 501,
          "end_line": 675,
          "content": [
            "static inline bool isolation_suitable(struct compact_control *cc,",
            "\t\t\t\t\tstruct page *page)",
            "{",
            "\treturn true;",
            "}",
            "static inline bool pageblock_skip_persistent(struct page *page)",
            "{",
            "\treturn false;",
            "}",
            "static inline void update_pageblock_skip(struct compact_control *cc,",
            "\t\t\tstruct page *page, unsigned long pfn)",
            "{",
            "}",
            "static void update_cached_migrate(struct compact_control *cc, unsigned long pfn)",
            "{",
            "}",
            "static bool test_and_set_skip(struct compact_control *cc, struct page *page)",
            "{",
            "\treturn false;",
            "}",
            "static bool compact_lock_irqsave(spinlock_t *lock, unsigned long *flags,",
            "\t\t\t\t\t\tstruct compact_control *cc)",
            "\t__acquires(lock)",
            "{",
            "\t/* Track if the lock is contended in async mode */",
            "\tif (cc->mode == MIGRATE_ASYNC && !cc->contended) {",
            "\t\tif (spin_trylock_irqsave(lock, *flags))",
            "\t\t\treturn true;",
            "",
            "\t\tcc->contended = true;",
            "\t}",
            "",
            "\tspin_lock_irqsave(lock, *flags);",
            "\treturn true;",
            "}",
            "static bool compact_unlock_should_abort(spinlock_t *lock,",
            "\t\tunsigned long flags, bool *locked, struct compact_control *cc)",
            "{",
            "\tif (*locked) {",
            "\t\tspin_unlock_irqrestore(lock, flags);",
            "\t\t*locked = false;",
            "\t}",
            "",
            "\tif (fatal_signal_pending(current)) {",
            "\t\tcc->contended = true;",
            "\t\treturn true;",
            "\t}",
            "",
            "\tcond_resched();",
            "",
            "\treturn false;",
            "}",
            "static unsigned long isolate_freepages_block(struct compact_control *cc,",
            "\t\t\t\tunsigned long *start_pfn,",
            "\t\t\t\tunsigned long end_pfn,",
            "\t\t\t\tstruct list_head *freelist,",
            "\t\t\t\tunsigned int stride,",
            "\t\t\t\tbool strict)",
            "{",
            "\tint nr_scanned = 0, total_isolated = 0;",
            "\tstruct page *page;",
            "\tunsigned long flags = 0;",
            "\tbool locked = false;",
            "\tunsigned long blockpfn = *start_pfn;",
            "\tunsigned int order;",
            "",
            "\t/* Strict mode is for isolation, speed is secondary */",
            "\tif (strict)",
            "\t\tstride = 1;",
            "",
            "\tpage = pfn_to_page(blockpfn);",
            "",
            "\t/* Isolate free pages. */",
            "\tfor (; blockpfn < end_pfn; blockpfn += stride, page += stride) {",
            "\t\tint isolated;",
            "",
            "\t\t/*",
            "\t\t * Periodically drop the lock (if held) regardless of its",
            "\t\t * contention, to give chance to IRQs. Abort if fatal signal",
            "\t\t * pending.",
            "\t\t */",
            "\t\tif (!(blockpfn % COMPACT_CLUSTER_MAX)",
            "\t\t    && compact_unlock_should_abort(&cc->zone->lock, flags,",
            "\t\t\t\t\t\t\t\t&locked, cc))",
            "\t\t\tbreak;",
            "",
            "\t\tnr_scanned++;",
            "",
            "\t\t/*",
            "\t\t * For compound pages such as THP and hugetlbfs, we can save",
            "\t\t * potentially a lot of iterations if we skip them at once.",
            "\t\t * The check is racy, but we can consider only valid values",
            "\t\t * and the only danger is skipping too much.",
            "\t\t */",
            "\t\tif (PageCompound(page)) {",
            "\t\t\tconst unsigned int order = compound_order(page);",
            "",
            "\t\t\tif ((order <= MAX_PAGE_ORDER) &&",
            "\t\t\t    (blockpfn + (1UL << order) <= end_pfn)) {",
            "\t\t\t\tblockpfn += (1UL << order) - 1;",
            "\t\t\t\tpage += (1UL << order) - 1;",
            "\t\t\t\tnr_scanned += (1UL << order) - 1;",
            "\t\t\t}",
            "",
            "\t\t\tgoto isolate_fail;",
            "\t\t}",
            "",
            "\t\tif (!PageBuddy(page))",
            "\t\t\tgoto isolate_fail;",
            "",
            "\t\t/* If we already hold the lock, we can skip some rechecking. */",
            "\t\tif (!locked) {",
            "\t\t\tlocked = compact_lock_irqsave(&cc->zone->lock,",
            "\t\t\t\t\t\t\t\t&flags, cc);",
            "",
            "\t\t\t/* Recheck this is a buddy page under lock */",
            "\t\t\tif (!PageBuddy(page))",
            "\t\t\t\tgoto isolate_fail;",
            "\t\t}",
            "",
            "\t\t/* Found a free page, will break it into order-0 pages */",
            "\t\torder = buddy_order(page);",
            "\t\tisolated = __isolate_free_page(page, order);",
            "\t\tif (!isolated)",
            "\t\t\tbreak;",
            "\t\tset_page_private(page, order);",
            "",
            "\t\tnr_scanned += isolated - 1;",
            "\t\ttotal_isolated += isolated;",
            "\t\tcc->nr_freepages += isolated;",
            "\t\tlist_add_tail(&page->lru, &freelist[order]);",
            "",
            "\t\tif (!strict && cc->nr_migratepages <= cc->nr_freepages) {",
            "\t\t\tblockpfn += isolated;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t/* Advance to the end of split page */",
            "\t\tblockpfn += isolated - 1;",
            "\t\tpage += isolated - 1;",
            "\t\tcontinue;",
            "",
            "isolate_fail:",
            "\t\tif (strict)",
            "\t\t\tbreak;",
            "",
            "\t}",
            "",
            "\tif (locked)",
            "\t\tspin_unlock_irqrestore(&cc->zone->lock, flags);",
            "",
            "\t/*",
            "\t * Be careful to not go outside of the pageblock.",
            "\t */",
            "\tif (unlikely(blockpfn > end_pfn))",
            "\t\tblockpfn = end_pfn;",
            "",
            "\ttrace_mm_compaction_isolate_freepages(*start_pfn, blockpfn,",
            "\t\t\t\t\tnr_scanned, total_isolated);",
            "",
            "\t/* Record how far we have got within the block */",
            "\t*start_pfn = blockpfn;",
            "",
            "\t/*",
            "\t * If strict isolation is requested by CMA then check that all the",
            "\t * pages requested were isolated. If there were any failures, 0 is",
            "\t * returned and CMA will fail.",
            "\t */",
            "\tif (strict && blockpfn < end_pfn)",
            "\t\ttotal_isolated = 0;",
            "",
            "\tcc->total_free_scanned += nr_scanned;",
            "\tif (total_isolated)",
            "\t\tcount_compact_events(COMPACTISOLATED, total_isolated);",
            "\treturn total_isolated;",
            "}"
          ],
          "function_name": "isolation_suitable, pageblock_skip_persistent, update_pageblock_skip, update_cached_migrate, test_and_set_skip, compact_lock_irqsave, compact_unlock_should_abort, isolate_freepages_block",
          "description": "实现页面块隔离核心逻辑，包含并发锁管理、页面扫描与隔离、严格模式下强制隔离等功能，支持CMA内存分配需求",
          "similarity": 0.5028625726699829
        }
      ]
    }
  ]
}