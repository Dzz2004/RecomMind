{
  "query": "虚拟化环境中balance_dirty_pages_ratelimited的调优",
  "timestamp": "2025-12-26 01:48:30",
  "retrieved_files": [
    {
      "source_file": "mm/page-writeback.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:59:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page-writeback.c`\n\n---\n\n# page-writeback.c 技术文档\n\n## 1. 文件概述\n\n`page-writeback.c` 是 Linux 内核内存管理子系统（MM）中的核心文件，负责实现**脏页回写（dirty page writeback）机制**。该机制用于控制和协调将修改过的页面（即“脏页”）从内存写回到持久化存储（如磁盘）的过程，以确保数据一致性、防止内存耗尽，并在系统负载与 I/O 带宽之间取得平衡。\n\n该文件主要提供以下功能：\n- 脏页数量的全局与每 BDI（Backing Device Info）级别的阈值管理\n- 脏页生成速率的动态限流（throttling）\n- 后台回写线程（如 `writeback` 线程）的触发逻辑\n- 支持基于 cgroup 的内存回写控制（当启用 `CONFIG_CGROUP_WRITEBACK` 时）\n- 与 `/proc/sys/vm` 中可调参数的交互接口\n\n## 2. 核心功能\n\n### 主要全局变量（可通过 sysctl 调整）\n| 变量名 | 默认值 | 说明 |\n|--------|--------|------|\n| `dirty_background_ratio` | 10 | 当脏页占可用内存比例达到此值时，启动后台回写 |\n| `vm_dirty_ratio` | 20 | 脏页比例硬上限，超过则阻塞写进程进行同步回写 |\n| `dirty_background_bytes` | 0 | 以字节为单位指定后台回写阈值（优先级高于 ratio） |\n| `vm_dirty_bytes` | 0 | 以字节为单位指定脏页硬上限（优先级高于 ratio） |\n| `dirty_writeback_interval` | 500 (5秒) | 后台回写线程的唤醒间隔（单位：厘秒） |\n| `dirty_expire_interval` | 3000 (30秒) | 脏页最大存活时间，超时强制回写 |\n| `laptop_mode` | 0 | 笔记本模式开关，减少磁盘活动以省电 |\n| `ratelimit_pages` | 32 | 每 CPU 脏页速率限制阈值 |\n\n### 关键数据结构\n- **`struct wb_domain`**  \n  回写域（writeback domain），用于聚合多个 BDI 的回写状态，支持全局或 per-memcg 的回写控制。\n  \n- **`struct dirty_throttle_control` (dtc)**  \n  脏页限流控制上下文，包含：\n  - `avail`：当前可脏化的内存总量\n  - `dirty`：当前脏页数量\n  - `thresh` / `bg_thresh`：硬/软回写阈值\n  - `wb_dirty` / `wb_thresh` / `wb_bg_thresh`：per-BDI 级别的对应值\n  - `pos_ratio`：用于计算回写速率的比例因子\n\n- **条件编译支持**  \n  通过 `CONFIG_CGROUP_WRITEBACK` 区分是否支持 memcg 级别的回写控制，提供 `GDTC_INIT`、`MDTC_INIT` 等宏及辅助函数（如 `mdtc_valid()`、`wb_min_max_ratio()`）。\n\n### 核心辅助函数（部分在截断代码中未完整显示）\n- `node_dirtyable_memory()`：计算指定 NUMA 节点中可用于脏页缓存的内存总量（包括空闲页 + 文件缓存页 - 保留页）。\n- `balance_dirty_pages()`：主限流函数，在进程写入时被调用，根据当前脏页水位决定是否休眠或触发回写。\n- `balance_dirty_pages_ratelimited()`：带速率限制的脏页平衡入口，避免频繁调用开销。\n\n## 3. 关键实现\n\n### 脏页阈值计算逻辑\n- 脏页上限基于 **“dirtyable memory”** 计算，即 `(free pages + file cache pages - kernel reserves)`。\n- 支持两种配置方式：**百分比（ratio）** 或 **绝对字节数（bytes）**，后者优先。\n- 当启用 `vm_highmem_is_dirtyable` 时，highmem 区域的空闲页也计入 dirtyable memory。\n\n### 动态限流机制\n- 使用 **`MAX_PAUSE`（最大 200ms）** 限制单次 `balance_dirty_pages()` 的休眠时间。\n- 引入 **`DIRTY_POLL_THRESH`（128KB）** 作为调用间隔优化阈值：若脏页增长过快，则提升休眠时间至最大值。\n- 通过 **`BANDWIDTH_INTERVAL`（200ms）** 动态估算存储设备的写入带宽，用于调整回写速率。\n\n### cgroup writeback 支持\n- 在 `CONFIG_CGROUP_WRITEBACK` 启用时：\n  - 每个 memcg 有独立的 `wb_domain`\n  - `dirty_throttle_control` 可关联全局（gdtc）或 memcg（mdtc）上下文\n  - BDI 的 min/max_ratio 根据其实际带宽动态缩放，实现公平分配\n\n### 老化与完成计数\n- 使用 `fprop_local_percpu` 结构跟踪每个 BDI 的回写完成情况。\n- `VM_COMPLETIONS_PERIOD_LEN`（3 秒）定义了回写完成率的老化周期，影响带宽估算的响应速度。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/mm.h>`、`<linux/swap.h>`、`<linux/pagevec.h>` 等，与页分配、回收机制紧密集成。\n- **VFS 层**：通过 `<linux/fs.h>`、`<linux/pagemap.h>` 与 address_space 和 inode 交互。\n- **块设备层**：通过 `<linux/blkdev.h>`、`<linux/backing-dev.h>` 获取 BDI 信息和 I/O 能力。\n- **调度与同步**：使用 `<linux/sched.h>`、`<linux/spinlock.h>`、`<linux/timer.h>` 实现休眠、锁和定时器。\n- **追踪系统**：集成 `<trace/events/writeback.h>` 提供回写事件追踪点。\n- **内部头文件**：包含 `\"internal.h\"` 获取 MM 子系统内部接口。\n\n## 5. 使用场景\n\n1. **用户空间写入文件**  \n   当进程通过 `write()` 修改文件页时，页被标记为脏，随后调用 `balance_dirty_pages_ratelimited()` 触发脏页控制。\n\n2. **内存压力下的页面回收**  \n   kswapd 或直接回收路径在需要释放内存时，可能调用回写逻辑清理脏页。\n\n3. **定期后台回写**  \n   `writeback` 内核线程按 `dirty_writeback_interval` 周期唤醒，检查并回写超过 `dirty_expire_interval` 的脏页。\n\n4. **系统关闭或 sync 调用**  \n   虽然主要同步逻辑在其他文件，但本文件提供的阈值和状态是决策基础。\n\n5. **容器环境中的资源隔离**  \n   启用 cgroup writeback 后，不同 memcg 的脏页回写相互隔离，避免一个容器的大量写入影响其他容器性能。\n\n6. **笔记本省电模式**  \n   当 `laptop_mode` 启用时，延迟回写以减少磁盘旋转时间，延长电池寿命。",
      "similarity": 0.5611791610717773,
      "chunks": [
        {
          "chunk_id": 10,
          "file_path": "mm/page-writeback.c",
          "start_line": 2033,
          "end_line": 2145,
          "content": [
            "int balance_dirty_pages_ratelimited_flags(struct address_space *mapping,",
            "\t\t\t\t\tunsigned int flags)",
            "{",
            "\tstruct inode *inode = mapping->host;",
            "\tstruct backing_dev_info *bdi = inode_to_bdi(inode);",
            "\tstruct bdi_writeback *wb = NULL;",
            "\tint ratelimit;",
            "\tint ret = 0;",
            "\tint *p;",
            "",
            "\tif (!(bdi->capabilities & BDI_CAP_WRITEBACK))",
            "\t\treturn ret;",
            "",
            "\tif (inode_cgwb_enabled(inode))",
            "\t\twb = wb_get_create_current(bdi, GFP_KERNEL);",
            "\tif (!wb)",
            "\t\twb = &bdi->wb;",
            "",
            "\tratelimit = current->nr_dirtied_pause;",
            "\tif (wb->dirty_exceeded)",
            "\t\tratelimit = min(ratelimit, 32 >> (PAGE_SHIFT - 10));",
            "",
            "\tpreempt_disable();",
            "\t/*",
            "\t * This prevents one CPU to accumulate too many dirtied pages without",
            "\t * calling into balance_dirty_pages(), which can happen when there are",
            "\t * 1000+ tasks, all of them start dirtying pages at exactly the same",
            "\t * time, hence all honoured too large initial task->nr_dirtied_pause.",
            "\t */",
            "\tp =  this_cpu_ptr(&bdp_ratelimits);",
            "\tif (unlikely(current->nr_dirtied >= ratelimit))",
            "\t\t*p = 0;",
            "\telse if (unlikely(*p >= ratelimit_pages)) {",
            "\t\t*p = 0;",
            "\t\tratelimit = 0;",
            "\t}",
            "\t/*",
            "\t * Pick up the dirtied pages by the exited tasks. This avoids lots of",
            "\t * short-lived tasks (eg. gcc invocations in a kernel build) escaping",
            "\t * the dirty throttling and livelock other long-run dirtiers.",
            "\t */",
            "\tp = this_cpu_ptr(&dirty_throttle_leaks);",
            "\tif (*p > 0 && current->nr_dirtied < ratelimit) {",
            "\t\tunsigned long nr_pages_dirtied;",
            "\t\tnr_pages_dirtied = min(*p, ratelimit - current->nr_dirtied);",
            "\t\t*p -= nr_pages_dirtied;",
            "\t\tcurrent->nr_dirtied += nr_pages_dirtied;",
            "\t}",
            "\tpreempt_enable();",
            "",
            "\tif (unlikely(current->nr_dirtied >= ratelimit))",
            "\t\tret = balance_dirty_pages(wb, current->nr_dirtied, flags);",
            "",
            "\twb_put(wb);",
            "\treturn ret;",
            "}",
            "void balance_dirty_pages_ratelimited(struct address_space *mapping)",
            "{",
            "\tbalance_dirty_pages_ratelimited_flags(mapping, 0);",
            "}",
            "bool wb_over_bg_thresh(struct bdi_writeback *wb)",
            "{",
            "\tstruct dirty_throttle_control gdtc_stor = { GDTC_INIT(wb) };",
            "\tstruct dirty_throttle_control mdtc_stor = { MDTC_INIT(wb, &gdtc_stor) };",
            "\tstruct dirty_throttle_control * const gdtc = &gdtc_stor;",
            "\tstruct dirty_throttle_control * const mdtc = mdtc_valid(&mdtc_stor) ?",
            "\t\t\t\t\t\t     &mdtc_stor : NULL;",
            "\tunsigned long reclaimable;",
            "\tunsigned long thresh;",
            "",
            "\t/*",
            "\t * Similar to balance_dirty_pages() but ignores pages being written",
            "\t * as we're trying to decide whether to put more under writeback.",
            "\t */",
            "\tgdtc->avail = global_dirtyable_memory();",
            "\tgdtc->dirty = global_node_page_state(NR_FILE_DIRTY);",
            "\tdomain_dirty_limits(gdtc);",
            "",
            "\tif (gdtc->dirty > gdtc->bg_thresh)",
            "\t\treturn true;",
            "",
            "\tthresh = wb_calc_thresh(gdtc->wb, gdtc->bg_thresh);",
            "\tif (thresh < 2 * wb_stat_error())",
            "\t\treclaimable = wb_stat_sum(wb, WB_RECLAIMABLE);",
            "\telse",
            "\t\treclaimable = wb_stat(wb, WB_RECLAIMABLE);",
            "",
            "\tif (reclaimable > thresh)",
            "\t\treturn true;",
            "",
            "\tif (mdtc) {",
            "\t\tunsigned long filepages, headroom, writeback;",
            "",
            "\t\tmem_cgroup_wb_stats(wb, &filepages, &headroom, &mdtc->dirty,",
            "\t\t\t\t    &writeback);",
            "\t\tmdtc_calc_avail(mdtc, filepages, headroom);",
            "\t\tdomain_dirty_limits(mdtc);\t/* ditto, ignore writeback */",
            "",
            "\t\tif (mdtc->dirty > mdtc->bg_thresh)",
            "\t\t\treturn true;",
            "",
            "\t\tthresh = wb_calc_thresh(mdtc->wb, mdtc->bg_thresh);",
            "\t\tif (thresh < 2 * wb_stat_error())",
            "\t\t\treclaimable = wb_stat_sum(wb, WB_RECLAIMABLE);",
            "\t\telse",
            "\t\t\treclaimable = wb_stat(wb, WB_RECLAIMABLE);",
            "",
            "\t\tif (reclaimable > thresh)",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\treturn false;",
            "}"
          ],
          "function_name": "balance_dirty_pages_ratelimited_flags, balance_dirty_pages_ratelimited, wb_over_bg_thresh",
          "description": "balance_dirty_pages_ratelimited_flags 函数用于控制脏页的速率限制和写回决策，通过检查当前脏页数量与速率限制阈值比较，决定是否触发writeback。wb_over_bg_thresh 判断是否超过背景写回阈值，用于决定是否允许更多脏页产生。",
          "similarity": 0.6504440307617188
        },
        {
          "chunk_id": 1,
          "file_path": "mm/page-writeback.c",
          "start_line": 164,
          "end_line": 268,
          "content": [
            "static bool mdtc_valid(struct dirty_throttle_control *dtc)",
            "{",
            "\treturn dtc->dom;",
            "}",
            "static void wb_min_max_ratio(struct bdi_writeback *wb,",
            "\t\t\t     unsigned long *minp, unsigned long *maxp)",
            "{",
            "\tunsigned long this_bw = READ_ONCE(wb->avg_write_bandwidth);",
            "\tunsigned long tot_bw = atomic_long_read(&wb->bdi->tot_write_bandwidth);",
            "\tunsigned long long min = wb->bdi->min_ratio;",
            "\tunsigned long long max = wb->bdi->max_ratio;",
            "",
            "\t/*",
            "\t * @wb may already be clean by the time control reaches here and",
            "\t * the total may not include its bw.",
            "\t */",
            "\tif (this_bw < tot_bw) {",
            "\t\tif (min) {",
            "\t\t\tmin *= this_bw;",
            "\t\t\tmin = div64_ul(min, tot_bw);",
            "\t\t}",
            "\t\tif (max < 100 * BDI_RATIO_SCALE) {",
            "\t\t\tmax *= this_bw;",
            "\t\t\tmax = div64_ul(max, tot_bw);",
            "\t\t}",
            "\t}",
            "",
            "\t*minp = min;",
            "\t*maxp = max;",
            "}",
            "static bool mdtc_valid(struct dirty_throttle_control *dtc)",
            "{",
            "\treturn false;",
            "}",
            "static void wb_min_max_ratio(struct bdi_writeback *wb,",
            "\t\t\t     unsigned long *minp, unsigned long *maxp)",
            "{",
            "\t*minp = wb->bdi->min_ratio;",
            "\t*maxp = wb->bdi->max_ratio;",
            "}",
            "static unsigned long node_dirtyable_memory(struct pglist_data *pgdat)",
            "{",
            "\tunsigned long nr_pages = 0;",
            "\tint z;",
            "",
            "\tfor (z = 0; z < MAX_NR_ZONES; z++) {",
            "\t\tstruct zone *zone = pgdat->node_zones + z;",
            "",
            "\t\tif (!populated_zone(zone))",
            "\t\t\tcontinue;",
            "",
            "\t\tnr_pages += zone_page_state(zone, NR_FREE_PAGES);",
            "\t}",
            "",
            "\t/*",
            "\t * Pages reserved for the kernel should not be considered",
            "\t * dirtyable, to prevent a situation where reclaim has to",
            "\t * clean pages in order to balance the zones.",
            "\t */",
            "\tnr_pages -= min(nr_pages, pgdat->totalreserve_pages);",
            "",
            "\tnr_pages += node_page_state(pgdat, NR_INACTIVE_FILE);",
            "\tnr_pages += node_page_state(pgdat, NR_ACTIVE_FILE);",
            "",
            "\treturn nr_pages;",
            "}",
            "static unsigned long highmem_dirtyable_memory(unsigned long total)",
            "{",
            "#ifdef CONFIG_HIGHMEM",
            "\tint node;",
            "\tunsigned long x = 0;",
            "\tint i;",
            "",
            "\tfor_each_node_state(node, N_HIGH_MEMORY) {",
            "\t\tfor (i = ZONE_NORMAL + 1; i < MAX_NR_ZONES; i++) {",
            "\t\t\tstruct zone *z;",
            "\t\t\tunsigned long nr_pages;",
            "",
            "\t\t\tif (!is_highmem_idx(i))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tz = &NODE_DATA(node)->node_zones[i];",
            "\t\t\tif (!populated_zone(z))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tnr_pages = zone_page_state(z, NR_FREE_PAGES);",
            "\t\t\t/* watch for underflows */",
            "\t\t\tnr_pages -= min(nr_pages, high_wmark_pages(z));",
            "\t\t\tnr_pages += zone_page_state(z, NR_ZONE_INACTIVE_FILE);",
            "\t\t\tnr_pages += zone_page_state(z, NR_ZONE_ACTIVE_FILE);",
            "\t\t\tx += nr_pages;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * Make sure that the number of highmem pages is never larger",
            "\t * than the number of the total dirtyable memory. This can only",
            "\t * occur in very strange VM situations but we want to make sure",
            "\t * that this does not occur.",
            "\t */",
            "\treturn min(x, total);",
            "#else",
            "\treturn 0;",
            "#endif",
            "}"
          ],
          "function_name": "mdtc_valid, wb_min_max_ratio, mdtc_valid, wb_min_max_ratio, node_dirtyable_memory, highmem_dirtyable_memory",
          "description": "计算各节点可脏化内存大小，并基于当前写入带宽调整脏页限制的最小和最大比率，用于后续脏页阈值计算。",
          "similarity": 0.647320568561554
        },
        {
          "chunk_id": 6,
          "file_path": "mm/page-writeback.c",
          "start_line": 883,
          "end_line": 1126,
          "content": [
            "static unsigned long __wb_calc_thresh(struct dirty_throttle_control *dtc)",
            "{",
            "\tstruct wb_domain *dom = dtc_dom(dtc);",
            "\tunsigned long thresh = dtc->thresh;",
            "\tu64 wb_thresh;",
            "\tunsigned long numerator, denominator;",
            "\tunsigned long wb_min_ratio, wb_max_ratio;",
            "",
            "\t/*",
            "\t * Calculate this BDI's share of the thresh ratio.",
            "\t */",
            "\tfprop_fraction_percpu(&dom->completions, dtc->wb_completions,",
            "\t\t\t      &numerator, &denominator);",
            "",
            "\twb_thresh = (thresh * (100 * BDI_RATIO_SCALE - bdi_min_ratio)) / (100 * BDI_RATIO_SCALE);",
            "\twb_thresh *= numerator;",
            "\twb_thresh = div64_ul(wb_thresh, denominator);",
            "",
            "\twb_min_max_ratio(dtc->wb, &wb_min_ratio, &wb_max_ratio);",
            "",
            "\twb_thresh += (thresh * wb_min_ratio) / (100 * BDI_RATIO_SCALE);",
            "\tif (wb_thresh > (thresh * wb_max_ratio) / (100 * BDI_RATIO_SCALE))",
            "\t\twb_thresh = thresh * wb_max_ratio / (100 * BDI_RATIO_SCALE);",
            "",
            "\treturn wb_thresh;",
            "}",
            "unsigned long wb_calc_thresh(struct bdi_writeback *wb, unsigned long thresh)",
            "{",
            "\tstruct dirty_throttle_control gdtc = { GDTC_INIT(wb),",
            "\t\t\t\t\t       .thresh = thresh };",
            "\treturn __wb_calc_thresh(&gdtc);",
            "}",
            "unsigned long cgwb_calc_thresh(struct bdi_writeback *wb)",
            "{",
            "\tstruct dirty_throttle_control gdtc = { GDTC_INIT_NO_WB };",
            "\tstruct dirty_throttle_control mdtc = { MDTC_INIT(wb, &gdtc) };",
            "\tunsigned long filepages = 0, headroom = 0, writeback = 0;",
            "",
            "\tgdtc.avail = global_dirtyable_memory();",
            "\tgdtc.dirty = global_node_page_state(NR_FILE_DIRTY) +",
            "\t\t     global_node_page_state(NR_WRITEBACK);",
            "",
            "\tmem_cgroup_wb_stats(wb, &filepages, &headroom,",
            "\t\t\t    &mdtc.dirty, &writeback);",
            "\tmdtc.dirty += writeback;",
            "\tmdtc_calc_avail(&mdtc, filepages, headroom);",
            "\tdomain_dirty_limits(&mdtc);",
            "",
            "\treturn __wb_calc_thresh(&mdtc);",
            "}",
            "static long long pos_ratio_polynom(unsigned long setpoint,",
            "\t\t\t\t\t  unsigned long dirty,",
            "\t\t\t\t\t  unsigned long limit)",
            "{",
            "\tlong long pos_ratio;",
            "\tlong x;",
            "",
            "\tx = div64_s64(((s64)setpoint - (s64)dirty) << RATELIMIT_CALC_SHIFT,",
            "\t\t      (limit - setpoint) | 1);",
            "\tpos_ratio = x;",
            "\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;",
            "\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;",
            "\tpos_ratio += 1 << RATELIMIT_CALC_SHIFT;",
            "",
            "\treturn clamp(pos_ratio, 0LL, 2LL << RATELIMIT_CALC_SHIFT);",
            "}",
            "static void wb_position_ratio(struct dirty_throttle_control *dtc)",
            "{",
            "\tstruct bdi_writeback *wb = dtc->wb;",
            "\tunsigned long write_bw = READ_ONCE(wb->avg_write_bandwidth);",
            "\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);",
            "\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);",
            "\tunsigned long wb_thresh = dtc->wb_thresh;",
            "\tunsigned long x_intercept;",
            "\tunsigned long setpoint;\t\t/* dirty pages' target balance point */",
            "\tunsigned long wb_setpoint;",
            "\tunsigned long span;",
            "\tlong long pos_ratio;\t\t/* for scaling up/down the rate limit */",
            "\tlong x;",
            "",
            "\tdtc->pos_ratio = 0;",
            "",
            "\tif (unlikely(dtc->dirty >= limit))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * global setpoint",
            "\t *",
            "\t * See comment for pos_ratio_polynom().",
            "\t */",
            "\tsetpoint = (freerun + limit) / 2;",
            "\tpos_ratio = pos_ratio_polynom(setpoint, dtc->dirty, limit);",
            "",
            "\t/*",
            "\t * The strictlimit feature is a tool preventing mistrusted filesystems",
            "\t * from growing a large number of dirty pages before throttling. For",
            "\t * such filesystems balance_dirty_pages always checks wb counters",
            "\t * against wb limits. Even if global \"nr_dirty\" is under \"freerun\".",
            "\t * This is especially important for fuse which sets bdi->max_ratio to",
            "\t * 1% by default. Without strictlimit feature, fuse writeback may",
            "\t * consume arbitrary amount of RAM because it is accounted in",
            "\t * NR_WRITEBACK_TEMP which is not involved in calculating \"nr_dirty\".",
            "\t *",
            "\t * Here, in wb_position_ratio(), we calculate pos_ratio based on",
            "\t * two values: wb_dirty and wb_thresh. Let's consider an example:",
            "\t * total amount of RAM is 16GB, bdi->max_ratio is equal to 1%, global",
            "\t * limits are set by default to 10% and 20% (background and throttle).",
            "\t * Then wb_thresh is 1% of 20% of 16GB. This amounts to ~8K pages.",
            "\t * wb_calc_thresh(wb, bg_thresh) is about ~4K pages. wb_setpoint is",
            "\t * about ~6K pages (as the average of background and throttle wb",
            "\t * limits). The 3rd order polynomial will provide positive feedback if",
            "\t * wb_dirty is under wb_setpoint and vice versa.",
            "\t *",
            "\t * Note, that we cannot use global counters in these calculations",
            "\t * because we want to throttle process writing to a strictlimit wb",
            "\t * much earlier than global \"freerun\" is reached (~23MB vs. ~2.3GB",
            "\t * in the example above).",
            "\t */",
            "\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {",
            "\t\tlong long wb_pos_ratio;",
            "",
            "\t\tif (dtc->wb_dirty < 8) {",
            "\t\t\tdtc->pos_ratio = min_t(long long, pos_ratio * 2,",
            "\t\t\t\t\t   2 << RATELIMIT_CALC_SHIFT);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tif (dtc->wb_dirty >= wb_thresh)",
            "\t\t\treturn;",
            "",
            "\t\twb_setpoint = dirty_freerun_ceiling(wb_thresh,",
            "\t\t\t\t\t\t    dtc->wb_bg_thresh);",
            "",
            "\t\tif (wb_setpoint == 0 || wb_setpoint == wb_thresh)",
            "\t\t\treturn;",
            "",
            "\t\twb_pos_ratio = pos_ratio_polynom(wb_setpoint, dtc->wb_dirty,",
            "\t\t\t\t\t\t wb_thresh);",
            "",
            "\t\t/*",
            "\t\t * Typically, for strictlimit case, wb_setpoint << setpoint",
            "\t\t * and pos_ratio >> wb_pos_ratio. In the other words global",
            "\t\t * state (\"dirty\") is not limiting factor and we have to",
            "\t\t * make decision based on wb counters. But there is an",
            "\t\t * important case when global pos_ratio should get precedence:",
            "\t\t * global limits are exceeded (e.g. due to activities on other",
            "\t\t * wb's) while given strictlimit wb is below limit.",
            "\t\t *",
            "\t\t * \"pos_ratio * wb_pos_ratio\" would work for the case above,",
            "\t\t * but it would look too non-natural for the case of all",
            "\t\t * activity in the system coming from a single strictlimit wb",
            "\t\t * with bdi->max_ratio == 100%.",
            "\t\t *",
            "\t\t * Note that min() below somewhat changes the dynamics of the",
            "\t\t * control system. Normally, pos_ratio value can be well over 3",
            "\t\t * (when globally we are at freerun and wb is well below wb",
            "\t\t * setpoint). Now the maximum pos_ratio in the same situation",
            "\t\t * is 2. We might want to tweak this if we observe the control",
            "\t\t * system is too slow to adapt.",
            "\t\t */",
            "\t\tdtc->pos_ratio = min(pos_ratio, wb_pos_ratio);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * We have computed basic pos_ratio above based on global situation. If",
            "\t * the wb is over/under its share of dirty pages, we want to scale",
            "\t * pos_ratio further down/up. That is done by the following mechanism.",
            "\t */",
            "",
            "\t/*",
            "\t * wb setpoint",
            "\t *",
            "\t *        f(wb_dirty) := 1.0 + k * (wb_dirty - wb_setpoint)",
            "\t *",
            "\t *                        x_intercept - wb_dirty",
            "\t *                     := --------------------------",
            "\t *                        x_intercept - wb_setpoint",
            "\t *",
            "\t * The main wb control line is a linear function that subjects to",
            "\t *",
            "\t * (1) f(wb_setpoint) = 1.0",
            "\t * (2) k = - 1 / (8 * write_bw)  (in single wb case)",
            "\t *     or equally: x_intercept = wb_setpoint + 8 * write_bw",
            "\t *",
            "\t * For single wb case, the dirty pages are observed to fluctuate",
            "\t * regularly within range",
            "\t *        [wb_setpoint - write_bw/2, wb_setpoint + write_bw/2]",
            "\t * for various filesystems, where (2) can yield in a reasonable 12.5%",
            "\t * fluctuation range for pos_ratio.",
            "\t *",
            "\t * For JBOD case, wb_thresh (not wb_dirty!) could fluctuate up to its",
            "\t * own size, so move the slope over accordingly and choose a slope that",
            "\t * yields 100% pos_ratio fluctuation on suddenly doubled wb_thresh.",
            "\t */",
            "\tif (unlikely(wb_thresh > dtc->thresh))",
            "\t\twb_thresh = dtc->thresh;",
            "\t/*",
            "\t * It's very possible that wb_thresh is close to 0 not because the",
            "\t * device is slow, but that it has remained inactive for long time.",
            "\t * Honour such devices a reasonable good (hopefully IO efficient)",
            "\t * threshold, so that the occasional writes won't be blocked and active",
            "\t * writes can rampup the threshold quickly.",
            "\t */",
            "\twb_thresh = max(wb_thresh, (limit - dtc->dirty) / 8);",
            "\t/*",
            "\t * scale global setpoint to wb's:",
            "\t *\twb_setpoint = setpoint * wb_thresh / thresh",
            "\t */",
            "\tx = div_u64((u64)wb_thresh << 16, dtc->thresh | 1);",
            "\twb_setpoint = setpoint * (u64)x >> 16;",
            "\t/*",
            "\t * Use span=(8*write_bw) in single wb case as indicated by",
            "\t * (thresh - wb_thresh ~= 0) and transit to wb_thresh in JBOD case.",
            "\t *",
            "\t *        wb_thresh                    thresh - wb_thresh",
            "\t * span = --------- * (8 * write_bw) + ------------------ * wb_thresh",
            "\t *         thresh                           thresh",
            "\t */",
            "\tspan = (dtc->thresh - wb_thresh + 8 * write_bw) * (u64)x >> 16;",
            "\tx_intercept = wb_setpoint + span;",
            "",
            "\tif (dtc->wb_dirty < x_intercept - span / 4) {",
            "\t\tpos_ratio = div64_u64(pos_ratio * (x_intercept - dtc->wb_dirty),",
            "\t\t\t\t      (x_intercept - wb_setpoint) | 1);",
            "\t} else",
            "\t\tpos_ratio /= 4;",
            "",
            "\t/*",
            "\t * wb reserve area, safeguard against dirty pool underrun and disk idle",
            "\t * It may push the desired control point of global dirty pages higher",
            "\t * than setpoint.",
            "\t */",
            "\tx_intercept = wb_thresh / 2;",
            "\tif (dtc->wb_dirty < x_intercept) {",
            "\t\tif (dtc->wb_dirty > x_intercept / 8)",
            "\t\t\tpos_ratio = div_u64(pos_ratio * x_intercept,",
            "\t\t\t\t\t    dtc->wb_dirty);",
            "\t\telse",
            "\t\t\tpos_ratio *= 8;",
            "\t}",
            "",
            "\tdtc->pos_ratio = pos_ratio;",
            "}"
          ],
          "function_name": "__wb_calc_thresh, wb_calc_thresh, cgwb_calc_thresh, pos_ratio_polynom, wb_position_ratio",
          "description": "实现基于脏页阈值的动态调节算法，包含计算全局和内存控制组的脏页阈值、基于多项式的位置比值计算、根据写入带宽和当前脏页状态调整控制参数等功能，通过多级阈值和反馈机制平衡系统负载。",
          "similarity": 0.6219021081924438
        },
        {
          "chunk_id": 2,
          "file_path": "mm/page-writeback.c",
          "start_line": 345,
          "end_line": 459,
          "content": [
            "static unsigned long global_dirtyable_memory(void)",
            "{",
            "\tunsigned long x;",
            "",
            "\tx = global_zone_page_state(NR_FREE_PAGES);",
            "\t/*",
            "\t * Pages reserved for the kernel should not be considered",
            "\t * dirtyable, to prevent a situation where reclaim has to",
            "\t * clean pages in order to balance the zones.",
            "\t */",
            "\tx -= min(x, totalreserve_pages);",
            "",
            "\tx += global_node_page_state(NR_INACTIVE_FILE);",
            "\tx += global_node_page_state(NR_ACTIVE_FILE);",
            "",
            "\tif (!vm_highmem_is_dirtyable)",
            "\t\tx -= highmem_dirtyable_memory(x);",
            "",
            "\treturn x + 1;\t/* Ensure that we never return 0 */",
            "}",
            "static void domain_dirty_limits(struct dirty_throttle_control *dtc)",
            "{",
            "\tconst unsigned long available_memory = dtc->avail;",
            "\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(dtc);",
            "\tunsigned long bytes = vm_dirty_bytes;",
            "\tunsigned long bg_bytes = dirty_background_bytes;",
            "\t/* convert ratios to per-PAGE_SIZE for higher precision */",
            "\tunsigned long ratio = (vm_dirty_ratio * PAGE_SIZE) / 100;",
            "\tunsigned long bg_ratio = (dirty_background_ratio * PAGE_SIZE) / 100;",
            "\tunsigned long thresh;",
            "\tunsigned long bg_thresh;",
            "\tstruct task_struct *tsk;",
            "",
            "\t/* gdtc is !NULL iff @dtc is for memcg domain */",
            "\tif (gdtc) {",
            "\t\tunsigned long global_avail = gdtc->avail;",
            "",
            "\t\t/*",
            "\t\t * The byte settings can't be applied directly to memcg",
            "\t\t * domains.  Convert them to ratios by scaling against",
            "\t\t * globally available memory.  As the ratios are in",
            "\t\t * per-PAGE_SIZE, they can be obtained by dividing bytes by",
            "\t\t * number of pages.",
            "\t\t */",
            "\t\tif (bytes)",
            "\t\t\tratio = min(DIV_ROUND_UP(bytes, global_avail),",
            "\t\t\t\t    PAGE_SIZE);",
            "\t\tif (bg_bytes)",
            "\t\t\tbg_ratio = min(DIV_ROUND_UP(bg_bytes, global_avail),",
            "\t\t\t\t       PAGE_SIZE);",
            "\t\tbytes = bg_bytes = 0;",
            "\t}",
            "",
            "\tif (bytes)",
            "\t\tthresh = DIV_ROUND_UP(bytes, PAGE_SIZE);",
            "\telse",
            "\t\tthresh = (ratio * available_memory) / PAGE_SIZE;",
            "",
            "\tif (bg_bytes)",
            "\t\tbg_thresh = DIV_ROUND_UP(bg_bytes, PAGE_SIZE);",
            "\telse",
            "\t\tbg_thresh = (bg_ratio * available_memory) / PAGE_SIZE;",
            "",
            "\ttsk = current;",
            "\tif (rt_or_dl_task(tsk)) {",
            "\t\tbg_thresh += bg_thresh / 4 + global_wb_domain.dirty_limit / 32;",
            "\t\tthresh += thresh / 4 + global_wb_domain.dirty_limit / 32;",
            "\t}",
            "\t/*",
            "\t * Dirty throttling logic assumes the limits in page units fit into",
            "\t * 32-bits. This gives 16TB dirty limits max which is hopefully enough.",
            "\t */",
            "\tif (thresh > UINT_MAX)",
            "\t\tthresh = UINT_MAX;",
            "\t/* This makes sure bg_thresh is within 32-bits as well */",
            "\tif (bg_thresh >= thresh)",
            "\t\tbg_thresh = thresh / 2;",
            "\tdtc->thresh = thresh;",
            "\tdtc->bg_thresh = bg_thresh;",
            "",
            "\t/* we should eventually report the domain in the TP */",
            "\tif (!gdtc)",
            "\t\ttrace_global_dirty_state(bg_thresh, thresh);",
            "}",
            "void global_dirty_limits(unsigned long *pbackground, unsigned long *pdirty)",
            "{",
            "\tstruct dirty_throttle_control gdtc = { GDTC_INIT_NO_WB };",
            "",
            "\tgdtc.avail = global_dirtyable_memory();",
            "\tdomain_dirty_limits(&gdtc);",
            "",
            "\t*pbackground = gdtc.bg_thresh;",
            "\t*pdirty = gdtc.thresh;",
            "}",
            "static unsigned long node_dirty_limit(struct pglist_data *pgdat)",
            "{",
            "\tunsigned long node_memory = node_dirtyable_memory(pgdat);",
            "\tstruct task_struct *tsk = current;",
            "\tunsigned long dirty;",
            "",
            "\tif (vm_dirty_bytes)",
            "\t\tdirty = DIV_ROUND_UP(vm_dirty_bytes, PAGE_SIZE) *",
            "\t\t\tnode_memory / global_dirtyable_memory();",
            "\telse",
            "\t\tdirty = vm_dirty_ratio * node_memory / 100;",
            "",
            "\tif (rt_or_dl_task(tsk))",
            "\t\tdirty += dirty / 4;",
            "",
            "\t/*",
            "\t * Dirty throttling logic assumes the limits in page units fit into",
            "\t * 32-bits. This gives 16TB dirty limits max which is hopefully enough.",
            "\t */",
            "\treturn min_t(unsigned long, dirty, UINT_MAX);",
            "}"
          ],
          "function_name": "global_dirtyable_memory, domain_dirty_limits, global_dirty_limits, node_dirty_limit",
          "description": "计算全局可用脏化内存并结合域级别参数确定脏页上限，根据实时任务特性调整阈值，提供全局和节点层级的脏页限制。",
          "similarity": 0.6184621453285217
        },
        {
          "chunk_id": 9,
          "file_path": "mm/page-writeback.c",
          "start_line": 1662,
          "end_line": 1988,
          "content": [
            "static inline void wb_dirty_limits(struct dirty_throttle_control *dtc)",
            "{",
            "\tstruct bdi_writeback *wb = dtc->wb;",
            "\tunsigned long wb_reclaimable;",
            "",
            "\t/*",
            "\t * wb_thresh is not treated as some limiting factor as",
            "\t * dirty_thresh, due to reasons",
            "\t * - in JBOD setup, wb_thresh can fluctuate a lot",
            "\t * - in a system with HDD and USB key, the USB key may somehow",
            "\t *   go into state (wb_dirty >> wb_thresh) either because",
            "\t *   wb_dirty starts high, or because wb_thresh drops low.",
            "\t *   In this case we don't want to hard throttle the USB key",
            "\t *   dirtiers for 100 seconds until wb_dirty drops under",
            "\t *   wb_thresh. Instead the auxiliary wb control line in",
            "\t *   wb_position_ratio() will let the dirtier task progress",
            "\t *   at some rate <= (write_bw / 2) for bringing down wb_dirty.",
            "\t */",
            "\tdtc->wb_thresh = __wb_calc_thresh(dtc);",
            "\tdtc->wb_bg_thresh = dtc->thresh ?",
            "\t\tdiv_u64((u64)dtc->wb_thresh * dtc->bg_thresh, dtc->thresh) : 0;",
            "",
            "\t/*",
            "\t * In order to avoid the stacked BDI deadlock we need",
            "\t * to ensure we accurately count the 'dirty' pages when",
            "\t * the threshold is low.",
            "\t *",
            "\t * Otherwise it would be possible to get thresh+n pages",
            "\t * reported dirty, even though there are thresh-m pages",
            "\t * actually dirty; with m+n sitting in the percpu",
            "\t * deltas.",
            "\t */",
            "\tif (dtc->wb_thresh < 2 * wb_stat_error()) {",
            "\t\twb_reclaimable = wb_stat_sum(wb, WB_RECLAIMABLE);",
            "\t\tdtc->wb_dirty = wb_reclaimable + wb_stat_sum(wb, WB_WRITEBACK);",
            "\t} else {",
            "\t\twb_reclaimable = wb_stat(wb, WB_RECLAIMABLE);",
            "\t\tdtc->wb_dirty = wb_reclaimable + wb_stat(wb, WB_WRITEBACK);",
            "\t}",
            "}",
            "static int balance_dirty_pages(struct bdi_writeback *wb,",
            "\t\t\t       unsigned long pages_dirtied, unsigned int flags)",
            "{",
            "\tstruct dirty_throttle_control gdtc_stor = { GDTC_INIT(wb) };",
            "\tstruct dirty_throttle_control mdtc_stor = { MDTC_INIT(wb, &gdtc_stor) };",
            "\tstruct dirty_throttle_control * const gdtc = &gdtc_stor;",
            "\tstruct dirty_throttle_control * const mdtc = mdtc_valid(&mdtc_stor) ?",
            "\t\t\t\t\t\t     &mdtc_stor : NULL;",
            "\tstruct dirty_throttle_control *sdtc;",
            "\tunsigned long nr_dirty;",
            "\tlong period;",
            "\tlong pause;",
            "\tlong max_pause;",
            "\tlong min_pause;",
            "\tint nr_dirtied_pause;",
            "\tbool dirty_exceeded = false;",
            "\tunsigned long task_ratelimit;",
            "\tunsigned long dirty_ratelimit;",
            "\tstruct backing_dev_info *bdi = wb->bdi;",
            "\tbool strictlimit = bdi->capabilities & BDI_CAP_STRICTLIMIT;",
            "\tunsigned long start_time = jiffies;",
            "\tint ret = 0;",
            "",
            "\tfor (;;) {",
            "\t\tunsigned long now = jiffies;",
            "\t\tunsigned long dirty, thresh, bg_thresh;",
            "\t\tunsigned long m_dirty = 0;\t/* stop bogus uninit warnings */",
            "\t\tunsigned long m_thresh = 0;",
            "\t\tunsigned long m_bg_thresh = 0;",
            "",
            "\t\tnr_dirty = global_node_page_state(NR_FILE_DIRTY);",
            "\t\tgdtc->avail = global_dirtyable_memory();",
            "\t\tgdtc->dirty = nr_dirty + global_node_page_state(NR_WRITEBACK);",
            "",
            "\t\tdomain_dirty_limits(gdtc);",
            "",
            "\t\tif (unlikely(strictlimit)) {",
            "\t\t\twb_dirty_limits(gdtc);",
            "",
            "\t\t\tdirty = gdtc->wb_dirty;",
            "\t\t\tthresh = gdtc->wb_thresh;",
            "\t\t\tbg_thresh = gdtc->wb_bg_thresh;",
            "\t\t} else {",
            "\t\t\tdirty = gdtc->dirty;",
            "\t\t\tthresh = gdtc->thresh;",
            "\t\t\tbg_thresh = gdtc->bg_thresh;",
            "\t\t}",
            "",
            "\t\tif (mdtc) {",
            "\t\t\tunsigned long filepages, headroom, writeback;",
            "",
            "\t\t\t/*",
            "\t\t\t * If @wb belongs to !root memcg, repeat the same",
            "\t\t\t * basic calculations for the memcg domain.",
            "\t\t\t */",
            "\t\t\tmem_cgroup_wb_stats(wb, &filepages, &headroom,",
            "\t\t\t\t\t    &mdtc->dirty, &writeback);",
            "\t\t\tmdtc->dirty += writeback;",
            "\t\t\tmdtc_calc_avail(mdtc, filepages, headroom);",
            "",
            "\t\t\tdomain_dirty_limits(mdtc);",
            "",
            "\t\t\tif (unlikely(strictlimit)) {",
            "\t\t\t\twb_dirty_limits(mdtc);",
            "\t\t\t\tm_dirty = mdtc->wb_dirty;",
            "\t\t\t\tm_thresh = mdtc->wb_thresh;",
            "\t\t\t\tm_bg_thresh = mdtc->wb_bg_thresh;",
            "\t\t\t} else {",
            "\t\t\t\tm_dirty = mdtc->dirty;",
            "\t\t\t\tm_thresh = mdtc->thresh;",
            "\t\t\t\tm_bg_thresh = mdtc->bg_thresh;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * In laptop mode, we wait until hitting the higher threshold",
            "\t\t * before starting background writeout, and then write out all",
            "\t\t * the way down to the lower threshold.  So slow writers cause",
            "\t\t * minimal disk activity.",
            "\t\t *",
            "\t\t * In normal mode, we start background writeout at the lower",
            "\t\t * background_thresh, to keep the amount of dirty memory low.",
            "\t\t */",
            "\t\tif (!laptop_mode && nr_dirty > gdtc->bg_thresh &&",
            "\t\t    !writeback_in_progress(wb))",
            "\t\t\twb_start_background_writeback(wb);",
            "",
            "\t\t/*",
            "\t\t * Throttle it only when the background writeback cannot",
            "\t\t * catch-up. This avoids (excessively) small writeouts",
            "\t\t * when the wb limits are ramping up in case of !strictlimit.",
            "\t\t *",
            "\t\t * In strictlimit case make decision based on the wb counters",
            "\t\t * and limits. Small writeouts when the wb limits are ramping",
            "\t\t * up are the price we consciously pay for strictlimit-ing.",
            "\t\t *",
            "\t\t * If memcg domain is in effect, @dirty should be under",
            "\t\t * both global and memcg freerun ceilings.",
            "\t\t */",
            "\t\tif (dirty <= dirty_freerun_ceiling(thresh, bg_thresh) &&",
            "\t\t    (!mdtc ||",
            "\t\t     m_dirty <= dirty_freerun_ceiling(m_thresh, m_bg_thresh))) {",
            "\t\t\tunsigned long intv;",
            "\t\t\tunsigned long m_intv;",
            "",
            "free_running:",
            "\t\t\tintv = dirty_poll_interval(dirty, thresh);",
            "\t\t\tm_intv = ULONG_MAX;",
            "",
            "\t\t\tcurrent->dirty_paused_when = now;",
            "\t\t\tcurrent->nr_dirtied = 0;",
            "\t\t\tif (mdtc)",
            "\t\t\t\tm_intv = dirty_poll_interval(m_dirty, m_thresh);",
            "\t\t\tcurrent->nr_dirtied_pause = min(intv, m_intv);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* Start writeback even when in laptop mode */",
            "\t\tif (unlikely(!writeback_in_progress(wb)))",
            "\t\t\twb_start_background_writeback(wb);",
            "",
            "\t\tmem_cgroup_flush_foreign(wb);",
            "",
            "\t\t/*",
            "\t\t * Calculate global domain's pos_ratio and select the",
            "\t\t * global dtc by default.",
            "\t\t */",
            "\t\tif (!strictlimit) {",
            "\t\t\twb_dirty_limits(gdtc);",
            "",
            "\t\t\tif ((current->flags & PF_LOCAL_THROTTLE) &&",
            "\t\t\t    gdtc->wb_dirty <",
            "\t\t\t    dirty_freerun_ceiling(gdtc->wb_thresh,",
            "\t\t\t\t\t\t  gdtc->wb_bg_thresh))",
            "\t\t\t\t/*",
            "\t\t\t\t * LOCAL_THROTTLE tasks must not be throttled",
            "\t\t\t\t * when below the per-wb freerun ceiling.",
            "\t\t\t\t */",
            "\t\t\t\tgoto free_running;",
            "\t\t}",
            "",
            "\t\tdirty_exceeded = (gdtc->wb_dirty > gdtc->wb_thresh) &&",
            "\t\t\t((gdtc->dirty > gdtc->thresh) || strictlimit);",
            "",
            "\t\twb_position_ratio(gdtc);",
            "\t\tsdtc = gdtc;",
            "",
            "\t\tif (mdtc) {",
            "\t\t\t/*",
            "\t\t\t * If memcg domain is in effect, calculate its",
            "\t\t\t * pos_ratio.  @wb should satisfy constraints from",
            "\t\t\t * both global and memcg domains.  Choose the one",
            "\t\t\t * w/ lower pos_ratio.",
            "\t\t\t */",
            "\t\t\tif (!strictlimit) {",
            "\t\t\t\twb_dirty_limits(mdtc);",
            "",
            "\t\t\t\tif ((current->flags & PF_LOCAL_THROTTLE) &&",
            "\t\t\t\t    mdtc->wb_dirty <",
            "\t\t\t\t    dirty_freerun_ceiling(mdtc->wb_thresh,",
            "\t\t\t\t\t\t\t  mdtc->wb_bg_thresh))",
            "\t\t\t\t\t/*",
            "\t\t\t\t\t * LOCAL_THROTTLE tasks must not be",
            "\t\t\t\t\t * throttled when below the per-wb",
            "\t\t\t\t\t * freerun ceiling.",
            "\t\t\t\t\t */",
            "\t\t\t\t\tgoto free_running;",
            "\t\t\t}",
            "\t\t\tdirty_exceeded |= (mdtc->wb_dirty > mdtc->wb_thresh) &&",
            "\t\t\t\t((mdtc->dirty > mdtc->thresh) || strictlimit);",
            "",
            "\t\t\twb_position_ratio(mdtc);",
            "\t\t\tif (mdtc->pos_ratio < gdtc->pos_ratio)",
            "\t\t\t\tsdtc = mdtc;",
            "\t\t}",
            "",
            "\t\tif (dirty_exceeded != wb->dirty_exceeded)",
            "\t\t\twb->dirty_exceeded = dirty_exceeded;",
            "",
            "\t\tif (time_is_before_jiffies(READ_ONCE(wb->bw_time_stamp) +",
            "\t\t\t\t\t   BANDWIDTH_INTERVAL))",
            "\t\t\t__wb_update_bandwidth(gdtc, mdtc, true);",
            "",
            "\t\t/* throttle according to the chosen dtc */",
            "\t\tdirty_ratelimit = READ_ONCE(wb->dirty_ratelimit);",
            "\t\ttask_ratelimit = ((u64)dirty_ratelimit * sdtc->pos_ratio) >>",
            "\t\t\t\t\t\t\tRATELIMIT_CALC_SHIFT;",
            "\t\tmax_pause = wb_max_pause(wb, sdtc->wb_dirty);",
            "\t\tmin_pause = wb_min_pause(wb, max_pause,",
            "\t\t\t\t\t task_ratelimit, dirty_ratelimit,",
            "\t\t\t\t\t &nr_dirtied_pause);",
            "",
            "\t\tif (unlikely(task_ratelimit == 0)) {",
            "\t\t\tperiod = max_pause;",
            "\t\t\tpause = max_pause;",
            "\t\t\tgoto pause;",
            "\t\t}",
            "\t\tperiod = HZ * pages_dirtied / task_ratelimit;",
            "\t\tpause = period;",
            "\t\tif (current->dirty_paused_when)",
            "\t\t\tpause -= now - current->dirty_paused_when;",
            "\t\t/*",
            "\t\t * For less than 1s think time (ext3/4 may block the dirtier",
            "\t\t * for up to 800ms from time to time on 1-HDD; so does xfs,",
            "\t\t * however at much less frequency), try to compensate it in",
            "\t\t * future periods by updating the virtual time; otherwise just",
            "\t\t * do a reset, as it may be a light dirtier.",
            "\t\t */",
            "\t\tif (pause < min_pause) {",
            "\t\t\ttrace_balance_dirty_pages(wb,",
            "\t\t\t\t\t\t  sdtc->thresh,",
            "\t\t\t\t\t\t  sdtc->bg_thresh,",
            "\t\t\t\t\t\t  sdtc->dirty,",
            "\t\t\t\t\t\t  sdtc->wb_thresh,",
            "\t\t\t\t\t\t  sdtc->wb_dirty,",
            "\t\t\t\t\t\t  dirty_ratelimit,",
            "\t\t\t\t\t\t  task_ratelimit,",
            "\t\t\t\t\t\t  pages_dirtied,",
            "\t\t\t\t\t\t  period,",
            "\t\t\t\t\t\t  min(pause, 0L),",
            "\t\t\t\t\t\t  start_time);",
            "\t\t\tif (pause < -HZ) {",
            "\t\t\t\tcurrent->dirty_paused_when = now;",
            "\t\t\t\tcurrent->nr_dirtied = 0;",
            "\t\t\t} else if (period) {",
            "\t\t\t\tcurrent->dirty_paused_when += period;",
            "\t\t\t\tcurrent->nr_dirtied = 0;",
            "\t\t\t} else if (current->nr_dirtied_pause <= pages_dirtied)",
            "\t\t\t\tcurrent->nr_dirtied_pause += pages_dirtied;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (unlikely(pause > max_pause)) {",
            "\t\t\t/* for occasional dropped task_ratelimit */",
            "\t\t\tnow += min(pause - max_pause, max_pause);",
            "\t\t\tpause = max_pause;",
            "\t\t}",
            "",
            "pause:",
            "\t\ttrace_balance_dirty_pages(wb,",
            "\t\t\t\t\t  sdtc->thresh,",
            "\t\t\t\t\t  sdtc->bg_thresh,",
            "\t\t\t\t\t  sdtc->dirty,",
            "\t\t\t\t\t  sdtc->wb_thresh,",
            "\t\t\t\t\t  sdtc->wb_dirty,",
            "\t\t\t\t\t  dirty_ratelimit,",
            "\t\t\t\t\t  task_ratelimit,",
            "\t\t\t\t\t  pages_dirtied,",
            "\t\t\t\t\t  period,",
            "\t\t\t\t\t  pause,",
            "\t\t\t\t\t  start_time);",
            "\t\tif (flags & BDP_ASYNC) {",
            "\t\t\tret = -EAGAIN;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t__set_current_state(TASK_KILLABLE);",
            "\t\tbdi->last_bdp_sleep = jiffies;",
            "\t\tio_schedule_timeout(pause);",
            "",
            "\t\tcurrent->dirty_paused_when = now + pause;",
            "\t\tcurrent->nr_dirtied = 0;",
            "\t\tcurrent->nr_dirtied_pause = nr_dirtied_pause;",
            "",
            "\t\t/*",
            "\t\t * This is typically equal to (dirty < thresh) and can also",
            "\t\t * keep \"1000+ dd on a slow USB stick\" under control.",
            "\t\t */",
            "\t\tif (task_ratelimit)",
            "\t\t\tbreak;",
            "",
            "\t\t/*",
            "\t\t * In the case of an unresponsive NFS server and the NFS dirty",
            "\t\t * pages exceeds dirty_thresh, give the other good wb's a pipe",
            "\t\t * to go through, so that tasks on them still remain responsive.",
            "\t\t *",
            "\t\t * In theory 1 page is enough to keep the consumer-producer",
            "\t\t * pipe going: the flusher cleans 1 page => the task dirties 1",
            "\t\t * more page. However wb_dirty has accounting errors.  So use",
            "\t\t * the larger and more IO friendly wb_stat_error.",
            "\t\t */",
            "\t\tif (sdtc->wb_dirty <= wb_stat_error())",
            "\t\t\tbreak;",
            "",
            "\t\tif (fatal_signal_pending(current))",
            "\t\t\tbreak;",
            "\t}",
            "\treturn ret;",
            "}"
          ],
          "function_name": "wb_dirty_limits, balance_dirty_pages",
          "description": "实现脏页管理核心逻辑，包含确定当前脏页限制的计算函数和脏页平衡主函数，通过多级阈值检测、动态速率限制、暂停时间控制等机制，在保证系统响应性的同时防止内存过载，支持严格限制模式下的特殊处理。",
          "similarity": 0.6160373687744141
        }
      ]
    },
    {
      "source_file": "mm/shuffle.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:21:18\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `shuffle.c`\n\n---\n\n# shuffle.c 技术文档\n\n## 1. 文件概述\n\n`shuffle.c` 实现了 Linux 内核内存管理子系统中的**页面分配随机化（Page Allocation Shuffling）**功能。该机制通过在内存初始化阶段对空闲页面链表进行 Fisher-Yates 洗牌操作，降低物理页帧分配的可预测性，从而增强系统安全性，抵御基于内存布局预测的攻击（如堆喷射、地址泄露等）。该功能默认关闭，可通过内核启动参数 `shuffle=1` 启用。\n\n## 2. 核心功能\n\n### 数据结构与全局变量\n- `page_alloc_shuffle_key`：静态分支键（static key），用于运行时启用/禁用洗牌逻辑，减少未启用时的性能开销。\n- `shuffle_param`：模块参数布尔值，控制是否启用洗牌功能。\n- `shuffle_param_ops`：自定义模块参数操作集，用于处理 `shuffle` 参数的设置和读取。\n\n### 主要函数\n- `shuffle_param_set()`：解析并设置 `shuffle` 内核参数，若启用则激活 `page_alloc_shuffle_key`。\n- `shuffle_valid_page()`：验证指定 PFN 的页面是否满足洗牌条件（属于 buddy 系统、同 zone、空闲、相同 order 和 migratetype）。\n- `__shuffle_zone()`：对指定内存区域（zone）执行 Fisher-Yates 洗牌算法，随机交换同阶空闲页面。\n- `__shuffle_free_memory()`：遍历节点（pgdat）中所有 zone，依次调用 `shuffle_zone()` 进行洗牌。\n- `shuffle_pick_tail()`：提供轻量级随机位生成器，用于在分配时决定从链表头部还是尾部取页（增强运行时随机性）。\n\n## 3. 关键实现\n\n### 洗牌算法（Fisher-Yates）\n- **粒度**：以 `SHUFFLE_ORDER`（通常为 0，即单页）为单位进行洗牌。\n- **范围**：遍历 zone 内所有按 order 对齐的 PFN，对每个有效页面 `page_i` 随机选择另一个有效页面 `page_j` 进行交换。\n- **有效性校验**：通过 `shuffle_valid_page()` 确保交换双方均为 buddy 系统管理的空闲页，且具有相同的迁移类型（migratetype）。\n- **重试机制**：最多尝试 `SHUFFLE_RETRY`（10 次）寻找有效的随机目标页，避免因内存空洞导致失败。\n- **锁优化**：每处理 100 个页面后释放 zone 自旋锁并调度，防止长时间持锁影响系统响应。\n\n### 随机性来源\n- 使用 `get_random_long()` 获取高质量伪随机数作为洗牌索引。\n- `shuffle_pick_tail()` 使用无锁的 64 位随机状态生成器，每次返回最低位并右移，用于运行时分配策略的微调。\n\n### 安全性权衡\n- 明确承认不消除模运算偏差（modulo bias）或 PRNG 偏差，目标是“提高攻击门槛”而非完美随机。\n- 仅在内存初始化阶段（`__meminit`）执行一次洗牌，不影响运行时分配性能。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/mm.h>`、`<linux/mmzone.h>`：内存管理核心数据结构（`struct zone`, `struct page`）。\n  - `<linux/random.h>`：提供 `get_random_long()` 和 `get_random_u64()`。\n  - `\"internal.h\"`、`\"shuffle.h\"`：内核 MM 子系统内部接口及洗牌功能声明。\n- **功能依赖**：\n  - Buddy 分配器：依赖 `PageBuddy()`、`buddy_order()` 等接口判断页面状态。\n  - 页面迁移类型（Migratetype）：确保洗牌不破坏不同迁移类型页面的隔离。\n  - 静态分支（Static Keys）：通过 `static_branch_enable()` 动态启用洗牌路径。\n\n## 5. 使用场景\n\n- **安全加固**：在需要防范物理地址预测攻击的场景（如虚拟化宿主机、安全敏感设备）中启用，增加攻击者利用内存布局漏洞的难度。\n- **内核初始化**：在 `free_area_init_core()` 等内存子系统初始化流程中调用 `__shuffle_free_memory()`，对初始空闲内存进行一次性洗牌。\n- **运行时分配辅助**：`shuffle_pick_tail()` 被页面分配器调用，决定从空闲链表头/尾取页，进一步增加分配时序的不可预测性。\n- **调试支持**：通过 `pr_debug()` 输出洗牌失败或迁移类型不匹配的日志，便于问题诊断（需开启 `DEBUG_SHUFFLE`）。",
      "similarity": 0.5551591515541077,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/shuffle.c",
          "start_line": 16,
          "end_line": 121,
          "content": [
            "static __meminit int shuffle_param_set(const char *val,",
            "\t\tconst struct kernel_param *kp)",
            "{",
            "\tif (param_set_bool(val, kp))",
            "\t\treturn -EINVAL;",
            "\tif (*(bool *)kp->arg)",
            "\t\tstatic_branch_enable(&page_alloc_shuffle_key);",
            "\treturn 0;",
            "}",
            "void __meminit __shuffle_zone(struct zone *z)",
            "{",
            "\tunsigned long i, flags;",
            "\tunsigned long start_pfn = z->zone_start_pfn;",
            "\tunsigned long end_pfn = zone_end_pfn(z);",
            "\tconst int order = SHUFFLE_ORDER;",
            "\tconst int order_pages = 1 << order;",
            "",
            "\tspin_lock_irqsave(&z->lock, flags);",
            "\tstart_pfn = ALIGN(start_pfn, order_pages);",
            "\tfor (i = start_pfn; i < end_pfn; i += order_pages) {",
            "\t\tunsigned long j;",
            "\t\tint migratetype, retry;",
            "\t\tstruct page *page_i, *page_j;",
            "",
            "\t\t/*",
            "\t\t * We expect page_i, in the sub-range of a zone being added",
            "\t\t * (@start_pfn to @end_pfn), to more likely be valid compared to",
            "\t\t * page_j randomly selected in the span @zone_start_pfn to",
            "\t\t * @spanned_pages.",
            "\t\t */",
            "\t\tpage_i = shuffle_valid_page(z, i, order);",
            "\t\tif (!page_i)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (retry = 0; retry < SHUFFLE_RETRY; retry++) {",
            "\t\t\t/*",
            "\t\t\t * Pick a random order aligned page in the zone span as",
            "\t\t\t * a swap target. If the selected pfn is a hole, retry",
            "\t\t\t * up to SHUFFLE_RETRY attempts find a random valid pfn",
            "\t\t\t * in the zone.",
            "\t\t\t */",
            "\t\t\tj = z->zone_start_pfn +",
            "\t\t\t\tALIGN_DOWN(get_random_long() % z->spanned_pages,",
            "\t\t\t\t\t\torder_pages);",
            "\t\t\tpage_j = shuffle_valid_page(z, j, order);",
            "\t\t\tif (page_j && page_j != page_i)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (retry >= SHUFFLE_RETRY) {",
            "\t\t\tpr_debug(\"%s: failed to swap %#lx\\n\", __func__, i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * Each migratetype corresponds to its own list, make sure the",
            "\t\t * types match otherwise we're moving pages to lists where they",
            "\t\t * do not belong.",
            "\t\t */",
            "\t\tmigratetype = get_pageblock_migratetype(page_i);",
            "\t\tif (get_pageblock_migratetype(page_j) != migratetype) {",
            "\t\t\tpr_debug(\"%s: migratetype mismatch %#lx\\n\", __func__, i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tlist_swap(&page_i->lru, &page_j->lru);",
            "",
            "\t\tpr_debug(\"%s: swap: %#lx -> %#lx\\n\", __func__, i, j);",
            "",
            "\t\t/* take it easy on the zone lock */",
            "\t\tif ((i % (100 * order_pages)) == 0) {",
            "\t\t\tspin_unlock_irqrestore(&z->lock, flags);",
            "\t\t\tcond_resched();",
            "\t\t\tspin_lock_irqsave(&z->lock, flags);",
            "\t\t}",
            "\t}",
            "\tspin_unlock_irqrestore(&z->lock, flags);",
            "}",
            "void __meminit __shuffle_free_memory(pg_data_t *pgdat)",
            "{",
            "\tstruct zone *z;",
            "",
            "\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)",
            "\t\tshuffle_zone(z);",
            "}",
            "bool shuffle_pick_tail(void)",
            "{",
            "\tstatic u64 rand;",
            "\tstatic u8 rand_bits;",
            "\tbool ret;",
            "",
            "\t/*",
            "\t * The lack of locking is deliberate. If 2 threads race to",
            "\t * update the rand state it just adds to the entropy.",
            "\t */",
            "\tif (rand_bits == 0) {",
            "\t\trand_bits = 64;",
            "\t\trand = get_random_u64();",
            "\t}",
            "",
            "\tret = rand & 1;",
            "",
            "\trand_bits--;",
            "\trand >>= 1;",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "shuffle_param_set, __shuffle_zone, __shuffle_free_memory, shuffle_pick_tail",
          "description": "shuffle_param_set设置参数并启用/禁用静态键；__shuffle_zone在内存区随机交换页面以打乱物理顺序；__shuffle_free_memory初始化时调用__shuffle_zone；shuffle_pick_tail生成随机布尔值用于选择尾部页",
          "similarity": 0.5517627000808716
        },
        {
          "chunk_id": 0,
          "file_path": "mm/shuffle.c",
          "start_line": 1,
          "end_line": 15,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright(c) 2018 Intel Corporation. All rights reserved.",
            "",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/random.h>",
            "#include <linux/moduleparam.h>",
            "#include \"internal.h\"",
            "#include \"shuffle.h\"",
            "",
            "DEFINE_STATIC_KEY_FALSE(page_alloc_shuffle_key);",
            "",
            "static bool shuffle_param;",
            ""
          ],
          "function_name": null,
          "description": "定义静态键用于控制页面分配随机化功能，并声明参数变量shuffle_param，用于启用或禁用相关机制",
          "similarity": 0.4215483069419861
        }
      ]
    },
    {
      "source_file": "mm/page_poison.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:04:51\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `page_poison.c`\n\n---\n\n# page_poison.c 技术文档\n\n## 1. 文件概述\n\n`page_poison.c` 实现了 Linux 内核中的**页面毒化（Page Poisoning）**机制，用于在内存页被释放到伙伴系统（buddy allocator）时填充特定的毒化值（`PAGE_POISON`），并在后续分配时检测该值是否被意外修改。此机制主要用于**检测内存越界写、Use-After-Free 等内存错误**，是内核调试和内存安全的重要工具。该功能可通过内核启动参数 `page_poison=1` 启用。\n\n## 2. 核心功能\n\n### 全局变量\n- `_page_poisoning_enabled_early`：布尔变量，记录早期启动阶段是否通过命令行启用了页面毒化。\n- `_page_poisoning_enabled`：静态键（static key），用于运行时高效判断页面毒化是否启用。\n\n### 主要函数\n- `early_page_poison_param()`：解析内核启动参数 `page_poison`，设置 `_page_poisoning_enabled_early`。\n- `poison_page()`：对单个页面进行毒化（填充 `PAGE_POISON` 字节）。\n- `__kernel_poison_pages()`：批量毒化连续的多个页面。\n- `unpoison_page()`：在页面重新分配前检查其内容是否仍为毒化值，并报告异常。\n- `__kernel_unpoison_pages()`：批量检查并“解毒”多个页面。\n- `check_poison_mem()`：检测内存区域是否被非法修改，区分单比特翻转与严重内存破坏。\n- `__kernel_map_pages()`（仅当 `CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC` 未定义时）：空实现，表示架构不支持基于映射的调试页分配。\n\n### 辅助函数\n- `single_bit_flip()`：判断两个字节是否仅有一位不同（用于识别可能的硬件单比特错误）。\n\n## 3. 关键实现\n\n### 页面毒化流程\n- 当页面被释放到 buddy allocator 时，若页面毒化启用，则调用 `__kernel_poison_pages()`。\n- `poison_page()` 使用 `kmap_atomic()` 临时映射高内存页，绕过 KASAN 的检测（通过 `kasan_disable_current()`/`kasan_enable_current()`），然后用 `PAGE_POISON`（通常为 `0xaa`）填充整个页面。\n\n### 毒化检查机制\n- 在页面重新分配前，调用 `__kernel_unpoison_pages()` 触发 `unpoison_page()`。\n- `unpoison_page()` 映射页面后调用 `check_poison_mem()` 验证内容：\n  - 使用 `memchr_inv()` 快速查找首个非毒化字节。\n  - 若发现异常，使用速率限制（ratelimit）避免日志泛洪。\n  - 区分两种错误：\n    - **单比特翻转**：可能由硬件 ECC 错误引起，打印 `\"single bit error\"`。\n    - **其他修改**：视为内存破坏，打印 `\"memory corruption\"`。\n  - 输出十六进制内存转储、调用栈及页面详细信息（通过 `dump_page()`）。\n\n### 性能优化\n- 使用 `static_key`（`_page_poisoning_enabled`）实现零开销分支：当功能关闭时，相关代码路径可被编译器完全跳过。\n- 速率限制（`DEFINE_RATELIMIT_STATE`）防止频繁错误导致系统卡死。\n\n### KASAN 兼容性\n- 在毒化/检查过程中显式禁用 KASAN 检测（`kasan_disable_current()`），因为 KASAN 仍认为页面处于“已分配”状态，直接访问会触发误报。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/poison.h>`：提供 `PAGE_POISON` 宏定义。\n  - `<linux/kasan.h>`：提供 KASAN 相关接口（`kasan_disable_current` 等）。\n  - `<linux/mm.h>`、`<linux/highmem.h>`：提供页面管理及高内存映射函数（`kmap_atomic`）。\n  - `<linux/ratelimit.h>`：提供日志速率限制功能。\n- **配置依赖**：\n  - 依赖 `CONFIG_PAGE_POISONING` 内核配置选项。\n  - 若架构支持 `CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC`，则 `__kernel_map_pages` 由架构层实现；否则本文件提供空实现。\n- **与其他子系统交互**：\n  - 与 **伙伴分配器（buddy allocator）** 紧密集成，在 `free_pages_prepare()` 和 `prep_new_page()` 中调用毒化/解毒函数。\n  - 与 **KASAN（Kernel Address Sanitizer）** 协同工作，避免检测冲突。\n\n## 5. 使用场景\n\n- **内核调试**：开发人员启用 `page_poison=1` 后，可捕获 Use-After-Free、缓冲区溢出等内存错误。\n- **生产环境监控**：在稳定性要求高的系统中，可长期启用以检测潜在的硬件内存故障（如单比特错误）或驱动 bug。\n- **安全加固**：通过填充不可预测的毒化值（结合 `CONFIG_PAGE_POISONING_ZERO` 可设为 0），增加攻击者利用 UAF 漏洞的难度。\n- **错误诊断**：当检测到内存破坏时，自动输出详细的内存转储和调用栈，加速问题定位。",
      "similarity": 0.553589403629303,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/page_poison.c",
          "start_line": 16,
          "end_line": 95,
          "content": [
            "static int __init early_page_poison_param(char *buf)",
            "{",
            "\treturn kstrtobool(buf, &_page_poisoning_enabled_early);",
            "}",
            "static void poison_page(struct page *page)",
            "{",
            "\tvoid *addr = kmap_atomic(page);",
            "",
            "\t/* KASAN still think the page is in-use, so skip it. */",
            "\tkasan_disable_current();",
            "\tmemset(kasan_reset_tag(addr), PAGE_POISON, PAGE_SIZE);",
            "\tkasan_enable_current();",
            "\tkunmap_atomic(addr);",
            "}",
            "void __kernel_poison_pages(struct page *page, int n)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < n; i++)",
            "\t\tpoison_page(page + i);",
            "}",
            "static bool single_bit_flip(unsigned char a, unsigned char b)",
            "{",
            "\tunsigned char error = a ^ b;",
            "",
            "\treturn error && !(error & (error - 1));",
            "}",
            "static void check_poison_mem(struct page *page, unsigned char *mem, size_t bytes)",
            "{",
            "\tstatic DEFINE_RATELIMIT_STATE(ratelimit, 5 * HZ, 10);",
            "\tunsigned char *start;",
            "\tunsigned char *end;",
            "",
            "\tstart = memchr_inv(mem, PAGE_POISON, bytes);",
            "\tif (!start)",
            "\t\treturn;",
            "",
            "\tfor (end = mem + bytes - 1; end > start; end--) {",
            "\t\tif (*end != PAGE_POISON)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\tif (!__ratelimit(&ratelimit))",
            "\t\treturn;",
            "\telse if (start == end && single_bit_flip(*start, PAGE_POISON))",
            "\t\tpr_err(\"pagealloc: single bit error\\n\");",
            "\telse",
            "\t\tpr_err(\"pagealloc: memory corruption\\n\");",
            "",
            "\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_ADDRESS, 16, 1, start,",
            "\t\t\tend - start + 1, 1);",
            "\tdump_stack();",
            "\tdump_page(page, \"pagealloc: corrupted page details\");",
            "}",
            "static void unpoison_page(struct page *page)",
            "{",
            "\tvoid *addr;",
            "",
            "\taddr = kmap_atomic(page);",
            "\tkasan_disable_current();",
            "\t/*",
            "\t * Page poisoning when enabled poisons each and every page",
            "\t * that is freed to buddy. Thus no extra check is done to",
            "\t * see if a page was poisoned.",
            "\t */",
            "\tcheck_poison_mem(page, kasan_reset_tag(addr), PAGE_SIZE);",
            "\tkasan_enable_current();",
            "\tkunmap_atomic(addr);",
            "}",
            "void __kernel_unpoison_pages(struct page *page, int n)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < n; i++)",
            "\t\tunpoison_page(page + i);",
            "}",
            "void __kernel_map_pages(struct page *page, int numpages, int enable)",
            "{",
            "\t/* This function does nothing, all work is done via poison pages */",
            "}"
          ],
          "function_name": "early_page_poison_param, poison_page, __kernel_poison_pages, single_bit_flip, check_poison_mem, unpoison_page, __kernel_unpoison_pages, __kernel_map_pages",
          "description": "该代码实现了一套页面毒化机制，用于检测内存错误及数据完整性。  \n`poison_page`与`unpoison_page`分别用于对释放的页面进行毒化标记和解除标记，`check_poison_mem`通过比对POISON值检测单比特翻转或内存破坏。  \n上下文不完整，未展示`_page_poisoning_enabled_early`等关键变量定义及完整调用链。",
          "similarity": 0.5433005094528198
        },
        {
          "chunk_id": 0,
          "file_path": "mm/page_poison.c",
          "start_line": 1,
          "end_line": 15,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/highmem.h>",
            "#include <linux/poison.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kasan.h>",
            "",
            "bool _page_poisoning_enabled_early;",
            "EXPORT_SYMBOL(_page_poisoning_enabled_early);",
            "DEFINE_STATIC_KEY_FALSE(_page_poisoning_enabled);",
            "EXPORT_SYMBOL(_page_poisoning_enabled);",
            ""
          ],
          "function_name": null,
          "description": "该代码片段定义了两个用于控制页面中毒功能的静态键变量 `_page_poisoning_enabled_early` 和 `_page_poisoning_enabled`，并导出其符号以供其他模块访问。这两个变量分别表示早期启动时和常规情况下页面中毒功能的启用状态。由于缺乏具体函数实现，无法进一步推断其完整行为。",
          "similarity": 0.4917559325695038
        }
      ]
    }
  ]
}