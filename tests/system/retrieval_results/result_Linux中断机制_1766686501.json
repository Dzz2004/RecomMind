{
  "query": "Linux中断机制",
  "timestamp": "2025-12-26 02:15:01",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/autoprobe.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:47:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\autoprobe.c`\n\n---\n\n# `irq/autoprobe.c` 技术文档\n\n## 1. 文件概述\n\n`irq/autoprobe.c` 实现了 Linux 内核中的中断自动探测（IRQ autodetection）机制。该机制用于在设备驱动程序无法预先知道其所使用的中断号时，动态探测硬件实际触发的中断线。文件提供了一组 API，允许驱动程序在安全、受控的环境下扫描并识别有效的中断请求（IRQ）线路。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`probe_irq_on(void)`**  \n  启动中断自动探测过程。激活所有可探测的未分配中断线，等待潜在中断触发，并返回一个位掩码，表示可能有效的低编号（<32）中断线。\n\n- **`probe_irq_mask(unsigned long val)`**  \n  扫描所有中断线，返回在指定掩码 `val` 范围内被触发的有效中断位图，并清理探测状态。\n\n- **`probe_irq_off(unsigned long val)`**  \n  结束中断探测，检查哪些中断线在探测期间被触发。若唯一中断被触发，返回其中断号；若多个中断被触发，返回负值表示冲突；若无中断触发，返回 0。\n\n### 关键数据结构与状态标志\n\n- **`IRQS_AUTODETECT`**：标记该中断正处于自动探测状态。\n- **`IRQS_WAITING`**：表示该中断尚未被触发；若在探测期间被触发，此标志会被清除。\n- **`probing_active`**：全局互斥锁（`mutex`），确保同一时间只有一个探测过程在进行。\n\n## 3. 关键实现\n\n### 探测流程\n\n1. **准备阶段（`probe_irq_on`）**：\n   - 调用 `async_synchronize_full()` 确保异步任务完成，避免干扰。\n   - 获取 `probing_active` 互斥锁，防止并发探测。\n   - 遍历所有中断描述符（`irq_desc`），对未分配（`!desc->action`）且允许探测（`irq_settings_can_probe`）的中断：\n     - 若芯片支持，调用 `irq_set_type(..., IRQ_TYPE_PROBE)` 通知硬件进入探测模式。\n     - 调用 `irq_activate_and_startup()` 激活并启用中断（不重发）。\n   - 等待 20ms，让“陈旧”中断（longstanding irq）有机会触发并自屏蔽。\n\n2. **正式探测阶段**：\n   - 再次遍历中断描述符，为可探测中断设置 `IRQS_AUTODETECT | IRQS_WAITING`。\n   - 重新激活中断（处理可能因陈旧中断而被屏蔽的情况）。\n   - 等待 100ms，让真实硬件中断触发。\n\n3. **结果收集与清理**：\n   - 在 `probe_irq_off` 或 `probe_irq_mask` 中：\n     - 检查哪些中断仍带有 `IRQS_AUTODETECT` 且 **未** 设置 `IRQS_WAITING`（即已被触发）。\n     - 清除 `IRQS_AUTODETECT` 标志，并调用 `irq_shutdown_and_deactivate()` 关闭中断。\n     - 根据触发中断的数量返回结果：唯一中断返回正号，多个返回负号，无触发返回 0。\n\n### 并发控制\n\n- 使用 `probing_active` 互斥锁保证探测过程的原子性。\n- 所有对 `irq_desc` 的访问均在 `raw_spin_lock_irq()` 保护下进行，确保中断上下文安全。\n\n### 硬件交互\n\n- 支持通过 `irq_chip->irq_set_type()` 向中断控制器发送 `IRQ_TYPE_PROBE` 类型，使某些硬件（如 ISA 控制器）进入探测兼容模式。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`：IRQ 核心定义。\n  - `<linux/interrupt.h>`：中断处理相关 API。\n  - `<linux/delay.h>`：提供 `msleep()`。\n  - `<linux/async.h>`：用于同步异步任务。\n  - `\"internals.h\"`：包含 IRQ 子系统内部函数（如 `irq_activate_and_startup`、`irq_shutdown_and_deactivate`）。\n\n- **内核子系统依赖**：\n  - **IRQ 子系统核心**：依赖 `irq_desc` 管理、中断激活/关闭逻辑。\n  - **中断控制器驱动**：依赖 `irq_chip` 回调（特别是 `irq_set_type`）。\n\n## 5. 使用场景\n\n- **传统 ISA/PnP 设备驱动**：在即插即用（PnP）或资源未知的旧硬件驱动中，用于动态确定设备使用的 IRQ 号。\n- **调试与诊断工具**：内核调试时用于验证硬件中断线路是否正常工作。\n- **模块化驱动初始化**：在 `module_init` 阶段，当设备资源未通过 ACPI/FDT 等机制明确指定时，作为后备探测手段。\n\n> **注意**：现代设备通常通过设备树（Device Tree）、ACPI 或 PCI 配置空间明确指定中断号，因此该机制主要用于遗留硬件支持。文档中也指出，在模块中使用时存在并发风险，应避免重叠调用。",
      "similarity": 0.6799031496047974,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/autoprobe.c",
          "start_line": 30,
          "end_line": 149,
          "content": [
            "unsigned long probe_irq_on(void)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tunsigned long mask = 0;",
            "\tint i;",
            "",
            "\t/*",
            "\t * quiesce the kernel, or at least the asynchronous portion",
            "\t */",
            "\tasync_synchronize_full();",
            "\tmutex_lock(&probing_active);",
            "\t/*",
            "\t * something may have generated an irq long ago and we want to",
            "\t * flush such a longstanding irq before considering it as spurious.",
            "\t */",
            "\tfor_each_irq_desc_reverse(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "\t\tif (!desc->action && irq_settings_can_probe(desc)) {",
            "\t\t\t/*",
            "\t\t\t * Some chips need to know about probing in",
            "\t\t\t * progress:",
            "\t\t\t */",
            "\t\t\tif (desc->irq_data.chip->irq_set_type)",
            "\t\t\t\tdesc->irq_data.chip->irq_set_type(&desc->irq_data,",
            "\t\t\t\t\t\t\t IRQ_TYPE_PROBE);",
            "\t\t\tirq_activate_and_startup(desc, IRQ_NORESEND);",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "",
            "\t/* Wait for longstanding interrupts to trigger. */",
            "\tmsleep(20);",
            "",
            "\t/*",
            "\t * enable any unassigned irqs",
            "\t * (we must startup again here because if a longstanding irq",
            "\t * happened in the previous stage, it may have masked itself)",
            "\t */",
            "\tfor_each_irq_desc_reverse(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "\t\tif (!desc->action && irq_settings_can_probe(desc)) {",
            "\t\t\tdesc->istate |= IRQS_AUTODETECT | IRQS_WAITING;",
            "\t\t\tif (irq_activate_and_startup(desc, IRQ_NORESEND))",
            "\t\t\t\tdesc->istate |= IRQS_PENDING;",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "",
            "\t/*",
            "\t * Wait for spurious interrupts to trigger",
            "\t */",
            "\tmsleep(100);",
            "",
            "\t/*",
            "\t * Now filter out any obviously spurious interrupts",
            "\t */",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "",
            "\t\tif (desc->istate & IRQS_AUTODETECT) {",
            "\t\t\t/* It triggered already - consider it spurious. */",
            "\t\t\tif (!(desc->istate & IRQS_WAITING)) {",
            "\t\t\t\tdesc->istate &= ~IRQS_AUTODETECT;",
            "\t\t\t\tirq_shutdown_and_deactivate(desc);",
            "\t\t\t} else",
            "\t\t\t\tif (i < 32)",
            "\t\t\t\t\tmask |= 1 << i;",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "",
            "\treturn mask;",
            "}",
            "unsigned int probe_irq_mask(unsigned long val)",
            "{",
            "\tunsigned int mask = 0;",
            "\tstruct irq_desc *desc;",
            "\tint i;",
            "",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "\t\tif (desc->istate & IRQS_AUTODETECT) {",
            "\t\t\tif (i < 16 && !(desc->istate & IRQS_WAITING))",
            "\t\t\t\tmask |= 1 << i;",
            "",
            "\t\t\tdesc->istate &= ~IRQS_AUTODETECT;",
            "\t\t\tirq_shutdown_and_deactivate(desc);",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "\tmutex_unlock(&probing_active);",
            "",
            "\treturn mask & val;",
            "}",
            "int probe_irq_off(unsigned long val)",
            "{",
            "\tint i, irq_found = 0, nr_of_irqs = 0;",
            "\tstruct irq_desc *desc;",
            "",
            "\tfor_each_irq_desc(i, desc) {",
            "\t\traw_spin_lock_irq(&desc->lock);",
            "",
            "\t\tif (desc->istate & IRQS_AUTODETECT) {",
            "\t\t\tif (!(desc->istate & IRQS_WAITING)) {",
            "\t\t\t\tif (!nr_of_irqs)",
            "\t\t\t\t\tirq_found = i;",
            "\t\t\t\tnr_of_irqs++;",
            "\t\t\t}",
            "\t\t\tdesc->istate &= ~IRQS_AUTODETECT;",
            "\t\t\tirq_shutdown_and_deactivate(desc);",
            "\t\t}",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t}",
            "\tmutex_unlock(&probing_active);",
            "",
            "\tif (nr_of_irqs > 1)",
            "\t\tirq_found = -irq_found;",
            "",
            "\treturn irq_found;",
            "}"
          ],
          "function_name": "probe_irq_on, probe_irq_mask, probe_irq_off",
          "description": "实现中断自动检测三阶段流程，probe_irq_on启用未分配中断并收集触发掩码，probe_irq_mask筛选有效中断位，probe_irq_off解析最终中断号，通过遍历中断描述符完成状态修改与激活控制。",
          "similarity": 0.5922725796699524
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/autoprobe.c",
          "start_line": 1,
          "end_line": 29,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992, 1998-2004 Linus Torvalds, Ingo Molnar",
            " *",
            " * This file contains the interrupt probing code and driver APIs.",
            " */",
            "",
            "#include <linux/irq.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "",
            "#include \"internals.h\"",
            "",
            "/*",
            " * Autodetection depends on the fact that any interrupt that",
            " * comes in on to an unassigned handler will get stuck with",
            " * \"IRQS_WAITING\" cleared and the interrupt disabled.",
            " */",
            "static DEFINE_MUTEX(probing_active);",
            "",
            "/**",
            " *\tprobe_irq_on\t- begin an interrupt autodetect",
            " *",
            " *\tCommence probing for an interrupt. The interrupts are scanned",
            " *\tand a mask of potential interrupt lines is returned.",
            " *",
            " */"
          ],
          "function_name": null,
          "description": "定义用于中断自动检测的互斥锁probing_active，并声明probe_irq_on、probe_irq_mask和probe_irq_off函数，为后续中断探针流程提供基础框架。",
          "similarity": 0.5125293731689453
        }
      ]
    },
    {
      "source_file": "kernel/irq/timings.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:10:35\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\timings.c`\n\n---\n\n# irq/timings.c 技术文档\n\n## 1. 文件概述\n\n`irq/timings.c` 是 Linux 内核中用于中断时间预测的核心模块。该文件实现了基于历史中断时间戳的预测算法，旨在通过分析中断发生的周期性模式，预测下一次中断可能发生的时间。此功能主要用于低功耗场景（如 CPU 空闲状态管理），帮助调度器或电源管理子系统更精确地设置唤醒时间，从而在保证响应性的同时减少不必要的唤醒开销。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct irq_timings`：每个 CPU 私有的中断时间记录结构，包含一个循环缓冲区，用于存储 `<中断号, 时间戳>` 元组。\n- `irqt_stats`：全局 IDR（整数到指针映射）结构，用于按中断号索引中断统计信息。\n- `irq_timing_enabled`：静态分支键（`static_key`），用于在运行时动态启用/禁用中断时间跟踪功能，避免性能开销。\n\n### 主要函数\n\n- `irq_timings_enable(void)`：启用中断时间跟踪功能，激活静态分支。\n- `irq_timings_disable(void)`：禁用中断时间跟踪功能，关闭静态分支。\n- （注：实际的预测算法逻辑虽未在代码片段中完整展示，但文档详细描述了其实现原理）\n\n## 3. 关键实现\n\n### 中断时间预测算法\n\n该模块采用三阶段算法预测中断周期：\n\n#### 1) 后缀数组（Suffix Array）模式识别\n- 将中断间隔（经 `ilog2` 映射后的索引值）序列视为字符串。\n- 构建长度为 2 到 5 的后缀（受限于实际设备周期经验）。\n- 在最近 `3 × max_period`（即 15）个索引中搜索后缀的重复出现。\n- 若某后缀连续出现 3 次，则认为发现有效周期模式，其长度即为预测周期。\n\n#### 2) 对数间隔桶（Log Interval Bucketing）\n- 使用 `ilog2(interval)` 将原始时间间隔映射到 0~63 的桶索引（因 `u64` 最大为 2^64）。\n- 该方法将大范围的时间值压缩到小数组中，例如值 1123 映射到索引 10（因 2^10 = 1024 ≤ 1123 < 2048 = 2^11）。\n\n#### 3) 指数移动平均（Exponential Moving Average, EMA）\n- 每个桶维护一个 EMA 值，用于平滑同一数量级间隔的波动。\n- EMA 公式使平均值对新数据具有可调的响应速度（通过 alpha 参数隐式控制）。\n- 预测时，根据识别出的周期模式中的桶索引，返回对应桶的 EMA 值作为预测间隔。\n\n### 工作流程\n1. 中断发生时，若 `irq_timing_enabled` 为真，则将 `<irq, timestamp>` 记录到 per-CPU 的循环缓冲区。\n2. 当需要预测某中断的下次发生时间时：\n   - 清空并处理循环缓冲区，将间隔数据分发到各中断的统计结构中。\n   - 对每个中断的间隔序列执行上述三阶段算法。\n   - 若找到重复模式，则用 EMA 值计算预测时间；否则返回未预测。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/percpu.h>`：实现 per-CPU 变量 `irq_timings`。\n  - `<linux/static_key.h>`：提供静态分支优化，避免未启用时的条件判断开销。\n  - `<linux/math64.h>` 和 `<linux/log2.h>`：用于 `ilog2` 等数学运算。\n  - `<trace/events/irq.h>`：可能用于跟踪事件（虽未在片段中调用）。\n  - `\"internals.h\"`：内核中断子系统内部头文件。\n- **子系统依赖**：\n  - 通用中断子系统（`<linux/irq.h>`, `<linux/interrupt.h>`）。\n  - 内存管理（`<linux/slab.h>`）用于动态分配统计结构。\n  - IDR 机制（`<linux/idr.h>`）用于中断号到统计结构的映射。\n\n## 5. 使用场景\n\n- **CPU 空闲状态管理（cpuidle）**：在进入深度 C-state 前，预测下一次中断时间以设置精确的唤醒定时器，避免过早或过晚唤醒。\n- **实时系统调度**：辅助调度器预判周期性中断（如 tickless 系统中的高精度定时器），优化任务调度时机。\n- **电源管理**：结合设备驱动的中断模式，动态调整设备或 CPU 的电源状态。\n- **性能分析**：通过跟踪中断时间模式，诊断中断风暴或异常周期行为。\n\n该功能默认关闭，仅在需要时通过 `irq_timings_enable()` 动态启用，确保对常规系统性能无影响。",
      "similarity": 0.6728991866111755,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/timings.c",
          "start_line": 1,
          "end_line": 25,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "// Copyright (C) 2016, Linaro Ltd - Daniel Lezcano <daniel.lezcano@linaro.org>",
            "#define pr_fmt(fmt) \"irq_timings: \" fmt",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/static_key.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/idr.h>",
            "#include <linux/irq.h>",
            "#include <linux/math64.h>",
            "#include <linux/log2.h>",
            "",
            "#include <trace/events/irq.h>",
            "",
            "#include \"internals.h\"",
            "",
            "DEFINE_STATIC_KEY_FALSE(irq_timing_enabled);",
            "",
            "DEFINE_PER_CPU(struct irq_timings, irq_timings);",
            "",
            "static DEFINE_IDR(irqt_stats);",
            ""
          ],
          "function_name": null,
          "description": "定义中断计时模块的静态键开关和PER-CPU结构体，声明IDR管理器用于动态分配中断统计实例",
          "similarity": 0.5950039029121399
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/timings.c",
          "start_line": 26,
          "end_line": 165,
          "content": [
            "void irq_timings_enable(void)",
            "{",
            "\tstatic_branch_enable(&irq_timing_enabled);",
            "}",
            "void irq_timings_disable(void)",
            "{",
            "\tstatic_branch_disable(&irq_timing_enabled);",
            "}",
            "static u64 irq_timings_ema_new(u64 value, u64 ema_old)",
            "{",
            "\ts64 diff;",
            "",
            "\tif (unlikely(!ema_old))",
            "\t\treturn value;",
            "",
            "\tdiff = (value - ema_old) * EMA_ALPHA_VAL;",
            "\t/*",
            "\t * We can use a s64 type variable to be added with the u64",
            "\t * ema_old variable as this one will never have its topmost",
            "\t * bit set, it will be always smaller than 2^63 nanosec",
            "\t * interrupt interval (292 years).",
            "\t */",
            "\treturn ema_old + (diff >> EMA_ALPHA_SHIFT);",
            "}",
            "static int irq_timings_next_event_index(int *buffer, size_t len, int period_max)",
            "{",
            "\tint period;",
            "",
            "\t/*",
            "\t * Move the beginning pointer to the end minus the max period x 3.",
            "\t * We are at the point we can begin searching the pattern",
            "\t */",
            "\tbuffer = &buffer[len - (period_max * 3)];",
            "",
            "\t/* Adjust the length to the maximum allowed period x 3 */",
            "\tlen = period_max * 3;",
            "",
            "\t/*",
            "\t * The buffer contains the suite of intervals, in a ilog2",
            "\t * basis, we are looking for a repetition. We point the",
            "\t * beginning of the search three times the length of the",
            "\t * period beginning at the end of the buffer. We do that for",
            "\t * each suffix.",
            "\t */",
            "\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {",
            "",
            "\t\t/*",
            "\t\t * The first comparison always succeed because the",
            "\t\t * suffix is deduced from the first n-period bytes of",
            "\t\t * the buffer and we compare the initial suffix with",
            "\t\t * itself, so we can skip the first iteration.",
            "\t\t */",
            "\t\tint idx = period;",
            "\t\tsize_t size = period;",
            "",
            "\t\t/*",
            "\t\t * We look if the suite with period 'i' repeat",
            "\t\t * itself. If it is truncated at the end, as it",
            "\t\t * repeats we can use the period to find out the next",
            "\t\t * element with the modulo.",
            "\t\t */",
            "\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {",
            "",
            "\t\t\t/*",
            "\t\t\t * Move the index in a period basis",
            "\t\t\t */",
            "\t\t\tidx += size;",
            "",
            "\t\t\t/*",
            "\t\t\t * If this condition is reached, all previous",
            "\t\t\t * memcmp were successful, so the period is",
            "\t\t\t * found.",
            "\t\t\t */",
            "\t\t\tif (idx == len)",
            "\t\t\t\treturn buffer[len % period];",
            "",
            "\t\t\t/*",
            "\t\t\t * If the remaining elements to compare are",
            "\t\t\t * smaller than the period, readjust the size",
            "\t\t\t * of the comparison for the last iteration.",
            "\t\t\t */",
            "\t\t\tif (len - idx < period)",
            "\t\t\t\tsize = len - idx;",
            "\t\t}",
            "\t}",
            "",
            "\treturn -1;",
            "}",
            "static u64 __irq_timings_next_event(struct irqt_stat *irqs, int irq, u64 now)",
            "{",
            "\tint index, i, period_max, count, start, min = INT_MAX;",
            "",
            "\tif ((now - irqs->last_ts) >= NSEC_PER_SEC) {",
            "\t\tirqs->count = irqs->last_ts = 0;",
            "\t\treturn U64_MAX;",
            "\t}",
            "",
            "\t/*",
            "\t * As we want to find three times the repetition, we need a",
            "\t * number of intervals greater or equal to three times the",
            "\t * maximum period, otherwise we truncate the max period.",
            "\t */",
            "\tperiod_max = irqs->count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : irqs->count / 3;",
            "",
            "\t/*",
            "\t * If we don't have enough irq timings for this prediction,",
            "\t * just bail out.",
            "\t */",
            "\tif (period_max <= PREDICTION_PERIOD_MIN)",
            "\t\treturn U64_MAX;",
            "",
            "\t/*",
            "\t * 'count' will depends if the circular buffer wrapped or not",
            "\t */",
            "\tcount = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\tirqs->count : IRQ_TIMINGS_SIZE;",
            "",
            "\tstart = irqs->count < IRQ_TIMINGS_SIZE ?",
            "\t\t0 : (irqs->count & IRQ_TIMINGS_MASK);",
            "",
            "\t/*",
            "\t * Copy the content of the circular buffer into another buffer",
            "\t * in order to linearize the buffer instead of dealing with",
            "\t * wrapping indexes and shifted array which will be prone to",
            "\t * error and extremely difficult to debug.",
            "\t */",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "",
            "\t\tirqs->timings[i] = irqs->circ_timings[index];",
            "\t\tmin = min_t(int, irqs->timings[i], min);",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(irqs->timings, count, period_max);",
            "\tif (index < 0)",
            "\t\treturn irqs->last_ts + irqs->ema_time[min];",
            "",
            "\treturn irqs->last_ts + irqs->ema_time[index];",
            "}"
          ],
          "function_name": "irq_timings_enable, irq_timings_disable, irq_timings_ema_new, irq_timings_next_event_index, __irq_timings_next_event",
          "description": "实现中断计时功能的启用/禁用控制，EMA计算算法及基于模式匹配的周期预测核心逻辑",
          "similarity": 0.5784847736358643
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/timings.c",
          "start_line": 594,
          "end_line": 739,
          "content": [
            "void irq_timings_free(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s) {",
            "\t\tfree_percpu(s);",
            "\t\tidr_remove(&irqt_stats, irq);",
            "\t}",
            "}",
            "int irq_timings_alloc(int irq)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tint id;",
            "",
            "\t/*",
            "\t * Some platforms can have the same private interrupt per cpu,",
            "\t * so this function may be called several times with the",
            "\t * same interrupt number. Just bail out in case the per cpu",
            "\t * stat structure is already allocated.",
            "\t */",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (s)",
            "\t\treturn 0;",
            "",
            "\ts = alloc_percpu(*s);",
            "\tif (!s)",
            "\t\treturn -ENOMEM;",
            "",
            "\tidr_preload(GFP_KERNEL);",
            "\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);",
            "\tidr_preload_end();",
            "",
            "\tif (id < 0) {",
            "\t\tfree_percpu(s);",
            "\t\treturn id;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_test_next_index(struct timings_intervals *ti)",
            "{",
            "\tint _buffer[IRQ_TIMINGS_SIZE];",
            "\tint buffer[IRQ_TIMINGS_SIZE];",
            "\tint index, start, i, count, period_max;",
            "",
            "\tcount = ti->count - 1;",
            "",
            "\tperiod_max = count > (3 * PREDICTION_PERIOD_MAX) ?",
            "\t\tPREDICTION_PERIOD_MAX : count / 3;",
            "",
            "\t/*",
            "\t * Inject all values except the last one which will be used",
            "\t * to compare with the next index result.",
            "\t */",
            "\tpr_debug(\"index suite: \");",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\t_buffer[i & IRQ_TIMINGS_MASK] = index;",
            "\t\tpr_cont(\"%d \", index);",
            "\t}",
            "",
            "\tstart = count < IRQ_TIMINGS_SIZE ? 0 :",
            "\t\tcount & IRQ_TIMINGS_MASK;",
            "",
            "\tcount = min_t(int, count, IRQ_TIMINGS_SIZE);",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tint index = (start + i) & IRQ_TIMINGS_MASK;",
            "\t\tbuffer[i] = _buffer[index];",
            "\t}",
            "",
            "\tindex = irq_timings_next_event_index(buffer, count, period_max);",
            "\ti = irq_timings_interval_index(ti->intervals[ti->count - 1]);",
            "",
            "\tif (index != i) {",
            "\t\tpr_err(\"Expected (%d) and computed (%d) next indexes differ\\n\",",
            "\t\t       i, index);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_next_index_selftest(void)",
            "{",
            "\tint i, ret;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {",
            "",
            "\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",",
            "\t\t\ti, tis[i].count);",
            "",
            "\t\tret = irq_timings_test_next_index(&tis[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __init irq_timings_test_irqs(struct timings_intervals *ti)",
            "{",
            "\tstruct irqt_stat __percpu *s;",
            "\tstruct irqt_stat *irqs;",
            "\tint i, index, ret, irq = 0xACE5;",
            "",
            "\tret = irq_timings_alloc(irq);",
            "\tif (ret) {",
            "\t\tpr_err(\"Failed to allocate irq timings\\n\");",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ts = idr_find(&irqt_stats, irq);",
            "\tif (!s) {",
            "\t\tret = -EIDRM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tirqs = this_cpu_ptr(s);",
            "",
            "\tfor (i = 0; i < ti->count; i++) {",
            "",
            "\t\tindex = irq_timings_interval_index(ti->intervals[i]);",
            "\t\tpr_debug(\"%d: interval=%llu ema_index=%d\\n\",",
            "\t\t\t i, ti->intervals[i], index);",
            "",
            "\t\t__irq_timings_store(irq, irqs, ti->intervals[i]);",
            "\t\tif (irqs->circ_timings[i & IRQ_TIMINGS_MASK] != index) {",
            "\t\t\tret = -EBADSLT;",
            "\t\t\tpr_err(\"Failed to store in the circular buffer\\n\");",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tif (irqs->count != ti->count) {",
            "\t\tret = -ERANGE;",
            "\t\tpr_err(\"Count differs\\n\");",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = 0;",
            "out:",
            "\tirq_timings_free(irq);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_free, irq_timings_alloc, irq_timings_test_next_index, irq_timings_next_index_selftest, irq_timings_test_irqs",
          "description": "实现中断统计结构的动态分配/释放机制，包含预测算法的自检测试函数",
          "similarity": 0.5727349519729614
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/irq/timings.c",
          "start_line": 927,
          "end_line": 956,
          "content": [
            "static int __init irq_timings_selftest(void)",
            "{",
            "\tint ret;",
            "",
            "\tpr_info(\"------------------- selftest start -----------------\\n\");",
            "",
            "\t/*",
            "\t * At this point, we don't except any subsystem to use the irq",
            "\t * timings but us, so it should not be enabled.",
            "\t */",
            "\tif (static_branch_unlikely(&irq_timing_enabled)) {",
            "\t\tpr_warn(\"irq timings already initialized, skipping selftest\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tret = irq_timings_irqts_selftest();",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tret = irq_timings_irqs_selftest();",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tret = irq_timings_next_index_selftest();",
            "out:",
            "\tpr_info(\"---------- selftest end with %s -----------\\n\",",
            "\t\tret ? \"failure\" : \"success\");",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_selftest",
          "description": "该代码段实现了中断定时功能的自我检测逻辑，用于验证中断时间戳、中断序列及索引管理等子系统的正确性。作为初始化函数，它通过调用三个子测试函数依次检查相关功能模块的行为是否符合预期。由于代码中引用了未展示的测试函数（如irq_timings_irqts_selftest），需结合上下文才能完整理解其工作机制。",
          "similarity": 0.5706967115402222
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/timings.c",
          "start_line": 821,
          "end_line": 923,
          "content": [
            "static int __init irq_timings_irqs_selftest(void)",
            "{",
            "\tint i, ret;",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {",
            "\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",",
            "\t\t\ti, tis[i].count);",
            "\t\tret = irq_timings_test_irqs(&tis[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int __init irq_timings_test_irqts(struct irq_timings *irqts,",
            "\t\t\t\t\t unsigned count)",
            "{",
            "\tint start = count >= IRQ_TIMINGS_SIZE ? count - IRQ_TIMINGS_SIZE : 0;",
            "\tint i, irq, oirq = 0xBEEF;",
            "\tu64 ots = 0xDEAD, ts;",
            "",
            "\t/*",
            "\t * Fill the circular buffer by using the dedicated function.",
            "\t */",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tpr_debug(\"%d: index=%d, ts=%llX irq=%X\\n\",",
            "\t\t\t i, i & IRQ_TIMINGS_MASK, ots + i, oirq + i);",
            "",
            "\t\tirq_timings_push(ots + i, oirq + i);",
            "\t}",
            "",
            "\t/*",
            "\t * Compute the first elements values after the index wrapped",
            "\t * up or not.",
            "\t */",
            "\tots += start;",
            "\toirq += start;",
            "",
            "\t/*",
            "\t * Test the circular buffer count is correct.",
            "\t */",
            "\tpr_debug(\"---> Checking timings array count (%d) is right\\n\", count);",
            "\tif (WARN_ON(irqts->count != count))",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * Test the macro allowing to browse all the irqts.",
            "\t */",
            "\tpr_debug(\"---> Checking the for_each_irqts() macro\\n\");",
            "\tfor_each_irqts(i, irqts) {",
            "",
            "\t\tirq = irq_timing_decode(irqts->values[i], &ts);",
            "",
            "\t\tpr_debug(\"index=%d, ts=%llX / %llX, irq=%X / %X\\n\",",
            "\t\t\t i, ts, ots, irq, oirq);",
            "",
            "\t\tif (WARN_ON(ts != ots || irq != oirq))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tots++; oirq++;",
            "\t}",
            "",
            "\t/*",
            "\t * The circular buffer should have be flushed when browsed",
            "\t * with for_each_irqts",
            "\t */",
            "\tpr_debug(\"---> Checking timings array is empty after browsing it\\n\");",
            "\tif (WARN_ON(irqts->count))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static int __init irq_timings_irqts_selftest(void)",
            "{",
            "\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);",
            "\tint i, ret;",
            "",
            "\t/*",
            "\t * Test the circular buffer with different number of",
            "\t * elements. The purpose is to test at the limits (empty, half",
            "\t * full, full, wrapped with the cursor at the boundaries,",
            "\t * wrapped several times, etc ...",
            "\t */",
            "\tint count[] = { 0,",
            "\t\t\tIRQ_TIMINGS_SIZE >> 1,",
            "\t\t\tIRQ_TIMINGS_SIZE,",
            "\t\t\tIRQ_TIMINGS_SIZE + (IRQ_TIMINGS_SIZE >> 1),",
            "\t\t\t2 * IRQ_TIMINGS_SIZE,",
            "\t\t\t(2 * IRQ_TIMINGS_SIZE) + 3,",
            "\t};",
            "",
            "\tfor (i = 0; i < ARRAY_SIZE(count); i++) {",
            "",
            "\t\tpr_info(\"---> Checking the timings with %d/%d values\\n\",",
            "\t\t\tcount[i], IRQ_TIMINGS_SIZE);",
            "",
            "\t\tret = irq_timings_test_irqts(irqts, count[i]);",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "\t}",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "irq_timings_irqs_selftest, irq_timings_test_irqts, irq_timings_irqts_selftest",
          "description": "包含完整的中断计时模块自检框架，验证环形缓冲区操作和for_each_irqts宏的正确性",
          "similarity": 0.5426793098449707
        }
      ]
    },
    {
      "source_file": "kernel/irq/irq_sim.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:58:53\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\irq_sim.c`\n\n---\n\n# `irq/irq_sim.c` 技术文档\n\n## 1. 文件概述\n\n`irq/irq_sim.c` 实现了一个**中断模拟器（IRQ Simulator）**，用于在 Linux 内核中创建虚拟的中断域（`irq_domain`），以模拟硬件中断行为。该模块主要用于**测试、调试和驱动开发**场景，允许开发者在没有真实硬件中断源的情况下触发和处理中断。它通过 `irq_work` 机制异步处理“模拟中断”，并提供标准的 `irq_chip` 接口，使上层驱动代码可以像使用真实中断一样使用这些虚拟中断。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct irq_sim_work_ctx`**  \n  中断模拟器的工作上下文，包含：\n  - `struct irq_work work`：用于异步处理待处理中断的 irq_work 实例\n  - `int irq_base`：保留字段（当前未使用）\n  - `unsigned int irq_count`：模拟中断的数量\n  - `unsigned long *pending`：位图，标记哪些中断处于 pending 状态\n  - `struct irq_domain *domain`：关联的中断域\n\n- **`struct irq_sim_irq_ctx`**  \n  每个虚拟中断的上下文，包含：\n  - `int irqnum`：保留字段（当前未使用）\n  - `bool enabled`：中断是否已启用（unmask）\n  - `struct irq_sim_work_ctx *work_ctx`：指向工作上下文的指针\n\n- **`struct irq_chip irq_sim_irqchip`**  \n  虚拟中断控制器的实现，提供标准的中断芯片操作接口。\n\n- **`struct irq_domain_ops irq_sim_domain_ops`**  \n  中断域映射操作集，用于虚拟中断号与硬件中断号的映射管理。\n\n### 主要函数\n\n- **`irq_domain_create_sim()`**  \n  创建一个新的中断模拟器域，分配指定数量的虚拟中断。\n\n- **`irq_domain_remove_sim()`**  \n  销毁中断模拟器域，释放相关资源。\n\n- **`devm_irq_domain_create_sim()`**  \n  基于设备资源管理（devres）的中断模拟器创建函数，自动在设备卸载时清理资源。\n\n- **`irq_sim_handle_irq()`**  \n  `irq_work` 的回调函数，遍历 pending 位图并触发对应的虚拟中断。\n\n- **`irq_sim_irqmask()` / `irq_sim_irqunmask()`**  \n  实现中断的屏蔽与解除屏蔽，仅设置 `enabled` 标志。\n\n- **`irq_sim_set_type()`**  \n  设置中断触发类型，仅支持 `IRQ_TYPE_EDGE_RISING` 和 `IRQ_TYPE_EDGE_FALLING`。\n\n- **`irq_sim_get_irqchip_state()` / `irq_sim_set_irqchip_state()`**  \n  查询和设置中断芯片状态（目前仅支持 `IRQCHIP_STATE_PENDING`）。\n\n## 3. 关键实现\n\n### 中断模拟机制\n- 使用 **位图（`pending`）** 记录哪些虚拟中断处于 pending 状态。\n- 当调用 `irq_sim_set_irqchip_state(..., IRQCHIP_STATE_PENDING, true)` 时：\n  - 若中断已启用（`enabled == true`），则在位图中标记对应位。\n  - 同时调用 `irq_work_queue()` 触发异步处理。\n- `irq_work` 回调 `irq_sim_handle_irq()` 遍历位图，对每个 pending 中断：\n  - 清除位图中的对应位。\n  - 通过 `irq_find_mapping()` 获取虚拟中断号。\n  - 调用 `handle_simple_irq()` 触发中断处理流程。\n\n### 中断域管理\n- 使用 **线性映射（`irq_domain_create_linear`）** 创建中断域。\n- 每个虚拟中断在 `map` 时分配独立的 `irq_sim_irq_ctx`，并绑定 `irq_sim_irqchip`。\n- 中断默认设置为 `IRQ_NOREQUEST | IRQ_NOAUTOEN`，防止自动使能和用户空间请求。\n\n### 资源管理\n- `devm_irq_domain_create_sim()` 利用内核的 **设备资源管理（devres）** 机制，在设备移除时自动调用 `irq_domain_remove_sim()`。\n- `irq_domain_remove_sim()` 会同步等待所有 pending 的 `irq_work` 完成（`irq_work_sync()`），确保安全释放内存。\n\n### 中断状态控制\n- 仅当中断处于 **enabled 状态** 时，才允许设置或查询 pending 状态。\n- 不支持电平触发中断，仅支持边沿触发（`IRQ_TYPE_EDGE_BOTH`）。\n\n## 4. 依赖关系\n\n- **`<linux/irq.h>`**：提供中断核心 API（如 `irq_set_chip`、`handle_simple_irq`）。\n- **`<linux/irq_sim.h>`**：定义中断模拟器的公共接口（如 `irq_domain_create_sim` 声明）。\n- **`<linux/irq_work.h>`**：提供 `irq_work` 机制，用于异步中断处理。\n- **`<linux/interrupt.h>`**：提供中断描述符和状态操作函数。\n- **`<linux/slab.h>`**：提供动态内存分配（`kmalloc`/`kzalloc`/`kfree`）。\n- **依赖 `GENERIC_IRQ_CHIP` 和 `IRQ_DOMAIN` 子系统**：作为中断子系统的扩展模块。\n\n## 5. 使用场景\n\n- **驱动开发与测试**：在无硬件环境下验证中断处理逻辑。\n- **虚拟化与仿真**：为虚拟设备提供中断模拟支持。\n- **内核子系统测试**：用于测试中断子系统、电源管理、实时性等模块。\n- **平台无关的中断逻辑验证**：避免依赖特定硬件平台进行中断行为测试。\n- **教学与调试**：帮助理解 Linux 中断处理机制的工作流程。",
      "similarity": 0.6715284585952759,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/irq_sim.c",
          "start_line": 203,
          "end_line": 218,
          "content": [
            "void irq_domain_remove_sim(struct irq_domain *domain)",
            "{",
            "\tstruct irq_sim_work_ctx *work_ctx = domain->host_data;",
            "",
            "\tirq_work_sync(&work_ctx->work);",
            "\tbitmap_free(work_ctx->pending);",
            "\tkfree(work_ctx);",
            "",
            "\tirq_domain_remove(domain);",
            "}",
            "static void devm_irq_domain_remove_sim(void *data)",
            "{",
            "\tstruct irq_domain *domain = data;",
            "",
            "\tirq_domain_remove_sim(domain);",
            "}"
          ],
          "function_name": "irq_domain_remove_sim, devm_irq_domain_remove_sim",
          "description": "提供中断域清理接口，同步工作队列确保Pending中断处理完成，释放位图内存并安全移除中断域，包含设备管理器版本的延迟卸载实现",
          "similarity": 0.6532593965530396
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/irq_sim.c",
          "start_line": 27,
          "end_line": 131,
          "content": [
            "static void irq_sim_irqmask(struct irq_data *data)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);",
            "",
            "\tirq_ctx->enabled = false;",
            "}",
            "static void irq_sim_irqunmask(struct irq_data *data)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);",
            "",
            "\tirq_ctx->enabled = true;",
            "}",
            "static int irq_sim_set_type(struct irq_data *data, unsigned int type)",
            "{",
            "\t/* We only support rising and falling edge trigger types. */",
            "\tif (type & ~IRQ_TYPE_EDGE_BOTH)",
            "\t\treturn -EINVAL;",
            "",
            "\tirqd_set_trigger_type(data, type);",
            "",
            "\treturn 0;",
            "}",
            "static int irq_sim_get_irqchip_state(struct irq_data *data,",
            "\t\t\t\t     enum irqchip_irq_state which, bool *state)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);",
            "\tirq_hw_number_t hwirq = irqd_to_hwirq(data);",
            "",
            "\tswitch (which) {",
            "\tcase IRQCHIP_STATE_PENDING:",
            "\t\tif (irq_ctx->enabled)",
            "\t\t\t*state = test_bit(hwirq, irq_ctx->work_ctx->pending);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int irq_sim_set_irqchip_state(struct irq_data *data,",
            "\t\t\t\t     enum irqchip_irq_state which, bool state)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);",
            "\tirq_hw_number_t hwirq = irqd_to_hwirq(data);",
            "",
            "\tswitch (which) {",
            "\tcase IRQCHIP_STATE_PENDING:",
            "\t\tif (irq_ctx->enabled) {",
            "\t\t\tassign_bit(hwirq, irq_ctx->work_ctx->pending, state);",
            "\t\t\tif (state)",
            "\t\t\t\tirq_work_queue(&irq_ctx->work_ctx->work);",
            "\t\t}",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void irq_sim_handle_irq(struct irq_work *work)",
            "{",
            "\tstruct irq_sim_work_ctx *work_ctx;",
            "\tunsigned int offset = 0;",
            "\tint irqnum;",
            "",
            "\twork_ctx = container_of(work, struct irq_sim_work_ctx, work);",
            "",
            "\twhile (!bitmap_empty(work_ctx->pending, work_ctx->irq_count)) {",
            "\t\toffset = find_next_bit(work_ctx->pending,",
            "\t\t\t\t       work_ctx->irq_count, offset);",
            "\t\tclear_bit(offset, work_ctx->pending);",
            "\t\tirqnum = irq_find_mapping(work_ctx->domain, offset);",
            "\t\thandle_simple_irq(irq_to_desc(irqnum));",
            "\t}",
            "}",
            "static int irq_sim_domain_map(struct irq_domain *domain,",
            "\t\t\t      unsigned int virq, irq_hw_number_t hw)",
            "{",
            "\tstruct irq_sim_work_ctx *work_ctx = domain->host_data;",
            "\tstruct irq_sim_irq_ctx *irq_ctx;",
            "",
            "\tirq_ctx = kzalloc(sizeof(*irq_ctx), GFP_KERNEL);",
            "\tif (!irq_ctx)",
            "\t\treturn -ENOMEM;",
            "",
            "\tirq_set_chip(virq, &irq_sim_irqchip);",
            "\tirq_set_chip_data(virq, irq_ctx);",
            "\tirq_set_handler(virq, handle_simple_irq);",
            "\tirq_modify_status(virq, IRQ_NOREQUEST | IRQ_NOAUTOEN, IRQ_NOPROBE);",
            "\tirq_ctx->work_ctx = work_ctx;",
            "",
            "\treturn 0;",
            "}",
            "static void irq_sim_domain_unmap(struct irq_domain *domain, unsigned int virq)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx;",
            "\tstruct irq_data *irqd;",
            "",
            "\tirqd = irq_domain_get_irq_data(domain, virq);",
            "\tirq_ctx = irq_data_get_irq_chip_data(irqd);",
            "",
            "\tirq_set_handler(virq, NULL);",
            "\tirq_domain_reset_irq_data(irqd);",
            "\tkfree(irq_ctx);",
            "}"
          ],
          "function_name": "irq_sim_irqmask, irq_sim_irqunmask, irq_sim_set_type, irq_sim_get_irqchip_state, irq_sim_set_irqchip_state, irq_sim_handle_irq, irq_sim_domain_map, irq_sim_domain_unmap",
          "description": "实现模拟中断芯片的操作函数，包括中断使能/禁止控制、触发类型设置、芯片状态读取/修改、中断处理回调及中断域映射/解除映射逻辑，通过位图管理待处理中断并调度至简单中断处理流程",
          "similarity": 0.6382542252540588
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/irq_sim.c",
          "start_line": 1,
          "end_line": 26,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * Copyright (C) 2017-2018 Bartosz Golaszewski <brgl@bgdev.pl>",
            " * Copyright (C) 2020 Bartosz Golaszewski <bgolaszewski@baylibre.com>",
            " */",
            "",
            "#include <linux/irq.h>",
            "#include <linux/irq_sim.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "",
            "struct irq_sim_work_ctx {",
            "\tstruct irq_work\t\twork;",
            "\tint\t\t\tirq_base;",
            "\tunsigned int\t\tirq_count;",
            "\tunsigned long\t\t*pending;",
            "\tstruct irq_domain\t*domain;",
            "};",
            "",
            "struct irq_sim_irq_ctx {",
            "\tint\t\t\tirqnum;",
            "\tbool\t\t\tenabled;",
            "\tstruct irq_sim_work_ctx\t*work_ctx;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义了irq_sim_work_ctx和irq_sim_irq_ctx结构体，前者用于维护中断工作队列上下文（含位图pending、中断域指针等），后者保存单个中断的配置信息（中断号、启用状态及工作上下文指针）",
          "similarity": 0.5290080904960632
        }
      ]
    }
  ]
}