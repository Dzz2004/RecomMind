{
  "query": "限制访问 加密文件系统",
  "timestamp": "2025-12-26 01:33:48",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/token.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:36:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\token.c`\n\n---\n\n# `bpf/token.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/token.c` 实现了 BPF（Berkeley Packet Filter）令牌（token）机制，用于在受限环境中安全地委托 BPF 操作权限。该机制允许用户空间程序通过文件描述符形式的令牌，将特定的 BPF 命令、映射类型、程序类型和附加类型权限委托给其他进程，同时结合用户命名空间（user namespace）和 LSM（Linux Security Module）安全策略进行细粒度访问控制。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `bpf_ns_capable()`：检查用户命名空间是否具备指定能力，或具备 `CAP_SYS_ADMIN`（除 `CAP_SYS_ADMIN` 自身外）。\n- `bpf_token_capable()`：结合用户命名空间能力和 LSM 安全钩子，判断令牌是否具备指定能力。\n- `bpf_token_inc()` / `bpf_token_put()`：引用计数管理，支持延迟释放。\n- `bpf_token_free()`：释放令牌资源，包括用户命名空间引用和安全模块数据。\n- `bpf_token_create()`：创建 BPF 令牌文件描述符，基于挂载在 BPF 文件系统上的委托配置。\n- `bpf_token_get_from_fd()`：从文件描述符获取并增加引用计数的 `bpf_token` 结构。\n- `bpf_token_allow_cmd()` / `bpf_token_allow_map_type()` / `bpf_token_allow_prog_type()`：检查令牌是否允许执行特定 BPF 操作。\n\n### 关键数据结构\n\n- `struct bpf_token`：表示 BPF 令牌，包含：\n  - `refcnt`：引用计数（`atomic64_t`）\n  - `userns`：关联的用户命名空间\n  - `allowed_cmds` / `allowed_maps` / `allowed_progs` / `allowed_attachs`：位掩码，分别表示允许的 BPF 命令、映射类型、程序类型和附加类型\n  - `work`：用于延迟释放的工作队列项\n\n### 文件操作接口\n\n- `bpf_token_fops`：定义了 `release` 和 `show_fdinfo` 回调，用于文件关闭和 `/proc/pid/fdinfo/` 信息展示。\n\n## 3. 关键实现\n\n### 令牌创建流程 (`bpf_token_create`)\n\n1. **验证输入**：检查传入的 `bpffs_fd` 是否指向 BPF 文件系统的根目录。\n2. **权限校验**：\n   - 要求调用者与 BPF 文件系统实例处于同一用户命名空间。\n   - 必须具备 `CAP_BPF` 能力。\n   - 禁止在 `init_user_ns` 中创建令牌。\n3. **委托配置检查**：确保 BPF 文件系统挂载时已通过挂载选项设置了至少一项委托权限（`delegate_*` 字段非零）。\n4. **资源分配**：\n   - 创建匿名 inode 和文件。\n   - 分配 `bpf_token` 结构并初始化引用计数为 1。\n   - 复制挂载选项中的委托位掩码到令牌。\n5. **安全模块集成**：调用 `security_bpf_token_create()` 允许 LSM 进行额外策略检查。\n6. **返回文件描述符**：安装文件到进程 fd 表并返回。\n\n### 安全能力检查 (`bpf_token_capable`)\n\n- 默认允许 `CAP_SYS_ADMIN` 作为“超级能力”覆盖其他能力检查（但 `CAP_SYS_ADMIN` 本身仍需显式授权）。\n- 调用 `security_bpf_token_capable()` 允许 LSM 对令牌能力进行二次验证。\n\n### 引用计数与延迟释放\n\n- 使用 `atomic64_t refcnt` 管理生命周期。\n- 当引用计数归零时，通过 `schedule_work()` 将释放操作推迟到工作队列执行，避免在中断或原子上下文中调用可能睡眠的 `put_user_ns()` 和 `kfree()`。\n\n### `/proc/pid/fdinfo/` 支持\n\n- `bpf_token_show_fdinfo()` 将令牌的委托权限以十六进制或 \"any\" 形式输出，便于调试和审计。\n\n### 权限位掩码设计\n\n- 所有委托权限（命令、映射、程序、附加类型）均使用 64 位无符号整数位掩码表示。\n- 通过 `BUILD_BUG_ON()` 确保枚举类型数量不超过 64，防止位移溢出。\n- 若掩码全为 1，则显示为 \"any\"，表示无限制。\n\n## 4. 依赖关系\n\n- **BPF 子系统**：依赖 `bpf_super_ops`、`bpf_get_inode()` 等 BPF 文件系统接口。\n- **用户命名空间**：通过 `user_namespace` 和 `ns_capable()` 实现能力隔离。\n- **安全模块 (LSM)**：集成 `security_bpf_token_*` 钩子，支持 SELinux、AppArmor 等策略扩展。\n- **VFS 层**：使用 `inode`、`file`、`path`、`fdtable` 等通用文件系统抽象。\n- **内存管理**：使用 `kzalloc()`/`kfree()` 和 `vmalloc.h`（虽未直接使用，但为潜在扩展预留）。\n- **工作队列**：通过 `schedule_work()` 实现延迟释放。\n\n## 5. 使用场景\n\n- **容器化环境中的 BPF 权限委托**：在用户命名空间隔离的容器中，特权进程可创建 BPF 令牌并传递给非特权子进程，使其在受限范围内使用 BPF 功能（如 eBPF 程序加载、映射操作）。\n- **安全沙箱**：应用程序可通过令牌机制将特定 BPF 操作权限委托给插件或子模块，避免授予完整 `CAP_BPF` 或 `CAP_SYS_ADMIN`。\n- **审计与调试**：通过 `/proc/pid/fdinfo/` 查看进程持有的 BPF 令牌权限，辅助安全分析。\n- **LSM 策略集成**：安全模块可基于令牌内容实施更细粒度的访问控制，例如限制特定程序类型只能在特定挂载点使用。",
      "similarity": 0.5929930806159973,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/token.c",
          "start_line": 230,
          "end_line": 254,
          "content": [
            "bool bpf_token_allow_cmd(const struct bpf_token *token, enum bpf_cmd cmd)",
            "{",
            "\tif (!token)",
            "\t\treturn false;",
            "\tif (!(token->allowed_cmds & (1ULL << cmd)))",
            "\t\treturn false;",
            "\treturn security_bpf_token_cmd(token, cmd) == 0;",
            "}",
            "bool bpf_token_allow_map_type(const struct bpf_token *token, enum bpf_map_type type)",
            "{",
            "\tif (!token || type >= __MAX_BPF_MAP_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn token->allowed_maps & (1ULL << type);",
            "}",
            "bool bpf_token_allow_prog_type(const struct bpf_token *token,",
            "\t\t\t       enum bpf_prog_type prog_type,",
            "\t\t\t       enum bpf_attach_type attach_type)",
            "{",
            "\tif (!token || prog_type >= __MAX_BPF_PROG_TYPE || attach_type >= __MAX_BPF_ATTACH_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn (token->allowed_progs & (1ULL << prog_type)) &&",
            "\t       (token->allowed_attachs & (1ULL << attach_type));",
            "}"
          ],
          "function_name": "bpf_token_allow_cmd, bpf_token_allow_map_type, bpf_token_allow_prog_type",
          "description": "提供对BPF命令、映射类型和程序类型的访问控制检查，通过位掩码匹配并结合安全模块验证权限。",
          "similarity": 0.5877698659896851
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/token.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "#include <linux/bpf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            ""
          ],
          "function_name": null,
          "description": "包含BPF令牌功能所需的各种内核头文件，如用户命名空间、安全策略、文件操作及BPF相关定义。",
          "similarity": 0.5185409784317017
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/token.c",
          "start_line": 12,
          "end_line": 195,
          "content": [
            "static bool bpf_ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable(ns, cap) || (cap != CAP_SYS_ADMIN && ns_capable(ns, CAP_SYS_ADMIN));",
            "}",
            "bool bpf_token_capable(const struct bpf_token *token, int cap)",
            "{",
            "\tstruct user_namespace *userns;",
            "",
            "\t/* BPF token allows ns_capable() level of capabilities */",
            "\tuserns = token ? token->userns : &init_user_ns;",
            "\tif (!bpf_ns_capable(userns, cap))",
            "\t\treturn false;",
            "\tif (token && security_bpf_token_capable(token, cap) < 0)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "void bpf_token_inc(struct bpf_token *token)",
            "{",
            "\tatomic64_inc(&token->refcnt);",
            "}",
            "static void bpf_token_free(struct bpf_token *token)",
            "{",
            "\tsecurity_bpf_token_free(token);",
            "\tput_user_ns(token->userns);",
            "\tkfree(token);",
            "}",
            "static void bpf_token_put_deferred(struct work_struct *work)",
            "{",
            "\tstruct bpf_token *token = container_of(work, struct bpf_token, work);",
            "",
            "\tbpf_token_free(token);",
            "}",
            "void bpf_token_put(struct bpf_token *token)",
            "{",
            "\tif (!token)",
            "\t\treturn;",
            "",
            "\tif (!atomic64_dec_and_test(&token->refcnt))",
            "\t\treturn;",
            "",
            "\tINIT_WORK(&token->work, bpf_token_put_deferred);",
            "\tschedule_work(&token->work);",
            "}",
            "static int bpf_token_release(struct inode *inode, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "",
            "\tbpf_token_put(token);",
            "\treturn 0;",
            "}",
            "static void bpf_token_show_fdinfo(struct seq_file *m, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "\tu64 mask;",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_CMD >= 64);",
            "\tmask = (1ULL << __MAX_BPF_CMD) - 1;",
            "\tif ((token->allowed_cmds & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_cmds:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_cmds:\\t0x%llx\\n\", token->allowed_cmds);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_MAP_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_MAP_TYPE) - 1;",
            "\tif ((token->allowed_maps & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_maps:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_maps:\\t0x%llx\\n\", token->allowed_maps);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_PROG_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_PROG_TYPE) - 1;",
            "\tif ((token->allowed_progs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_progs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_progs:\\t0x%llx\\n\", token->allowed_progs);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_ATTACH_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_ATTACH_TYPE) - 1;",
            "\tif ((token->allowed_attachs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_attachs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_attachs:\\t0x%llx\\n\", token->allowed_attachs);",
            "}",
            "int bpf_token_create(union bpf_attr *attr)",
            "{",
            "\tstruct bpf_mount_opts *mnt_opts;",
            "\tstruct bpf_token *token = NULL;",
            "\tstruct user_namespace *userns;",
            "\tstruct inode *inode;",
            "\tstruct file *file;",
            "\tCLASS(fd, f)(attr->token_create.bpffs_fd);",
            "\tstruct path path;",
            "\tstruct super_block *sb;",
            "\tumode_t mode;",
            "\tint err, fd;",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "",
            "\tpath = fd_file(f)->f_path;",
            "\tsb = path.dentry->d_sb;",
            "",
            "\tif (path.dentry != sb->s_root)",
            "\t\treturn -EINVAL;",
            "\tif (sb->s_op != &bpf_super_ops)",
            "\t\treturn -EINVAL;",
            "\terr = path_permission(&path, MAY_ACCESS);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tuserns = sb->s_user_ns;",
            "\t/*",
            "\t * Enforce that creators of BPF tokens are in the same user",
            "\t * namespace as the BPF FS instance. This makes reasoning about",
            "\t * permissions a lot easier and we can always relax this later.",
            "\t */",
            "\tif (current_user_ns() != userns)",
            "\t\treturn -EPERM;",
            "\tif (!ns_capable(userns, CAP_BPF))",
            "\t\treturn -EPERM;",
            "",
            "\t/* Creating BPF token in init_user_ns doesn't make much sense. */",
            "\tif (current_user_ns() == &init_user_ns)",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\tmnt_opts = sb->s_fs_info;",
            "\tif (mnt_opts->delegate_cmds == 0 &&",
            "\t    mnt_opts->delegate_maps == 0 &&",
            "\t    mnt_opts->delegate_progs == 0 &&",
            "\t    mnt_opts->delegate_attachs == 0)",
            "\t\treturn -ENOENT; /* no BPF token delegation is set up */",
            "",
            "\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());",
            "\tinode = bpf_get_inode(sb, NULL, mode);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = &bpf_token_iops;",
            "\tinode->i_fop = &bpf_token_fops;",
            "\tclear_nlink(inode); /* make sure it is unlinked */",
            "",
            "\tfile = alloc_file_pseudo(inode, path.mnt, BPF_TOKEN_INODE_NAME, O_RDWR, &bpf_token_fops);",
            "\tif (IS_ERR(file)) {",
            "\t\tiput(inode);",
            "\t\treturn PTR_ERR(file);",
            "\t}",
            "",
            "\ttoken = kzalloc(sizeof(*token), GFP_USER);",
            "\tif (!token) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto out_file;",
            "\t}",
            "",
            "\tatomic64_set(&token->refcnt, 1);",
            "",
            "\t/* remember bpffs owning userns for future ns_capable() checks */",
            "\ttoken->userns = get_user_ns(userns);",
            "",
            "\ttoken->allowed_cmds = mnt_opts->delegate_cmds;",
            "\ttoken->allowed_maps = mnt_opts->delegate_maps;",
            "\ttoken->allowed_progs = mnt_opts->delegate_progs;",
            "\ttoken->allowed_attachs = mnt_opts->delegate_attachs;",
            "",
            "\terr = security_bpf_token_create(token, attr, &path);",
            "\tif (err)",
            "\t\tgoto out_token;",
            "",
            "\tfd = get_unused_fd_flags(O_CLOEXEC);",
            "\tif (fd < 0) {",
            "\t\terr = fd;",
            "\t\tgoto out_token;",
            "\t}",
            "",
            "\tfile->private_data = token;",
            "\tfd_install(fd, file);",
            "",
            "\treturn fd;",
            "",
            "out_token:",
            "\tbpf_token_free(token);",
            "out_file:",
            "\tfput(file);",
            "\treturn err;",
            "}"
          ],
          "function_name": "bpf_ns_capable, bpf_token_capable, bpf_token_inc, bpf_token_free, bpf_token_put_deferred, bpf_token_put, bpf_token_release, bpf_token_show_fdinfo, bpf_token_create",
          "description": "实现BPF令牌的权限检查、引用计数管理、延迟释放及创建逻辑，包括基于挂载选项的令牌初始化和安全策略校验。",
          "similarity": 0.499388724565506
        }
      ]
    },
    {
      "source_file": "mm/memfd.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:40:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `memfd.c`\n\n---\n\n# memfd.c 技术文档\n\n## 1. 文件概述\n\n`memfd.c` 实现了 Linux 内核中的 `memfd_create()` 系统调用及其配套的文件密封（file sealing）机制。该文件最初是 `shmem.c` 的一部分，后被拆分出来以同时支持 tmpfs 和 hugetlbfs 文件系统。其核心功能包括：\n\n- 创建匿名内存文件（memfd），无需关联磁盘或文件系统路径\n- 提供文件密封（sealing）能力，允许对共享内存区域施加不可逆的操作限制\n- 支持普通页和大页（hugetlb）两种内存分配模式\n- 通过引用计数检测和等待机制确保密封操作的安全性\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|---------|\n| `memfd_alloc_folio()` | 为 memfd 文件分配 folio（页），支持普通页和大页模式 |\n| `memfd_wait_for_pins()` | 等待所有被外部引用（如 GUP、DMA）的 folio 释放，用于 SEAL_WRITE 密封前的安全检查 |\n| `memfd_tag_pins()` | 扫描地址空间，标记具有额外引用计数的 folio |\n| `memfd_add_seals()` | 向文件添加密封标志，实现不可逆的访问控制 |\n| `memfd_get_seals()` | 获取文件当前的密封标志 |\n| `memfd_fcntl()` | 处理 F_ADD_SEALS 和 F_GET_SEALS fcntl 命令 |\n\n### 关键数据结构和常量\n\n- **密封标志**：\n  - `F_SEAL_SEAL`：禁止进一步添加密封\n  - `F_SEAL_WRITE`：禁止写入\n  - `F_SEAL_GROW/SHRINK`：禁止文件增长/缩小\n  - `F_SEAL_EXEC`：禁止修改执行权限位\n  - `F_SEAL_FUTURE_WRITE`：禁止未来写入（与 EXEC 相关）\n\n- **memfd 标志**：\n  - `MFD_CLOEXEC`：close-on-exec\n  - `MFD_ALLOW_SEALING`：允许密封\n  - `MFD_HUGETLB`：使用大页\n  - `MFD_NOEXEC_SEAL` / `MFD_EXEC`：控制执行权限\n\n- **内部标记**：\n  - `MEMFD_TAG_PINNED`：复用 `PAGECACHE_TAG_TOWRITE` 标记被外部引用的 folio\n\n## 3. 关键实现\n\n### 文件密封机制\n\n密封是一种**单向、不可逆**的访问控制机制：\n- 密封只能添加，不能移除\n- 一旦设置 `F_SEAL_SEAL`，不能再添加任何密封\n- 密封作用于整个 inode，影响所有文件描述符\n\n### 引用计数检测算法\n\n为安全实现 `SEAL_WRITE`，内核需确保无外部引用：\n1. **标记阶段** (`memfd_tag_pins`)：\n   - 遍历 radix tree 中的所有 folio\n   - 对 `folio_ref_count() - folio_mapcount() != folio_nr_pages()` 的 folio 标记为 PINNED\n   - 表示存在非映射引用（如 GUP、DMA）\n\n2. **等待阶段** (`memfd_wait_for_pins`)：\n   - 最多进行 5 次扫描（LAST_SCAN = 4）\n   - 指数退避等待（(HZ << scan) / 200）\n   - 最后一次扫描清理标记并返回 `-EBUSY`（如有残留引用）\n\n### 大页支持\n\n通过条件编译支持 hugetlbfs：\n- 检测 `is_file_hugepages()` 判断是否大页模式\n- 使用 `htlb_alloc_mask()` 并清除 `__GFP_HIGHMEM | __GFP_MOVABLE`\n- 调用 hugetlb 专用分配和缓存接口\n\n### 执行权限密封\n\n`F_SEAL_EXEC` 具有特殊语义：\n- 若文件已有执行权限（`i_mode & 0111`），自动添加 `WRITE|GROW|SHRINK|FUTURE_WRITE` 密封\n- 实现 W^X（Write XOR Execute）安全策略\n\n## 4. 依赖关系\n\n### 内核模块依赖\n\n- **内存管理**：\n  - `<linux/mm.h>`：folio 操作、GFP 标志\n  - `<linux/pagemap.h>`：address_space、radix tree 操作\n  - `<linux/shmem_fs.h>`：tmpfs inode 结构（`SHMEM_I`）\n  \n- **文件系统**：\n  - `<linux/hugetlb.h>`：大页支持（`HUGETLBFS_I`）\n  - `<linux/fs.h>` / `<linux/vfs.h>`：VFS 层接口\n  \n- **同步机制**：\n  - `<linux/sched/signal.h>`：可杀等待（`schedule_timeout_killable`）\n  - XArray 锁（`xas_lock_irq`）保证并发安全\n\n### 复用设计\n\n- **标记复用**：使用 `PAGECACHE_TAG_TOWRITE` 作为 `MEMFD_TAG_PINNED`，因 tmpfs/hugetlbfs 不使用此标记\n- **代码共享**：同时服务 tmpfs 和 hugetlbfs，通过 `memfd_file_seals_ptr()` 抽象 inode 访问\n\n## 5. 使用场景\n\n### 用户态应用场景\n\n1. **安全共享内存**：\n   - 多进程通过 `memfd_create()` 创建共享内存\n   - 生产者添加 `SEAL_WRITE` 后传递 fd 给消费者，确保数据不可篡改\n\n2. **动态代码加载**：\n   - JIT 编译器创建可执行 memfd\n   - 写入代码后密封 `SEAL_WRITE`，防止后续修改（配合 `SEAL_EXEC`）\n\n3. **容器/沙箱**：\n   - 限制不受信任进程对共享内存的操作能力\n   - 通过密封防止恶意进程破坏共享状态\n\n### 内核内部使用\n\n1. **GUP（Get User Pages）集成**：\n   - `memfd_alloc_folio()` 被 `gup.c` 调用，处理 memfd 的缺页\n   - 确保 DMA/GUP 场景下密封的安全性\n\n2. **大页优化**：\n   - 通过 `MFD_HUGETLB` 标志创建大页 memfd\n   - 适用于需要大块连续内存的高性能场景（如 DPDK）\n\n3. **安全增强**：\n   - `sysctl_memfd_noexec` 控制默认执行权限\n   - 防止 memfd 被滥用于代码注入攻击",
      "similarity": 0.5864059925079346,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/memfd.c",
          "start_line": 275,
          "end_line": 320,
          "content": [
            "static int memfd_get_seals(struct file *file)",
            "{",
            "\tunsigned int *seals = memfd_file_seals_ptr(file);",
            "",
            "\treturn seals ? *seals : -EINVAL;",
            "}",
            "long memfd_fcntl(struct file *file, unsigned int cmd, unsigned int arg)",
            "{",
            "\tlong error;",
            "",
            "\tswitch (cmd) {",
            "\tcase F_ADD_SEALS:",
            "\t\terror = memfd_add_seals(file, arg);",
            "\t\tbreak;",
            "\tcase F_GET_SEALS:",
            "\t\terror = memfd_get_seals(file);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\terror = -EINVAL;",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn error;",
            "}",
            "static int check_sysctl_memfd_noexec(unsigned int *flags)",
            "{",
            "#ifdef CONFIG_SYSCTL",
            "\tstruct pid_namespace *ns = task_active_pid_ns(current);",
            "\tint sysctl = pidns_memfd_noexec_scope(ns);",
            "",
            "\tif (!(*flags & (MFD_EXEC | MFD_NOEXEC_SEAL))) {",
            "\t\tif (sysctl >= MEMFD_NOEXEC_SCOPE_NOEXEC_SEAL)",
            "\t\t\t*flags |= MFD_NOEXEC_SEAL;",
            "\t\telse",
            "\t\t\t*flags |= MFD_EXEC;",
            "\t}",
            "",
            "\tif (!(*flags & MFD_NOEXEC_SEAL) && sysctl >= MEMFD_NOEXEC_SCOPE_NOEXEC_ENFORCED) {",
            "\t\tpr_err_ratelimited(",
            "\t\t\t\"%s[%d]: memfd_create() requires MFD_NOEXEC_SEAL with vm.memfd_noexec=%d\\n\",",
            "\t\t\tcurrent->comm, task_pid_nr(current), sysctl);",
            "\t\treturn -EACCES;",
            "\t}",
            "#endif",
            "\treturn 0;",
            "}"
          ],
          "function_name": "memfd_get_seals, memfd_fcntl, check_sysctl_memfd_noexec",
          "description": "提供密封信息查询接口(memfd_get_seals)和fcntl命令处理(memfd_fcntl)，check_sysctl_memfd_noexec根据内核配置动态调整内存文件执行权限标志，强制应用noexec安全策略。",
          "similarity": 0.6114012598991394
        },
        {
          "chunk_id": 1,
          "file_path": "mm/memfd.c",
          "start_line": 32,
          "end_line": 194,
          "content": [
            "static bool memfd_folio_has_extra_refs(struct folio *folio)",
            "{",
            "\treturn folio_ref_count(folio) - folio_mapcount(folio) !=",
            "\t       folio_nr_pages(folio);",
            "}",
            "static void memfd_tag_pins(struct xa_state *xas)",
            "{",
            "\tstruct folio *folio;",
            "\tint latency = 0;",
            "",
            "\tlru_add_drain();",
            "",
            "\txas_lock_irq(xas);",
            "\txas_for_each(xas, folio, ULONG_MAX) {",
            "\t\tif (!xa_is_value(folio) && memfd_folio_has_extra_refs(folio))",
            "\t\t\txas_set_mark(xas, MEMFD_TAG_PINNED);",
            "",
            "\t\tif (++latency < XA_CHECK_SCHED)",
            "\t\t\tcontinue;",
            "\t\tlatency = 0;",
            "",
            "\t\txas_pause(xas);",
            "\t\txas_unlock_irq(xas);",
            "\t\tcond_resched();",
            "\t\txas_lock_irq(xas);",
            "\t}",
            "\txas_unlock_irq(xas);",
            "}",
            "static int memfd_wait_for_pins(struct address_space *mapping)",
            "{",
            "\tXA_STATE(xas, &mapping->i_pages, 0);",
            "\tstruct folio *folio;",
            "\tint error, scan;",
            "",
            "\tmemfd_tag_pins(&xas);",
            "",
            "\terror = 0;",
            "\tfor (scan = 0; scan <= LAST_SCAN; scan++) {",
            "\t\tint latency = 0;",
            "",
            "\t\tif (!xas_marked(&xas, MEMFD_TAG_PINNED))",
            "\t\t\tbreak;",
            "",
            "\t\tif (!scan)",
            "\t\t\tlru_add_drain_all();",
            "\t\telse if (schedule_timeout_killable((HZ << scan) / 200))",
            "\t\t\tscan = LAST_SCAN;",
            "",
            "\t\txas_set(&xas, 0);",
            "\t\txas_lock_irq(&xas);",
            "\t\txas_for_each_marked(&xas, folio, ULONG_MAX, MEMFD_TAG_PINNED) {",
            "\t\t\tbool clear = true;",
            "",
            "\t\t\tif (!xa_is_value(folio) &&",
            "\t\t\t    memfd_folio_has_extra_refs(folio)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * On the last scan, we clean up all those tags",
            "\t\t\t\t * we inserted; but make a note that we still",
            "\t\t\t\t * found folios pinned.",
            "\t\t\t\t */",
            "\t\t\t\tif (scan == LAST_SCAN)",
            "\t\t\t\t\terror = -EBUSY;",
            "\t\t\t\telse",
            "\t\t\t\t\tclear = false;",
            "\t\t\t}",
            "\t\t\tif (clear)",
            "\t\t\t\txas_clear_mark(&xas, MEMFD_TAG_PINNED);",
            "",
            "\t\t\tif (++latency < XA_CHECK_SCHED)",
            "\t\t\t\tcontinue;",
            "\t\t\tlatency = 0;",
            "",
            "\t\t\txas_pause(&xas);",
            "\t\t\txas_unlock_irq(&xas);",
            "\t\t\tcond_resched();",
            "\t\t\txas_lock_irq(&xas);",
            "\t\t}",
            "\t\txas_unlock_irq(&xas);",
            "\t}",
            "",
            "\treturn error;",
            "}",
            "static int memfd_add_seals(struct file *file, unsigned int seals)",
            "{",
            "\tstruct inode *inode = file_inode(file);",
            "\tunsigned int *file_seals;",
            "\tint error;",
            "",
            "\t/*",
            "\t * SEALING",
            "\t * Sealing allows multiple parties to share a tmpfs or hugetlbfs file",
            "\t * but restrict access to a specific subset of file operations. Seals",
            "\t * can only be added, but never removed. This way, mutually untrusted",
            "\t * parties can share common memory regions with a well-defined policy.",
            "\t * A malicious peer can thus never perform unwanted operations on a",
            "\t * shared object.",
            "\t *",
            "\t * Seals are only supported on special tmpfs or hugetlbfs files and",
            "\t * always affect the whole underlying inode. Once a seal is set, it",
            "\t * may prevent some kinds of access to the file. Currently, the",
            "\t * following seals are defined:",
            "\t *   SEAL_SEAL: Prevent further seals from being set on this file",
            "\t *   SEAL_SHRINK: Prevent the file from shrinking",
            "\t *   SEAL_GROW: Prevent the file from growing",
            "\t *   SEAL_WRITE: Prevent write access to the file",
            "\t *   SEAL_EXEC: Prevent modification of the exec bits in the file mode",
            "\t *",
            "\t * As we don't require any trust relationship between two parties, we",
            "\t * must prevent seals from being removed. Therefore, sealing a file",
            "\t * only adds a given set of seals to the file, it never touches",
            "\t * existing seals. Furthermore, the \"setting seals\"-operation can be",
            "\t * sealed itself, which basically prevents any further seal from being",
            "\t * added.",
            "\t *",
            "\t * Semantics of sealing are only defined on volatile files. Only",
            "\t * anonymous tmpfs and hugetlbfs files support sealing. More",
            "\t * importantly, seals are never written to disk. Therefore, there's",
            "\t * no plan to support it on other file types.",
            "\t */",
            "",
            "\tif (!(file->f_mode & FMODE_WRITE))",
            "\t\treturn -EPERM;",
            "\tif (seals & ~(unsigned int)F_ALL_SEALS)",
            "\t\treturn -EINVAL;",
            "",
            "\tinode_lock(inode);",
            "",
            "\tfile_seals = memfd_file_seals_ptr(file);",
            "\tif (!file_seals) {",
            "\t\terror = -EINVAL;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\tif (*file_seals & F_SEAL_SEAL) {",
            "\t\terror = -EPERM;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\tif ((seals & F_SEAL_WRITE) && !(*file_seals & F_SEAL_WRITE)) {",
            "\t\terror = mapping_deny_writable(file->f_mapping);",
            "\t\tif (error)",
            "\t\t\tgoto unlock;",
            "",
            "\t\terror = memfd_wait_for_pins(file->f_mapping);",
            "\t\tif (error) {",
            "\t\t\tmapping_allow_writable(file->f_mapping);",
            "\t\t\tgoto unlock;",
            "\t\t}",
            "\t}",
            "",
            "\t/*",
            "\t * SEAL_EXEC implys SEAL_WRITE, making W^X from the start.",
            "\t */",
            "\tif (seals & F_SEAL_EXEC && inode->i_mode & 0111)",
            "\t\tseals |= F_SEAL_SHRINK|F_SEAL_GROW|F_SEAL_WRITE|F_SEAL_FUTURE_WRITE;",
            "",
            "\t*file_seals |= seals;",
            "\terror = 0;",
            "",
            "unlock:",
            "\tinode_unlock(inode);",
            "\treturn error;",
            "}"
          ],
          "function_name": "memfd_folio_has_extra_refs, memfd_tag_pins, memfd_wait_for_pins, memfd_add_seals",
          "description": "实现内存文件的页引用追踪与密封逻辑，memfd_tag_pins遍历页表标记额外引用页，memfd_wait_for_pins等待所有引用释放后清除标记，memfd_add_seals处理文件密封标志验证及权限限制设置。",
          "similarity": 0.5880178213119507
        },
        {
          "chunk_id": 0,
          "file_path": "mm/memfd.c",
          "start_line": 1,
          "end_line": 31,
          "content": [
            "/*",
            " * memfd_create system call and file sealing support",
            " *",
            " * Code was originally included in shmem.c, and broken out to facilitate",
            " * use by hugetlbfs as well as tmpfs.",
            " *",
            " * This file is released under the GPL.",
            " */",
            "",
            "#include <linux/fs.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/memfd.h>",
            "#include <linux/pid_namespace.h>",
            "#include <uapi/linux/memfd.h>",
            "",
            "/*",
            " * We need a tag: a new tag would expand every xa_node by 8 bytes,",
            " * so reuse a tag which we firmly believe is never set or cleared on tmpfs",
            " * or hugetlbfs because they are memory only filesystems.",
            " */",
            "#define MEMFD_TAG_PINNED        PAGECACHE_TAG_TOWRITE",
            "#define LAST_SCAN               4       /* about 150ms max */",
            ""
          ],
          "function_name": null,
          "description": "定义MEMFD_TAG_PINNED宏用于标识内存文件的特殊页缓存标记，通过复用tmpfs和hugetlbfs中未使用的PAGECACHE_TAG_TOWRITE标签，为后续内存文件的页管理提供标记支持。",
          "similarity": 0.47409552335739136
        }
      ]
    },
    {
      "source_file": "mm/secretmem.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:16:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `secretmem.c`\n\n---\n\n# secretmem.c 技术文档\n\n## 1. 文件概述\n\n`secretmem.c` 实现了 Linux 内核中的 **Secret Memory（秘密内存）** 功能，提供了一种安全的、不可交换（non-swappable）、不可转储（non-dumpable）且对内核页表隐藏的匿名内存区域。该功能通过新增系统调用 `memfd_secret(2)` 暴露给用户空间，用于创建具有特殊安全属性的内存文件描述符。此类内存主要用于存储敏感数据（如加密密钥），防止其被意外泄露到 swap、core dump 或通过 `/proc/pid/maps` 被探测。\n\n## 2. 核心功能\n\n### 主要函数\n- `memfd_secret(unsigned int flags)`：系统调用入口，创建 secret memory 文件描述符。\n- `secretmem_fault(struct vm_fault *vmf)`：处理缺页异常，按需分配并锁定秘密内存页。\n- `secretmem_mmap(struct file *file, struct vm_area_struct *vma)`：设置 VMA 属性，启用 `VM_LOCKED | VM_DONTDUMP` 并绑定 fault handler。\n- `secretmem_release(struct inode *inode, struct file *file)`：释放文件时减少用户计数。\n- `secretmem_file_create(unsigned long flags)`：创建基于伪文件系统的 secret memory 文件对象。\n- `secretmem_init(void)`：模块初始化，挂载 secretmem 伪文件系统。\n\n### 关键数据结构\n- `secretmem_fops`：文件操作结构体，定义 `.mmap` 和 `.release` 方法。\n- `secretmem_vm_ops`：VMA 操作结构体，仅实现 `.fault` 回调。\n- `secretmem_aops`：地址空间操作结构体，包含：\n  - `.free_folio`：释放页面前恢复直接映射并清零。\n  - `.migrate_folio`：返回 `-EBUSY` 禁止迁移。\n  - `.dirty_folio`：空操作（`noop_dirty_folio`），禁止脏页标记。\n- `secretmem_iops`：inode 操作结构体，限制文件大小不可修改（除初始为 0 外）。\n\n### 全局变量\n- `secretmem_enable`：模块参数，控制是否启用 secretmem 功能（默认启用）。\n- `secretmem_users`：原子计数器，跟踪当前活跃的 secret memory 用户数量。\n- `secretmem_mnt`：指向 secretmem 伪文件系统的内核挂载点。\n\n## 3. 关键实现\n\n### 内存安全性保障\n- **直接映射移除**：在 `secretmem_fault()` 中分配新页后，调用 `set_direct_map_invalid_noflush()` 将该物理页从内核直接映射区（direct map）中移除，使内核无法通过常规线性地址访问该页内容，增强对抗内核漏洞利用的能力。\n- **页面清零与恢复**：在 `secretmem_free_folio()` 中，先调用 `set_direct_map_default_noflush()` 恢复直接映射，再使用 `folio_zero_segment()` 安全清零页面内容，防止敏感数据残留。\n- **TLB 刷新**：分配新页并修改直接映射后，调用 `flush_tlb_kernel_range()` 刷新内核 TLB，确保 CPU 不再缓存旧映射。\n\n### 内存管理特性\n- **不可交换 & 不可回收**：通过 `mapping_set_unevictable()` 标记 address_space 为不可驱逐，确保页面不会被 swap 出或被内存回收机制回收。\n- **禁止迁移**：`.migrate_folio` 返回 `-EBUSY`，阻止 CMA、内存热插拔等场景下的页面迁移。\n- **禁止写脏**：使用 `noop_dirty_folio` 防止页面被标记为 dirty，避免写回行为。\n- **强制锁定**：`secretmem_mmap()` 强制设置 `VM_LOCKED`，结合 `mlock_future_ok()` 检查，确保内存常驻物理 RAM。\n\n### 文件系统与权限控制\n- 基于 `anon_inode` 构建伪文件系统（magic: `SECRETMEM_MAGIC`），挂载时设置 `MNT_NOEXEC` 禁止执行。\n- 文件大小只能为 0，`setattr` 操作拒绝任何非零的 `ATTR_SIZE` 修改。\n- 文件描述符默认具有 `O_RDWR` 权限，但实际 I/O 通过 mmap 访问。\n\n### 系统调用验证\n- 仅当 `secretmem_enable=1` 且平台支持 `can_set_direct_map()`（如 x86 的 `set_memory_valid()`）时才启用。\n- 参数 `flags` 必须为 `O_CLOEXEC` 或 0，其他位均视为非法。\n\n## 4. 依赖关系\n\n- **架构支持**：依赖 `asm/tlbflush.h` 和 `set_memory.h` 提供的 `set_direct_map_*` 及 TLB 刷新接口，目前主要在 x86 上实现。\n- **内存管理子系统**：重度依赖 `mm/` 下的 `filemap`、`folio`、`mlock`、`swap` 等机制。\n- **VFS 层**：使用 `pseudo_fs.h` 和 `anon_inode` 基础设施创建安全 inode。\n- **UAPI**：通过 `uapi/linux/magic.h` 定义文件系统 magic number。\n- **模块参数**：使用 `module_param_named` 提供运行时开关。\n\n## 5. 使用场景\n\n- **敏感数据保护**：应用程序（如加密库、密钥管理服务）可使用 `memfd_secret()` 创建内存区域存储私钥、会话密钥等，防止其出现在 swap 分区或 core dump 文件中。\n- **安全隔离**：由于页面从内核直接映射中移除，即使内核存在任意地址读取漏洞，攻击者也难以直接定位和提取 secret memory 中的数据。\n- **高性能安全内存**：相比传统 `mlock()` + `mmap()` 方案，secret memory 提供更严格的访问控制和自动清零机制，适用于对安全性要求极高的场景。\n- **容器与虚拟化**：可在容器或 VM 中为可信应用提供受保护的内存空间，降低侧信道攻击风险。",
      "similarity": 0.5652583241462708,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/secretmem.c",
          "start_line": 262,
          "end_line": 279,
          "content": [
            "static int secretmem_init_fs_context(struct fs_context *fc)",
            "{",
            "\treturn init_pseudo(fc, SECRETMEM_MAGIC) ? 0 : -ENOMEM;",
            "}",
            "static int __init secretmem_init(void)",
            "{",
            "\tif (!secretmem_enable || !can_set_direct_map())",
            "\t\treturn 0;",
            "",
            "\tsecretmem_mnt = kern_mount(&secretmem_fs);",
            "\tif (IS_ERR(secretmem_mnt))",
            "\t\treturn PTR_ERR(secretmem_mnt);",
            "",
            "\t/* prevent secretmem mappings from ever getting PROT_EXEC */",
            "\tsecretmem_mnt->mnt_flags |= MNT_NOEXEC;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "secretmem_init_fs_context, secretmem_init",
          "description": "初始化secretmem伪文件系统，通过kern_mount创建挂载点并设置MNT_NOEXEC标志，防止秘密内存区域被赋予执行权限",
          "similarity": 0.6401456594467163
        },
        {
          "chunk_id": 1,
          "file_path": "mm/secretmem.c",
          "start_line": 45,
          "end_line": 163,
          "content": [
            "bool secretmem_active(void)",
            "{",
            "\treturn !!atomic_read(&secretmem_users);",
            "}",
            "static vm_fault_t secretmem_fault(struct vm_fault *vmf)",
            "{",
            "\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;",
            "\tstruct inode *inode = file_inode(vmf->vma->vm_file);",
            "\tpgoff_t offset = vmf->pgoff;",
            "\tgfp_t gfp = vmf->gfp_mask;",
            "\tunsigned long addr;",
            "\tstruct page *page;",
            "\tstruct folio *folio;",
            "\tvm_fault_t ret;",
            "\tint err;",
            "",
            "\tif (((loff_t)vmf->pgoff << PAGE_SHIFT) >= i_size_read(inode))",
            "\t\treturn vmf_error(-EINVAL);",
            "",
            "\tfilemap_invalidate_lock_shared(mapping);",
            "",
            "retry:",
            "\tpage = find_lock_page(mapping, offset);",
            "\tif (!page) {",
            "\t\tfolio = folio_alloc(gfp | __GFP_ZERO, 0);",
            "\t\tif (!folio) {",
            "\t\t\tret = VM_FAULT_OOM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tpage = &folio->page;",
            "\t\terr = set_direct_map_invalid_noflush(page);",
            "\t\tif (err) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\tret = vmf_error(err);",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\t__folio_mark_uptodate(folio);",
            "\t\terr = filemap_add_folio(mapping, folio, offset, gfp);",
            "\t\tif (unlikely(err)) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\t/*",
            "\t\t\t * If a split of large page was required, it",
            "\t\t\t * already happened when we marked the page invalid",
            "\t\t\t * which guarantees that this call won't fail",
            "\t\t\t */",
            "\t\t\tset_direct_map_default_noflush(page);",
            "\t\t\tif (err == -EEXIST)",
            "\t\t\t\tgoto retry;",
            "",
            "\t\t\tret = vmf_error(err);",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\taddr = (unsigned long)page_address(page);",
            "\t\tflush_tlb_kernel_range(addr, addr + PAGE_SIZE);",
            "\t}",
            "",
            "\tvmf->page = page;",
            "\tret = VM_FAULT_LOCKED;",
            "",
            "out:",
            "\tfilemap_invalidate_unlock_shared(mapping);",
            "\treturn ret;",
            "}",
            "static int secretmem_release(struct inode *inode, struct file *file)",
            "{",
            "\tatomic_dec(&secretmem_users);",
            "\treturn 0;",
            "}",
            "static int secretmem_mmap(struct file *file, struct vm_area_struct *vma)",
            "{",
            "\tunsigned long len = vma->vm_end - vma->vm_start;",
            "",
            "\tif ((vma->vm_flags & (VM_SHARED | VM_MAYSHARE)) == 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (!mlock_future_ok(vma->vm_mm, vma->vm_flags | VM_LOCKED, len))",
            "\t\treturn -EAGAIN;",
            "",
            "\tvm_flags_set(vma, VM_LOCKED | VM_DONTDUMP);",
            "\tvma->vm_ops = &secretmem_vm_ops;",
            "",
            "\treturn 0;",
            "}",
            "bool vma_is_secretmem(struct vm_area_struct *vma)",
            "{",
            "\treturn vma->vm_ops == &secretmem_vm_ops;",
            "}",
            "static int secretmem_migrate_folio(struct address_space *mapping,",
            "\t\tstruct folio *dst, struct folio *src, enum migrate_mode mode)",
            "{",
            "\treturn -EBUSY;",
            "}",
            "static void secretmem_free_folio(struct folio *folio)",
            "{",
            "\tset_direct_map_default_noflush(&folio->page);",
            "\tfolio_zero_segment(folio, 0, folio_size(folio));",
            "}",
            "static int secretmem_setattr(struct mnt_idmap *idmap,",
            "\t\t\t     struct dentry *dentry, struct iattr *iattr)",
            "{",
            "\tstruct inode *inode = d_inode(dentry);",
            "\tstruct address_space *mapping = inode->i_mapping;",
            "\tunsigned int ia_valid = iattr->ia_valid;",
            "\tint ret;",
            "",
            "\tfilemap_invalidate_lock(mapping);",
            "",
            "\tif ((ia_valid & ATTR_SIZE) && inode->i_size)",
            "\t\tret = -EINVAL;",
            "\telse",
            "\t\tret = simple_setattr(idmap, dentry, iattr);",
            "",
            "\tfilemap_invalidate_unlock(mapping);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "secretmem_active, secretmem_fault, secretmem_release, secretmem_mmap, vma_is_secretmem, secretmem_migrate_folio, secretmem_free_folio, secretmem_setattr",
          "description": "实现secretmem核心功能，包括检查是否启用、处理页面故障时分配并标记不可执行页面、管理VMA标志、验证文件属性等内存加密相关操作",
          "similarity": 0.5876941680908203
        },
        {
          "chunk_id": 0,
          "file_path": "mm/secretmem.c",
          "start_line": 1,
          "end_line": 44,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright IBM Corporation, 2021",
            " *",
            " * Author: Mike Rapoport <rppt@linux.ibm.com>",
            " */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/memfd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/printk.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/sched/signal.h>",
            "",
            "#include <uapi/linux/magic.h>",
            "",
            "#include <asm/tlbflush.h>",
            "",
            "#include \"internal.h\"",
            "",
            "#undef pr_fmt",
            "#define pr_fmt(fmt) \"secretmem: \" fmt",
            "",
            "/*",
            " * Define mode and flag masks to allow validation of the system call",
            " * parameters.",
            " */",
            "#define SECRETMEM_MODE_MASK\t(0x0)",
            "#define SECRETMEM_FLAGS_MASK\tSECRETMEM_MODE_MASK",
            "",
            "static bool secretmem_enable __ro_after_init = 1;",
            "module_param_named(enable, secretmem_enable, bool, 0400);",
            "MODULE_PARM_DESC(secretmem_enable,",
            "\t\t \"Enable secretmem and memfd_secret(2) system call\");",
            "",
            "static atomic_t secretmem_users;",
            ""
          ],
          "function_name": null,
          "description": "定义secretmem模块的许可证和基本包含头文件，声明全局变量secretmem_enable用于控制功能启用状态，并注册模块参数供外部配置",
          "similarity": 0.5467662215232849
        }
      ]
    }
  ]
}