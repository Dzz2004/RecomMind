{
  "query": "模块加载时的符号版本校验",
  "timestamp": "2025-12-26 01:28:21",
  "retrieved_files": [
    {
      "source_file": "kernel/module/version.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:10:07\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\version.c`\n\n---\n\n# module/version.c 技术文档\n\n## 1. 文件概述\n\n`module/version.c` 是 Linux 内核模块子系统中负责模块版本校验的核心实现文件。该文件提供了模块加载过程中符号版本（symbol versioning）的检查机制，用于确保加载的模块与其依赖的内核或其他模块在接口层面保持兼容性。通过 CRC 校验码比对，防止因内核结构体或函数接口变更导致的模块不兼容问题，从而提升系统稳定性。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`check_version()`**  \n  检查模块中某个符号的版本 CRC 是否与当前内核中导出的符号 CRC 一致。\n\n- **`check_modstruct_version()`**  \n  专门用于校验 `module_layout` 符号的版本一致性，该符号代表模块布局结构的 ABI。\n\n- **`same_magic()`**  \n  比较两个模块魔数（magic string）是否相同，支持忽略内核版本前缀（当模块包含 CRC 时）。\n\n- **`module_layout()`**  \n  一个空实现的占位函数，其符号被导出，用于生成模块布局的版本签名。\n\n### 关键数据结构\n\n- **`struct modversion_info`**  \n  存储符号名称及其对应的 CRC 校验值，用于版本比对。\n\n- **`struct load_info`**  \n  模块加载过程中的元数据结构，包含 ELF 节头、版本节索引等信息。\n\n## 3. 关键实现\n\n### 符号版本校验机制\n\n- `check_version()` 函数从模块的 `.modver` 节（由 `versindex` 指定）中读取 `modversion_info` 数组。\n- 遍历该数组，查找与目标符号名 `symname` 匹配的条目。\n- 若找到且 CRC 值匹配，则返回 1（校验通过）；否则打印警告并返回 0（校验失败）。\n- 若模块未提供 CRC（`crc == NULL`），视为已污染（tainted），直接放行。\n- 若模块无版本节（`versindex == 0`），则调用 `try_to_force_load()` 允许强制加载（如 `modprobe --force`）。\n\n### `module_layout` 特殊处理\n\n- `check_modstruct_version()` 通过 `find_symbol()` 查找内核中名为 `\"module_layout\"` 的符号。\n- 该符号代表模块内存布局的 ABI，其变化意味着模块结构不兼容。\n- 使用 `preempt_disable()` 避免调度（因内核符号不可卸载，无需锁，仅用于满足 lockdep 检查）。\n\n### 魔数比较逻辑\n\n- `same_magic()` 在模块包含 CRC 时，跳过魔数字符串开头的内核版本部分（通过 `strcspn(..., \" \")` 定位空格后内容），仅比较后续 ABI 标识部分。\n- 此设计允许不同内核版本但相同 ABI 的模块兼容加载。\n\n### `module_layout()` 的作用\n\n- 该函数本身无实现，但其符号被 `EXPORT_SYMBOL` 导出。\n- 链接时，`genksyms` 工具会根据其参数类型（`struct module`, `modversion_info` 等）生成唯一的 CRC。\n- 该 CRC 反映了关键内核数据结构的布局，任何结构变更都会导致 CRC 变化，从而触发版本不匹配。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/module.h>`：提供模块核心 API 和数据结构。\n  - `<linux/string.h>`：使用 `strcmp`、`strcspn` 等字符串函数。\n  - `<linux/printk.h>`：使用 `pr_debug`、`pr_warn` 等日志接口。\n  - `\"internal.h\"`：包含模块子系统内部实现细节（如 `find_symbol`、`try_to_force_load` 等）。\n\n- **功能依赖**：\n  - 依赖内核符号表（`find_symbol`）查询 `module_layout`。\n  - 依赖模块加载流程中解析的 ELF 节信息（`load_info::sechdrs`）。\n  - 与 `scripts/genksyms/` 工具链协同工作，生成符号 CRC。\n\n## 5. 使用场景\n\n- **模块正常加载**：  \n  内核在解析模块依赖时，对每个外部符号调用 `check_version()`，确保 CRC 一致。\n\n- **强制加载模块（`modprobe --force`）**：  \n  当模块无版本信息（`versindex == 0`）时，调用 `try_to_force_load()` 允许加载，但系统会被标记为 tainted。\n\n- **内核升级后模块兼容性检查**：  \n  若内核关键结构（如 `struct module`）发生变化，`module_layout` 的 CRC 将不同，阻止旧模块加载。\n\n- **开发调试**：  \n  开发者可通过 `pr_debug` 输出查看 CRC 不匹配详情，辅助定位 ABI 不兼容问题。\n\n- **模块签名与安全加载**：  \n  版本校验是模块安全加载的前提，防止因结构错位导致内存破坏。",
      "similarity": 0.722039520740509,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/version.c",
          "start_line": 13,
          "end_line": 92,
          "content": [
            "int check_version(const struct load_info *info,",
            "\t\t  const char *symname,",
            "\t\t\t struct module *mod,",
            "\t\t\t const s32 *crc)",
            "{",
            "\tElf_Shdr *sechdrs = info->sechdrs;",
            "\tunsigned int versindex = info->index.vers;",
            "\tunsigned int i, num_versions;",
            "\tstruct modversion_info *versions;",
            "",
            "\t/* Exporting module didn't supply crcs?  OK, we're already tainted. */",
            "\tif (!crc)",
            "\t\treturn 1;",
            "",
            "\t/* No versions at all?  modprobe --force does this. */",
            "\tif (versindex == 0)",
            "\t\treturn try_to_force_load(mod, symname) == 0;",
            "",
            "\tversions = (void *)sechdrs[versindex].sh_addr;",
            "\tnum_versions = sechdrs[versindex].sh_size",
            "\t\t/ sizeof(struct modversion_info);",
            "",
            "\tfor (i = 0; i < num_versions; i++) {",
            "\t\tu32 crcval;",
            "",
            "\t\tif (strcmp(versions[i].name, symname) != 0)",
            "\t\t\tcontinue;",
            "",
            "\t\tcrcval = *crc;",
            "\t\tif (versions[i].crc == crcval)",
            "\t\t\treturn 1;",
            "\t\tpr_debug(\"Found checksum %X vs module %lX\\n\",",
            "\t\t\t crcval, versions[i].crc);",
            "\t\tgoto bad_version;",
            "\t}",
            "",
            "\t/* Broken toolchain. Warn once, then let it go.. */",
            "\tpr_warn_once(\"%s: no symbol version for %s\\n\", info->name, symname);",
            "\treturn 1;",
            "",
            "bad_version:",
            "\tpr_warn(\"%s: disagrees about version of symbol %s\\n\", info->name, symname);",
            "\treturn 0;",
            "}",
            "int check_modstruct_version(const struct load_info *info,",
            "\t\t\t    struct module *mod)",
            "{",
            "\tstruct find_symbol_arg fsa = {",
            "\t\t.name\t= \"module_layout\",",
            "\t\t.gplok\t= true,",
            "\t};",
            "",
            "\t/*",
            "\t * Since this should be found in kernel (which can't be removed), no",
            "\t * locking is necessary -- use preempt_disable() to placate lockdep.",
            "\t */",
            "\tpreempt_disable();",
            "\tif (!find_symbol(&fsa)) {",
            "\t\tpreempt_enable();",
            "\t\tBUG();",
            "\t}",
            "\tpreempt_enable();",
            "\treturn check_version(info, \"module_layout\", mod, fsa.crc);",
            "}",
            "int same_magic(const char *amagic, const char *bmagic,",
            "\t       bool has_crcs)",
            "{",
            "\tif (has_crcs) {",
            "\t\tamagic += strcspn(amagic, \" \");",
            "\t\tbmagic += strcspn(bmagic, \" \");",
            "\t}",
            "\treturn strcmp(amagic, bmagic) == 0;",
            "}",
            "void module_layout(struct module *mod,",
            "\t\t   struct modversion_info *ver,",
            "\t\t   struct kernel_param *kp,",
            "\t\t   struct kernel_symbol *ks,",
            "\t\t   struct tracepoint * const *tp)",
            "{",
            "}"
          ],
          "function_name": "check_version, check_modstruct_version, same_magic, module_layout",
          "description": "实现模块符号版本校验逻辑，check_version验证符号CRC一致性，check_modstruct_version检查模块布局版本，same_magic对比魔术字符串，module_layout作为预留接口当前为空实现。",
          "similarity": 0.7035435438156128
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/version.c",
          "start_line": 1,
          "end_line": 12,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Module version support",
            " *",
            " * Copyright (C) 2008 Rusty Russell",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/printk.h>",
            "#include \"internal.h\"",
            ""
          ],
          "function_name": null,
          "description": "定义模块版本支持的实现文件，包含许可证声明及核心头文件导入，提供模块版本校验所需的基础结构和内部接口定义。",
          "similarity": 0.6661949753761292
        }
      ]
    },
    {
      "source_file": "kernel/module_signature.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:10:38\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module_signature.c`\n\n---\n\n# module_signature.c 技术文档\n\n## 1. 文件概述\n\n`module_signature.c` 是 Linux 内核中用于验证内核模块数字签名有效性的核心组件。该文件实现了对附加在模块末尾的 PKCS#7 格式签名的初步格式校验逻辑，确保加载的模块签名结构合法且符合内核预期的安全要求。此功能是内核模块签名验证机制的第一道防线，用于防止加载格式错误或使用非预期签名算法的模块。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`mod_check_sig`**  \n  函数原型：  \n  ```c\n  int mod_check_sig(const struct module_signature *ms, size_t file_len, const char *name)\n  ```  \n  功能：验证模块签名结构的合法性，包括签名长度、签名类型及保留字段是否符合预期。\n\n### 关键数据结构\n\n- **`struct module_signature`**  \n  定义在 `<linux/module_signature.h>` 中，描述附加在模块文件末尾的签名元数据结构，包含签名长度、标识类型、算法、哈希方式、签名人长度、密钥 ID 长度及填充字段等。\n\n## 3. 关键实现\n\n- **签名长度校验**：  \n  使用 `be32_to_cpu(ms->sig_len)` 将大端序存储的签名长度转换为主机字节序，并验证其不超过模块文件总长度减去签名结构本身的大小，防止缓冲区越界。\n\n- **签名类型强制约束**：  \n  仅接受 `PKEY_ID_PKCS7` 类型的签名，这是内核模块签名的标准格式。若使用其他签名类型（如 X.509 直接签名），则拒绝加载并返回 `-ENOPKG`。\n\n- **保留字段清零检查**：  \n  对于 PKCS#7 签名，`algo`、`hash`、`signer_len`、`key_id_len` 及三个填充字节 `__pad` 必须为零。这是因为 PKCS#7 本身已包含完整的算法和身份信息，无需在签名头中重复指定。任何非零值均视为格式错误，返回 `-EBADMSG`。\n\n- **错误报告机制**：  \n  使用 `pr_err()` 输出带上下文名称（如模块文件名）的详细错误信息，便于调试和审计。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/errno.h>`：提供标准错误码（如 `-EBADMSG`, `-ENOPKG`）\n  - `<linux/printk.h>`：提供内核日志输出接口 `pr_err()`\n  - `<linux/module_signature.h>`：定义 `struct module_signature` 结构体\n  - `<asm/byteorder.h>`：提供字节序转换函数 `be32_to_cpu()`\n\n- **内核子系统依赖**：\n  - **模块加载子系统（module loader）**：在模块加载流程中调用此函数进行签名预检\n  - **密钥管理子系统（KEYS）**：后续的 PKCS#7 签名验证由 KEYS 子系统完成，本文件仅做格式检查\n\n## 5. 使用场景\n\n- **内核模块加载时的安全校验**：  \n  当用户通过 `insmod`、`modprobe` 等命令加载内核模块时，内核模块加载器会读取模块文件末尾的签名数据，并调用 `mod_check_sig()` 进行初步格式验证。只有通过此检查的模块才会进入后续的 PKCS#7 签名验证阶段。\n\n- **启用模块签名强制策略时的关键环节**：  \n  在配置了 `CONFIG_MODULE_SIG_FORCE=y` 的系统中，所有模块必须带有有效签名。`mod_check_sig()` 作为签名验证链的第一步，确保签名结构本身合法，防止恶意构造的签名数据绕过安全检查。\n\n- **内核自保护机制的一部分**：  \n  该文件与内核完整性子系统（如 IMA）协同工作，共同保障运行时内核代码的完整性与可信性。",
      "similarity": 0.6123876571655273,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/module_signature.c",
          "start_line": 1,
          "end_line": 20,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * Module signature checker",
            " *",
            " * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.",
            " * Written by David Howells (dhowells@redhat.com)",
            " */",
            "",
            "#include <linux/errno.h>",
            "#include <linux/printk.h>",
            "#include <linux/module_signature.h>",
            "#include <asm/byteorder.h>",
            "",
            "/**",
            " * mod_check_sig - check that the given signature is sane",
            " *",
            " * @ms:\t\tSignature to check.",
            " * @file_len:\tSize of the file to which @ms is appended.",
            " * @name:\tWhat is being checked. Used for error messages.",
            " */"
          ],
          "function_name": null,
          "description": "定义模块签名检查函数mod_check_sig的原型，用于验证模块签名结构有效性，包含签名长度检查、算法标识符类型校验及字段初始化状态检测，但尚未包含完整实现逻辑",
          "similarity": 0.630866289138794
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module_signature.c",
          "start_line": 21,
          "end_line": 46,
          "content": [
            "int mod_check_sig(const struct module_signature *ms, size_t file_len,",
            "\t\t  const char *name)",
            "{",
            "\tif (be32_to_cpu(ms->sig_len) >= file_len - sizeof(*ms))",
            "\t\treturn -EBADMSG;",
            "",
            "\tif (ms->id_type != PKEY_ID_PKCS7) {",
            "\t\tpr_err(\"%s: not signed with expected PKCS#7 message\\n\",",
            "\t\t       name);",
            "\t\treturn -ENOPKG;",
            "\t}",
            "",
            "\tif (ms->algo != 0 ||",
            "\t    ms->hash != 0 ||",
            "\t    ms->signer_len != 0 ||",
            "\t    ms->key_id_len != 0 ||",
            "\t    ms->__pad[0] != 0 ||",
            "\t    ms->__pad[1] != 0 ||",
            "\t    ms->__pad[2] != 0) {",
            "\t\tpr_err(\"%s: PKCS#7 signature info has unexpected non-zero params\\n\",",
            "\t\t       name);",
            "\t\treturn -EBADMSG;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "mod_check_sig",
          "description": "实现模块签名验证函数mod_check_sig，检查签名长度是否超出有效范围，验证PKCS#7标识符类型，并确保签名结构中的非关键字段均为零值以保证签名数据完整性",
          "similarity": 0.6234564781188965
        }
      ]
    },
    {
      "source_file": "kernel/module/kallsyms.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:02:17\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\kallsyms.c`\n\n---\n\n# module/kallsyms.c 技术文档\n\n## 1. 文件概述\n\n`module/kallsyms.c` 是 Linux 内核模块子系统中用于支持 **模块符号表（kallsyms）** 的核心实现文件。该文件负责在模块加载过程中处理 ELF 符号表（`.symtab`）和字符串表（`.strtab`），为模块提供运行时符号解析、调试信息支持以及 `/proc/kallsyms` 中模块符号的展示能力。它实现了模块符号的筛选、布局、复制和类型标注，确保只有“核心符号”（即非初始化段符号）在模块初始化完成后仍可被访问，同时支持 livepatch 模块的特殊需求。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`lookup_exported_symbol()`**  \n  在指定的 `kernel_symbol` 数组范围内使用二分查找（`bsearch`）定位导出符号。\n\n- **`is_exported()`**  \n  判断给定名称和地址的符号是否为内核或指定模块的已导出符号。\n\n- **`elf_type()`**  \n  根据 ELF 符号属性和节区信息，返回与 `nm` 工具兼容的符号类型字符（如 `'t'` 表示代码，`'d'` 表示已初始化数据等）。\n\n- **`is_core_symbol()`**  \n  判断一个 ELF 符号是否属于“核心符号”（即在模块初始化完成后仍需保留的符号），依据包括节区属性（`SHF_ALLOC`、`SHF_EXECINSTR`）、是否为 per-CPU 符号（受 `CONFIG_KALLSYMS_ALL` 控制）以及是否属于初始化内存类型。\n\n- **`layout_symtab()`**  \n  在模块内存布局阶段，计算并预留用于存储核心符号表、字符串表及类型表的空间，同时将原始符号表和字符串表标记为可分配（`SHF_ALLOC`）并放置在初始化数据段末尾。\n\n- **`add_kallsyms()`**  \n  在模块加载过程中，将完整的符号信息（用于初始化阶段）和裁剪后的核心符号信息（用于运行时）分别填充到初始化数据段和核心数据段，并设置符号类型。\n\n- **`init_build_id()`**  \n  （条件编译）从模块的 `SHT_NOTE` 节区中解析并初始化 Build ID，用于栈追踪和调试。\n\n- **`kallsyms_symbol_name()`**  \n  辅助函数，根据符号索引返回符号名称字符串。\n\n- **`find_kallsyms_sym()`**  \n  （未完整显示）用于根据地址在模块符号表中查找对应的符号名称，并可返回符号大小和偏移。\n\n### 关键数据结构\n\n- **`struct mod_kallsyms`**  \n  存储模块的完整符号表信息（在初始化阶段使用），包含 `symtab`、`strtab`、`typetab` 和符号数量。\n\n- **`mod->core_kallsyms`**  \n  模块结构体中的字段，存储裁剪后的核心符号表信息（初始化完成后使用）。\n\n- **`info->symoffs` / `info->stroffs` / `info->core_typeoffs` / `info->init_typeoffs`**  \n  `load_info` 中的偏移量字段，用于记录符号表、字符串表和类型表在模块内存中的布局位置。\n\n## 3. 关键实现\n\n### 符号筛选与内存布局\n- **两阶段符号表**：模块加载时维护两套符号表：\n  - **完整符号表**：包含所有符号，存放在 `MOD_INIT_DATA` 段，仅在模块初始化期间有效。\n  - **核心符号表**：仅包含 `is_core_symbol()` 判定为有效的符号（如代码段、只读数据、per-CPU 符号等），存放在 `MOD_DATA` 段，模块初始化完成后长期保留。\n- **内存分配**：通过 `layout_symtab()` 预先计算核心符号所需空间，并在模块内存布局中预留连续区域，避免运行时动态分配。\n\n### 符号类型标注\n- **`elf_type()`** 函数模拟 `nm` 工具的符号分类逻辑，根据 ELF 节区标志（如 `SHF_EXECINSTR`、`SHF_WRITE`）和符号绑定类型（如 `STB_WEAK`）生成单字符类型标识，用于 `/proc/kallsyms` 输出。\n\n### RCU 安全访问\n- 模块的 `kallsyms` 字段通过 **RCU（Read-Copy-Update）** 机制保护，在 `add_kallsyms()` 中使用 `rcu_dereference()` 和 `rcu_read_lock()` 确保并发安全。\n\n### Build ID 支持\n- 当启用 `CONFIG_STACKTRACE_BUILD_ID` 时，从模块的 `SHT_NOTE` 节区解析 GNU Build ID，用于唯一标识模块二进制，辅助崩溃分析和调试。\n\n### Livepatch 特殊处理\n- 在符号筛选逻辑中，若模块为 livepatch 模块（`is_livepatch_module(mod)`），则保留所有符号（包括初始化符号），以支持动态补丁的符号解析需求。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/module.h>`：模块核心结构体和 API。\n  - `<linux/kallsyms.h>`：内核符号表相关定义（如 `cmp_name`、`kernel_symbol_value`）。\n  - `<linux/buildid.h>`：Build ID 解析函数。\n  - `\"internal.h\"`：模块子系统内部头文件，包含 `module_memory`、`mod_mem_type` 等私有定义。\n- **内核配置依赖**：\n  - `CONFIG_KALLSYMS_ALL`：控制是否将所有已分配节区的符号（包括数据符号）纳入核心符号表。\n  - `CONFIG_STACKTRACE_BUILD_ID`：启用 Build ID 解析功能。\n- **与其他模块交互**：\n  - 与 `kernel/kallsyms.c` 协同工作，为 `/proc/kallsyms` 提供模块符号信息。\n  - 依赖模块加载器（`module.c`）提供的 `load_info` 结构和内存布局机制。\n\n## 5. 使用场景\n\n- **模块加载过程**：在 `load_module()` 流程中，由 `layout_symtab()` 和 `add_kallsyms()` 处理符号表，为模块提供运行时符号信息。\n- **内核符号解析**：当内核需要解析模块内的符号地址（如 Oops 日志、ftrace、perf）时，通过 `find_kallsyms_sym()` 查询模块的核心符号表。\n- **调试与分析**：通过 `/proc/kallsyms` 导出模块符号，供调试工具（如 GDB、perf）使用；Build ID 用于匹配调试符号文件。\n- **Livepatch 动态补丁**：确保 livepatch 模块的所有符号（包括初始化符号）在运行时可被解析，支持热补丁的符号重定向。\n- **内存优化**：在模块初始化完成后释放初始化段（包括完整符号表），仅保留核心符号表，减少内存占用。",
      "similarity": 0.6082984209060669,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/module/kallsyms.c",
          "start_line": 414,
          "end_line": 516,
          "content": [
            "static unsigned long __find_kallsyms_symbol_value(struct module *mod, const char *name)",
            "{",
            "\tunsigned int i;",
            "\tstruct mod_kallsyms *kallsyms = rcu_dereference_sched(mod->kallsyms);",
            "",
            "\tfor (i = 0; i < kallsyms->num_symtab; i++) {",
            "\t\tconst Elf_Sym *sym = &kallsyms->symtab[i];",
            "",
            "\t\tif (strcmp(name, kallsyms_symbol_name(kallsyms, i)) == 0 &&",
            "\t\t    sym->st_shndx != SHN_UNDEF)",
            "\t\t\treturn kallsyms_symbol_value(sym);",
            "\t}",
            "\treturn 0;",
            "}",
            "static unsigned long __module_kallsyms_lookup_name(const char *name)",
            "{",
            "\tstruct module *mod;",
            "\tchar *colon;",
            "",
            "\tcolon = strnchr(name, MODULE_NAME_LEN, ':');",
            "\tif (colon) {",
            "\t\tmod = find_module_all(name, colon - name, false);",
            "\t\tif (mod)",
            "\t\t\treturn __find_kallsyms_symbol_value(mod, colon + 1);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tlist_for_each_entry_rcu(mod, &modules, list) {",
            "\t\tunsigned long ret;",
            "",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "\t\tret = __find_kallsyms_symbol_value(mod, name);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t}",
            "\treturn 0;",
            "}",
            "unsigned long module_kallsyms_lookup_name(const char *name)",
            "{",
            "\tunsigned long ret;",
            "",
            "\t/* Don't lock: we're in enough trouble already. */",
            "\tpreempt_disable();",
            "\tret = __module_kallsyms_lookup_name(name);",
            "\tpreempt_enable();",
            "\treturn ret;",
            "}",
            "unsigned long find_kallsyms_symbol_value(struct module *mod, const char *name)",
            "{",
            "\tunsigned long ret;",
            "",
            "\tpreempt_disable();",
            "\tret = __find_kallsyms_symbol_value(mod, name);",
            "\tpreempt_enable();",
            "\treturn ret;",
            "}",
            "int module_kallsyms_on_each_symbol(const char *modname,",
            "\t\t\t\t   int (*fn)(void *, const char *, unsigned long),",
            "\t\t\t\t   void *data)",
            "{",
            "\tstruct module *mod;",
            "\tunsigned int i;",
            "\tint ret = 0;",
            "",
            "\tmutex_lock(&module_mutex);",
            "\tlist_for_each_entry(mod, &modules, list) {",
            "\t\tstruct mod_kallsyms *kallsyms;",
            "",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (modname && strcmp(modname, mod->name))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Use rcu_dereference_sched() to remain compliant with the sparse tool */",
            "\t\tpreempt_disable();",
            "\t\tkallsyms = rcu_dereference_sched(mod->kallsyms);",
            "\t\tpreempt_enable();",
            "",
            "\t\tfor (i = 0; i < kallsyms->num_symtab; i++) {",
            "\t\t\tconst Elf_Sym *sym = &kallsyms->symtab[i];",
            "",
            "\t\t\tif (sym->st_shndx == SHN_UNDEF)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tret = fn(data, kallsyms_symbol_name(kallsyms, i),",
            "\t\t\t\t kallsyms_symbol_value(sym));",
            "\t\t\tif (ret != 0)",
            "\t\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * The given module is found, the subsequent modules do not",
            "\t\t * need to be compared.",
            "\t\t */",
            "\t\tif (modname)",
            "\t\t\tbreak;",
            "\t}",
            "out:",
            "\tmutex_unlock(&module_mutex);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__find_kallsyms_symbol_value, __module_kallsyms_lookup_name, module_kallsyms_lookup_name, find_kallsyms_symbol_value, module_kallsyms_on_each_symbol",
          "description": "实现符号值查找、带模块限定的符号查找及遍历所有符号的函数，提供内核模块符号访问的核心实现逻辑",
          "similarity": 0.6243147850036621
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/kallsyms.c",
          "start_line": 1,
          "end_line": 23,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Module kallsyms support",
            " *",
            " * Copyright (C) 2010 Rusty Russell",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/module_symbol.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buildid.h>",
            "#include <linux/bsearch.h>",
            "#include \"internal.h\"",
            "",
            "/* Lookup exported symbol in given range of kernel_symbols */",
            "static const struct kernel_symbol *lookup_exported_symbol(const char *name,",
            "\t\t\t\t\t\t\t  const struct kernel_symbol *start,",
            "\t\t\t\t\t\t\t  const struct kernel_symbol *stop)",
            "{",
            "\treturn bsearch(name, start, stop - start,",
            "\t\t\tsizeof(struct kernel_symbol), cmp_name);",
            "}",
            ""
          ],
          "function_name": null,
          "description": "实现通过二分查找在内核符号表中定位导出符号的辅助函数，用于模块符号查找。",
          "similarity": 0.6228381991386414
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/kallsyms.c",
          "start_line": 24,
          "end_line": 152,
          "content": [
            "static int is_exported(const char *name, unsigned long value,",
            "\t\t       const struct module *mod)",
            "{",
            "\tconst struct kernel_symbol *ks;",
            "",
            "\tif (!mod)",
            "\t\tks = lookup_exported_symbol(name, __start___ksymtab, __stop___ksymtab);",
            "\telse",
            "\t\tks = lookup_exported_symbol(name, mod->syms, mod->syms + mod->num_syms);",
            "",
            "\treturn ks && kernel_symbol_value(ks) == value;",
            "}",
            "static char elf_type(const Elf_Sym *sym, const struct load_info *info)",
            "{",
            "\tconst Elf_Shdr *sechdrs = info->sechdrs;",
            "",
            "\tif (ELF_ST_BIND(sym->st_info) == STB_WEAK) {",
            "\t\tif (ELF_ST_TYPE(sym->st_info) == STT_OBJECT)",
            "\t\t\treturn 'v';",
            "\t\telse",
            "\t\t\treturn 'w';",
            "\t}",
            "\tif (sym->st_shndx == SHN_UNDEF)",
            "\t\treturn 'U';",
            "\tif (sym->st_shndx == SHN_ABS || sym->st_shndx == info->index.pcpu)",
            "\t\treturn 'a';",
            "\tif (sym->st_shndx >= SHN_LORESERVE)",
            "\t\treturn '?';",
            "\tif (sechdrs[sym->st_shndx].sh_flags & SHF_EXECINSTR)",
            "\t\treturn 't';",
            "\tif (sechdrs[sym->st_shndx].sh_flags & SHF_ALLOC &&",
            "\t    sechdrs[sym->st_shndx].sh_type != SHT_NOBITS) {",
            "\t\tif (!(sechdrs[sym->st_shndx].sh_flags & SHF_WRITE))",
            "\t\t\treturn 'r';",
            "\t\telse if (sechdrs[sym->st_shndx].sh_flags & ARCH_SHF_SMALL)",
            "\t\t\treturn 'g';",
            "\t\telse",
            "\t\t\treturn 'd';",
            "\t}",
            "\tif (sechdrs[sym->st_shndx].sh_type == SHT_NOBITS) {",
            "\t\tif (sechdrs[sym->st_shndx].sh_flags & ARCH_SHF_SMALL)",
            "\t\t\treturn 's';",
            "\t\telse",
            "\t\t\treturn 'b';",
            "\t}",
            "\tif (strstarts(info->secstrings + sechdrs[sym->st_shndx].sh_name,",
            "\t\t      \".debug\")) {",
            "\t\treturn 'n';",
            "\t}",
            "\treturn '?';",
            "}",
            "static bool is_core_symbol(const Elf_Sym *src, const Elf_Shdr *sechdrs,",
            "\t\t\t   unsigned int shnum, unsigned int pcpundx)",
            "{",
            "\tconst Elf_Shdr *sec;",
            "\tenum mod_mem_type type;",
            "",
            "\tif (src->st_shndx == SHN_UNDEF ||",
            "\t    src->st_shndx >= shnum ||",
            "\t    !src->st_name)",
            "\t\treturn false;",
            "",
            "#ifdef CONFIG_KALLSYMS_ALL",
            "\tif (src->st_shndx == pcpundx)",
            "\t\treturn true;",
            "#endif",
            "",
            "\tsec = sechdrs + src->st_shndx;",
            "\ttype = sec->sh_entsize >> SH_ENTSIZE_TYPE_SHIFT;",
            "\tif (!(sec->sh_flags & SHF_ALLOC)",
            "#ifndef CONFIG_KALLSYMS_ALL",
            "\t    || !(sec->sh_flags & SHF_EXECINSTR)",
            "#endif",
            "\t    || mod_mem_type_is_init(type))",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}",
            "void layout_symtab(struct module *mod, struct load_info *info)",
            "{",
            "\tElf_Shdr *symsect = info->sechdrs + info->index.sym;",
            "\tElf_Shdr *strsect = info->sechdrs + info->index.str;",
            "\tconst Elf_Sym *src;",
            "\tunsigned int i, nsrc, ndst, strtab_size = 0;",
            "\tstruct module_memory *mod_mem_data = &mod->mem[MOD_DATA];",
            "\tstruct module_memory *mod_mem_init_data = &mod->mem[MOD_INIT_DATA];",
            "",
            "\t/* Put symbol section at end of init part of module. */",
            "\tsymsect->sh_flags |= SHF_ALLOC;",
            "\tsymsect->sh_entsize = module_get_offset_and_type(mod, MOD_INIT_DATA,",
            "\t\t\t\t\t\t\t symsect, info->index.sym);",
            "\tpr_debug(\"\\t%s\\n\", info->secstrings + symsect->sh_name);",
            "",
            "\tsrc = (void *)info->hdr + symsect->sh_offset;",
            "\tnsrc = symsect->sh_size / sizeof(*src);",
            "",
            "\t/* Compute total space required for the core symbols' strtab. */",
            "\tfor (ndst = i = 0; i < nsrc; i++) {",
            "\t\tif (i == 0 || is_livepatch_module(mod) ||",
            "\t\t    is_core_symbol(src + i, info->sechdrs, info->hdr->e_shnum,",
            "\t\t\t\t   info->index.pcpu)) {",
            "\t\t\tstrtab_size += strlen(&info->strtab[src[i].st_name]) + 1;",
            "\t\t\tndst++;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Append room for core symbols at end of core part. */",
            "\tinfo->symoffs = ALIGN(mod_mem_data->size, symsect->sh_addralign ?: 1);",
            "\tinfo->stroffs = mod_mem_data->size = info->symoffs + ndst * sizeof(Elf_Sym);",
            "\tmod_mem_data->size += strtab_size;",
            "\t/* Note add_kallsyms() computes strtab_size as core_typeoffs - stroffs */",
            "\tinfo->core_typeoffs = mod_mem_data->size;",
            "\tmod_mem_data->size += ndst * sizeof(char);",
            "",
            "\t/* Put string table section at end of init part of module. */",
            "\tstrsect->sh_flags |= SHF_ALLOC;",
            "\tstrsect->sh_entsize = module_get_offset_and_type(mod, MOD_INIT_DATA,",
            "\t\t\t\t\t\t\t strsect, info->index.str);",
            "\tpr_debug(\"\\t%s\\n\", info->secstrings + strsect->sh_name);",
            "",
            "\t/* We'll tack temporary mod_kallsyms on the end. */",
            "\tmod_mem_init_data->size = ALIGN(mod_mem_init_data->size,",
            "\t\t\t\t\t__alignof__(struct mod_kallsyms));",
            "\tinfo->mod_kallsyms_init_off = mod_mem_init_data->size;",
            "",
            "\tmod_mem_init_data->size += sizeof(struct mod_kallsyms);",
            "\tinfo->init_typeoffs = mod_mem_init_data->size;",
            "\tmod_mem_init_data->size += nsrc * sizeof(char);",
            "}"
          ],
          "function_name": "is_exported, elf_type, is_core_symbol, layout_symtab",
          "description": "定义符号导出检查、ELF符号类型识别及核心符号判定逻辑，用于模块符号表布局与符号分类处理。上下文不完整",
          "similarity": 0.5937527418136597
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/module/kallsyms.c",
          "start_line": 170,
          "end_line": 293,
          "content": [
            "void add_kallsyms(struct module *mod, const struct load_info *info)",
            "{",
            "\tunsigned int i, ndst;",
            "\tconst Elf_Sym *src;",
            "\tElf_Sym *dst;",
            "\tchar *s;",
            "\tElf_Shdr *symsec = &info->sechdrs[info->index.sym];",
            "\tunsigned long strtab_size;",
            "\tvoid *data_base = mod->mem[MOD_DATA].base;",
            "\tvoid *init_data_base = mod->mem[MOD_INIT_DATA].base;",
            "",
            "\t/* Set up to point into init section. */",
            "\tmod->kallsyms = (void __rcu *)init_data_base +",
            "\t\tinfo->mod_kallsyms_init_off;",
            "",
            "\trcu_read_lock();",
            "\t/* The following is safe since this pointer cannot change */",
            "\trcu_dereference(mod->kallsyms)->symtab = (void *)symsec->sh_addr;",
            "\trcu_dereference(mod->kallsyms)->num_symtab = symsec->sh_size / sizeof(Elf_Sym);",
            "\t/* Make sure we get permanent strtab: don't use info->strtab. */",
            "\trcu_dereference(mod->kallsyms)->strtab =",
            "\t\t(void *)info->sechdrs[info->index.str].sh_addr;",
            "\trcu_dereference(mod->kallsyms)->typetab = init_data_base + info->init_typeoffs;",
            "",
            "\t/*",
            "\t * Now populate the cut down core kallsyms for after init",
            "\t * and set types up while we still have access to sections.",
            "\t */",
            "\tmod->core_kallsyms.symtab = dst = data_base + info->symoffs;",
            "\tmod->core_kallsyms.strtab = s = data_base + info->stroffs;",
            "\tmod->core_kallsyms.typetab = data_base + info->core_typeoffs;",
            "\tstrtab_size = info->core_typeoffs - info->stroffs;",
            "\tsrc = rcu_dereference(mod->kallsyms)->symtab;",
            "\tfor (ndst = i = 0; i < rcu_dereference(mod->kallsyms)->num_symtab; i++) {",
            "\t\trcu_dereference(mod->kallsyms)->typetab[i] = elf_type(src + i, info);",
            "\t\tif (i == 0 || is_livepatch_module(mod) ||",
            "\t\t    is_core_symbol(src + i, info->sechdrs, info->hdr->e_shnum,",
            "\t\t\t\t   info->index.pcpu)) {",
            "\t\t\tssize_t ret;",
            "",
            "\t\t\tmod->core_kallsyms.typetab[ndst] =",
            "\t\t\t    rcu_dereference(mod->kallsyms)->typetab[i];",
            "\t\t\tdst[ndst] = src[i];",
            "\t\t\tdst[ndst++].st_name = s - mod->core_kallsyms.strtab;",
            "\t\t\tret = strscpy(s,",
            "\t\t\t\t      &rcu_dereference(mod->kallsyms)->strtab[src[i].st_name],",
            "\t\t\t\t      strtab_size);",
            "\t\t\tif (ret < 0)",
            "\t\t\t\tbreak;",
            "\t\t\ts += ret + 1;",
            "\t\t\tstrtab_size -= ret + 1;",
            "\t\t}",
            "\t}",
            "\trcu_read_unlock();",
            "\tmod->core_kallsyms.num_symtab = ndst;",
            "}",
            "void init_build_id(struct module *mod, const struct load_info *info)",
            "{",
            "\tconst Elf_Shdr *sechdr;",
            "\tunsigned int i;",
            "",
            "\tfor (i = 0; i < info->hdr->e_shnum; i++) {",
            "\t\tsechdr = &info->sechdrs[i];",
            "\t\tif (!sect_empty(sechdr) && sechdr->sh_type == SHT_NOTE &&",
            "\t\t    !build_id_parse_buf((void *)sechdr->sh_addr, mod->build_id,",
            "\t\t\t\t\tsechdr->sh_size))",
            "\t\t\tbreak;",
            "\t}",
            "}",
            "void init_build_id(struct module *mod, const struct load_info *info)",
            "{",
            "}",
            "int lookup_module_symbol_name(unsigned long addr, char *symname)",
            "{",
            "\tstruct module *mod;",
            "",
            "\tpreempt_disable();",
            "\tlist_for_each_entry_rcu(mod, &modules, list) {",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "\t\tif (within_module(addr, mod)) {",
            "\t\t\tconst char *sym;",
            "",
            "\t\t\tsym = find_kallsyms_symbol(mod, addr, NULL, NULL);",
            "\t\t\tif (!sym)",
            "\t\t\t\tgoto out;",
            "",
            "\t\t\tstrscpy(symname, sym, KSYM_NAME_LEN);",
            "\t\t\tpreempt_enable();",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "out:",
            "\tpreempt_enable();",
            "\treturn -ERANGE;",
            "}",
            "int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,",
            "\t\t       char *name, char *module_name, int *exported)",
            "{",
            "\tstruct module *mod;",
            "",
            "\tpreempt_disable();",
            "\tlist_for_each_entry_rcu(mod, &modules, list) {",
            "\t\tstruct mod_kallsyms *kallsyms;",
            "",
            "\t\tif (mod->state == MODULE_STATE_UNFORMED)",
            "\t\t\tcontinue;",
            "\t\tkallsyms = rcu_dereference_sched(mod->kallsyms);",
            "\t\tif (symnum < kallsyms->num_symtab) {",
            "\t\t\tconst Elf_Sym *sym = &kallsyms->symtab[symnum];",
            "",
            "\t\t\t*value = kallsyms_symbol_value(sym);",
            "\t\t\t*type = kallsyms->typetab[symnum];",
            "\t\t\tstrscpy(name, kallsyms_symbol_name(kallsyms, symnum), KSYM_NAME_LEN);",
            "\t\t\tstrscpy(module_name, mod->name, MODULE_NAME_LEN);",
            "\t\t\t*exported = is_exported(name, *value, mod);",
            "\t\t\tpreempt_enable();",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tsymnum -= kallsyms->num_symtab;",
            "\t}",
            "\tpreempt_enable();",
            "\treturn -ERANGE;",
            "}"
          ],
          "function_name": "add_kallsyms, init_build_id, init_build_id, lookup_module_symbol_name, module_get_kallsym",
          "description": "初始化模块kallsyms数据结构并填充符号信息，包含构建ID解析、符号查找及模块符号表访问接口。存在重复函数声明",
          "similarity": 0.5892834067344666
        }
      ]
    }
  ]
}