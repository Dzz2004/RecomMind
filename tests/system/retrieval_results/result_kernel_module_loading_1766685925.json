{
  "query": "kernel module loading",
  "timestamp": "2025-12-26 02:05:25",
  "retrieved_files": [
    {
      "source_file": "kernel/module/kmod.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:03:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\kmod.c`\n\n---\n\n# `module/kmod.c` 技术文档\n\n## 1. 文件概述\n\n`kmod.c` 是 Linux 内核中负责**内核模块自动加载机制**的核心实现文件。它提供了从内核空间调用用户态 `modprobe` 工具以动态加载缺失模块的能力。该机制允许内核在运行时按需加载驱动或功能模块（例如当设备被探测到但对应驱动未加载时），从而提升系统灵活性和资源利用率。\n\n该文件实现了 `__request_module()` 接口，作为内核其他子系统请求模块加载的统一入口，并通过 `call_usermodehelper` 机制安全地调用用户空间的 `/sbin/modprobe`（或由 `modprobe_path` 指定的路径）。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`__request_module(bool wait, const char *fmt, ...)`**  \n  内核模块加载的主入口函数。支持格式化模块名，可选择同步（`wait=true`）或异步（`wait=false`）执行。返回值为 0 表示成功启动加载过程，负值为错误码，正值为 `modprobe` 的退出码。\n\n- **`call_modprobe(char *orig_module_name, int wait)`**  \n  封装对用户态 `modprobe` 的调用。构造命令行参数（`modprobe -q -- <module_name>`）和环境变量，通过 `call_usermodehelper_setup()` 和 `call_usermodehelper_exec()` 执行。\n\n- **`free_modprobe_argv(struct subprocess_info *info)`**  \n  释放 `call_modprobe` 中分配的参数内存，作为 `call_usermodehelper_setup()` 的清理回调。\n\n### 关键数据结构与变量\n\n- **`modprobe_path[KMOD_PATH_LEN]`**  \n  全局可配置的 `modprobe` 可执行文件路径，默认为 `CONFIG_MODPROBE_PATH`（通常为 `\"/sbin/modprobe\"`），可通过 `/proc/sys/kernel/modprobe` 修改。\n\n- **`kmod_concurrent_max`**  \n  信号量，限制同时进行的模块加载请求数量，上限为 `MAX_KMOD_CONCURRENT`（50），防止资源耗尽或递归依赖导致的死锁。\n\n- **`MAX_KMOD_ALL_BUSY_TIMEOUT`**  \n  超时阈值（5 秒），当所有并发槽位被占用超过此时间，判定为可能的模块依赖循环，拒绝新请求。\n\n## 3. 关键实现\n\n### 并发控制与死锁预防\n\n- 使用 `down_timeout(&kmod_concurrent_max, ...)` 限制并发加载线程数，避免系统资源（如内存、进程数）被大量 `modprobe` 进程耗尽。\n- 若所有 50 个并发槽位在 5 秒内未释放，内核判定为**模块依赖循环**（如 A 依赖 B，B 又依赖 A），主动拒绝请求并打印警告，防止无限递归。\n- 通过 `WARN_ON_ONCE(wait && current_is_async())` 禁止在异步上下文（如 workqueue、async 任务）中执行**同步**模块加载，避免与 `async_synchronize_full()` 产生死锁。\n\n### 安全与资源管理\n\n- 调用 `security_kernel_module_request()` 执行 LSM（Linux Security Module）安全检查，允许安全模块（如 SELinux、AppArmor）控制模块加载权限。\n- 使用 `UMH_KILLABLE` 标志使 `modprobe` 进程可被信号中断，提升系统响应性。\n- 通过 `kmod_dup_request_exists_wait()` 检测重复的模块加载请求，避免对同一模块发起多次 `modprobe` 调用，提升效率。\n\n### 用户态交互\n\n- 构造标准环境变量（`HOME=/`, `PATH=/sbin:/usr/sbin:/bin:/usr/bin`）确保 `modprobe` 在受限但可用的环境中执行。\n- 使用 `call_usermodehelper` 子系统创建内核线程执行用户态程序，该机制处理了凭证（cred）、文件描述符、挂载命名空间等上下文隔离。\n\n### 跟踪与调试\n\n- 集成 `trace_module_request` 跟踪点，可通过 ftrace 或 perf 监控模块加载请求。\n- 调用 `kmod_dup_request_announce()` 记录重复请求或失败事件，便于诊断。\n\n## 4. 依赖关系\n\n- **内核子系统依赖**：\n  - `call_usermodehelper`（`<linux/unistd.h>`, `<linux/binfmts.h>`）：用于执行用户态 helper 程序。\n  - LSM 框架（`<linux/security.h>`）：执行模块加载安全策略。\n  - 内存管理（`<linux/slab.h>`）：动态分配参数字符串。\n  - 同步原语（`<linux/semaphore.h>` via `DEFINE_SEMAPHORE`）：并发控制。\n  - 调试与跟踪（`<trace/events/module.h>`）：性能分析支持。\n- **配置依赖**：\n  - `CONFIG_MODULES`：模块支持必须启用。\n  - `CONFIG_MODPROBE_PATH`：定义默认 `modprobe` 路径。\n- **内部依赖**：\n  - `internal.h`：包含模块子系统内部声明（如 `kmod_dup_request_exists_wait`）。\n\n## 5. 使用场景\n\n- **设备驱动自动加载**：当内核探测到新硬件（如 USB 设备）但无对应驱动时，通过 `__request_module(\"usb:vXXXXpXXXX...\")` 触发驱动加载。\n- **文件系统按需挂载**：挂载未知文件系统类型时（如 `mount -t foo`），内核调用 `__request_module(\"fs-foo\")` 加载文件系统模块。\n- **网络协议模块加载**：使用未加载的网络协议（如 `AF_PHONET`）时自动加载对应模块。\n- **内核特性动态扩展**：如加密算法、压缩模块等在首次使用时按需加载。\n- **内核模块依赖解析**：当模块 A 依赖模块 B，而 B 未加载时，`insmod`/`modprobe` 内部会通过此机制加载 B。\n\n> **注意**：成功返回仅表示 `modprobe` 已启动，不保证模块最终加载成功。调用者必须验证所需功能是否可用。",
      "similarity": 0.6212300062179565,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/kmod.c",
          "start_line": 66,
          "end_line": 161,
          "content": [
            "static void free_modprobe_argv(struct subprocess_info *info)",
            "{",
            "\tkfree(info->argv[3]); /* check call_modprobe() */",
            "\tkfree(info->argv);",
            "}",
            "static int call_modprobe(char *orig_module_name, int wait)",
            "{",
            "\tstruct subprocess_info *info;",
            "\tstatic char *envp[] = {",
            "\t\t\"HOME=/\",",
            "\t\t\"TERM=linux\",",
            "\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",",
            "\t\tNULL",
            "\t};",
            "\tchar *module_name;",
            "\tint ret;",
            "",
            "\tchar **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);",
            "\tif (!argv)",
            "\t\tgoto out;",
            "",
            "\tmodule_name = kstrdup(orig_module_name, GFP_KERNEL);",
            "\tif (!module_name)",
            "\t\tgoto free_argv;",
            "",
            "\targv[0] = modprobe_path;",
            "\targv[1] = \"-q\";",
            "\targv[2] = \"--\";",
            "\targv[3] = module_name;\t/* check free_modprobe_argv() */",
            "\targv[4] = NULL;",
            "",
            "\tinfo = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,",
            "\t\t\t\t\t NULL, free_modprobe_argv, NULL);",
            "\tif (!info)",
            "\t\tgoto free_module_name;",
            "",
            "\tret = call_usermodehelper_exec(info, wait | UMH_KILLABLE);",
            "\tkmod_dup_request_announce(orig_module_name, ret);",
            "\treturn ret;",
            "",
            "free_module_name:",
            "\tkfree(module_name);",
            "free_argv:",
            "\tkfree(argv);",
            "out:",
            "\tkmod_dup_request_announce(orig_module_name, -ENOMEM);",
            "\treturn -ENOMEM;",
            "}",
            "int __request_module(bool wait, const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "\tchar module_name[MODULE_NAME_LEN];",
            "\tint ret, dup_ret;",
            "",
            "\t/*",
            "\t * We don't allow synchronous module loading from async.  Module",
            "\t * init may invoke async_synchronize_full() which will end up",
            "\t * waiting for this task which already is waiting for the module",
            "\t * loading to complete, leading to a deadlock.",
            "\t */",
            "\tWARN_ON_ONCE(wait && current_is_async());",
            "",
            "\tif (!modprobe_path[0])",
            "\t\treturn -ENOENT;",
            "",
            "\tva_start(args, fmt);",
            "\tret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);",
            "\tva_end(args);",
            "\tif (ret >= MODULE_NAME_LEN)",
            "\t\treturn -ENAMETOOLONG;",
            "",
            "\tret = security_kernel_module_request(module_name);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = down_timeout(&kmod_concurrent_max, MAX_KMOD_ALL_BUSY_TIMEOUT * HZ);",
            "\tif (ret) {",
            "\t\tpr_warn_ratelimited(\"request_module: modprobe %s cannot be processed, kmod busy with %d threads for more than %d seconds now\",",
            "\t\t\t\t    module_name, MAX_KMOD_CONCURRENT, MAX_KMOD_ALL_BUSY_TIMEOUT);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ttrace_module_request(module_name, wait, _RET_IP_);",
            "",
            "\tif (kmod_dup_request_exists_wait(module_name, wait, &dup_ret)) {",
            "\t\tret = dup_ret;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);",
            "",
            "out:",
            "\tup(&kmod_concurrent_max);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "free_modprobe_argv, call_modprobe, __request_module",
          "description": "实现模块请求处理逻辑，通过调用modprobe执行模块加载，包含参数构造、子进程管理及并发控制机制",
          "similarity": 0.5866149067878723
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/kmod.c",
          "start_line": 1,
          "end_line": 65,
          "content": [
            "/*",
            " * kmod - the kernel module loader",
            " *",
            " * Copyright (C) 2023 Luis Chamberlain <mcgrof@kernel.org>",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/unistd.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/cred.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/resource.h>",
            "#include <linux/notifier.h>",
            "#include <linux/suspend.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/async.h>",
            "#include <linux/uaccess.h>",
            "",
            "#include <trace/events/module.h>",
            "#include \"internal.h\"",
            "",
            "/*",
            " * Assuming:",
            " *",
            " * threads = div64_u64((u64) totalram_pages * (u64) PAGE_SIZE,",
            " *\t\t       (u64) THREAD_SIZE * 8UL);",
            " *",
            " * If you need less than 50 threads would mean we're dealing with systems",
            " * smaller than 3200 pages. This assumes you are capable of having ~13M memory,",
            " * and this would only be an upper limit, after which the OOM killer would take",
            " * effect. Systems like these are very unlikely if modules are enabled.",
            " */",
            "#define MAX_KMOD_CONCURRENT 50",
            "static DEFINE_SEMAPHORE(kmod_concurrent_max, MAX_KMOD_CONCURRENT);",
            "",
            "/*",
            " * This is a restriction on having *all* MAX_KMOD_CONCURRENT threads",
            " * running at the same time without returning. When this happens we",
            " * believe you've somehow ended up with a recursive module dependency",
            " * creating a loop.",
            " *",
            " * We have no option but to fail.",
            " *",
            " * Userspace should proactively try to detect and prevent these.",
            " */",
            "#define MAX_KMOD_ALL_BUSY_TIMEOUT 5",
            "",
            "/*",
            "\tmodprobe_path is set via /proc/sys.",
            "*/",
            "char modprobe_path[KMOD_PATH_LEN] = CONFIG_MODPROBE_PATH;",
            ""
          ],
          "function_name": null,
          "description": "定义模块加载并发控制相关常量与全局变量，包含模块加载所需头文件并初始化modprobe路径",
          "similarity": 0.5394432544708252
        }
      ]
    },
    {
      "source_file": "kernel/module/dups.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:00:29\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\dups.c`\n\n---\n\n# `module/dups.c` 技术文档\n\n## 1. 文件概述\n\n`module/dups.c` 实现了 Linux 内核模块自动加载（`request_module()`）过程中的**重复请求抑制机制**。该机制旨在防止多个并发线程对同一模块发起重复的自动加载请求，从而避免不必要的用户空间 `modprobe` 调用、减少 `vmalloc()` 内存碎片，并优化系统启动或模块加载期间的性能。\n\n该功能通过维护一个受互斥锁保护的重复请求跟踪列表，对首次请求进行记录，并让后续重复请求等待首个请求的结果，最终共享其返回值，从而实现去重与同步。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct kmod_dup_req`**  \n  表示一个模块加载请求的跟踪条目，包含：\n  - `list`：链表节点，用于加入全局 `dup_kmod_reqs` 列表\n  - `name[MODULE_NAME_LEN]`：模块名称\n  - `first_req_done`：完成量（`completion`），用于通知等待者首个请求已完成\n  - `complete_work`：工作队列项，用于异步完成所有等待者的通知\n  - `delete_work`：延迟工作队列项，用于在请求完成后一段时间（60秒）自动清理条目\n  - `dup_ret`：首个请求的返回值，供后续重复请求复用\n\n### 主要函数\n\n- **`kmod_dup_request_lookup(char *module_name)`**  \n  在 `dup_kmod_reqs` 列表中查找是否存在指定模块名的请求条目（需持有 `kmod_dup_mutex` 锁）。\n\n- **`kmod_dup_request_delete(struct work_struct *work)`**  \n  延迟工作回调函数，从列表中安全删除请求条目并释放内存（使用 RCU 同步）。\n\n- **`kmod_dup_request_complete(struct work_struct *work)`**  \n  工作队列回调函数，调用 `complete_all()` 唤醒所有等待该模块加载完成的线程，并调度延迟删除。\n\n- **`kmod_dup_request_exists_wait(char *module_name, bool wait, int *dup_ret)`**  \n  **核心入口函数**。检查是否存在对 `module_name` 的重复请求：\n  - 若不存在且当前为 `request_module()`（`wait == true`），则创建新条目并返回 `false`（表示非重复）。\n  - 若为 `request_module_nowait()`（`wait == false`）且无现有条目，则不跟踪，返回 `false`。\n  - 若存在重复请求：\n    - 对 `nowait` 请求，直接返回成功（`*dup_ret = 0`）。\n    - 对 `wait` 请求，等待首个请求完成并复用其返回值。\n  - 若启用 `enable_dups_trace`，对重复请求触发 `WARN()` 警告。\n\n- **`kmod_dup_request_announce(char *module_name, int ret)`**  \n  由首个请求的调用者在 `request_module()` 返回后调用，用于记录返回值 `ret` 并触发完成通知（通过工作队列异步执行）。\n\n### 模块参数\n\n- **`module.enable_dups_trace`**（布尔型，只读写 `true`）  \n  控制是否对重复请求使用 `WARN()`（否则仅 `pr_warn`）。默认值由 `CONFIG_MODULE_DEBUG_AUTOLOAD_DUPS_TRACE` 决定。\n\n## 3. 关键实现\n\n### 重复请求检测与同步机制\n\n1. **首次请求处理**：\n   - `request_module()`（`wait=true`）调用 `kmod_dup_request_exists_wait()`。\n   - 若无重复条目，则分配 `kmod_dup_req` 并加入全局列表，返回 `false`，继续执行用户空间加载。\n   - `request_module_nowait()`（`wait=false`）若为首个请求，则不创建条目，直接返回 `false`（不参与去重）。\n\n2. **重复请求处理**：\n   - 后续相同模块名的请求命中已有条目。\n   - `nowait` 请求立即返回成功（`0`）。\n   - `wait` 请求调用 `wait_for_completion_state()` 等待首个请求完成。\n\n3. **结果广播与清理**：\n   - 首个请求完成后调用 `kmod_dup_request_announce()`，记录返回值并调度 `complete_work`。\n   - `complete_work` 调用 `complete_all()` 唤醒所有等待者。\n   - 随后调度 `delete_work`，60 秒后自动清理条目（避免内存泄漏，同时容忍短暂窗口内的新请求）。\n\n### 并发与内存安全\n\n- **互斥锁保护**：`kmod_dup_mutex` 保护列表的增删操作。\n- **RCU 读取**：`kmod_dup_request_lookup()` 使用 `list_for_each_entry_rcu()`，允许无锁读取（需持有锁或处于 RCU 读侧临界区）。\n- **延迟删除**：通过 `synchronize_rcu()` 确保所有读者完成后再释放内存。\n- **预分配优化**：在获取锁前预分配 `new_kmod_req`，减少锁持有时间。\n\n### 设计权衡\n\n- **不跟踪 `nowait` 首请求**：因无法提供有效返回值给后续 `wait` 请求。\n- **容忍短暂重复窗口**：删除条目前允许新请求直接调用 `modprobe`（仅返回 0），认为这是用户空间的责任。\n- **异步完成通知**：避免在 `kmod_dup_request_announce()` 中阻塞首个请求的调用路径。\n\n## 4. 依赖关系\n\n- **内部头文件**：`#include \"internal.h\"`（模块子系统内部接口）\n- **内核核心组件**：\n  - `linux/kmod.h`：`request_module()` 相关接口\n  - `linux/completion.h`：完成量同步原语\n  - `linux/workqueue.h`：工作队列机制\n  - `linux/rcupdate.h`（隐式）：RCU 同步\n  - `linux/mutex.h`：互斥锁\n  - `linux/slab.h`：内存分配\n- **配置依赖**：`CONFIG_MODULE_DEBUG_AUTOLOAD_DUPS_TRACE` 控制调试行为\n\n## 5. 使用场景\n\n- **内核模块自动加载**：当多个子系统（如设备驱动、文件系统、网络协议）几乎同时尝试通过 `request_module()` 加载同一模块时，避免多次调用用户空间 `modprobe`。\n- **系统启动优化**：在初始化阶段减少因模块重复加载导致的 `vmalloc()` 内存碎片和不必要的上下文切换。\n- **防止滥用**：检测并警告开发人员对 `request_module()` 的低效重复调用，鼓励使用 `try_then_request_module()` 或集中加载策略。\n- **异步加载兼容**：支持 `request_module_nowait()` 与 `request_module()` 混合调用场景下的合理去重。",
      "similarity": 0.5996142625808716,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/dups.c",
          "start_line": 72,
          "end_line": 218,
          "content": [
            "static void kmod_dup_request_delete(struct work_struct *work)",
            "{",
            "\tstruct kmod_dup_req *kmod_req;",
            "\tkmod_req = container_of(to_delayed_work(work), struct kmod_dup_req, delete_work);",
            "",
            "\t/*",
            "\t * The typical situation is a module successully loaded. In that",
            "\t * situation the module will be present already in userspace. If",
            "\t * new requests come in after that, userspace will already know the",
            "\t * module is loaded so will just return 0 right away. There is still",
            "\t * a small chance right after we delete this entry new request_module()",
            "\t * calls may happen after that, they can happen. These heuristics",
            "\t * are to protect finit_module() abuse for auto-loading, if modules",
            "\t * are still tryign to auto-load even if a module is already loaded,",
            "\t * that's on them, and those inneficiencies should not be fixed by",
            "\t * kmod. The inneficies there are a call to modprobe and modprobe",
            "\t * just returning 0.",
            "\t */",
            "\tmutex_lock(&kmod_dup_mutex);",
            "\tlist_del_rcu(&kmod_req->list);",
            "\tsynchronize_rcu();",
            "\tmutex_unlock(&kmod_dup_mutex);",
            "\tkfree(kmod_req);",
            "}",
            "static void kmod_dup_request_complete(struct work_struct *work)",
            "{",
            "\tstruct kmod_dup_req *kmod_req;",
            "",
            "\tkmod_req = container_of(work, struct kmod_dup_req, complete_work);",
            "",
            "\t/*",
            "\t * This will ensure that the kernel will let all the waiters get",
            "\t * informed its time to check the return value. It's time to",
            "\t * go home.",
            "\t */",
            "\tcomplete_all(&kmod_req->first_req_done);",
            "",
            "\t/*",
            "\t * Now that we have allowed prior request_module() calls to go on",
            "\t * with life, let's schedule deleting this entry. We don't have",
            "\t * to do it right away, but we *eventually* want to do it so to not",
            "\t * let this linger forever as this is just a boot optimization for",
            "\t * possible abuses of vmalloc() incurred by finit_module() thrashing.",
            "\t */",
            "\tqueue_delayed_work(system_wq, &kmod_req->delete_work, 60 * HZ);",
            "}",
            "bool kmod_dup_request_exists_wait(char *module_name, bool wait, int *dup_ret)",
            "{",
            "\tstruct kmod_dup_req *kmod_req, *new_kmod_req;",
            "\tint ret;",
            "",
            "\t/*",
            "\t * Pre-allocate the entry in case we have to use it later",
            "\t * to avoid contention with the mutex.",
            "\t */",
            "\tnew_kmod_req = kzalloc(sizeof(*new_kmod_req), GFP_KERNEL);",
            "\tif (!new_kmod_req)",
            "\t\treturn false;",
            "",
            "\tmemcpy(new_kmod_req->name, module_name, strlen(module_name));",
            "\tINIT_WORK(&new_kmod_req->complete_work, kmod_dup_request_complete);",
            "\tINIT_DELAYED_WORK(&new_kmod_req->delete_work, kmod_dup_request_delete);",
            "\tinit_completion(&new_kmod_req->first_req_done);",
            "",
            "\tmutex_lock(&kmod_dup_mutex);",
            "",
            "\tkmod_req = kmod_dup_request_lookup(module_name);",
            "\tif (!kmod_req) {",
            "\t\t/*",
            "\t\t * If the first request that came through for a module",
            "\t\t * was with request_module_nowait() we cannot wait for it",
            "\t\t * and share its return value with other users which may",
            "\t\t * have used request_module() and need a proper return value",
            "\t\t * so just skip using them as an anchor.",
            "\t\t *",
            "\t\t * If a prior request to this one came through with",
            "\t\t * request_module() though, then a request_module_nowait()",
            "\t\t * would benefit from duplicate detection.",
            "\t\t */",
            "\t\tif (!wait) {",
            "\t\t\tkfree(new_kmod_req);",
            "\t\t\tpr_debug(\"New request_module_nowait() for %s -- cannot track duplicates for this request\\n\", module_name);",
            "\t\t\tmutex_unlock(&kmod_dup_mutex);",
            "\t\t\treturn false;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * There was no duplicate, just add the request so we can",
            "\t\t * keep tab on duplicates later.",
            "\t\t */",
            "\t\tpr_debug(\"New request_module() for %s\\n\", module_name);",
            "\t\tlist_add_rcu(&new_kmod_req->list, &dup_kmod_reqs);",
            "\t\tmutex_unlock(&kmod_dup_mutex);",
            "\t\treturn false;",
            "\t}",
            "\tmutex_unlock(&kmod_dup_mutex);",
            "",
            "\t/* We are dealing with a duplicate request now */",
            "\tkfree(new_kmod_req);",
            "",
            "\t/*",
            "\t * To fix these try to use try_then_request_module() instead as that",
            "\t * will check if the component you are looking for is present or not.",
            "\t * You could also just queue a single request to load the module once,",
            "\t * instead of having each and everything you need try to request for",
            "\t * the module.",
            "\t *",
            "\t * Duplicate request_module() calls  can cause quite a bit of wasted",
            "\t * vmalloc() space when racing with userspace.",
            "\t */",
            "\tif (enable_dups_trace)",
            "\t\tWARN(1, \"module-autoload: duplicate request for module %s\\n\", module_name);",
            "\telse",
            "\t\tpr_warn(\"module-autoload: duplicate request for module %s\\n\", module_name);",
            "",
            "\tif (!wait) {",
            "\t\t/*",
            "\t\t * If request_module_nowait() was used then the user just",
            "\t\t * wanted to issue the request and if another module request",
            "\t\t * was already its way with the same name we don't care for",
            "\t\t * the return value either. Let duplicate request_module_nowait()",
            "\t\t * calls bail out right away.",
            "\t\t */",
            "\t\t*dup_ret = 0;",
            "\t\treturn true;",
            "\t}",
            "",
            "\t/*",
            "\t * If a duplicate request_module() was used they *may* care for",
            "\t * the return value, so we have no other option but to wait for",
            "\t * the first caller to complete. If the first caller used",
            "\t * the request_module_nowait() call, subsquent callers will",
            "\t * deal with the comprmise of getting a successful call with this",
            "\t * optimization enabled ...",
            "\t */",
            "\tret = wait_for_completion_state(&kmod_req->first_req_done,",
            "\t\t\t\t\tTASK_UNINTERRUPTIBLE | TASK_KILLABLE);",
            "\tif (ret) {",
            "\t\t*dup_ret = ret;",
            "\t\treturn true;",
            "\t}",
            "",
            "\t/* Now the duplicate request has the same exact return value as the first request */",
            "\t*dup_ret = kmod_req->dup_ret;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "kmod_dup_request_delete, kmod_dup_request_complete, kmod_dup_request_exists_wait",
          "description": "实现重复模块请求的处理逻辑，通过工作队列延迟清理冗余请求，支持等待首次请求结果并传递给后续请求，防止因重复加载导致的资源浪费",
          "similarity": 0.538223385810852
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/module/dups.c",
          "start_line": 222,
          "end_line": 248,
          "content": [
            "void kmod_dup_request_announce(char *module_name, int ret)",
            "{",
            "\tstruct kmod_dup_req *kmod_req;",
            "",
            "\tmutex_lock(&kmod_dup_mutex);",
            "",
            "\tkmod_req = kmod_dup_request_lookup(module_name);",
            "\tif (!kmod_req)",
            "\t\tgoto out;",
            "",
            "\tkmod_req->dup_ret = ret;",
            "",
            "\t/*",
            "\t * If we complete() here we may allow duplicate threads",
            "\t * to continue before the first one that submitted the",
            "\t * request. We're in no rush also, given that each and",
            "\t * every bounce back to userspace is slow we avoid that",
            "\t * with a slight delay here. So queueue up the completion",
            "\t * and let duplicates suffer, just wait a tad bit longer.",
            "\t * There is no rush. But we also don't want to hold the",
            "\t * caller up forever or introduce any boot delays.",
            "\t */",
            "\tqueue_work(system_wq, &kmod_req->complete_work);",
            "",
            "out:",
            "\tmutex_unlock(&kmod_dup_mutex);",
            "}"
          ],
          "function_name": "kmod_dup_request_announce",
          "description": "通告模块加载结果的接口函数，通过唤醒等待队列通知后续请求获取首次加载的返回状态，避免重复发起不必要的模块加载请求",
          "similarity": 0.5150285959243774
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/dups.c",
          "start_line": 1,
          "end_line": 71,
          "content": [
            "/* SPDX-License-Identifier: GPL-2.0-or-later */",
            "/*",
            " * kmod dups - the kernel module autoloader duplicate suppressor",
            " *",
            " * Copyright (C) 2023 Luis Chamberlain <mcgrof@kernel.org>",
            " */",
            "",
            "#define pr_fmt(fmt)     \"module: \" fmt",
            "",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/unistd.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/cred.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/resource.h>",
            "#include <linux/notifier.h>",
            "#include <linux/suspend.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/async.h>",
            "#include <linux/uaccess.h>",
            "",
            "#include \"internal.h\"",
            "",
            "#undef MODULE_PARAM_PREFIX",
            "#define MODULE_PARAM_PREFIX \"module.\"",
            "static bool enable_dups_trace = IS_ENABLED(CONFIG_MODULE_DEBUG_AUTOLOAD_DUPS_TRACE);",
            "module_param(enable_dups_trace, bool_enable_only, 0644);",
            "",
            "/*",
            " * Protects dup_kmod_reqs list, adds / removals with RCU.",
            " */",
            "static DEFINE_MUTEX(kmod_dup_mutex);",
            "static LIST_HEAD(dup_kmod_reqs);",
            "",
            "struct kmod_dup_req {",
            "\tstruct list_head list;",
            "\tchar name[MODULE_NAME_LEN];",
            "\tstruct completion first_req_done;",
            "\tstruct work_struct complete_work;",
            "\tstruct delayed_work delete_work;",
            "\tint dup_ret;",
            "};",
            "",
            "static struct kmod_dup_req *kmod_dup_request_lookup(char *module_name)",
            "{",
            "\tstruct kmod_dup_req *kmod_req;",
            "",
            "\tlist_for_each_entry_rcu(kmod_req, &dup_kmod_reqs, list,",
            "\t\t\t\tlockdep_is_held(&kmod_dup_mutex)) {",
            "\t\tif (strlen(kmod_req->name) == strlen(module_name) &&",
            "\t\t    !memcmp(kmod_req->name, module_name, strlen(module_name))) {",
            "\t\t\treturn kmod_req;",
            "                }",
            "        }",
            "",
            "\treturn NULL;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义内核模块自动加载重复抑制器的基础设施，包括互斥锁保护的链表结构、模块请求记录结构体kmod_dup_req及其成员变量，提供基于RCU的查找接口",
          "similarity": 0.5001197457313538
        }
      ]
    },
    {
      "source_file": "kernel/module/debug_kmemleak.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:58:25\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\debug_kmemleak.c`\n\n---\n\n# module/debug_kmemleak.c 技术文档\n\n## 1. 文件概述\n\n该文件为 Linux 内核模块系统提供对 **kmemleak**（内核内存泄漏检测器）的支持。其主要作用是在模块加载过程中，将模块相关的可写、非可执行内存区域注册到 kmemleak 扫描机制中，以便 kmemleak 能够追踪这些区域中的指针引用，从而避免将仍在使用的动态分配内存误判为泄漏。\n\n## 2. 核心功能\n\n- **函数**：\n  - `void kmemleak_load_module(const struct module *mod, const struct load_info *info)`  \n    在模块加载时，向 kmemleak 注册模块结构体本身以及模块中所有可写且非可执行的已分配节（section）作为扫描区域。\n\n- **数据结构（引用）**：\n  - `struct module`：内核模块的核心描述结构。\n  - `struct load_info`：模块加载过程中的临时信息结构，包含 ELF 头、节头表等。\n  - `Elf_Shdr`（通过 `info->sechdrs` 访问）：ELF 节头描述符，用于判断节的属性。\n\n## 3. 关键实现\n\n- **模块结构体扫描**：  \n  首先调用 `kmemleak_scan_area(mod, sizeof(struct module), GFP_KERNEL)`，将整个 `struct module` 实例标记为 kmemleak 的扫描区域，确保模块元数据中的指针不会被误判为泄漏。\n\n- **节（Section）筛选逻辑**：  \n  遍历 ELF 文件的所有节（从索引 1 开始，跳过空节），仅对同时满足以下条件的节进行扫描注册：\n  - `SHF_ALLOC`：该节在运行时需要被加载到内存中。\n  - `SHF_WRITE`：该节是可写的（通常包含数据段，如 `.data`、`.bss` 等）。\n  - **非** `SHF_EXECINSTR`：该节**不是**可执行的（排除代码段如 `.text`）。\n\n- **内存区域注册**：  \n  对符合条件的节，调用 `kmemleak_scan_area()`，传入节在内核空间的虚拟地址（`sh_addr`）和大小（`sh_size`），通知 kmemleak 在后续的内存泄漏扫描中将该区域视为“根指针”来源，用于追踪潜在的内存引用。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/module.h>`：提供模块系统相关定义。\n  - `<linux/kmemleak.h>`：提供 `kmemleak_scan_area()` 等 kmemleak 接口。\n  - `\"internal.h\"`：模块子系统内部头文件，定义 `struct load_info` 等内部结构。\n\n- **功能依赖**：\n  - 依赖 **kmemleak 子系统**（需在内核配置中启用 `CONFIG_DEBUG_KMEMLEAK`）。\n  - 与 **模块加载器**（`load_module()` 流程）紧密集成，在模块布局完成后、正式启用前调用此函数。\n\n## 5. 使用场景\n\n- 当内核启用 **kmemleak 内存泄漏检测功能** 且动态加载模块（通过 `insmod` 或 `modprobe`）时，此函数会被模块加载流程自动调用。\n- 用于确保模块自身的数据段（如全局变量、静态变量等）中的指针能被 kmemleak 正确识别为有效引用，防止将模块仍在使用的动态分配内存（如通过 `kmalloc()` 分配）错误报告为内存泄漏。\n- 仅在 `CONFIG_DEBUG_KMEMLEAK` 配置选项启用时编译进内核，对正常系统运行无影响。",
      "similarity": 0.598741888999939,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/debug_kmemleak.c",
          "start_line": 12,
          "end_line": 30,
          "content": [
            "void kmemleak_load_module(const struct module *mod,",
            "\t\t\t  const struct load_info *info)",
            "{",
            "\tunsigned int i;",
            "",
            "\t/* only scan the sections containing data */",
            "\tkmemleak_scan_area(mod, sizeof(struct module), GFP_KERNEL);",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\t/* Scan all writable sections that's not executable */",
            "\t\tif (!(info->sechdrs[i].sh_flags & SHF_ALLOC) ||",
            "\t\t    !(info->sechdrs[i].sh_flags & SHF_WRITE) ||",
            "\t\t    (info->sechdrs[i].sh_flags & SHF_EXECINSTR))",
            "\t\t\tcontinue;",
            "",
            "\t\tkmemleak_scan_area((void *)info->sechdrs[i].sh_addr,",
            "\t\t\t\t   info->sechdrs[i].sh_size, GFP_KERNEL);",
            "\t}",
            "}"
          ],
          "function_name": "kmemleak_load_module",
          "description": "该函数在模块加载时扫描模块的可写数据段，通过检查section属性过滤出需分析的内存区域，调用kmemleak接口进行泄漏检测。",
          "similarity": 0.5980067849159241
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/debug_kmemleak.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Module kmemleak support",
            " *",
            " * Copyright (C) 2009 Catalin Marinas",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/kmemleak.h>",
            "#include \"internal.h\"",
            ""
          ],
          "function_name": null,
          "description": "此代码块定义了kmemleak模块的调试支持，声明GPL许可证并引入相关头文件，为后续内存泄漏检测功能提供基础框架。",
          "similarity": 0.571830153465271
        }
      ]
    }
  ]
}