{
  "query": "time-sharing scheduler",
  "timestamp": "2025-12-25 23:54:11",
  "retrieved_files": [
    {
      "source_file": "kernel/time/itimer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:39:13\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\itimer.c`\n\n---\n\n# `time/itimer.c` 技术文档\n\n## 1. 文件概述\n\n`time/itimer.c` 是 Linux 内核中实现 POSIX 间隔定时器（interval timers，简称 itimers）的核心文件。该文件提供了对三种经典 Unix 间隔定时器的支持：\n\n- **ITIMER_REAL**：基于真实时间（墙上时钟）的定时器，到期时发送 `SIGALRM` 信号\n- **ITIMER_VIRTUAL**：基于进程用户态 CPU 时间的定时器，到期时发送 `SIGVTALRM` 信号\n- **ITIMER_PROF**：基于进程总 CPU 时间（用户态+内核态）的定时器，到期时发送 `SIGPROF` 信号\n\n该文件实现了 `getitimer()`、`setitimer()` 系统调用以及 `alarm()` 系统调用（在架构支持的情况下），为用户空间程序提供间隔定时器功能。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`itimer_get_remtime()`**：获取高精度实时定时器的剩余时间\n- **`get_cpu_itimer()`**：获取 CPU 时间相关的定时器（虚拟/性能）状态\n- **`do_getitimer()`**：内部实现获取指定类型定时器状态的逻辑\n- **`put_itimerval()`**：将内核内部的 `itimerspec64` 格式转换为用户空间的 `old_itimerval` 格式\n- **`getitimer()` 系统调用**：用户空间获取定时器状态的入口\n- **`it_real_fn()`**：ITIMER_REAL 定时器到期时的回调函数\n- **`set_cpu_itimer()`**：设置 CPU 时间相关的定时器\n- **`do_setitimer()`**：内部实现设置指定类型定时器的逻辑\n- **`clear_itimer()`**：在 SELinux 环境下清除所有定时器（安全相关）\n- **`alarm_setitimer()`**：实现 `alarm()` 系统调用的内部函数\n- **`alarm()` 系统调用**：设置单次实时定时器的简化接口\n\n### 数据结构\n\n- **`struct cpu_itimer`**：存储 CPU 时间定时器的状态（在 `signal_struct` 中）\n- **`struct hrtimer`**：高精度定时器，用于实现 ITIMER_REAL\n- **`struct itimerspec64`**：64 位时间规格结构，内核内部使用\n- **`struct __kernel_old_itimerval`**：用户空间兼容的定时器值结构\n\n## 3. 关键实现\n\n### 定时器类型实现差异\n\n- **ITIMER_REAL**：使用高精度定时器（`hrtimer`）实现，基于真实时间，通过 `hrtimer_start()` 启动，到期时调用 `it_real_fn()` 发送 `SIGALRM` 信号\n- **ITIMER_VIRTUAL/ITIMER_PROF**：基于 CPU 时间采样实现，通过 `thread_group_sample_cputime()` 获取当前进程组的 CPU 时间，与设定的过期时间比较来判断是否到期\n\n### 时间精度处理\n\n- 使用纳秒级精度的 `ktime_t` 和 `timespec64` 进行内部计算\n- 用户空间接口使用微秒精度（`tv_usec`），通过 `NSEC_PER_USEC` 进行单位转换\n- 对于即将到期的定时器，返回 `TICK_NSEC`（1 微秒）作为剩余时间，避免返回 0 导致用户误判\n\n### 并发安全\n\n- 使用 `siglock` 自旋锁保护信号结构体中的定时器状态\n- ITIMER_REAL 的设置操作需要处理定时器可能正在执行的竞态条件，通过 `hrtimer_try_to_cancel()` 和重试机制确保安全\n- CPU 定时器操作在 `siglock` 保护下进行，确保线程组内的一致性\n\n### 兼容性支持\n\n- 提供 32 位兼容接口（`COMPAT_SYSCALL_DEFINE2`）\n- 支持 `alarm()` 系统调用（在 `__ARCH_WANT_SYS_ALARM` 定义时）\n- 处理 32 位系统上的时间值溢出问题（限制为 `INT_MAX`）\n\n## 4. 依赖关系\n\n### 头文件依赖\n\n- **`<linux/hrtimer.h>`**：高精度定时器框架，用于 ITIMER_REAL 实现\n- **`<linux/sched/cputime.h>`**：CPU 时间采样功能，用于虚拟和性能定时器\n- **`<linux/posix-timers.h>`**：POSIX 定时器相关定义\n- **`<linux/sched/signal.h>`**：信号处理和 `signal_struct` 结构定义\n- **`<linux/time.h>`**：时间转换和操作函数\n- **`<trace/events/timer.h>`**：定时器事件跟踪支持\n\n### 内核子系统依赖\n\n- **调度子系统**：通过 `current` 获取当前任务，使用 `thread_group_sample_cputime()` 采样 CPU 时间\n- **信号子系统**：通过 `kill_pid_info()` 发送信号，使用 `siglock` 进行同步\n- **高精度定时器子系统**：ITIMER_REAL 的底层实现依赖 hrtimer 框架\n- **安全子系统**：SELinux 相关的 `clear_itimer()` 函数\n\n## 5. 使用场景\n\n### 用户空间编程\n\n- **定时任务**：应用程序使用 `setitimer()` 设置周期性或一次性定时器\n- **超时控制**：网络编程中设置 I/O 操作超时\n- **性能监控**：使用 ITIMER_PROF 监控程序 CPU 使用情况\n- **简单定时**：使用 `alarm()` 系统调用设置简单的秒级定时器\n\n### 内核内部使用\n\n- **进程管理**：在进程退出或权限变更时清除定时器（SELinux 场景）\n- **信号处理**：定时器到期时向进程发送相应信号\n- **时间跟踪**：通过 tracepoint 记录定时器状态变化和到期事件\n- **兼容层**：为不同架构和位数提供统一的定时器接口\n\n### 系统调用路径\n\n- **`getitimer()`** → `do_getitimer()` → 对应定时器类型的具体获取函数\n- **`setitimer()`** → `do_setitimer()` → 对应定时器类型的具体设置函数  \n- **`alarm()`** → `alarm_setitimer()` → `do_setitimer(ITIMER_REAL, ...)`\n\n该文件是 Linux 内核 POSIX 定时器功能的重要组成部分，为用户空间提供了经典的 Unix 间隔定时器接口。",
      "similarity": 0.5700560808181763,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/time/itimer.c",
          "start_line": 168,
          "end_line": 275,
          "content": [
            "static void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,",
            "\t\t\t   const struct itimerspec64 *const value,",
            "\t\t\t   struct itimerspec64 *const ovalue)",
            "{",
            "\tu64 oval, nval, ointerval, ninterval;",
            "\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];",
            "",
            "\tnval = timespec64_to_ns(&value->it_value);",
            "\tninterval = timespec64_to_ns(&value->it_interval);",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "",
            "\toval = it->expires;",
            "\tointerval = it->incr;",
            "\tif (oval || nval) {",
            "\t\tif (nval > 0)",
            "\t\t\tnval += TICK_NSEC;",
            "\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);",
            "\t}",
            "\tit->expires = nval;",
            "\tit->incr = ninterval;",
            "\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?",
            "\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);",
            "",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\tif (ovalue) {",
            "\t\tovalue->it_value = ns_to_timespec64(oval);",
            "\t\tovalue->it_interval = ns_to_timespec64(ointerval);",
            "\t}",
            "}",
            "static int do_setitimer(int which, struct itimerspec64 *value,",
            "\t\t\tstruct itimerspec64 *ovalue)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tstruct hrtimer *timer;",
            "\tktime_t expires;",
            "",
            "\tswitch (which) {",
            "\tcase ITIMER_REAL:",
            "again:",
            "\t\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t\ttimer = &tsk->signal->real_timer;",
            "\t\tif (ovalue) {",
            "\t\t\tovalue->it_value = itimer_get_remtime(timer);",
            "\t\t\tovalue->it_interval",
            "\t\t\t\t= ktime_to_timespec64(tsk->signal->it_real_incr);",
            "\t\t}",
            "\t\t/* We are sharing ->siglock with it_real_fn() */",
            "\t\tif (hrtimer_try_to_cancel(timer) < 0) {",
            "\t\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\t\thrtimer_cancel_wait_running(timer);",
            "\t\t\tgoto again;",
            "\t\t}",
            "\t\texpires = timespec64_to_ktime(value->it_value);",
            "\t\tif (expires != 0) {",
            "\t\t\ttsk->signal->it_real_incr =",
            "\t\t\t\ttimespec64_to_ktime(value->it_interval);",
            "\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);",
            "\t\t} else",
            "\t\t\ttsk->signal->it_real_incr = 0;",
            "",
            "\t\ttrace_itimer_state(ITIMER_REAL, value, 0);",
            "\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\tbreak;",
            "\tcase ITIMER_VIRTUAL:",
            "\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);",
            "\t\tbreak;",
            "\tcase ITIMER_PROF:",
            "\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}",
            "void clear_itimer(void)",
            "{",
            "\tstruct itimerspec64 v = {};",
            "\tint i;",
            "",
            "\tfor (i = 0; i < 3; i++)",
            "\t\tdo_setitimer(i, &v, NULL);",
            "}",
            "static unsigned int alarm_setitimer(unsigned int seconds)",
            "{",
            "\tstruct itimerspec64 it_new, it_old;",
            "",
            "#if BITS_PER_LONG < 64",
            "\tif (seconds > INT_MAX)",
            "\t\tseconds = INT_MAX;",
            "#endif",
            "\tit_new.it_value.tv_sec = seconds;",
            "\tit_new.it_value.tv_nsec = 0;",
            "\tit_new.it_interval.tv_sec = it_new.it_interval.tv_nsec = 0;",
            "",
            "\tdo_setitimer(ITIMER_REAL, &it_new, &it_old);",
            "",
            "\t/*",
            "\t * We can't return 0 if we have an alarm pending ...  And we'd",
            "\t * better return too much than too little anyway",
            "\t */",
            "\tif ((!it_old.it_value.tv_sec && it_old.it_value.tv_nsec) ||",
            "\t      it_old.it_value.tv_nsec >= (NSEC_PER_SEC / 2))",
            "\t\tit_old.it_value.tv_sec++;",
            "",
            "\treturn it_old.it_value.tv_sec;",
            "}"
          ],
          "function_name": "set_cpu_itimer, do_setitimer, clear_itimer, alarm_setitimer",
          "description": "包含set_cpu_itimer设置CPU定时器参数、do_setitimer根据时钟类型配置定时器、clear_itimer清除所有定时器、alarm_setitimer设置一次性闹钟，其中do_setitimer处理实时时钟的启动和取消操作",
          "similarity": 0.5845109224319458
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/itimer.c",
          "start_line": 29,
          "end_line": 129,
          "content": [
            "static struct timespec64 itimer_get_remtime(struct hrtimer *timer)",
            "{",
            "\tktime_t rem = __hrtimer_get_remaining(timer, true);",
            "",
            "\t/*",
            "\t * Racy but safe: if the itimer expires after the above",
            "\t * hrtimer_get_remtime() call but before this condition",
            "\t * then we return 0 - which is correct.",
            "\t */",
            "\tif (hrtimer_active(timer)) {",
            "\t\tif (rem <= 0)",
            "\t\t\trem = NSEC_PER_USEC;",
            "\t} else",
            "\t\trem = 0;",
            "",
            "\treturn ktime_to_timespec64(rem);",
            "}",
            "static void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,",
            "\t\t\t   struct itimerspec64 *const value)",
            "{",
            "\tu64 val, interval;",
            "\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];",
            "",
            "\tspin_lock_irq(&tsk->sighand->siglock);",
            "",
            "\tval = it->expires;",
            "\tinterval = it->incr;",
            "\tif (val) {",
            "\t\tu64 t, samples[CPUCLOCK_MAX];",
            "",
            "\t\tthread_group_sample_cputime(tsk, samples);",
            "\t\tt = samples[clock_id];",
            "",
            "\t\tif (val < t)",
            "\t\t\t/* about to fire */",
            "\t\t\tval = TICK_NSEC;",
            "\t\telse",
            "\t\t\tval -= t;",
            "\t}",
            "",
            "\tspin_unlock_irq(&tsk->sighand->siglock);",
            "",
            "\tvalue->it_value = ns_to_timespec64(val);",
            "\tvalue->it_interval = ns_to_timespec64(interval);",
            "}",
            "static int do_getitimer(int which, struct itimerspec64 *value)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "",
            "\tswitch (which) {",
            "\tcase ITIMER_REAL:",
            "\t\tspin_lock_irq(&tsk->sighand->siglock);",
            "\t\tvalue->it_value = itimer_get_remtime(&tsk->signal->real_timer);",
            "\t\tvalue->it_interval =",
            "\t\t\tktime_to_timespec64(tsk->signal->it_real_incr);",
            "\t\tspin_unlock_irq(&tsk->sighand->siglock);",
            "\t\tbreak;",
            "\tcase ITIMER_VIRTUAL:",
            "\t\tget_cpu_itimer(tsk, CPUCLOCK_VIRT, value);",
            "\t\tbreak;",
            "\tcase ITIMER_PROF:",
            "\t\tget_cpu_itimer(tsk, CPUCLOCK_PROF, value);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn(-EINVAL);",
            "\t}",
            "\treturn 0;",
            "}",
            "static int put_itimerval(struct __kernel_old_itimerval __user *o,",
            "\t\t\t const struct itimerspec64 *i)",
            "{",
            "\tstruct __kernel_old_itimerval v;",
            "",
            "\tv.it_interval.tv_sec = i->it_interval.tv_sec;",
            "\tv.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;",
            "\tv.it_value.tv_sec = i->it_value.tv_sec;",
            "\tv.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;",
            "\treturn copy_to_user(o, &v, sizeof(struct __kernel_old_itimerval)) ? -EFAULT : 0;",
            "}",
            "static int put_old_itimerval32(struct old_itimerval32 __user *o,",
            "\t\t\t       const struct itimerspec64 *i)",
            "{",
            "\tstruct old_itimerval32 v32;",
            "",
            "\tv32.it_interval.tv_sec = i->it_interval.tv_sec;",
            "\tv32.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;",
            "\tv32.it_value.tv_sec = i->it_value.tv_sec;",
            "\tv32.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;",
            "\treturn copy_to_user(o, &v32, sizeof(struct old_itimerval32)) ? -EFAULT : 0;",
            "}",
            "enum hrtimer_restart it_real_fn(struct hrtimer *timer)",
            "{",
            "\tstruct signal_struct *sig =",
            "\t\tcontainer_of(timer, struct signal_struct, real_timer);",
            "\tstruct pid *leader_pid = sig->pids[PIDTYPE_TGID];",
            "",
            "\ttrace_itimer_expire(ITIMER_REAL, leader_pid, 0);",
            "\tkill_pid_info(SIGALRM, SEND_SIG_PRIV, leader_pid);",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}"
          ],
          "function_name": "itimer_get_remtime, get_cpu_itimer, do_getitimer, put_itimerval, put_old_itimerval32, it_real_fn",
          "description": "实现了itimer_get_remtime获取剩余时间、get_cpu_itimer读取CPU定时器信息、do_getitimer根据时钟类型获取定时器状态、put_itimerval/put_old_itimerval32转换并复制时间值到用户空间，以及it_real_fn作为实时时钟的超时处理函数",
          "similarity": 0.5817811489105225
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/time/itimer.c",
          "start_line": 313,
          "end_line": 348,
          "content": [
            "static int get_itimerval(struct itimerspec64 *o, const struct __kernel_old_itimerval __user *i)",
            "{",
            "\tstruct __kernel_old_itimerval v;",
            "",
            "\tif (copy_from_user(&v, i, sizeof(struct __kernel_old_itimerval)))",
            "\t\treturn -EFAULT;",
            "",
            "\t/* Validate the timevals in value. */",
            "\tif (!timeval_valid(&v.it_value) ||",
            "\t    !timeval_valid(&v.it_interval))",
            "\t\treturn -EINVAL;",
            "",
            "\to->it_interval.tv_sec = v.it_interval.tv_sec;",
            "\to->it_interval.tv_nsec = v.it_interval.tv_usec * NSEC_PER_USEC;",
            "\to->it_value.tv_sec = v.it_value.tv_sec;",
            "\to->it_value.tv_nsec = v.it_value.tv_usec * NSEC_PER_USEC;",
            "\treturn 0;",
            "}",
            "static int get_old_itimerval32(struct itimerspec64 *o, const struct old_itimerval32 __user *i)",
            "{",
            "\tstruct old_itimerval32 v32;",
            "",
            "\tif (copy_from_user(&v32, i, sizeof(struct old_itimerval32)))",
            "\t\treturn -EFAULT;",
            "",
            "\t/* Validate the timevals in value.  */",
            "\tif (!timeval_valid(&v32.it_value) ||",
            "\t    !timeval_valid(&v32.it_interval))",
            "\t\treturn -EINVAL;",
            "",
            "\to->it_interval.tv_sec = v32.it_interval.tv_sec;",
            "\to->it_interval.tv_nsec = v32.it_interval.tv_usec * NSEC_PER_USEC;",
            "\to->it_value.tv_sec = v32.it_value.tv_sec;",
            "\to->it_value.tv_nsec = v32.it_value.tv_usec * NSEC_PER_USEC;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_itimerval, get_old_itimerval32",
          "description": "实现get_itimerval/get_old_itimerval32将用户态时间值转换为内核时间结构体，执行有效性校验，确保输入时间值在合法范围内",
          "similarity": 0.5472544431686401
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/itimer.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992 Darren Senn",
            " */",
            "",
            "/* These are all the functions necessary to implement itimers */",
            "",
            "#include <linux/mm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/time.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/hrtimer.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/compat.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "/**",
            " * itimer_get_remtime - get remaining time for the timer",
            " *",
            " * @timer: the timer to read",
            " *",
            " * Returns the delta between the expiry time and now, which can be",
            " * less than zero or 1usec for an pending expired timer",
            " */"
          ],
          "function_name": null,
          "description": "该代码块定义了itimer_get_remtime函数的原型，用于获取高精度定时器的剩余时间，通过计算当前时间与定时器到期时间的差值得到剩余时间，但未提供完整实现，上下文不完整",
          "similarity": 0.5379075407981873
        }
      ]
    },
    {
      "source_file": "kernel/time/sched_clock.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:46:17\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\sched_clock.c`\n\n---\n\n# `time/sched_clock.c` 技术文档\n\n## 1. 文件概述\n\n`time/sched_clock.c` 实现了 Linux 内核中通用的 `sched_clock()` 机制，用于将底层硬件计数器（如 TSC、ARM arch timer 等）扩展为 64 位纳秒级单调时间戳。该机制为调度器、延迟跟踪、性能分析等子系统提供高精度、低开销的时间基准。文件通过双缓冲（双副本）+ 序列锁（`seqcount_latch_t`）的方式，确保即使在 NMI（不可屏蔽中断）上下文中调用 `sched_clock()` 也能获得一致、无撕裂的时间读数。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct clock_data`**  \n  全局状态结构体，包含：\n  - `seq`: `seqcount_latch_t` 类型的序列计数器，用于同步读写。\n  - `read_data[2]`: 双缓冲数组，分别存储当前有效和更新中的读取参数。\n  - `wrap_kt`: 计数器溢出前的最大持续时间（ktime_t 格式）。\n  - `rate`: 当前注册的时钟源频率（Hz）。\n  - `actual_read_sched_clock`: 指向底层硬件读取函数的指针。\n\n- **`struct clock_read_data`**（定义在头文件中）  \n  包含读取 `sched_clock` 所需的关键参数：\n  - `read_sched_clock`: 当前使用的读取函数（可能为挂起状态下的特殊函数）。\n  - `sched_clock_mask`: 计数器位宽掩码（如 `CLOCKSOURCE_MASK(bits)`）。\n  - `mult/shift`: 用于将计数器周期转换为纳秒的乘法/移位因子。\n  - `epoch_cyc/epoch_ns`: 上次校准时刻的计数器值和对应的纳秒时间戳。\n\n### 主要函数\n\n- **`sched_clock_noinstr(void)`**  \n  无插桩（noinstr）版本的 `sched_clock()`，在禁用抢占的上下文中直接读取并计算纳秒时间，使用序列锁保证一致性。\n\n- **`sched_clock(void)`**  \n  对外公开的 `sched_clock()` 接口，内部调用 `sched_clock_noinstr()` 并确保抢占被禁用。\n\n- **`sched_clock_register(read, bits, rate)`**  \n  注册新的底层硬件时钟源。计算 `mult/shift` 转换参数，更新全局 `clock_data`，并启动防溢出定时器。\n\n- **`generic_sched_clock_init(void)`**  \n  初始化通用 `sched_clock` 机制。若未注册硬件时钟，则回退到基于 `jiffies` 的实现，并启动周期性更新定时器。\n\n- **`sched_clock_suspend()/sched_clock_resume()`**  \n  系统挂起/恢复时的回调函数。挂起时切换读取函数为返回最后校准值的静态函数，恢复时重新同步并启用硬件读取。\n\n- **`update_sched_clock()`**  \n  更新 `epoch_cyc` 和 `epoch_ns`，防止因计数器长时间运行导致转换溢出。\n\n- **`sched_clock_poll()`**  \n  高精度定时器（hrtimer）回调函数，周期性调用 `update_sched_clock()`。\n\n## 3. 关键实现\n\n### 双缓冲 + Latch 序列锁机制\n\n- 使用 `seqcount_latch_t` 实现无锁读取：读操作通过 `sched_clock_read_begin()` 获取当前有效副本索引（`seq & 1`），并在末尾通过 `sched_clock_read_retry()` 验证读取期间未发生更新。\n- 写操作（如 `update_clock_read_data()`）先更新奇数副本（索引 1），通过 `raw_write_seqcount_latch()` 切换读者到奇数副本；再更新偶数副本（索引 0），再次切换回偶数副本。确保读者始终看到一致的旧数据或新数据，不会看到中间状态。\n\n### 时间转换与防溢出\n\n- 使用 `clocks_calc_mult_shift()` 计算最优的 `mult/shift` 对，将硬件计数器周期高效转换为纳秒（公式：`ns = (cyc * mult) >> shift`）。\n- 通过 `clocks_calc_max_nsecs()` 计算计数器在溢出前可安全表示的最大纳秒数，并以此设置 `hrtimer` 的超时时间（`wrap_kt`），定期调用 `update_sched_clock()` 重置 `epoch`，避免 64 位中间结果溢出。\n\n### 挂起/恢复处理\n\n- 系统挂起时，将 `read_sched_clock` 替换为 `suspended_sched_clock_read()`，该函数返回最后一次校准的 `epoch_cyc`，使 `sched_clock()` 在挂起期间表现为“冻结”。\n- 恢复时重新读取硬件计数器作为新的 `epoch_cyc`，并恢复原始读取函数。\n\n### 中断上下文安全\n\n- 所有读路径（`sched_clock*`）标记为 `notrace` 和 `noinstr`，避免在关键路径引入追踪或插桩开销。\n- 写操作（如注册、更新）在关中断（`local_irq_save`）下执行，确保与 NMI 上下文的读操作互斥。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/clocksource.h>`：提供 `CLOCKSOURCE_MASK`、`clocks_calc_mult_shift` 等时钟源工具。\n  - `<linux/hrtimer.h>`：用于实现防溢出定时器。\n  - `<linux/seqlock.h>`：提供 `seqcount_latch_t` 及相关操作。\n  - `\"timekeeping.h\"`：内核时间管理内部头文件。\n  - `<linux/sched/clock.h>`：定义 `sched_clock()` 接口及 `enable_sched_clock_irqtime()`。\n\n- **模块交互**：\n  - **调度器（scheduler）**：`sched_clock()` 是 `rq_clock()` 等调度时间基准的底层实现。\n  - **时间子系统（timekeeping）**：与 `ktime_get()` 等接口协同，但 `sched_clock()` 更侧重低开销、单调性。\n  - **电源管理（PM）**：通过 `syscore_ops` 注册挂起/恢复回调。\n  - **中断子系统**：若时钟频率 ≥ 1MHz 且 `irqtime` 未禁用，则启用中断时间统计（`enable_sched_clock_irqtime()`）。\n\n## 5. 使用场景\n\n- **调度延迟测量**：调度器使用 `sched_clock()` 计算任务运行时间、睡眠时间及调度延迟。\n- **性能分析工具**：如 `ftrace`、`perf` 使用 `sched_clock()` 作为事件时间戳。\n- **内核延迟跟踪**：`irqsoff`、`preemptoff` 等 tracer 依赖高精度单调时钟。\n- **硬件计数器抽象**：为架构特定的高精度计数器（如 x86 TSC、ARM arch timer）提供统一的 64 位纳秒接口。\n- **系统挂起/恢复**：在 Suspend-to-RAM 等场景下保持时间连续性，避免挂起期间时间“跳跃”。",
      "similarity": 0.5698654651641846,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/time/sched_clock.c",
          "start_line": 237,
          "end_line": 285,
          "content": [
            "void __init generic_sched_clock_init(void)",
            "{",
            "\t/*",
            "\t * If no sched_clock() function has been provided at that point,",
            "\t * make it the final one.",
            "\t */",
            "\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)",
            "\t\tsched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);",
            "",
            "\tupdate_sched_clock();",
            "",
            "\t/*",
            "\t * Start the timer to keep sched_clock() properly updated and",
            "\t * sets the initial epoch.",
            "\t */",
            "\thrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);",
            "\tsched_clock_timer.function = sched_clock_poll;",
            "\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);",
            "}",
            "static u64 notrace suspended_sched_clock_read(void)",
            "{",
            "\tunsigned int seq = raw_read_seqcount_latch(&cd.seq);",
            "",
            "\treturn cd.read_data[seq & 1].epoch_cyc;",
            "}",
            "int sched_clock_suspend(void)",
            "{",
            "\tstruct clock_read_data *rd = &cd.read_data[0];",
            "",
            "\tupdate_sched_clock();",
            "\thrtimer_cancel(&sched_clock_timer);",
            "\trd->read_sched_clock = suspended_sched_clock_read;",
            "",
            "\treturn 0;",
            "}",
            "void sched_clock_resume(void)",
            "{",
            "\tstruct clock_read_data *rd = &cd.read_data[0];",
            "",
            "\trd->epoch_cyc = cd.actual_read_sched_clock();",
            "\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);",
            "\trd->read_sched_clock = cd.actual_read_sched_clock;",
            "}",
            "static int __init sched_clock_syscore_init(void)",
            "{",
            "\tregister_syscore_ops(&sched_clock_ops);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "generic_sched_clock_init, suspended_sched_clock_read, sched_clock_suspend, sched_clock_resume, sched_clock_syscore_init",
          "description": "提供调度时钟初始化、挂起/恢复处理及系统核心操作注册，初始化阶段设置默认时钟源并启动更新定时器，挂起时切换至专用读取函数以保持时间连续性",
          "similarity": 0.5687137246131897
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/sched_clock.c",
          "start_line": 52,
          "end_line": 202,
          "content": [
            "static u64 notrace jiffy_sched_clock_read(void)",
            "{",
            "\t/*",
            "\t * We don't need to use get_jiffies_64 on 32-bit arches here",
            "\t * because we register with BITS_PER_LONG",
            "\t */",
            "\treturn (u64)(jiffies - INITIAL_JIFFIES);",
            "}",
            "static __always_inline u64 cyc_to_ns(u64 cyc, u32 mult, u32 shift)",
            "{",
            "\treturn (cyc * mult) >> shift;",
            "}",
            "notrace int sched_clock_read_retry(unsigned int seq)",
            "{",
            "\treturn raw_read_seqcount_latch_retry(&cd.seq, seq);",
            "}",
            "unsigned long long noinstr sched_clock_noinstr(void)",
            "{",
            "\tstruct clock_read_data *rd;",
            "\tunsigned int seq;",
            "\tu64 cyc, res;",
            "",
            "\tdo {",
            "\t\tseq = raw_read_seqcount_latch(&cd.seq);",
            "\t\trd = cd.read_data + (seq & 1);",
            "",
            "\t\tcyc = (rd->read_sched_clock() - rd->epoch_cyc) &",
            "\t\t      rd->sched_clock_mask;",
            "\t\tres = rd->epoch_ns + cyc_to_ns(cyc, rd->mult, rd->shift);",
            "\t} while (raw_read_seqcount_latch_retry(&cd.seq, seq));",
            "",
            "\treturn res;",
            "}",
            "unsigned long long notrace sched_clock(void)",
            "{",
            "\tunsigned long long ns;",
            "\tpreempt_disable_notrace();",
            "\tns = sched_clock_noinstr();",
            "\tpreempt_enable_notrace();",
            "\treturn ns;",
            "}",
            "static void update_clock_read_data(struct clock_read_data *rd)",
            "{",
            "\t/* update the backup (odd) copy with the new data */",
            "\tcd.read_data[1] = *rd;",
            "",
            "\t/* steer readers towards the odd copy */",
            "\traw_write_seqcount_latch(&cd.seq);",
            "",
            "\t/* now its safe for us to update the normal (even) copy */",
            "\tcd.read_data[0] = *rd;",
            "",
            "\t/* switch readers back to the even copy */",
            "\traw_write_seqcount_latch(&cd.seq);",
            "}",
            "static void update_sched_clock(void)",
            "{",
            "\tu64 cyc;",
            "\tu64 ns;",
            "\tstruct clock_read_data rd;",
            "",
            "\trd = cd.read_data[0];",
            "",
            "\tcyc = cd.actual_read_sched_clock();",
            "\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);",
            "",
            "\trd.epoch_ns = ns;",
            "\trd.epoch_cyc = cyc;",
            "",
            "\tupdate_clock_read_data(&rd);",
            "}",
            "static enum hrtimer_restart sched_clock_poll(struct hrtimer *hrt)",
            "{",
            "\tupdate_sched_clock();",
            "\thrtimer_forward_now(hrt, cd.wrap_kt);",
            "",
            "\treturn HRTIMER_RESTART;",
            "}",
            "void __init",
            "sched_clock_register(u64 (*read)(void), int bits, unsigned long rate)",
            "{",
            "\tu64 res, wrap, new_mask, new_epoch, cyc, ns;",
            "\tu32 new_mult, new_shift;",
            "\tunsigned long r, flags;",
            "\tchar r_unit;",
            "\tstruct clock_read_data rd;",
            "",
            "\tif (cd.rate > rate)",
            "\t\treturn;",
            "",
            "\t/* Cannot register a sched_clock with interrupts on */",
            "\tlocal_irq_save(flags);",
            "",
            "\t/* Calculate the mult/shift to convert counter ticks to ns. */",
            "\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, NSEC_PER_SEC, 3600);",
            "",
            "\tnew_mask = CLOCKSOURCE_MASK(bits);",
            "\tcd.rate = rate;",
            "",
            "\t/* Calculate how many nanosecs until we risk wrapping */",
            "\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, NULL);",
            "\tcd.wrap_kt = ns_to_ktime(wrap);",
            "",
            "\trd = cd.read_data[0];",
            "",
            "\t/* Update epoch for new counter and update 'epoch_ns' from old counter*/",
            "\tnew_epoch = read();",
            "\tcyc = cd.actual_read_sched_clock();",
            "\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);",
            "\tcd.actual_read_sched_clock = read;",
            "",
            "\trd.read_sched_clock\t= read;",
            "\trd.sched_clock_mask\t= new_mask;",
            "\trd.mult\t\t\t= new_mult;",
            "\trd.shift\t\t= new_shift;",
            "\trd.epoch_cyc\t\t= new_epoch;",
            "\trd.epoch_ns\t\t= ns;",
            "",
            "\tupdate_clock_read_data(&rd);",
            "",
            "\tif (sched_clock_timer.function != NULL) {",
            "\t\t/* update timeout for clock wrap */",
            "\t\thrtimer_start(&sched_clock_timer, cd.wrap_kt,",
            "\t\t\t      HRTIMER_MODE_REL_HARD);",
            "\t}",
            "",
            "\tr = rate;",
            "\tif (r >= 4000000) {",
            "\t\tr = DIV_ROUND_CLOSEST(r, 1000000);",
            "\t\tr_unit = 'M';",
            "\t} else if (r >= 4000) {",
            "\t\tr = DIV_ROUND_CLOSEST(r, 1000);",
            "\t\tr_unit = 'k';",
            "\t} else {",
            "\t\tr_unit = ' ';",
            "\t}",
            "",
            "\t/* Calculate the ns resolution of this counter */",
            "\tres = cyc_to_ns(1ULL, new_mult, new_shift);",
            "",
            "\tpr_info(\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\",",
            "\t\tbits, r, r_unit, res, wrap);",
            "",
            "\t/* Enable IRQ time accounting if we have a fast enough sched_clock() */",
            "\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))",
            "\t\tenable_sched_clock_irqtime();",
            "",
            "\tlocal_irq_restore(flags);",
            "",
            "\tpr_debug(\"Registered %pS as sched_clock source\\n\", read);",
            "}"
          ],
          "function_name": "jiffy_sched_clock_read, cyc_to_ns, sched_clock_read_retry, sched_clock_noinstr, sched_clock, update_clock_read_data, update_sched_clock, sched_clock_poll, sched_clock_register",
          "description": "实现调度时钟读取逻辑，包含周期到纳秒转换、时钟数据更新、定时器回调及注册接口，支持多版本读取数据的原子更新和时钟包装检测",
          "similarity": 0.5678273439407349
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/sched_clock.c",
          "start_line": 1,
          "end_line": 51,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Generic sched_clock() support, to extend low level hardware time",
            " * counters to full 64-bit ns values.",
            " */",
            "#include <linux/clocksource.h>",
            "#include <linux/init.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ktime.h>",
            "#include <linux/kernel.h>",
            "#include <linux/math.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/bitops.h>",
            "",
            "#include \"timekeeping.h\"",
            "",
            "/**",
            " * struct clock_data - all data needed for sched_clock() (including",
            " *                     registration of a new clock source)",
            " *",
            " * @seq:\t\tSequence counter for protecting updates. The lowest",
            " *\t\t\tbit is the index for @read_data.",
            " * @read_data:\t\tData required to read from sched_clock.",
            " * @wrap_kt:\t\tDuration for which clock can run before wrapping.",
            " * @rate:\t\tTick rate of the registered clock.",
            " * @actual_read_sched_clock: Registered hardware level clock read function.",
            " *",
            " * The ordering of this structure has been chosen to optimize cache",
            " * performance. In particular 'seq' and 'read_data[0]' (combined) should fit",
            " * into a single 64-byte cache line.",
            " */",
            "struct clock_data {",
            "\tseqcount_latch_t\tseq;",
            "\tstruct clock_read_data\tread_data[2];",
            "\tktime_t\t\t\twrap_kt;",
            "\tunsigned long\t\trate;",
            "",
            "\tu64 (*actual_read_sched_clock)(void);",
            "};",
            "",
            "static struct hrtimer sched_clock_timer;",
            "static int irqtime = -1;",
            "",
            "core_param(irqtime, irqtime, int, 0400);",
            ""
          ],
          "function_name": null,
          "description": "定义调度时钟所需的数据结构和全局变量，其中struct clock_data用于存储时钟读取数据、序列计数器、包装时间、速率及实际读取函数指针，通过结构体布局优化缓存性能",
          "similarity": 0.5432966947555542
        }
      ]
    },
    {
      "source_file": "kernel/time/timer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:57:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\timer.c`\n\n---\n\n# `time/timer.c` 技术文档\n\n## 1. 文件概述\n\n`time/timer.c` 是 Linux 内核中实现**内核定时器子系统**的核心文件，负责管理基于**定时器轮（timer wheel）** 的动态定时器机制。该文件提供了高效、可扩展的定时器调度框架，支持高精度超时处理、SMP（对称多处理）环境下的 per-CPU 定时器管理，以及与 NO_HZ（动态 tick）节能机制的集成。其设计目标是在保证大多数超时场景（如网络、I/O 超时）性能的同时，通过多级粒度结构避免传统定时器轮中频繁的级联（cascading）操作，从而提升系统可扩展性。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`jiffies_64`**：全局 64 位 jiffies 计数器，记录自系统启动以来的时钟滴答数，对齐缓存行以优化 SMP 访问。\n- **多级定时器轮（Timer Wheel）结构**：\n  - 由 `LVL_DEPTH` 层（通常为 8 或 9）组成，每层包含 `LVL_SIZE`（64）个桶（buckets）。\n  - 每层具有不同的时间粒度（granularity），随层级升高而增大。\n- **定时器基础（Timer Bases）**：\n  - `BASE_STD`：标准定时器基础，用于普通定时器。\n  - `BASE_DEF`：可延迟定时器基础（仅当 `CONFIG_NO_HZ_COMMON` 启用时存在），用于在 CPU 空闲时可推迟执行的定时器。\n\n### 关键宏定义\n- `LVL_CLK_SHIFT` / `LVL_CLK_DIV`：定义层级间的时间粒度缩放因子（默认为 8 倍）。\n- `LVL_GRAN(n)`：第 `n` 层的时间粒度（单位：jiffies）。\n- `LVL_START(n)`：第 `n` 层的起始偏移时间，用于计算定时器应插入的层级。\n- `WHEEL_TIMEOUT_CUTOFF` / `WHEEL_TIMEOUT_MAX`：定时器轮的最大支持超时时间（约 12 天 @ HZ=1000）。\n\n### 主要功能\n- 定时器的注册（`add_timer`）、删除（`del_timer`）和修改（`mod_timer`）。\n- 定时器到期处理（软中断上下文执行）。\n- 与 tick 管理子系统（`tick.h`）和 NO_HZ 模式协同工作。\n- 提供 `sys_sysinfo` 系统调用的底层支持。\n\n## 3. 关键实现\n\n### 多级定时器轮算法\n- **层级设计**：定时器根据其到期时间的远近被分配到不同层级。近到期定时器放入低层（高精度），远到期放入高层（低精度）。\n- **无级联机制**：与经典定时器轮不同，本实现**不进行定时器的级联迁移**。高层定时器到期时直接触发，牺牲少量精度换取显著性能提升。\n- **隐式批处理**：高层的粗粒度天然实现超时事件的批处理，减少中断和软中断开销。\n- **超时截断**：超过 `WHEEL_TIMEOUT_MAX` 的定时器会被强制设为最大支持超时值，实测表明实际使用中超时极少超过 5 天。\n\n### 粒度与范围（以 HZ=1000 为例）\n| 层级 | 偏移 | 粒度 | 范围 |\n|------|------|------|------|\n| 0 | 0 | 1 ms | 0 – 63 ms |\n| 1 | 64 | 8 ms | 64 – 511 ms |\n| ... | ... | ... | ... |\n| 8 | 512 | ~4 小时 | ~1 天 – ~12 天 |\n\n### NO_HZ 支持\n- 当启用 `CONFIG_NO_HZ_COMMON` 时，系统维护**两个独立的定时器轮**：\n  - `BASE_STD`：标准定时器，必须准时触发。\n  - `BASE_DEF`：可延迟定时器，在 CPU 进入空闲状态时可推迟执行，用于节能。\n\n### SMP 优化\n- 定时器默认绑定到注册时的 CPU，利用 per-CPU 数据结构减少锁竞争。\n- `jiffies_64` 使用 `__cacheline_aligned_in_smp` 对齐，避免 false sharing。\n\n## 4. 依赖关系\n\n### 头文件依赖\n- **时间子系统**：`<linux/time.h>`, `<linux/jiffies.h>`, `<asm/timex.h>`\n- **调度与中断**：`<linux/interrupt.h>`, `<linux/irq_work.h>`, `<linux/sched/*.h>`\n- **内存管理**：`<linux/slab.h>`, `<linux/mm.h>`\n- **系统调用**：`<linux/syscalls.h>`, `<linux/uaccess.h>`\n- **内部模块**：`\"tick-internal.h\"`（tick 管理）、`<trace/events/timer.h>`（跟踪点）\n\n### 内核子系统交互\n- **Tick 管理**：通过 `tick.h` 接口获取时钟事件，驱动定时器轮推进。\n- **软中断**：定时器到期回调在 `TIMER_SOFTIRQ` 软中断上下文中执行。\n- **POSIX 定时器**：为 `<linux/posix-timers.h>` 提供底层支持。\n- **CPU 热插拔**：通过 `cpu.h` 处理 CPU 上下线时的定时器迁移。\n- **电源管理**：与 `NO_HZ` 和 `sched/nohz.h` 协同实现动态 tick。\n\n## 5. 使用场景\n\n- **内核超时机制**：网络协议栈（TCP 重传、连接超时）、块设备 I/O 超时、文件系统缓存回收等。\n- **延迟执行任务**：通过 `mod_timer` 实现延迟工作队列（如 `delayed_work`）。\n- **系统时间维护**：为 `jiffies` 和 `get_jiffies_64()` 提供原子更新。\n- **用户空间接口**：支撑 `sysinfo` 系统调用返回 uptime、负载等信息。\n- **高精度定时需求**：短超时（<64ms @ HZ=1000）可获得毫秒级精度，满足实时性要求。\n- **低功耗系统**：在 `NO_HZ_IDLE` 或 `NO_HZ_FULL` 模式下，通过 `BASE_DEF` 减少不必要的 tick 中断。",
      "similarity": 0.5640945434570312,
      "chunks": [
        {
          "chunk_id": 9,
          "file_path": "kernel/time/timer.c",
          "start_line": 1883,
          "end_line": 2004,
          "content": [
            "static u64 cmp_next_hrtimer_event(u64 basem, u64 expires)",
            "{",
            "\tu64 nextevt = hrtimer_get_next_event();",
            "",
            "\t/*",
            "\t * If high resolution timers are enabled",
            "\t * hrtimer_get_next_event() returns KTIME_MAX.",
            "\t */",
            "\tif (expires <= nextevt)",
            "\t\treturn expires;",
            "",
            "\t/*",
            "\t * If the next timer is already expired, return the tick base",
            "\t * time so the tick is fired immediately.",
            "\t */",
            "\tif (nextevt <= basem)",
            "\t\treturn basem;",
            "",
            "\t/*",
            "\t * Round up to the next jiffie. High resolution timers are",
            "\t * off, so the hrtimers are expired in the tick and we need to",
            "\t * make sure that this tick really expires the timer to avoid",
            "\t * a ping pong of the nohz stop code.",
            "\t *",
            "\t * Use DIV_ROUND_UP_ULL to prevent gcc calling __divdi3",
            "\t */",
            "\treturn DIV_ROUND_UP_ULL(nextevt, TICK_NSEC) * TICK_NSEC;",
            "}",
            "u64 get_next_timer_interrupt(unsigned long basej, u64 basem)",
            "{",
            "\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);",
            "\tu64 expires = KTIME_MAX;",
            "\tunsigned long nextevt;",
            "",
            "\t/*",
            "\t * Pretend that there is no timer pending if the cpu is offline.",
            "\t * Possible pending timers will be migrated later to an active cpu.",
            "\t */",
            "\tif (cpu_is_offline(smp_processor_id()))",
            "\t\treturn expires;",
            "",
            "\traw_spin_lock(&base->lock);",
            "\tif (base->next_expiry_recalc)",
            "\t\tbase->next_expiry = __next_timer_interrupt(base);",
            "\tnextevt = base->next_expiry;",
            "",
            "\t/*",
            "\t * We have a fresh next event. Check whether we can forward the",
            "\t * base. We can only do that when @basej is past base->clk",
            "\t * otherwise we might rewind base->clk.",
            "\t */",
            "\tif (time_after(basej, base->clk)) {",
            "\t\tif (time_after(nextevt, basej))",
            "\t\t\tbase->clk = basej;",
            "\t\telse if (time_after(nextevt, base->clk))",
            "\t\t\tbase->clk = nextevt;",
            "\t}",
            "",
            "\tif (time_before_eq(nextevt, basej)) {",
            "\t\texpires = basem;",
            "\t\tbase->is_idle = false;",
            "\t} else {",
            "\t\tif (base->timers_pending)",
            "\t\t\texpires = basem + (u64)(nextevt - basej) * TICK_NSEC;",
            "\t\t/*",
            "\t\t * If we expect to sleep more than a tick, mark the base idle.",
            "\t\t * Also the tick is stopped so any added timer must forward",
            "\t\t * the base clk itself to keep granularity small. This idle",
            "\t\t * logic is only maintained for the BASE_STD base, deferrable",
            "\t\t * timers may still see large granularity skew (by design).",
            "\t\t */",
            "\t\tif ((expires - basem) > TICK_NSEC)",
            "\t\t\tbase->is_idle = true;",
            "\t}",
            "\traw_spin_unlock(&base->lock);",
            "",
            "\treturn cmp_next_hrtimer_event(basem, expires);",
            "}",
            "void timer_clear_idle(void)",
            "{",
            "\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);",
            "",
            "\t/*",
            "\t * We do this unlocked. The worst outcome is a remote enqueue sending",
            "\t * a pointless IPI, but taking the lock would just make the window for",
            "\t * sending the IPI a few instructions smaller for the cost of taking",
            "\t * the lock in the exit from idle path.",
            "\t */",
            "\tbase->is_idle = false;",
            "}",
            "static inline void __run_timers(struct timer_base *base)",
            "{",
            "\tstruct hlist_head heads[LVL_DEPTH];",
            "\tint levels;",
            "",
            "\tif (time_before(jiffies, base->next_expiry))",
            "\t\treturn;",
            "",
            "\ttimer_base_lock_expiry(base);",
            "\traw_spin_lock_irq(&base->lock);",
            "",
            "\twhile (time_after_eq(jiffies, base->clk) &&",
            "\t       time_after_eq(jiffies, base->next_expiry)) {",
            "\t\tlevels = collect_expired_timers(base, heads);",
            "\t\t/*",
            "\t\t * The two possible reasons for not finding any expired",
            "\t\t * timer at this clk are that all matching timers have been",
            "\t\t * dequeued or no timer has been queued since",
            "\t\t * base::next_expiry was set to base::clk +",
            "\t\t * NEXT_TIMER_MAX_DELTA.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(!levels && !base->next_expiry_recalc",
            "\t\t\t     && base->timers_pending);",
            "\t\tbase->clk++;",
            "\t\tbase->next_expiry = __next_timer_interrupt(base);",
            "",
            "\t\twhile (levels--)",
            "\t\t\texpire_timers(base, heads + levels);",
            "\t}",
            "\traw_spin_unlock_irq(&base->lock);",
            "\ttimer_base_unlock_expiry(base);",
            "}"
          ],
          "function_name": "cmp_next_hrtimer_event, get_next_timer_interrupt, timer_clear_idle, __run_timers",
          "description": "实现高精度定时器协调逻辑，cmp_next_hrtimer_event比较下一个高精度定时器事件；get_next_timer_interrupt计算下一中断时间；timer_clear_idle清除空闲标记；__run_timers驱动定时器执行流程，处理多级桶中到期定时器。",
          "similarity": 0.5953510403633118
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/time/timer.c",
          "start_line": 2190,
          "end_line": 2292,
          "content": [
            "signed long __sched schedule_timeout_killable(signed long timeout)",
            "{",
            "\t__set_current_state(TASK_KILLABLE);",
            "\treturn schedule_timeout(timeout);",
            "}",
            "signed long __sched schedule_timeout_uninterruptible(signed long timeout)",
            "{",
            "\t__set_current_state(TASK_UNINTERRUPTIBLE);",
            "\treturn schedule_timeout(timeout);",
            "}",
            "signed long __sched schedule_timeout_idle(signed long timeout)",
            "{",
            "\t__set_current_state(TASK_IDLE);",
            "\treturn schedule_timeout(timeout);",
            "}",
            "static void migrate_timer_list(struct timer_base *new_base, struct hlist_head *head)",
            "{",
            "\tstruct timer_list *timer;",
            "\tint cpu = new_base->cpu;",
            "",
            "\twhile (!hlist_empty(head)) {",
            "\t\ttimer = hlist_entry(head->first, struct timer_list, entry);",
            "\t\tdetach_timer(timer, false);",
            "\t\ttimer->flags = (timer->flags & ~TIMER_BASEMASK) | cpu;",
            "\t\tinternal_add_timer(new_base, timer);",
            "\t}",
            "}",
            "int timers_prepare_cpu(unsigned int cpu)",
            "{",
            "\tstruct timer_base *base;",
            "\tint b;",
            "",
            "\tfor (b = 0; b < NR_BASES; b++) {",
            "\t\tbase = per_cpu_ptr(&timer_bases[b], cpu);",
            "\t\tbase->clk = jiffies;",
            "\t\tbase->next_expiry = base->clk + NEXT_TIMER_MAX_DELTA;",
            "\t\tbase->next_expiry_recalc = false;",
            "\t\tbase->timers_pending = false;",
            "\t\tbase->is_idle = false;",
            "\t}",
            "\treturn 0;",
            "}",
            "int timers_dead_cpu(unsigned int cpu)",
            "{",
            "\tstruct timer_base *old_base;",
            "\tstruct timer_base *new_base;",
            "\tint b, i;",
            "",
            "\tfor (b = 0; b < NR_BASES; b++) {",
            "\t\told_base = per_cpu_ptr(&timer_bases[b], cpu);",
            "\t\tnew_base = get_cpu_ptr(&timer_bases[b]);",
            "\t\t/*",
            "\t\t * The caller is globally serialized and nobody else",
            "\t\t * takes two locks at once, deadlock is not possible.",
            "\t\t */",
            "\t\traw_spin_lock_irq(&new_base->lock);",
            "\t\traw_spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);",
            "",
            "\t\t/*",
            "\t\t * The current CPUs base clock might be stale. Update it",
            "\t\t * before moving the timers over.",
            "\t\t */",
            "\t\tforward_timer_base(new_base);",
            "",
            "\t\tWARN_ON_ONCE(old_base->running_timer);",
            "\t\told_base->running_timer = NULL;",
            "",
            "\t\tfor (i = 0; i < WHEEL_SIZE; i++)",
            "\t\t\tmigrate_timer_list(new_base, old_base->vectors + i);",
            "",
            "\t\traw_spin_unlock(&old_base->lock);",
            "\t\traw_spin_unlock_irq(&new_base->lock);",
            "\t\tput_cpu_ptr(&timer_bases);",
            "\t}",
            "\treturn 0;",
            "}",
            "static void __init init_timer_cpu(int cpu)",
            "{",
            "\tstruct timer_base *base;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < NR_BASES; i++) {",
            "\t\tbase = per_cpu_ptr(&timer_bases[i], cpu);",
            "\t\tbase->cpu = cpu;",
            "\t\traw_spin_lock_init(&base->lock);",
            "\t\tbase->clk = jiffies;",
            "\t\tbase->next_expiry = base->clk + NEXT_TIMER_MAX_DELTA;",
            "\t\ttimer_base_init_expiry_lock(base);",
            "\t}",
            "}",
            "static void __init init_timer_cpus(void)",
            "{",
            "\tint cpu;",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tinit_timer_cpu(cpu);",
            "}",
            "void __init init_timers(void)",
            "{",
            "\tinit_timer_cpus();",
            "\tposix_cputimers_init_work();",
            "\topen_softirq(TIMER_SOFTIRQ, run_timer_softirq);",
            "}"
          ],
          "function_name": "schedule_timeout_killable, schedule_timeout_uninterruptible, schedule_timeout_idle, migrate_timer_list, timers_prepare_cpu, timers_dead_cpu, init_timer_cpu, init_timer_cpus, init_timers",
          "description": "该代码段实现Linux内核中的定时器管理和进程睡眠控制功能。  \n三个`schedule_timeout_*`函数通过设置任务状态（可中断/不可中断/空闲）实现进程睡眠并返回超时值；`migrate_timer_list`及`timers_prepare_cpu`/`timers_dead_cpu`系列函数负责多CPU环境下定时器列表的迁移与初始化，保障定时器在CPU热插拔时的数据一致性。  \n其余函数（`init_timer_cpu`/`init_timer_cpus`/`init_timers`）完成全局定时器基础结构的初始化，构建多核系统中定时器调度所需的底层资源。",
          "similarity": 0.5860073566436768
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/time/timer.c",
          "start_line": 1154,
          "end_line": 1268,
          "content": [
            "int mod_timer_pending(struct timer_list *timer, unsigned long expires)",
            "{",
            "\treturn __mod_timer(timer, expires, MOD_TIMER_PENDING_ONLY);",
            "}",
            "int mod_timer(struct timer_list *timer, unsigned long expires)",
            "{",
            "\treturn __mod_timer(timer, expires, 0);",
            "}",
            "int timer_reduce(struct timer_list *timer, unsigned long expires)",
            "{",
            "\treturn __mod_timer(timer, expires, MOD_TIMER_REDUCE);",
            "}",
            "void add_timer(struct timer_list *timer)",
            "{",
            "\tif (WARN_ON_ONCE(timer_pending(timer)))",
            "\t\treturn;",
            "\t__mod_timer(timer, timer->expires, MOD_TIMER_NOTPENDING);",
            "}",
            "void add_timer_on(struct timer_list *timer, int cpu)",
            "{",
            "\tstruct timer_base *new_base, *base;",
            "\tunsigned long flags;",
            "",
            "\tdebug_assert_init(timer);",
            "",
            "\tif (WARN_ON_ONCE(timer_pending(timer)))",
            "\t\treturn;",
            "",
            "\tnew_base = get_timer_cpu_base(timer->flags, cpu);",
            "",
            "\t/*",
            "\t * If @timer was on a different CPU, it should be migrated with the",
            "\t * old base locked to prevent other operations proceeding with the",
            "\t * wrong base locked.  See lock_timer_base().",
            "\t */",
            "\tbase = lock_timer_base(timer, &flags);",
            "\t/*",
            "\t * Has @timer been shutdown? This needs to be evaluated while",
            "\t * holding base lock to prevent a race against the shutdown code.",
            "\t */",
            "\tif (!timer->function)",
            "\t\tgoto out_unlock;",
            "",
            "\tif (base != new_base) {",
            "\t\ttimer->flags |= TIMER_MIGRATING;",
            "",
            "\t\traw_spin_unlock(&base->lock);",
            "\t\tbase = new_base;",
            "\t\traw_spin_lock(&base->lock);",
            "\t\tWRITE_ONCE(timer->flags,",
            "\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);",
            "\t}",
            "\tforward_timer_base(base);",
            "",
            "\tdebug_timer_activate(timer);",
            "\tinternal_add_timer(base, timer);",
            "out_unlock:",
            "\traw_spin_unlock_irqrestore(&base->lock, flags);",
            "}",
            "static int __timer_delete(struct timer_list *timer, bool shutdown)",
            "{",
            "\tstruct timer_base *base;",
            "\tunsigned long flags;",
            "\tint ret = 0;",
            "",
            "\tdebug_assert_init(timer);",
            "",
            "\t/*",
            "\t * If @shutdown is set then the lock has to be taken whether the",
            "\t * timer is pending or not to protect against a concurrent rearm",
            "\t * which might hit between the lockless pending check and the lock",
            "\t * aquisition. By taking the lock it is ensured that such a newly",
            "\t * enqueued timer is dequeued and cannot end up with",
            "\t * timer->function == NULL in the expiry code.",
            "\t *",
            "\t * If timer->function is currently executed, then this makes sure",
            "\t * that the callback cannot requeue the timer.",
            "\t */",
            "\tif (timer_pending(timer) || shutdown) {",
            "\t\tbase = lock_timer_base(timer, &flags);",
            "\t\tret = detach_if_pending(timer, base, true);",
            "\t\tif (shutdown)",
            "\t\t\ttimer->function = NULL;",
            "\t\traw_spin_unlock_irqrestore(&base->lock, flags);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "int timer_delete(struct timer_list *timer)",
            "{",
            "\treturn __timer_delete(timer, false);",
            "}",
            "int timer_shutdown(struct timer_list *timer)",
            "{",
            "\treturn __timer_delete(timer, true);",
            "}",
            "static int __try_to_del_timer_sync(struct timer_list *timer, bool shutdown)",
            "{",
            "\tstruct timer_base *base;",
            "\tunsigned long flags;",
            "\tint ret = -1;",
            "",
            "\tdebug_assert_init(timer);",
            "",
            "\tbase = lock_timer_base(timer, &flags);",
            "",
            "\tif (base->running_timer != timer)",
            "\t\tret = detach_if_pending(timer, base, true);",
            "\tif (shutdown)",
            "\t\ttimer->function = NULL;",
            "",
            "\traw_spin_unlock_irqrestore(&base->lock, flags);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "mod_timer_pending, mod_timer, timer_reduce, add_timer, add_timer_on, __timer_delete, timer_delete, timer_shutdown, __try_to_del_timer_sync",
          "description": "提供多个定时器控制接口函数，包括mod_timer_pending、mod_timer、timer_reduce、add_timer、add_timer_on、timer_delete、timer_shutdown及__try_to_del_timer_sync。其中add_timer_on支持跨CPU调度，timer_delete/timer_shutdown用于安全移除定时器，__try_to_del_timer_sync尝试同步删除定时器。",
          "similarity": 0.5833021402359009
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/time/timer.c",
          "start_line": 2030,
          "end_line": 2130,
          "content": [
            "static __latent_entropy void run_timer_softirq(struct softirq_action *h)",
            "{",
            "\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);",
            "",
            "\t__run_timers(base);",
            "\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON))",
            "\t\t__run_timers(this_cpu_ptr(&timer_bases[BASE_DEF]));",
            "}",
            "static void run_local_timers(void)",
            "{",
            "\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);",
            "",
            "\thrtimer_run_queues();",
            "\t/* Raise the softirq only if required. */",
            "\tif (time_before(jiffies, base->next_expiry)) {",
            "\t\tif (!IS_ENABLED(CONFIG_NO_HZ_COMMON))",
            "\t\t\treturn;",
            "\t\t/* CPU is awake, so check the deferrable base. */",
            "\t\tbase++;",
            "\t\tif (time_before(jiffies, base->next_expiry))",
            "\t\t\treturn;",
            "\t}",
            "\traise_timer_softirq(TIMER_SOFTIRQ);",
            "}",
            "void update_process_times(int user_tick)",
            "{",
            "\tstruct task_struct *p = current;",
            "",
            "\t/* Note: this timer irq context must be accounted for as well. */",
            "\taccount_process_tick(p, user_tick);",
            "\trun_local_timers();",
            "\trcu_sched_clock_irq(user_tick);",
            "#ifdef CONFIG_IRQ_WORK",
            "\tif (in_irq())",
            "\t\tirq_work_tick();",
            "#endif",
            "\tsched_tick();",
            "\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))",
            "\t\trun_posix_cpu_timers();",
            "}",
            "static void process_timeout(struct timer_list *t)",
            "{",
            "\tstruct process_timer *timeout = from_timer(timeout, t, timer);",
            "",
            "\twake_up_process(timeout->task);",
            "}",
            "signed long __sched schedule_timeout(signed long timeout)",
            "{",
            "\tstruct process_timer timer;",
            "\tunsigned long expire;",
            "",
            "\tswitch (timeout)",
            "\t{",
            "\tcase MAX_SCHEDULE_TIMEOUT:",
            "\t\t/*",
            "\t\t * These two special cases are useful to be comfortable",
            "\t\t * in the caller. Nothing more. We could take",
            "\t\t * MAX_SCHEDULE_TIMEOUT from one of the negative value",
            "\t\t * but I' d like to return a valid offset (>=0) to allow",
            "\t\t * the caller to do everything it want with the retval.",
            "\t\t */",
            "\t\tschedule();",
            "\t\tgoto out;",
            "\tdefault:",
            "\t\t/*",
            "\t\t * Another bit of PARANOID. Note that the retval will be",
            "\t\t * 0 since no piece of kernel is supposed to do a check",
            "\t\t * for a negative retval of schedule_timeout() (since it",
            "\t\t * should never happens anyway). You just have the printk()",
            "\t\t * that will tell you if something is gone wrong and where.",
            "\t\t */",
            "\t\tif (timeout < 0) {",
            "\t\t\tprintk(KERN_ERR \"schedule_timeout: wrong timeout \"",
            "\t\t\t\t\"value %lx\\n\", timeout);",
            "\t\t\tdump_stack();",
            "\t\t\t__set_current_state(TASK_RUNNING);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\texpire = timeout + jiffies;",
            "",
            "\ttimer.task = current;",
            "\ttimer_setup_on_stack(&timer.timer, process_timeout, 0);",
            "\t__mod_timer(&timer.timer, expire, MOD_TIMER_NOTPENDING);",
            "\tschedule();",
            "\tdel_timer_sync(&timer.timer);",
            "",
            "\t/* Remove the timer from the object tracker */",
            "\tdestroy_timer_on_stack(&timer.timer);",
            "",
            "\ttimeout = expire - jiffies;",
            "",
            " out:",
            "\treturn timeout < 0 ? 0 : timeout;",
            "}",
            "signed long __sched schedule_timeout_interruptible(signed long timeout)",
            "{",
            "\t__set_current_state(TASK_INTERRUPTIBLE);",
            "\treturn schedule_timeout(timeout);",
            "}"
          ],
          "function_name": "run_timer_softirq, run_local_timers, update_process_times, process_timeout, schedule_timeout, schedule_timeout_interruptible",
          "description": "该代码段核心功能是处理定时器相关操作，涵盖软中断处理、本地定时器管理、进程时间更新及休眠超时控制。  \n`run_timer_softirq`和`run_local_timers`分别用于处理软中断中的定时器队列和本地定时器检查，`update_process_times`更新进程时间并触发本地定时器，`schedule_timeout`系列通过定时器实现进程休眠与超时唤醒。  \n上下文不完整：部分关键函数（如`__run_timers`、`hrtimer_run_queues`）的实现未展示，依赖外部知识理解其行为。",
          "similarity": 0.5739123225212097
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/timer.c",
          "start_line": 460,
          "end_line": 560,
          "content": [
            "unsigned long __round_jiffies_up_relative(unsigned long j, int cpu)",
            "{",
            "\tunsigned long j0 = jiffies;",
            "",
            "\t/* Use j0 because jiffies might change while we run */",
            "\treturn round_jiffies_common(j + j0, cpu, true) - j0;",
            "}",
            "unsigned long round_jiffies_up(unsigned long j)",
            "{",
            "\treturn round_jiffies_common(j, raw_smp_processor_id(), true);",
            "}",
            "unsigned long round_jiffies_up_relative(unsigned long j)",
            "{",
            "\treturn __round_jiffies_up_relative(j, raw_smp_processor_id());",
            "}",
            "static inline unsigned int timer_get_idx(struct timer_list *timer)",
            "{",
            "\treturn (timer->flags & TIMER_ARRAYMASK) >> TIMER_ARRAYSHIFT;",
            "}",
            "static inline void timer_set_idx(struct timer_list *timer, unsigned int idx)",
            "{",
            "\ttimer->flags = (timer->flags & ~TIMER_ARRAYMASK) |",
            "\t\t\tidx << TIMER_ARRAYSHIFT;",
            "}",
            "static inline unsigned calc_index(unsigned long expires, unsigned lvl,",
            "\t\t\t\t  unsigned long *bucket_expiry)",
            "{",
            "",
            "\t/*",
            "\t * The timer wheel has to guarantee that a timer does not fire",
            "\t * early. Early expiry can happen due to:",
            "\t * - Timer is armed at the edge of a tick",
            "\t * - Truncation of the expiry time in the outer wheel levels",
            "\t *",
            "\t * Round up with level granularity to prevent this.",
            "\t */",
            "\texpires = (expires >> LVL_SHIFT(lvl)) + 1;",
            "\t*bucket_expiry = expires << LVL_SHIFT(lvl);",
            "\treturn LVL_OFFS(lvl) + (expires & LVL_MASK);",
            "}",
            "static int calc_wheel_index(unsigned long expires, unsigned long clk,",
            "\t\t\t    unsigned long *bucket_expiry)",
            "{",
            "\tunsigned long delta = expires - clk;",
            "\tunsigned int idx;",
            "",
            "\tif (delta < LVL_START(1)) {",
            "\t\tidx = calc_index(expires, 0, bucket_expiry);",
            "\t} else if (delta < LVL_START(2)) {",
            "\t\tidx = calc_index(expires, 1, bucket_expiry);",
            "\t} else if (delta < LVL_START(3)) {",
            "\t\tidx = calc_index(expires, 2, bucket_expiry);",
            "\t} else if (delta < LVL_START(4)) {",
            "\t\tidx = calc_index(expires, 3, bucket_expiry);",
            "\t} else if (delta < LVL_START(5)) {",
            "\t\tidx = calc_index(expires, 4, bucket_expiry);",
            "\t} else if (delta < LVL_START(6)) {",
            "\t\tidx = calc_index(expires, 5, bucket_expiry);",
            "\t} else if (delta < LVL_START(7)) {",
            "\t\tidx = calc_index(expires, 6, bucket_expiry);",
            "\t} else if (LVL_DEPTH > 8 && delta < LVL_START(8)) {",
            "\t\tidx = calc_index(expires, 7, bucket_expiry);",
            "\t} else if ((long) delta < 0) {",
            "\t\tidx = clk & LVL_MASK;",
            "\t\t*bucket_expiry = clk;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Force expire obscene large timeouts to expire at the",
            "\t\t * capacity limit of the wheel.",
            "\t\t */",
            "\t\tif (delta >= WHEEL_TIMEOUT_CUTOFF)",
            "\t\t\texpires = clk + WHEEL_TIMEOUT_MAX;",
            "",
            "\t\tidx = calc_index(expires, LVL_DEPTH - 1, bucket_expiry);",
            "\t}",
            "\treturn idx;",
            "}",
            "static void",
            "trigger_dyntick_cpu(struct timer_base *base, struct timer_list *timer)",
            "{",
            "\tif (!is_timers_nohz_active())",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * TODO: This wants some optimizing similar to the code below, but we",
            "\t * will do that when we switch from push to pull for deferrable timers.",
            "\t */",
            "\tif (timer->flags & TIMER_DEFERRABLE) {",
            "\t\tif (tick_nohz_full_cpu(base->cpu))",
            "\t\t\twake_up_nohz_cpu(base->cpu);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/*",
            "\t * We might have to IPI the remote CPU if the base is idle and the",
            "\t * timer is not deferrable. If the other CPU is on the way to idle",
            "\t * then it can't set base->is_idle as we hold the base lock:",
            "\t */",
            "\tif (base->is_idle)",
            "\t\twake_up_nohz_cpu(base->cpu);",
            "}"
          ],
          "function_name": "__round_jiffies_up_relative, round_jiffies_up, round_jiffies_up_relative, timer_get_idx, timer_set_idx, calc_index, calc_wheel_index, trigger_dyntick_cpu",
          "description": "实现定时器层级索引计算逻辑和动态tick触发机制，通过层级间转换规则确定定时器存储位置，处理非活动CPU上的定时器唤醒需求。",
          "similarity": 0.5733048915863037
        }
      ]
    }
  ]
}