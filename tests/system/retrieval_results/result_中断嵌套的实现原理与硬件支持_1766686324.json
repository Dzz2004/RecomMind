{
  "query": "中断嵌套的实现原理与硬件支持",
  "timestamp": "2025-12-26 02:12:04",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/irq_sim.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:58:53\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\irq_sim.c`\n\n---\n\n# `irq/irq_sim.c` 技术文档\n\n## 1. 文件概述\n\n`irq/irq_sim.c` 实现了一个**中断模拟器（IRQ Simulator）**，用于在 Linux 内核中创建虚拟的中断域（`irq_domain`），以模拟硬件中断行为。该模块主要用于**测试、调试和驱动开发**场景，允许开发者在没有真实硬件中断源的情况下触发和处理中断。它通过 `irq_work` 机制异步处理“模拟中断”，并提供标准的 `irq_chip` 接口，使上层驱动代码可以像使用真实中断一样使用这些虚拟中断。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct irq_sim_work_ctx`**  \n  中断模拟器的工作上下文，包含：\n  - `struct irq_work work`：用于异步处理待处理中断的 irq_work 实例\n  - `int irq_base`：保留字段（当前未使用）\n  - `unsigned int irq_count`：模拟中断的数量\n  - `unsigned long *pending`：位图，标记哪些中断处于 pending 状态\n  - `struct irq_domain *domain`：关联的中断域\n\n- **`struct irq_sim_irq_ctx`**  \n  每个虚拟中断的上下文，包含：\n  - `int irqnum`：保留字段（当前未使用）\n  - `bool enabled`：中断是否已启用（unmask）\n  - `struct irq_sim_work_ctx *work_ctx`：指向工作上下文的指针\n\n- **`struct irq_chip irq_sim_irqchip`**  \n  虚拟中断控制器的实现，提供标准的中断芯片操作接口。\n\n- **`struct irq_domain_ops irq_sim_domain_ops`**  \n  中断域映射操作集，用于虚拟中断号与硬件中断号的映射管理。\n\n### 主要函数\n\n- **`irq_domain_create_sim()`**  \n  创建一个新的中断模拟器域，分配指定数量的虚拟中断。\n\n- **`irq_domain_remove_sim()`**  \n  销毁中断模拟器域，释放相关资源。\n\n- **`devm_irq_domain_create_sim()`**  \n  基于设备资源管理（devres）的中断模拟器创建函数，自动在设备卸载时清理资源。\n\n- **`irq_sim_handle_irq()`**  \n  `irq_work` 的回调函数，遍历 pending 位图并触发对应的虚拟中断。\n\n- **`irq_sim_irqmask()` / `irq_sim_irqunmask()`**  \n  实现中断的屏蔽与解除屏蔽，仅设置 `enabled` 标志。\n\n- **`irq_sim_set_type()`**  \n  设置中断触发类型，仅支持 `IRQ_TYPE_EDGE_RISING` 和 `IRQ_TYPE_EDGE_FALLING`。\n\n- **`irq_sim_get_irqchip_state()` / `irq_sim_set_irqchip_state()`**  \n  查询和设置中断芯片状态（目前仅支持 `IRQCHIP_STATE_PENDING`）。\n\n## 3. 关键实现\n\n### 中断模拟机制\n- 使用 **位图（`pending`）** 记录哪些虚拟中断处于 pending 状态。\n- 当调用 `irq_sim_set_irqchip_state(..., IRQCHIP_STATE_PENDING, true)` 时：\n  - 若中断已启用（`enabled == true`），则在位图中标记对应位。\n  - 同时调用 `irq_work_queue()` 触发异步处理。\n- `irq_work` 回调 `irq_sim_handle_irq()` 遍历位图，对每个 pending 中断：\n  - 清除位图中的对应位。\n  - 通过 `irq_find_mapping()` 获取虚拟中断号。\n  - 调用 `handle_simple_irq()` 触发中断处理流程。\n\n### 中断域管理\n- 使用 **线性映射（`irq_domain_create_linear`）** 创建中断域。\n- 每个虚拟中断在 `map` 时分配独立的 `irq_sim_irq_ctx`，并绑定 `irq_sim_irqchip`。\n- 中断默认设置为 `IRQ_NOREQUEST | IRQ_NOAUTOEN`，防止自动使能和用户空间请求。\n\n### 资源管理\n- `devm_irq_domain_create_sim()` 利用内核的 **设备资源管理（devres）** 机制，在设备移除时自动调用 `irq_domain_remove_sim()`。\n- `irq_domain_remove_sim()` 会同步等待所有 pending 的 `irq_work` 完成（`irq_work_sync()`），确保安全释放内存。\n\n### 中断状态控制\n- 仅当中断处于 **enabled 状态** 时，才允许设置或查询 pending 状态。\n- 不支持电平触发中断，仅支持边沿触发（`IRQ_TYPE_EDGE_BOTH`）。\n\n## 4. 依赖关系\n\n- **`<linux/irq.h>`**：提供中断核心 API（如 `irq_set_chip`、`handle_simple_irq`）。\n- **`<linux/irq_sim.h>`**：定义中断模拟器的公共接口（如 `irq_domain_create_sim` 声明）。\n- **`<linux/irq_work.h>`**：提供 `irq_work` 机制，用于异步中断处理。\n- **`<linux/interrupt.h>`**：提供中断描述符和状态操作函数。\n- **`<linux/slab.h>`**：提供动态内存分配（`kmalloc`/`kzalloc`/`kfree`）。\n- **依赖 `GENERIC_IRQ_CHIP` 和 `IRQ_DOMAIN` 子系统**：作为中断子系统的扩展模块。\n\n## 5. 使用场景\n\n- **驱动开发与测试**：在无硬件环境下验证中断处理逻辑。\n- **虚拟化与仿真**：为虚拟设备提供中断模拟支持。\n- **内核子系统测试**：用于测试中断子系统、电源管理、实时性等模块。\n- **平台无关的中断逻辑验证**：避免依赖特定硬件平台进行中断行为测试。\n- **教学与调试**：帮助理解 Linux 中断处理机制的工作流程。",
      "similarity": 0.6744894981384277,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/irq_sim.c",
          "start_line": 27,
          "end_line": 131,
          "content": [
            "static void irq_sim_irqmask(struct irq_data *data)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);",
            "",
            "\tirq_ctx->enabled = false;",
            "}",
            "static void irq_sim_irqunmask(struct irq_data *data)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);",
            "",
            "\tirq_ctx->enabled = true;",
            "}",
            "static int irq_sim_set_type(struct irq_data *data, unsigned int type)",
            "{",
            "\t/* We only support rising and falling edge trigger types. */",
            "\tif (type & ~IRQ_TYPE_EDGE_BOTH)",
            "\t\treturn -EINVAL;",
            "",
            "\tirqd_set_trigger_type(data, type);",
            "",
            "\treturn 0;",
            "}",
            "static int irq_sim_get_irqchip_state(struct irq_data *data,",
            "\t\t\t\t     enum irqchip_irq_state which, bool *state)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);",
            "\tirq_hw_number_t hwirq = irqd_to_hwirq(data);",
            "",
            "\tswitch (which) {",
            "\tcase IRQCHIP_STATE_PENDING:",
            "\t\tif (irq_ctx->enabled)",
            "\t\t\t*state = test_bit(hwirq, irq_ctx->work_ctx->pending);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int irq_sim_set_irqchip_state(struct irq_data *data,",
            "\t\t\t\t     enum irqchip_irq_state which, bool state)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);",
            "\tirq_hw_number_t hwirq = irqd_to_hwirq(data);",
            "",
            "\tswitch (which) {",
            "\tcase IRQCHIP_STATE_PENDING:",
            "\t\tif (irq_ctx->enabled) {",
            "\t\t\tassign_bit(hwirq, irq_ctx->work_ctx->pending, state);",
            "\t\t\tif (state)",
            "\t\t\t\tirq_work_queue(&irq_ctx->work_ctx->work);",
            "\t\t}",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void irq_sim_handle_irq(struct irq_work *work)",
            "{",
            "\tstruct irq_sim_work_ctx *work_ctx;",
            "\tunsigned int offset = 0;",
            "\tint irqnum;",
            "",
            "\twork_ctx = container_of(work, struct irq_sim_work_ctx, work);",
            "",
            "\twhile (!bitmap_empty(work_ctx->pending, work_ctx->irq_count)) {",
            "\t\toffset = find_next_bit(work_ctx->pending,",
            "\t\t\t\t       work_ctx->irq_count, offset);",
            "\t\tclear_bit(offset, work_ctx->pending);",
            "\t\tirqnum = irq_find_mapping(work_ctx->domain, offset);",
            "\t\thandle_simple_irq(irq_to_desc(irqnum));",
            "\t}",
            "}",
            "static int irq_sim_domain_map(struct irq_domain *domain,",
            "\t\t\t      unsigned int virq, irq_hw_number_t hw)",
            "{",
            "\tstruct irq_sim_work_ctx *work_ctx = domain->host_data;",
            "\tstruct irq_sim_irq_ctx *irq_ctx;",
            "",
            "\tirq_ctx = kzalloc(sizeof(*irq_ctx), GFP_KERNEL);",
            "\tif (!irq_ctx)",
            "\t\treturn -ENOMEM;",
            "",
            "\tirq_set_chip(virq, &irq_sim_irqchip);",
            "\tirq_set_chip_data(virq, irq_ctx);",
            "\tirq_set_handler(virq, handle_simple_irq);",
            "\tirq_modify_status(virq, IRQ_NOREQUEST | IRQ_NOAUTOEN, IRQ_NOPROBE);",
            "\tirq_ctx->work_ctx = work_ctx;",
            "",
            "\treturn 0;",
            "}",
            "static void irq_sim_domain_unmap(struct irq_domain *domain, unsigned int virq)",
            "{",
            "\tstruct irq_sim_irq_ctx *irq_ctx;",
            "\tstruct irq_data *irqd;",
            "",
            "\tirqd = irq_domain_get_irq_data(domain, virq);",
            "\tirq_ctx = irq_data_get_irq_chip_data(irqd);",
            "",
            "\tirq_set_handler(virq, NULL);",
            "\tirq_domain_reset_irq_data(irqd);",
            "\tkfree(irq_ctx);",
            "}"
          ],
          "function_name": "irq_sim_irqmask, irq_sim_irqunmask, irq_sim_set_type, irq_sim_get_irqchip_state, irq_sim_set_irqchip_state, irq_sim_handle_irq, irq_sim_domain_map, irq_sim_domain_unmap",
          "description": "实现模拟中断芯片的操作函数，包括中断使能/禁止控制、触发类型设置、芯片状态读取/修改、中断处理回调及中断域映射/解除映射逻辑，通过位图管理待处理中断并调度至简单中断处理流程",
          "similarity": 0.6815968751907349
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/irq_sim.c",
          "start_line": 203,
          "end_line": 218,
          "content": [
            "void irq_domain_remove_sim(struct irq_domain *domain)",
            "{",
            "\tstruct irq_sim_work_ctx *work_ctx = domain->host_data;",
            "",
            "\tirq_work_sync(&work_ctx->work);",
            "\tbitmap_free(work_ctx->pending);",
            "\tkfree(work_ctx);",
            "",
            "\tirq_domain_remove(domain);",
            "}",
            "static void devm_irq_domain_remove_sim(void *data)",
            "{",
            "\tstruct irq_domain *domain = data;",
            "",
            "\tirq_domain_remove_sim(domain);",
            "}"
          ],
          "function_name": "irq_domain_remove_sim, devm_irq_domain_remove_sim",
          "description": "提供中断域清理接口，同步工作队列确保Pending中断处理完成，释放位图内存并安全移除中断域，包含设备管理器版本的延迟卸载实现",
          "similarity": 0.652847170829773
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/irq_sim.c",
          "start_line": 1,
          "end_line": 26,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0+",
            "/*",
            " * Copyright (C) 2017-2018 Bartosz Golaszewski <brgl@bgdev.pl>",
            " * Copyright (C) 2020 Bartosz Golaszewski <bgolaszewski@baylibre.com>",
            " */",
            "",
            "#include <linux/irq.h>",
            "#include <linux/irq_sim.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "",
            "struct irq_sim_work_ctx {",
            "\tstruct irq_work\t\twork;",
            "\tint\t\t\tirq_base;",
            "\tunsigned int\t\tirq_count;",
            "\tunsigned long\t\t*pending;",
            "\tstruct irq_domain\t*domain;",
            "};",
            "",
            "struct irq_sim_irq_ctx {",
            "\tint\t\t\tirqnum;",
            "\tbool\t\t\tenabled;",
            "\tstruct irq_sim_work_ctx\t*work_ctx;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义了irq_sim_work_ctx和irq_sim_irq_ctx结构体，前者用于维护中断工作队列上下文（含位图pending、中断域指针等），后者保存单个中断的配置信息（中断号、启用状态及工作上下文指针）",
          "similarity": 0.5908669829368591
        }
      ]
    },
    {
      "source_file": "kernel/irq/chip.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:48:28\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\chip.c`\n\n---\n\n# `irq/chip.c` 技术文档\n\n## 1. 文件概述\n\n`irq/chip.c` 是 Linux 内核通用中断子系统（Generic IRQ）的核心实现文件之一，主要负责基于 `irq_chip` 抽象的中断控制器底层操作。该文件提供了中断芯片（IRQ chip）的注册、配置、启停、数据管理等基础接口，是架构无关的中断处理基础设施，为各种硬件中断控制器（如 GIC、APIC、MSI 等）提供统一的管理框架。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能说明 |\n|--------|--------|\n| `irq_set_chip()` | 为指定 IRQ 号绑定 `irq_chip` 操作结构体 |\n| `irq_set_irq_type()` | 设置中断触发类型（电平/边沿触发等） |\n| `irq_set_handler_data()` | 设置中断处理程序私有数据（`handler_data`） |\n| `irq_set_chip_data()` | 设置中断芯片私有数据（`chip_data`） |\n| `irq_set_msi_desc()` / `irq_set_msi_desc_off()` | 为 MSI/MSI-X 中断设置描述符 |\n| `irq_get_irq_data()` | 获取指定 IRQ 的 `irq_data` 结构指针 |\n| `irq_startup()` | 启动一个中断（调用 chip 的 `irq_startup` 或 `irq_enable`） |\n| `irq_shutdown()` | 关闭一个中断（调用 chip 的 `irq_shutdown` 或 `irq_disable`） |\n| `irq_activate()` | 激活中断（通常用于 IRQ domain 资源分配） |\n| `irq_activate_and_startup()` | 组合激活并启动中断 |\n| `irq_shutdown_and_deactivate()` | 组合关闭并去激活中断 |\n\n### 关键数据结构\n\n- **`chained_action`**：专用于级联中断（chained IRQ）的默认 `irqaction`，其处理函数 `bad_chained_irq` 会在错误调用时发出警告。\n- **`struct irq_chip`**：中断控制器操作抽象，包含 `irq_startup`、`irq_shutdown`、`irq_enable`、`irq_disable` 等回调函数。\n- **`struct irq_desc`**：中断描述符，包含中断状态、操作函数、私有数据等。\n- **`struct irq_data`**：中断数据结构，嵌入在 `irq_desc` 中，包含 `chip`、`chip_data`、状态标志（如 `IRQD_IRQ_DISABLED`）等。\n\n## 3. 关键实现\n\n### 中断状态管理\n- 使用 `irqd_set()` / `irqd_clear()` 操作 `irq_data` 中的状态位（如 `IRQD_IRQ_DISABLED`、`IRQD_IRQ_MASKED`、`IRQD_IRQ_STARTED`）。\n- `irq_startup()` 和 `irq_shutdown()` 通过检查 `irqd_is_started()` 决定是否执行完整启停流程。\n\n### 级联中断保护\n- `chained_action` 的 `bad_chained_irq` 处理函数用于防止级联中断被误当作普通中断处理，确保级联中断仅由父中断控制器驱动调用。\n\n### 管理型中断（Managed IRQ）支持\n- 在 `CONFIG_SMP` 下，`__irq_startup_managed()` 检查中断是否为“管理型”（由内核自动管理 CPU 亲和性）。\n- 若亲和性掩码中无在线 CPU，则进入 `IRQ_STARTUP_ABORT` 状态并设置 `IRQD_MANAGED_SHUTDOWN`，等待 CPU 热插拔事件重新启动。\n\n### 启动流程\n- `irq_startup()` 根据 `irq_chip` 是否提供 `irq_startup` 回调选择不同路径：\n  - 有 `irq_startup`：调用该函数，并清除 `DISABLED` 和 `MASKED` 状态。\n  - 无 `irq_startup`：调用通用 `irq_enable()`。\n- 支持亲和性设置时机控制：通过 `IRQCHIP_AFFINITY_PRE_STARTUP` 标志决定在启动前还是启动后设置 CPU 亲和性。\n\n### MSI 描述符管理\n- `irq_set_msi_desc_off()` 支持为 MSI 中断组（base + offset）设置描述符，并在 offset 为 0 时更新 `msi_desc->irq` 字段。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`：定义 `irq_chip`、`irq_desc` 等核心结构。\n  - `<linux/msi.h>`：MSI 相关定义。\n  - `<linux/irqdomain.h>`：IRQ domain 支持。\n  - `\"internals.h\"`：中断子系统内部接口。\n- **模块依赖**：\n  - 依赖通用中断子系统（Generic IRQ）的其他组件，如 `irqdesc.c`（描述符管理）、`irqdomain.c`（IRQ domain 映射）。\n  - 与 CPU 热插拔子系统交互（管理型中断场景）。\n  - 被各类中断控制器驱动（如 GIC、IOAPIC、MSI 驱动）调用以注册和配置中断。\n\n## 5. 使用场景\n\n- **中断控制器驱动初始化**：在平台或设备驱动中调用 `irq_set_chip()`、`irq_set_chip_data()` 等函数注册中断控制器操作。\n- **中断类型配置**：设备驱动通过 `irq_set_irq_type()` 设置中断触发方式（如 `IRQ_TYPE_EDGE_RISING`）。\n- **MSI/MSI-X 中断设置**：PCIe 驱动使用 `irq_set_msi_desc()` 关联 MSI 描述符与 IRQ 号。\n- **中断启停控制**：内核在 `request_irq()` / `free_irq()` 或 `enable_irq()` / `disable_irq()` 路径中调用 `irq_startup()` / `irq_shutdown()`。\n- **CPU 热插拔处理**：管理型中断在 CPU 上线/下线时自动启停，依赖本文件的 `__irq_startup_managed()` 逻辑。\n- **级联中断实现**：父中断控制器使用 `chained_action` 作为占位符，防止子中断被错误处理。",
      "similarity": 0.6547191143035889,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/chip.c",
          "start_line": 22,
          "end_line": 148,
          "content": [
            "static irqreturn_t bad_chained_irq(int irq, void *dev_id)",
            "{",
            "\tWARN_ONCE(1, \"Chained irq %d should not call an action\\n\", irq);",
            "\treturn IRQ_NONE;",
            "}",
            "int irq_set_chip(unsigned int irq, const struct irq_chip *chip)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "",
            "\tdesc->irq_data.chip = (struct irq_chip *)(chip ?: &no_irq_chip);",
            "\tirq_put_desc_unlock(desc, flags);",
            "\t/*",
            "\t * For !CONFIG_SPARSE_IRQ make the irq show up in",
            "\t * allocated_irqs.",
            "\t */",
            "\tirq_mark_irq(irq);",
            "\treturn 0;",
            "}",
            "int irq_set_irq_type(unsigned int irq, unsigned int type)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);",
            "\tint ret = 0;",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "",
            "\tret = __irq_set_trigger(desc, type);",
            "\tirq_put_desc_busunlock(desc, flags);",
            "\treturn ret;",
            "}",
            "int irq_set_handler_data(unsigned int irq, void *data)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "\tdesc->irq_common_data.handler_data = data;",
            "\tirq_put_desc_unlock(desc, flags);",
            "\treturn 0;",
            "}",
            "int irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,",
            "\t\t\t struct msi_desc *entry)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_lock(irq_base + irq_offset, &flags, IRQ_GET_DESC_CHECK_GLOBAL);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "\tdesc->irq_common_data.msi_desc = entry;",
            "\tif (entry && !irq_offset)",
            "\t\tentry->irq = irq_base;",
            "\tirq_put_desc_unlock(desc, flags);",
            "\treturn 0;",
            "}",
            "int irq_set_msi_desc(unsigned int irq, struct msi_desc *entry)",
            "{",
            "\treturn irq_set_msi_desc_off(irq, 0, entry);",
            "}",
            "int irq_set_chip_data(unsigned int irq, void *data)",
            "{",
            "\tunsigned long flags;",
            "\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "\tdesc->irq_data.chip_data = data;",
            "\tirq_put_desc_unlock(desc, flags);",
            "\treturn 0;",
            "}",
            "static void irq_state_clr_disabled(struct irq_desc *desc)",
            "{",
            "\tirqd_clear(&desc->irq_data, IRQD_IRQ_DISABLED);",
            "}",
            "static void irq_state_clr_masked(struct irq_desc *desc)",
            "{",
            "\tirqd_clear(&desc->irq_data, IRQD_IRQ_MASKED);",
            "}",
            "static void irq_state_clr_started(struct irq_desc *desc)",
            "{",
            "\tirqd_clear(&desc->irq_data, IRQD_IRQ_STARTED);",
            "}",
            "static void irq_state_set_started(struct irq_desc *desc)",
            "{",
            "\tirqd_set(&desc->irq_data, IRQD_IRQ_STARTED);",
            "}",
            "static int",
            "__irq_startup_managed(struct irq_desc *desc, const struct cpumask *aff,",
            "\t\t      bool force)",
            "{",
            "\tstruct irq_data *d = irq_desc_get_irq_data(desc);",
            "",
            "\tif (!irqd_affinity_is_managed(d))",
            "\t\treturn IRQ_STARTUP_NORMAL;",
            "",
            "\tirqd_clr_managed_shutdown(d);",
            "",
            "\tif (cpumask_any_and(aff, cpu_online_mask) >= nr_cpu_ids) {",
            "\t\t/*",
            "\t\t * Catch code which fiddles with enable_irq() on a managed",
            "\t\t * and potentially shutdown IRQ. Chained interrupt",
            "\t\t * installment or irq auto probing should not happen on",
            "\t\t * managed irqs either.",
            "\t\t */",
            "\t\tif (WARN_ON_ONCE(force))",
            "\t\t\treturn IRQ_STARTUP_ABORT;",
            "\t\t/*",
            "\t\t * The interrupt was requested, but there is no online CPU",
            "\t\t * in it's affinity mask. Put it into managed shutdown",
            "\t\t * state and let the cpu hotplug mechanism start it up once",
            "\t\t * a CPU in the mask becomes available.",
            "\t\t */",
            "\t\treturn IRQ_STARTUP_ABORT;",
            "\t}",
            "\t/*",
            "\t * Managed interrupts have reserved resources, so this should not",
            "\t * happen.",
            "\t */",
            "\tif (WARN_ON(irq_domain_activate_irq(d, false)))",
            "\t\treturn IRQ_STARTUP_ABORT;",
            "\treturn IRQ_STARTUP_MANAGED;",
            "}"
          ],
          "function_name": "bad_chained_irq, irq_set_chip, irq_set_irq_type, irq_set_handler_data, irq_set_msi_desc_off, irq_set_msi_desc, irq_set_chip_data, irq_state_clr_disabled, irq_state_clr_masked, irq_state_clr_started, irq_state_set_started, __irq_startup_managed",
          "description": "实现中断芯片配置接口，包括设置中断芯片、触发类型、MSI描述符等，包含链式中断错误处理函数",
          "similarity": 0.7118593454360962
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/chip.c",
          "start_line": 350,
          "end_line": 456,
          "content": [
            "static void __irq_disable(struct irq_desc *desc, bool mask)",
            "{",
            "\tif (irqd_irq_disabled(&desc->irq_data)) {",
            "\t\tif (mask)",
            "\t\t\tmask_irq(desc);",
            "\t} else {",
            "\t\tirq_state_set_disabled(desc);",
            "\t\tif (desc->irq_data.chip->irq_disable) {",
            "\t\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);",
            "\t\t\tirq_state_set_masked(desc);",
            "\t\t} else if (mask) {",
            "\t\t\tmask_irq(desc);",
            "\t\t}",
            "\t}",
            "}",
            "void irq_disable(struct irq_desc *desc)",
            "{",
            "\t__irq_disable(desc, irq_settings_disable_unlazy(desc));",
            "}",
            "void irq_percpu_enable(struct irq_desc *desc, unsigned int cpu)",
            "{",
            "\tif (desc->irq_data.chip->irq_enable)",
            "\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);",
            "\telse",
            "\t\tdesc->irq_data.chip->irq_unmask(&desc->irq_data);",
            "\tcpumask_set_cpu(cpu, desc->percpu_enabled);",
            "}",
            "void irq_percpu_disable(struct irq_desc *desc, unsigned int cpu)",
            "{",
            "\tif (desc->irq_data.chip->irq_disable)",
            "\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);",
            "\telse",
            "\t\tdesc->irq_data.chip->irq_mask(&desc->irq_data);",
            "\tcpumask_clear_cpu(cpu, desc->percpu_enabled);",
            "}",
            "static inline void mask_ack_irq(struct irq_desc *desc)",
            "{",
            "\tif (desc->irq_data.chip->irq_mask_ack) {",
            "\t\tdesc->irq_data.chip->irq_mask_ack(&desc->irq_data);",
            "\t\tirq_state_set_masked(desc);",
            "\t} else {",
            "\t\tmask_irq(desc);",
            "\t\tif (desc->irq_data.chip->irq_ack)",
            "\t\t\tdesc->irq_data.chip->irq_ack(&desc->irq_data);",
            "\t}",
            "}",
            "void mask_irq(struct irq_desc *desc)",
            "{",
            "\tif (irqd_irq_masked(&desc->irq_data))",
            "\t\treturn;",
            "",
            "\tif (desc->irq_data.chip->irq_mask) {",
            "\t\tdesc->irq_data.chip->irq_mask(&desc->irq_data);",
            "\t\tirq_state_set_masked(desc);",
            "\t}",
            "}",
            "void unmask_irq(struct irq_desc *desc)",
            "{",
            "\tif (!irqd_irq_masked(&desc->irq_data))",
            "\t\treturn;",
            "",
            "\tif (desc->irq_data.chip->irq_unmask) {",
            "\t\tdesc->irq_data.chip->irq_unmask(&desc->irq_data);",
            "\t\tirq_state_clr_masked(desc);",
            "\t}",
            "}",
            "void unmask_threaded_irq(struct irq_desc *desc)",
            "{",
            "\tstruct irq_chip *chip = desc->irq_data.chip;",
            "",
            "\tif (chip->flags & IRQCHIP_EOI_THREADED)",
            "\t\tchip->irq_eoi(&desc->irq_data);",
            "",
            "\tunmask_irq(desc);",
            "}",
            "void handle_nested_irq(unsigned int irq)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "\tstruct irqaction *action;",
            "\tirqreturn_t action_ret;",
            "",
            "\tmight_sleep();",
            "",
            "\traw_spin_lock_irq(&desc->lock);",
            "",
            "\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);",
            "",
            "\taction = desc->action;",
            "\tif (unlikely(!action || irqd_irq_disabled(&desc->irq_data))) {",
            "\t\tdesc->istate |= IRQS_PENDING;",
            "\t\traw_spin_unlock_irq(&desc->lock);",
            "\t\treturn;",
            "\t}",
            "",
            "\tkstat_incr_irqs_this_cpu(desc);",
            "\tatomic_inc(&desc->threads_active);",
            "\traw_spin_unlock_irq(&desc->lock);",
            "",
            "\taction_ret = IRQ_NONE;",
            "\tfor_each_action_of_desc(desc, action)",
            "\t\taction_ret |= action->thread_fn(action->irq, action->dev_id);",
            "",
            "\tif (!irq_settings_no_debug(desc))",
            "\t\tnote_interrupt(desc, action_ret);",
            "",
            "\twake_threads_waitq(desc);",
            "}"
          ],
          "function_name": "__irq_disable, irq_disable, irq_percpu_enable, irq_percpu_disable, mask_ack_irq, mask_irq, unmask_irq, unmask_threaded_irq, handle_nested_irq",
          "description": "实现中断屏蔽/解除屏蔽操作，包含芯片特定的屏蔽确认、单CPU使能控制等底层操作",
          "similarity": 0.7020475268363953
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/chip.c",
          "start_line": 1,
          "end_line": 21,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992, 1998-2006 Linus Torvalds, Ingo Molnar",
            " * Copyright (C) 2005-2006, Thomas Gleixner, Russell King",
            " *",
            " * This file contains the core interrupt handling code, for irq-chip based",
            " * architectures. Detailed information is available in",
            " * Documentation/core-api/genericirq.rst",
            " */",
            "",
            "#include <linux/irq.h>",
            "#include <linux/msi.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdomain.h>",
            "",
            "#include <trace/events/irq.h>",
            "",
            "#include \"internals.h\"",
            ""
          ],
          "function_name": null,
          "description": "声明通用中断处理核心代码，包含irq-chip相关头文件及内部实现依赖，提供中断处理框架基础支持",
          "similarity": 0.6725260019302368
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/chip.c",
          "start_line": 227,
          "end_line": 337,
          "content": [
            "static __always_inline int",
            "__irq_startup_managed(struct irq_desc *desc, const struct cpumask *aff,",
            "\t\t      bool force)",
            "{",
            "\treturn IRQ_STARTUP_NORMAL;",
            "}",
            "static int __irq_startup(struct irq_desc *desc)",
            "{",
            "\tstruct irq_data *d = irq_desc_get_irq_data(desc);",
            "\tint ret = 0;",
            "",
            "\t/* Warn if this interrupt is not activated but try nevertheless */",
            "\tWARN_ON_ONCE(!irqd_is_activated(d));",
            "",
            "\tif (d->chip->irq_startup) {",
            "\t\tret = d->chip->irq_startup(d);",
            "\t\tirq_state_clr_disabled(desc);",
            "\t\tirq_state_clr_masked(desc);",
            "\t} else {",
            "\t\tirq_enable(desc);",
            "\t}",
            "\tirq_state_set_started(desc);",
            "\treturn ret;",
            "}",
            "int irq_startup(struct irq_desc *desc, bool resend, bool force)",
            "{",
            "\tstruct irq_data *d = irq_desc_get_irq_data(desc);",
            "\tconst struct cpumask *aff = irq_data_get_affinity_mask(d);",
            "\tint ret = 0;",
            "",
            "\tdesc->depth = 0;",
            "",
            "\tif (irqd_is_started(d)) {",
            "\t\tirq_enable(desc);",
            "\t} else {",
            "\t\tswitch (__irq_startup_managed(desc, aff, force)) {",
            "\t\tcase IRQ_STARTUP_NORMAL:",
            "\t\t\tif (d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP)",
            "\t\t\t\tirq_setup_affinity(desc);",
            "\t\t\tret = __irq_startup(desc);",
            "\t\t\tif (!(d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP))",
            "\t\t\t\tirq_setup_affinity(desc);",
            "\t\t\tbreak;",
            "\t\tcase IRQ_STARTUP_MANAGED:",
            "\t\t\tirq_do_set_affinity(d, aff, false);",
            "\t\t\tret = __irq_startup(desc);",
            "\t\t\tbreak;",
            "\t\tcase IRQ_STARTUP_ABORT:",
            "\t\t\tirqd_set_managed_shutdown(d);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "\tif (resend)",
            "\t\tcheck_irq_resend(desc, false);",
            "",
            "\treturn ret;",
            "}",
            "int irq_activate(struct irq_desc *desc)",
            "{",
            "\tstruct irq_data *d = irq_desc_get_irq_data(desc);",
            "",
            "\tif (!irqd_affinity_is_managed(d))",
            "\t\treturn irq_domain_activate_irq(d, false);",
            "\treturn 0;",
            "}",
            "int irq_activate_and_startup(struct irq_desc *desc, bool resend)",
            "{",
            "\tif (WARN_ON(irq_activate(desc)))",
            "\t\treturn 0;",
            "\treturn irq_startup(desc, resend, IRQ_START_FORCE);",
            "}",
            "void irq_shutdown(struct irq_desc *desc)",
            "{",
            "\tif (irqd_is_started(&desc->irq_data)) {",
            "\t\tclear_irq_resend(desc);",
            "\t\tdesc->depth = 1;",
            "\t\tif (desc->irq_data.chip->irq_shutdown) {",
            "\t\t\tdesc->irq_data.chip->irq_shutdown(&desc->irq_data);",
            "\t\t\tirq_state_set_disabled(desc);",
            "\t\t\tirq_state_set_masked(desc);",
            "\t\t} else {",
            "\t\t\t__irq_disable(desc, true);",
            "\t\t}",
            "\t\tirq_state_clr_started(desc);",
            "\t}",
            "}",
            "void irq_shutdown_and_deactivate(struct irq_desc *desc)",
            "{",
            "\tirq_shutdown(desc);",
            "\t/*",
            "\t * This must be called even if the interrupt was never started up,",
            "\t * because the activation can happen before the interrupt is",
            "\t * available for request/startup. It has it's own state tracking so",
            "\t * it's safe to call it unconditionally.",
            "\t */",
            "\tirq_domain_deactivate_irq(&desc->irq_data);",
            "}",
            "void irq_enable(struct irq_desc *desc)",
            "{",
            "\tif (!irqd_irq_disabled(&desc->irq_data)) {",
            "\t\tunmask_irq(desc);",
            "\t} else {",
            "\t\tirq_state_clr_disabled(desc);",
            "\t\tif (desc->irq_data.chip->irq_enable) {",
            "\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);",
            "\t\t\tirq_state_clr_masked(desc);",
            "\t\t} else {",
            "\t\t\tunmask_irq(desc);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "__irq_startup_managed, __irq_startup, irq_startup, irq_activate, irq_activate_and_startup, irq_shutdown, irq_shutdown_and_deactivate, irq_enable",
          "description": "实现中断启动逻辑，包含管理型中断特殊处理流程，负责中断激活、启动及状态管理",
          "similarity": 0.6655359268188477
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/chip.c",
          "start_line": 495,
          "end_line": 610,
          "content": [
            "static bool irq_check_poll(struct irq_desc *desc)",
            "{",
            "\tif (!(desc->istate & IRQS_POLL_INPROGRESS))",
            "\t\treturn false;",
            "\treturn irq_wait_for_poll(desc);",
            "}",
            "static bool irq_may_run(struct irq_desc *desc)",
            "{",
            "\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;",
            "",
            "\t/*",
            "\t * If the interrupt is not in progress and is not an armed",
            "\t * wakeup interrupt, proceed.",
            "\t */",
            "\tif (!irqd_has_set(&desc->irq_data, mask))",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * If the interrupt is an armed wakeup source, mark it pending",
            "\t * and suspended, disable it and notify the pm core about the",
            "\t * event.",
            "\t */",
            "\tif (irq_pm_check_wakeup(desc))",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Handle a potential concurrent poll on a different core.",
            "\t */",
            "\treturn irq_check_poll(desc);",
            "}",
            "void handle_simple_irq(struct irq_desc *desc)",
            "{",
            "\traw_spin_lock(&desc->lock);",
            "",
            "\tif (!irq_may_run(desc))",
            "\t\tgoto out_unlock;",
            "",
            "\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);",
            "",
            "\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {",
            "\t\tdesc->istate |= IRQS_PENDING;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tkstat_incr_irqs_this_cpu(desc);",
            "\thandle_irq_event(desc);",
            "",
            "out_unlock:",
            "\traw_spin_unlock(&desc->lock);",
            "}",
            "void handle_untracked_irq(struct irq_desc *desc)",
            "{",
            "\traw_spin_lock(&desc->lock);",
            "",
            "\tif (!irq_may_run(desc))",
            "\t\tgoto out_unlock;",
            "",
            "\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);",
            "",
            "\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {",
            "\t\tdesc->istate |= IRQS_PENDING;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tdesc->istate &= ~IRQS_PENDING;",
            "\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);",
            "\traw_spin_unlock(&desc->lock);",
            "",
            "\t__handle_irq_event_percpu(desc);",
            "",
            "\traw_spin_lock(&desc->lock);",
            "\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);",
            "",
            "out_unlock:",
            "\traw_spin_unlock(&desc->lock);",
            "}",
            "static void cond_unmask_irq(struct irq_desc *desc)",
            "{",
            "\t/*",
            "\t * We need to unmask in the following cases:",
            "\t * - Standard level irq (IRQF_ONESHOT is not set)",
            "\t * - Oneshot irq which did not wake the thread (caused by a",
            "\t *   spurious interrupt or a primary handler handling it",
            "\t *   completely).",
            "\t */",
            "\tif (!irqd_irq_disabled(&desc->irq_data) &&",
            "\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)",
            "\t\tunmask_irq(desc);",
            "}",
            "void handle_level_irq(struct irq_desc *desc)",
            "{",
            "\traw_spin_lock(&desc->lock);",
            "\tmask_ack_irq(desc);",
            "",
            "\tif (!irq_may_run(desc))",
            "\t\tgoto out_unlock;",
            "",
            "\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);",
            "",
            "\t/*",
            "\t * If its disabled or no action available",
            "\t * keep it masked and get out of here",
            "\t */",
            "\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {",
            "\t\tdesc->istate |= IRQS_PENDING;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tkstat_incr_irqs_this_cpu(desc);",
            "\thandle_irq_event(desc);",
            "",
            "\tcond_unmask_irq(desc);",
            "",
            "out_unlock:",
            "\traw_spin_unlock(&desc->lock);",
            "}"
          ],
          "function_name": "irq_check_poll, irq_may_run, handle_simple_irq, handle_untracked_irq, cond_unmask_irq, handle_level_irq",
          "description": "实现中断处理流程控制，包含轮询检查、中断可执行性判断及不同类型中断（简单/层级）的处理逻辑",
          "similarity": 0.6460995078086853
        }
      ]
    },
    {
      "source_file": "kernel/irq/generic-chip.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:54:33\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\generic-chip.c`\n\n---\n\n# `irq/generic-chip.c` 技术文档\n\n## 1. 文件概述\n\n`generic-chip.c` 是 Linux 内核中断子系统中的一个通用中断控制器（IRQ chip）实现库。该文件提供了一系列通用的、可复用的中断芯片回调函数（如 mask、unmask、ack、eoi、wake 等），用于简化各类硬件中断控制器驱动的开发。通过抽象出常见的寄存器操作模式（如通过置位/清位掩码寄存器、独立的使能/禁止寄存器等），该模块允许驱动开发者无需重复实现标准中断操作逻辑，只需配置通用芯片结构体即可快速集成中断控制器。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct irq_chip_generic`：表示一个通用中断控制器实例，包含寄存器基地址、中断基数、锁、掩码缓存、芯片类型数组等。\n- `struct irq_chip_type`：描述中断控制器的一种操作类型（如电平触发、边沿触发），包含寄存器偏移、掩码缓存指针、流控处理函数等。\n- `enum irq_gc_flags`：控制通用芯片初始化行为的标志（如是否为每种类型维护独立掩码缓存、是否从硬件读取初始掩码值等）。\n\n### 主要导出函数\n- **中断屏蔽/解除屏蔽**：\n  - `irq_gc_mask_disable_reg()`：通过写入 disable 寄存器屏蔽中断。\n  - `irq_gc_mask_set_bit()` / `irq_gc_mask_clr_bit()`：通过置位/清位 mask 寄存器屏蔽中断。\n  - `irq_gc_unmask_enable_reg()`：通过写入 enable 寄存器解除屏蔽。\n- **中断确认（ACK）**：\n  - `irq_gc_ack_set_bit()`：通过置位 ack 寄存器确认中断。\n  - `irq_gc_ack_clr_bit()`：通过清位 ack 寄存器确认中断。\n- **组合操作**：\n  - `irq_gc_mask_disable_and_ack_set()`：同时屏蔽中断并确认（适用于特定硬件）。\n- **中断结束（EOI）**：\n  - `irq_gc_eoi()`：向 eoi 寄存器写入以结束中断处理。\n- **唤醒控制**：\n  - `irq_gc_set_wake()`：设置/清除中断的唤醒能力（用于系统挂起/恢复）。\n- **资源管理**：\n  - `irq_alloc_generic_chip()`：分配并初始化一个通用中断芯片结构。\n  - `__irq_alloc_domain_generic_chips()`：为整个 IRQ domain 分配多个通用芯片实例（未在代码片段中完整展示，但声明存在）。\n\n### 辅助函数\n- `irq_gc_noop()`：空操作回调，用于不需要实际操作的场景。\n- `irq_init_generic_chip()`：初始化已分配的 `irq_chip_generic` 结构。\n- `irq_gc_init_mask_cache()`：根据标志初始化掩码缓存（可选从硬件读取初始值）。\n\n## 3. 关键实现\n\n### 寄存器访问抽象\n- 使用 `irq_reg_writel()` 和 `irq_reg_readl()` 进行寄存器读写，支持大小端配置（通过 `irq_writel_be`/`irq_readl_be`）。\n- 所有寄存器操作均在 `irq_gc_lock()` / `irq_gc_unlock()` 保护下进行，确保多中断线程安全。\n\n### 掩码缓存机制\n- 通用芯片维护一个或多个掩码缓存（`mask_cache`），避免频繁读取硬件寄存器。\n- 缓存更新与硬件写入原子执行，保证状态一致性。\n- 支持两种缓存模式：\n  - 全局共享缓存（默认）：所有 `chip_type` 共享同一个掩码值。\n  - 每类型独立缓存（`IRQ_GC_MASK_CACHE_PER_TYPE`）：每个 `chip_type` 拥有独立掩码。\n\n### 初始化灵活性\n- `irq_alloc_generic_chip()` 允许指定芯片名称、中断数量、寄存器基址和默认流控处理函数。\n- `__irq_alloc_domain_generic_chips()` 支持为整个 IRQ domain 批量分配芯片，适用于处理大量中断线的控制器（如 GPIO 控制器）。\n\n### 唤醒功能实现\n- `irq_gc_set_wake()` 通过位掩码 `wake_active` 跟踪哪些中断被配置为唤醒源。\n- 仅当请求的中断在 `wake_enabled` 掩码中时才允许设置唤醒状态，提供安全检查。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`、`<linux/irqdomain.h>`：中断核心数据结构和 API。\n  - `<linux/io.h>`：寄存器 I/O 操作（`ioread32be`/`iowrite32be`）。\n  - `\"internals.h\"`：中断子系统内部函数（如 `irq_data_get_irq_chip_data`）。\n- **内核子系统**：\n  - 中断子系统（`kernel/irq/`）：作为通用 IRQ chip 实现，被具体硬件驱动调用。\n  - 内存管理（`slab.h`）：用于动态分配 `irq_chip_generic` 结构。\n  - 电源管理：`irq_gc_set_wake` 与系统挂起/恢复机制集成。\n\n## 5. 使用场景\n\n- **嵌入式 SoC 中断控制器**：如 ARM GIC 的简化变种、厂商自定义中断控制器。\n- **GPIO 控制器中断**：GPIO 控制器常提供中断功能，每个 GPIO 组可映射为一个通用芯片实例。\n- **PCI/PCIe MSI 中断**：部分 MSI 控制器可复用通用芯片逻辑。\n- **快速原型开发**：驱动开发者可通过配置通用芯片结构快速支持新硬件，无需从零实现所有 IRQ 回调。\n- **设备树集成**：配合 IRQ domain 机制，通过 `__irq_alloc_domain_generic_chips` 自动为设备树中描述的中断控制器分配资源。",
      "similarity": 0.6534526944160461,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/generic-chip.c",
          "start_line": 208,
          "end_line": 351,
          "content": [
            "static u32 irq_readl_be(void __iomem *addr)",
            "{",
            "\treturn ioread32be(addr);",
            "}",
            "static void irq_writel_be(u32 val, void __iomem *addr)",
            "{",
            "\tiowrite32be(val, addr);",
            "}",
            "void irq_init_generic_chip(struct irq_chip_generic *gc, const char *name,",
            "\t\t\t   int num_ct, unsigned int irq_base,",
            "\t\t\t   void __iomem *reg_base, irq_flow_handler_t handler)",
            "{",
            "\traw_spin_lock_init(&gc->lock);",
            "\tgc->num_ct = num_ct;",
            "\tgc->irq_base = irq_base;",
            "\tgc->reg_base = reg_base;",
            "\tgc->chip_types->chip.name = name;",
            "\tgc->chip_types->handler = handler;",
            "}",
            "static void",
            "irq_gc_init_mask_cache(struct irq_chip_generic *gc, enum irq_gc_flags flags)",
            "{",
            "\tstruct irq_chip_type *ct = gc->chip_types;",
            "\tu32 *mskptr = &gc->mask_cache, mskreg = ct->regs.mask;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < gc->num_ct; i++) {",
            "\t\tif (flags & IRQ_GC_MASK_CACHE_PER_TYPE) {",
            "\t\t\tmskptr = &ct[i].mask_cache_priv;",
            "\t\t\tmskreg = ct[i].regs.mask;",
            "\t\t}",
            "\t\tct[i].mask_cache = mskptr;",
            "\t\tif (flags & IRQ_GC_INIT_MASK_CACHE)",
            "\t\t\t*mskptr = irq_reg_readl(gc, mskreg);",
            "\t}",
            "}",
            "int __irq_alloc_domain_generic_chips(struct irq_domain *d, int irqs_per_chip,",
            "\t\t\t\t     int num_ct, const char *name,",
            "\t\t\t\t     irq_flow_handler_t handler,",
            "\t\t\t\t     unsigned int clr, unsigned int set,",
            "\t\t\t\t     enum irq_gc_flags gcflags)",
            "{",
            "\tstruct irq_domain_chip_generic *dgc;",
            "\tstruct irq_chip_generic *gc;",
            "\tunsigned long flags;",
            "\tint numchips, i;",
            "\tsize_t dgc_sz;",
            "\tsize_t gc_sz;",
            "\tsize_t sz;",
            "\tvoid *tmp;",
            "",
            "\tif (d->gc)",
            "\t\treturn -EBUSY;",
            "",
            "\tnumchips = DIV_ROUND_UP(d->revmap_size, irqs_per_chip);",
            "\tif (!numchips)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Allocate a pointer, generic chip and chiptypes for each chip */",
            "\tgc_sz = struct_size(gc, chip_types, num_ct);",
            "\tdgc_sz = struct_size(dgc, gc, numchips);",
            "\tsz = dgc_sz + numchips * gc_sz;",
            "",
            "\ttmp = dgc = kzalloc(sz, GFP_KERNEL);",
            "\tif (!dgc)",
            "\t\treturn -ENOMEM;",
            "\tdgc->irqs_per_chip = irqs_per_chip;",
            "\tdgc->num_chips = numchips;",
            "\tdgc->irq_flags_to_set = set;",
            "\tdgc->irq_flags_to_clear = clr;",
            "\tdgc->gc_flags = gcflags;",
            "\td->gc = dgc;",
            "",
            "\t/* Calc pointer to the first generic chip */",
            "\ttmp += dgc_sz;",
            "\tfor (i = 0; i < numchips; i++) {",
            "\t\t/* Store the pointer to the generic chip */",
            "\t\tdgc->gc[i] = gc = tmp;",
            "\t\tirq_init_generic_chip(gc, name, num_ct, i * irqs_per_chip,",
            "\t\t\t\t      NULL, handler);",
            "",
            "\t\tgc->domain = d;",
            "\t\tif (gcflags & IRQ_GC_BE_IO) {",
            "\t\t\tgc->reg_readl = &irq_readl_be;",
            "\t\t\tgc->reg_writel = &irq_writel_be;",
            "\t\t}",
            "",
            "\t\traw_spin_lock_irqsave(&gc_lock, flags);",
            "\t\tlist_add_tail(&gc->list, &gc_list);",
            "\t\traw_spin_unlock_irqrestore(&gc_lock, flags);",
            "\t\t/* Calc pointer to the next generic chip */",
            "\t\ttmp += gc_sz;",
            "\t}",
            "\treturn 0;",
            "}",
            "int irq_map_generic_chip(struct irq_domain *d, unsigned int virq,",
            "\t\t\t irq_hw_number_t hw_irq)",
            "{",
            "\tstruct irq_data *data = irq_domain_get_irq_data(d, virq);",
            "\tstruct irq_domain_chip_generic *dgc = d->gc;",
            "\tstruct irq_chip_generic *gc;",
            "\tstruct irq_chip_type *ct;",
            "\tstruct irq_chip *chip;",
            "\tunsigned long flags;",
            "\tint idx;",
            "",
            "\tgc = __irq_get_domain_generic_chip(d, hw_irq);",
            "\tif (IS_ERR(gc))",
            "\t\treturn PTR_ERR(gc);",
            "",
            "\tidx = hw_irq % dgc->irqs_per_chip;",
            "",
            "\tif (test_bit(idx, &gc->unused))",
            "\t\treturn -ENOTSUPP;",
            "",
            "\tif (test_bit(idx, &gc->installed))",
            "\t\treturn -EBUSY;",
            "",
            "\tct = gc->chip_types;",
            "\tchip = &ct->chip;",
            "",
            "\t/* We only init the cache for the first mapping of a generic chip */",
            "\tif (!gc->installed) {",
            "\t\traw_spin_lock_irqsave(&gc->lock, flags);",
            "\t\tirq_gc_init_mask_cache(gc, dgc->gc_flags);",
            "\t\traw_spin_unlock_irqrestore(&gc->lock, flags);",
            "\t}",
            "",
            "\t/* Mark the interrupt as installed */",
            "\tset_bit(idx, &gc->installed);",
            "",
            "\tif (dgc->gc_flags & IRQ_GC_INIT_NESTED_LOCK)",
            "\t\tirq_set_lockdep_class(virq, &irq_nested_lock_class,",
            "\t\t\t\t      &irq_nested_request_class);",
            "",
            "\tif (chip->irq_calc_mask)",
            "\t\tchip->irq_calc_mask(data);",
            "\telse",
            "\t\tdata->mask = 1 << idx;",
            "",
            "\tirq_domain_set_info(d, virq, hw_irq, chip, gc, ct->handler, NULL, NULL);",
            "\tirq_modify_status(virq, dgc->irq_flags_to_clear, dgc->irq_flags_to_set);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "irq_readl_be, irq_writel_be, irq_init_generic_chip, irq_gc_init_mask_cache, __irq_alloc_domain_generic_chips, irq_map_generic_chip",
          "description": "提供大端访问辅助函数及通用芯片初始化接口，构建中断域与硬件寄存器映射关系",
          "similarity": 0.6949405074119568
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/irq/generic-chip.c",
          "start_line": 434,
          "end_line": 536,
          "content": [
            "void irq_unmap_generic_chip(struct irq_domain *d, unsigned int virq)",
            "{",
            "\tstruct irq_data *data = irq_domain_get_irq_data(d, virq);",
            "\tstruct irq_domain_chip_generic *dgc = d->gc;",
            "\tunsigned int hw_irq = data->hwirq;",
            "\tstruct irq_chip_generic *gc;",
            "\tint irq_idx;",
            "",
            "\tgc = irq_get_domain_generic_chip(d, hw_irq);",
            "\tif (!gc)",
            "\t\treturn;",
            "",
            "\tirq_idx = hw_irq % dgc->irqs_per_chip;",
            "",
            "\tclear_bit(irq_idx, &gc->installed);",
            "\tirq_domain_set_info(d, virq, hw_irq, &no_irq_chip, NULL, NULL, NULL,",
            "\t\t\t    NULL);",
            "",
            "}",
            "void irq_setup_generic_chip(struct irq_chip_generic *gc, u32 msk,",
            "\t\t\t    enum irq_gc_flags flags, unsigned int clr,",
            "\t\t\t    unsigned int set)",
            "{",
            "\tstruct irq_chip_type *ct = gc->chip_types;",
            "\tstruct irq_chip *chip = &ct->chip;",
            "\tunsigned int i;",
            "",
            "\traw_spin_lock(&gc_lock);",
            "\tlist_add_tail(&gc->list, &gc_list);",
            "\traw_spin_unlock(&gc_lock);",
            "",
            "\tirq_gc_init_mask_cache(gc, flags);",
            "",
            "\tfor (i = gc->irq_base; msk; msk >>= 1, i++) {",
            "\t\tif (!(msk & 0x01))",
            "\t\t\tcontinue;",
            "",
            "\t\tif (flags & IRQ_GC_INIT_NESTED_LOCK)",
            "\t\t\tirq_set_lockdep_class(i, &irq_nested_lock_class,",
            "\t\t\t\t\t      &irq_nested_request_class);",
            "",
            "\t\tif (!(flags & IRQ_GC_NO_MASK)) {",
            "\t\t\tstruct irq_data *d = irq_get_irq_data(i);",
            "",
            "\t\t\tif (chip->irq_calc_mask)",
            "\t\t\t\tchip->irq_calc_mask(d);",
            "\t\t\telse",
            "\t\t\t\td->mask = 1 << (i - gc->irq_base);",
            "\t\t}",
            "\t\tirq_set_chip_and_handler(i, chip, ct->handler);",
            "\t\tirq_set_chip_data(i, gc);",
            "\t\tirq_modify_status(i, clr, set);",
            "\t}",
            "\tgc->irq_cnt = i - gc->irq_base;",
            "}",
            "int irq_setup_alt_chip(struct irq_data *d, unsigned int type)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = gc->chip_types;",
            "\tunsigned int i;",
            "",
            "\tfor (i = 0; i < gc->num_ct; i++, ct++) {",
            "\t\tif (ct->type & type) {",
            "\t\t\td->chip = &ct->chip;",
            "\t\t\tirq_data_to_desc(d)->handle_irq = ct->handler;",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "void irq_remove_generic_chip(struct irq_chip_generic *gc, u32 msk,",
            "\t\t\t     unsigned int clr, unsigned int set)",
            "{",
            "\tunsigned int i, virq;",
            "",
            "\traw_spin_lock(&gc_lock);",
            "\tlist_del(&gc->list);",
            "\traw_spin_unlock(&gc_lock);",
            "",
            "\tfor (i = 0; msk; msk >>= 1, i++) {",
            "\t\tif (!(msk & 0x01))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Interrupt domain based chips store the base hardware",
            "\t\t * interrupt number in gc::irq_base. Otherwise gc::irq_base",
            "\t\t * contains the base Linux interrupt number.",
            "\t\t */",
            "\t\tif (gc->domain) {",
            "\t\t\tvirq = irq_find_mapping(gc->domain, gc->irq_base + i);",
            "\t\t\tif (!virq)",
            "\t\t\t\tcontinue;",
            "\t\t} else {",
            "\t\t\tvirq = gc->irq_base + i;",
            "\t\t}",
            "",
            "\t\t/* Remove handler first. That will mask the irq line */",
            "\t\tirq_set_handler(virq, NULL);",
            "\t\tirq_set_chip(virq, &no_irq_chip);",
            "\t\tirq_set_chip_data(virq, NULL);",
            "\t\tirq_modify_status(virq, clr, set);",
            "\t}",
            "}"
          ],
          "function_name": "irq_unmap_generic_chip, irq_setup_generic_chip, irq_setup_alt_chip, irq_remove_generic_chip",
          "description": "实现中断芯片的注册/注销与多处理类型切换，支持动态配置中断处理逻辑",
          "similarity": 0.6920108795166016
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/generic-chip.c",
          "start_line": 1,
          "end_line": 24,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Library implementing the most common irq chip callback functions",
            " *",
            " * Copyright (C) 2011, Thomas Gleixner",
            " */",
            "#include <linux/io.h>",
            "#include <linux/irq.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/syscore_ops.h>",
            "",
            "#include \"internals.h\"",
            "",
            "static LIST_HEAD(gc_list);",
            "static DEFINE_RAW_SPINLOCK(gc_lock);",
            "",
            "/**",
            " * irq_gc_noop - NOOP function",
            " * @d: irq_data",
            " */"
          ],
          "function_name": null,
          "description": "定义通用中断芯片回调函数及数据结构，提供基础框架支持多种中断控制器实现",
          "similarity": 0.684485137462616
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/generic-chip.c",
          "start_line": 25,
          "end_line": 129,
          "content": [
            "void irq_gc_noop(struct irq_data *d)",
            "{",
            "}",
            "void irq_gc_mask_disable_reg(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\tirq_reg_writel(gc, mask, ct->regs.disable);",
            "\t*ct->mask_cache &= ~mask;",
            "\tirq_gc_unlock(gc);",
            "}",
            "void irq_gc_mask_set_bit(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\t*ct->mask_cache |= mask;",
            "\tirq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);",
            "\tirq_gc_unlock(gc);",
            "}",
            "void irq_gc_mask_clr_bit(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\t*ct->mask_cache &= ~mask;",
            "\tirq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);",
            "\tirq_gc_unlock(gc);",
            "}",
            "void irq_gc_unmask_enable_reg(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\tirq_reg_writel(gc, mask, ct->regs.enable);",
            "\t*ct->mask_cache |= mask;",
            "\tirq_gc_unlock(gc);",
            "}",
            "void irq_gc_ack_set_bit(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\tirq_reg_writel(gc, mask, ct->regs.ack);",
            "\tirq_gc_unlock(gc);",
            "}",
            "void irq_gc_ack_clr_bit(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = ~d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\tirq_reg_writel(gc, mask, ct->regs.ack);",
            "\tirq_gc_unlock(gc);",
            "}",
            "void irq_gc_mask_disable_and_ack_set(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\tirq_reg_writel(gc, mask, ct->regs.disable);",
            "\t*ct->mask_cache &= ~mask;",
            "\tirq_reg_writel(gc, mask, ct->regs.ack);",
            "\tirq_gc_unlock(gc);",
            "}",
            "void irq_gc_eoi(struct irq_data *d)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tirq_gc_lock(gc);",
            "\tirq_reg_writel(gc, mask, ct->regs.eoi);",
            "\tirq_gc_unlock(gc);",
            "}",
            "int irq_gc_set_wake(struct irq_data *d, unsigned int on)",
            "{",
            "\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);",
            "\tu32 mask = d->mask;",
            "",
            "\tif (!(mask & gc->wake_enabled))",
            "\t\treturn -EINVAL;",
            "",
            "\tirq_gc_lock(gc);",
            "\tif (on)",
            "\t\tgc->wake_active |= mask;",
            "\telse",
            "\t\tgc->wake_active &= ~mask;",
            "\tirq_gc_unlock(gc);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "irq_gc_noop, irq_gc_mask_disable_reg, irq_gc_mask_set_bit, irq_gc_mask_clr_bit, irq_gc_unmask_enable_reg, irq_gc_ack_set_bit, irq_gc_ack_clr_bit, irq_gc_mask_disable_and_ack_set, irq_gc_eoi, irq_gc_set_wake",
          "description": "实现通用中断掩码、ACK、使能等操作的底层函数，用于控制中断线路状态",
          "similarity": 0.6492136716842651
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/irq/generic-chip.c",
          "start_line": 598,
          "end_line": 654,
          "content": [
            "static int irq_gc_suspend(void)",
            "{",
            "\tstruct irq_chip_generic *gc;",
            "",
            "\tlist_for_each_entry(gc, &gc_list, list) {",
            "\t\tstruct irq_chip_type *ct = gc->chip_types;",
            "",
            "\t\tif (ct->chip.irq_suspend) {",
            "\t\t\tstruct irq_data *data = irq_gc_get_irq_data(gc);",
            "",
            "\t\t\tif (data)",
            "\t\t\t\tct->chip.irq_suspend(data);",
            "\t\t}",
            "",
            "\t\tif (gc->suspend)",
            "\t\t\tgc->suspend(gc);",
            "\t}",
            "\treturn 0;",
            "}",
            "static void irq_gc_resume(void)",
            "{",
            "\tstruct irq_chip_generic *gc;",
            "",
            "\tlist_for_each_entry(gc, &gc_list, list) {",
            "\t\tstruct irq_chip_type *ct = gc->chip_types;",
            "",
            "\t\tif (gc->resume)",
            "\t\t\tgc->resume(gc);",
            "",
            "\t\tif (ct->chip.irq_resume) {",
            "\t\t\tstruct irq_data *data = irq_gc_get_irq_data(gc);",
            "",
            "\t\t\tif (data)",
            "\t\t\t\tct->chip.irq_resume(data);",
            "\t\t}",
            "\t}",
            "}",
            "static void irq_gc_shutdown(void)",
            "{",
            "\tstruct irq_chip_generic *gc;",
            "",
            "\tlist_for_each_entry(gc, &gc_list, list) {",
            "\t\tstruct irq_chip_type *ct = gc->chip_types;",
            "",
            "\t\tif (ct->chip.irq_pm_shutdown) {",
            "\t\t\tstruct irq_data *data = irq_gc_get_irq_data(gc);",
            "",
            "\t\t\tif (data)",
            "\t\t\t\tct->chip.irq_pm_shutdown(data);",
            "\t\t}",
            "\t}",
            "}",
            "static int __init irq_gc_init_ops(void)",
            "{",
            "\tregister_syscore_ops(&irq_gc_syscore_ops);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "irq_gc_suspend, irq_gc_resume, irq_gc_shutdown, irq_gc_init_ops",
          "description": "集成电源管理操作，通过系统核心操作注册中断控制器的挂起/恢复/关闭处理流程",
          "similarity": 0.6032515168190002
        }
      ]
    }
  ]
}