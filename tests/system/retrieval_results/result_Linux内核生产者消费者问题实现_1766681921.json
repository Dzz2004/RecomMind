{
  "query": "Linux内核生产者消费者问题实现",
  "timestamp": "2025-12-26 00:58:41",
  "retrieved_files": [
    {
      "source_file": "kernel/trace/ring_buffer_benchmark.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:07:53\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\ring_buffer_benchmark.c`\n\n---\n\n# `trace/ring_buffer_benchmark.c` 技术文档\n\n## 1. 文件概述\n\n`ring_buffer_benchmark.c` 是 Linux 内核中用于测试和基准评估 **ring buffer（环形缓冲区）** 性能的模块。该文件实现了生产者-消费者模型，通过高频率写入事件并由消费者读取，来衡量 ring buffer 在高负载下的吞吐量、丢包率、延迟等关键指标。该模块主要用于调试、验证 ring buffer 的正确性和性能，也可用于调度策略对缓冲区性能影响的评估。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct rb_page`**  \n  自定义的 ring buffer 页面结构，包含时间戳 `ts`、提交计数器 `commit` 和 4080 字节的数据区域，用于模拟实际事件存储。\n\n- **全局变量**  \n  - `buffer`: 指向 ring buffer 实例。\n  - `producer` / `consumer`: 生产者和消费者内核线程的 `task_struct`。\n  - `read`: 已成功读取的事件计数。\n  - `test_error`: 错误标志，用于检测数据一致性问题。\n  - `reader_finish`: 控制消费者线程退出的标志。\n\n### 主要函数\n\n- **`read_event(int cpu)`**  \n  从指定 CPU 的 ring buffer 中消费单个事件，验证事件数据是否匹配 CPU ID。\n\n- **`read_page(int cpu)`**  \n  批量读取整个 ring buffer 页面，解析页面内所有事件（包括 padding、time extend 和普通事件），并验证数据完整性。\n\n- **`ring_buffer_consumer(void)`**  \n  消费者线程主循环：交替使用 `read_event` 和 `read_page` 模式读取所有在线 CPU 的事件，直到收到退出信号。\n\n- **`ring_buffer_producer(void)`**  \n  生产者线程主循环：在指定运行时间（默认 10 秒）内高频写入事件，定期唤醒消费者，并在结束后等待消费者完成读取。\n\n- **`TEST_ERROR()` 宏**  \n  用于标记测试失败，触发 `WARN_ON(1)` 并设置全局错误标志。\n\n## 3. 关键实现\n\n### 生产者-消费者同步机制\n- 使用两个 `completion` 对象（`read_start` 和 `read_done`）协调生产者与消费者的结束流程。\n- 通过 `reader_finish` 原子标志通知消费者退出。\n- 生产者每写入 `wakeup_interval`（默认 100）批事件后唤醒消费者，避免消费者长时间休眠。\n\n### 事件写入与验证\n- 每次写入 10 字节事件，内容为当前 CPU ID。\n- 消费者读取后验证数据是否等于对应 CPU ID，不一致则触发 `TEST_ERROR()`。\n- 支持两种读取模式：逐事件读取（`read_event`）和整页读取（`read_page`），后者需手动解析 ring buffer 页面格式。\n\n### 调度策略控制\n- 通过模块参数 `producer_fifo` / `consumer_fifo` 支持设置 SCHED_FIFO 实时调度策略（高/低优先级）。\n- 通过 `producer_nice` / `consumer_nice` 设置普通调度策略下的 nice 值（默认最低优先级 `MAX_NICE`）。\n- 在非抢占内核（`!CONFIG_PREEMPTION`）中，生产者定期调用 `cond_resched()` 避免系统完全卡死。\n\n### 性能统计\n- 统计总运行时间、写入命中数（`hit`）、丢失数（`missed`）、总条目数、溢出数（`overruns`）和读取数。\n- 计算每毫秒写入事件数作为吞吐量指标。\n- 通过 `trace_printk` 输出详细测试结果到 ftrace 缓冲区。\n\n## 4. 依赖关系\n\n- **`<linux/ring_buffer.h>`**：核心依赖，提供 ring buffer 的分配、写入、读取等 API。\n- **`<linux/kthread.h>`**：用于创建和管理生产者/消费者内核线程。\n- **`<linux/completion.h>`**：实现线程间同步。\n- **`<linux/ktime.h>`**：高精度时间测量。\n- **`<asm/local.h>`**：提供 per-CPU 原子操作（用于 `rb_page::commit`）。\n- **`<uapi/linux/sched/types.h>`**：调度策略相关定义。\n- **ftrace 子系统**：通过 `trace_printk` 输出结果，依赖 ftrace 基础设施。\n\n## 5. 使用场景\n\n- **ring buffer 功能验证**：在开发或修改 ring buffer 实现后，运行此模块验证其正确性（如数据一致性、事件顺序）。\n- **性能基准测试**：评估不同负载、调度策略、CPU 配置下 ring buffer 的吞吐量和丢包率。\n- **调度器影响分析**：通过调整生产者/消费者的调度策略（FIFO vs CFS）和优先级，研究调度对高吞吐 I/O 路径的影响。\n- **内核稳定性压力测试**：在高频率写入场景下检测系统响应性和稳定性（尤其在非抢占内核中）。\n- **教学与调试**：作为 ring buffer 使用范例，展示如何正确使用 `ring_buffer_lock_reserve` / `ring_buffer_unlock_commit` 和批量读取接口。",
      "similarity": 0.5692058205604553,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/ring_buffer_benchmark.c",
          "start_line": 230,
          "end_line": 369,
          "content": [
            "static void ring_buffer_producer(void)",
            "{",
            "\tktime_t start_time, end_time, timeout;",
            "\tunsigned long long time;",
            "\tunsigned long long entries;",
            "\tunsigned long long overruns;",
            "\tunsigned long missed = 0;",
            "\tunsigned long hit = 0;",
            "\tunsigned long avg;",
            "\tint cnt = 0;",
            "",
            "\t/*",
            "\t * Hammer the buffer for 10 secs (this may",
            "\t * make the system stall)",
            "\t */",
            "\ttrace_printk(\"Starting ring buffer hammer\\n\");",
            "\tstart_time = ktime_get();",
            "\ttimeout = ktime_add_ns(start_time, RUN_TIME * NSEC_PER_SEC);",
            "\tdo {",
            "\t\tstruct ring_buffer_event *event;",
            "\t\tint *entry;",
            "\t\tint i;",
            "",
            "\t\tfor (i = 0; i < write_iteration; i++) {",
            "\t\t\tevent = ring_buffer_lock_reserve(buffer, 10);",
            "\t\t\tif (!event) {",
            "\t\t\t\tmissed++;",
            "\t\t\t} else {",
            "\t\t\t\thit++;",
            "\t\t\t\tentry = ring_buffer_event_data(event);",
            "\t\t\t\t*entry = smp_processor_id();",
            "\t\t\t\tring_buffer_unlock_commit(buffer);",
            "\t\t\t}",
            "\t\t}",
            "\t\tend_time = ktime_get();",
            "",
            "\t\tcnt++;",
            "\t\tif (consumer && !(cnt % wakeup_interval))",
            "\t\t\twake_up_process(consumer);",
            "",
            "#ifndef CONFIG_PREEMPTION",
            "\t\t/*",
            "\t\t * If we are a non preempt kernel, the 10 seconds run will",
            "\t\t * stop everything while it runs. Instead, we will call",
            "\t\t * cond_resched and also add any time that was lost by a",
            "\t\t * reschedule.",
            "\t\t *",
            "\t\t * Do a cond resched at the same frequency we would wake up",
            "\t\t * the reader.",
            "\t\t */",
            "\t\tif (cnt % wakeup_interval)",
            "\t\t\tcond_resched();",
            "#endif",
            "\t} while (ktime_before(end_time, timeout) && !break_test());",
            "\ttrace_printk(\"End ring buffer hammer\\n\");",
            "",
            "\tif (consumer) {",
            "\t\t/* Init both completions here to avoid races */",
            "\t\tinit_completion(&read_start);",
            "\t\tinit_completion(&read_done);",
            "\t\t/* the completions must be visible before the finish var */",
            "\t\tsmp_wmb();",
            "\t\treader_finish = 1;",
            "\t\twake_up_process(consumer);",
            "\t\twait_for_completion(&read_done);",
            "\t}",
            "",
            "\ttime = ktime_us_delta(end_time, start_time);",
            "",
            "\tentries = ring_buffer_entries(buffer);",
            "\toverruns = ring_buffer_overruns(buffer);",
            "",
            "\tif (test_error)",
            "\t\ttrace_printk(\"ERROR!\\n\");",
            "",
            "\tif (!disable_reader) {",
            "\t\tif (consumer_fifo)",
            "\t\t\ttrace_printk(\"Running Consumer at SCHED_FIFO %s\\n\",",
            "\t\t\t\t     consumer_fifo == 1 ? \"low\" : \"high\");",
            "\t\telse",
            "\t\t\ttrace_printk(\"Running Consumer at nice: %d\\n\",",
            "\t\t\t\t     consumer_nice);",
            "\t}",
            "\tif (producer_fifo)",
            "\t\ttrace_printk(\"Running Producer at SCHED_FIFO %s\\n\",",
            "\t\t\t     producer_fifo == 1 ? \"low\" : \"high\");",
            "\telse",
            "\t\ttrace_printk(\"Running Producer at nice: %d\\n\",",
            "\t\t\t     producer_nice);",
            "",
            "\t/* Let the user know that the test is running at low priority */",
            "\tif (!producer_fifo && !consumer_fifo &&",
            "\t    producer_nice == MAX_NICE && consumer_nice == MAX_NICE)",
            "\t\ttrace_printk(\"WARNING!!! This test is running at lowest priority.\\n\");",
            "",
            "\ttrace_printk(\"Time:     %lld (usecs)\\n\", time);",
            "\ttrace_printk(\"Overruns: %lld\\n\", overruns);",
            "\tif (disable_reader)",
            "\t\ttrace_printk(\"Read:     (reader disabled)\\n\");",
            "\telse",
            "\t\ttrace_printk(\"Read:     %ld  (by %s)\\n\", read,",
            "\t\t\tread_events ? \"events\" : \"pages\");",
            "\ttrace_printk(\"Entries:  %lld\\n\", entries);",
            "\ttrace_printk(\"Total:    %lld\\n\", entries + overruns + read);",
            "\ttrace_printk(\"Missed:   %ld\\n\", missed);",
            "\ttrace_printk(\"Hit:      %ld\\n\", hit);",
            "",
            "\t/* Convert time from usecs to millisecs */",
            "\tdo_div(time, USEC_PER_MSEC);",
            "\tif (time)",
            "\t\thit /= (long)time;",
            "\telse",
            "\t\ttrace_printk(\"TIME IS ZERO??\\n\");",
            "",
            "\ttrace_printk(\"Entries per millisec: %ld\\n\", hit);",
            "",
            "\tif (hit) {",
            "\t\t/* Calculate the average time in nanosecs */",
            "\t\tavg = NSEC_PER_MSEC / hit;",
            "\t\ttrace_printk(\"%ld ns per entry\\n\", avg);",
            "\t}",
            "",
            "\tif (missed) {",
            "\t\tif (time)",
            "\t\t\tmissed /= (long)time;",
            "",
            "\t\ttrace_printk(\"Total iterations per millisec: %ld\\n\",",
            "\t\t\t     hit + missed);",
            "",
            "\t\t/* it is possible that hit + missed will overflow and be zero */",
            "\t\tif (!(hit + missed)) {",
            "\t\t\ttrace_printk(\"hit + missed overflowed and totalled zero!\\n\");",
            "\t\t\thit--; /* make it non zero */",
            "\t\t}",
            "",
            "\t\t/* Calculate the average time in nanosecs */",
            "\t\tavg = NSEC_PER_MSEC / (hit + missed);",
            "\t\ttrace_printk(\"%ld ns per entry\\n\", avg);",
            "\t}",
            "}"
          ],
          "function_name": "ring_buffer_producer",
          "description": "生产者线程实现，周期性地向环形缓冲区写入事件数据，统计吞吐量和丢包率，并在测试结束时输出性能报告及系统状态信息。",
          "similarity": 0.5801215767860413
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/ring_buffer_benchmark.c",
          "start_line": 80,
          "end_line": 225,
          "content": [
            "static bool break_test(void)",
            "{",
            "\treturn test_error || kthread_should_stop();",
            "}",
            "static enum event_status read_event(int cpu)",
            "{",
            "\tstruct ring_buffer_event *event;",
            "\tint *entry;",
            "\tu64 ts;",
            "",
            "\tevent = ring_buffer_consume(buffer, cpu, &ts, NULL);",
            "\tif (!event)",
            "\t\treturn EVENT_DROPPED;",
            "",
            "\tentry = ring_buffer_event_data(event);",
            "\tif (*entry != cpu) {",
            "\t\tTEST_ERROR();",
            "\t\treturn EVENT_DROPPED;",
            "\t}",
            "",
            "\tread++;",
            "\treturn EVENT_FOUND;",
            "}",
            "static enum event_status read_page(int cpu)",
            "{",
            "\tstruct ring_buffer_event *event;",
            "\tstruct rb_page *rpage;",
            "\tunsigned long commit;",
            "\tvoid *bpage;",
            "\tint *entry;",
            "\tint ret;",
            "\tint inc;",
            "\tint i;",
            "",
            "\tbpage = ring_buffer_alloc_read_page(buffer, cpu);",
            "\tif (IS_ERR(bpage))",
            "\t\treturn EVENT_DROPPED;",
            "",
            "\tret = ring_buffer_read_page(buffer, &bpage, PAGE_SIZE, cpu, 1);",
            "\tif (ret >= 0) {",
            "\t\trpage = bpage;",
            "\t\t/* The commit may have missed event flags set, clear them */",
            "\t\tcommit = local_read(&rpage->commit) & 0xfffff;",
            "\t\tfor (i = 0; i < commit && !test_error ; i += inc) {",
            "",
            "\t\t\tif (i >= (PAGE_SIZE - offsetof(struct rb_page, data))) {",
            "\t\t\t\tTEST_ERROR();",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t\tinc = -1;",
            "\t\t\tevent = (void *)&rpage->data[i];",
            "\t\t\tswitch (event->type_len) {",
            "\t\t\tcase RINGBUF_TYPE_PADDING:",
            "\t\t\t\t/* failed writes may be discarded events */",
            "\t\t\t\tif (!event->time_delta)",
            "\t\t\t\t\tTEST_ERROR();",
            "\t\t\t\tinc = event->array[0] + 4;",
            "\t\t\t\tbreak;",
            "\t\t\tcase RINGBUF_TYPE_TIME_EXTEND:",
            "\t\t\t\tinc = 8;",
            "\t\t\t\tbreak;",
            "\t\t\tcase 0:",
            "\t\t\t\tentry = ring_buffer_event_data(event);",
            "\t\t\t\tif (*entry != cpu) {",
            "\t\t\t\t\tTEST_ERROR();",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tread++;",
            "\t\t\t\tif (!event->array[0]) {",
            "\t\t\t\t\tTEST_ERROR();",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tinc = event->array[0] + 4;",
            "\t\t\t\tbreak;",
            "\t\t\tdefault:",
            "\t\t\t\tentry = ring_buffer_event_data(event);",
            "\t\t\t\tif (*entry != cpu) {",
            "\t\t\t\t\tTEST_ERROR();",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tread++;",
            "\t\t\t\tinc = ((event->type_len + 1) * 4);",
            "\t\t\t}",
            "\t\t\tif (test_error)",
            "\t\t\t\tbreak;",
            "",
            "\t\t\tif (inc <= 0) {",
            "\t\t\t\tTEST_ERROR();",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tring_buffer_free_read_page(buffer, cpu, bpage);",
            "",
            "\tif (ret < 0)",
            "\t\treturn EVENT_DROPPED;",
            "\treturn EVENT_FOUND;",
            "}",
            "static void ring_buffer_consumer(void)",
            "{",
            "\t/* toggle between reading pages and events */",
            "\tread_events ^= 1;",
            "",
            "\tread = 0;",
            "\t/*",
            "\t * Continue running until the producer specifically asks to stop",
            "\t * and is ready for the completion.",
            "\t */",
            "\twhile (!READ_ONCE(reader_finish)) {",
            "\t\tint found = 1;",
            "",
            "\t\twhile (found && !test_error) {",
            "\t\t\tint cpu;",
            "",
            "\t\t\tfound = 0;",
            "\t\t\tfor_each_online_cpu(cpu) {",
            "\t\t\t\tenum event_status stat;",
            "",
            "\t\t\t\tif (read_events)",
            "\t\t\t\t\tstat = read_event(cpu);",
            "\t\t\t\telse",
            "\t\t\t\t\tstat = read_page(cpu);",
            "",
            "\t\t\t\tif (test_error)",
            "\t\t\t\t\tbreak;",
            "",
            "\t\t\t\tif (stat == EVENT_FOUND)",
            "\t\t\t\t\tfound = 1;",
            "",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\t/* Wait till the producer wakes us up when there is more data",
            "\t\t * available or when the producer wants us to finish reading.",
            "\t\t */",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\tif (reader_finish)",
            "\t\t\tbreak;",
            "",
            "\t\tschedule();",
            "\t}",
            "\t__set_current_state(TASK_RUNNING);",
            "\treader_finish = 0;",
            "\tcomplete(&read_done);",
            "}"
          ],
          "function_name": "break_test, read_event, read_page, ring_buffer_consumer",
          "description": "实现消费者线程的核心逻辑，包含事件/页面读取函数，检测数据一致性，通过轮询方式持续从缓冲区读取数据直至中断条件触发。",
          "similarity": 0.5761245489120483
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/ring_buffer_benchmark.c",
          "start_line": 1,
          "end_line": 79,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * ring buffer tester and benchmark",
            " *",
            " * Copyright (C) 2009 Steven Rostedt <srostedt@redhat.com>",
            " */",
            "#include <linux/ring_buffer.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/module.h>",
            "#include <linux/ktime.h>",
            "#include <asm/local.h>",
            "",
            "struct rb_page {",
            "\tu64\t\tts;",
            "\tlocal_t\t\tcommit;",
            "\tchar\t\tdata[4080];",
            "};",
            "",
            "/* run time and sleep time in seconds */",
            "#define RUN_TIME\t10ULL",
            "#define SLEEP_TIME\t10",
            "",
            "/* number of events for writer to wake up the reader */",
            "static int wakeup_interval = 100;",
            "",
            "static int reader_finish;",
            "static DECLARE_COMPLETION(read_start);",
            "static DECLARE_COMPLETION(read_done);",
            "",
            "static struct trace_buffer *buffer;",
            "static struct task_struct *producer;",
            "static struct task_struct *consumer;",
            "static unsigned long read;",
            "",
            "static unsigned int disable_reader;",
            "module_param(disable_reader, uint, 0644);",
            "MODULE_PARM_DESC(disable_reader, \"only run producer\");",
            "",
            "static unsigned int write_iteration = 50;",
            "module_param(write_iteration, uint, 0644);",
            "MODULE_PARM_DESC(write_iteration, \"# of writes between timestamp readings\");",
            "",
            "static int producer_nice = MAX_NICE;",
            "static int consumer_nice = MAX_NICE;",
            "",
            "static int producer_fifo;",
            "static int consumer_fifo;",
            "",
            "module_param(producer_nice, int, 0644);",
            "MODULE_PARM_DESC(producer_nice, \"nice prio for producer\");",
            "",
            "module_param(consumer_nice, int, 0644);",
            "MODULE_PARM_DESC(consumer_nice, \"nice prio for consumer\");",
            "",
            "module_param(producer_fifo, int, 0644);",
            "MODULE_PARM_DESC(producer_fifo, \"use fifo for producer: 0 - disabled, 1 - low prio, 2 - fifo\");",
            "",
            "module_param(consumer_fifo, int, 0644);",
            "MODULE_PARM_DESC(consumer_fifo, \"use fifo for consumer: 0 - disabled, 1 - low prio, 2 - fifo\");",
            "",
            "static int read_events;",
            "",
            "static int test_error;",
            "",
            "#define TEST_ERROR()\t\t\t\t\\",
            "\tdo {\t\t\t\t\t\\",
            "\t\tif (!test_error) {\t\t\\",
            "\t\t\ttest_error = 1;\t\t\\",
            "\t\t\tWARN_ON(1);\t\t\\",
            "\t\t}\t\t\t\t\\",
            "\t} while (0)",
            "",
            "enum event_status {",
            "\tEVENT_FOUND,",
            "\tEVENT_DROPPED,",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义了环形缓冲区基准测试所需的全局变量、模块参数及辅助结构体rb_page，用于存储时间戳和事件数据，支持通过参数控制测试行为。",
          "similarity": 0.43088361620903015
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/ring_buffer_benchmark.c",
          "start_line": 484,
          "end_line": 490,
          "content": [
            "static void __exit ring_buffer_benchmark_exit(void)",
            "{",
            "\tkthread_stop(producer);",
            "\tif (consumer)",
            "\t\tkthread_stop(consumer);",
            "\tring_buffer_free(buffer);",
            "}"
          ],
          "function_name": "ring_buffer_benchmark_exit",
          "description": "模块卸载时释放所有资源，强制停止工作线程，回收环形缓冲区内存，确保系统状态回归初始状态。",
          "similarity": 0.4272107779979706
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/trace/ring_buffer_benchmark.c",
          "start_line": 371,
          "end_line": 479,
          "content": [
            "static void wait_to_die(void)",
            "{",
            "\tset_current_state(TASK_INTERRUPTIBLE);",
            "\twhile (!kthread_should_stop()) {",
            "\t\tschedule();",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t}",
            "\t__set_current_state(TASK_RUNNING);",
            "}",
            "static int ring_buffer_consumer_thread(void *arg)",
            "{",
            "\twhile (!break_test()) {",
            "\t\tcomplete(&read_start);",
            "",
            "\t\tring_buffer_consumer();",
            "",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\tif (break_test())",
            "\t\t\tbreak;",
            "\t\tschedule();",
            "\t}",
            "\t__set_current_state(TASK_RUNNING);",
            "",
            "\tif (!kthread_should_stop())",
            "\t\twait_to_die();",
            "",
            "\treturn 0;",
            "}",
            "static int ring_buffer_producer_thread(void *arg)",
            "{",
            "\twhile (!break_test()) {",
            "\t\tring_buffer_reset(buffer);",
            "",
            "\t\tif (consumer) {",
            "\t\t\twake_up_process(consumer);",
            "\t\t\twait_for_completion(&read_start);",
            "\t\t}",
            "",
            "\t\tring_buffer_producer();",
            "\t\tif (break_test())",
            "\t\t\tgoto out_kill;",
            "",
            "\t\ttrace_printk(\"Sleeping for 10 secs\\n\");",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\tif (break_test())",
            "\t\t\tgoto out_kill;",
            "\t\tschedule_timeout(HZ * SLEEP_TIME);",
            "\t}",
            "",
            "out_kill:",
            "\t__set_current_state(TASK_RUNNING);",
            "\tif (!kthread_should_stop())",
            "\t\twait_to_die();",
            "",
            "\treturn 0;",
            "}",
            "static int __init ring_buffer_benchmark_init(void)",
            "{",
            "\tint ret;",
            "",
            "\t/* make a one meg buffer in overwite mode */",
            "\tbuffer = ring_buffer_alloc(1000000, RB_FL_OVERWRITE);",
            "\tif (!buffer)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (!disable_reader) {",
            "\t\tconsumer = kthread_create(ring_buffer_consumer_thread,",
            "\t\t\t\t\t  NULL, \"rb_consumer\");",
            "\t\tret = PTR_ERR(consumer);",
            "\t\tif (IS_ERR(consumer))",
            "\t\t\tgoto out_fail;",
            "\t}",
            "",
            "\tproducer = kthread_run(ring_buffer_producer_thread,",
            "\t\t\t       NULL, \"rb_producer\");",
            "\tret = PTR_ERR(producer);",
            "",
            "\tif (IS_ERR(producer))",
            "\t\tgoto out_kill;",
            "",
            "\t/*",
            "\t * Run them as low-prio background tasks by default:",
            "\t */",
            "\tif (!disable_reader) {",
            "\t\tif (consumer_fifo >= 2)",
            "\t\t\tsched_set_fifo(consumer);",
            "\t\telse if (consumer_fifo == 1)",
            "\t\t\tsched_set_fifo_low(consumer);",
            "\t\telse",
            "\t\t\tset_user_nice(consumer, consumer_nice);",
            "\t}",
            "",
            "\tif (producer_fifo >= 2)",
            "\t\tsched_set_fifo(producer);",
            "\telse if (producer_fifo == 1)",
            "\t\tsched_set_fifo_low(producer);",
            "\telse",
            "\t\tset_user_nice(producer, producer_nice);",
            "",
            "\treturn 0;",
            "",
            " out_kill:",
            "\tif (consumer)",
            "\t\tkthread_stop(consumer);",
            "",
            " out_fail:",
            "\tring_buffer_free(buffer);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "wait_to_die, ring_buffer_consumer_thread, ring_buffer_producer_thread, ring_buffer_benchmark_init",
          "description": "管理测试线程的启动与调度，包含线程入口函数、中止等待机制及初始化函数，动态配置线程优先级并分配环形缓冲区实例。",
          "similarity": 0.39189693331718445
        }
      ]
    },
    {
      "source_file": "mm/usercopy.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:30:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `usercopy.c`\n\n---\n\n# usercopy.c 技术文档\n\n## 1. 文件概述\n\n`usercopy.c` 实现了 Linux 内核中 `CONFIG_HARDENED_USERCOPY*` 系列安全机制的核心检查逻辑，旨在防止内核内存在用户空间与内核空间之间进行数据拷贝（如 `copy_from_user()` 和 `copy_to_user()`）时发生**非预期的暴露（exposure）或覆写（overwrite）**。该机制源自 PaX 的 `PAX_USERCOPY` 安全特性，通过严格验证待拷贝缓冲区的合法性，阻止攻击者利用内核漏洞读取或篡改敏感内核数据。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`__check_object_size(const void *ptr, unsigned long n, bool to_user)`**  \n  入口函数，对指定内存区域 `[ptr, ptr+n)` 执行完整的安全性检查。\n  \n- **`usercopy_abort(const char *name, const char *detail, bool to_user, unsigned long offset, unsigned long len)`**  \n  安全违规处理函数，打印详细错误信息并触发内核 `BUG()` 崩溃。\n\n- **`check_stack_object(const void *obj, unsigned long len)`**  \n  检查对象是否位于当前任务的合法栈范围内，并进一步判断是否处于有效栈帧内。\n\n- **`check_heap_object(const void *ptr, unsigned long n, bool to_user)`**  \n  验证堆分配对象（包括 slab、vmalloc、高端内存映射等）的边界和合法性。\n\n- **`check_kernel_text_object(unsigned long ptr, unsigned long n, bool to_user)`**  \n  检测访问是否涉及内核代码段（`.text`），防止内核指令被意外读取或修改。\n\n- **`check_bogus_address(unsigned long ptr, unsigned long n, bool to_user)`**  \n  检查地址是否为非法值（如空指针、地址回绕等）。\n\n- **`overlaps(unsigned long ptr, unsigned long n, unsigned long low, unsigned long high)`**  \n  辅助函数，判断两个内存区间是否重叠。\n\n### 关键数据结构/宏\n\n- **`bypass_usercopy_checks`**  \n  静态跳转键（static key），用于在运行时动态关闭所有用户拷贝检查（通常仅用于调试）。\n\n- **`parse_hardened_usercopy(char *str)`**  \n  内核启动参数解析函数（未完整显示），用于通过 `hardened_usercopy=` 参数控制是否启用检查。\n\n- **返回码枚举（隐式定义）**：\n  - `NOT_STACK`：对象不在栈上\n  - `GOOD_FRAME`：对象完全位于有效栈帧内\n  - `GOOD_STACK`：对象在栈上但无法精确验证帧\n  - `BAD_STACK`：栈位置非法或跨越栈边界\n\n## 3. 关键实现\n\n### 多层次内存区域验证\n`__check_object_size()` 按顺序执行以下检查：\n\n1. **地址有效性检查**  \n   使用 `check_bogus_address()` 排除空指针、零长度及地址算术溢出（回绕）情况。\n\n2. **栈内存检查**  \n   调用 `check_stack_object()`：\n   - 首先确认对象完全位于当前任务的栈页（`[stack, stack + THREAD_SIZE)`）内；\n   - 若架构支持（`arch_within_stack_frames`），进一步验证是否处于合法调用帧中；\n   - 若支持当前栈指针（`current_stack_pointer`），还会检查对象是否位于当前栈指针的有效方向内（考虑栈增长方向）。\n\n3. **堆内存检查**  \n   `check_heap_object()` 区分多种分配类型：\n   - **kmap 地址**：限制单页内偏移不超过页边界；\n   - **vmalloc 地址**：通过 `find_vmap_area()` 获取虚拟内存区域，验证不越界；\n   - **物理页分配（folio）**：\n     - 若为 slab 对象，调用 `__check_heap_object()`（定义于 `slab.h`）检查是否在缓存的 `useroffset/usersize` 白名单范围内；\n     - 若为大页（`folio_test_large`），验证不超出 folio 范围。\n\n4. **内核文本段保护**  \n   `check_kernel_text_object()` 检查是否与 `_stext` 到 `_etext` 区间重叠，并额外处理某些架构存在的线性映射别名（通过 `lm_alias()`）。\n\n### 安全违规响应\n一旦任一检查失败，立即调用 `usercopy_abort()`：\n- 打印包含操作方向（to/from user）、对象类型、偏移、长度等详细信息；\n- 调用 `BUG()` 触发内核崩溃，防止继续执行可能被利用的路径。\n\n### 性能优化\n- 使用 `static_branch_unlikely(&bypass_usercopy_checks)` 实现检查开关，正常启用时几乎无性能开销；\n- 栈帧检查使用 `noinline` 避免内联膨胀；\n- 零长度拷贝直接跳过所有检查。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/mm.h>`, `<linux/slab.h>`, `\"slab.h\"`：内存管理及 slab 分配器接口\n  - `<linux/vmalloc.h>`：vmalloc 区域查询\n  - `<linux/highmem.h>`：高端内存映射（kmap）判断\n  - `<asm/sections.h>`：内核符号 `_stext`/`_etext`\n  - `<linux/jump_label.h>`：静态跳转键支持\n\n- **架构依赖**：\n  - `arch_within_stack_frames()`：由各架构提供栈帧验证实现\n  - `current_stack_pointer`：需 `CONFIG_ARCH_HAS_CURRENT_STACK_POINTER`\n  - `lm_alias()`：处理内核线性映射别名（如 x86 的 `__va()`/`__pa()` 非对称映射）\n\n- **导出符号**：\n  - `EXPORT_SYMBOL(__check_object_size)`：供其他模块（如驱动、文件系统）在自定义用户拷贝路径中调用\n\n## 5. 使用场景\n\n- **内核用户拷贝入口点**  \n  在 `copy_from_user()` / `copy_to_user()` 等函数内部（通常通过 `might_fault()` 或特定配置选项）调用 `__check_object_size()`，确保传入的内核缓冲区安全。\n\n- **Slab 缓存白名单验证**  \n  当使用 `kmem_cache_create_usercopy()` 创建允许部分暴露给用户的 slab 缓存时，此文件验证访问是否严格限制在声明的 `useroffset` 和 `usersize` 范围内。\n\n- **安全加固默认行为**  \n  启用 `CONFIG_HARDENED_USERCOPY` 后，所有未显式绕过检查的内核-用户数据传输均受保护，有效缓解因缓冲区溢出、Use-After-Free 等漏洞导致的内核信息泄露或提权攻击。\n\n- **调试与禁用**  \n  通过内核启动参数 `hardened_usercopy=0` 可临时禁用检查（需 `parse_hardened_usercopy` 完整实现），用于调试或兼容特殊硬件驱动。",
      "similarity": 0.5316581130027771,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/usercopy.c",
          "start_line": 37,
          "end_line": 142,
          "content": [
            "static noinline int check_stack_object(const void *obj, unsigned long len)",
            "{",
            "\tconst void * const stack = task_stack_page(current);",
            "\tconst void * const stackend = stack + THREAD_SIZE;",
            "\tint ret;",
            "",
            "\t/* Object is not on the stack at all. */",
            "\tif (obj + len <= stack || stackend <= obj)",
            "\t\treturn NOT_STACK;",
            "",
            "\t/*",
            "\t * Reject: object partially overlaps the stack (passing the",
            "\t * check above means at least one end is within the stack,",
            "\t * so if this check fails, the other end is outside the stack).",
            "\t */",
            "\tif (obj < stack || stackend < obj + len)",
            "\t\treturn BAD_STACK;",
            "",
            "\t/* Check if object is safely within a valid frame. */",
            "\tret = arch_within_stack_frames(stack, stackend, obj, len);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\t/* Finally, check stack depth if possible. */",
            "#ifdef CONFIG_ARCH_HAS_CURRENT_STACK_POINTER",
            "\tif (IS_ENABLED(CONFIG_STACK_GROWSUP)) {",
            "\t\tif ((void *)current_stack_pointer < obj + len)",
            "\t\t\treturn BAD_STACK;",
            "\t} else {",
            "\t\tif (obj < (void *)current_stack_pointer)",
            "\t\t\treturn BAD_STACK;",
            "\t}",
            "#endif",
            "",
            "\treturn GOOD_STACK;",
            "}",
            "void __noreturn usercopy_abort(const char *name, const char *detail,",
            "\t\t\t       bool to_user, unsigned long offset,",
            "\t\t\t       unsigned long len)",
            "{",
            "\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",",
            "\t\t to_user ? \"exposure\" : \"overwrite\",",
            "\t\t to_user ? \"from\" : \"to\",",
            "\t\t name ? : \"unknown?!\",",
            "\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",",
            "\t\t offset, len);",
            "",
            "\t/*",
            "\t * For greater effect, it would be nice to do do_group_exit(),",
            "\t * but BUG() actually hooks all the lock-breaking and per-arch",
            "\t * Oops code, so that is used here instead.",
            "\t */",
            "\tBUG();",
            "}",
            "static bool overlaps(const unsigned long ptr, unsigned long n,",
            "\t\t     unsigned long low, unsigned long high)",
            "{",
            "\tconst unsigned long check_low = ptr;",
            "\tunsigned long check_high = check_low + n;",
            "",
            "\t/* Does not overlap if entirely above or entirely below. */",
            "\tif (check_low >= high || check_high <= low)",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}",
            "static inline void check_kernel_text_object(const unsigned long ptr,",
            "\t\t\t\t\t    unsigned long n, bool to_user)",
            "{",
            "\tunsigned long textlow = (unsigned long)_stext;",
            "\tunsigned long texthigh = (unsigned long)_etext;",
            "\tunsigned long textlow_linear, texthigh_linear;",
            "",
            "\tif (overlaps(ptr, n, textlow, texthigh))",
            "\t\tusercopy_abort(\"kernel text\", NULL, to_user, ptr - textlow, n);",
            "",
            "\t/*",
            "\t * Some architectures have virtual memory mappings with a secondary",
            "\t * mapping of the kernel text, i.e. there is more than one virtual",
            "\t * kernel address that points to the kernel image. It is usually",
            "\t * when there is a separate linear physical memory mapping, in that",
            "\t * __pa() is not just the reverse of __va(). This can be detected",
            "\t * and checked:",
            "\t */",
            "\ttextlow_linear = (unsigned long)lm_alias(textlow);",
            "\t/* No different mapping: we're done. */",
            "\tif (textlow_linear == textlow)",
            "\t\treturn;",
            "",
            "\t/* Check the secondary mapping... */",
            "\ttexthigh_linear = (unsigned long)lm_alias(texthigh);",
            "\tif (overlaps(ptr, n, textlow_linear, texthigh_linear))",
            "\t\tusercopy_abort(\"linear kernel text\", NULL, to_user,",
            "\t\t\t       ptr - textlow_linear, n);",
            "}",
            "static inline void check_bogus_address(const unsigned long ptr, unsigned long n,",
            "\t\t\t\t       bool to_user)",
            "{",
            "\t/* Reject if object wraps past end of memory. */",
            "\tif (ptr + (n - 1) < ptr)",
            "\t\tusercopy_abort(\"wrapped address\", NULL, to_user, 0, ptr + n);",
            "",
            "\t/* Reject if NULL or ZERO-allocation. */",
            "\tif (ZERO_OR_NULL_PTR(ptr))",
            "\t\tusercopy_abort(\"null address\", NULL, to_user, ptr, n);",
            "}"
          ],
          "function_name": "check_stack_object, usercopy_abort, overlaps, check_kernel_text_object, check_bogus_address",
          "description": "实现栈对象边界检查、异常终止函数、地址范围重叠检测及内核文本区域防护逻辑，用于防止非法内存访问",
          "similarity": 0.5303351879119873
        },
        {
          "chunk_id": 2,
          "file_path": "mm/usercopy.c",
          "start_line": 162,
          "end_line": 258,
          "content": [
            "static inline void check_heap_object(const void *ptr, unsigned long n,",
            "\t\t\t\t     bool to_user)",
            "{",
            "\tunsigned long addr = (unsigned long)ptr;",
            "\tunsigned long offset;",
            "\tstruct folio *folio;",
            "",
            "\tif (is_kmap_addr(ptr)) {",
            "\t\toffset = offset_in_page(ptr);",
            "\t\tif (n > PAGE_SIZE - offset)",
            "\t\t\tusercopy_abort(\"kmap\", NULL, to_user, offset, n);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (is_vmalloc_addr(ptr) && !pagefault_disabled()) {",
            "\t\tstruct vmap_area *area = find_vmap_area(addr);",
            "",
            "\t\tif (!area)",
            "\t\t\tusercopy_abort(\"vmalloc\", \"no area\", to_user, 0, n);",
            "",
            "\t\tif (n > area->va_end - addr) {",
            "\t\t\toffset = addr - area->va_start;",
            "\t\t\tusercopy_abort(\"vmalloc\", NULL, to_user, offset, n);",
            "\t\t}",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (!virt_addr_valid(ptr))",
            "\t\treturn;",
            "",
            "\tfolio = virt_to_folio(ptr);",
            "",
            "\tif (folio_test_slab(folio)) {",
            "\t\t/* Check slab allocator for flags and size. */",
            "\t\t__check_heap_object(ptr, n, folio_slab(folio), to_user);",
            "\t} else if (folio_test_large(folio)) {",
            "\t\toffset = ptr - folio_address(folio);",
            "\t\tif (n > folio_size(folio) - offset)",
            "\t\t\tusercopy_abort(\"page alloc\", NULL, to_user, offset, n);",
            "\t}",
            "}",
            "void __check_object_size(const void *ptr, unsigned long n, bool to_user)",
            "{",
            "\tif (static_branch_unlikely(&bypass_usercopy_checks))",
            "\t\treturn;",
            "",
            "\t/* Skip all tests if size is zero. */",
            "\tif (!n)",
            "\t\treturn;",
            "",
            "\t/* Check for invalid addresses. */",
            "\tcheck_bogus_address((const unsigned long)ptr, n, to_user);",
            "",
            "\t/* Check for bad stack object. */",
            "\tswitch (check_stack_object(ptr, n)) {",
            "\tcase NOT_STACK:",
            "\t\t/* Object is not touching the current process stack. */",
            "\t\tbreak;",
            "\tcase GOOD_FRAME:",
            "\tcase GOOD_STACK:",
            "\t\t/*",
            "\t\t * Object is either in the correct frame (when it",
            "\t\t * is possible to check) or just generally on the",
            "\t\t * process stack (when frame checking not available).",
            "\t\t */",
            "\t\treturn;",
            "\tdefault:",
            "\t\tusercopy_abort(\"process stack\", NULL, to_user,",
            "#ifdef CONFIG_ARCH_HAS_CURRENT_STACK_POINTER",
            "\t\t\tIS_ENABLED(CONFIG_STACK_GROWSUP) ?",
            "\t\t\t\tptr - (void *)current_stack_pointer :",
            "\t\t\t\t(void *)current_stack_pointer - ptr,",
            "#else",
            "\t\t\t0,",
            "#endif",
            "\t\t\tn);",
            "\t}",
            "",
            "\t/* Check for bad heap object. */",
            "\tcheck_heap_object(ptr, n, to_user);",
            "",
            "\t/* Check for object in kernel to avoid text exposure. */",
            "\tcheck_kernel_text_object((const unsigned long)ptr, n, to_user);",
            "}",
            "static int __init parse_hardened_usercopy(char *str)",
            "{",
            "\tif (kstrtobool(str, &enable_checks))",
            "\t\tpr_warn(\"Invalid option string for hardened_usercopy: '%s'\\n\",",
            "\t\t\tstr);",
            "\treturn 1;",
            "}",
            "static int __init set_hardened_usercopy(void)",
            "{",
            "\tif (enable_checks == false)",
            "\t\tstatic_branch_enable(&bypass_usercopy_checks);",
            "\treturn 1;",
            "}"
          ],
          "function_name": "check_heap_object, __check_object_size, parse_hardened_usercopy, set_hardened_usercopy",
          "description": "实现堆对象有效性检查、通用对象大小验证及硬编码用户复制检查配置解析与启用逻辑，支持动态配置安全检查机制",
          "similarity": 0.49229106307029724
        },
        {
          "chunk_id": 0,
          "file_path": "mm/usercopy.c",
          "start_line": 1,
          "end_line": 36,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * This implements the various checks for CONFIG_HARDENED_USERCOPY*,",
            " * which are designed to protect kernel memory from needless exposure",
            " * and overwrite under many unintended conditions. This code is based",
            " * on PAX_USERCOPY, which is:",
            " *",
            " * Copyright (C) 2001-2016 PaX Team, Bradley Spengler, Open Source",
            " * Security Inc.",
            " */",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kstrtox.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/atomic.h>",
            "#include <linux/jump_label.h>",
            "#include <asm/sections.h>",
            "#include \"slab.h\"",
            "",
            "/*",
            " * Checks if a given pointer and length is contained by the current",
            " * stack frame (if possible).",
            " *",
            " * Returns:",
            " *\tNOT_STACK: not at all on the stack",
            " *\tGOOD_FRAME: fully within a valid stack frame",
            " *\tGOOD_STACK: within the current stack (when can't frame-check exactly)",
            " *\tBAD_STACK: error condition (invalid stack position or bad stack frame)",
            " */"
          ],
          "function_name": null,
          "description": "声明CONFIG_HARDENED_USERCOPY相关的检查常量和基础头文件，定义用于检测栈对象是否安全的返回值类型",
          "similarity": 0.42346370220184326
        }
      ]
    },
    {
      "source_file": "kernel/kallsyms_selftest.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:14:43\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kallsyms_selftest.c`\n\n---\n\n# kallsyms_selftest.c 技术文档\n\n## 文件概述\n\n`kallsyms_selftest.c` 是 Linux 内核中用于对 `kallsyms`（内核符号表）子系统进行功能验证和性能测试的自检模块。该文件通过一系列测试用例，验证 `kallsyms_lookup_name()`、`kallsyms_on_each_symbol()` 和 `kallsyms_on_each_match_symbol()` 等核心接口的正确性，并评估其性能表现。同时，该模块还计算内核符号表的压缩率，用于评估符号表存储效率。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct test_stat`**  \n  用于记录测试过程中的统计信息，包括最小/最大耗时、调用次数、地址记录、累计时间等。\n\n- **`struct test_item`**  \n  定义测试项，包含符号名称和预期地址，用于验证符号解析的准确性。\n\n- **`test_items[]`**  \n  预定义的测试符号数组，涵盖静态函数、全局函数、弱符号以及（在 `CONFIG_KALLSYMS_ALL` 启用时）全局和静态变量。\n\n### 主要函数\n\n- **`test_kallsyms_basic_function()`**  \n  核心功能测试函数，验证三种符号查找接口对预定义符号的解析是否准确。\n\n- **`test_kallsyms_compression_ratio()`**  \n  计算并输出内核符号表的压缩率，包括原始符号名总长度与压缩后实际占用内存的对比。\n\n- **`test_perf_kallsyms_lookup_name()`**  \n  性能测试：遍历所有符号，测量 `kallsyms_lookup_name()` 的单次调用耗时（最小值、最大值、平均值）。\n\n- **`test_perf_kallsyms_on_each_symbol()`**  \n  性能测试：使用一个不可能匹配的“桩”符号名，遍历整个符号表，测量 `kallsyms_on_each_symbol()` 的总耗时。\n\n- **`test_perf_kallsyms_on_each_match_symbol()`**  \n  性能测试：使用桩符号名调用 `kallsyms_on_each_match_symbol()`，测量其遍历耗时。\n\n- **`lookup_name()` / `find_symbol()` / `match_symbol()`**  \n  回调函数，分别用于上述性能测试和功能验证中，收集统计信息。\n\n- **`match_cleanup_name()`**  \n  辅助函数，用于处理 Clang LTO（Link Time Optimization）编译时生成的带 `.llvm.` 后缀的符号名，确保测试兼容性。\n\n## 关键实现\n\n1. **测试符号设计**  \n   模块内部定义了多种类型的符号（静态函数、全局函数、弱函数、BSS/DATA 段变量），覆盖 `kallsyms` 支持的不同符号类别。变量测试仅在 `CONFIG_KALLSYMS_ALL` 配置启用时进行。\n\n2. **桩符号（Stub Symbol）生成**  \n   为避免在性能测试中因匹配成功而提前退出，模块构造一个由数字 `'4'` 组成的符号名（符号名不能以数字开头，确保无匹配）。其长度设为所有符号名的平均长度，使测试更贴近真实场景。\n\n3. **压缩率计算逻辑**  \n   - 通过 `kallsyms_on_each_symbol()` 累加所有符号名长度得到原始大小（`total_len`）。\n   - 手动解析 `kallsyms_names[]` 数组的压缩格式（支持 7/15 位长度编码），计算压缩后数据区大小（`off - num`，排除长度字段）。\n   - 加上 `kallsyms_token_table[]` 和 `kallsyms_token_index[]` 的内存开销，得到总压缩大小（`total_size`）。\n   - 最终计算压缩率：`ratio = (total_size * 10000) / total_len`，以百分比形式输出（保留两位小数）。\n\n4. **LTO 符号兼容性处理**  \n   在启用 Clang LTO 时，编译器会为符号添加 `.llvm.<hash>` 后缀。`match_cleanup_name()` 函数通过检查前缀是否匹配原始符号名，确保测试能正确识别这类符号。\n\n5. **性能测量方法**  \n   使用 `ktime_get_ns()` 获取纳秒级高精度时间戳，在每次符号查找前后采样，计算单次或整体操作耗时。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/kallsyms.h>`：提供 `kallsyms_lookup_name()`、`kallsyms_on_each_symbol()` 等公共接口。\n  - `\"kallsyms_internal.h\"`：访问 `kallsyms` 内部数据结构（如 `kallsyms_names`、`kallsyms_token_table`、`kallsyms_num_syms`），用于压缩率计算。\n  - `\"kallsyms_selftest.h\"`：可能包含测试相关的辅助定义（本文件未展示其内容）。\n  - 其他通用内核头文件（`init.h`, `module.h`, `random.h`, `sched/clock.h`, `kthread.h`, `vmalloc.h`）。\n\n- **配置依赖**：\n  - `CONFIG_KALLSYMS`：必须启用，否则 `kallsyms` 功能不可用。\n  - `CONFIG_KALLSYMS_ALL`：控制是否测试变量符号。\n  - `CONFIG_LTO_CLANG`：影响符号名后缀处理逻辑。\n\n- **函数依赖**：\n  - 依赖 `vmalloc_noprof` 和 `vfree` 作为已知内核函数符号进行测试。\n  - 使用 `is_ksym_addr()` 判断地址是否属于内核符号范围（代码片段末尾未完整展示）。\n\n## 使用场景\n\n- **内核开发与调试**：在开发或修改 `kallsyms` 相关代码后，加载此模块可快速验证符号解析功能是否正常。\n- **性能基准测试**：评估不同内核版本或配置下 `kallsyms` 接口的性能变化，特别是在符号表规模较大时的查找效率。\n- **压缩算法验证**：监控符号表压缩率，帮助优化内核镜像大小（尤其在嵌入式或资源受限环境中）。\n- **CI/CD 自动化测试**：可集成到内核持续集成流程中，作为 `kallsyms` 子系统的回归测试用例。\n- **LTO 编译兼容性验证**：确保在使用 Clang LTO 编译内核时，`kallsyms` 仍能正确处理修饰后的符号名。",
      "similarity": 0.530889630317688,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/kallsyms_selftest.c",
          "start_line": 430,
          "end_line": 466,
          "content": [
            "static int test_entry(void *p)",
            "{",
            "\tint ret;",
            "",
            "\tdo {",
            "\t\tschedule_timeout(5 * HZ);",
            "\t} while (system_state != SYSTEM_RUNNING);",
            "",
            "\tpr_info(\"start\\n\");",
            "\tret = test_kallsyms_basic_function();",
            "\tif (ret) {",
            "\t\tpr_info(\"abort\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\ttest_kallsyms_compression_ratio();",
            "\ttest_perf_kallsyms_lookup_name();",
            "\ttest_perf_kallsyms_on_each_symbol();",
            "\ttest_perf_kallsyms_on_each_match_symbol();",
            "\tpr_info(\"finish\\n\");",
            "",
            "\treturn 0;",
            "}",
            "static int __init kallsyms_test_init(void)",
            "{",
            "\tstruct task_struct *t;",
            "",
            "\tt = kthread_create(test_entry, NULL, \"kallsyms_test\");",
            "\tif (IS_ERR(t)) {",
            "\t\tpr_info(\"Create kallsyms selftest task failed\\n\");",
            "\t\treturn PTR_ERR(t);",
            "\t}",
            "\tkthread_bind(t, 0);",
            "\twake_up_process(t);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "test_entry, kallsyms_test_init",
          "description": "作为模块初始化入口，创建内核线程异步执行完整的kallsyms自测流程，包含所有测试项的调用和结果输出。",
          "similarity": 0.5494862794876099
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/kallsyms_selftest.c",
          "start_line": 61,
          "end_line": 166,
          "content": [
            "static int kallsyms_test_func_static(void)",
            "{",
            "\tkallsyms_test_var_bss_static++;",
            "\tkallsyms_test_var_data_static++;",
            "",
            "\treturn 0;",
            "}",
            "int kallsyms_test_func(void)",
            "{",
            "\treturn kallsyms_test_func_static();",
            "}",
            "__weak int kallsyms_test_func_weak(void)",
            "{",
            "\tkallsyms_test_var_bss++;",
            "\tkallsyms_test_var_data++;",
            "\treturn 0;",
            "}",
            "static int stat_symbol_len(void *data, const char *name, unsigned long addr)",
            "{",
            "\t*(u32 *)data += strlen(name);",
            "",
            "\treturn 0;",
            "}",
            "static void test_kallsyms_compression_ratio(void)",
            "{",
            "\tu32 pos, off, len, num;",
            "\tu32 ratio, total_size, total_len = 0;",
            "",
            "\tkallsyms_on_each_symbol(stat_symbol_len, &total_len);",
            "",
            "\t/*",
            "\t * A symbol name cannot start with a number. This stub name helps us",
            "\t * traverse the entire symbol table without finding a match. It's used",
            "\t * for subsequent performance tests, and its length is the average",
            "\t * length of all symbol names.",
            "\t */",
            "\tmemset(stub_name, '4', sizeof(stub_name));",
            "\tpos = total_len / kallsyms_num_syms;",
            "\tstub_name[pos] = 0;",
            "",
            "\tpos = 0;",
            "\tnum = 0;",
            "\toff = 0;",
            "\twhile (pos < kallsyms_num_syms) {",
            "\t\tlen = kallsyms_names[off];",
            "\t\tnum++;",
            "\t\toff++;",
            "\t\tpos++;",
            "\t\tif ((len & 0x80) != 0) {",
            "\t\t\tlen = (len & 0x7f) | (kallsyms_names[off] << 7);",
            "\t\t\tnum++;",
            "\t\t\toff++;",
            "\t\t}",
            "\t\toff += len;",
            "\t}",
            "",
            "\t/*",
            "\t * 1. The length fields is not counted",
            "\t * 2. The memory occupied by array kallsyms_token_table[] and",
            "\t *    kallsyms_token_index[] needs to be counted.",
            "\t */",
            "\ttotal_size = off - num;",
            "\tpos = kallsyms_token_index[0xff];",
            "\ttotal_size += pos + strlen(&kallsyms_token_table[pos]) + 1;",
            "\ttotal_size += 0x100 * sizeof(u16);",
            "",
            "\tpr_info(\" ---------------------------------------------------------\\n\");",
            "\tpr_info(\"| nr_symbols | compressed size | original size | ratio(%%) |\\n\");",
            "\tpr_info(\"|---------------------------------------------------------|\\n\");",
            "\tratio = (u32)div_u64(10000ULL * total_size, total_len);",
            "\tpr_info(\"| %10d |    %10d   |   %10d  |  %2d.%-2d   |\\n\",",
            "\t\tkallsyms_num_syms, total_size, total_len, ratio / 100, ratio % 100);",
            "\tpr_info(\" ---------------------------------------------------------\\n\");",
            "}",
            "static int lookup_name(void *data, const char *name, unsigned long addr)",
            "{",
            "\tu64 t0, t1, t;",
            "\tstruct test_stat *stat = (struct test_stat *)data;",
            "",
            "\tt0 = ktime_get_ns();",
            "\t(void)kallsyms_lookup_name(name);",
            "\tt1 = ktime_get_ns();",
            "",
            "\tt = t1 - t0;",
            "\tif (t < stat->min)",
            "\t\tstat->min = t;",
            "",
            "\tif (t > stat->max)",
            "\t\tstat->max = t;",
            "",
            "\tstat->real_cnt++;",
            "\tstat->sum += t;",
            "",
            "\treturn 0;",
            "}",
            "static void test_perf_kallsyms_lookup_name(void)",
            "{",
            "\tstruct test_stat stat;",
            "",
            "\tmemset(&stat, 0, sizeof(stat));",
            "\tstat.min = INT_MAX;",
            "\tkallsyms_on_each_symbol(lookup_name, &stat);",
            "\tpr_info(\"kallsyms_lookup_name() looked up %d symbols\\n\", stat.real_cnt);",
            "\tpr_info(\"The time spent on each symbol is (ns): min=%d, max=%d, avg=%lld\\n\",",
            "\t\tstat.min, stat.max, div_u64(stat.sum, stat.real_cnt));",
            "}"
          ],
          "function_name": "kallsyms_test_func_static, kallsyms_test_func, kallsyms_test_func_weak, stat_symbol_len, test_kallsyms_compression_ratio, lookup_name, test_perf_kallsyms_lookup_name",
          "description": "实现kallsyms符号表相关测试逻辑，包含符号长度统计、压缩率计算、kallsyms_lookup_name性能测试及遍历符号表的回调函数实现。",
          "similarity": 0.43402060866355896
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/kallsyms_selftest.c",
          "start_line": 1,
          "end_line": 60,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Test the function and performance of kallsyms",
            " *",
            " * Copyright (C) Huawei Technologies Co., Ltd., 2022",
            " *",
            " * Authors: Zhen Lei <thunder.leizhen@huawei.com> Huawei",
            " */",
            "",
            "#define pr_fmt(fmt) \"kallsyms_selftest: \" fmt",
            "",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/random.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kthread.h>",
            "#include <linux/vmalloc.h>",
            "",
            "#include \"kallsyms_internal.h\"",
            "#include \"kallsyms_selftest.h\"",
            "",
            "",
            "#define MAX_NUM_OF_RECORDS\t\t64",
            "",
            "struct test_stat {",
            "\tint min;",
            "\tint max;",
            "\tint save_cnt;",
            "\tint real_cnt;",
            "\tint perf;",
            "\tu64 sum;",
            "\tchar *name;",
            "\tunsigned long addr;",
            "\tunsigned long addrs[MAX_NUM_OF_RECORDS];",
            "};",
            "",
            "struct test_item {",
            "\tchar *name;",
            "\tunsigned long addr;",
            "};",
            "",
            "#define ITEM_FUNC(s)\t\t\t\t\\",
            "\t{\t\t\t\t\t\\",
            "\t\t.name = #s,\t\t\t\\",
            "\t\t.addr = (unsigned long)s,\t\\",
            "\t}",
            "",
            "#define ITEM_DATA(s)\t\t\t\t\\",
            "\t{\t\t\t\t\t\\",
            "\t\t.name = #s,\t\t\t\\",
            "\t\t.addr = (unsigned long)&s,\t\\",
            "\t}",
            "",
            "",
            "static int kallsyms_test_var_bss_static;",
            "static int kallsyms_test_var_data_static = 1;",
            "int kallsyms_test_var_bss;",
            "int kallsyms_test_var_data = 1;",
            ""
          ],
          "function_name": null,
          "description": "定义了用于kallsyms自测的测试变量和结构体，包括静态变量、数据段变量及测试项结构体，通过宏ITEM_FUNC和ITEM_DATA注册测试符号及其地址。",
          "similarity": 0.39451056718826294
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/kallsyms_selftest.c",
          "start_line": 190,
          "end_line": 423,
          "content": [
            "static bool match_cleanup_name(const char *s, const char *name)",
            "{",
            "\tchar *p;",
            "\tint len;",
            "",
            "\tif (!IS_ENABLED(CONFIG_LTO_CLANG))",
            "\t\treturn false;",
            "",
            "\tp = strstr(s, \".llvm.\");",
            "\tif (!p)",
            "\t\treturn false;",
            "",
            "\tlen = strlen(name);",
            "\tif (p - s != len)",
            "\t\treturn false;",
            "",
            "\treturn !strncmp(s, name, len);",
            "}",
            "static int find_symbol(void *data, const char *name, unsigned long addr)",
            "{",
            "\tstruct test_stat *stat = (struct test_stat *)data;",
            "",
            "\tif (strcmp(name, stat->name) == 0 ||",
            "\t    (!stat->perf && match_cleanup_name(name, stat->name))) {",
            "\t\tstat->real_cnt++;",
            "\t\tstat->addr = addr;",
            "",
            "\t\tif (stat->save_cnt < MAX_NUM_OF_RECORDS) {",
            "\t\t\tstat->addrs[stat->save_cnt] = addr;",
            "\t\t\tstat->save_cnt++;",
            "\t\t}",
            "",
            "\t\tif (stat->real_cnt == stat->max)",
            "\t\t\treturn 1;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void test_perf_kallsyms_on_each_symbol(void)",
            "{",
            "\tu64 t0, t1;",
            "\tstruct test_stat stat;",
            "",
            "\tmemset(&stat, 0, sizeof(stat));",
            "\tstat.max = INT_MAX;",
            "\tstat.name = stub_name;",
            "\tstat.perf = 1;",
            "\tt0 = ktime_get_ns();",
            "\tkallsyms_on_each_symbol(find_symbol, &stat);",
            "\tt1 = ktime_get_ns();",
            "\tpr_info(\"kallsyms_on_each_symbol() traverse all: %lld ns\\n\", t1 - t0);",
            "}",
            "static int match_symbol(void *data, unsigned long addr)",
            "{",
            "\tstruct test_stat *stat = (struct test_stat *)data;",
            "",
            "\tstat->real_cnt++;",
            "\tstat->addr = addr;",
            "",
            "\tif (stat->save_cnt < MAX_NUM_OF_RECORDS) {",
            "\t\tstat->addrs[stat->save_cnt] = addr;",
            "\t\tstat->save_cnt++;",
            "\t}",
            "",
            "\tif (stat->real_cnt == stat->max)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static void test_perf_kallsyms_on_each_match_symbol(void)",
            "{",
            "\tu64 t0, t1;",
            "\tstruct test_stat stat;",
            "",
            "\tmemset(&stat, 0, sizeof(stat));",
            "\tstat.max = INT_MAX;",
            "\tstat.name = stub_name;",
            "\tt0 = ktime_get_ns();",
            "\tkallsyms_on_each_match_symbol(match_symbol, stat.name, &stat);",
            "\tt1 = ktime_get_ns();",
            "\tpr_info(\"kallsyms_on_each_match_symbol() traverse all: %lld ns\\n\", t1 - t0);",
            "}",
            "static int test_kallsyms_basic_function(void)",
            "{",
            "\tint i, j, ret;",
            "\tint next = 0, nr_failed = 0;",
            "\tchar *prefix;",
            "\tunsigned short rand;",
            "\tunsigned long addr, lookup_addr;",
            "\tchar namebuf[KSYM_NAME_LEN];",
            "\tstruct test_stat *stat, *stat2;",
            "",
            "\tstat = kmalloc(sizeof(*stat) * 2, GFP_KERNEL);",
            "\tif (!stat)",
            "\t\treturn -ENOMEM;",
            "\tstat2 = stat + 1;",
            "",
            "\tprefix = \"kallsyms_lookup_name() for\";",
            "\tfor (i = 0; i < ARRAY_SIZE(test_items); i++) {",
            "\t\taddr = kallsyms_lookup_name(test_items[i].name);",
            "\t\tif (addr != test_items[i].addr) {",
            "\t\t\tnr_failed++;",
            "\t\t\tpr_info(\"%s %s failed: addr=%lx, expect %lx\\n\",",
            "\t\t\t\tprefix, test_items[i].name, addr, test_items[i].addr);",
            "\t\t}",
            "\t}",
            "",
            "\tprefix = \"kallsyms_on_each_symbol() for\";",
            "\tfor (i = 0; i < ARRAY_SIZE(test_items); i++) {",
            "\t\tmemset(stat, 0, sizeof(*stat));",
            "\t\tstat->max = INT_MAX;",
            "\t\tstat->name = test_items[i].name;",
            "\t\tkallsyms_on_each_symbol(find_symbol, stat);",
            "\t\tif (stat->addr != test_items[i].addr || stat->real_cnt != 1) {",
            "\t\t\tnr_failed++;",
            "\t\t\tpr_info(\"%s %s failed: count=%d, addr=%lx, expect %lx\\n\",",
            "\t\t\t\tprefix, test_items[i].name,",
            "\t\t\t\tstat->real_cnt, stat->addr, test_items[i].addr);",
            "\t\t}",
            "\t}",
            "",
            "\tprefix = \"kallsyms_on_each_match_symbol() for\";",
            "\tfor (i = 0; i < ARRAY_SIZE(test_items); i++) {",
            "\t\tmemset(stat, 0, sizeof(*stat));",
            "\t\tstat->max = INT_MAX;",
            "\t\tstat->name = test_items[i].name;",
            "\t\tkallsyms_on_each_match_symbol(match_symbol, test_items[i].name, stat);",
            "\t\tif (stat->addr != test_items[i].addr || stat->real_cnt != 1) {",
            "\t\t\tnr_failed++;",
            "\t\t\tpr_info(\"%s %s failed: count=%d, addr=%lx, expect %lx\\n\",",
            "\t\t\t\tprefix, test_items[i].name,",
            "\t\t\t\tstat->real_cnt, stat->addr, test_items[i].addr);",
            "\t\t}",
            "\t}",
            "",
            "\tif (nr_failed) {",
            "\t\tkfree(stat);",
            "\t\treturn -ESRCH;",
            "\t}",
            "",
            "\tfor (i = 0; i < kallsyms_num_syms; i++) {",
            "\t\taddr = kallsyms_sym_address(i);",
            "\t\tif (!is_ksym_addr(addr))",
            "\t\t\tcontinue;",
            "",
            "\t\tret = lookup_symbol_name(addr, namebuf);",
            "\t\tif (unlikely(ret)) {",
            "\t\t\tnamebuf[0] = 0;",
            "\t\t\tpr_info(\"%d: lookup_symbol_name(%lx) failed\\n\", i, addr);",
            "\t\t\tgoto failed;",
            "\t\t}",
            "",
            "\t\tlookup_addr = kallsyms_lookup_name(namebuf);",
            "",
            "\t\tmemset(stat, 0, sizeof(*stat));",
            "\t\tstat->max = INT_MAX;",
            "\t\tkallsyms_on_each_match_symbol(match_symbol, namebuf, stat);",
            "",
            "\t\t/*",
            "\t\t * kallsyms_on_each_symbol() is too slow, randomly select some",
            "\t\t * symbols for test.",
            "\t\t */",
            "\t\tif (i >= next) {",
            "\t\t\tmemset(stat2, 0, sizeof(*stat2));",
            "\t\t\tstat2->max = INT_MAX;",
            "\t\t\tstat2->name = namebuf;",
            "\t\t\tkallsyms_on_each_symbol(find_symbol, stat2);",
            "",
            "\t\t\t/*",
            "\t\t\t * kallsyms_on_each_symbol() and kallsyms_on_each_match_symbol()",
            "\t\t\t * need to get the same traversal result.",
            "\t\t\t */",
            "\t\t\tif (stat->addr != stat2->addr ||",
            "\t\t\t    stat->real_cnt != stat2->real_cnt ||",
            "\t\t\t    memcmp(stat->addrs, stat2->addrs,",
            "\t\t\t\t   stat->save_cnt * sizeof(stat->addrs[0]))) {",
            "\t\t\t\tpr_info(\"%s: mismatch between kallsyms_on_each_symbol() and kallsyms_on_each_match_symbol()\\n\",",
            "\t\t\t\t\tnamebuf);",
            "\t\t\t\tgoto failed;",
            "\t\t\t}",
            "",
            "\t\t\t/*",
            "\t\t\t * The average of random increments is 128, that is, one of",
            "\t\t\t * them is tested every 128 symbols.",
            "\t\t\t */",
            "\t\t\tget_random_bytes(&rand, sizeof(rand));",
            "\t\t\tnext = i + (rand & 0xff) + 1;",
            "\t\t}",
            "",
            "\t\t/* Need to be found at least once */",
            "\t\tif (!stat->real_cnt) {",
            "\t\t\tpr_info(\"%s: Never found\\n\", namebuf);",
            "\t\t\tgoto failed;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * kallsyms_lookup_name() returns the address of the first",
            "\t\t * symbol found and cannot be NULL.",
            "\t\t */",
            "\t\tif (!lookup_addr) {",
            "\t\t\tpr_info(\"%s: NULL lookup_addr?!\\n\", namebuf);",
            "\t\t\tgoto failed;",
            "\t\t}",
            "\t\tif (lookup_addr != stat->addrs[0]) {",
            "\t\t\tpr_info(\"%s: lookup_addr != stat->addrs[0]\\n\", namebuf);",
            "\t\t\tgoto failed;",
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * If the addresses of all matching symbols are recorded, the",
            "\t\t * target address needs to be exist.",
            "\t\t */",
            "\t\tif (stat->real_cnt <= MAX_NUM_OF_RECORDS) {",
            "\t\t\tfor (j = 0; j < stat->save_cnt; j++) {",
            "\t\t\t\tif (stat->addrs[j] == addr)",
            "\t\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t\tif (j == stat->save_cnt) {",
            "\t\t\t\tpr_info(\"%s: j == save_cnt?!\\n\", namebuf);",
            "\t\t\t\tgoto failed;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tkfree(stat);",
            "",
            "\treturn 0;",
            "",
            "failed:",
            "\tpr_info(\"Test for %dth symbol failed: (%s) addr=%lx\", i, namebuf, addr);",
            "\tkfree(stat);",
            "\treturn -ESRCH;",
            "}"
          ],
          "function_name": "match_cleanup_name, find_symbol, test_perf_kallsyms_on_each_symbol, match_symbol, test_perf_kallsyms_on_each_match_symbol, test_kallsyms_basic_function",
          "description": "实现符号匹配校验逻辑和基础功能测试，包含符号地址查找验证、遍历符号表的匹配函数测试，以及跨不同遍历API的结果一致性检测。",
          "similarity": 0.3716059923171997
        }
      ]
    }
  ]
}