{
  "query": "分时系统中的虚拟内存管理",
  "timestamp": "2025-12-25 23:54:02",
  "retrieved_files": [
    {
      "source_file": "kernel/time/namespace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:40:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\namespace.c`\n\n---\n\n# time/namespace.c 技术文档\n\n## 1. 文件概述\n\n`time/namespace.c` 实现了 Linux 内核中的 **时间命名空间（time namespace）** 功能，允许不同进程组拥有独立的时间视图。该机制主要用于容器化环境中，使容器内的进程能够看到与宿主机或其他容器不同的系统时间（特别是 `CLOCK_MONOTONIC` 和 `CLOCK_BOOTTIME` 等单调时钟）。时间命名空间通过偏移量（offset）机制实现，不影响真实硬件时钟，仅在用户空间通过 VDSO（虚拟动态共享对象）提供转换后的时间值。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `do_timens_ktime_to_host()` | 将时间命名空间中的时间值转换回宿主机时间（减去偏移量），用于内核内部时间比较 |\n| `clone_time_ns()` | 克隆一个时间命名空间，分配资源并初始化 VVAR 页面 |\n| `copy_time_ns()` | 根据 `CLONE_NEWTIME` 标志决定是克隆还是复用现有时间命名空间 |\n| `timens_setup_vdso_data()` | 在 VDSO 数据页中设置时间偏移量，供用户空间读取 |\n| `find_timens_vvar_page()` | 为进程查找其所属时间命名空间的 VVAR 页面 |\n| `timens_set_vvar_page()` | 初始化时间命名空间的 VVAR 页面（仅首次进入时执行） |\n| `free_time_ns()` | 释放时间命名空间占用的资源 |\n| `timens_commit()` | 在任务切换到新时间命名空间时提交配置（设置 VVAR 和 VDSO） |\n| `timens_install()` | 安装新的时间命名空间到当前进程（需权限检查） |\n| `timens_on_fork()` | 子进程 fork 时继承父进程的 `time_ns_for_children` |\n\n### 关键数据结构\n\n- `struct time_namespace`：时间命名空间的核心结构，包含：\n  - `vvar_page`：用于 VDSO 的特殊内存页\n  - `offsets`：`monotonic` 和 `boottime` 时钟的偏移量\n  - `frozen_offsets`：标志位，表示偏移量是否已固化（防止重复初始化）\n  - `user_ns`：所属的用户命名空间\n  - `ucounts`：资源计数器，限制时间命名空间创建数量\n\n- `struct timens_offsets`：存储 `CLOCK_MONOTONIC` 和 `CLOCK_BOOTTIME` 的偏移量（`timespec64` 格式）\n\n- `struct timens_offset`：VDSO 中使用的偏移量结构（`sec` + `nsec`）\n\n## 3. 关键实现\n\n### 时间偏移转换机制\n- `do_timens_ktime_to_host()` 负责将命名空间内的时间值（如定时器到期时间）转换为宿主机视角的时间。\n- 对于 `CLOCK_MONOTONIC` 和 `CLOCK_BOOTTIME`，减去对应的偏移量。\n- 若转换后时间小于 0，则视为已过期，返回 0。\n- 转换结果被限制在 `[0, KTIME_MAX]` 范围内。\n\n### VDSO 集成\n- 时间命名空间通过 **VVAR 页面** 向用户空间暴露偏移量。\n- 正常进程的 VDSO 布局：`VVAR → PVCLOCK → HVCLOCK`\n- 时间命名空间进程的 VDSO 布局：`TIMENS → PVCLOCK → HVCLOCK → VVAR`\n- `timens_setup_vdso_data()` 在 VVAR 页面中设置 `clock_mode = VDSO_CLOCKMODE_TIMENS` 并填充各时钟的偏移量。\n- 用户空间 VDSO 代码根据 `clock_mode` 决定是否应用偏移。\n\n### 偏移量初始化保护\n- 使用全局 `offset_lock` 互斥锁确保 `vvar_page` 仅被初始化一次。\n- `frozen_offsets` 标志位避免重复初始化，提高性能（快路径无锁）。\n\n### 资源管理与权限控制\n- 通过 `ucounts` 限制每个用户命名空间可创建的时间命名空间数量（防 DoS）。\n- `timens_install()` 要求调用者在**目标命名空间**和**当前命名空间**均具备 `CAP_SYS_ADMIN` 权限。\n- 仅允许单线程进程（`current_is_single_threaded()`）切换时间命名空间，避免多线程一致性问题。\n\n### 进程继承模型\n- 每个进程拥有两个时间命名空间指针：\n  - `time_ns`：当前生效的时间命名空间\n  - `time_ns_for_children`：子进程将继承的时间命名空间\n- `timens_on_fork()` 确保子进程正确继承父进程的 `time_ns_for_children`\n\n## 4. 依赖关系\n\n| 依赖模块 | 用途 |\n|---------|------|\n| `<linux/user_namespace.h>` | 用户命名空间支持，用于权限隔离和资源计数 |\n| `<linux/proc_ns.h>` | 命名空间 proc 接口（如 `/proc/PID/ns/time`） |\n| `<vdso/datapage.h>` | VDSO 数据页结构定义 |\n| `<linux/clocksource.h>` | 时钟源相关常量（如 `CS_BASES`） |\n| `<linux/sched/*.h>` | 进程调度和 nsproxy 管理 |\n| `<linux/cred.h>` | 凭据和权限检查（`ns_capable()`） |\n| `<linux/mm.h>` | 内存管理（`alloc_page()`、`vm_area_struct`） |\n\n## 5. 使用场景\n\n1. **容器时间隔离**  \n   容器运行时（如 LXC、systemd-nspawn）可通过 `unshare(CLONE_NEWTIME)` 创建独立时间视图，使容器内 `CLOCK_MONOTONIC` 从 0 开始计时，便于测试或迁移。\n\n2. **系统时间回滚测试**  \n   开发者可在时间命名空间中设置负偏移量，模拟系统时间回退场景，验证应用程序的健壮性。\n\n3. **沙箱环境**  \n   安全沙箱可限制进程看到的时间范围，防止基于时间的侧信道攻击。\n\n4. **VDSO 优化路径**  \n   用户空间通过 VDSO 直接读取偏移后的时间，无需系统调用，性能开销极低。\n\n5. **命名空间组合**  \n   时间命名空间通常与 PID、mount、user 等命名空间联合使用，构建完整的隔离环境。",
      "similarity": 0.6383554339408875,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/time/namespace.c",
          "start_line": 23,
          "end_line": 124,
          "content": [
            "ktime_t do_timens_ktime_to_host(clockid_t clockid, ktime_t tim,",
            "\t\t\t\tstruct timens_offsets *ns_offsets)",
            "{",
            "\tktime_t offset;",
            "",
            "\tswitch (clockid) {",
            "\tcase CLOCK_MONOTONIC:",
            "\t\toffset = timespec64_to_ktime(ns_offsets->monotonic);",
            "\t\tbreak;",
            "\tcase CLOCK_BOOTTIME:",
            "\tcase CLOCK_BOOTTIME_ALARM:",
            "\t\toffset = timespec64_to_ktime(ns_offsets->boottime);",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn tim;",
            "\t}",
            "",
            "\t/*",
            "\t * Check that @tim value is in [offset, KTIME_MAX + offset]",
            "\t * and subtract offset.",
            "\t */",
            "\tif (tim < offset) {",
            "\t\t/*",
            "\t\t * User can specify @tim *absolute* value - if it's lesser than",
            "\t\t * the time namespace's offset - it's already expired.",
            "\t\t */",
            "\t\ttim = 0;",
            "\t} else {",
            "\t\ttim = ktime_sub(tim, offset);",
            "\t\tif (unlikely(tim > KTIME_MAX))",
            "\t\t\ttim = KTIME_MAX;",
            "\t}",
            "",
            "\treturn tim;",
            "}",
            "static void dec_time_namespaces(struct ucounts *ucounts)",
            "{",
            "\tdec_ucount(ucounts, UCOUNT_TIME_NAMESPACES);",
            "}",
            "static struct timens_offset offset_from_ts(struct timespec64 off)",
            "{",
            "\tstruct timens_offset ret;",
            "",
            "\tret.sec = off.tv_sec;",
            "\tret.nsec = off.tv_nsec;",
            "",
            "\treturn ret;",
            "}",
            "static void timens_setup_vdso_data(struct vdso_data *vdata,",
            "\t\t\t\t   struct time_namespace *ns)",
            "{",
            "\tstruct timens_offset *offset = vdata->offset;",
            "\tstruct timens_offset monotonic = offset_from_ts(ns->offsets.monotonic);",
            "\tstruct timens_offset boottime = offset_from_ts(ns->offsets.boottime);",
            "",
            "\tvdata->seq\t\t\t= 1;",
            "\tvdata->clock_mode\t\t= VDSO_CLOCKMODE_TIMENS;",
            "\toffset[CLOCK_MONOTONIC]\t\t= monotonic;",
            "\toffset[CLOCK_MONOTONIC_RAW]\t= monotonic;",
            "\toffset[CLOCK_MONOTONIC_COARSE]\t= monotonic;",
            "\toffset[CLOCK_BOOTTIME]\t\t= boottime;",
            "\toffset[CLOCK_BOOTTIME_ALARM]\t= boottime;",
            "}",
            "static void timens_set_vvar_page(struct task_struct *task,",
            "\t\t\t\tstruct time_namespace *ns)",
            "{",
            "\tstruct vdso_data *vdata;",
            "\tunsigned int i;",
            "",
            "\tif (ns == &init_time_ns)",
            "\t\treturn;",
            "",
            "\t/* Fast-path, taken by every task in namespace except the first. */",
            "\tif (likely(ns->frozen_offsets))",
            "\t\treturn;",
            "",
            "\tmutex_lock(&offset_lock);",
            "\t/* Nothing to-do: vvar_page has been already initialized. */",
            "\tif (ns->frozen_offsets)",
            "\t\tgoto out;",
            "",
            "\tns->frozen_offsets = true;",
            "\tvdata = arch_get_vdso_data(page_address(ns->vvar_page));",
            "",
            "\tfor (i = 0; i < CS_BASES; i++)",
            "\t\ttimens_setup_vdso_data(&vdata[i], ns);",
            "",
            "out:",
            "\tmutex_unlock(&offset_lock);",
            "}",
            "void free_time_ns(struct time_namespace *ns)",
            "{",
            "\tdec_time_namespaces(ns->ucounts);",
            "\tput_user_ns(ns->user_ns);",
            "\tns_free_inum(&ns->ns);",
            "\t__free_page(ns->vvar_page);",
            "\tkfree(ns);",
            "}",
            "static void timens_put(struct ns_common *ns)",
            "{",
            "\tput_time_ns(to_time_ns(ns));",
            "}"
          ],
          "function_name": "do_timens_ktime_to_host, dec_time_namespaces, offset_from_ts, timens_setup_vdso_data, timens_set_vvar_page, free_time_ns, timens_put",
          "description": "实现时间命名空间偏移转换逻辑，包括时间转换、引用计数更新、VDSO数据初始化、页内存释放及命名空间引用计数管理等功能模块。",
          "similarity": 0.5732424259185791
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/namespace.c",
          "start_line": 298,
          "end_line": 448,
          "content": [
            "void timens_commit(struct task_struct *tsk, struct time_namespace *ns)",
            "{",
            "\ttimens_set_vvar_page(tsk, ns);",
            "\tvdso_join_timens(tsk, ns);",
            "}",
            "static int timens_install(struct nsset *nsset, struct ns_common *new)",
            "{",
            "\tstruct nsproxy *nsproxy = nsset->nsproxy;",
            "\tstruct time_namespace *ns = to_time_ns(new);",
            "",
            "\tif (!current_is_single_threaded())",
            "\t\treturn -EUSERS;",
            "",
            "\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN) ||",
            "\t    !ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tget_time_ns(ns);",
            "\tput_time_ns(nsproxy->time_ns);",
            "\tnsproxy->time_ns = ns;",
            "",
            "\tget_time_ns(ns);",
            "\tput_time_ns(nsproxy->time_ns_for_children);",
            "\tnsproxy->time_ns_for_children = ns;",
            "\treturn 0;",
            "}",
            "void timens_on_fork(struct nsproxy *nsproxy, struct task_struct *tsk)",
            "{",
            "\tstruct ns_common *nsc = &nsproxy->time_ns_for_children->ns;",
            "\tstruct time_namespace *ns = to_time_ns(nsc);",
            "",
            "\t/* create_new_namespaces() already incremented the ref counter */",
            "\tif (nsproxy->time_ns == nsproxy->time_ns_for_children)",
            "\t\treturn;",
            "",
            "\tget_time_ns(ns);",
            "\tput_time_ns(nsproxy->time_ns);",
            "\tnsproxy->time_ns = ns;",
            "",
            "\ttimens_commit(tsk, ns);",
            "}",
            "static void show_offset(struct seq_file *m, int clockid, struct timespec64 *ts)",
            "{",
            "\tchar *clock;",
            "",
            "\tswitch (clockid) {",
            "\tcase CLOCK_BOOTTIME:",
            "\t\tclock = \"boottime\";",
            "\t\tbreak;",
            "\tcase CLOCK_MONOTONIC:",
            "\t\tclock = \"monotonic\";",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tclock = \"unknown\";",
            "\t\tbreak;",
            "\t}",
            "\tseq_printf(m, \"%-10s %10lld %9ld\\n\", clock, ts->tv_sec, ts->tv_nsec);",
            "}",
            "void proc_timens_show_offsets(struct task_struct *p, struct seq_file *m)",
            "{",
            "\tstruct ns_common *ns;",
            "\tstruct time_namespace *time_ns;",
            "",
            "\tns = timens_for_children_get(p);",
            "\tif (!ns)",
            "\t\treturn;",
            "\ttime_ns = to_time_ns(ns);",
            "",
            "\tshow_offset(m, CLOCK_MONOTONIC, &time_ns->offsets.monotonic);",
            "\tshow_offset(m, CLOCK_BOOTTIME, &time_ns->offsets.boottime);",
            "\tput_time_ns(time_ns);",
            "}",
            "int proc_timens_set_offset(struct file *file, struct task_struct *p,",
            "\t\t\t   struct proc_timens_offset *offsets, int noffsets)",
            "{",
            "\tstruct ns_common *ns;",
            "\tstruct time_namespace *time_ns;",
            "\tstruct timespec64 tp;",
            "\tint i, err;",
            "",
            "\tns = timens_for_children_get(p);",
            "\tif (!ns)",
            "\t\treturn -ESRCH;",
            "\ttime_ns = to_time_ns(ns);",
            "",
            "\tif (!file_ns_capable(file, time_ns->user_ns, CAP_SYS_TIME)) {",
            "\t\tput_time_ns(time_ns);",
            "\t\treturn -EPERM;",
            "\t}",
            "",
            "\tfor (i = 0; i < noffsets; i++) {",
            "\t\tstruct proc_timens_offset *off = &offsets[i];",
            "",
            "\t\tswitch (off->clockid) {",
            "\t\tcase CLOCK_MONOTONIC:",
            "\t\t\tktime_get_ts64(&tp);",
            "\t\t\tbreak;",
            "\t\tcase CLOCK_BOOTTIME:",
            "\t\t\tktime_get_boottime_ts64(&tp);",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\terr = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\terr = -ERANGE;",
            "",
            "\t\tif (off->val.tv_sec > KTIME_SEC_MAX ||",
            "\t\t    off->val.tv_sec < -KTIME_SEC_MAX)",
            "\t\t\tgoto out;",
            "",
            "\t\ttp = timespec64_add(tp, off->val);",
            "\t\t/*",
            "\t\t * KTIME_SEC_MAX is divided by 2 to be sure that KTIME_MAX is",
            "\t\t * still unreachable.",
            "\t\t */",
            "\t\tif (tp.tv_sec < 0 || tp.tv_sec > KTIME_SEC_MAX / 2)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tmutex_lock(&offset_lock);",
            "\tif (time_ns->frozen_offsets) {",
            "\t\terr = -EACCES;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\terr = 0;",
            "\t/* Don't report errors after this line */",
            "\tfor (i = 0; i < noffsets; i++) {",
            "\t\tstruct proc_timens_offset *off = &offsets[i];",
            "\t\tstruct timespec64 *offset = NULL;",
            "",
            "\t\tswitch (off->clockid) {",
            "\t\tcase CLOCK_MONOTONIC:",
            "\t\t\toffset = &time_ns->offsets.monotonic;",
            "\t\t\tbreak;",
            "\t\tcase CLOCK_BOOTTIME:",
            "\t\t\toffset = &time_ns->offsets.boottime;",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t*offset = off->val;",
            "\t}",
            "",
            "out_unlock:",
            "\tmutex_unlock(&offset_lock);",
            "out:",
            "\tput_time_ns(time_ns);",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "timens_commit, timens_install, timens_on_fork, show_offset, proc_timens_show_offsets, proc_timens_set_offset",
          "description": "实现时间命名空间的安装传播机制，包含命名空间继承处理、偏移量展示接口、时钟偏移量设置接口及其权限校验逻辑。",
          "similarity": 0.5425852537155151
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/namespace.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Author: Andrei Vagin <avagin@openvz.org>",
            " * Author: Dmitry Safonov <dima@arista.com>",
            " */",
            "",
            "#include <linux/time_namespace.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/export.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "",
            "#include <vdso/datapage.h>",
            ""
          ],
          "function_name": null,
          "description": "包含时间命名空间所需头文件，声明时间、用户命名空间及内核通用结构体，为后续时间命名空间实现提供类型和函数声明支持。",
          "similarity": 0.48507556319236755
        }
      ]
    },
    {
      "source_file": "mm/sparse.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:25:01\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sparse.c`\n\n---\n\n# sparse.c 技术文档\n\n## 1. 文件概述\n\n`sparse.c` 是 Linux 内核中实现 **SPARSEMEM（稀疏内存模型）** 的核心文件，用于管理物理内存的稀疏映射。该模型将整个物理地址空间划分为固定大小的“内存段”（memory sections），仅对实际存在的内存段分配 `mem_map`（页描述符数组），从而在支持大物理地址空间的同时节省内存开销。此文件负责内存段的初始化、节点关联、存在性标记以及与内存热插拔和 vmemmap 相关的功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`mem_section`**: 全局内存段数组，每个元素代表一个内存段，存储该段的 `mem_map` 指针及其他元数据。\n  - 在 `CONFIG_SPARSEMEM_EXTREME` 下为二级指针（动态分配根数组）\n  - 否则为静态二维数组 `[NR_SECTION_ROOTS][SECTIONS_PER_ROOT]`\n- **`section_to_node_table`**: （仅当 `NODE_NOT_IN_PAGE_FLAGS` 时）用于通过内存段号查找所属 NUMA 节点的查找表。\n- **`__highest_present_section_nr`**: 记录当前系统中编号最大的已存在内存段，用于优化遍历。\n\n### 主要函数\n- **`memory_present()`**: 标记指定 PFN 范围内的内存段为“存在”，并关联到指定 NUMA 节点。\n- **`memblocks_present()`**: 遍历所有 memblock 内存区域，调用 `memory_present()` 标记所有系统内存。\n- **`sparse_index_init()`**: （仅 `CONFIG_SPARSEMEM_EXTREME`）为指定内存段分配其所在的根数组项。\n- **`sparse_encode_mem_map()` / `sparse_decode_mem_map()`**: 编码/解码 `mem_map` 指针，使其能通过段内偏移计算出实际 PFN。\n- **`subsection_map_init()`**: （仅 `CONFIG_SPARSEMEM_VMEMMAP`）初始化子段（subsection）位图，用于更细粒度的内存管理。\n- **`page_to_nid()`**: （仅 `NODE_NOT_IN_PAGE_FLAGS`）通过页结构获取其所属 NUMA 节点。\n- **`mminit_validate_memmodel_limits()`**: 验证传入的 PFN 范围是否超出 SPARSEMEM 模型支持的最大地址。\n\n### 辅助宏与内联函数\n- **`for_each_present_section_nr()`**: 高效遍历所有已存在的内存段。\n- **`first_present_section_nr()`**: 获取第一个存在的内存段编号。\n- **`sparse_encode_early_nid()` / `sparse_early_nid()`**: 在早期启动阶段利用 `section_mem_map` 字段临时存储 NUMA 节点 ID。\n\n## 3. 关键实现\n\n### 内存段管理\n- 物理内存被划分为 `PAGES_PER_SECTION` 大小的段（通常 128MB）。\n- `mem_section` 数组索引即为段号（section number），通过 `__nr_to_section()` 宏访问。\n- 段的存在性通过 `SECTION_MARKED_PRESENT` 位标记，并维护 `__highest_present_section_nr` 以加速遍历。\n\n### NUMA 节点关联\n- 若页结构体（`struct page`）中未直接存储节点 ID（`NODE_NOT_IN_PAGE_FLAGS`），则使用 `section_to_node_table` 查找。\n- 在 `memory_present()` 中通过 `set_section_nid()` 建立段到节点的映射。\n\n### 动态内存段分配（SPARSEMEM_EXTREME）\n- 为减少静态内存占用，`mem_section` 采用二级结构：\n  - 一级：`mem_section[]` 指向多个二级数组\n  - 二级：每个 `mem_section[root]` 指向 `SECTIONS_PER_ROOT` 个 `struct mem_section`\n- `sparse_index_init()` 在需要时动态分配二级数组（使用 `kzalloc_node` 或 `memblock_alloc_node`）。\n\n### 早期启动阶段的优化\n- 在 `mem_map` 分配前，复用 `section_mem_map` 字段的高位存储 NUMA 节点 ID（`sparse_encode_early_nid()`）。\n- 此信息在分配真实 `mem_map` 前被清除。\n\n### vmemmap 子段支持\n- 当启用 `CONFIG_SPARSEMEM_VMEMMAP` 时，每个内存段进一步划分为子段（subsections）。\n- `subsection_map_init()` 初始化位图，标记哪些子段包含有效内存，支持更灵活的内存热插拔。\n\n### 地址空间验证\n- `mminit_validate_memmodel_limits()` 确保传入的 PFN 范围不超过 `PHYSMEM_END`（SPARSEMEM 模型最大支持地址），防止越界。\n\n## 4. 依赖关系\n\n- **头文件依赖**:\n  - `<linux/mm.h>`, `<linux/mmzone.h>`: 内存管理核心定义\n  - `<linux/memblock.h>`: 早期内存分配器\n  - `<linux/vmalloc.h>`: 用于 vmemmap 映射\n  - `<asm/dma.h>`: 架构相关 DMA 定义\n  - `\"internal.h\"`: MM 子系统内部头文件\n- **配置选项依赖**:\n  - `CONFIG_SPARSEMEM`: 基础稀疏内存模型\n  - `CONFIG_SPARSEMEM_EXTREME`: 动态内存段分配\n  - `CONFIG_SPARSEMEM_VMEMMAP`: 使用虚拟映射的 mem_map\n  - `CONFIG_MEMORY_HOTPLUG`: 内存热插拔支持\n  - `NODE_NOT_IN_PAGE_FLAGS`: 页结构体不包含节点 ID\n- **与其他模块交互**:\n  - **Memory Block (memblock)**: 通过 `for_each_mem_pfn_range()` 获取初始内存布局\n  - **Page Allocator**: 提供 `struct page` 数组（mem_map）\n  - **NUMA Subsystem**: 通过节点 ID 关联内存与 CPU 拓扑\n  - **Memory Hotplug**: 依赖本文件提供的段管理接口进行内存增删\n\n## 5. 使用场景\n\n- **系统启动初始化**:\n  - `memblocks_present()` 在 `mm_init()` 阶段被调用，标记所有固件报告的内存区域为“存在”。\n- **内存热插拔**:\n  - 热添加内存时，调用 `memory_present()` 标记新段；热移除时清理对应段。\n  - `sparse_index_init()` 支持动态扩展 `mem_section` 数组。\n- **页到节点转换**:\n  - 当 `page_to_nid()` 被调用时（如页面迁移、NUMA 调度），通过段查找节点。\n- **vmemmap 优化**:\n  - 在支持 `SPARSEMEM_VMEMMAP` 的架构（如 x86_64, ARM64）上，`subsection_map_init()` 使内核能按子段粒度映射 `struct page`，减少虚拟地址空间占用。\n- **调试与验证**:\n  - `mminit_validate_memmodel_limits()` 在开发阶段捕获内存模型配置错误。",
      "similarity": 0.6273294687271118,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/sparse.c",
          "start_line": 219,
          "end_line": 339,
          "content": [
            "void __init subsection_map_init(unsigned long pfn, unsigned long nr_pages)",
            "{",
            "}",
            "static void __init memory_present(int nid, unsigned long start, unsigned long end)",
            "{",
            "\tunsigned long pfn;",
            "",
            "#ifdef CONFIG_SPARSEMEM_EXTREME",
            "\tif (unlikely(!mem_section)) {",
            "\t\tunsigned long size, align;",
            "",
            "\t\tsize = sizeof(struct mem_section *) * NR_SECTION_ROOTS;",
            "\t\talign = 1 << (INTERNODE_CACHE_SHIFT);",
            "\t\tmem_section = memblock_alloc(size, align);",
            "\t\tif (!mem_section)",
            "\t\t\tpanic(\"%s: Failed to allocate %lu bytes align=0x%lx\\n\",",
            "\t\t\t      __func__, size, align);",
            "\t}",
            "#endif",
            "",
            "\tstart &= PAGE_SECTION_MASK;",
            "\tmminit_validate_memmodel_limits(&start, &end);",
            "\tfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION) {",
            "\t\tunsigned long section = pfn_to_section_nr(pfn);",
            "\t\tstruct mem_section *ms;",
            "",
            "\t\tsparse_index_init(section, nid);",
            "\t\tset_section_nid(section, nid);",
            "",
            "\t\tms = __nr_to_section(section);",
            "\t\tif (!ms->section_mem_map) {",
            "\t\t\tms->section_mem_map = sparse_encode_early_nid(nid) |",
            "\t\t\t\t\t\t\tSECTION_IS_ONLINE;",
            "\t\t\t__section_mark_present(ms, section);",
            "\t\t}",
            "\t}",
            "}",
            "static void __init memblocks_present(void)",
            "{",
            "\tunsigned long start, end;",
            "\tint i, nid;",
            "",
            "\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start, &end, &nid)",
            "\t\tmemory_present(nid, start, end);",
            "}",
            "static unsigned long sparse_encode_mem_map(struct page *mem_map, unsigned long pnum)",
            "{",
            "\tunsigned long coded_mem_map =",
            "\t\t(unsigned long)(mem_map - (section_nr_to_pfn(pnum)));",
            "\tBUILD_BUG_ON(SECTION_MAP_LAST_BIT > PFN_SECTION_SHIFT);",
            "\tBUG_ON(coded_mem_map & ~SECTION_MAP_MASK);",
            "\treturn coded_mem_map;",
            "}",
            "static void __meminit sparse_init_one_section(struct mem_section *ms,",
            "\t\tunsigned long pnum, struct page *mem_map,",
            "\t\tstruct mem_section_usage *usage, unsigned long flags)",
            "{",
            "\tms->section_mem_map &= ~SECTION_MAP_MASK;",
            "\tms->section_mem_map |= sparse_encode_mem_map(mem_map, pnum)",
            "\t\t| SECTION_HAS_MEM_MAP | flags;",
            "\tms->usage = usage;",
            "}",
            "static unsigned long usemap_size(void)",
            "{",
            "\treturn BITS_TO_LONGS(SECTION_BLOCKFLAGS_BITS) * sizeof(unsigned long);",
            "}",
            "size_t mem_section_usage_size(void)",
            "{",
            "\treturn sizeof(struct mem_section_usage) + usemap_size();",
            "}",
            "static inline phys_addr_t pgdat_to_phys(struct pglist_data *pgdat)",
            "{",
            "#ifndef CONFIG_NUMA",
            "\tVM_BUG_ON(pgdat != &contig_page_data);",
            "\treturn __pa_symbol(&contig_page_data);",
            "#else",
            "\treturn __pa(pgdat);",
            "#endif",
            "}",
            "static void __init check_usemap_section_nr(int nid,",
            "\t\tstruct mem_section_usage *usage)",
            "{",
            "\tunsigned long usemap_snr, pgdat_snr;",
            "\tstatic unsigned long old_usemap_snr;",
            "\tstatic unsigned long old_pgdat_snr;",
            "\tstruct pglist_data *pgdat = NODE_DATA(nid);",
            "\tint usemap_nid;",
            "",
            "\t/* First call */",
            "\tif (!old_usemap_snr) {",
            "\t\told_usemap_snr = NR_MEM_SECTIONS;",
            "\t\told_pgdat_snr = NR_MEM_SECTIONS;",
            "\t}",
            "",
            "\tusemap_snr = pfn_to_section_nr(__pa(usage) >> PAGE_SHIFT);",
            "\tpgdat_snr = pfn_to_section_nr(pgdat_to_phys(pgdat) >> PAGE_SHIFT);",
            "\tif (usemap_snr == pgdat_snr)",
            "\t\treturn;",
            "",
            "\tif (old_usemap_snr == usemap_snr && old_pgdat_snr == pgdat_snr)",
            "\t\t/* skip redundant message */",
            "\t\treturn;",
            "",
            "\told_usemap_snr = usemap_snr;",
            "\told_pgdat_snr = pgdat_snr;",
            "",
            "\tusemap_nid = sparse_early_nid(__nr_to_section(usemap_snr));",
            "\tif (usemap_nid != nid) {",
            "\t\tpr_info(\"node %d must be removed before remove section %ld\\n\",",
            "\t\t\tnid, usemap_snr);",
            "\t\treturn;",
            "\t}",
            "\t/*",
            "\t * There is a circular dependency.",
            "\t * Some platforms allow un-removable section because they will just",
            "\t * gather other removable sections for dynamic partitioning.",
            "\t * Just notify un-removable section's number here.",
            "\t */",
            "\tpr_info(\"Section %ld and %ld (node %d) have a circular dependency on usemap and pgdat allocations\\n\",",
            "\t\tusemap_snr, pgdat_snr, nid);",
            "}"
          ],
          "function_name": "subsection_map_init, memory_present, memblocks_present, sparse_encode_mem_map, sparse_init_one_section, usemap_size, mem_section_usage_size, pgdat_to_phys, check_usemap_section_nr",
          "description": "实现memory_present标记内存区段为有效，memblocks_present遍历所有内存块执行此操作。提供sparse_encode_mem_map编码内存图，sparse_init_one_section初始化区段结构体。包含使用图大小计算、PGDAT物理地址转换及使用图与PGDAT的依赖检查功能。",
          "similarity": 0.5936102867126465
        },
        {
          "chunk_id": 4,
          "file_path": "mm/sparse.c",
          "start_line": 592,
          "end_line": 692,
          "content": [
            "void online_mem_sections(unsigned long start_pfn, unsigned long end_pfn)",
            "{",
            "\tunsigned long pfn;",
            "",
            "\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {",
            "\t\tunsigned long section_nr = pfn_to_section_nr(pfn);",
            "\t\tstruct mem_section *ms;",
            "",
            "\t\t/* onlining code should never touch invalid ranges */",
            "\t\tif (WARN_ON(!valid_section_nr(section_nr)))",
            "\t\t\tcontinue;",
            "",
            "\t\tms = __nr_to_section(section_nr);",
            "\t\tms->section_mem_map |= SECTION_IS_ONLINE;",
            "\t}",
            "}",
            "void offline_mem_sections(unsigned long start_pfn, unsigned long end_pfn)",
            "{",
            "\tunsigned long pfn;",
            "",
            "\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {",
            "\t\tunsigned long section_nr = pfn_to_section_nr(pfn);",
            "\t\tstruct mem_section *ms;",
            "",
            "\t\t/*",
            "\t\t * TODO this needs some double checking. Offlining code makes",
            "\t\t * sure to check pfn_valid but those checks might be just bogus",
            "\t\t */",
            "\t\tif (WARN_ON(!valid_section_nr(section_nr)))",
            "\t\t\tcontinue;",
            "",
            "\t\tms = __nr_to_section(section_nr);",
            "\t\tms->section_mem_map &= ~SECTION_IS_ONLINE;",
            "\t}",
            "}",
            "static void depopulate_section_memmap(unsigned long pfn, unsigned long nr_pages,",
            "\t\tstruct vmem_altmap *altmap)",
            "{",
            "\tunsigned long start = (unsigned long) pfn_to_page(pfn);",
            "\tunsigned long end = start + nr_pages * sizeof(struct page);",
            "",
            "\tvmemmap_free(start, end, altmap);",
            "}",
            "static void free_map_bootmem(struct page *memmap)",
            "{",
            "\tunsigned long start = (unsigned long)memmap;",
            "\tunsigned long end = (unsigned long)(memmap + PAGES_PER_SECTION);",
            "",
            "\tvmemmap_free(start, end, NULL);",
            "}",
            "static int clear_subsection_map(unsigned long pfn, unsigned long nr_pages)",
            "{",
            "\tDECLARE_BITMAP(map, SUBSECTIONS_PER_SECTION) = { 0 };",
            "\tDECLARE_BITMAP(tmp, SUBSECTIONS_PER_SECTION) = { 0 };",
            "\tstruct mem_section *ms = __pfn_to_section(pfn);",
            "\tunsigned long *subsection_map = ms->usage",
            "\t\t? &ms->usage->subsection_map[0] : NULL;",
            "",
            "\tsubsection_mask_set(map, pfn, nr_pages);",
            "\tif (subsection_map)",
            "\t\tbitmap_and(tmp, map, subsection_map, SUBSECTIONS_PER_SECTION);",
            "",
            "\tif (WARN(!subsection_map || !bitmap_equal(tmp, map, SUBSECTIONS_PER_SECTION),",
            "\t\t\t\t\"section already deactivated (%#lx + %ld)\\n\",",
            "\t\t\t\tpfn, nr_pages))",
            "\t\treturn -EINVAL;",
            "",
            "\tbitmap_xor(subsection_map, map, subsection_map, SUBSECTIONS_PER_SECTION);",
            "\treturn 0;",
            "}",
            "static bool is_subsection_map_empty(struct mem_section *ms)",
            "{",
            "\treturn bitmap_empty(&ms->usage->subsection_map[0],",
            "\t\t\t    SUBSECTIONS_PER_SECTION);",
            "}",
            "static int fill_subsection_map(unsigned long pfn, unsigned long nr_pages)",
            "{",
            "\tstruct mem_section *ms = __pfn_to_section(pfn);",
            "\tDECLARE_BITMAP(map, SUBSECTIONS_PER_SECTION) = { 0 };",
            "\tunsigned long *subsection_map;",
            "\tint rc = 0;",
            "",
            "\tsubsection_mask_set(map, pfn, nr_pages);",
            "",
            "\tsubsection_map = &ms->usage->subsection_map[0];",
            "",
            "\tif (bitmap_empty(map, SUBSECTIONS_PER_SECTION))",
            "\t\trc = -EINVAL;",
            "\telse if (bitmap_intersects(map, subsection_map, SUBSECTIONS_PER_SECTION))",
            "\t\trc = -EEXIST;",
            "\telse",
            "\t\tbitmap_or(subsection_map, map, subsection_map,",
            "\t\t\t\tSUBSECTIONS_PER_SECTION);",
            "",
            "\treturn rc;",
            "}",
            "static void depopulate_section_memmap(unsigned long pfn, unsigned long nr_pages,",
            "\t\tstruct vmem_altmap *altmap)",
            "{",
            "\tkvfree(pfn_to_page(pfn));",
            "}"
          ],
          "function_name": "online_mem_sections, offline_mem_sections, depopulate_section_memmap, free_map_bootmem, clear_subsection_map, is_subsection_map_empty, fill_subsection_map, depopulate_section_memmap",
          "description": "提供区段在线/离线操作接口，修改区段在线状态标志。实现depopulate_section_memmap释放内存映射，free_map_bootmem释放启动内存。包含子部分掩码操作函数，用于跟踪和验证内存区域的有效性。",
          "similarity": 0.5773797035217285
        },
        {
          "chunk_id": 3,
          "file_path": "mm/sparse.c",
          "start_line": 410,
          "end_line": 527,
          "content": [
            "static void __init check_usemap_section_nr(int nid,",
            "\t\tstruct mem_section_usage *usage)",
            "{",
            "}",
            "static unsigned long __init section_map_size(void)",
            "{",
            "\treturn ALIGN(sizeof(struct page) * PAGES_PER_SECTION, PMD_SIZE);",
            "}",
            "static unsigned long __init section_map_size(void)",
            "{",
            "\treturn PAGE_ALIGN(sizeof(struct page) * PAGES_PER_SECTION);",
            "}",
            "static inline void __meminit sparse_buffer_free(unsigned long size)",
            "{",
            "\tWARN_ON(!sparsemap_buf || size == 0);",
            "\tmemblock_free(sparsemap_buf, size);",
            "}",
            "static void __init sparse_buffer_init(unsigned long size, int nid)",
            "{",
            "\tphys_addr_t addr = __pa(MAX_DMA_ADDRESS);",
            "\tWARN_ON(sparsemap_buf);\t/* forgot to call sparse_buffer_fini()? */",
            "\t/*",
            "\t * Pre-allocated buffer is mainly used by __populate_section_memmap",
            "\t * and we want it to be properly aligned to the section size - this is",
            "\t * especially the case for VMEMMAP which maps memmap to PMDs",
            "\t */",
            "\tsparsemap_buf = memmap_alloc(size, section_map_size(), addr, nid, true);",
            "\tsparsemap_buf_end = sparsemap_buf + size;",
            "}",
            "static void __init sparse_buffer_fini(void)",
            "{",
            "\tunsigned long size = sparsemap_buf_end - sparsemap_buf;",
            "",
            "\tif (sparsemap_buf && size > 0)",
            "\t\tsparse_buffer_free(size);",
            "\tsparsemap_buf = NULL;",
            "}",
            "void __weak __meminit vmemmap_populate_print_last(void)",
            "{",
            "}",
            "static void __init sparse_init_nid(int nid, unsigned long pnum_begin,",
            "\t\t\t\t   unsigned long pnum_end,",
            "\t\t\t\t   unsigned long map_count)",
            "{",
            "\tstruct mem_section_usage *usage;",
            "\tunsigned long pnum;",
            "\tstruct page *map;",
            "",
            "\tusage = sparse_early_usemaps_alloc_pgdat_section(NODE_DATA(nid),",
            "\t\t\tmem_section_usage_size() * map_count);",
            "\tif (!usage) {",
            "\t\tpr_err(\"%s: node[%d] usemap allocation failed\", __func__, nid);",
            "\t\tgoto failed;",
            "\t}",
            "\tsparse_buffer_init(map_count * section_map_size(), nid);",
            "\tfor_each_present_section_nr(pnum_begin, pnum) {",
            "\t\tunsigned long pfn = section_nr_to_pfn(pnum);",
            "",
            "\t\tif (pnum >= pnum_end)",
            "\t\t\tbreak;",
            "",
            "\t\tmap = __populate_section_memmap(pfn, PAGES_PER_SECTION,",
            "\t\t\t\tnid, NULL, NULL);",
            "\t\tif (!map) {",
            "\t\t\tpr_err(\"%s: node[%d] memory map backing failed. Some memory will not be available.\",",
            "\t\t\t       __func__, nid);",
            "\t\t\tpnum_begin = pnum;",
            "\t\t\tsparse_buffer_fini();",
            "\t\t\tgoto failed;",
            "\t\t}",
            "\t\tcheck_usemap_section_nr(nid, usage);",
            "\t\tsparse_init_one_section(__nr_to_section(pnum), pnum, map, usage,",
            "\t\t\t\tSECTION_IS_EARLY);",
            "\t\tusage = (void *) usage + mem_section_usage_size();",
            "\t}",
            "\tsparse_buffer_fini();",
            "\treturn;",
            "failed:",
            "\t/* We failed to allocate, mark all the following pnums as not present */",
            "\tfor_each_present_section_nr(pnum_begin, pnum) {",
            "\t\tstruct mem_section *ms;",
            "",
            "\t\tif (pnum >= pnum_end)",
            "\t\t\tbreak;",
            "\t\tms = __nr_to_section(pnum);",
            "\t\tms->section_mem_map = 0;",
            "\t}",
            "}",
            "void __init sparse_init(void)",
            "{",
            "\tunsigned long pnum_end, pnum_begin, map_count = 1;",
            "\tint nid_begin;",
            "",
            "\tmemblocks_present();",
            "",
            "\tpnum_begin = first_present_section_nr();",
            "\tnid_begin = sparse_early_nid(__nr_to_section(pnum_begin));",
            "",
            "\t/* Setup pageblock_order for HUGETLB_PAGE_SIZE_VARIABLE */",
            "\tset_pageblock_order();",
            "",
            "\tfor_each_present_section_nr(pnum_begin + 1, pnum_end) {",
            "\t\tint nid = sparse_early_nid(__nr_to_section(pnum_end));",
            "",
            "\t\tif (nid == nid_begin) {",
            "\t\t\tmap_count++;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t/* Init node with sections in range [pnum_begin, pnum_end) */",
            "\t\tsparse_init_nid(nid_begin, pnum_begin, pnum_end, map_count);",
            "\t\tnid_begin = nid;",
            "\t\tpnum_begin = pnum_end;",
            "\t\tmap_count = 1;",
            "\t}",
            "\t/* cover the last node */",
            "\tsparse_init_nid(nid_begin, pnum_begin, pnum_end, map_count);",
            "\tvmemmap_populate_print_last();",
            "}"
          ],
          "function_name": "check_usemap_section_nr, section_map_size, section_map_size, sparse_buffer_free, sparse_buffer_init, sparse_buffer_fini, vmemmap_populate_print_last, sparse_init_nid, sparse_init",
          "description": "定义section_map_size计算区段映射大小，管理sparse_buffer缓冲区的分配释放。实现sparse_init_nid初始化节点区段，通过__populate_section_memmap填充内存图。包含错误处理逻辑，失败时清除已分配区段标识。",
          "similarity": 0.5672698020935059
        },
        {
          "chunk_id": 1,
          "file_path": "mm/sparse.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "int page_to_nid(const struct page *page)",
            "{",
            "\treturn section_to_node_table[page_to_section(page)];",
            "}",
            "static void set_section_nid(unsigned long section_nr, int nid)",
            "{",
            "\tsection_to_node_table[section_nr] = nid;",
            "}",
            "static inline void set_section_nid(unsigned long section_nr, int nid)",
            "{",
            "}",
            "static int __meminit sparse_index_init(unsigned long section_nr, int nid)",
            "{",
            "\tunsigned long root = SECTION_NR_TO_ROOT(section_nr);",
            "\tstruct mem_section *section;",
            "",
            "\t/*",
            "\t * An existing section is possible in the sub-section hotplug",
            "\t * case. First hot-add instantiates, follow-on hot-add reuses",
            "\t * the existing section.",
            "\t *",
            "\t * The mem_hotplug_lock resolves the apparent race below.",
            "\t */",
            "\tif (mem_section[root])",
            "\t\treturn 0;",
            "",
            "\tsection = sparse_index_alloc(nid);",
            "\tif (!section)",
            "\t\treturn -ENOMEM;",
            "",
            "\tmem_section[root] = section;",
            "",
            "\treturn 0;",
            "}",
            "static inline int sparse_index_init(unsigned long section_nr, int nid)",
            "{",
            "\treturn 0;",
            "}",
            "static inline unsigned long sparse_encode_early_nid(int nid)",
            "{",
            "\treturn ((unsigned long)nid << SECTION_NID_SHIFT);",
            "}",
            "static inline int sparse_early_nid(struct mem_section *section)",
            "{",
            "\treturn (section->section_mem_map >> SECTION_NID_SHIFT);",
            "}",
            "static void __meminit mminit_validate_memmodel_limits(unsigned long *start_pfn,",
            "\t\t\t\t\t\tunsigned long *end_pfn)",
            "{",
            "\tunsigned long max_sparsemem_pfn = (PHYSMEM_END + 1) >> PAGE_SHIFT;",
            "",
            "\t/*",
            "\t * Sanity checks - do not allow an architecture to pass",
            "\t * in larger pfns than the maximum scope of sparsemem:",
            "\t */",
            "\tif (*start_pfn > max_sparsemem_pfn) {",
            "\t\tmminit_dprintk(MMINIT_WARNING, \"pfnvalidation\",",
            "\t\t\t\"Start of range %lu -> %lu exceeds SPARSEMEM max %lu\\n\",",
            "\t\t\t*start_pfn, *end_pfn, max_sparsemem_pfn);",
            "\t\tWARN_ON_ONCE(1);",
            "\t\t*start_pfn = max_sparsemem_pfn;",
            "\t\t*end_pfn = max_sparsemem_pfn;",
            "\t} else if (*end_pfn > max_sparsemem_pfn) {",
            "\t\tmminit_dprintk(MMINIT_WARNING, \"pfnvalidation\",",
            "\t\t\t\"End of range %lu -> %lu exceeds SPARSEMEM max %lu\\n\",",
            "\t\t\t*start_pfn, *end_pfn, max_sparsemem_pfn);",
            "\t\tWARN_ON_ONCE(1);",
            "\t\t*end_pfn = max_sparsemem_pfn;",
            "\t}",
            "}",
            "static void __section_mark_present(struct mem_section *ms,",
            "\t\tunsigned long section_nr)",
            "{",
            "\tif (section_nr > __highest_present_section_nr)",
            "\t\t__highest_present_section_nr = section_nr;",
            "",
            "\tms->section_mem_map |= SECTION_MARKED_PRESENT;",
            "}",
            "static inline unsigned long first_present_section_nr(void)",
            "{",
            "\treturn next_present_section_nr(-1);",
            "}",
            "static void subsection_mask_set(unsigned long *map, unsigned long pfn,",
            "\t\tunsigned long nr_pages)",
            "{",
            "\tint idx = subsection_map_index(pfn);",
            "\tint end = subsection_map_index(pfn + nr_pages - 1);",
            "",
            "\tbitmap_set(map, idx, end - idx + 1);",
            "}",
            "void __init subsection_map_init(unsigned long pfn, unsigned long nr_pages)",
            "{",
            "\tint end_sec = pfn_to_section_nr(pfn + nr_pages - 1);",
            "\tunsigned long nr, start_sec = pfn_to_section_nr(pfn);",
            "",
            "\tif (!nr_pages)",
            "\t\treturn;",
            "",
            "\tfor (nr = start_sec; nr <= end_sec; nr++) {",
            "\t\tstruct mem_section *ms;",
            "\t\tunsigned long pfns;",
            "",
            "\t\tpfns = min(nr_pages, PAGES_PER_SECTION",
            "\t\t\t\t- (pfn & ~PAGE_SECTION_MASK));",
            "\t\tms = __nr_to_section(nr);",
            "\t\tsubsection_mask_set(ms->usage->subsection_map, pfn, pfns);",
            "",
            "\t\tpr_debug(\"%s: sec: %lu pfns: %lu set(%d, %d)\\n\", __func__, nr,",
            "\t\t\t\tpfns, subsection_map_index(pfn),",
            "\t\t\t\tsubsection_map_index(pfn + pfns - 1));",
            "",
            "\t\tpfn += pfns;",
            "\t\tnr_pages -= pfns;",
            "\t}",
            "}"
          ],
          "function_name": "page_to_nid, set_section_nid, set_section_nid, sparse_index_init, sparse_index_init, sparse_encode_early_nid, sparse_early_nid, mminit_validate_memmodel_limits, __section_mark_present, first_present_section_nr, subsection_mask_set, subsection_map_init",
          "description": "提供区段与节点号转换接口，包括page_to_nid获取节点号，set_section_nid设置区段节点号。实现sparse_index_init初始化区段结构，包含内存分配和有效性检查。定义sparse_encode_early_nid/nid转换函数，以及内存模型验证和子部分掩码操作函数。",
          "similarity": 0.5284492373466492
        },
        {
          "chunk_id": 6,
          "file_path": "mm/sparse.c",
          "start_line": 925,
          "end_line": 934,
          "content": [
            "void sparse_remove_section(unsigned long pfn, unsigned long nr_pages,",
            "\t\t\t   struct vmem_altmap *altmap)",
            "{",
            "\tstruct mem_section *ms = __pfn_to_section(pfn);",
            "",
            "\tif (WARN_ON_ONCE(!valid_section(ms)))",
            "\t\treturn;",
            "",
            "\tsection_deactivate(pfn, nr_pages, altmap);",
            "}"
          ],
          "function_name": "sparse_remove_section",
          "description": "sparse_remove_section 调用 section_deactivate 停用指定 PFN 区间内存节，前提是目标节处于有效状态。",
          "similarity": 0.5263228416442871
        }
      ]
    },
    {
      "source_file": "kernel/sched/cputime.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:05:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\cputime.c`\n\n---\n\n# `sched/cputime.c` 技术文档\n\n## 1. 文件概述\n\n`sched/cputime.c` 是 Linux 内核调度子系统中负责 **CPU 时间统计与会计（accounting）** 的核心实现文件。其主要功能包括：\n\n- 对用户态、内核态、中断（硬中断/软中断）、虚拟机（guest）、steal、idle、iowait 等各类 CPU 时间进行精确统计；\n- 支持将 CPU 时间按进程、线程组（thread group）和 cgroup 层级进行聚合；\n- 在启用 `CONFIG_IRQ_TIME_ACCOUNTING` 时，提供基于高精度调度时钟（`sched_clock`）的中断时间细粒度追踪；\n- 为 `/proc/stat`、`/proc/[pid]/stat`、cgroup v1/v2 的 CPU 统计接口提供底层数据支持。\n\n该文件是内核 CPU 使用率监控、资源控制和性能分析的基础组件。\n\n---\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- `struct irqtime`（仅当 `CONFIG_IRQ_TIME_ACCOUNTING` 启用）  \n  每 CPU 变量，用于记录当前 CPU 上硬中断和软中断的累计时间及同步状态。\n- `cpu_irqtime`  \n  `DEFINE_PER_CPU(struct irqtime, cpu_irqtime)`，每个 CPU 的中断时间统计结构。\n\n### 主要函数\n\n| 函数 | 功能说明 |\n|------|--------|\n| `account_user_time()` | 统计进程在用户态消耗的 CPU 时间 |\n| `account_guest_time()` | 统计进程作为虚拟机 guest 消耗的 CPU 时间 |\n| `account_system_time()` | 统计进程在内核态（含中断上下文）消耗的 CPU 时间 |\n| `account_system_index_time()` | 按指定类型（IRQ/SOFTIRQ/SYSTEM）统计系统态时间 |\n| `account_steal_time()` | 统计因虚拟化导致的“被偷走”的 CPU 时间 |\n| `account_idle_time()` | 统计 CPU 空闲时间（区分 iowait 与普通 idle） |\n| `irqtime_account_irq()` | 在中断进入/退出时更新中断时间统计 |\n| `thread_group_cputime()` | 聚合线程组内所有任务的累计 CPU 时间（未完整显示） |\n| `account_other_time()` | 综合统计 steal、IRQ、softirq 等“非任务执行”时间 |\n| `read_sum_exec_runtime()` | 安全读取任务的累计执行时间（32 位平台加锁） |\n\n### 控制接口\n\n- `enable_sched_clock_irqtime()` / `disable_sched_clock_irqtime()`  \n  动态启停基于 `sched_clock` 的中断时间会计功能。\n\n---\n\n## 3. 关键实现\n\n### 中断时间会计（`CONFIG_IRQ_TIME_ACCOUNTING`）\n\n- 使用每 CPU 的 `cpu_irqtime` 结构，通过 `u64_stats` 同步机制保证读写一致性；\n- 在 `{soft,}irq_enter/exit` 路径中调用 `irqtime_account_irq()`，利用 `sched_clock_cpu()` 计算中断持续时间；\n- **无锁设计**：写操作仅在本 CPU 中断关闭时进行，读操作（如 `update_rq_clock()`）可能读到稍旧值，但避免了中断路径加锁开销；\n- 特殊处理 `ksoftirqd`：其软中断时间仍计入该内核线程自身，避免调度器误判。\n\n### 时间分类与统计\n\n- **用户时间**：根据 `task_nice(p) > 0` 区分 `CPUTIME_USER` 与 `CPUTIME_NICE`；\n- **Guest 时间**：同时计入用户时间与 `CPUTIME_GUEST`/`GUEST_NICE`；\n- **系统时间**：根据中断上下文动态判断为 `IRQ`、`SOFTIRQ` 或 `SYSTEM`；\n- **Idle 时间**：通过 `rq->nr_iowait` 判断是否为 I/O 等待状态；\n- **Steal 时间**：通过 `paravirt_steal_clock()` 获取虚拟化层报告的被抢占时间。\n\n### cgroup 集成\n\n- 所有时间统计均通过 `task_group_account_field()` 同时更新：\n  - 全局 `kernel_cpustat`（用于 `/proc/stat`）；\n  - 当前任务所属 cgroup 的 CPU 统计（通过 `cgroup_account_cputime_field()`）。\n\n### 32 位平台兼容性\n\n- 在 32 位系统上，`sum_exec_runtime` 的读取需加 `rq` 锁以避免 64 位值撕裂（tearing）；\n- 64 位平台可直接原子读取。\n\n---\n\n## 4. 依赖关系\n\n- **架构依赖**：\n  - `CONFIG_VIRT_CPU_ACCOUNTING_NATIVE`：包含 `<asm/cputime.h>`，用于架构特定的 CPU 时间处理；\n- **配置选项**：\n  - `CONFIG_IRQ_TIME_ACCOUNTING`：启用高精度中断时间追踪；\n  - `CONFIG_PARAVIRT`：支持虚拟化 steal time 统计；\n  - `CONFIG_SCHED_CORE`：支持 core scheduling 的 forceidle 时间统计；\n  - `CONFIG_CGROUPS`：通过 `cgroup_account_cputime_field()` 集成 cgroup CPU 统计；\n- **内核模块**：\n  - 调度器核心（`kernel/sched/core.c`）：调用时间会计函数；\n  - 进程管理（`kernel/fork.c`, `kernel/exit.c`）：使用 `thread_group_cputime()`；\n  - 虚拟化子系统（`arch/*/kernel/paravirt.c`）：提供 `paravirt_steal_clock()`；\n  - procfs（`fs/proc/stat.c`）：读取 `kcpustat_this_cpu` 生成 `/proc/stat`。\n\n---\n\n## 5. 使用场景\n\n1. **系统监控工具**  \n   `top`、`htop`、`vmstat`、`iostat` 等通过 `/proc/stat` 获取全局 CPU 使用分布（user/nice/system/irq/steal 等）。\n\n2. **进程资源统计**  \n   `/proc/[pid]/stat` 中的 `utime`/`stime` 字段由 `account_user_time()` 和 `account_system_time()` 更新。\n\n3. **cgroup 资源控制**  \n   cgroup v1 的 `cpuacct` 子系统和 cgroup v2 的 `cpu.stat` 依赖 `task_group_account_field()` 聚合计费数据。\n\n4. **虚拟化性能分析**  \n   在 KVM/Xen 等虚拟机中，`steal time` 反映宿主机对 vCPU 的调度延迟，用于诊断性能瓶颈。\n\n5. **调度器决策**  \n   CFS 调度器使用 `sum_exec_runtime` 进行公平调度；`ksoftirqd` 的特殊处理确保软中断负载被正确感知。\n\n6. **功耗与能效分析**  \n   精确的 idle/iowait/irq 时间统计为 CPU 频率调节（如 `intel_pstate`）和电源管理提供依据。",
      "similarity": 0.6238787174224854,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/sched/cputime.c",
          "start_line": 648,
          "end_line": 758,
          "content": [
            "void thread_group_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)",
            "{",
            "\tstruct task_cputime cputime;",
            "",
            "\tthread_group_cputime(p, &cputime);",
            "\tcputime_adjust(&cputime, &p->signal->prev_cputime, ut, st);",
            "}",
            "static u64 vtime_delta(struct vtime *vtime)",
            "{",
            "\tunsigned long long clock;",
            "",
            "\tclock = sched_clock();",
            "\tif (clock < vtime->starttime)",
            "\t\treturn 0;",
            "",
            "\treturn clock - vtime->starttime;",
            "}",
            "static u64 get_vtime_delta(struct vtime *vtime)",
            "{",
            "\tu64 delta = vtime_delta(vtime);",
            "\tu64 other;",
            "",
            "\t/*",
            "\t * Unlike tick based timing, vtime based timing never has lost",
            "\t * ticks, and no need for steal time accounting to make up for",
            "\t * lost ticks. Vtime accounts a rounded version of actual",
            "\t * elapsed time. Limit account_other_time to prevent rounding",
            "\t * errors from causing elapsed vtime to go negative.",
            "\t */",
            "\tother = account_other_time(delta);",
            "\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);",
            "\tvtime->starttime += delta;",
            "",
            "\treturn delta - other;",
            "}",
            "static void vtime_account_system(struct task_struct *tsk,",
            "\t\t\t\t struct vtime *vtime)",
            "{",
            "\tvtime->stime += get_vtime_delta(vtime);",
            "\tif (vtime->stime >= TICK_NSEC) {",
            "\t\taccount_system_time(tsk, irq_count(), vtime->stime);",
            "\t\tvtime->stime = 0;",
            "\t}",
            "}",
            "static void vtime_account_guest(struct task_struct *tsk,",
            "\t\t\t\tstruct vtime *vtime)",
            "{",
            "\tvtime->gtime += get_vtime_delta(vtime);",
            "\tif (vtime->gtime >= TICK_NSEC) {",
            "\t\taccount_guest_time(tsk, vtime->gtime);",
            "\t\tvtime->gtime = 0;",
            "\t}",
            "}",
            "static void __vtime_account_kernel(struct task_struct *tsk,",
            "\t\t\t\t   struct vtime *vtime)",
            "{",
            "\t/* We might have scheduled out from guest path */",
            "\tif (vtime->state == VTIME_GUEST)",
            "\t\tvtime_account_guest(tsk, vtime);",
            "\telse",
            "\t\tvtime_account_system(tsk, vtime);",
            "}",
            "void vtime_account_kernel(struct task_struct *tsk)",
            "{",
            "\tstruct vtime *vtime = &tsk->vtime;",
            "",
            "\tif (!vtime_delta(vtime))",
            "\t\treturn;",
            "",
            "\twrite_seqcount_begin(&vtime->seqcount);",
            "\t__vtime_account_kernel(tsk, vtime);",
            "\twrite_seqcount_end(&vtime->seqcount);",
            "}",
            "void vtime_user_enter(struct task_struct *tsk)",
            "{",
            "\tstruct vtime *vtime = &tsk->vtime;",
            "",
            "\twrite_seqcount_begin(&vtime->seqcount);",
            "\tvtime_account_system(tsk, vtime);",
            "\tvtime->state = VTIME_USER;",
            "\twrite_seqcount_end(&vtime->seqcount);",
            "}",
            "void vtime_user_exit(struct task_struct *tsk)",
            "{",
            "\tstruct vtime *vtime = &tsk->vtime;",
            "",
            "\twrite_seqcount_begin(&vtime->seqcount);",
            "\tvtime->utime += get_vtime_delta(vtime);",
            "\tif (vtime->utime >= TICK_NSEC) {",
            "\t\taccount_user_time(tsk, vtime->utime);",
            "\t\tvtime->utime = 0;",
            "\t}",
            "\tvtime->state = VTIME_SYS;",
            "\twrite_seqcount_end(&vtime->seqcount);",
            "}",
            "void vtime_guest_enter(struct task_struct *tsk)",
            "{",
            "\tstruct vtime *vtime = &tsk->vtime;",
            "\t/*",
            "\t * The flags must be updated under the lock with",
            "\t * the vtime_starttime flush and update.",
            "\t * That enforces a right ordering and update sequence",
            "\t * synchronization against the reader (task_gtime())",
            "\t * that can thus safely catch up with a tickless delta.",
            "\t */",
            "\twrite_seqcount_begin(&vtime->seqcount);",
            "\tvtime_account_system(tsk, vtime);",
            "\ttsk->flags |= PF_VCPU;",
            "\tvtime->state = VTIME_GUEST;",
            "\twrite_seqcount_end(&vtime->seqcount);",
            "}"
          ],
          "function_name": "thread_group_cputime_adjusted, vtime_delta, get_vtime_delta, vtime_account_system, vtime_account_guest, __vtime_account_kernel, vtime_account_kernel, vtime_user_enter, vtime_user_exit, vtime_guest_enter",
          "description": "处理线程组累计CPU时间调整，计算虚拟时间差值并更新系统/用户/客体时间，通过状态机管理任务时间统计",
          "similarity": 0.6672906875610352
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/sched/cputime.c",
          "start_line": 896,
          "end_line": 1014,
          "content": [
            "static int vtime_state_fetch(struct vtime *vtime, int cpu)",
            "{",
            "\tint state = READ_ONCE(vtime->state);",
            "",
            "\t/*",
            "\t * We raced against a context switch, fetch the",
            "\t * kcpustat task again.",
            "\t */",
            "\tif (vtime->cpu != cpu && vtime->cpu != -1)",
            "\t\treturn -EAGAIN;",
            "",
            "\t/*",
            "\t * Two possible things here:",
            "\t * 1) We are seeing the scheduling out task (prev) or any past one.",
            "\t * 2) We are seeing the scheduling in task (next) but it hasn't",
            "\t *    passed though vtime_task_switch() yet so the pending",
            "\t *    cputime of the prev task may not be flushed yet.",
            "\t *",
            "\t * Case 1) is ok but 2) is not. So wait for a safe VTIME state.",
            "\t */",
            "\tif (state == VTIME_INACTIVE)",
            "\t\treturn -EAGAIN;",
            "",
            "\treturn state;",
            "}",
            "static u64 kcpustat_user_vtime(struct vtime *vtime)",
            "{",
            "\tif (vtime->state == VTIME_USER)",
            "\t\treturn vtime->utime + vtime_delta(vtime);",
            "\telse if (vtime->state == VTIME_GUEST)",
            "\t\treturn vtime->gtime + vtime_delta(vtime);",
            "\treturn 0;",
            "}",
            "static int kcpustat_field_vtime(u64 *cpustat,",
            "\t\t\t\tstruct task_struct *tsk,",
            "\t\t\t\tenum cpu_usage_stat usage,",
            "\t\t\t\tint cpu, u64 *val)",
            "{",
            "\tstruct vtime *vtime = &tsk->vtime;",
            "\tunsigned int seq;",
            "",
            "\tdo {",
            "\t\tint state;",
            "",
            "\t\tseq = read_seqcount_begin(&vtime->seqcount);",
            "",
            "\t\tstate = vtime_state_fetch(vtime, cpu);",
            "\t\tif (state < 0)",
            "\t\t\treturn state;",
            "",
            "\t\t*val = cpustat[usage];",
            "",
            "\t\t/*",
            "\t\t * Nice VS unnice cputime accounting may be inaccurate if",
            "\t\t * the nice value has changed since the last vtime update.",
            "\t\t * But proper fix would involve interrupting target on nice",
            "\t\t * updates which is a no go on nohz_full (although the scheduler",
            "\t\t * may still interrupt the target if rescheduling is needed...)",
            "\t\t */",
            "\t\tswitch (usage) {",
            "\t\tcase CPUTIME_SYSTEM:",
            "\t\t\tif (state == VTIME_SYS)",
            "\t\t\t\t*val += vtime->stime + vtime_delta(vtime);",
            "\t\t\tbreak;",
            "\t\tcase CPUTIME_USER:",
            "\t\t\tif (task_nice(tsk) <= 0)",
            "\t\t\t\t*val += kcpustat_user_vtime(vtime);",
            "\t\t\tbreak;",
            "\t\tcase CPUTIME_NICE:",
            "\t\t\tif (task_nice(tsk) > 0)",
            "\t\t\t\t*val += kcpustat_user_vtime(vtime);",
            "\t\t\tbreak;",
            "\t\tcase CPUTIME_GUEST:",
            "\t\t\tif (state == VTIME_GUEST && task_nice(tsk) <= 0)",
            "\t\t\t\t*val += vtime->gtime + vtime_delta(vtime);",
            "\t\t\tbreak;",
            "\t\tcase CPUTIME_GUEST_NICE:",
            "\t\t\tif (state == VTIME_GUEST && task_nice(tsk) > 0)",
            "\t\t\t\t*val += vtime->gtime + vtime_delta(vtime);",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t} while (read_seqcount_retry(&vtime->seqcount, seq));",
            "",
            "\treturn 0;",
            "}",
            "u64 kcpustat_field(struct kernel_cpustat *kcpustat,",
            "\t\t   enum cpu_usage_stat usage, int cpu)",
            "{",
            "\tu64 *cpustat = kcpustat->cpustat;",
            "\tu64 val = cpustat[usage];",
            "\tstruct rq *rq;",
            "\tint err;",
            "",
            "\tif (!vtime_accounting_enabled_cpu(cpu))",
            "\t\treturn val;",
            "",
            "\trq = cpu_rq(cpu);",
            "",
            "\tfor (;;) {",
            "\t\tstruct task_struct *curr;",
            "",
            "\t\trcu_read_lock();",
            "\t\tcurr = rcu_dereference(rq->curr);",
            "\t\tif (WARN_ON_ONCE(!curr)) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\treturn cpustat[usage];",
            "\t\t}",
            "",
            "\t\terr = kcpustat_field_vtime(cpustat, curr, usage, cpu, &val);",
            "\t\trcu_read_unlock();",
            "",
            "\t\tif (!err)",
            "\t\t\treturn val;",
            "",
            "\t\tcpu_relax();",
            "\t}",
            "}"
          ],
          "function_name": "vtime_state_fetch, kcpustat_user_vtime, kcpustat_field_vtime, kcpustat_field",
          "description": "实现CPU统计字段的虚拟时间修正逻辑，根据任务状态区分系统/用户/Guest时间，并处理优先级调整导致的统计偏差",
          "similarity": 0.6665530204772949
        },
        {
          "chunk_id": 8,
          "file_path": "kernel/sched/cputime.c",
          "start_line": 1020,
          "end_line": 1104,
          "content": [
            "static int kcpustat_cpu_fetch_vtime(struct kernel_cpustat *dst,",
            "\t\t\t\t    const struct kernel_cpustat *src,",
            "\t\t\t\t    struct task_struct *tsk, int cpu)",
            "{",
            "\tstruct vtime *vtime = &tsk->vtime;",
            "\tunsigned int seq;",
            "",
            "\tdo {",
            "\t\tu64 *cpustat;",
            "\t\tu64 delta;",
            "\t\tint state;",
            "",
            "\t\tseq = read_seqcount_begin(&vtime->seqcount);",
            "",
            "\t\tstate = vtime_state_fetch(vtime, cpu);",
            "\t\tif (state < 0)",
            "\t\t\treturn state;",
            "",
            "\t\t*dst = *src;",
            "\t\tcpustat = dst->cpustat;",
            "",
            "\t\t/* Task is sleeping, dead or idle, nothing to add */",
            "\t\tif (state < VTIME_SYS)",
            "\t\t\tcontinue;",
            "",
            "\t\tdelta = vtime_delta(vtime);",
            "",
            "\t\t/*",
            "\t\t * Task runs either in user (including guest) or kernel space,",
            "\t\t * add pending nohz time to the right place.",
            "\t\t */",
            "\t\tif (state == VTIME_SYS) {",
            "\t\t\tcpustat[CPUTIME_SYSTEM] += vtime->stime + delta;",
            "\t\t} else if (state == VTIME_USER) {",
            "\t\t\tif (task_nice(tsk) > 0)",
            "\t\t\t\tcpustat[CPUTIME_NICE] += vtime->utime + delta;",
            "\t\t\telse",
            "\t\t\t\tcpustat[CPUTIME_USER] += vtime->utime + delta;",
            "\t\t} else {",
            "\t\t\tWARN_ON_ONCE(state != VTIME_GUEST);",
            "\t\t\tif (task_nice(tsk) > 0) {",
            "\t\t\t\tcpustat[CPUTIME_GUEST_NICE] += vtime->gtime + delta;",
            "\t\t\t\tcpustat[CPUTIME_NICE] += vtime->gtime + delta;",
            "\t\t\t} else {",
            "\t\t\t\tcpustat[CPUTIME_GUEST] += vtime->gtime + delta;",
            "\t\t\t\tcpustat[CPUTIME_USER] += vtime->gtime + delta;",
            "\t\t\t}",
            "\t\t}",
            "\t} while (read_seqcount_retry(&vtime->seqcount, seq));",
            "",
            "\treturn 0;",
            "}",
            "void kcpustat_cpu_fetch(struct kernel_cpustat *dst, int cpu)",
            "{",
            "\tconst struct kernel_cpustat *src = &kcpustat_cpu(cpu);",
            "\tstruct rq *rq;",
            "\tint err;",
            "",
            "\tif (!vtime_accounting_enabled_cpu(cpu)) {",
            "\t\t*dst = *src;",
            "\t\treturn;",
            "\t}",
            "",
            "\trq = cpu_rq(cpu);",
            "",
            "\tfor (;;) {",
            "\t\tstruct task_struct *curr;",
            "",
            "\t\trcu_read_lock();",
            "\t\tcurr = rcu_dereference(rq->curr);",
            "\t\tif (WARN_ON_ONCE(!curr)) {",
            "\t\t\trcu_read_unlock();",
            "\t\t\t*dst = *src;",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\terr = kcpustat_cpu_fetch_vtime(dst, src, curr, cpu);",
            "\t\trcu_read_unlock();",
            "",
            "\t\tif (!err)",
            "\t\t\treturn;",
            "",
            "\t\tcpu_relax();",
            "\t}",
            "}"
          ],
          "function_name": "kcpustat_cpu_fetch_vtime, kcpustat_cpu_fetch",
          "description": "同步CPU层级统计信息，通过遍历就绪队列当前任务，将虚拟时间增量合并到全局CPU使用统计中，支持多核时间追踪",
          "similarity": 0.6279176473617554
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/sched/cputime.c",
          "start_line": 376,
          "end_line": 489,
          "content": [
            "static void irqtime_account_process_tick(struct task_struct *p, int user_tick,",
            "\t\t\t\t\t int ticks)",
            "{",
            "\tu64 other, cputime = TICK_NSEC * ticks;",
            "",
            "\t/*",
            "\t * When returning from idle, many ticks can get accounted at",
            "\t * once, including some ticks of steal, irq, and softirq time.",
            "\t * Subtract those ticks from the amount of time accounted to",
            "\t * idle, or potentially user or system time. Due to rounding,",
            "\t * other time can exceed ticks occasionally.",
            "\t */",
            "\tother = account_other_time(ULONG_MAX);",
            "\tif (other >= cputime)",
            "\t\treturn;",
            "",
            "\tcputime -= other;",
            "",
            "\tif (this_cpu_ksoftirqd() == p) {",
            "\t\t/*",
            "\t\t * ksoftirqd time do not get accounted in cpu_softirq_time.",
            "\t\t * So, we have to handle it separately here.",
            "\t\t * Also, p->stime needs to be updated for ksoftirqd.",
            "\t\t */",
            "\t\taccount_system_index_time(p, cputime, CPUTIME_SOFTIRQ);",
            "\t} else if (user_tick) {",
            "\t\taccount_user_time(p, cputime);",
            "\t} else if (p == this_rq()->idle) {",
            "\t\taccount_idle_time(cputime);",
            "\t} else if (p->flags & PF_VCPU) { /* System time or guest time */",
            "\t\taccount_guest_time(p, cputime);",
            "\t} else {",
            "\t\taccount_system_index_time(p, cputime, CPUTIME_SYSTEM);",
            "\t}",
            "}",
            "static void irqtime_account_idle_ticks(int ticks)",
            "{",
            "\tirqtime_account_process_tick(current, 0, ticks);",
            "}",
            "static inline void irqtime_account_idle_ticks(int ticks) { }",
            "static inline void irqtime_account_process_tick(struct task_struct *p, int user_tick,",
            "\t\t\t\t\t\tint nr_ticks) { }",
            "void vtime_task_switch(struct task_struct *prev)",
            "{",
            "\tif (is_idle_task(prev))",
            "\t\tvtime_account_idle(prev);",
            "\telse",
            "\t\tvtime_account_kernel(prev);",
            "",
            "\tvtime_flush(prev);",
            "\tarch_vtime_task_switch(prev);",
            "}",
            "void vtime_account_irq(struct task_struct *tsk, unsigned int offset)",
            "{",
            "\tunsigned int pc = irq_count() - offset;",
            "",
            "\tif (pc & HARDIRQ_OFFSET) {",
            "\t\tvtime_account_hardirq(tsk);",
            "\t} else if (pc & SOFTIRQ_OFFSET) {",
            "\t\tvtime_account_softirq(tsk);",
            "\t} else if (!IS_ENABLED(CONFIG_HAVE_VIRT_CPU_ACCOUNTING_IDLE) &&",
            "\t\t   is_idle_task(tsk)) {",
            "\t\tvtime_account_idle(tsk);",
            "\t} else {",
            "\t\tvtime_account_kernel(tsk);",
            "\t}",
            "}",
            "void cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,",
            "\t\t    u64 *ut, u64 *st)",
            "{",
            "\t*ut = curr->utime;",
            "\t*st = curr->stime;",
            "}",
            "void task_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)",
            "{",
            "\t*ut = p->utime;",
            "\t*st = p->stime;",
            "}",
            "void thread_group_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)",
            "{",
            "\tstruct task_cputime cputime;",
            "",
            "\tthread_group_cputime(p, &cputime);",
            "",
            "\t*ut = cputime.utime;",
            "\t*st = cputime.stime;",
            "}",
            "void account_process_tick(struct task_struct *p, int user_tick)",
            "{",
            "\tu64 cputime, steal;",
            "",
            "\tif (vtime_accounting_enabled_this_cpu())",
            "\t\treturn;",
            "",
            "\tif (sched_clock_irqtime) {",
            "\t\tirqtime_account_process_tick(p, user_tick, 1);",
            "\t\treturn;",
            "\t}",
            "",
            "\tcputime = TICK_NSEC;",
            "\tsteal = steal_account_process_time(ULONG_MAX);",
            "",
            "\tif (steal >= cputime)",
            "\t\treturn;",
            "",
            "\tcputime -= steal;",
            "",
            "\tif (user_tick)",
            "\t\taccount_user_time(p, cputime);",
            "\telse if ((p != this_rq()->idle) || (irq_count() != HARDIRQ_OFFSET))",
            "\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime);",
            "\telse",
            "\t\taccount_idle_time(cputime);",
            "}"
          ],
          "function_name": "irqtime_account_process_tick, irqtime_account_idle_ticks, irqtime_account_idle_ticks, irqtime_account_process_tick, vtime_task_switch, vtime_account_irq, cputime_adjust, task_cputime_adjusted, thread_group_cputime_adjusted, account_process_tick",
          "description": "irqtime_account_process_tick根据用户态/系统态分配时间，vtime_task_switch处理任务切换时的上下文统计，vtime_account_irq区分硬中断/软中断统计，cputime_adjust/task_cputime_adjusted系列函数用于调整任务CPU时间统计以保证单调性",
          "similarity": 0.6057195067405701
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/sched/cputime.c",
          "start_line": 772,
          "end_line": 883,
          "content": [
            "void vtime_guest_exit(struct task_struct *tsk)",
            "{",
            "\tstruct vtime *vtime = &tsk->vtime;",
            "",
            "\twrite_seqcount_begin(&vtime->seqcount);",
            "\tvtime_account_guest(tsk, vtime);",
            "\ttsk->flags &= ~PF_VCPU;",
            "\tvtime->state = VTIME_SYS;",
            "\twrite_seqcount_end(&vtime->seqcount);",
            "}",
            "void vtime_account_idle(struct task_struct *tsk)",
            "{",
            "\taccount_idle_time(get_vtime_delta(&tsk->vtime));",
            "}",
            "void vtime_task_switch_generic(struct task_struct *prev)",
            "{",
            "\tstruct vtime *vtime = &prev->vtime;",
            "",
            "\twrite_seqcount_begin(&vtime->seqcount);",
            "\tif (vtime->state == VTIME_IDLE)",
            "\t\tvtime_account_idle(prev);",
            "\telse",
            "\t\t__vtime_account_kernel(prev, vtime);",
            "\tvtime->state = VTIME_INACTIVE;",
            "\tvtime->cpu = -1;",
            "\twrite_seqcount_end(&vtime->seqcount);",
            "",
            "\tvtime = &current->vtime;",
            "",
            "\twrite_seqcount_begin(&vtime->seqcount);",
            "\tif (is_idle_task(current))",
            "\t\tvtime->state = VTIME_IDLE;",
            "\telse if (current->flags & PF_VCPU)",
            "\t\tvtime->state = VTIME_GUEST;",
            "\telse",
            "\t\tvtime->state = VTIME_SYS;",
            "\tvtime->starttime = sched_clock();",
            "\tvtime->cpu = smp_processor_id();",
            "\twrite_seqcount_end(&vtime->seqcount);",
            "}",
            "void vtime_init_idle(struct task_struct *t, int cpu)",
            "{",
            "\tstruct vtime *vtime = &t->vtime;",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "\twrite_seqcount_begin(&vtime->seqcount);",
            "\tvtime->state = VTIME_IDLE;",
            "\tvtime->starttime = sched_clock();",
            "\tvtime->cpu = cpu;",
            "\twrite_seqcount_end(&vtime->seqcount);",
            "\tlocal_irq_restore(flags);",
            "}",
            "u64 task_gtime(struct task_struct *t)",
            "{",
            "\tstruct vtime *vtime = &t->vtime;",
            "\tunsigned int seq;",
            "\tu64 gtime;",
            "",
            "\tif (!vtime_accounting_enabled())",
            "\t\treturn t->gtime;",
            "",
            "\tdo {",
            "\t\tseq = read_seqcount_begin(&vtime->seqcount);",
            "",
            "\t\tgtime = t->gtime;",
            "\t\tif (vtime->state == VTIME_GUEST)",
            "\t\t\tgtime += vtime->gtime + vtime_delta(vtime);",
            "",
            "\t} while (read_seqcount_retry(&vtime->seqcount, seq));",
            "",
            "\treturn gtime;",
            "}",
            "bool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)",
            "{",
            "\tstruct vtime *vtime = &t->vtime;",
            "\tunsigned int seq;",
            "\tu64 delta;",
            "\tint ret;",
            "",
            "\tif (!vtime_accounting_enabled()) {",
            "\t\t*utime = t->utime;",
            "\t\t*stime = t->stime;",
            "\t\treturn false;",
            "\t}",
            "",
            "\tdo {",
            "\t\tret = false;",
            "\t\tseq = read_seqcount_begin(&vtime->seqcount);",
            "",
            "\t\t*utime = t->utime;",
            "\t\t*stime = t->stime;",
            "",
            "\t\t/* Task is sleeping or idle, nothing to add */",
            "\t\tif (vtime->state < VTIME_SYS)",
            "\t\t\tcontinue;",
            "",
            "\t\tret = true;",
            "\t\tdelta = vtime_delta(vtime);",
            "",
            "\t\t/*",
            "\t\t * Task runs either in user (including guest) or kernel space,",
            "\t\t * add pending nohz time to the right place.",
            "\t\t */",
            "\t\tif (vtime->state == VTIME_SYS)",
            "\t\t\t*stime += vtime->stime + delta;",
            "\t\telse",
            "\t\t\t*utime += vtime->utime + delta;",
            "\t} while (read_seqcount_retry(&vtime->seqcount, seq));",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "vtime_guest_exit, vtime_account_idle, vtime_task_switch_generic, vtime_init_idle, task_gtime, task_cputime",
          "description": "管理任务切换时的空闲时间会计，初始化空闲任务时间戳，提供任务实际运行时间查询及CPU时间统计接口",
          "similarity": 0.6004440188407898
        }
      ]
    }
  ]
}