{
  "query": "操作系统模块化带来的性能开销分析",
  "timestamp": "2025-12-26 02:00:11",
  "retrieved_files": [
    {
      "source_file": "kernel/module/stats.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:06:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\stats.c`\n\n---\n\n# `module/stats.c` 技术文档\n\n## 1. 文件概述\n\n`module/stats.c` 是 Linux 内核模块子系统中用于收集和跟踪模块加载失败相关调试统计信息的实现文件。当启用 `CONFIG_MODULE_STATS` 配置选项时，该文件提供对模块加载过程中因各种原因失败所导致的虚拟内存浪费情况的监控能力。其主要目标是帮助开发者和系统维护人员识别和优化模块加载过程中的资源浪费问题，特别是在系统启动阶段因重复加载或竞争条件导致的无效内存分配。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`dup_failed_modules`**  \n  全局静态链表（`LIST_HEAD`），用于记录因模块名称重复（已加载或正在处理）而加载失败的模块实例。该链表帮助追踪因用户空间竞争或内核并发加载导致的无效加载尝试。\n\n### 调试统计计数器（通过 debugfs 暴露）\n\n- **`total_mod_size`**：系统处理过的所有模块占用的总字节数。\n- **`total_text_size`**：所有模块的 `.text` 和 `.init.text` ELF 节区大小总和。\n- **`invalid_kread_bytes`**：因 `kernel_read_file_from_fd()` 阶段失败而浪费的 `vmalloc()` 分配字节数。\n- **`invalid_decompress_bytes`**：模块解压过程中因失败而浪费的 `vmap()` 分配字节数。\n- **`invalid_becoming_bytes`**：在 `early_mod_check()` 之后、`layout_and_allocate()` 之前失败所浪费的内存总量（含解压和读取阶段）。\n- **`invalid_mod_bytes`**：在 `layout_and_allocate()` 之后（即模块已分配最终内存布局）因失败而释放的内存总量。\n\n> 注：文档片段在 `invalid_mod_bytes` 处截断，但根据上下文可推断其用于统计最晚阶段（模块结构体已分配）的失败内存开销。\n\n## 3. 关键实现\n\n### 模块加载失败的三阶段内存模型\n\n模块加载过程中的内存分配分为三个关键阶段，每个阶段失败对应不同的统计计数器：\n\n1. **阶段 a**：`kernel_read_file_from_fd()` 使用 `vmalloc()` 读取模块文件。\n2. **阶段 b**（可选）：若模块为压缩格式，解压后通过 `vmap()` 映射解压内容，原始读取缓冲区随即释放。\n3. **阶段 c**：`layout_and_allocate()` 为模块分配最终运行时内存布局（可能使用 `vzalloc()` 或架构特定的 `vmalloc` 变体）。\n\n失败统计遵循“最晚失败点”原则：仅在导致失败的最晚阶段对应的计数器中累加**该次加载尝试中所有已分配并最终释放的内存总量**。\n\n### 重复模块加载失败分类\n\n针对因模块名重复导致的失败，细分为两类：\n\n- **`FAIL_DUP_MOD_BECOMING`**：在 `early_mod_check()` 末尾检测到重复（尚未调用 `layout_and_allocate()`）。\n  - 有解压：浪费 2 次分配（`kread` + `vmap`）\n  - 无解压：浪费 1 次分配（`kread`）\n- **`FAIL_DUP_MOD_LOAD`**：在 `add_unformed_module()` 阶段检测到重复（已执行 `layout_and_allocate()`）。\n  - 有解压：浪费 3 次分配\n  - 无解压：浪费 2 次分配\n\n### 原子计数与性能考量\n\n所有统计计数器均使用**原子操作**更新，以避免锁竞争、死锁及性能开销，确保在高并发模块加载场景下的低延迟。\n\n### debugfs 集成\n\n统计信息通过 **debugfs** 文件系统暴露，便于用户空间工具（如 `cat /sys/kernel/debug/...`）实时监控模块加载效率和内存浪费情况。\n\n## 4. 依赖关系\n\n- **内核头文件依赖**：\n  - `<linux/module.h>`：模块核心接口\n  - `<linux/debugfs.h>`：调试文件系统支持\n  - `<linux/vmalloc.h>` 相关（通过 `slab.h`, `math.h` 等间接依赖）：虚拟内存分配\n  - `<linux/rculist.h>`：RCU 安全链表操作\n- **内部依赖**：\n  - `\"internal.h\"`：模块子系统内部头文件，包含未公开的模块管理结构和函数\n- **配置依赖**：\n  - 仅在 `CONFIG_MODULE_STATS=y` 时编译生效\n\n## 5. 使用场景\n\n- **系统启动优化**：分析启动过程中因用户空间并发调用 `modprobe` 或 `request_module()` 导致的重复模块加载，减少不必要的 `vmalloc` 压力。\n- **内存压力诊断**：在虚拟地址空间受限的架构（如 x86 默认 128 MiB vmalloc 空间）上，定位模块加载失败是否加剧内存碎片或耗尽问题。\n- **内核/用户空间协同改进**：通过 `dup_failed_modules` 链表识别用户空间加载逻辑缺陷（如未检查 `/sys/module` 即重复加载），推动工具链优化。\n- **安全与验证调试**：监控因签名验证（`module_sig_check`）、ELF 格式错误或黑名单策略导致的早期失败，评估安全机制开销。",
      "similarity": 0.573165774345398,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/stats.c",
          "start_line": 220,
          "end_line": 385,
          "content": [
            "void mod_stat_bump_invalid(struct load_info *info, int flags)",
            "{",
            "\tatomic_long_add(info->len * 2, &invalid_mod_bytes);",
            "\tatomic_inc(&failed_load_modules);",
            "#if defined(CONFIG_MODULE_DECOMPRESS)",
            "\tif (flags & MODULE_INIT_COMPRESSED_FILE)",
            "\t\tatomic_long_add(info->compressed_len, &invalid_mod_bytes);",
            "#endif",
            "}",
            "void mod_stat_bump_becoming(struct load_info *info, int flags)",
            "{",
            "\tatomic_inc(&failed_becoming);",
            "\tatomic_long_add(info->len, &invalid_becoming_bytes);",
            "#if defined(CONFIG_MODULE_DECOMPRESS)",
            "\tif (flags & MODULE_INIT_COMPRESSED_FILE)",
            "\t\tatomic_long_add(info->compressed_len, &invalid_becoming_bytes);",
            "#endif",
            "}",
            "int try_add_failed_module(const char *name, enum fail_dup_mod_reason reason)",
            "{",
            "\tstruct mod_fail_load *mod_fail;",
            "",
            "\tlist_for_each_entry_rcu(mod_fail, &dup_failed_modules, list,",
            "\t\t\t\tlockdep_is_held(&module_mutex)) {",
            "\t\tif (!strcmp(mod_fail->name, name)) {",
            "\t\t\tatomic_long_inc(&mod_fail->count);",
            "\t\t\t__set_bit(reason, &mod_fail->dup_fail_mask);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tmod_fail = kzalloc(sizeof(*mod_fail), GFP_KERNEL);",
            "\tif (!mod_fail)",
            "\t\treturn -ENOMEM;",
            "\tmemcpy(mod_fail->name, name, strlen(name));",
            "\t__set_bit(reason, &mod_fail->dup_fail_mask);",
            "\tatomic_long_inc(&mod_fail->count);",
            "\tlist_add_rcu(&mod_fail->list, &dup_failed_modules);",
            "out:",
            "\treturn 0;",
            "}",
            "static ssize_t read_file_mod_stats(struct file *file, char __user *user_buf,",
            "\t\t\t\t   size_t count, loff_t *ppos)",
            "{",
            "\tstruct mod_fail_load *mod_fail;",
            "\tunsigned int len, size, count_failed = 0;",
            "\tchar *buf;",
            "\tint ret;",
            "\tu32 live_mod_count, fkreads, fdecompress, fbecoming, floads;",
            "\tunsigned long total_size, text_size, ikread_bytes, ibecoming_bytes,",
            "\t\tidecompress_bytes, imod_bytes, total_virtual_lost;",
            "",
            "\tlive_mod_count = atomic_read(&modcount);",
            "\tfkreads = atomic_read(&failed_kreads);",
            "\tfdecompress = atomic_read(&failed_decompress);",
            "\tfbecoming = atomic_read(&failed_becoming);",
            "\tfloads = atomic_read(&failed_load_modules);",
            "",
            "\ttotal_size = atomic_long_read(&total_mod_size);",
            "\ttext_size = atomic_long_read(&total_text_size);",
            "\tikread_bytes = atomic_long_read(&invalid_kread_bytes);",
            "\tidecompress_bytes = atomic_long_read(&invalid_decompress_bytes);",
            "\tibecoming_bytes = atomic_long_read(&invalid_becoming_bytes);",
            "\timod_bytes = atomic_long_read(&invalid_mod_bytes);",
            "",
            "\ttotal_virtual_lost = ikread_bytes + idecompress_bytes + ibecoming_bytes + imod_bytes;",
            "",
            "\tsize = MAX_PREAMBLE + min((unsigned int)(floads + fbecoming),",
            "\t\t\t\t  (unsigned int)MAX_FAILED_MOD_PRINT) * MAX_BYTES_PER_MOD;",
            "\tbuf = kzalloc(size, GFP_KERNEL);",
            "\tif (buf == NULL)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/* The beginning of our debug preamble */",
            "\tlen = scnprintf(buf, size, \"%25s\\t%u\\n\", \"Mods ever loaded\", live_mod_count);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%u\\n\", \"Mods failed on kread\", fkreads);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%u\\n\", \"Mods failed on decompress\",",
            "\t\t\t fdecompress);",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%u\\n\", \"Mods failed on becoming\", fbecoming);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%u\\n\", \"Mods failed on load\", floads);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Total module size\", total_size);",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Total mod text size\", text_size);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Failed kread bytes\", ikread_bytes);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Failed decompress bytes\",",
            "\t\t\t idecompress_bytes);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Failed becoming bytes\", ibecoming_bytes);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Failed kmod bytes\", imod_bytes);",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Virtual mem wasted bytes\", total_virtual_lost);",
            "",
            "\tif (live_mod_count && total_size) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Average mod size\",",
            "\t\t\t\t DIV_ROUND_UP(total_size, live_mod_count));",
            "\t}",
            "",
            "\tif (live_mod_count && text_size) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Average mod text size\",",
            "\t\t\t\t DIV_ROUND_UP(text_size, live_mod_count));",
            "\t}",
            "",
            "\t/*",
            "\t * We use WARN_ON_ONCE() for the counters to ensure we always have parity",
            "\t * for keeping tabs on a type of failure with one type of byte counter.",
            "\t * The counters for imod_bytes does not increase for fkreads failures",
            "\t * for example, and so on.",
            "\t */",
            "",
            "\tWARN_ON_ONCE(ikread_bytes && !fkreads);",
            "\tif (fkreads && ikread_bytes) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Avg fail kread bytes\",",
            "\t\t\t\t DIV_ROUND_UP(ikread_bytes, fkreads));",
            "\t}",
            "",
            "\tWARN_ON_ONCE(ibecoming_bytes && !fbecoming);",
            "\tif (fbecoming && ibecoming_bytes) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Avg fail becoming bytes\",",
            "\t\t\t\t DIV_ROUND_UP(ibecoming_bytes, fbecoming));",
            "\t}",
            "",
            "\tWARN_ON_ONCE(idecompress_bytes && !fdecompress);",
            "\tif (fdecompress && idecompress_bytes) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Avg fail decomp bytes\",",
            "\t\t\t\t DIV_ROUND_UP(idecompress_bytes, fdecompress));",
            "\t}",
            "",
            "\tWARN_ON_ONCE(imod_bytes && !floads);",
            "\tif (floads && imod_bytes) {",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%lu\\n\", \"Average fail load bytes\",",
            "\t\t\t\t DIV_ROUND_UP(imod_bytes, floads));",
            "\t}",
            "",
            "\t/* End of our debug preamble header. */",
            "",
            "\t/* Catch when we've gone beyond our expected preamble */",
            "\tWARN_ON_ONCE(len >= MAX_PREAMBLE);",
            "",
            "\tif (list_empty(&dup_failed_modules))",
            "\t\tgoto out;",
            "",
            "\tlen += scnprintf(buf + len, size - len, \"Duplicate failed modules:\\n\");",
            "\tlen += scnprintf(buf + len, size - len, \"%25s\\t%15s\\t%25s\\n\",",
            "\t\t\t \"Module-name\", \"How-many-times\", \"Reason\");",
            "\tmutex_lock(&module_mutex);",
            "",
            "",
            "\tlist_for_each_entry_rcu(mod_fail, &dup_failed_modules, list) {",
            "\t\tif (WARN_ON_ONCE(++count_failed >= MAX_FAILED_MOD_PRINT))",
            "\t\t\tgoto out_unlock;",
            "\t\tlen += scnprintf(buf + len, size - len, \"%25s\\t%15lu\\t%25s\\n\", mod_fail->name,",
            "\t\t\t\t atomic_long_read(&mod_fail->count), mod_fail_to_str(mod_fail));",
            "\t}",
            "out_unlock:",
            "\tmutex_unlock(&module_mutex);",
            "out:",
            "\tret = simple_read_from_buffer(user_buf, count, ppos, buf, len);",
            "\tkfree(buf);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "mod_stat_bump_invalid, mod_stat_bump_becoming, try_add_failed_module, read_file_mod_stats",
          "description": "实现模块加载失败统计的更新逻辑与导出接口，包含失败计数器递增、失败模块记录及调试信息格式化输出功能",
          "similarity": 0.5506958961486816
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/stats.c",
          "start_line": 1,
          "end_line": 219,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Debugging module statistics.",
            " *",
            " * Copyright (C) 2023 Luis Chamberlain <mcgrof@kernel.org>",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <uapi/linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/math.h>",
            "",
            "#include \"internal.h\"",
            "",
            "/**",
            " * DOC: module debugging statistics overview",
            " *",
            " * Enabling CONFIG_MODULE_STATS enables module debugging statistics which",
            " * are useful to monitor and root cause memory pressure issues with module",
            " * loading. These statistics are useful to allow us to improve production",
            " * workloads.",
            " *",
            " * The current module debugging statistics supported help keep track of module",
            " * loading failures to enable improvements either for kernel module auto-loading",
            " * usage (request_module()) or interactions with userspace. Statistics are",
            " * provided to track all possible failures in the finit_module() path and memory",
            " * wasted in this process space.  Each of the failure counters are associated",
            " * to a type of module loading failure which is known to incur a certain amount",
            " * of memory allocation loss. In the worst case loading a module will fail after",
            " * a 3 step memory allocation process:",
            " *",
            " *   a) memory allocated with kernel_read_file_from_fd()",
            " *   b) module decompression processes the file read from",
            " *      kernel_read_file_from_fd(), and vmap() is used to map",
            " *      the decompressed module to a new local buffer which represents",
            " *      a copy of the decompressed module passed from userspace. The buffer",
            " *      from kernel_read_file_from_fd() is freed right away.",
            " *   c) layout_and_allocate() allocates space for the final resting",
            " *      place where we would keep the module if it were to be processed",
            " *      successfully.",
            " *",
            " * If a failure occurs after these three different allocations only one",
            " * counter will be incremented with the summation of the allocated bytes freed",
            " * incurred during this failure. Likewise, if module loading failed only after",
            " * step b) a separate counter is used and incremented for the bytes freed and",
            " * not used during both of those allocations.",
            " *",
            " * Virtual memory space can be limited, for example on x86 virtual memory size",
            " * defaults to 128 MiB. We should strive to limit and avoid wasting virtual",
            " * memory allocations when possible. These module debugging statistics help",
            " * to evaluate how much memory is being wasted on bootup due to module loading",
            " * failures.",
            " *",
            " * All counters are designed to be incremental. Atomic counters are used so to",
            " * remain simple and avoid delays and deadlocks.",
            " */",
            "",
            "/**",
            " * DOC: dup_failed_modules - tracks duplicate failed modules",
            " *",
            " * Linked list of modules which failed to be loaded because an already existing",
            " * module with the same name was already being processed or already loaded.",
            " * The finit_module() system call incurs heavy virtual memory allocations. In",
            " * the worst case an finit_module() system call can end up allocating virtual",
            " * memory 3 times:",
            " *",
            " *   1) kernel_read_file_from_fd() call uses vmalloc()",
            " *   2) optional module decompression uses vmap()",
            " *   3) layout_and allocate() can use vzalloc() or an arch specific variation of",
            " *      vmalloc to deal with ELF sections requiring special permissions",
            " *",
            " * In practice on a typical boot today most finit_module() calls fail due to",
            " * the module with the same name already being loaded or about to be processed.",
            " * All virtual memory allocated to these failed modules will be freed with",
            " * no functional use.",
            " *",
            " * To help with this the dup_failed_modules allows us to track modules which",
            " * failed to load due to the fact that a module was already loaded or being",
            " * processed.  There are only two points at which we can fail such calls,",
            " * we list them below along with the number of virtual memory allocation",
            " * calls:",
            " *",
            " *   a) FAIL_DUP_MOD_BECOMING: at the end of early_mod_check() before",
            " *\tlayout_and_allocate().",
            " *\t- with module decompression: 2 virtual memory allocation calls",
            " *\t- without module decompression: 1 virtual memory allocation calls",
            " *   b) FAIL_DUP_MOD_LOAD: after layout_and_allocate() on add_unformed_module()",
            " *   \t- with module decompression 3 virtual memory allocation calls",
            " *   \t- without module decompression 2 virtual memory allocation calls",
            " *",
            " * We should strive to get this list to be as small as possible. If this list",
            " * is not empty it is a reflection of possible work or optimizations possible",
            " * either in-kernel or in userspace.",
            " */",
            "static LIST_HEAD(dup_failed_modules);",
            "",
            "/**",
            " * DOC: module statistics debugfs counters",
            " *",
            " * The total amount of wasted virtual memory allocation space during module",
            " * loading can be computed by adding the total from the summation:",
            " *",
            " *   * @invalid_kread_bytes +",
            " *     @invalid_decompress_bytes +",
            " *     @invalid_becoming_bytes +",
            " *     @invalid_mod_bytes",
            " *",
            " * The following debugfs counters are available to inspect module loading",
            " * failures:",
            " *",
            " *   * total_mod_size: total bytes ever used by all modules we've dealt with on",
            " *     this system",
            " *   * total_text_size: total bytes of the .text and .init.text ELF section",
            " *     sizes we've dealt with on this system",
            " *   * invalid_kread_bytes: bytes allocated and then freed on failures which",
            " *     happen due to the initial kernel_read_file_from_fd(). kernel_read_file_from_fd()",
            " *     uses vmalloc(). These should typically not happen unless your system is",
            " *     under memory pressure.",
            " *   * invalid_decompress_bytes: number of bytes allocated and freed due to",
            " *     memory allocations in the module decompression path that use vmap().",
            " *     These typically should not happen unless your system is under memory",
            " *     pressure.",
            " *   * invalid_becoming_bytes: total number of bytes allocated and freed used",
            " *     used to read the kernel module userspace wants us to read before we",
            " *     promote it to be processed to be added to our @modules linked list. These",
            " *     failures can happen if we had a check in between a successful kernel_read_file_from_fd()",
            " *     call and right before we allocate the our private memory for the module",
            " *     which would be kept if the module is successfully loaded. The most common",
            " *     reason for this failure is when userspace is racing to load a module",
            " *     which it does not yet see loaded. The first module to succeed in",
            " *     add_unformed_module() will add a module to our &modules list and",
            " *     subsequent loads of modules with the same name will error out at the",
            " *     end of early_mod_check(). The check for module_patient_check_exists()",
            " *     at the end of early_mod_check() prevents duplicate allocations",
            " *     on layout_and_allocate() for modules already being processed. These",
            " *     duplicate failed modules are non-fatal, however they typically are",
            " *     indicative of userspace not seeing a module in userspace loaded yet and",
            " *     unnecessarily trying to load a module before the kernel even has a chance",
            " *     to begin to process prior requests. Although duplicate failures can be",
            " *     non-fatal, we should try to reduce vmalloc() pressure proactively, so",
            " *     ideally after boot this will be close to as 0 as possible.  If module",
            " *     decompression was used we also add to this counter the cost of the",
            " *     initial kernel_read_file_from_fd() of the compressed module. If module",
            " *     decompression was not used the value represents the total allocated and",
            " *     freed bytes in kernel_read_file_from_fd() calls for these type of",
            " *     failures. These failures can occur because:",
            " *",
            " *    * module_sig_check() - module signature checks",
            " *    * elf_validity_cache_copy() - some ELF validation issue",
            " *    * early_mod_check():",
            " *",
            " *      * blacklisting",
            " *      * failed to rewrite section headers",
            " *      * version magic",
            " *      * live patch requirements didn't check out",
            " *      * the module was detected as being already present",
            " *",
            " *   * invalid_mod_bytes: these are the total number of bytes allocated and",
            " *     freed due to failures after we did all the sanity checks of the module",
            " *     which userspace passed to us and after our first check that the module",
            " *     is unique.  A module can still fail to load if we detect the module is",
            " *     loaded after we allocate space for it with layout_and_allocate(), we do",
            " *     this check right before processing the module as live and run its",
            " *     initialization routines. Note that you have a failure of this type it",
            " *     also means the respective kernel_read_file_from_fd() memory space was",
            " *     also freed and not used, and so we increment this counter with twice",
            " *     the size of the module. Additionally if you used module decompression",
            " *     the size of the compressed module is also added to this counter.",
            " *",
            " *  * modcount: how many modules we've loaded in our kernel life time",
            " *  * failed_kreads: how many modules failed due to failed kernel_read_file_from_fd()",
            " *  * failed_decompress: how many failed module decompression attempts we've had.",
            " *    These really should not happen unless your compression / decompression",
            " *    might be broken.",
            " *  * failed_becoming: how many modules failed after we kernel_read_file_from_fd()",
            " *    it and before we allocate memory for it with layout_and_allocate(). This",
            " *    counter is never incremented if you manage to validate the module and",
            " *    call layout_and_allocate() for it.",
            " *  * failed_load_modules: how many modules failed once we've allocated our",
            " *    private space for our module using layout_and_allocate(). These failures",
            " *    should hopefully mostly be dealt with already. Races in theory could",
            " *    still exist here, but it would just mean the kernel had started processing",
            " *    two threads concurrently up to early_mod_check() and one thread won.",
            " *    These failures are good signs the kernel or userspace is doing something",
            " *    seriously stupid or that could be improved. We should strive to fix these,",
            " *    but it is perhaps not easy to fix them. A recent example are the modules",
            " *    requests incurred for frequency modules, a separate module request was",
            " *    being issued for each CPU on a system.",
            " */",
            "",
            "atomic_long_t total_mod_size;",
            "atomic_long_t total_text_size;",
            "atomic_long_t invalid_kread_bytes;",
            "atomic_long_t invalid_decompress_bytes;",
            "static atomic_long_t invalid_becoming_bytes;",
            "static atomic_long_t invalid_mod_bytes;",
            "atomic_t modcount;",
            "atomic_t failed_kreads;",
            "atomic_t failed_decompress;",
            "static atomic_t failed_becoming;",
            "static atomic_t failed_load_modules;",
            "",
            "static const char *mod_fail_to_str(struct mod_fail_load *mod_fail)",
            "{",
            "\tif (test_bit(FAIL_DUP_MOD_BECOMING, &mod_fail->dup_fail_mask) &&",
            "\t    test_bit(FAIL_DUP_MOD_LOAD, &mod_fail->dup_fail_mask))",
            "\t\treturn \"Becoming & Load\";",
            "\tif (test_bit(FAIL_DUP_MOD_BECOMING, &mod_fail->dup_fail_mask))",
            "\t\treturn \"Becoming\";",
            "\tif (test_bit(FAIL_DUP_MOD_LOAD, &mod_fail->dup_fail_mask))",
            "\t\treturn \"Load\";",
            "\treturn \"Bug-on-stats\";",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义模块调试统计相关的原子计数器和链表结构，用于追踪模块加载失败导致的虚拟内存浪费情况，包括不同阶段的内存分配失败统计及重复模块列表管理",
          "similarity": 0.537948489189148
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/module/stats.c",
          "start_line": 411,
          "end_line": 429,
          "content": [
            "static int __init module_stats_init(void)",
            "{",
            "\tmod_debug_add_ulong(total_mod_size);",
            "\tmod_debug_add_ulong(total_text_size);",
            "\tmod_debug_add_ulong(invalid_kread_bytes);",
            "\tmod_debug_add_ulong(invalid_decompress_bytes);",
            "\tmod_debug_add_ulong(invalid_becoming_bytes);",
            "\tmod_debug_add_ulong(invalid_mod_bytes);",
            "",
            "\tmod_debug_add_atomic(modcount);",
            "\tmod_debug_add_atomic(failed_kreads);",
            "\tmod_debug_add_atomic(failed_decompress);",
            "\tmod_debug_add_atomic(failed_becoming);",
            "\tmod_debug_add_atomic(failed_load_modules);",
            "",
            "\tdebugfs_create_file(\"stats\", 0400, mod_debugfs_root, mod_debugfs_root, &fops_mod_stats);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "module_stats_init",
          "description": "初始化模块统计信息到debugfs系统，注册统计文件节点以支持通过/proc/self/debugfs接口访问模块加载统计数据",
          "similarity": 0.47435271739959717
        }
      ]
    },
    {
      "source_file": "kernel/dma/map_benchmark.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:13:45\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `dma\\map_benchmark.c`\n\n---\n\n# `dma/map_benchmark.c` 技术文档\n\n## 1. 文件概述\n\n`dma/map_benchmark.c` 是 Linux 内核中用于对 DMA（Direct Memory Access）映射和解映射操作进行性能基准测试的模块。该模块通过用户空间 ioctl 接口接收测试参数，创建多个内核线程并发执行 `dma_map_single()` 和 `dma_unmap_single()` 操作，统计其平均延迟和标准差，用于评估不同硬件平台或驱动实现下 DMA 映射的性能开销。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct map_benchmark_data`**  \n  封装测试上下文，包含：\n  - `bparam`：用户传入的测试参数（线程数、测试时长、DMA 方向、粒度等）\n  - `dev`：关联的设备结构体，用于 DMA 操作\n  - `debugfs`：用于调试的 debugfs 条目\n  - `dir`：转换后的 DMA 数据方向（`DMA_BIDIRECTIONAL` 等）\n  - 多个 `atomic64_t` 字段用于线程安全地累积映射/解映射耗时及其平方值，以及循环次数\n\n### 主要函数\n\n- **`map_benchmark_thread(void *data)`**  \n  内核线程主函数，循环执行以下操作：\n  - 分配指定大小的内存缓冲区（按页对齐）\n  - 若非 `DMA_FROM_DEVICE`，预填充缓冲区以模拟缓存污染\n  - 调用 `dma_map_single()` 并记录耗时\n  - 模拟 DMA 传输延迟（`ndelay`）\n  - 调用 `dma_unmap_single()` 并记录耗时\n  - 累加耗时（以 100 纳秒为单位）及其平方值，用于后续统计\n  - 定期调用 `cond_resched()` 避免阻塞调度\n\n- **`do_map_benchmark(struct map_benchmark_data *map)`**  \n  启动并管理多个测试线程：\n  - 根据参数创建指定数量的内核线程（可绑定到指定 NUMA 节点）\n  - 重置统计计数器\n  - 启动所有线程并休眠指定秒数\n  - 停止所有线程并收集结果\n  - 计算平均延迟和标准差（基于方差公式）\n\n- **`map_benchmark_ioctl(struct file *file, unsigned int cmd, unsigned long arg)`**  \n  用户空间 ioctl 接口处理函数：\n  - 验证输入参数合法性（线程数、时长、NUMA 节点、粒度等）\n  - 转换 DMA 方向枚举值\n  - 临时设置设备的 `dma_mask`（测试完成后恢复原值）\n  - 调用 `do_map_benchmark()` 执行测试\n  - 将结果拷贝回用户空间\n\n- **`__map_benchmark_probe(struct device *dev)`**  \n  设备探测函数（代码片段未完整），负责初始化 `map_benchmark_data` 结构并关联设备。\n\n## 3. 关键实现\n\n- **高精度时间测量**  \n  使用 `ktime_get()` 获取纳秒级时间戳，计算 `dma_map_single()` 和 `dma_unmap_single()` 的实际耗时。\n\n- **统计方法**  \n  为避免浮点运算，所有时间以 **100 纳秒** 为单位存储。通过累加时间和时间平方值，在测试结束后计算：\n  - 平均值：`sum / loops`\n  - 方差：`E[X²] - (E[X])²`\n  - 标准差：使用 `int_sqrt64()` 计算整数平方根\n\n- **缓存行为模拟**  \n  对于 `DMA_BIDIRECTIONAL` 或 `DMA_TO_DEVICE`，在映射前填充缓冲区（`memset(buf, 0x66, size)`），以触发缓存写回，更真实地反映非一致性设备的开销。\n\n- **DMA 掩码隔离**  \n  测试期间临时修改设备的 `dma_mask`，测试结束后恢复原始值，避免影响设备正常驱动行为。\n\n- **调度友好性**  \n  在密集循环中调用 `cond_resched()`，防止在非抢占内核中因线程数 ≥ CPU 数而导致系统挂死。\n\n- **NUMA 感知**  \n  支持将测试线程绑定到指定 NUMA 节点，用于评估 NUMA 架构下的 DMA 性能差异。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/dma-mapping.h>`：提供 `dma_map_single`/`dma_unmap_single` 等核心 DMA API\n  - `<linux/debugfs.h>`：用于创建调试接口（虽未在片段中完整体现）\n  - `<linux/kthread.h>`：内核线程管理\n  - `<linux/math64.h>`：64 位除法和平方根计算\n  - `<linux/map_benchmark.h>`：定义用户接口结构体 `map_benchmark` 和 ioctl 命令（如 `DMA_MAP_BENCHMARK`）\n  - 其他基础内核头文件（`slab.h`, `device.h`, `timekeeping.h` 等）\n\n- **内核子系统**：\n  - **DMA 子系统**：依赖底层架构（如 ARM64、x86）或总线（PCI、平台设备）提供的 DMA 映射实现\n  - **调度子系统**：依赖 `kthread` 和 `cond_resched()` 机制\n  - **内存管理**：使用 `alloc_pages_exact()` 分配连续物理内存\n\n## 5. 使用场景\n\n- **驱动开发与调优**：评估不同 DMA 映射策略（如一致性 vs 非一致性）的性能开销。\n- **平台性能分析**：比较不同 SoC 或服务器平台的 IOMMU 或 DMA 引擎效率。\n- **内核子系统验证**：测试 DMA 子系统在高并发场景下的稳定性与延迟表现。\n- **NUMA 性能研究**：分析跨 NUMA 节点 DMA 操作的额外延迟。\n- **回归测试**：在内核版本迭代中监控 DMA 映射性能是否退化。\n\n该模块通常通过用户空间工具（如专用 benchmark 程序）打开 debugfs 或字符设备节点，传入测试参数后触发 ioctl 执行基准测试，并读取返回的统计结果。",
      "similarity": 0.5555328130722046,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/dma/map_benchmark.c",
          "start_line": 331,
          "end_line": 360,
          "content": [
            "static int map_benchmark_platform_probe(struct platform_device *pdev)",
            "{",
            "\treturn __map_benchmark_probe(&pdev->dev);",
            "}",
            "static int",
            "map_benchmark_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
            "{",
            "\treturn __map_benchmark_probe(&pdev->dev);",
            "}",
            "static int __init map_benchmark_init(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = pci_register_driver(&map_benchmark_pci_driver);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = platform_driver_register(&map_benchmark_platform_driver);",
            "\tif (ret) {",
            "\t\tpci_unregister_driver(&map_benchmark_pci_driver);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void __exit map_benchmark_cleanup(void)",
            "{",
            "\tplatform_driver_unregister(&map_benchmark_platform_driver);",
            "\tpci_unregister_driver(&map_benchmark_pci_driver);",
            "}"
          ],
          "function_name": "map_benchmark_platform_probe, map_benchmark_pci_probe, map_benchmark_init, map_benchmark_cleanup",
          "description": "map_benchmark_platform_probe和map_benchmark_pci_probe作为平台及PCI设备的探针函数，map_benchmark_init注册驱动程序，map_benchmark_cleanup卸载驱动程序并释放资源",
          "similarity": 0.469564825296402
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/dma/map_benchmark.c",
          "start_line": 34,
          "end_line": 196,
          "content": [
            "static int map_benchmark_thread(void *data)",
            "{",
            "\tvoid *buf;",
            "\tdma_addr_t dma_addr;",
            "\tstruct map_benchmark_data *map = data;",
            "\tint npages = map->bparam.granule;",
            "\tu64 size = npages * PAGE_SIZE;",
            "\tint ret = 0;",
            "",
            "\tbuf = alloc_pages_exact(size, GFP_KERNEL);",
            "\tif (!buf)",
            "\t\treturn -ENOMEM;",
            "",
            "\twhile (!kthread_should_stop())  {",
            "\t\tu64 map_100ns, unmap_100ns, map_sq, unmap_sq;",
            "\t\tktime_t map_stime, map_etime, unmap_stime, unmap_etime;",
            "\t\tktime_t map_delta, unmap_delta;",
            "",
            "\t\t/*",
            "\t\t * for a non-coherent device, if we don't stain them in the",
            "\t\t * cache, this will give an underestimate of the real-world",
            "\t\t * overhead of BIDIRECTIONAL or TO_DEVICE mappings;",
            "\t\t * 66 means evertything goes well! 66 is lucky.",
            "\t\t */",
            "\t\tif (map->dir != DMA_FROM_DEVICE)",
            "\t\t\tmemset(buf, 0x66, size);",
            "",
            "\t\tmap_stime = ktime_get();",
            "\t\tdma_addr = dma_map_single(map->dev, buf, size, map->dir);",
            "\t\tif (unlikely(dma_mapping_error(map->dev, dma_addr))) {",
            "\t\t\tpr_err(\"dma_map_single failed on %s\\n\",",
            "\t\t\t\tdev_name(map->dev));",
            "\t\t\tret = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tmap_etime = ktime_get();",
            "\t\tmap_delta = ktime_sub(map_etime, map_stime);",
            "",
            "\t\t/* Pretend DMA is transmitting */",
            "\t\tndelay(map->bparam.dma_trans_ns);",
            "",
            "\t\tunmap_stime = ktime_get();",
            "\t\tdma_unmap_single(map->dev, dma_addr, size, map->dir);",
            "\t\tunmap_etime = ktime_get();",
            "\t\tunmap_delta = ktime_sub(unmap_etime, unmap_stime);",
            "",
            "\t\t/* calculate sum and sum of squares */",
            "",
            "\t\tmap_100ns = div64_ul(map_delta,  100);",
            "\t\tunmap_100ns = div64_ul(unmap_delta, 100);",
            "\t\tmap_sq = map_100ns * map_100ns;",
            "\t\tunmap_sq = unmap_100ns * unmap_100ns;",
            "",
            "\t\tatomic64_add(map_100ns, &map->sum_map_100ns);",
            "\t\tatomic64_add(unmap_100ns, &map->sum_unmap_100ns);",
            "\t\tatomic64_add(map_sq, &map->sum_sq_map);",
            "\t\tatomic64_add(unmap_sq, &map->sum_sq_unmap);",
            "\t\tatomic64_inc(&map->loops);",
            "",
            "\t\t/*",
            "\t\t * We may test for a long time so periodically check whether",
            "\t\t * we need to schedule to avoid starving the others. Otherwise",
            "\t\t * we may hangup the kernel in a non-preemptible kernel when",
            "\t\t * the test kthreads number >= CPU number, the test kthreads",
            "\t\t * will run endless on every CPU since the thread resposible",
            "\t\t * for notifying the kthread stop (in do_map_benchmark())",
            "\t\t * could not be scheduled.",
            "\t\t *",
            "\t\t * Note this may degrade the test concurrency since the test",
            "\t\t * threads may need to share the CPU time with other load",
            "\t\t * in the system. So it's recommended to run this benchmark",
            "\t\t * on an idle system.",
            "\t\t */",
            "\t\tcond_resched();",
            "\t}",
            "",
            "out:",
            "\tfree_pages_exact(buf, size);",
            "\treturn ret;",
            "}",
            "static int do_map_benchmark(struct map_benchmark_data *map)",
            "{",
            "\tstruct task_struct **tsk;",
            "\tint threads = map->bparam.threads;",
            "\tint node = map->bparam.node;",
            "\tu64 loops;",
            "\tint ret = 0;",
            "\tint i;",
            "",
            "\ttsk = kmalloc_array(threads, sizeof(*tsk), GFP_KERNEL);",
            "\tif (!tsk)",
            "\t\treturn -ENOMEM;",
            "",
            "\tget_device(map->dev);",
            "",
            "\tfor (i = 0; i < threads; i++) {",
            "\t\ttsk[i] = kthread_create_on_node(map_benchmark_thread, map,",
            "\t\t\t\tmap->bparam.node, \"dma-map-benchmark/%d\", i);",
            "\t\tif (IS_ERR(tsk[i])) {",
            "\t\t\tpr_err(\"create dma_map thread failed\\n\");",
            "\t\t\tret = PTR_ERR(tsk[i]);",
            "\t\t\twhile (--i >= 0)",
            "\t\t\t\tkthread_stop(tsk[i]);",
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tif (node != NUMA_NO_NODE)",
            "\t\t\tkthread_bind_mask(tsk[i], cpumask_of_node(node));",
            "\t}",
            "",
            "\t/* clear the old value in the previous benchmark */",
            "\tatomic64_set(&map->sum_map_100ns, 0);",
            "\tatomic64_set(&map->sum_unmap_100ns, 0);",
            "\tatomic64_set(&map->sum_sq_map, 0);",
            "\tatomic64_set(&map->sum_sq_unmap, 0);",
            "\tatomic64_set(&map->loops, 0);",
            "",
            "\tfor (i = 0; i < threads; i++) {",
            "\t\tget_task_struct(tsk[i]);",
            "\t\twake_up_process(tsk[i]);",
            "\t}",
            "",
            "\tmsleep_interruptible(map->bparam.seconds * 1000);",
            "",
            "\t/* wait for the completion of all started benchmark threads */",
            "\tfor (i = 0; i < threads; i++) {",
            "\t\tint kthread_ret = kthread_stop_put(tsk[i]);",
            "",
            "\t\tif (kthread_ret)",
            "\t\t\tret = kthread_ret;",
            "\t}",
            "",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\tloops = atomic64_read(&map->loops);",
            "\tif (likely(loops > 0)) {",
            "\t\tu64 map_variance, unmap_variance;",
            "\t\tu64 sum_map = atomic64_read(&map->sum_map_100ns);",
            "\t\tu64 sum_unmap = atomic64_read(&map->sum_unmap_100ns);",
            "\t\tu64 sum_sq_map = atomic64_read(&map->sum_sq_map);",
            "\t\tu64 sum_sq_unmap = atomic64_read(&map->sum_sq_unmap);",
            "",
            "\t\t/* average latency */",
            "\t\tmap->bparam.avg_map_100ns = div64_u64(sum_map, loops);",
            "\t\tmap->bparam.avg_unmap_100ns = div64_u64(sum_unmap, loops);",
            "",
            "\t\t/* standard deviation of latency */",
            "\t\tmap_variance = div64_u64(sum_sq_map, loops) -",
            "\t\t\t\tmap->bparam.avg_map_100ns *",
            "\t\t\t\tmap->bparam.avg_map_100ns;",
            "\t\tunmap_variance = div64_u64(sum_sq_unmap, loops) -",
            "\t\t\t\tmap->bparam.avg_unmap_100ns *",
            "\t\t\t\tmap->bparam.avg_unmap_100ns;",
            "\t\tmap->bparam.map_stddev = int_sqrt64(map_variance);",
            "\t\tmap->bparam.unmap_stddev = int_sqrt64(unmap_variance);",
            "\t}",
            "",
            "out:",
            "\tput_device(map->dev);",
            "\tkfree(tsk);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "map_benchmark_thread, do_map_benchmark",
          "description": "map_benchmark_thread执行DMA映射/解映射操作并记录时间戳，do_map_benchmark创建多线程进行基准测试，计算平均延迟和标准差，支持NUMA节点绑定和超时中断",
          "similarity": 0.46757733821868896
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/dma/map_benchmark.c",
          "start_line": 199,
          "end_line": 322,
          "content": [
            "static long map_benchmark_ioctl(struct file *file, unsigned int cmd,",
            "\t\tunsigned long arg)",
            "{",
            "\tstruct map_benchmark_data *map = file->private_data;",
            "\tvoid __user *argp = (void __user *)arg;",
            "\tu64 old_dma_mask;",
            "\tint ret;",
            "",
            "\tif (copy_from_user(&map->bparam, argp, sizeof(map->bparam)))",
            "\t\treturn -EFAULT;",
            "",
            "\tswitch (cmd) {",
            "\tcase DMA_MAP_BENCHMARK:",
            "\t\tif (map->bparam.threads == 0 ||",
            "\t\t    map->bparam.threads > DMA_MAP_MAX_THREADS) {",
            "\t\t\tpr_err(\"invalid thread number\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (map->bparam.seconds == 0 ||",
            "\t\t    map->bparam.seconds > DMA_MAP_MAX_SECONDS) {",
            "\t\t\tpr_err(\"invalid duration seconds\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (map->bparam.dma_trans_ns > DMA_MAP_MAX_TRANS_DELAY) {",
            "\t\t\tpr_err(\"invalid transmission delay\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (map->bparam.node != NUMA_NO_NODE &&",
            "\t\t    (map->bparam.node < 0 || map->bparam.node >= MAX_NUMNODES ||",
            "\t\t     !node_possible(map->bparam.node))) {",
            "\t\t\tpr_err(\"invalid numa node\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (map->bparam.granule < 1 || map->bparam.granule > 1024) {",
            "\t\t\tpr_err(\"invalid granule size\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tswitch (map->bparam.dma_dir) {",
            "\t\tcase DMA_MAP_BIDIRECTIONAL:",
            "\t\t\tmap->dir = DMA_BIDIRECTIONAL;",
            "\t\t\tbreak;",
            "\t\tcase DMA_MAP_FROM_DEVICE:",
            "\t\t\tmap->dir = DMA_FROM_DEVICE;",
            "\t\t\tbreak;",
            "\t\tcase DMA_MAP_TO_DEVICE:",
            "\t\t\tmap->dir = DMA_TO_DEVICE;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tpr_err(\"invalid DMA direction\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\told_dma_mask = dma_get_mask(map->dev);",
            "",
            "\t\tret = dma_set_mask(map->dev,",
            "\t\t\t\t   DMA_BIT_MASK(map->bparam.dma_bits));",
            "\t\tif (ret) {",
            "\t\t\tpr_err(\"failed to set dma_mask on device %s\\n\",",
            "\t\t\t\tdev_name(map->dev));",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tret = do_map_benchmark(map);",
            "",
            "\t\t/*",
            "\t\t * restore the original dma_mask as many devices' dma_mask are",
            "\t\t * set by architectures, acpi, busses. When we bind them back",
            "\t\t * to their original drivers, those drivers shouldn't see",
            "\t\t * dma_mask changed by benchmark",
            "\t\t */",
            "\t\tdma_set_mask(map->dev, old_dma_mask);",
            "",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (copy_to_user(argp, &map->bparam, sizeof(map->bparam)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn ret;",
            "}",
            "static void map_benchmark_remove_debugfs(void *data)",
            "{",
            "\tstruct map_benchmark_data *map = (struct map_benchmark_data *)data;",
            "",
            "\tdebugfs_remove(map->debugfs);",
            "}",
            "static int __map_benchmark_probe(struct device *dev)",
            "{",
            "\tstruct dentry *entry;",
            "\tstruct map_benchmark_data *map;",
            "\tint ret;",
            "",
            "\tmap = devm_kzalloc(dev, sizeof(*map), GFP_KERNEL);",
            "\tif (!map)",
            "\t\treturn -ENOMEM;",
            "\tmap->dev = dev;",
            "",
            "\tret = devm_add_action(dev, map_benchmark_remove_debugfs, map);",
            "\tif (ret) {",
            "\t\tpr_err(\"Can't add debugfs remove action\\n\");",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/*",
            "\t * we only permit a device bound with this driver, 2nd probe",
            "\t * will fail",
            "\t */",
            "\tentry = debugfs_create_file(\"dma_map_benchmark\", 0600, NULL, map,",
            "\t\t\t&map_benchmark_fops);",
            "\tif (IS_ERR(entry))",
            "\t\treturn PTR_ERR(entry);",
            "\tmap->debugfs = entry;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "map_benchmark_ioctl, map_benchmark_remove_debugfs, __map_benchmark_probe",
          "description": "map_benchmark_ioctl通过ioctl接口配置并触发DMA基准测试，map_benchmark_remove_debugfs清理调试文件系统条目，__map_benchmark_probe初始化设备并注册调试文件",
          "similarity": 0.42165374755859375
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/dma/map_benchmark.c",
          "start_line": 1,
          "end_line": 33,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (C) 2020 HiSilicon Limited.",
            " */",
            "",
            "#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/device.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/map_benchmark.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/pci.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/slab.h>",
            "#include <linux/timekeeping.h>",
            "",
            "struct map_benchmark_data {",
            "\tstruct map_benchmark bparam;",
            "\tstruct device *dev;",
            "\tstruct dentry  *debugfs;",
            "\tenum dma_data_direction dir;",
            "\tatomic64_t sum_map_100ns;",
            "\tatomic64_t sum_unmap_100ns;",
            "\tatomic64_t sum_sq_map;",
            "\tatomic64_t sum_sq_unmap;",
            "\tatomic64_t loops;",
            "};",
            ""
          ],
          "function_name": null,
          "description": "定义DMA映射基准测试数据结构，包含基准参数、设备指针、调试文件系统入口、数据传输方向及统计原子变量，用于跟踪DMA映射/解映射性能指标",
          "similarity": 0.40336716175079346
        }
      ]
    },
    {
      "source_file": "kernel/module/main.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:04:44\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\main.c`\n\n---\n\n# `module/main.c` 技术文档\n\n## 1. 文件概述\n\n`module/main.c` 是 Linux 内核模块子系统的核心实现文件，负责模块的加载、卸载、符号解析、内存管理、状态跟踪以及模块间依赖关系的维护。该文件实现了内核模块机制的基础框架，包括模块列表管理、模块内存布局控制、符号查找、模块通知机制、模块引用计数等关键功能，是内核动态加载模块能力的核心支撑。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct mod_tree_root mod_tree`**：用于加速地址到模块映射的全局模块地址范围树，包含 `addr_min`/`addr_max`（及可选的 `data_addr_min`/`data_addr_max`）。\n- **`LIST_HEAD(modules)`**：全局模块链表，存储所有已加载模块。\n- **`DEFINE_MUTEX(module_mutex)`**：保护模块列表、模块使用关系及地址边界的关键互斥锁。\n- **`struct symsearch`**：用于描述符号搜索范围，包含符号起止位置、CRC 校验数组及许可证类型。\n- **`struct find_symbol_arg`**：符号查找的参数结构体，用于传递查找目标及接收结果（所有者、符号指针、CRC、许可证等）。\n\n### 主要函数与接口\n\n- **模块注册/注销通知**：\n  - `register_module_notifier()` / `unregister_module_notifier()`：注册/注销模块生命周期事件通知回调。\n- **模块引用管理**：\n  - `strong_try_module_get()`：强引用获取，拒绝处于 `COMING` 状态的模块。\n  - `__module_put_and_kthread_exit()`：专用于内核线程在退出前释放模块引用。\n- **模块内存边界管理**：\n  - `__mod_update_bounds()` / `mod_update_bounds()`：更新全局模块地址范围，用于加速 `__module_address()`。\n- **ELF 节区辅助函数**：\n  - `find_sec()` / `find_any_sec()`：根据名称查找 ELF 节区索引。\n  - `section_addr()` / `section_objs()`：获取节区地址及对象数量。\n- **符号查找**：\n  - `find_symbol()`：在内核及已加载模块中查找导出符号。\n  - `find_exported_symbol_in_section()`：在指定符号段中二分查找符号。\n- **模块状态与安全**：\n  - `add_taint_module()`：为模块添加污点标记（taint flag）。\n- **全局控制**：\n  - `modules_disabled`：通过 `nomodule` 内核参数控制是否禁用模块加载。\n\n### 全局变量与工作队列\n\n- **`init_free_wq`**：用于异步释放模块初始化段（`.init`）内存的工作队列。\n- **`init_free_list`**：待释放初始化内存的无锁链表。\n- **`module_wq`**：等待模块初始化完成的等待队列。\n\n## 3. 关键实现\n\n### 模块地址范围加速\n\n通过 `mod_tree` 全局结构维护所有模块（或核心数据）的最小/最大虚拟地址。`__module_address()` 可先检查目标地址是否落在 `[addr_min, addr_max]` 范围内，若不在则直接返回 `NULL`，避免遍历整个模块链表，显著提升性能。\n\n### 符号查找机制\n\n- 使用 `bsearch()` 在已排序的导出符号表中进行二分查找，时间复杂度为 O(log n)。\n- 支持符号命名空间（namespace）和 GPL 许可证检查：非 GPL 模块无法使用 `GPL_ONLY` 符号。\n- 通过 `symsearch` 数组统一管理内核及各模块的符号段，实现统一查找接口。\n\n### 模块内存管理\n\n- 模块内存按 `mod_mem_type`（如代码、只读数据、可写数据、初始化段等）分类管理。\n- 初始化段（`.init`）在模块初始化成功后通过工作队列异步释放，节省内存。\n- 支持 `CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC` 架构选项，将模块数据段单独纳入地址范围管理。\n\n### 模块状态与引用安全\n\n- `strong_try_module_get()` 确保不会对处于 `MODULE_STATE_COMING`（正在初始化）或 `MODULE_STATE_UNFORMED`（未形成）状态的模块增加引用，防止竞态。\n- `__module_put_and_kthread_exit()` 为内核线程提供安全退出路径，在释放模块引用后终止线程。\n\n### 模块通知机制\n\n基于 `blocking_notifier_chain` 实现模块生命周期事件（如加载、卸载、初始化完成等）的通知，允许其他子系统（如 livepatch、ftrace）监听并响应模块状态变化。\n\n### 构建标识与版本校验\n\n- 通过 `INCLUDE_VERMAGIC` 宏包含模块魔数（vermagic）信息，用于加载时内核版本兼容性检查。\n- 支持 `CONFIG_MODVERSIONS`，在符号查找时返回 CRC 校验值，确保符号 ABI 兼容性。\n\n## 4. 依赖关系\n\n- **架构相关**：\n  - 依赖 `asm/cacheflush.h`、`asm/mmu_context.h`、`asm/sections.h` 等架构头文件，处理指令缓存刷新、内存映射等。\n  - 使用 `CONFIG_HAVE_ARCH_PREL32_RELOCATIONS` 优化符号字符串存储。\n- **内核子系统**：\n  - **内存管理**：`vmalloc`、`slab` 用于模块内存分配。\n  - **安全机制**：`capability`、`audit`、`module_signature` 用于模块加载权限和签名验证。\n  - **调试与追踪**：`kallsyms`、`trace_events`、`ftrace`、`dynamic_debug`、`debugfs` 提供模块调试支持。\n  - **并发控制**：`RCU`、`mutex`、`percpu` 用于同步。\n  - **文件系统**：`fs.h`、`kernel_read_file.h` 用于从文件加载模块。\n- **内部依赖**：\n  - 依赖同目录下的 `internal.h`，包含模块子系统内部数据结构和函数声明。\n  - 使用 `uapi/linux/module.h` 定义用户空间接口常量。\n\n## 5. 使用场景\n\n- **动态加载内核模块**：通过 `init_module()` 或 `finit_module()` 系统调用加载 `.ko` 文件时，该文件中的函数负责解析 ELF、重定位、符号解析、执行初始化函数。\n- **模块卸载**：通过 `delete_module()` 系统调用卸载模块时，管理模块引用计数、执行清理函数、释放内存。\n- **内核符号解析**：当模块或内核其他部分调用 `symbol_get()` 或通过 `EXPORT_SYMBOL` 机制访问符号时，`find_symbol()` 被调用。\n- **运行时模块查询**：`/proc/modules`、`/sys/module/` 等接口依赖此文件维护的模块列表和状态信息。\n- **内核热补丁（Livepatch）**：依赖模块通知机制和符号查找功能实现函数替换。\n- **内核调试与性能分析**：ftrace、kprobes 等工具依赖模块地址范围和符号信息进行函数跟踪。",
      "similarity": 0.5523899793624878,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/module/main.c",
          "start_line": 460,
          "end_line": 567,
          "content": [
            "bool is_module_percpu_address(unsigned long addr)",
            "{",
            "\treturn __is_module_percpu_address(addr, NULL);",
            "}",
            "static int percpu_modalloc(struct module *mod, struct load_info *info)",
            "{",
            "\t/* UP modules shouldn't have this section: ENOMEM isn't quite right */",
            "\tif (info->sechdrs[info->index.pcpu].sh_size != 0)",
            "\t\treturn -ENOMEM;",
            "\treturn 0;",
            "}",
            "static inline void percpu_modfree(struct module *mod)",
            "{",
            "}",
            "static unsigned int find_pcpusec(struct load_info *info)",
            "{",
            "\treturn 0;",
            "}",
            "static inline void percpu_modcopy(struct module *mod,",
            "\t\t\t\t  const void *from, unsigned long size)",
            "{",
            "\t/* pcpusec should be 0, and size of that section should be 0. */",
            "\tBUG_ON(size != 0);",
            "}",
            "bool is_module_percpu_address(unsigned long addr)",
            "{",
            "\treturn false;",
            "}",
            "bool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)",
            "{",
            "\treturn false;",
            "}",
            "static int module_unload_init(struct module *mod)",
            "{",
            "\t/*",
            "\t * Initialize reference counter to MODULE_REF_BASE.",
            "\t * refcnt == 0 means module is going.",
            "\t */",
            "\tatomic_set(&mod->refcnt, MODULE_REF_BASE);",
            "",
            "\tINIT_LIST_HEAD(&mod->source_list);",
            "\tINIT_LIST_HEAD(&mod->target_list);",
            "",
            "\t/* Hold reference count during initialization. */",
            "\tatomic_inc(&mod->refcnt);",
            "",
            "\treturn 0;",
            "}",
            "static int already_uses(struct module *a, struct module *b)",
            "{",
            "\tstruct module_use *use;",
            "",
            "\tlist_for_each_entry(use, &b->source_list, source_list) {",
            "\t\tif (use->source == a)",
            "\t\t\treturn 1;",
            "\t}",
            "\tpr_debug(\"%s does not use %s!\\n\", a->name, b->name);",
            "\treturn 0;",
            "}",
            "static int add_module_usage(struct module *a, struct module *b)",
            "{",
            "\tstruct module_use *use;",
            "",
            "\tpr_debug(\"Allocating new usage for %s.\\n\", a->name);",
            "\tuse = kmalloc(sizeof(*use), GFP_ATOMIC);",
            "\tif (!use)",
            "\t\treturn -ENOMEM;",
            "",
            "\tuse->source = a;",
            "\tuse->target = b;",
            "\tlist_add(&use->source_list, &b->source_list);",
            "\tlist_add(&use->target_list, &a->target_list);",
            "\treturn 0;",
            "}",
            "static int ref_module(struct module *a, struct module *b)",
            "{",
            "\tint err;",
            "",
            "\tif (b == NULL || already_uses(a, b))",
            "\t\treturn 0;",
            "",
            "\t/* If module isn't available, we fail. */",
            "\terr = strong_try_module_get(b);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = add_module_usage(a, b);",
            "\tif (err) {",
            "\t\tmodule_put(b);",
            "\t\treturn err;",
            "\t}",
            "\treturn 0;",
            "}",
            "static void module_unload_free(struct module *mod)",
            "{",
            "\tstruct module_use *use, *tmp;",
            "",
            "\tmutex_lock(&module_mutex);",
            "\tlist_for_each_entry_safe(use, tmp, &mod->target_list, target_list) {",
            "\t\tstruct module *i = use->target;",
            "\t\tpr_debug(\"%s unusing %s\\n\", mod->name, i->name);",
            "\t\tmodule_put(i);",
            "\t\tlist_del(&use->source_list);",
            "\t\tlist_del(&use->target_list);",
            "\t\tkfree(use);",
            "\t}",
            "\tmutex_unlock(&module_mutex);",
            "}"
          ],
          "function_name": "is_module_percpu_address, percpu_modalloc, percpu_modfree, find_pcpusec, percpu_modcopy, is_module_percpu_address, __is_module_percpu_address, module_unload_init, already_uses, add_module_usage, ref_module, module_unload_free",
          "description": "包含模块卸载初始化逻辑，管理模块间依赖关系（通过module_use结构），实现模块引用计数调整及依赖链清理，在模块卸载时安全解除其他模块对其的依赖。",
          "similarity": 0.5532461404800415
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/main.c",
          "start_line": 96,
          "end_line": 202,
          "content": [
            "static void __mod_update_bounds(enum mod_mem_type type __maybe_unused, void *base,",
            "\t\t\t\tunsigned int size, struct mod_tree_root *tree)",
            "{",
            "\tunsigned long min = (unsigned long)base;",
            "\tunsigned long max = min + size;",
            "",
            "#ifdef CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC",
            "\tif (mod_mem_type_is_core_data(type)) {",
            "\t\tif (min < tree->data_addr_min)",
            "\t\t\ttree->data_addr_min = min;",
            "\t\tif (max > tree->data_addr_max)",
            "\t\t\ttree->data_addr_max = max;",
            "\t\treturn;",
            "\t}",
            "#endif",
            "\tif (min < tree->addr_min)",
            "\t\ttree->addr_min = min;",
            "\tif (max > tree->addr_max)",
            "\t\ttree->addr_max = max;",
            "}",
            "static void mod_update_bounds(struct module *mod)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tstruct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (mod_mem->size)",
            "\t\t\t__mod_update_bounds(type, mod_mem->base, mod_mem->size, &mod_tree);",
            "\t}",
            "}",
            "int register_module_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_register(&module_notify_list, nb);",
            "}",
            "int unregister_module_notifier(struct notifier_block *nb)",
            "{",
            "\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);",
            "}",
            "static inline int strong_try_module_get(struct module *mod)",
            "{",
            "\tBUG_ON(mod && mod->state == MODULE_STATE_UNFORMED);",
            "\tif (mod && mod->state == MODULE_STATE_COMING)",
            "\t\treturn -EBUSY;",
            "\tif (try_module_get(mod))",
            "\t\treturn 0;",
            "\telse",
            "\t\treturn -ENOENT;",
            "}",
            "static inline void add_taint_module(struct module *mod, unsigned flag,",
            "\t\t\t\t    enum lockdep_ok lockdep_ok)",
            "{",
            "\tadd_taint(flag, lockdep_ok);",
            "\tset_bit(flag, &mod->taints);",
            "}",
            "void __noreturn __module_put_and_kthread_exit(struct module *mod, long code)",
            "{",
            "\tmodule_put(mod);",
            "\tkthread_exit(code);",
            "}",
            "static unsigned int find_sec(const struct load_info *info, const char *name)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\t/* Alloc bit cleared means \"ignore it.\" */",
            "\t\tif ((shdr->sh_flags & SHF_ALLOC)",
            "\t\t    && strcmp(info->secstrings + shdr->sh_name, name) == 0)",
            "\t\t\treturn i;",
            "\t}",
            "\treturn 0;",
            "}",
            "static unsigned int find_any_sec(const struct load_info *info, const char *name)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\tif (strcmp(info->secstrings + shdr->sh_name, name) == 0)",
            "\t\t\treturn i;",
            "\t}",
            "\treturn 0;",
            "}",
            "int cmp_name(const void *name, const void *sym)",
            "{",
            "\treturn strcmp(name, kernel_symbol_name(sym));",
            "}",
            "static bool find_exported_symbol_in_section(const struct symsearch *syms,",
            "\t\t\t\t\t    struct module *owner,",
            "\t\t\t\t\t    struct find_symbol_arg *fsa)",
            "{",
            "\tstruct kernel_symbol *sym;",
            "",
            "\tif (!fsa->gplok && syms->license == GPL_ONLY)",
            "\t\treturn false;",
            "",
            "\tsym = bsearch(fsa->name, syms->start, syms->stop - syms->start,",
            "\t\t\tsizeof(struct kernel_symbol), cmp_name);",
            "\tif (!sym)",
            "\t\treturn false;",
            "",
            "\tfsa->owner = owner;",
            "\tfsa->crc = symversion(syms->crcs, sym - syms->start);",
            "\tfsa->sym = sym;",
            "\tfsa->license = syms->license;",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "__mod_update_bounds, mod_update_bounds, register_module_notifier, unregister_module_notifier, strong_try_module_get, add_taint_module, __module_put_and_kthread_exit, find_sec, find_any_sec, cmp_name, find_exported_symbol_in_section",
          "description": "实现模块内存边界更新逻辑、模块状态变更通知注册与注销接口，以及强引用获取检查函数，用于维护模块内存范围并控制模块生命周期事件。",
          "similarity": 0.5499426126480103
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/module/main.c",
          "start_line": 1071,
          "end_line": 1218,
          "content": [
            "static int verify_namespace_is_imported(const struct load_info *info,",
            "\t\t\t\t\tconst struct kernel_symbol *sym,",
            "\t\t\t\t\tstruct module *mod)",
            "{",
            "\tconst char *namespace;",
            "\tchar *imported_namespace;",
            "",
            "\tnamespace = kernel_symbol_namespace(sym);",
            "\tif (namespace && namespace[0]) {",
            "\t\tfor_each_modinfo_entry(imported_namespace, info, \"import_ns\") {",
            "\t\t\tif (strcmp(namespace, imported_namespace) == 0)",
            "\t\t\t\treturn 0;",
            "\t\t}",
            "#ifdef CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS",
            "\t\tpr_warn(",
            "#else",
            "\t\tpr_err(",
            "#endif",
            "\t\t\t\"%s: module uses symbol (%s) from namespace %s, but does not import it.\\n\",",
            "\t\t\tmod->name, kernel_symbol_name(sym), namespace);",
            "#ifndef CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS",
            "\t\treturn -EINVAL;",
            "#endif",
            "\t}",
            "\treturn 0;",
            "}",
            "static bool inherit_taint(struct module *mod, struct module *owner, const char *name)",
            "{",
            "\tif (!owner || !test_bit(TAINT_PROPRIETARY_MODULE, &owner->taints))",
            "\t\treturn true;",
            "",
            "\tif (mod->using_gplonly_symbols) {",
            "\t\tpr_err(\"%s: module using GPL-only symbols uses symbols %s from proprietary module %s.\\n\",",
            "\t\t\tmod->name, name, owner->name);",
            "\t\treturn false;",
            "\t}",
            "",
            "\tif (!test_bit(TAINT_PROPRIETARY_MODULE, &mod->taints)) {",
            "\t\tpr_warn(\"%s: module uses symbols %s from proprietary module %s, inheriting taint.\\n\",",
            "\t\t\tmod->name, name, owner->name);",
            "\t\tset_bit(TAINT_PROPRIETARY_MODULE, &mod->taints);",
            "\t}",
            "\treturn true;",
            "}",
            "void __weak module_memfree(void *module_region)",
            "{",
            "\t/*",
            "\t * This memory may be RO, and freeing RO memory in an interrupt is not",
            "\t * supported by vmalloc.",
            "\t */",
            "\tWARN_ON(in_interrupt());",
            "\tvfree(module_region);",
            "}",
            "void __weak module_arch_cleanup(struct module *mod)",
            "{",
            "}",
            "void __weak module_arch_freeing_init(struct module *mod)",
            "{",
            "}",
            "static bool mod_mem_use_vmalloc(enum mod_mem_type type)",
            "{",
            "\treturn IS_ENABLED(CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC) &&",
            "\t\tmod_mem_type_is_core_data(type);",
            "}",
            "static void module_memory_free(void *ptr, enum mod_mem_type type,",
            "\t\t\t       bool unload_codetags)",
            "{",
            "\tif (!unload_codetags && mod_mem_type_is_core_data(type))",
            "\t\treturn;",
            "",
            "\tif (mod_mem_use_vmalloc(type))",
            "\t\tvfree(ptr);",
            "\telse",
            "\t\tmodule_memfree(ptr);",
            "}",
            "static void free_mod_mem(struct module *mod, bool unload_codetags)",
            "{",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tstruct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (type == MOD_DATA)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Free lock-classes; relies on the preceding sync_rcu(). */",
            "\t\tlockdep_free_key_range(mod_mem->base, mod_mem->size);",
            "\t\tif (mod_mem->size)",
            "\t\t\tmodule_memory_free(mod_mem->base, type,",
            "\t\t\t\t\t   unload_codetags);",
            "\t}",
            "",
            "\t/* MOD_DATA hosts mod, so free it at last */",
            "\tlockdep_free_key_range(mod->mem[MOD_DATA].base, mod->mem[MOD_DATA].size);",
            "\tmodule_memory_free(mod->mem[MOD_DATA].base, MOD_DATA, unload_codetags);",
            "}",
            "static void free_module(struct module *mod)",
            "{",
            "\tbool unload_codetags;",
            "",
            "\ttrace_module_free(mod);",
            "",
            "\tunload_codetags = codetag_unload_module(mod);",
            "\tif (!unload_codetags)",
            "\t\tpr_warn(\"%s: memory allocation(s) from the module still alive, cannot unload cleanly\\n\",",
            "\t\t\tmod->name);",
            "",
            "\tmod_sysfs_teardown(mod);",
            "",
            "\t/*",
            "\t * We leave it in list to prevent duplicate loads, but make sure",
            "\t * that noone uses it while it's being deconstructed.",
            "\t */",
            "\tmutex_lock(&module_mutex);",
            "\tmod->state = MODULE_STATE_UNFORMED;",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\t/* Arch-specific cleanup. */",
            "\tmodule_arch_cleanup(mod);",
            "",
            "\t/* Module unload stuff */",
            "\tmodule_unload_free(mod);",
            "",
            "\t/* Free any allocated parameters. */",
            "\tdestroy_params(mod->kp, mod->num_kp);",
            "",
            "\tif (is_livepatch_module(mod))",
            "\t\tfree_module_elf(mod);",
            "",
            "\t/* Now we can delete it from the lists */",
            "\tmutex_lock(&module_mutex);",
            "\t/* Unlink carefully: kallsyms could be walking list. */",
            "\tlist_del_rcu(&mod->list);",
            "\tmod_tree_remove(mod);",
            "\t/* Remove this module from bug list, this uses list_del_rcu */",
            "\tmodule_bug_cleanup(mod);",
            "\t/* Wait for RCU-sched synchronizing before releasing mod->list and buglist. */",
            "\tsynchronize_rcu();",
            "\tif (try_add_tainted_module(mod))",
            "\t\tpr_err(\"%s: adding tainted module to the unloaded tainted modules list failed.\\n\",",
            "\t\t       mod->name);",
            "\tmutex_unlock(&module_mutex);",
            "",
            "\t/* This may be empty, but that's OK */",
            "\tmodule_arch_freeing_init(mod);",
            "\tkfree(mod->args);",
            "\tpercpu_modfree(mod);",
            "",
            "\tfree_mod_mem(mod, unload_codetags);",
            "}"
          ],
          "function_name": "verify_namespace_is_imported, inherit_taint, module_memfree, module_arch_cleanup, module_arch_freeing_init, mod_mem_use_vmalloc, module_memory_free, free_mod_mem, free_module",
          "description": "实现模块符号命名空间验证(verify_namespace_is_imported)、污点继承逻辑(herit_taint)、内存释放(module_memory_free/free_mod_mem)及架构特定清理(module_arch_cleanup/module_arch_freeing_init)，包含弱符号声明供架构扩展。",
          "similarity": 0.5433468818664551
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/module/main.c",
          "start_line": 1925,
          "end_line": 2029,
          "content": [
            "static int copy_chunked_from_user(void *dst, const void __user *usrc, unsigned long len)",
            "{",
            "\tdo {",
            "\t\tunsigned long n = min(len, COPY_CHUNK_SIZE);",
            "",
            "\t\tif (copy_from_user(dst, usrc, n) != 0)",
            "\t\t\treturn -EFAULT;",
            "\t\tcond_resched();",
            "\t\tdst += n;",
            "\t\tusrc += n;",
            "\t\tlen -= n;",
            "\t} while (len);",
            "\treturn 0;",
            "}",
            "static int check_modinfo_livepatch(struct module *mod, struct load_info *info)",
            "{",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (!get_modinfo(info, \"livepatch\")) {",
            "\t\tset_mod_klp_rel_state(mod, MODULE_KLP_REL_NONE);",
            "\t\treturn 0;",
            "\t}",
            "\tset_mod_klp_rel_state(mod, MODULE_KLP_REL_UNDO);",
            "#else /* !CONFIG_LIVEPATCH_WO_FTRACE */",
            "\tif (!get_modinfo(info, \"livepatch\"))",
            "\t\t/* Nothing more to do */",
            "\t\treturn 0;",
            "#endif /* CONFIG_LIVEPATCH_WO_FTRACE */",
            "",
            "\tif (set_livepatch_module(mod))",
            "\t\treturn 0;",
            "",
            "\tpr_err(\"%s: module is marked as livepatch module, but livepatch support is disabled\",",
            "\t       mod->name);",
            "\treturn -ENOEXEC;",
            "}",
            "static void check_modinfo_retpoline(struct module *mod, struct load_info *info)",
            "{",
            "\tif (retpoline_module_ok(get_modinfo(info, \"retpoline\")))",
            "\t\treturn;",
            "",
            "\tpr_warn(\"%s: loading module not compiled with retpoline compiler.\\n\",",
            "\t\tmod->name);",
            "}",
            "static int copy_module_from_user(const void __user *umod, unsigned long len,",
            "\t\t\t\t  struct load_info *info)",
            "{",
            "\tint err;",
            "",
            "\tinfo->len = len;",
            "\tif (info->len < sizeof(*(info->hdr)))",
            "\t\treturn -ENOEXEC;",
            "",
            "\terr = security_kernel_load_data(LOADING_MODULE, true);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\t/* Suck in entire file: we'll want most of it. */",
            "\tinfo->hdr = __vmalloc(info->len, GFP_KERNEL | __GFP_NOWARN);",
            "\tif (!info->hdr)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (copy_chunked_from_user(info->hdr, umod, info->len) != 0) {",
            "\t\terr = -EFAULT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\terr = security_kernel_post_load_data((char *)info->hdr, info->len,",
            "\t\t\t\t\t     LOADING_MODULE, \"init_module\");",
            "out:",
            "\tif (err)",
            "\t\tvfree(info->hdr);",
            "",
            "\treturn err;",
            "}",
            "static void free_copy(struct load_info *info, int flags)",
            "{",
            "\tif (flags & MODULE_INIT_COMPRESSED_FILE)",
            "\t\tmodule_decompress_cleanup(info);",
            "\telse",
            "\t\tvfree(info->hdr);",
            "}",
            "static int rewrite_section_headers(struct load_info *info, int flags)",
            "{",
            "\tunsigned int i;",
            "",
            "\t/* This should always be true, but let's be sure. */",
            "\tinfo->sechdrs[0].sh_addr = 0;",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "",
            "\t\t/*",
            "\t\t * Mark all sections sh_addr with their address in the",
            "\t\t * temporary image.",
            "\t\t */",
            "\t\tshdr->sh_addr = (size_t)info->hdr + shdr->sh_offset;",
            "",
            "\t}",
            "",
            "\t/* Track but don't keep modinfo and version sections. */",
            "\tinfo->sechdrs[info->index.vers].sh_flags &= ~(unsigned long)SHF_ALLOC;",
            "\tinfo->sechdrs[info->index.info].sh_flags &= ~(unsigned long)SHF_ALLOC;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "copy_chunked_from_user, check_modinfo_livepatch, check_modinfo_retpoline, copy_module_from_user, free_copy, rewrite_section_headers",
          "description": "实现分块从用户空间复制数据到内核缓冲区，检查模块livepatch属性，校验retpoline标志，复制模块元信息到内核，释放动态分配的模块数据，重写ELF节头地址以匹配实际内存布局",
          "similarity": 0.5413110852241516
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/module/main.c",
          "start_line": 2256,
          "end_line": 2359,
          "content": [
            "static int move_module(struct module *mod, struct load_info *info)",
            "{",
            "\tint i;",
            "\tvoid *ptr;",
            "\tenum mod_mem_type t = 0;",
            "\tint ret = -ENOMEM;",
            "",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tif (!mod->mem[type].size) {",
            "\t\t\tmod->mem[type].base = NULL;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tmod->mem[type].size = PAGE_ALIGN(mod->mem[type].size);",
            "\t\tptr = module_memory_alloc(mod->mem[type].size, type);",
            "\t\t/*",
            "                 * The pointer to these blocks of memory are stored on the module",
            "                 * structure and we keep that around so long as the module is",
            "                 * around. We only free that memory when we unload the module.",
            "                 * Just mark them as not being a leak then. The .init* ELF",
            "                 * sections *do* get freed after boot so we *could* treat them",
            "                 * slightly differently with kmemleak_ignore() and only grey",
            "                 * them out as they work as typical memory allocations which",
            "                 * *do* eventually get freed, but let's just keep things simple",
            "                 * and avoid *any* false positives.",
            "\t\t */",
            "\t\tkmemleak_not_leak(ptr);",
            "\t\tif (!ptr) {",
            "\t\t\tt = type;",
            "\t\t\tgoto out_enomem;",
            "\t\t}",
            "\t\tmemset(ptr, 0, mod->mem[type].size);",
            "\t\tmod->mem[type].base = ptr;",
            "\t}",
            "",
            "\t/* Transfer each section which specifies SHF_ALLOC */",
            "\tpr_debug(\"Final section addresses for %s:\\n\", mod->name);",
            "\tfor (i = 0; i < info->hdr->e_shnum; i++) {",
            "\t\tvoid *dest;",
            "\t\tElf_Shdr *shdr = &info->sechdrs[i];",
            "\t\tenum mod_mem_type type = shdr->sh_entsize >> SH_ENTSIZE_TYPE_SHIFT;",
            "",
            "\t\tif (!(shdr->sh_flags & SHF_ALLOC))",
            "\t\t\tcontinue;",
            "",
            "\t\tdest = mod->mem[type].base + (shdr->sh_entsize & SH_ENTSIZE_OFFSET_MASK);",
            "",
            "\t\tif (shdr->sh_type != SHT_NOBITS) {",
            "\t\t\t/*",
            "\t\t\t * Our ELF checker already validated this, but let's",
            "\t\t\t * be pedantic and make the goal clearer. We actually",
            "\t\t\t * end up copying over all modifications made to the",
            "\t\t\t * userspace copy of the entire struct module.",
            "\t\t\t */",
            "\t\t\tif (i == info->index.mod &&",
            "\t\t\t   (WARN_ON_ONCE(shdr->sh_size != sizeof(struct module)))) {",
            "\t\t\t\tret = -ENOEXEC;",
            "\t\t\t\tgoto out_enomem;",
            "\t\t\t}",
            "\t\t\tmemcpy(dest, (void *)shdr->sh_addr, shdr->sh_size);",
            "\t\t}",
            "\t\t/*",
            "\t\t * Update the userspace copy's ELF section address to point to",
            "\t\t * our newly allocated memory as a pure convenience so that",
            "\t\t * users of info can keep taking advantage and using the newly",
            "\t\t * minted official memory area.",
            "\t\t */",
            "\t\tshdr->sh_addr = (unsigned long)dest;",
            "\t\tpr_debug(\"\\t0x%lx 0x%.8lx %s\\n\", (long)shdr->sh_addr,",
            "\t\t\t (long)shdr->sh_size, info->secstrings + shdr->sh_name);",
            "\t}",
            "",
            "\treturn 0;",
            "out_enomem:",
            "\tfor (t--; t >= 0; t--)",
            "\t\tmodule_memory_free(mod->mem[t].base, t, true);",
            "\treturn ret;",
            "}",
            "static int check_export_symbol_versions(struct module *mod)",
            "{",
            "#ifdef CONFIG_MODVERSIONS",
            "\tif ((mod->num_syms && !mod->crcs) ||",
            "\t    (mod->num_gpl_syms && !mod->gpl_crcs)) {",
            "\t\treturn try_to_force_load(mod,",
            "\t\t\t\t\t \"no versions for exported symbols\");",
            "\t}",
            "#endif",
            "\treturn 0;",
            "}",
            "void flush_module_icache(const struct module *mod)",
            "{",
            "\t/*",
            "\t * Flush the instruction cache, since we've played with text.",
            "\t * Do it before processing of module parameters, so the module",
            "\t * can provide parameter accessor functions of its own.",
            "\t */",
            "\tfor_each_mod_mem_type(type) {",
            "\t\tconst struct module_memory *mod_mem = &mod->mem[type];",
            "",
            "\t\tif (mod_mem->size) {",
            "\t\t\tflush_icache_range((unsigned long)mod_mem->base,",
            "\t\t\t\t\t   (unsigned long)mod_mem->base + mod_mem->size);",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "move_module, check_export_symbol_versions, flush_module_icache",
          "description": "为模块各内存类型分配物理页框，将ELF节区内容拷贝至对应内存区域，检查导出符号版本一致性，刷新指令高速缓存以确保新代码可见",
          "similarity": 0.5374882221221924
        }
      ]
    }
  ]
}