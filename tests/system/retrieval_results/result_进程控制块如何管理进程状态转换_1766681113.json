{
  "query": "进程控制块如何管理进程状态转换",
  "timestamp": "2025-12-26 00:45:13",
  "retrieved_files": [
    {
      "source_file": "kernel/power/console.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:19:20\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `power\\console.c`\n\n---\n\n# power/console.c 技术文档\n\n## 1. 文件概述\n\n`power/console.c` 是 Linux 内核电源管理子系统中的一个组件，负责在系统挂起（suspend）和恢复（resume）过程中对控制台（console）进行保存与恢复操作。其主要目标是通过虚拟终端（VT）切换机制，确保在系统休眠期间控制台状态的正确性和可视性，同时支持部分图形或控制台驱动实现“无闪烁”（flicker-free）的挂起/恢复流程。\n\n该文件最初源自 `swsusp`（Software Suspend）项目，现用于协调多个控制台驱动对 VT 切换的需求，避免不必要的屏幕闪烁，并在必要时将内核日志重定向到专用的挂起控制台。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `pm_vt_switch_required(struct device *dev, bool required)`  \n  注册设备对 VT 切换的需求。若 `required` 为 `true`，表示该设备驱动在挂起/恢复时需要进行 VT 切换；若为 `false`，则表示支持无切换挂起。\n\n- `pm_vt_switch_unregister(struct device *dev)`  \n  注销设备的 VT 切换需求，将其从跟踪列表中移除。\n\n- `pm_prepare_console(void)`  \n  在系统挂起前准备控制台：若需要 VT 切换，则切换到专用的挂起控制台（`SUSPEND_CONSOLE`），并重定向内核消息输出。\n\n- `pm_restore_console(void)`  \n  在系统恢复后还原控制台：切换回原始前台控制台，并恢复内核消息的原始重定向目标。\n\n### 主要数据结构\n\n- `struct pm_vt_switch`  \n  表示一个设备对 VT 切换的需求：\n  ```c\n  struct pm_vt_switch {\n      struct list_head head;   // 链表节点\n      struct device *dev;      // 关联的设备\n      bool required;           // 是否需要 VT 切换\n  };\n  ```\n\n- 全局变量：\n  - `orig_fgconsole`：原始前台控制台编号。\n  - `orig_kmsg`：原始内核消息重定向目标控制台。\n  - `vt_switch_done`：标志位，表示是否已执行 VT 切换。\n  - `pm_vt_switch_list`：所有注册设备的 VT 切换需求链表。\n  - `vt_switch_mutex`：保护链表操作的互斥锁。\n\n## 3. 关键实现\n\n### VT 切换决策逻辑（`pm_vt_switch()`）\n\n系统是否执行 VT 切换由以下三个条件之一触发：\n1. **无任何驱动注册需求**：保留传统行为（默认切换）。\n2. **`console_suspend_enabled` 被禁用**（通过内核命令行参数 `no_console_suspend`）：需显示挂起/恢复期间的调试信息。\n3. **任一已注册驱动声明需要 VT 切换**（`required == true`）。\n\n只有当**所有已注册驱动都明确声明不需要 VT 切换**，且 `console_suspend_enabled` 为 `true` 时，才可跳过 VT 切换，实现无闪烁恢复。\n\n### 控制台保存与恢复流程\n\n- **挂起前（`pm_prepare_console`）**：\n  - 若需切换，调用 `vt_move_to_console(SUSPEND_CONSOLE, 1)` 切换到专用控制台（编号 `MAX_NR_CONSOLES-1`）。\n  - 使用 `vt_kmsg_redirect()` 将内核日志重定向至该控制台。\n  - 记录原始前台控制台编号和原始重定向目标。\n\n- **恢复后（`pm_restore_console`）**：\n  - 若曾执行切换，调用 `vt_move_to_console(orig_fgconsole, 0)` 切回原前台控制台。\n  - 恢复内核消息重定向至原始目标。\n  - 清除 `vt_switch_done` 标志。\n\n### 线程安全\n\n所有对 `pm_vt_switch_list` 的访问均受 `vt_switch_mutex` 互斥锁保护，确保在并发注册/注销场景下的数据一致性。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/console.h>`：控制台核心接口。\n  - `<linux/vt_kern.h>` 和 `<linux/vt.h>`：虚拟终端内核接口，提供 `vt_move_to_console()` 和 `vt_kmsg_redirect()`。\n  - `<linux/kbd_kern.h>`：键盘相关（虽未直接使用，但 VT 子系统依赖）。\n  - `\"power.h\"`：本地电源管理头文件（可能定义 `console_suspend_enabled` 等）。\n\n- **内核子系统依赖**：\n  - **VT 子系统**：提供虚拟终端管理和切换能力。\n  - **电源管理核心（PM Core）**：本文件被 PM Core 在挂起/恢复流程中调用。\n  - **控制台驱动**：如 `fbcon`、`vgacon` 等可通过 `pm_vt_switch_required()` 声明自身需求。\n\n- **导出符号**：\n  - `pm_vt_switch_required` 和 `pm_vt_switch_unregister` 通过 `EXPORT_SYMBOL` 导出，供其他内核模块（如显卡驱动）调用。\n\n## 5. 使用场景\n\n- **系统挂起/恢复流程**：  \n  在 `suspend` 阶段调用 `pm_prepare_console()`，在 `resume` 阶段调用 `pm_restore_console()`，确保控制台状态一致。\n\n- **图形驱动优化**：  \n  支持现代显示驱动（如 DRM/KMS 驱动）在挂起/恢复时自行管理显示状态，无需 VT 切换，从而避免屏幕闪烁，提升用户体验。\n\n- **调试支持**：  \n  当启用 `no_console_suspend` 内核参数时，强制进行 VT 切换并将内核日志输出到可见控制台，便于调试挂起/恢复问题。\n\n- **多控制台环境协调**：  \n  在存在多个控制台驱动（如文本控制台与帧缓冲控制台共存）时，统一协调 VT 切换策略，防止冲突。",
      "similarity": 0.6099897623062134,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/power/console.c",
          "start_line": 47,
          "end_line": 132,
          "content": [
            "void pm_vt_switch_required(struct device *dev, bool required)",
            "{",
            "\tstruct pm_vt_switch *entry, *tmp;",
            "",
            "\tmutex_lock(&vt_switch_mutex);",
            "\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {",
            "\t\tif (tmp->dev == dev) {",
            "\t\t\t/* already registered, update requirement */",
            "\t\t\ttmp->required = required;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);",
            "\tif (!entry)",
            "\t\tgoto out;",
            "",
            "\tentry->required = required;",
            "\tentry->dev = dev;",
            "",
            "\tlist_add(&entry->head, &pm_vt_switch_list);",
            "out:",
            "\tmutex_unlock(&vt_switch_mutex);",
            "}",
            "void pm_vt_switch_unregister(struct device *dev)",
            "{",
            "\tstruct pm_vt_switch *tmp;",
            "",
            "\tmutex_lock(&vt_switch_mutex);",
            "\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {",
            "\t\tif (tmp->dev == dev) {",
            "\t\t\tlist_del(&tmp->head);",
            "\t\t\tkfree(tmp);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&vt_switch_mutex);",
            "}",
            "static bool pm_vt_switch(void)",
            "{",
            "\tstruct pm_vt_switch *entry;",
            "\tbool ret = true;",
            "",
            "\tmutex_lock(&vt_switch_mutex);",
            "\tif (list_empty(&pm_vt_switch_list))",
            "\t\tgoto out;",
            "",
            "\tif (!console_suspend_enabled)",
            "\t\tgoto out;",
            "",
            "\tlist_for_each_entry(entry, &pm_vt_switch_list, head) {",
            "\t\tif (entry->required)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "\tret = false;",
            "out:",
            "\tmutex_unlock(&vt_switch_mutex);",
            "\treturn ret;",
            "}",
            "void pm_prepare_console(void)",
            "{",
            "\tif (!pm_vt_switch())",
            "\t\treturn;",
            "",
            "\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);",
            "\tif (orig_fgconsole < 0)",
            "\t\treturn;",
            "",
            "\tvt_switch_done = true;",
            "",
            "\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);",
            "\treturn;",
            "}",
            "void pm_restore_console(void)",
            "{",
            "\tif (!pm_vt_switch() && !vt_switch_done)",
            "\t\treturn;",
            "",
            "\tif (orig_fgconsole >= 0) {",
            "\t\tvt_move_to_console(orig_fgconsole, 0);",
            "\t\tvt_kmsg_redirect(orig_kmsg);",
            "\t}",
            "",
            "\tvt_switch_done = false;",
            "}"
          ],
          "function_name": "pm_vt_switch_required, pm_vt_switch_unregister, pm_vt_switch, pm_prepare_console, pm_restore_console",
          "description": "实现VT切换需求注册/注销操作，判断是否需执行VT切换的辅助函数，以及准备/恢复控制台状态的完整流程，包含控制台切换和kmsg重定向的原子操作",
          "similarity": 0.5971071124076843
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/power/console.c",
          "start_line": 1,
          "end_line": 46,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Functions for saving/restoring console.",
            " *",
            " * Originally from swsusp.",
            " */",
            "",
            "#include <linux/console.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include \"power.h\"",
            "",
            "#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)",
            "",
            "static int orig_fgconsole, orig_kmsg;",
            "static bool vt_switch_done;",
            "",
            "static DEFINE_MUTEX(vt_switch_mutex);",
            "",
            "struct pm_vt_switch {",
            "\tstruct list_head head;",
            "\tstruct device *dev;",
            "\tbool required;",
            "};",
            "",
            "static LIST_HEAD(pm_vt_switch_list);",
            "",
            "",
            "/**",
            " * pm_vt_switch_required - indicate VT switch at suspend requirements",
            " * @dev: device",
            " * @required: if true, caller needs VT switch at suspend/resume time",
            " *",
            " * The different console drivers may or may not require VT switches across",
            " * suspend/resume, depending on how they handle restoring video state and",
            " * what may be running.",
            " *",
            " * Drivers can indicate support for switchless suspend/resume, which can",
            " * save time and flicker, by using this routine and passing 'false' as",
            " * the argument.  If any loaded driver needs VT switching, or the",
            " * no_console_suspend argument has been passed on the command line, VT",
            " * switches will occur.",
            " */"
          ],
          "function_name": null,
          "description": "定义控制台保存/恢复相关全局变量及结构体，用于记录原始前台控制台和kmsg重定向信息，声明PM VT切换需求管理接口，包含VT切换所需锁和链表结构",
          "similarity": 0.5751417279243469
        }
      ]
    },
    {
      "source_file": "kernel/sched/stop_task.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:17:42\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\stop_task.c`\n\n---\n\n# `sched/stop_task.c` 技术文档\n\n## 1. 文件概述\n\n`sched/stop_task.c` 实现了 Linux 内核调度器中的 **stop 调度类（stop scheduling class）**。该调度类用于管理 per-CPU 的 **stop 任务（stop task）**，这些任务具有系统中最高的调度优先级，能够抢占所有其他任务，且自身不会被任何任务抢占。stop 任务主要用于需要在所有 CPU 上立即停止常规调度活动的场景，例如 CPU 热插拔、内核模块卸载或 `stop_machine()` 机制执行期间。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `select_task_rq_stop()`：在 SMP 系统中，确保 stop 任务始终运行在其初始 CPU 上，禁止迁移。\n- `balance_stop()`：在负载均衡时判断当前运行队列上是否有可运行的 stop 任务。\n- `wakeup_preempt_stop()`：空实现，因为 stop 任务不会被抢占。\n- `set_next_task_stop()`：设置下一个运行的 stop 任务，并记录其执行起始时间。\n- `pick_task_stop()`：从运行队列中选择 stop 任务（如果存在且可运行）。\n- `enqueue_task_stop()` / `dequeue_task_stop()`：将 stop 任务加入/移出运行队列，并更新运行任务计数。\n- `yield_task_stop()`：触发 `BUG()`，因为 stop 任务绝不应主动让出 CPU。\n- `put_prev_task_stop()`：在切换出 stop 任务时更新其运行统计（调用通用更新函数）。\n- `task_tick_stop()`：空实现，stop 任务不受调度 tick 影响。\n- `switched_to_stop()` / `prio_changed_stop()`：均触发 `BUG()`，因为任务不能动态切换到 stop 调度类，也无优先级概念。\n- `update_curr_stop()`：空实现，stop 任务不参与常规的运行时间更新逻辑。\n\n### 数据结构\n\n- `DEFINE_SCHED_CLASS(stop)`：定义并初始化名为 `stop` 的调度类实例，实现了 `struct sched_class` 接口的所有必要回调函数。\n\n## 3. 关键实现\n\n- **最高优先级保证**：stop 调度类在调度类层级中位于最顶端（高于 `rt`、`fair`、`idle`），确保其任务总是优先获得 CPU。\n- **禁止迁移**：在 `CONFIG_SMP` 下，`select_task_rq_stop()` 强制 stop 任务绑定到其创建时的 CPU，防止跨 CPU 迁移，保证操作的局部性和确定性。\n- **无抢占逻辑**：所有与抢占相关的函数（如 `wakeup_preempt_stop`）均为空或触发错误，因为 stop 任务运行期间系统处于“停止”状态，不应被中断。\n- **错误防护机制**：任何试图动态切换到 stop 调度类、修改其优先级或主动让出 CPU 的行为都会触发 `BUG()`，防止误用。\n- **轻量级统计**：虽然调用 `update_curr_common()` 更新运行时间，但 `update_curr_stop()` 本身为空，表明 stop 任务不参与复杂的调度实体（`sched_entity`）时间计算。\n- **与 `stop_machine` 协同**：该文件与 `kernel/stop_machine.c` 紧密配合，为 `stop_machine()` 提供底层调度支持，确保在所有 CPU 上同步执行关键操作。\n\n## 4. 依赖关系\n\n- **调度核心**：依赖 `kernel/sched/core.c` 中定义的调度类框架、运行队列（`rq`）结构和通用辅助函数（如 `add_nr_running`、`update_curr_common`）。\n- **SMP 支持**：在 `CONFIG_SMP` 编译选项下，依赖 `kernel/sched/sched.h` 中的 `set_cpus_allowed_common` 函数。\n- **Stop Machine 机制**：与 `kernel/stop_machine.c` 深度集成，后者负责创建和管理 per-CPU stop 任务，并触发其执行。\n- **时间子系统**：使用 `rq_clock_task()` 获取任务执行时间戳，依赖内核时间管理基础设施。\n\n## 5. 使用场景\n\n- **`stop_machine()` 执行**：当内核需要在所有在线 CPU 上同步执行一段不能被中断的代码时（如修改全局数据结构、CPU 热插拔），会激活所有 CPU 的 stop 任务。\n- **CPU 热插拔**：在 CPU 上线或下线过程中，使用 stop 任务确保目标 CPU 处于可控状态，避免调度干扰。\n- **内核关键路径保护**：在极少数需要完全禁止调度器干预的内核关键操作中，临时启用 stop 任务以获得独占 CPU 的能力。\n- **调试与诊断**：某些内核调试机制可能利用 stop 任务来冻结系统状态进行分析。",
      "similarity": 0.5826830267906189,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/sched/stop_task.c",
          "start_line": 12,
          "end_line": 64,
          "content": [
            "static int",
            "select_task_rq_stop(struct task_struct *p, int cpu, int flags)",
            "{",
            "\treturn task_cpu(p); /* stop tasks as never migrate */",
            "}",
            "static int",
            "balance_stop(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)",
            "{",
            "\treturn sched_stop_runnable(rq);",
            "}",
            "static void",
            "wakeup_preempt_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\t/* we're never preempted */",
            "}",
            "static void set_next_task_stop(struct rq *rq, struct task_struct *stop, bool first)",
            "{",
            "\tstop->se.exec_start = rq_clock_task(rq);",
            "}",
            "static void",
            "enqueue_task_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tadd_nr_running(rq, 1);",
            "}",
            "static bool",
            "dequeue_task_stop(struct rq *rq, struct task_struct *p, int flags)",
            "{",
            "\tsub_nr_running(rq, 1);",
            "\treturn true;",
            "}",
            "static void yield_task_stop(struct rq *rq)",
            "{",
            "\tBUG(); /* the stop task should never yield, its pointless. */",
            "}",
            "static void put_prev_task_stop(struct rq *rq, struct task_struct *prev, struct task_struct *next)",
            "{",
            "\tupdate_curr_common(rq);",
            "}",
            "static void task_tick_stop(struct rq *rq, struct task_struct *curr, int queued)",
            "{",
            "}",
            "static void switched_to_stop(struct rq *rq, struct task_struct *p)",
            "{",
            "\tBUG(); /* its impossible to change to this class */",
            "}",
            "static void",
            "prio_changed_stop(struct rq *rq, struct task_struct *p, int oldprio)",
            "{",
            "\tBUG(); /* how!?, what priority? */",
            "}",
            "static void update_curr_stop(struct rq *rq)",
            "{",
            "}"
          ],
          "function_name": "select_task_rq_stop, balance_stop, wakeup_preempt_stop, set_next_task_stop, enqueue_task_stop, dequeue_task_stop, yield_task_stop, put_prev_task_stop, task_tick_stop, switched_to_stop, prio_changed_stop, update_curr_stop",
          "description": "实现stop任务调度类的核心操作，包括CPU选择、负载均衡、抢占唤醒、任务添加删除、时间统计更新等，强制禁止任务迁移和抢占以保证系统中断处理优先级",
          "similarity": 0.5964434146881104
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/stop_task.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * stop-task scheduling class.",
            " *",
            " * The stop task is the highest priority task in the system, it preempts",
            " * everything and will be preempted by nothing.",
            " *",
            " * See kernel/stop_machine.c",
            " */",
            "",
            "#ifdef CONFIG_SMP"
          ],
          "function_name": null,
          "description": "定义stop任务调度类的框架，启用SMP配置时提供最高优先级调度策略，通过禁用任务迁移和抢占实现系统级中断控制",
          "similarity": 0.5792568922042847
        }
      ]
    },
    {
      "source_file": "kernel/livepatch/transition.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:34:51\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `livepatch\\transition.c`\n\n---\n\n# livepatch/transition.c 技术文档\n\n## 1. 文件概述\n\n`livepatch/transition.c` 是 Linux 内核实时补丁（Kernel Live Patching）子系统的核心组件之一，负责管理补丁状态转换过程。该文件实现了从旧代码到新补丁代码（或反向）的安全过渡机制，确保所有正在运行的任务（包括内核线程、用户态进程和 idle 线程）都能安全地切换到目标补丁状态，避免在函数栈中仍存在待替换函数时进行切换，从而防止系统崩溃或行为异常。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `klp_transition_patch`：指向当前正在进行状态转换的补丁对象。\n- `klp_target_state`：目标补丁状态（`KLP_PATCHED` 或 `KLP_UNPATCHED`），初始为 `KLP_UNDEFINED`。\n- `klp_signals_cnt`：用于统计信号处理相关计数（当前未在代码片段中完整使用）。\n- `klp_stack_entries`：每 CPU 栈追踪缓冲区，用于保存任务调用栈。\n\n### 主要函数\n- `klp_transition_work_fn()`：延迟工作队列回调，用于重试未能完成转换的“滞留”任务。\n- `klp_synchronize_transition()`：强制在所有 CPU 上执行调度同步，确保 RCU 不可见区域也能完成同步。\n- `klp_complete_transition()`：完成整个补丁状态转换，清理数据结构并调用回调。\n- `klp_cancel_transition()`：在转换开始前取消补丁操作。\n- `klp_update_patch_state()`：更新指定任务的补丁状态。\n- `klp_check_stack_func()`：检查给定函数是否出现在栈追踪中。\n- `klp_check_stack()`：检查任务栈中是否存在待替换/待移除的函数（代码片段中被截断）。\n\n### 静态键与调度集成\n- 在支持 `CONFIG_PREEMPT_DYNAMIC` 的系统上，通过 `sched_dynamic_klp_enable/disable()` 启用/禁用 cond_resched 中的栈检查。\n- 否则使用静态键 `klp_sched_try_switch_key` 控制是否在 `cond_resched()` 中进行补丁栈检查，以帮助 CPU 密集型内核线程完成补丁切换。\n\n## 3. 关键实现\n\n### 补丁状态转换流程\n1. **初始化阶段**：设置 `klp_transition_patch` 和 `klp_target_state`。\n2. **任务状态更新**：通过 `TIF_PATCH_PENDING` 标志标记需要更新状态的任务。\n3. **栈安全检查**：使用 `stack_trace_save_tsk_reliable()` 获取可靠栈追踪，检查是否存在待替换函数。\n4. **同步机制**：\n   - 使用 `klp_synchronize_transition()` 调用 `schedule_on_each_cpu(klp_sync)`，强制所有 CPU（包括 idle 和用户态）参与同步。\n   - 此机制绕过标准 RCU，适用于 RCU 不活跃的上下文（如 `user_exit()` 前）。\n5. **完成清理**：\n   - 清除所有任务的 `patch_state` 为 `KLP_UNDEFINED`。\n   - 调用对象级的 `post_patch` 或 `post_unpatch` 回调。\n   - 重置全局状态变量。\n\n### 栈检查逻辑\n- **打补丁时（KLP_PATCHED）**：检查栈中是否包含**旧函数**（原始函数或上一个补丁版本的函数）。\n- **卸补丁时（KLP_UNPATCHED）**：检查栈中是否包含**新函数**（当前补丁中的函数）。\n- 若发现相关函数在栈中，则返回 `-EAGAIN`，推迟该任务的状态切换。\n\n### 内存屏障与并发控制\n- `test_and_clear_tsk_thread_flag()` 不仅清除 `TIF_PATCH_PENDING`，还充当读屏障（`smp_rmb`），确保：\n  1. `klp_target_state` 的读取顺序正确。\n  2. 后续 `klp_ftrace_handler()` 能看到一致的 `func->transition` 状态。\n\n### 滞留任务处理\n- 通过 `DECLARE_DELAYED_WORK(klp_transition_work, ...)` 定期重试未能完成转换的任务，提高转换成功率。\n\n## 4. 依赖关系\n\n- **内部依赖**：\n  - `core.h`：提供 `klp_mutex`、`klp_for_each_object/func` 等核心宏和函数。\n  - `patch.h`：定义 `klp_func`、`klp_object`、`klp_patch` 等数据结构及操作函数（如 `klp_unpatch_objects`）。\n  - `transition.h`：声明本文件导出的接口（如 `klp_cancel_transition`）。\n- **内核子系统**：\n  - **RCU**：用于常规同步，但在 RCU 不活跃区域使用自定义同步。\n  - **调度器**：通过 `cond_resched()` 集成补丁检查，依赖 `CONFIG_PREEMPT_DYNAMIC` 或静态键。\n  - **栈追踪**：使用 `stack_trace_save_tsk_reliable()` 获取可靠调用栈。\n  - **CPU 热插拔**：通过 `for_each_possible_cpu` 处理所有可能的 CPU（包括离线 CPU 的 idle 任务）。\n\n## 5. 使用场景\n\n- **应用实时补丁**：当管理员通过 sysfs 启用一个 livepatch 模块时，内核调用此文件中的函数将所有任务从旧代码切换到新补丁代码。\n- **卸载实时补丁**：当禁用补丁时，安全地将所有任务切换回旧函数，并清理补丁数据结构。\n- **处理滞留任务**：对于因长时间运行或处于不可中断状态而未能及时切换的任务，通过延迟工作队列周期性重试。\n- **支持特殊上下文**：确保在 RCU 不活跃的上下文（如系统调用入口/出口、idle 循环）中也能安全完成补丁切换。\n- **错误恢复**：在补丁初始化后、实际切换前发生错误时，调用 `klp_cancel_transition()` 安全回滚。",
      "similarity": 0.5756155252456665,
      "chunks": [
        {
          "chunk_id": 5,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 648,
          "end_line": 740,
          "content": [
            "void klp_reverse_transition(void)",
            "{",
            "\tunsigned int cpu;",
            "\tstruct task_struct *g, *task;",
            "",
            "\tpr_debug(\"'%s': reversing transition from %s\\n\",",
            "\t\t klp_transition_patch->mod->name,",
            "\t\t klp_target_state == KLP_PATCHED ? \"patching to unpatching\" :",
            "\t\t\t\t\t\t   \"unpatching to patching\");",
            "",
            "\t/*",
            "\t * Clear all TIF_PATCH_PENDING flags to prevent races caused by",
            "\t * klp_update_patch_state() or __klp_sched_try_switch() running in",
            "\t * parallel with the reverse transition.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task)",
            "\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tclear_tsk_thread_flag(idle_task(cpu), TIF_PATCH_PENDING);",
            "",
            "\t/*",
            "\t * Make sure all existing invocations of klp_update_patch_state() and",
            "\t * __klp_sched_try_switch() see the cleared TIF_PATCH_PENDING before",
            "\t * starting the reverse transition.",
            "\t */",
            "\tklp_synchronize_transition();",
            "",
            "\t/*",
            "\t * All patching has stopped, now re-initialize the global variables to",
            "\t * prepare for the reverse transition.",
            "\t */",
            "\tklp_transition_patch->enabled = !klp_transition_patch->enabled;",
            "\tklp_target_state = !klp_target_state;",
            "",
            "\t/*",
            "\t * Enforce the order of the klp_target_state write and the",
            "\t * TIF_PATCH_PENDING writes in klp_start_transition() to ensure",
            "\t * klp_update_patch_state() and __klp_sched_try_switch() don't set",
            "\t * task->patch_state to the wrong value.",
            "\t */",
            "\tsmp_wmb();",
            "",
            "\tklp_start_transition();",
            "}",
            "void klp_copy_process(struct task_struct *child)",
            "{",
            "",
            "\t/*",
            "\t * The parent process may have gone through a KLP transition since",
            "\t * the thread flag was copied in setup_thread_stack earlier. Bring",
            "\t * the task flag up to date with the parent here.",
            "\t *",
            "\t * The operation is serialized against all klp_*_transition()",
            "\t * operations by the tasklist_lock. The only exceptions are",
            "\t * klp_update_patch_state(current) and __klp_sched_try_switch(), but we",
            "\t * cannot race with them because we are current.",
            "\t */",
            "\tif (test_tsk_thread_flag(current, TIF_PATCH_PENDING))",
            "\t\tset_tsk_thread_flag(child, TIF_PATCH_PENDING);",
            "\telse",
            "\t\tclear_tsk_thread_flag(child, TIF_PATCH_PENDING);",
            "",
            "\tchild->patch_state = current->patch_state;",
            "}",
            "void klp_force_transition(void)",
            "{",
            "\tstruct klp_patch *patch;",
            "\tstruct task_struct *g, *task;",
            "\tunsigned int cpu;",
            "",
            "\tpr_warn(\"forcing remaining tasks to the patched state\\n\");",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task)",
            "\t\tklp_update_patch_state(task);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tfor_each_possible_cpu(cpu)",
            "\t\tklp_update_patch_state(idle_task(cpu));",
            "",
            "\t/* Set forced flag for patches being removed. */",
            "\tif (klp_target_state == KLP_UNPATCHED)",
            "\t\tklp_transition_patch->forced = true;",
            "\telse if (klp_transition_patch->replace) {",
            "\t\tklp_for_each_patch(patch) {",
            "\t\t\tif (patch != klp_transition_patch)",
            "\t\t\t\tpatch->forced = true;",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "klp_reverse_transition, klp_copy_process, klp_force_transition",
          "description": "该代码段实现Live Patching框架中的状态转换控制逻辑。  \n`klp_reverse_transition`负责反向转换补丁状态，清除所有任务的TIF_PATCH_PENDING标志并切换全局状态后启动反向迁移；`klp_copy_process`在进程复制时同步父进程的补丁状态标志；`klp_force_transition`强制将剩余任务设为目标状态，并标记待移除补丁的强制属性。  \n\n注：代码依赖`klp_transition_patch`、`klp_target_state`等全局变量及`tasklist_lock`等上下文，此处仅展示部分实现。",
          "similarity": 0.6509548425674438
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 214,
          "end_line": 352,
          "content": [
            "static int klp_check_stack_func(struct klp_func *func, unsigned long *entries,",
            "\t\t\t\tunsigned int nr_entries)",
            "{",
            "\tunsigned long func_addr, func_size, address;",
            "\tstruct klp_ops *ops;",
            "\tint i;",
            "",
            "\tif (klp_target_state == KLP_UNPATCHED) {",
            "\t\t /*",
            "\t\t  * Check for the to-be-unpatched function",
            "\t\t  * (the func itself).",
            "\t\t  */",
            "\t\tfunc_addr = (unsigned long)func->new_func;",
            "\t\tfunc_size = func->new_size;",
            "\t} else {",
            "\t\t/*",
            "\t\t * Check for the to-be-patched function",
            "\t\t * (the previous func).",
            "\t\t */",
            "\t\tops = klp_find_ops(func->old_func);",
            "",
            "\t\tif (list_is_singular(&ops->func_stack)) {",
            "\t\t\t/* original function */",
            "\t\t\tfunc_addr = (unsigned long)func->old_func;",
            "\t\t\tfunc_size = func->old_size;",
            "\t\t} else {",
            "\t\t\t/* previously patched function */",
            "\t\t\tstruct klp_func *prev;",
            "",
            "\t\t\tprev = list_next_entry(func, stack_node);",
            "\t\t\tfunc_addr = (unsigned long)prev->new_func;",
            "\t\t\tfunc_size = prev->new_size;",
            "\t\t}",
            "\t}",
            "",
            "\tfor (i = 0; i < nr_entries; i++) {",
            "\t\taddress = entries[i];",
            "",
            "\t\tif (address >= func_addr && address < func_addr + func_size)",
            "\t\t\treturn -EAGAIN;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int klp_check_stack(struct task_struct *task, const char **oldname)",
            "{",
            "\tunsigned long *entries = this_cpu_ptr(klp_stack_entries);",
            "\tstruct klp_object *obj;",
            "\tstruct klp_func *func;",
            "\tint ret, nr_entries;",
            "",
            "\t/* Protect 'klp_stack_entries' */",
            "\tlockdep_assert_preemption_disabled();",
            "",
            "\tret = stack_trace_save_tsk_reliable(task, entries, MAX_STACK_ENTRIES);",
            "\tif (ret < 0)",
            "\t\treturn -EINVAL;",
            "\tnr_entries = ret;",
            "",
            "\tklp_for_each_object(klp_transition_patch, obj) {",
            "\t\tif (!obj->patched)",
            "\t\t\tcontinue;",
            "\t\tklp_for_each_func(obj, func) {",
            "\t\t\tret = klp_check_stack_func(func, entries, nr_entries);",
            "\t\t\tif (ret) {",
            "\t\t\t\t*oldname = func->old_name;",
            "\t\t\t\treturn -EADDRINUSE;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int klp_check_and_switch_task(struct task_struct *task, void *arg)",
            "{",
            "\tint ret;",
            "",
            "\tif (task_curr(task) && task != current)",
            "\t\treturn -EBUSY;",
            "",
            "\tret = klp_check_stack(task, arg);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\ttask->patch_state = klp_target_state;",
            "\treturn 0;",
            "}",
            "static bool klp_try_switch_task(struct task_struct *task)",
            "{",
            "\tconst char *old_name;",
            "\tint ret;",
            "",
            "\t/* check if this task has already switched over */",
            "\tif (task->patch_state == klp_target_state)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * For arches which don't have reliable stack traces, we have to rely",
            "\t * on other methods (e.g., switching tasks at kernel exit).",
            "\t */",
            "\tif (!klp_have_reliable_stack())",
            "\t\treturn false;",
            "",
            "\t/*",
            "\t * Now try to check the stack for any to-be-patched or to-be-unpatched",
            "\t * functions.  If all goes well, switch the task to the target patch",
            "\t * state.",
            "\t */",
            "\tif (task == current)",
            "\t\tret = klp_check_and_switch_task(current, &old_name);",
            "\telse",
            "\t\tret = task_call_func(task, klp_check_and_switch_task, &old_name);",
            "",
            "\tswitch (ret) {",
            "\tcase 0:\t\t/* success */",
            "\t\tbreak;",
            "",
            "\tcase -EBUSY:\t/* klp_check_and_switch_task() */",
            "\t\tpr_debug(\"%s: %s:%d is running\\n\",",
            "\t\t\t __func__, task->comm, task->pid);",
            "\t\tbreak;",
            "\tcase -EINVAL:\t/* klp_check_and_switch_task() */",
            "\t\tpr_debug(\"%s: %s:%d has an unreliable stack\\n\",",
            "\t\t\t __func__, task->comm, task->pid);",
            "\t\tbreak;",
            "\tcase -EADDRINUSE: /* klp_check_and_switch_task() */",
            "\t\tpr_debug(\"%s: %s:%d is sleeping on function %s\\n\",",
            "\t\t\t __func__, task->comm, task->pid, old_name);",
            "\t\tbreak;",
            "",
            "\tdefault:",
            "\t\tpr_debug(\"%s: Unknown error code (%d) when trying to switch %s:%d\\n\",",
            "\t\t\t __func__, ret, task->comm, task->pid);",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn !ret;",
            "}"
          ],
          "function_name": "klp_check_stack_func, klp_check_stack, klp_check_and_switch_task, klp_try_switch_task",
          "description": "提供堆栈检查与任务状态切换机制，验证当前线程堆栈中是否包含待修改函数地址，确保安全切换到目标补丁状态",
          "similarity": 0.6220390796661377
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 366,
          "end_line": 509,
          "content": [
            "void __klp_sched_try_switch(void)",
            "{",
            "\tif (likely(!klp_patch_pending(current)))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * This function is called from cond_resched() which is called in many",
            "\t * places throughout the kernel.  Using the klp_mutex here might",
            "\t * deadlock.",
            "\t *",
            "\t * Instead, disable preemption to prevent racing with other callers of",
            "\t * klp_try_switch_task().  Thanks to task_call_func() they won't be",
            "\t * able to switch this task while it's running.",
            "\t */",
            "\tpreempt_disable();",
            "",
            "\t/*",
            "\t * Make sure current didn't get patched between the above check and",
            "\t * preempt_disable().",
            "\t */",
            "\tif (unlikely(!klp_patch_pending(current)))",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Enforce the order of the TIF_PATCH_PENDING read above and the",
            "\t * klp_target_state read in klp_try_switch_task().  The corresponding",
            "\t * write barriers are in klp_init_transition() and",
            "\t * klp_reverse_transition().",
            "\t */",
            "\tsmp_rmb();",
            "",
            "\tklp_try_switch_task(current);",
            "",
            "out:",
            "\tpreempt_enable();",
            "}",
            "static void klp_send_signals(void)",
            "{",
            "\tstruct task_struct *g, *task;",
            "",
            "\tif (klp_signals_cnt == SIGNALS_TIMEOUT)",
            "\t\tpr_notice(\"signaling remaining tasks\\n\");",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task) {",
            "\t\tif (!klp_patch_pending(task))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * There is a small race here. We could see TIF_PATCH_PENDING",
            "\t\t * set and decide to wake up a kthread or send a fake signal.",
            "\t\t * Meanwhile the task could migrate itself and the action",
            "\t\t * would be meaningless. It is not serious though.",
            "\t\t */",
            "\t\tif (task->flags & PF_KTHREAD) {",
            "\t\t\t/*",
            "\t\t\t * Wake up a kthread which sleeps interruptedly and",
            "\t\t\t * still has not been migrated.",
            "\t\t\t */",
            "\t\t\twake_up_state(task, TASK_INTERRUPTIBLE);",
            "\t\t} else {",
            "\t\t\t/*",
            "\t\t\t * Send fake signal to all non-kthread tasks which are",
            "\t\t\t * still not migrated.",
            "\t\t\t */",
            "\t\t\tset_notify_signal(task);",
            "\t\t}",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "}",
            "void klp_try_complete_transition(void)",
            "{",
            "\tunsigned int cpu;",
            "\tstruct task_struct *g, *task;",
            "\tstruct klp_patch *patch;",
            "\tbool complete = true;",
            "",
            "\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);",
            "",
            "\t/*",
            "\t * Try to switch the tasks to the target patch state by walking their",
            "\t * stacks and looking for any to-be-patched or to-be-unpatched",
            "\t * functions.  If such functions are found on a stack, or if the stack",
            "\t * is deemed unreliable, the task can't be switched yet.",
            "\t *",
            "\t * Usually this will transition most (or all) of the tasks on a system",
            "\t * unless the patch includes changes to a very common function.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task)",
            "\t\tif (!klp_try_switch_task(task))",
            "\t\t\tcomplete = false;",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\t/*",
            "\t * Ditto for the idle \"swapper\" tasks.",
            "\t */",
            "\tcpus_read_lock();",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\ttask = idle_task(cpu);",
            "\t\tif (cpu_online(cpu)) {",
            "\t\t\tif (!klp_try_switch_task(task)) {",
            "\t\t\t\tcomplete = false;",
            "\t\t\t\t/* Make idle task go through the main loop. */",
            "\t\t\t\twake_up_if_idle(cpu);",
            "\t\t\t}",
            "\t\t} else if (task->patch_state != klp_target_state) {",
            "\t\t\t/* offline idle tasks can be switched immediately */",
            "\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\t\t\ttask->patch_state = klp_target_state;",
            "\t\t}",
            "\t}",
            "\tcpus_read_unlock();",
            "",
            "\tif (!complete) {",
            "\t\tif (klp_signals_cnt && !(klp_signals_cnt % SIGNALS_TIMEOUT))",
            "\t\t\tklp_send_signals();",
            "\t\tklp_signals_cnt++;",
            "",
            "\t\t/*",
            "\t\t * Some tasks weren't able to be switched over.  Try again",
            "\t\t * later and/or wait for other methods like kernel exit",
            "\t\t * switching.",
            "\t\t */",
            "\t\tschedule_delayed_work(&klp_transition_work,",
            "\t\t\t\t      round_jiffies_relative(HZ));",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* Done!  Now cleanup the data structures. */",
            "\tklp_cond_resched_disable();",
            "\tpatch = klp_transition_patch;",
            "\tklp_complete_transition();",
            "",
            "\t/*",
            "\t * It would make more sense to free the unused patches in",
            "\t * klp_complete_transition() but it is called also",
            "\t * from klp_cancel_transition().",
            "\t */",
            "\tif (!patch->enabled)",
            "\t\tklp_free_patch_async(patch);",
            "\telse if (patch->replace)",
            "\t\tklp_free_replaced_patches_async(patch);",
            "}"
          ],
          "function_name": "__klp_sched_try_switch, klp_send_signals, klp_try_complete_transition",
          "description": "调度器层面的过渡辅助函数，通过禁止抢占防止竞态条件，并向未迁移任务发送信号触发上下文切换以完成补丁应用",
          "similarity": 0.6167824864387512
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 53,
          "end_line": 172,
          "content": [
            "static void klp_transition_work_fn(struct work_struct *work)",
            "{",
            "\tmutex_lock(&klp_mutex);",
            "",
            "\tif (klp_transition_patch)",
            "\t\tklp_try_complete_transition();",
            "",
            "\tmutex_unlock(&klp_mutex);",
            "}",
            "static void klp_sync(struct work_struct *work)",
            "{",
            "}",
            "static void klp_synchronize_transition(void)",
            "{",
            "\tschedule_on_each_cpu(klp_sync);",
            "}",
            "static void klp_complete_transition(void)",
            "{",
            "\tstruct klp_object *obj;",
            "\tstruct klp_func *func;",
            "\tstruct task_struct *g, *task;",
            "\tunsigned int cpu;",
            "",
            "\tpr_debug(\"'%s': completing %s transition\\n\",",
            "\t\t klp_transition_patch->mod->name,",
            "\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");",
            "",
            "\tif (klp_transition_patch->replace && klp_target_state == KLP_PATCHED) {",
            "\t\tklp_unpatch_replaced_patches(klp_transition_patch);",
            "\t\tklp_discard_nops(klp_transition_patch);",
            "\t}",
            "",
            "\tif (klp_target_state == KLP_UNPATCHED) {",
            "\t\t/*",
            "\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now",
            "\t\t * remove the new functions from the func_stack.",
            "\t\t */",
            "\t\tklp_unpatch_objects(klp_transition_patch);",
            "",
            "\t\t/*",
            "\t\t * Make sure klp_ftrace_handler() can no longer see functions",
            "\t\t * from this patch on the ops->func_stack.  Otherwise, after",
            "\t\t * func->transition gets cleared, the handler may choose a",
            "\t\t * removed function.",
            "\t\t */",
            "\t\tklp_synchronize_transition();",
            "\t}",
            "",
            "\tklp_for_each_object(klp_transition_patch, obj)",
            "\t\tklp_for_each_func(obj, func)",
            "\t\t\tfunc->transition = false;",
            "",
            "\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */",
            "\tif (klp_target_state == KLP_PATCHED)",
            "\t\tklp_synchronize_transition();",
            "",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task) {",
            "\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));",
            "\t\ttask->patch_state = KLP_UNDEFINED;",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\ttask = idle_task(cpu);",
            "\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));",
            "\t\ttask->patch_state = KLP_UNDEFINED;",
            "\t}",
            "",
            "\tklp_for_each_object(klp_transition_patch, obj) {",
            "\t\tif (!klp_is_object_loaded(obj))",
            "\t\t\tcontinue;",
            "\t\tif (klp_target_state == KLP_PATCHED)",
            "\t\t\tklp_post_patch_callback(obj);",
            "\t\telse if (klp_target_state == KLP_UNPATCHED)",
            "\t\t\tklp_post_unpatch_callback(obj);",
            "\t}",
            "",
            "\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,",
            "\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");",
            "",
            "\tklp_target_state = KLP_UNDEFINED;",
            "\tklp_transition_patch = NULL;",
            "}",
            "void klp_cancel_transition(void)",
            "{",
            "\tif (WARN_ON_ONCE(klp_target_state != KLP_PATCHED))",
            "\t\treturn;",
            "",
            "\tpr_debug(\"'%s': canceling patching transition, going to unpatch\\n\",",
            "\t\t klp_transition_patch->mod->name);",
            "",
            "\tklp_target_state = KLP_UNPATCHED;",
            "\tklp_complete_transition();",
            "}",
            "void klp_update_patch_state(struct task_struct *task)",
            "{",
            "\t/*",
            "\t * A variant of synchronize_rcu() is used to allow patching functions",
            "\t * where RCU is not watching, see klp_synchronize_transition().",
            "\t */",
            "\tpreempt_disable_notrace();",
            "",
            "\t/*",
            "\t * This test_and_clear_tsk_thread_flag() call also serves as a read",
            "\t * barrier (smp_rmb) for two cases:",
            "\t *",
            "\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the",
            "\t *    klp_target_state read.  The corresponding write barriers are in",
            "\t *    klp_init_transition() and klp_reverse_transition().",
            "\t *",
            "\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read",
            "\t *    of func->transition, if klp_ftrace_handler() is called later on",
            "\t *    the same CPU.  See __klp_disable_patch().",
            "\t */",
            "\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))",
            "\t\ttask->patch_state = READ_ONCE(klp_target_state);",
            "",
            "\tpreempt_enable_notrace();",
            "}"
          ],
          "function_name": "klp_transition_work_fn, klp_sync, klp_synchronize_transition, klp_complete_transition, klp_cancel_transition, klp_update_patch_state",
          "description": "实现热补丁过渡的核心协程逻辑，包含任务状态同步、补丁完成处理、取消操作及状态更新，通过循环遍历进程和空闲任务确保全部迁移",
          "similarity": 0.6029363870620728
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/livepatch/transition.c",
          "start_line": 530,
          "end_line": 634,
          "content": [
            "void klp_start_transition(void)",
            "{",
            "\tstruct task_struct *g, *task;",
            "\tunsigned int cpu;",
            "",
            "\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);",
            "",
            "\tpr_notice(\"'%s': starting %s transition\\n\",",
            "\t\t  klp_transition_patch->mod->name,",
            "\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");",
            "",
            "\t/*",
            "\t * Mark all normal tasks as needing a patch state update.  They'll",
            "\t * switch either in klp_try_complete_transition() or as they exit the",
            "\t * kernel.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task)",
            "\t\tif (task->patch_state != klp_target_state)",
            "\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\t/*",
            "\t * Mark all idle tasks as needing a patch state update.  They'll switch",
            "\t * either in klp_try_complete_transition() or at the idle loop switch",
            "\t * point.",
            "\t */",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\ttask = idle_task(cpu);",
            "\t\tif (task->patch_state != klp_target_state)",
            "\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);",
            "\t}",
            "",
            "\tklp_cond_resched_enable();",
            "",
            "\tklp_signals_cnt = 0;",
            "}",
            "void klp_init_transition(struct klp_patch *patch, int state)",
            "{",
            "\tstruct task_struct *g, *task;",
            "\tunsigned int cpu;",
            "\tstruct klp_object *obj;",
            "\tstruct klp_func *func;",
            "\tint initial_state = !state;",
            "",
            "\tWARN_ON_ONCE(klp_target_state != KLP_UNDEFINED);",
            "",
            "\tklp_transition_patch = patch;",
            "",
            "\t/*",
            "\t * Set the global target patch state which tasks will switch to.  This",
            "\t * has no effect until the TIF_PATCH_PENDING flags get set later.",
            "\t */",
            "\tklp_target_state = state;",
            "",
            "\tpr_debug(\"'%s': initializing %s transition\\n\", patch->mod->name,",
            "\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");",
            "",
            "\t/*",
            "\t * Initialize all tasks to the initial patch state to prepare them for",
            "\t * switching to the target state.",
            "\t */",
            "\tread_lock(&tasklist_lock);",
            "\tfor_each_process_thread(g, task) {",
            "\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);",
            "\t\ttask->patch_state = initial_state;",
            "\t}",
            "\tread_unlock(&tasklist_lock);",
            "",
            "\t/*",
            "\t * Ditto for the idle \"swapper\" tasks.",
            "\t */",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\ttask = idle_task(cpu);",
            "\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);",
            "\t\ttask->patch_state = initial_state;",
            "\t}",
            "",
            "\t/*",
            "\t * Enforce the order of the task->patch_state initializations and the",
            "\t * func->transition updates to ensure that klp_ftrace_handler() doesn't",
            "\t * see a func in transition with a task->patch_state of KLP_UNDEFINED.",
            "\t *",
            "\t * Also enforce the order of the klp_target_state write and future",
            "\t * TIF_PATCH_PENDING writes to ensure klp_update_patch_state() and",
            "\t * __klp_sched_try_switch() don't set a task->patch_state to",
            "\t * KLP_UNDEFINED.",
            "\t */",
            "\tsmp_wmb();",
            "",
            "\t/*",
            "\t * Set the func transition states so klp_ftrace_handler() will know to",
            "\t * switch to the transition logic.",
            "\t *",
            "\t * When patching, the funcs aren't yet in the func_stack and will be",
            "\t * made visible to the ftrace handler shortly by the calls to",
            "\t * klp_patch_object().",
            "\t *",
            "\t * When unpatching, the funcs are already in the func_stack and so are",
            "\t * already visible to the ftrace handler.",
            "\t */",
            "\tklp_for_each_object(patch, obj)",
            "\t\tklp_for_each_func(obj, func)",
            "\t\t\tfunc->transition = true;",
            "}"
          ],
          "function_name": "klp_start_transition, klp_init_transition",
          "description": "初始化热补丁过渡阶段，设置全局目标状态并批量标记所有任务需更新补丁状态，通过内存屏障保证状态更新顺序性",
          "similarity": 0.5932994484901428
        }
      ]
    }
  ]
}