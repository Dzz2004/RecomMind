{
  "query": "data prefetching",
  "timestamp": "2025-12-26 01:44:48",
  "retrieved_files": [
    {
      "source_file": "mm/readahead.c",
      "md_summary": "> 自动生成时间: 2025-12-07 17:14:54\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `readahead.c`\n\n---\n\n# readahead.c 技术文档\n\n## 1. 文件概述\n\n`readahead.c` 是 Linux 内核内存管理子系统（MM）中的核心文件，负责实现 **地址空间级别（address_space-level）的文件预读（readahead）机制**。该机制通过在应用程序显式请求之前将数据提前读入页缓存（page cache），从而提升顺序读取性能。文件实现了预读状态管理、预读触发逻辑、预读大小计算以及与文件系统交互的接口。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct file_ra_state`：每个打开文件关联的预读状态结构，记录历史访问信息、当前预读窗口大小等。\n- `struct readahead_control`（`rac`）：预读操作控制块，封装了本次预读请求的上下文（如映射地址空间、文件指针、预读页范围等）。\n\n### 主要函数\n- `file_ra_state_init()`：初始化文件的预读状态结构。\n- `read_pages()`：根据预读控制块，调用文件系统的 `->readahead()` 或 `->read_folio()` 方法发起实际 I/O。\n- `page_cache_ra_unbounded()`：启动无边界检查的预读（用于特殊场景，如超出 `i_size` 的读取）。\n- （注：代码片段未完整包含 `page_cache_async_readahead()` 和 `page_cache_sync_readahead()`，但文档说明中提及它们是主要入口）\n\n## 3. 关键实现\n\n### 预读触发机制\n- 当应用访问的页 **不在页缓存中**，或 **在页缓存中但设置了 `PG_readahead` 标志** 时，触发预读。\n- `PG_readahead` 标志标记了上一次预读窗口中“异步尾部”的第一页，其被访问表明应启动下一轮预读。\n\n### 预读窗口构成\n- 每次预读请求包含 **同步部分**（必须满足当前请求）和 **异步部分**（纯预读）。\n- `struct file_ra_state` 中：\n  - `size`：总预读页数。\n  - `async_size`：异步部分页数。\n- 异步部分的第一页会被设置 `PG_readahead` 标志，用于触发后续预读。\n\n### 预读大小计算策略\n- **基于历史**：若能确定上一次预读大小（通过 `file_ra_state` 或页缓存状态），则按比例（通常翻倍）扩展。\n- **基于上下文**：若无法确定历史，则估算页缓存中连续已存在页数作为参考（需大于当前请求且仅在文件开头可放大）。\n- **文件起始加速**：对文件开头的读取采用更激进的预读策略，因常为顺序访问。\n\n### 与文件系统交互\n- 通过地址空间操作 `->readahead()` 发起批量预读（推荐方式），典型实现为 `mpage_readahead()`。\n- 若文件系统未实现 `->readahead()`，则回退到逐页调用 `->read_folio()`。\n- `readahead_folio()` 用于从预读控制块中逐个获取待读页。\n- **错误处理**：\n  - 同步部分页必须成功读取（或等待资源），不可因拥塞失败。\n  - 异步部分页可因资源不足跳过，此时应调用 `filemap_remove_folio()` 从页缓存移除，以便后续重试；若留在缓存中，将导致低效的单页 `->read_folio()` 回退。\n\n### 资源管理\n- 使用 `blk_plug` 机制合并 I/O 请求以提升效率。\n- 通过 PSI（Pressure Stall Information）跟踪内存压力。\n\n## 4. 依赖关系\n\n- **内存管理核心**：依赖 `<linux/pagemap.h>`、`<linux/mm_inline.h>` 管理页缓存和页状态。\n- **块设备层**：通过 `<linux/blkdev.h>`、`<linux/blk-cgroup.h>` 与块 I/O 子系统交互。\n- **文件系统接口**：依赖 `struct address_space_operations` 中的 `readahead`/`read_folio` 方法。\n- **其他子系统**：\n  - PSI（`<linux/psi.h>`）用于内存压力监控。\n  - cgroup blkio（`<linux/blk-cgroup.h>`）支持 I/O 控制。\n  - DAX（`<linux/dax.h>`）支持直接访问持久内存。\n  - 任务 I/O 记账（`<linux/task_io_accounting_ops.h>`）。\n\n## 5. 使用场景\n\n- **顺序文件读取**：当应用顺序读取大文件时，内核自动扩展预读窗口，减少 I/O 次数。\n- **随机读取后的顺序检测**：若随机读取后出现连续访问，预读机制可快速切换到顺序模式。\n- **文件系统实现**：文件系统通过实现 `->readahead()` 方法高效处理批量预读请求（如 ext4、XFS）。\n- **特殊 I/O 模式**：通过 `posix_fadvise(POSIX_FADV_SEQUENTIAL)` 等系统调用提示内核启用更强预读。\n- **大页（Huge Page）支持**：预读逻辑适配 folio（大页抽象），提升大页场景性能。",
      "similarity": 0.5444599986076355,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "mm/readahead.c",
          "start_line": 297,
          "end_line": 411,
          "content": [
            "static void do_page_cache_ra(struct readahead_control *ractl,",
            "\t\tunsigned long nr_to_read, unsigned long lookahead_size)",
            "{",
            "\tstruct inode *inode = ractl->mapping->host;",
            "\tunsigned long index = readahead_index(ractl);",
            "\tloff_t isize = i_size_read(inode);",
            "\tpgoff_t end_index;\t/* The last page we want to read */",
            "",
            "\tif (isize == 0)",
            "\t\treturn;",
            "",
            "\tend_index = (isize - 1) >> PAGE_SHIFT;",
            "\tif (index > end_index)",
            "\t\treturn;",
            "\t/* Don't read past the page containing the last byte of the file */",
            "\tif (nr_to_read > end_index - index)",
            "\t\tnr_to_read = end_index - index + 1;",
            "",
            "\tpage_cache_ra_unbounded(ractl, nr_to_read, lookahead_size);",
            "}",
            "void force_page_cache_ra(struct readahead_control *ractl,",
            "\t\tunsigned long nr_to_read)",
            "{",
            "\tstruct address_space *mapping = ractl->mapping;",
            "\tstruct file_ra_state *ra = ractl->ra;",
            "\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);",
            "\tunsigned long max_pages, index;",
            "",
            "\tif (unlikely(!mapping->a_ops->read_folio && !mapping->a_ops->readahead))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * If the request exceeds the readahead window, allow the read to",
            "\t * be up to the optimal hardware IO size",
            "\t */",
            "\tindex = readahead_index(ractl);",
            "\tmax_pages = max_t(unsigned long, bdi->io_pages, ra->ra_pages);",
            "\tnr_to_read = min_t(unsigned long, nr_to_read, max_pages);",
            "\twhile (nr_to_read) {",
            "\t\tunsigned long this_chunk = (2 * 1024 * 1024) / PAGE_SIZE;",
            "",
            "\t\tif (this_chunk > nr_to_read)",
            "\t\t\tthis_chunk = nr_to_read;",
            "\t\tractl->_index = index;",
            "\t\tdo_page_cache_ra(ractl, this_chunk, 0);",
            "",
            "\t\tindex += this_chunk;",
            "\t\tnr_to_read -= this_chunk;",
            "\t}",
            "}",
            "static unsigned long get_init_ra_size(unsigned long size, unsigned long max)",
            "{",
            "\tunsigned long newsize = roundup_pow_of_two(size);",
            "",
            "\tif (newsize <= max / 32)",
            "\t\tnewsize = newsize * 4;",
            "\telse if (newsize <= max / 4)",
            "\t\tnewsize = newsize * 2;",
            "\telse",
            "\t\tnewsize = max;",
            "",
            "\treturn newsize;",
            "}",
            "static unsigned long get_next_ra_size(struct file_ra_state *ra,",
            "\t\t\t\t      unsigned long max)",
            "{",
            "\tunsigned long cur = ra->size;",
            "",
            "\tif (cur < max / 16)",
            "\t\treturn 4 * cur;",
            "\tif (cur <= max / 2)",
            "\t\treturn 2 * cur;",
            "\treturn max;",
            "}",
            "static pgoff_t count_history_pages(struct address_space *mapping,",
            "\t\t\t\t   pgoff_t index, unsigned long max)",
            "{",
            "\tpgoff_t head;",
            "",
            "\trcu_read_lock();",
            "\thead = page_cache_prev_miss(mapping, index - 1, max);",
            "\trcu_read_unlock();",
            "",
            "\treturn index - 1 - head;",
            "}",
            "static int try_context_readahead(struct address_space *mapping,",
            "\t\t\t\t struct file_ra_state *ra,",
            "\t\t\t\t pgoff_t index,",
            "\t\t\t\t unsigned long req_size,",
            "\t\t\t\t unsigned long max)",
            "{",
            "\tpgoff_t size;",
            "",
            "\tsize = count_history_pages(mapping, index, max);",
            "",
            "\t/*",
            "\t * not enough history pages:",
            "\t * it could be a random read",
            "\t */",
            "\tif (size <= req_size)",
            "\t\treturn 0;",
            "",
            "\t/*",
            "\t * starts from beginning of file:",
            "\t * it is a strong indication of long-run stream (or whole-file-read)",
            "\t */",
            "\tif (size >= index)",
            "\t\tsize *= 2;",
            "",
            "\tra->start = index;",
            "\tra->size = min(size + req_size, max);",
            "\tra->async_size = 1;",
            "",
            "\treturn 1;",
            "}"
          ],
          "function_name": "do_page_cache_ra, force_page_cache_ra, get_init_ra_size, get_next_ra_size, count_history_pages, try_context_readahead",
          "description": "执行分页预读，强制预读逻辑，计算初始和后续预读大小，统计历史页数及上下文预读判断",
          "similarity": 0.5815637111663818
        },
        {
          "chunk_id": 4,
          "file_path": "mm/readahead.c",
          "start_line": 587,
          "end_line": 708,
          "content": [
            "static void ondemand_readahead(struct readahead_control *ractl,",
            "\t\tstruct folio *folio, unsigned long req_size)",
            "{",
            "\tstruct backing_dev_info *bdi = inode_to_bdi(ractl->mapping->host);",
            "\tstruct file_ra_state *ra = ractl->ra;",
            "\tunsigned long max_pages = ra->ra_pages;",
            "\tunsigned long add_pages;",
            "\tpgoff_t index = readahead_index(ractl);",
            "\tpgoff_t expected, prev_index;",
            "\tunsigned int order = folio ? folio_order(folio) : 0;",
            "",
            "\t/*",
            "\t * If the request exceeds the readahead window, allow the read to",
            "\t * be up to the optimal hardware IO size",
            "\t */",
            "\tif (req_size > max_pages && bdi->io_pages > max_pages)",
            "\t\tmax_pages = min(req_size, bdi->io_pages);",
            "",
            "\t/*",
            "\t * start of file",
            "\t */",
            "\tif (!index)",
            "\t\tgoto initial_readahead;",
            "",
            "\t/*",
            "\t * It's the expected callback index, assume sequential access.",
            "\t * Ramp up sizes, and push forward the readahead window.",
            "\t */",
            "\texpected = round_down(ra->start + ra->size - ra->async_size,",
            "\t\t\t1UL << order);",
            "\tif (folio && index == expected) {",
            "\t\tra->start += ra->size;",
            "\t\t/*",
            "\t\t * In the case of MADV_HUGEPAGE, the actual size might exceed",
            "\t\t * the readahead window.",
            "\t\t */",
            "\t\tra->size = max(ra->size, get_next_ra_size(ra, max_pages));",
            "\t\tra->async_size = ra->size;",
            "\t\tgoto readit;",
            "\t}",
            "",
            "\t/*",
            "\t * Hit a marked folio without valid readahead state.",
            "\t * E.g. interleaved reads.",
            "\t * Query the pagecache for async_size, which normally equals to",
            "\t * readahead size. Ramp it up and use it as the new readahead size.",
            "\t */",
            "\tif (folio) {",
            "\t\tpgoff_t start;",
            "",
            "\t\trcu_read_lock();",
            "\t\tstart = page_cache_next_miss(ractl->mapping, index + 1,",
            "\t\t\t\tmax_pages);",
            "\t\trcu_read_unlock();",
            "",
            "\t\tif (!start || start - index > max_pages)",
            "\t\t\treturn;",
            "",
            "\t\tra->start = start;",
            "\t\tra->size = start - index;\t/* old async_size */",
            "\t\tra->size += req_size;",
            "\t\tra->size = get_next_ra_size(ra, max_pages);",
            "\t\tra->async_size = ra->size;",
            "\t\tgoto readit;",
            "\t}",
            "",
            "\t/*",
            "\t * oversize read",
            "\t */",
            "\tif (req_size > max_pages)",
            "\t\tgoto initial_readahead;",
            "",
            "\t/*",
            "\t * sequential cache miss",
            "\t * trivial case: (index - prev_index) == 1",
            "\t * unaligned reads: (index - prev_index) == 0",
            "\t */",
            "\tprev_index = (unsigned long long)ra->prev_pos >> PAGE_SHIFT;",
            "\tif (index - prev_index <= 1UL)",
            "\t\tgoto initial_readahead;",
            "",
            "\t/*",
            "\t * Query the page cache and look for the traces(cached history pages)",
            "\t * that a sequential stream would leave behind.",
            "\t */",
            "\tif (try_context_readahead(ractl->mapping, ra, index, req_size,",
            "\t\t\tmax_pages))",
            "\t\tgoto readit;",
            "",
            "\t/*",
            "\t * standalone, small random read",
            "\t * Read as is, and do not pollute the readahead state.",
            "\t */",
            "\tdo_page_cache_ra(ractl, req_size, 0);",
            "\treturn;",
            "",
            "initial_readahead:",
            "\tra->start = index;",
            "\tra->size = get_init_ra_size(req_size, max_pages);",
            "\tra->async_size = ra->size > req_size ? ra->size - req_size : ra->size;",
            "",
            "readit:",
            "\t/*",
            "\t * Will this read hit the readahead marker made by itself?",
            "\t * If so, trigger the readahead marker hit now, and merge",
            "\t * the resulted next readahead window into the current one.",
            "\t * Take care of maximum IO pages as above.",
            "\t */",
            "\tif (index == ra->start && ra->size == ra->async_size) {",
            "\t\tadd_pages = get_next_ra_size(ra, max_pages);",
            "\t\tif (ra->size + add_pages <= max_pages) {",
            "\t\t\tra->async_size = add_pages;",
            "\t\t\tra->size += add_pages;",
            "\t\t} else {",
            "\t\t\tra->size = max_pages;",
            "\t\t\tra->async_size = max_pages >> 1;",
            "\t\t}",
            "\t}",
            "",
            "\tractl->_index = ra->start;",
            "\tpage_cache_ra_order(ractl, ra, order);",
            "}"
          ],
          "function_name": "ondemand_readahead",
          "description": "按需预读逻辑，根据请求大小和历史记录动态调整预读窗口及大小",
          "similarity": 0.5701771974563599
        },
        {
          "chunk_id": 3,
          "file_path": "mm/readahead.c",
          "start_line": 480,
          "end_line": 581,
          "content": [
            "static inline int ra_alloc_folio(struct readahead_control *ractl, pgoff_t index,",
            "\t\tpgoff_t mark, unsigned int order, gfp_t gfp)",
            "{",
            "\tint err;",
            "\tstruct folio *folio = filemap_alloc_folio(gfp, order);",
            "",
            "\tif (!folio)",
            "\t\treturn -ENOMEM;",
            "\tmark = round_down(mark, 1UL << order);",
            "\tif (index == mark)",
            "\t\tfolio_set_readahead(folio);",
            "\terr = filemap_add_folio(ractl->mapping, folio, index, gfp);",
            "\tif (err) {",
            "\t\tfolio_put(folio);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tractl->_nr_pages += 1UL << order;",
            "\tractl->_workingset |= folio_test_workingset(folio);",
            "\treturn 0;",
            "}",
            "void page_cache_ra_order(struct readahead_control *ractl,",
            "\t\tstruct file_ra_state *ra, unsigned int new_order)",
            "{",
            "\tstruct address_space *mapping = ractl->mapping;",
            "\tpgoff_t start = readahead_index(ractl);",
            "\tpgoff_t index = start;",
            "\tunsigned int min_order = mapping_min_folio_order(mapping);",
            "\tpgoff_t limit = (i_size_read(mapping->host) - 1) >> PAGE_SHIFT;",
            "\tpgoff_t mark = index + ra->size - ra->async_size;",
            "\tunsigned int nofs;",
            "\tint err = 0;",
            "\tgfp_t gfp = readahead_gfp_mask(mapping);",
            "\tunsigned int min_ra_size = max(4, mapping_min_folio_nrpages(mapping));",
            "",
            "\t/*",
            "\t * Fallback when size < min_nrpages as each folio should be",
            "\t * at least min_nrpages anyway.",
            "\t */",
            "\tif (!mapping_large_folio_support(mapping) || ra->size < min_ra_size)",
            "\t\tgoto fallback;",
            "",
            "\tlimit = min(limit, index + ra->size - 1);",
            "",
            "\tif (new_order < mapping_max_folio_order(mapping))",
            "\t\tnew_order += 2;",
            "",
            "\tnew_order = min(mapping_max_folio_order(mapping), new_order);",
            "\tnew_order = min_t(unsigned int, new_order, ilog2(ra->size));",
            "\tnew_order = max(new_order, min_order);",
            "",
            "\t/* See comment in page_cache_ra_unbounded() */",
            "\tnofs = memalloc_nofs_save();",
            "\tfilemap_invalidate_lock_shared(mapping);",
            "\t/*",
            "\t * If the new_order is greater than min_order and index is",
            "\t * already aligned to new_order, then this will be noop as index",
            "\t * aligned to new_order should also be aligned to min_order.",
            "\t */",
            "\tractl->_index = mapping_align_index(mapping, index);",
            "\tindex = readahead_index(ractl);",
            "",
            "\twhile (index <= limit) {",
            "\t\tunsigned int order = new_order;",
            "",
            "\t\t/* Align with smaller pages if needed */",
            "\t\tif (index & ((1UL << order) - 1))",
            "\t\t\torder = __ffs(index);",
            "\t\t/* Don't allocate pages past EOF */",
            "\t\twhile (order > min_order && index + (1UL << order) - 1 > limit)",
            "\t\t\torder--;",
            "\t\terr = ra_alloc_folio(ractl, index, mark, order, gfp);",
            "\t\tif (err)",
            "\t\t\tbreak;",
            "\t\tindex += 1UL << order;",
            "\t}",
            "",
            "\tif (index > limit) {",
            "\t\tra->size += index - limit - 1;",
            "\t\tra->async_size += index - limit - 1;",
            "\t}",
            "",
            "\tread_pages(ractl);",
            "\tfilemap_invalidate_unlock_shared(mapping);",
            "\tmemalloc_nofs_restore(nofs);",
            "",
            "\t/*",
            "\t * If there were already pages in the page cache, then we may have",
            "\t * left some gaps.  Let the regular readahead code take care of this",
            "\t * situation below.",
            "\t */",
            "\tif (!err)",
            "\t\treturn;",
            "fallback:",
            "\t/*",
            "\t * ->readahead() may have updated readahead window size so we have to",
            "\t * check there's still something to read.",
            "\t */",
            "\tif (ra->size > index - start)",
            "\t\tdo_page_cache_ra(ractl, ra->size - (index - start),",
            "\t\t\t\t ra->async_size);",
            "}"
          ],
          "function_name": "ra_alloc_folio, page_cache_ra_order",
          "description": "分配folios并设置标记，根据新订单调整预读顺序和范围",
          "similarity": 0.5623337030410767
        },
        {
          "chunk_id": 5,
          "file_path": "mm/readahead.c",
          "start_line": 710,
          "end_line": 856,
          "content": [
            "void page_cache_sync_ra(struct readahead_control *ractl,",
            "\t\tunsigned long req_count)",
            "{",
            "\tbool do_forced_ra = ractl->file && (ractl->file->f_mode & FMODE_RANDOM);",
            "",
            "\t/*",
            "\t * Even if readahead is disabled, issue this request as readahead",
            "\t * as we'll need it to satisfy the requested range. The forced",
            "\t * readahead will do the right thing and limit the read to just the",
            "\t * requested range, which we'll set to 1 page for this case.",
            "\t */",
            "\tif (!ractl->ra->ra_pages || blk_cgroup_congested()) {",
            "\t\tif (!ractl->file)",
            "\t\t\treturn;",
            "\t\treq_count = 1;",
            "\t\tdo_forced_ra = true;",
            "\t}",
            "",
            "\t/* be dumb */",
            "\tif (do_forced_ra) {",
            "\t\tforce_page_cache_ra(ractl, req_count);",
            "\t\treturn;",
            "\t}",
            "",
            "\tondemand_readahead(ractl, NULL, req_count);",
            "}",
            "void page_cache_async_ra(struct readahead_control *ractl,",
            "\t\tstruct folio *folio, unsigned long req_count)",
            "{",
            "\t/* no readahead */",
            "\tif (!ractl->ra->ra_pages)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Same bit is used for PG_readahead and PG_reclaim.",
            "\t */",
            "\tif (folio_test_writeback(folio))",
            "\t\treturn;",
            "",
            "\tfolio_clear_readahead(folio);",
            "",
            "\tif (blk_cgroup_congested())",
            "\t\treturn;",
            "",
            "\tondemand_readahead(ractl, folio, req_count);",
            "}",
            "ssize_t ksys_readahead(int fd, loff_t offset, size_t count)",
            "{",
            "\tssize_t ret;",
            "\tstruct fd f;",
            "",
            "\tret = -EBADF;",
            "\tf = fdget(fd);",
            "\tif (!f.file || !(f.file->f_mode & FMODE_READ))",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * The readahead() syscall is intended to run only on files",
            "\t * that can execute readahead. If readahead is not possible",
            "\t * on this file, then we must return -EINVAL.",
            "\t */",
            "\tret = -EINVAL;",
            "\tif (!f.file->f_mapping || !f.file->f_mapping->a_ops ||",
            "\t    (!S_ISREG(file_inode(f.file)->i_mode) &&",
            "\t    !S_ISBLK(file_inode(f.file)->i_mode)))",
            "\t\tgoto out;",
            "",
            "\tret = vfs_fadvise(f.file, offset, count, POSIX_FADV_WILLNEED);",
            "out:",
            "\tfdput(f);",
            "\treturn ret;",
            "}",
            "void readahead_expand(struct readahead_control *ractl,",
            "\t\t      loff_t new_start, size_t new_len)",
            "{",
            "\tstruct address_space *mapping = ractl->mapping;",
            "\tstruct file_ra_state *ra = ractl->ra;",
            "\tpgoff_t new_index, new_nr_pages;",
            "\tgfp_t gfp_mask = readahead_gfp_mask(mapping);",
            "\tunsigned long min_nrpages = mapping_min_folio_nrpages(mapping);",
            "\tunsigned int min_order = mapping_min_folio_order(mapping);",
            "",
            "\tnew_index = new_start / PAGE_SIZE;",
            "\t/*",
            "\t * Readahead code should have aligned the ractl->_index to",
            "\t * min_nrpages before calling readahead aops.",
            "\t */",
            "\tVM_BUG_ON(!IS_ALIGNED(ractl->_index, min_nrpages));",
            "",
            "\t/* Expand the leading edge downwards */",
            "\twhile (ractl->_index > new_index) {",
            "\t\tunsigned long index = ractl->_index - 1;",
            "\t\tstruct folio *folio = xa_load(&mapping->i_pages, index);",
            "",
            "\t\tif (folio && !xa_is_value(folio))",
            "\t\t\treturn; /* Folio apparently present */",
            "",
            "\t\tfolio = filemap_alloc_folio(gfp_mask, min_order);",
            "\t\tif (!folio)",
            "\t\t\treturn;",
            "",
            "\t\tindex = mapping_align_index(mapping, index);",
            "\t\tif (filemap_add_folio(mapping, folio, index, gfp_mask) < 0) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif (unlikely(folio_test_workingset(folio)) &&",
            "\t\t\t\t!ractl->_workingset) {",
            "\t\t\tractl->_workingset = true;",
            "\t\t\tpsi_memstall_enter(&ractl->_pflags);",
            "\t\t}",
            "\t\tractl->_nr_pages += min_nrpages;",
            "\t\tractl->_index = folio->index;",
            "\t}",
            "",
            "\tnew_len += new_start - readahead_pos(ractl);",
            "\tnew_nr_pages = DIV_ROUND_UP(new_len, PAGE_SIZE);",
            "",
            "\t/* Expand the trailing edge upwards */",
            "\twhile (ractl->_nr_pages < new_nr_pages) {",
            "\t\tunsigned long index = ractl->_index + ractl->_nr_pages;",
            "\t\tstruct folio *folio = xa_load(&mapping->i_pages, index);",
            "",
            "\t\tif (folio && !xa_is_value(folio))",
            "\t\t\treturn; /* Folio apparently present */",
            "",
            "\t\tfolio = filemap_alloc_folio(gfp_mask, min_order);",
            "\t\tif (!folio)",
            "\t\t\treturn;",
            "",
            "\t\tindex = mapping_align_index(mapping, index);",
            "\t\tif (filemap_add_folio(mapping, folio, index, gfp_mask) < 0) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif (unlikely(folio_test_workingset(folio)) &&",
            "\t\t\t\t!ractl->_workingset) {",
            "\t\t\tractl->_workingset = true;",
            "\t\t\tpsi_memstall_enter(&ractl->_pflags);",
            "\t\t}",
            "\t\tractl->_nr_pages += min_nrpages;",
            "\t\tif (ra) {",
            "\t\t\tra->size += min_nrpages;",
            "\t\t\tra->async_size += min_nrpages;",
            "\t\t}",
            "\t}",
            "}"
          ],
          "function_name": "page_cache_sync_ra, page_cache_async_ra, ksys_readahead, readahead_expand",
          "description": "该代码块实现了Linux内核的文件读取预读机制，包含同步/异步预读逻辑及读取范围扩展功能。  \n`page_cache_sync_ra` 和 `page_cache_async_ra` 分别处理同步/异步预读请求，通过判断文件属性和I/O压力决定是否触发强制读取或按需读取。  \n`readahead_expand` 动态扩展文件读取范围，分配并插入新页帧以满足超出发起位置的读取需求。  \n注：`ondemand_readahead` 等辅助函数未完全展示，上下文存在缺失。",
          "similarity": 0.5414797067642212
        },
        {
          "chunk_id": 1,
          "file_path": "mm/readahead.c",
          "start_line": 138,
          "end_line": 271,
          "content": [
            "void",
            "file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping)",
            "{",
            "\tra->ra_pages = inode_to_bdi(mapping->host)->ra_pages;",
            "\tra->prev_pos = -1;",
            "}",
            "static void read_pages(struct readahead_control *rac)",
            "{",
            "\tconst struct address_space_operations *aops = rac->mapping->a_ops;",
            "\tstruct folio *folio;",
            "\tstruct blk_plug plug;",
            "",
            "\tif (!readahead_count(rac))",
            "\t\treturn;",
            "",
            "\tif (unlikely(rac->_workingset))",
            "\t\tpsi_memstall_enter(&rac->_pflags);",
            "\tblk_start_plug(&plug);",
            "",
            "\tif (aops->readahead) {",
            "\t\taops->readahead(rac);",
            "\t\t/* Clean up the remaining folios. */",
            "\t\twhile ((folio = readahead_folio(rac)) != NULL) {",
            "\t\t\tfolio_get(folio);",
            "\t\t\tfilemap_remove_folio(folio);",
            "\t\t\tfolio_unlock(folio);",
            "\t\t\tfolio_put(folio);",
            "\t\t}",
            "\t} else {",
            "\t\twhile ((folio = readahead_folio(rac)) != NULL)",
            "\t\t\taops->read_folio(rac->file, folio);",
            "\t}",
            "",
            "\tblk_finish_plug(&plug);",
            "\tif (unlikely(rac->_workingset))",
            "\t\tpsi_memstall_leave(&rac->_pflags);",
            "\trac->_workingset = false;",
            "",
            "\tBUG_ON(readahead_count(rac));",
            "}",
            "void page_cache_ra_unbounded(struct readahead_control *ractl,",
            "\t\tunsigned long nr_to_read, unsigned long lookahead_size)",
            "{",
            "\tstruct address_space *mapping = ractl->mapping;",
            "\tunsigned long index = readahead_index(ractl);",
            "\tgfp_t gfp_mask = readahead_gfp_mask(mapping);",
            "\tunsigned long mark = ULONG_MAX, i = 0;",
            "\tunsigned int min_nrpages = mapping_min_folio_nrpages(mapping);",
            "",
            "\t/*",
            "\t * Partway through the readahead operation, we will have added",
            "\t * locked pages to the page cache, but will not yet have submitted",
            "\t * them for I/O.  Adding another page may need to allocate memory,",
            "\t * which can trigger memory reclaim.  Telling the VM we're in",
            "\t * the middle of a filesystem operation will cause it to not",
            "\t * touch file-backed pages, preventing a deadlock.  Most (all?)",
            "\t * filesystems already specify __GFP_NOFS in their mapping's",
            "\t * gfp_mask, but let's be explicit here.",
            "\t */",
            "\tunsigned int nofs = memalloc_nofs_save();",
            "",
            "\tfilemap_invalidate_lock_shared(mapping);",
            "\tindex = mapping_align_index(mapping, index);",
            "",
            "\t/*",
            "\t * As iterator `i` is aligned to min_nrpages, round_up the",
            "\t * difference between nr_to_read and lookahead_size to mark the",
            "\t * index that only has lookahead or \"async_region\" to set the",
            "\t * readahead flag.",
            "\t */",
            "\tif (lookahead_size <= nr_to_read) {",
            "\t\tunsigned long ra_folio_index;",
            "",
            "\t\tra_folio_index = round_up(readahead_index(ractl) +",
            "\t\t\t\t\t  nr_to_read - lookahead_size,",
            "\t\t\t\t\t  min_nrpages);",
            "\t\tmark = ra_folio_index - index;",
            "\t}",
            "\tnr_to_read += readahead_index(ractl) - index;",
            "\tractl->_index = index;",
            "",
            "\t/*",
            "\t * Preallocate as many pages as we will need.",
            "\t */",
            "\twhile (i < nr_to_read) {",
            "\t\tstruct folio *folio = xa_load(&mapping->i_pages, index + i);",
            "\t\tint ret;",
            "",
            "\t\tif (folio && !xa_is_value(folio)) {",
            "\t\t\t/*",
            "\t\t\t * Page already present?  Kick off the current batch",
            "\t\t\t * of contiguous pages before continuing with the",
            "\t\t\t * next batch.  This page may be the one we would",
            "\t\t\t * have intended to mark as Readahead, but we don't",
            "\t\t\t * have a stable reference to this page, and it's",
            "\t\t\t * not worth getting one just for that.",
            "\t\t\t */",
            "\t\t\tread_pages(ractl);",
            "\t\t\tractl->_index += min_nrpages;",
            "\t\t\ti = ractl->_index + ractl->_nr_pages - index;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tfolio = filemap_alloc_folio(gfp_mask,",
            "\t\t\t\t\t    mapping_min_folio_order(mapping));",
            "\t\tif (!folio)",
            "\t\t\tbreak;",
            "",
            "\t\tret = filemap_add_folio(mapping, folio, index + i, gfp_mask);",
            "\t\tif (ret < 0) {",
            "\t\t\tfolio_put(folio);",
            "\t\t\tif (ret == -ENOMEM)",
            "\t\t\t\tbreak;",
            "\t\t\tread_pages(ractl);",
            "\t\t\tractl->_index += min_nrpages;",
            "\t\t\ti = ractl->_index + ractl->_nr_pages - index;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (i == mark)",
            "\t\t\tfolio_set_readahead(folio);",
            "\t\tractl->_workingset |= folio_test_workingset(folio);",
            "\t\tractl->_nr_pages += min_nrpages;",
            "\t\ti += min_nrpages;",
            "\t}",
            "",
            "\t/*",
            "\t * Now start the IO.  We ignore I/O errors - if the folio is not",
            "\t * uptodate then the caller will launch read_folio again, and",
            "\t * will then handle the error.",
            "\t */",
            "\tread_pages(ractl);",
            "\tfilemap_invalidate_unlock_shared(mapping);",
            "\tmemalloc_nofs_restore(nofs);",
            "}"
          ],
          "function_name": "file_ra_state_init, read_pages, page_cache_ra_unbounded",
          "description": "初始化文件读取状态，执行读取操作并清理未读取的folios，处理无界预读逻辑",
          "similarity": 0.5296671390533447
        }
      ]
    },
    {
      "source_file": "kernel/bpf/lpm_trie.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:16:29\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\lpm_trie.c`\n\n---\n\n# bpf/lpm_trie.c 技术文档\n\n## 1. 文件概述\n\n`bpf/lpm_trie.c` 实现了基于最长前缀匹配（Longest Prefix Match, LPM）算法的 BPF 映射（map）类型，主要用于高效匹配 IP 地址前缀。该数据结构特别适用于网络路由、访问控制列表（ACL）等需要根据 IP 地址前缀进行快速查找的场景。该实现支持 IPv4 和 IPv6 地址，并通过前缀树（Trie）结构实现高效的插入、查找和删除操作。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct lpm_trie_node`**  \n  表示前缀树中的一个节点，包含：\n  - `rcu`：用于 RCU（Read-Copy-Update）内存回收机制\n  - `child[2]`：指向左右子节点的指针（0 和 1 分支）\n  - `prefixlen`：该节点表示的前缀长度（位数）\n  - `flags`：节点标志，`LPM_TREE_NODE_FLAG_IM` 表示中间节点（无用户数据）\n  - `data[]`：变长数组，存储前缀数据（大端序）\n\n- **`struct lpm_trie`**  \n  表示整个 LPM Trie 映射，包含：\n  - `map`：嵌入的 `bpf_map` 基类\n  - `root`：指向根节点的 RCU 指针\n  - `n_entries`：当前条目数量\n  - `max_prefixlen`：最大前缀长度（如 32 表示 IPv4，128 表示 IPv6）\n  - `data_size`：前缀数据字节数（如 4 字节对应 IPv4）\n  - `lock`：自旋锁，用于同步更新操作\n\n### 主要函数\n\n- **`extract_bit()`**  \n  从字节数组中提取指定索引位置的比特位（大端序）。\n\n- **`longest_prefix_match()`**  \n  计算给定节点与查询键之间的最长匹配前缀长度，利用字对齐和字长优化（32/64 位）加速比较。\n\n- **`trie_lookup_elem()`**  \n  实现 BPF map 的查找接口，从根节点开始遍历 Trie，返回匹配路径中最深的非中间节点（即具有用户数据的节点）。\n\n## 3. 关键实现\n\n### 前缀树结构设计\n\n- 所有前缀数据以**大端序**存储，`data[0]` 为最高有效字节。\n- 节点分为两类：\n  - **真实节点**：包含用户通过 `bpf_map_update_elem()` 设置的值。\n  - **中间节点（Intermediate Node）**：仅用于路径分叉，无用户数据，由 `LPM_TREE_NODE_FLAG_IM` 标识。\n- 插入新前缀时，若路径上已有更短前缀，则沿比特路径向下查找；若需分叉但子节点已存在，则插入新的中间节点以扩展路径。\n\n### 高效前缀匹配算法\n\n- `longest_prefix_match()` 函数通过逐字（word-wise）比较加速前缀匹配：\n  - 在支持高效非对齐访问的 64 位平台上，优先使用 64 位比较。\n  - 否则依次尝试 32 位、16 位和 8 位比较。\n  - 利用 `fls()`/`fls64()`（Find Last Set）快速定位第一个不同比特位。\n\n### 并发与内存管理\n\n- **读操作（lookup）**：使用 RCU 机制，无需加锁，支持高并发。\n- **写操作（update/delete）**：通过自旋锁 `trie->lock` 保证原子性。\n- 节点内存通过 `kmalloc`/`vmalloc` 分配，并通过 RCU 回收。\n\n### 查找逻辑\n\n- 从根节点开始，逐层向下遍历。\n- 每次根据当前节点前缀长度之后的下一位比特值（0 或 1）选择子节点。\n- 记录遍历路径中最后一个**非中间节点**作为候选结果。\n- 当无法继续向下匹配时，返回该候选节点的值。\n\n## 4. 依赖关系\n\n- **内核头文件依赖**：\n  - `<linux/bpf.h>`：BPF 核心框架\n  - `<linux/rcupdate.h>`（通过 `<linux/bpf.h>` 间接包含）：RCU 机制\n  - `<linux/slab.h>` / `<linux/vmalloc.h>`：内存分配\n  - `<net/ipv6.h>`：IPv6 相关辅助函数（如 `ipv6_addr_prefix()`）\n  - `<linux/btf.h>`：BPF 类型格式（BTF）支持\n- **BPF 子系统**：作为 `BPF_MAP_TYPE_LPM_TRIE` 类型的后端实现，与 BPF verifier、map 操作接口紧密集成。\n- **网络子系统**：主要用于 IP 路由和策略匹配，但本身不直接依赖网络协议栈。\n\n## 5. 使用场景\n\n- **eBPF 程序中的 IP 路由查找**：例如在 XDP 或 TC 程序中根据目标 IP 查找下一跳或策略。\n- **访问控制**：匹配 IP 前缀以决定是否允许流量（如防火墙规则）。\n- **负载均衡**：根据客户端 IP 前缀进行会话保持或区域路由。\n- **网络监控**：按 IP 段聚合流量统计。\n- **用户空间工具**：通过 `bpf()` 系统调用管理 LPM Trie 映射，实现动态策略更新。",
      "similarity": 0.5415129661560059,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/lpm_trie.c",
          "start_line": 152,
          "end_line": 359,
          "content": [
            "static inline int extract_bit(const u8 *data, size_t index)",
            "{",
            "\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));",
            "}",
            "static size_t longest_prefix_match(const struct lpm_trie *trie,",
            "\t\t\t\t   const struct lpm_trie_node *node,",
            "\t\t\t\t   const struct bpf_lpm_trie_key_u8 *key)",
            "{",
            "\tu32 limit = min(node->prefixlen, key->prefixlen);",
            "\tu32 prefixlen = 0, i = 0;",
            "",
            "\tBUILD_BUG_ON(offsetof(struct lpm_trie_node, data) % sizeof(u32));",
            "\tBUILD_BUG_ON(offsetof(struct bpf_lpm_trie_key_u8, data) % sizeof(u32));",
            "",
            "#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(CONFIG_64BIT)",
            "",
            "\t/* data_size >= 16 has very small probability.",
            "\t * We do not use a loop for optimal code generation.",
            "\t */",
            "\tif (trie->data_size >= 8) {",
            "\t\tu64 diff = be64_to_cpu(*(__be64 *)node->data ^",
            "\t\t\t\t       *(__be64 *)key->data);",
            "",
            "\t\tprefixlen = 64 - fls64(diff);",
            "\t\tif (prefixlen >= limit)",
            "\t\t\treturn limit;",
            "\t\tif (diff)",
            "\t\t\treturn prefixlen;",
            "\t\ti = 8;",
            "\t}",
            "#endif",
            "",
            "\twhile (trie->data_size >= i + 4) {",
            "\t\tu32 diff = be32_to_cpu(*(__be32 *)&node->data[i] ^",
            "\t\t\t\t       *(__be32 *)&key->data[i]);",
            "",
            "\t\tprefixlen += 32 - fls(diff);",
            "\t\tif (prefixlen >= limit)",
            "\t\t\treturn limit;",
            "\t\tif (diff)",
            "\t\t\treturn prefixlen;",
            "\t\ti += 4;",
            "\t}",
            "",
            "\tif (trie->data_size >= i + 2) {",
            "\t\tu16 diff = be16_to_cpu(*(__be16 *)&node->data[i] ^",
            "\t\t\t\t       *(__be16 *)&key->data[i]);",
            "",
            "\t\tprefixlen += 16 - fls(diff);",
            "\t\tif (prefixlen >= limit)",
            "\t\t\treturn limit;",
            "\t\tif (diff)",
            "\t\t\treturn prefixlen;",
            "\t\ti += 2;",
            "\t}",
            "",
            "\tif (trie->data_size >= i + 1) {",
            "\t\tprefixlen += 8 - fls(node->data[i] ^ key->data[i]);",
            "",
            "\t\tif (prefixlen >= limit)",
            "\t\t\treturn limit;",
            "\t}",
            "",
            "\treturn prefixlen;",
            "}",
            "static int trie_check_add_elem(struct lpm_trie *trie, u64 flags)",
            "{",
            "\tif (flags == BPF_EXIST)",
            "\t\treturn -ENOENT;",
            "\tif (trie->n_entries == trie->map.max_entries)",
            "\t\treturn -ENOSPC;",
            "\ttrie->n_entries++;",
            "\treturn 0;",
            "}",
            "static long trie_update_elem(struct bpf_map *map,",
            "\t\t\t     void *_key, void *value, u64 flags)",
            "{",
            "\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);",
            "\tstruct lpm_trie_node *node, *im_node, *new_node = NULL;",
            "\tstruct lpm_trie_node *free_node = NULL;",
            "\tstruct lpm_trie_node __rcu **slot;",
            "\tstruct bpf_lpm_trie_key_u8 *key = _key;",
            "\tunsigned long irq_flags;",
            "\tunsigned int next_bit;",
            "\tsize_t matchlen = 0;",
            "\tint ret = 0;",
            "",
            "\tif (unlikely(flags > BPF_EXIST))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (key->prefixlen > trie->max_prefixlen)",
            "\t\treturn -EINVAL;",
            "",
            "\tspin_lock_irqsave(&trie->lock, irq_flags);",
            "",
            "\t/* Allocate and fill a new node */",
            "\tnew_node = lpm_trie_node_alloc(trie, value);",
            "\tif (!new_node) {",
            "\t\tret = -ENOMEM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tnew_node->prefixlen = key->prefixlen;",
            "\tRCU_INIT_POINTER(new_node->child[0], NULL);",
            "\tRCU_INIT_POINTER(new_node->child[1], NULL);",
            "\tmemcpy(new_node->data, key->data, trie->data_size);",
            "",
            "\t/* Now find a slot to attach the new node. To do that, walk the tree",
            "\t * from the root and match as many bits as possible for each node until",
            "\t * we either find an empty slot or a slot that needs to be replaced by",
            "\t * an intermediate node.",
            "\t */",
            "\tslot = &trie->root;",
            "",
            "\twhile ((node = rcu_dereference_protected(*slot,",
            "\t\t\t\t\tlockdep_is_held(&trie->lock)))) {",
            "\t\tmatchlen = longest_prefix_match(trie, node, key);",
            "",
            "\t\tif (node->prefixlen != matchlen ||",
            "\t\t    node->prefixlen == key->prefixlen ||",
            "\t\t    node->prefixlen == trie->max_prefixlen)",
            "\t\t\tbreak;",
            "",
            "\t\tnext_bit = extract_bit(key->data, node->prefixlen);",
            "\t\tslot = &node->child[next_bit];",
            "\t}",
            "",
            "\t/* If the slot is empty (a free child pointer or an empty root),",
            "\t * simply assign the @new_node to that slot and be done.",
            "\t */",
            "\tif (!node) {",
            "\t\tret = trie_check_add_elem(trie, flags);",
            "\t\tif (ret)",
            "\t\t\tgoto out;",
            "",
            "\t\trcu_assign_pointer(*slot, new_node);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* If the slot we picked already exists, replace it with @new_node",
            "\t * which already has the correct data array set.",
            "\t */",
            "\tif (node->prefixlen == matchlen) {",
            "\t\tif (!(node->flags & LPM_TREE_NODE_FLAG_IM)) {",
            "\t\t\tif (flags == BPF_NOEXIST) {",
            "\t\t\t\tret = -EEXIST;",
            "\t\t\t\tgoto out;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tret = trie_check_add_elem(trie, flags);",
            "\t\t\tif (ret)",
            "\t\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tnew_node->child[0] = node->child[0];",
            "\t\tnew_node->child[1] = node->child[1];",
            "",
            "\t\trcu_assign_pointer(*slot, new_node);",
            "\t\tfree_node = node;",
            "",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = trie_check_add_elem(trie, flags);",
            "\tif (ret)",
            "\t\tgoto out;",
            "",
            "\t/* If the new node matches the prefix completely, it must be inserted",
            "\t * as an ancestor. Simply insert it between @node and *@slot.",
            "\t */",
            "\tif (matchlen == key->prefixlen) {",
            "\t\tnext_bit = extract_bit(node->data, matchlen);",
            "\t\trcu_assign_pointer(new_node->child[next_bit], node);",
            "\t\trcu_assign_pointer(*slot, new_node);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tim_node = lpm_trie_node_alloc(trie, NULL);",
            "\tif (!im_node) {",
            "\t\ttrie->n_entries--;",
            "\t\tret = -ENOMEM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tim_node->prefixlen = matchlen;",
            "\tim_node->flags |= LPM_TREE_NODE_FLAG_IM;",
            "\tmemcpy(im_node->data, node->data, trie->data_size);",
            "",
            "\t/* Now determine which child to install in which slot */",
            "\tif (extract_bit(key->data, matchlen)) {",
            "\t\trcu_assign_pointer(im_node->child[0], node);",
            "\t\trcu_assign_pointer(im_node->child[1], new_node);",
            "\t} else {",
            "\t\trcu_assign_pointer(im_node->child[0], new_node);",
            "\t\trcu_assign_pointer(im_node->child[1], node);",
            "\t}",
            "",
            "\t/* Finally, assign the intermediate node to the determined slot */",
            "\trcu_assign_pointer(*slot, im_node);",
            "",
            "out:",
            "\tif (ret)",
            "\t\tkfree(new_node);",
            "\tspin_unlock_irqrestore(&trie->lock, irq_flags);",
            "\tkfree_rcu(free_node, rcu);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "extract_bit, longest_prefix_match, trie_check_add_elem, trie_update_elem",
          "description": "实现了最长前缀匹配核心逻辑（longest_prefix_match），提取位操作（extract_bit），以及添加/更新元素的处理（trie_check_add_elem, trie_update_elem）。其中trie_update_elem负责根据匹配结果决定插入新节点、替换现有节点或创建中间节点以维持树结构。",
          "similarity": 0.5342298746109009
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/lpm_trie.c",
          "start_line": 633,
          "end_line": 738,
          "content": [
            "static int trie_get_next_key(struct bpf_map *map, void *_key, void *_next_key)",
            "{",
            "\tstruct lpm_trie_node *node, *next_node = NULL, *parent, *search_root;",
            "\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);",
            "\tstruct bpf_lpm_trie_key_u8 *key = _key, *next_key = _next_key;",
            "\tstruct lpm_trie_node **node_stack = NULL;",
            "\tint err = 0, stack_ptr = -1;",
            "\tunsigned int next_bit;",
            "\tsize_t matchlen = 0;",
            "",
            "\t/* The get_next_key follows postorder. For the 4 node example in",
            "\t * the top of this file, the trie_get_next_key() returns the following",
            "\t * one after another:",
            "\t *   192.168.0.0/24",
            "\t *   192.168.1.0/24",
            "\t *   192.168.128.0/24",
            "\t *   192.168.0.0/16",
            "\t *",
            "\t * The idea is to return more specific keys before less specific ones.",
            "\t */",
            "",
            "\t/* Empty trie */",
            "\tsearch_root = rcu_dereference(trie->root);",
            "\tif (!search_root)",
            "\t\treturn -ENOENT;",
            "",
            "\t/* For invalid key, find the leftmost node in the trie */",
            "\tif (!key || key->prefixlen > trie->max_prefixlen)",
            "\t\tgoto find_leftmost;",
            "",
            "\tnode_stack = kmalloc_array(trie->max_prefixlen + 1,",
            "\t\t\t\t   sizeof(struct lpm_trie_node *),",
            "\t\t\t\t   GFP_ATOMIC | __GFP_NOWARN);",
            "\tif (!node_stack)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/* Try to find the exact node for the given key */",
            "\tfor (node = search_root; node;) {",
            "\t\tnode_stack[++stack_ptr] = node;",
            "\t\tmatchlen = longest_prefix_match(trie, node, key);",
            "\t\tif (node->prefixlen != matchlen ||",
            "\t\t    node->prefixlen == key->prefixlen)",
            "\t\t\tbreak;",
            "",
            "\t\tnext_bit = extract_bit(key->data, node->prefixlen);",
            "\t\tnode = rcu_dereference(node->child[next_bit]);",
            "\t}",
            "\tif (!node || node->prefixlen != matchlen ||",
            "\t    (node->flags & LPM_TREE_NODE_FLAG_IM))",
            "\t\tgoto find_leftmost;",
            "",
            "\t/* The node with the exactly-matching key has been found,",
            "\t * find the first node in postorder after the matched node.",
            "\t */",
            "\tnode = node_stack[stack_ptr];",
            "\twhile (stack_ptr > 0) {",
            "\t\tparent = node_stack[stack_ptr - 1];",
            "\t\tif (rcu_dereference(parent->child[0]) == node) {",
            "\t\t\tsearch_root = rcu_dereference(parent->child[1]);",
            "\t\t\tif (search_root)",
            "\t\t\t\tgoto find_leftmost;",
            "\t\t}",
            "\t\tif (!(parent->flags & LPM_TREE_NODE_FLAG_IM)) {",
            "\t\t\tnext_node = parent;",
            "\t\t\tgoto do_copy;",
            "\t\t}",
            "",
            "\t\tnode = parent;",
            "\t\tstack_ptr--;",
            "\t}",
            "",
            "\t/* did not find anything */",
            "\terr = -ENOENT;",
            "\tgoto free_stack;",
            "",
            "find_leftmost:",
            "\t/* Find the leftmost non-intermediate node, all intermediate nodes",
            "\t * have exact two children, so this function will never return NULL.",
            "\t */",
            "\tfor (node = search_root; node;) {",
            "\t\tif (node->flags & LPM_TREE_NODE_FLAG_IM) {",
            "\t\t\tnode = rcu_dereference(node->child[0]);",
            "\t\t} else {",
            "\t\t\tnext_node = node;",
            "\t\t\tnode = rcu_dereference(node->child[0]);",
            "\t\t\tif (!node)",
            "\t\t\t\tnode = rcu_dereference(next_node->child[1]);",
            "\t\t}",
            "\t}",
            "do_copy:",
            "\tnext_key->prefixlen = next_node->prefixlen;",
            "\tmemcpy((void *)next_key + offsetof(struct bpf_lpm_trie_key_u8, data),",
            "\t       next_node->data, trie->data_size);",
            "free_stack:",
            "\tkfree(node_stack);",
            "\treturn err;",
            "}",
            "static int trie_check_btf(const struct bpf_map *map,",
            "\t\t\t  const struct btf *btf,",
            "\t\t\t  const struct btf_type *key_type,",
            "\t\t\t  const struct btf_type *value_type)",
            "{",
            "\t/* Keys must have struct bpf_lpm_trie_key_u8 embedded. */",
            "\treturn BTF_INFO_KIND(key_type->info) != BTF_KIND_STRUCT ?",
            "\t       -EINVAL : 0;",
            "}"
          ],
          "function_name": "trie_get_next_key, trie_check_btf",
          "description": "实现了获取下一个键（trie_get_next_key）的后序遍历逻辑，以及BTF类型校验（trie_check_btf）。get_next_key遵循特定顺序返回更具体的键，check_btf确保键类型符合预定义结构。",
          "similarity": 0.48182302713394165
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/lpm_trie.c",
          "start_line": 1,
          "end_line": 151,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Longest prefix match list implementation",
            " *",
            " * Copyright (c) 2016,2017 Daniel Mack",
            " * Copyright (c) 2016 David Herrmann",
            " */",
            "",
            "#include <linux/bpf.h>",
            "#include <linux/btf.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/ipv6.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/btf_ids.h>",
            "",
            "/* Intermediate node */",
            "#define LPM_TREE_NODE_FLAG_IM BIT(0)",
            "",
            "struct lpm_trie_node;",
            "",
            "struct lpm_trie_node {",
            "\tstruct rcu_head rcu;",
            "\tstruct lpm_trie_node __rcu\t*child[2];",
            "\tu32\t\t\t\tprefixlen;",
            "\tu32\t\t\t\tflags;",
            "\tu8\t\t\t\tdata[];",
            "};",
            "",
            "struct lpm_trie {",
            "\tstruct bpf_map\t\t\tmap;",
            "\tstruct lpm_trie_node __rcu\t*root;",
            "\tsize_t\t\t\t\tn_entries;",
            "\tsize_t\t\t\t\tmax_prefixlen;",
            "\tsize_t\t\t\t\tdata_size;",
            "\tspinlock_t\t\t\tlock;",
            "};",
            "",
            "/* This trie implements a longest prefix match algorithm that can be used to",
            " * match IP addresses to a stored set of ranges.",
            " *",
            " * Data stored in @data of struct bpf_lpm_key and struct lpm_trie_node is",
            " * interpreted as big endian, so data[0] stores the most significant byte.",
            " *",
            " * Match ranges are internally stored in instances of struct lpm_trie_node",
            " * which each contain their prefix length as well as two pointers that may",
            " * lead to more nodes containing more specific matches. Each node also stores",
            " * a value that is defined by and returned to userspace via the update_elem",
            " * and lookup functions.",
            " *",
            " * For instance, let's start with a trie that was created with a prefix length",
            " * of 32, so it can be used for IPv4 addresses, and one single element that",
            " * matches 192.168.0.0/16. The data array would hence contain",
            " * [0xc0, 0xa8, 0x00, 0x00] in big-endian notation. This documentation will",
            " * stick to IP-address notation for readability though.",
            " *",
            " * As the trie is empty initially, the new node (1) will be places as root",
            " * node, denoted as (R) in the example below. As there are no other node, both",
            " * child pointers are %NULL.",
            " *",
            " *              +----------------+",
            " *              |       (1)  (R) |",
            " *              | 192.168.0.0/16 |",
            " *              |    value: 1    |",
            " *              |   [0]    [1]   |",
            " *              +----------------+",
            " *",
            " * Next, let's add a new node (2) matching 192.168.0.0/24. As there is already",
            " * a node with the same data and a smaller prefix (ie, a less specific one),",
            " * node (2) will become a child of (1). In child index depends on the next bit",
            " * that is outside of what (1) matches, and that bit is 0, so (2) will be",
            " * child[0] of (1):",
            " *",
            " *              +----------------+",
            " *              |       (1)  (R) |",
            " *              | 192.168.0.0/16 |",
            " *              |    value: 1    |",
            " *              |   [0]    [1]   |",
            " *              +----------------+",
            " *                   |",
            " *    +----------------+",
            " *    |       (2)      |",
            " *    | 192.168.0.0/24 |",
            " *    |    value: 2    |",
            " *    |   [0]    [1]   |",
            " *    +----------------+",
            " *",
            " * The child[1] slot of (1) could be filled with another node which has bit #17",
            " * (the next bit after the ones that (1) matches on) set to 1. For instance,",
            " * 192.168.128.0/24:",
            " *",
            " *              +----------------+",
            " *              |       (1)  (R) |",
            " *              | 192.168.0.0/16 |",
            " *              |    value: 1    |",
            " *              |   [0]    [1]   |",
            " *              +----------------+",
            " *                   |      |",
            " *    +----------------+  +------------------+",
            " *    |       (2)      |  |        (3)       |",
            " *    | 192.168.0.0/24 |  | 192.168.128.0/24 |",
            " *    |    value: 2    |  |     value: 3     |",
            " *    |   [0]    [1]   |  |    [0]    [1]    |",
            " *    +----------------+  +------------------+",
            " *",
            " * Let's add another node (4) to the game for 192.168.1.0/24. In order to place",
            " * it, node (1) is looked at first, and because (4) of the semantics laid out",
            " * above (bit #17 is 0), it would normally be attached to (1) as child[0].",
            " * However, that slot is already allocated, so a new node is needed in between.",
            " * That node does not have a value attached to it and it will never be",
            " * returned to users as result of a lookup. It is only there to differentiate",
            " * the traversal further. It will get a prefix as wide as necessary to",
            " * distinguish its two children:",
            " *",
            " *                      +----------------+",
            " *                      |       (1)  (R) |",
            " *                      | 192.168.0.0/16 |",
            " *                      |    value: 1    |",
            " *                      |   [0]    [1]   |",
            " *                      +----------------+",
            " *                           |      |",
            " *            +----------------+  +------------------+",
            " *            |       (4)  (I) |  |        (3)       |",
            " *            | 192.168.0.0/23 |  | 192.168.128.0/24 |",
            " *            |    value: ---  |  |     value: 3     |",
            " *            |   [0]    [1]   |  |    [0]    [1]    |",
            " *            +----------------+  +------------------+",
            " *                 |      |",
            " *  +----------------+  +----------------+",
            " *  |       (2)      |  |       (5)      |",
            " *  | 192.168.0.0/24 |  | 192.168.1.0/24 |",
            " *  |    value: 2    |  |     value: 5   |",
            " *  |   [0]    [1]   |  |   [0]    [1]   |",
            " *  +----------------+  +----------------+",
            " *",
            " * 192.168.1.1/32 would be a child of (5) etc.",
            " *",
            " * An intermediate node will be turned into a 'real' node on demand. In the",
            " * example above, (4) would be re-used if 192.168.0.0/23 is added to the trie.",
            " *",
            " * A fully populated trie would have a height of 32 nodes, as the trie was",
            " * created with a prefix length of 32.",
            " *",
            " * The lookup starts at the root node. If the current node matches and if there",
            " * is a child that can be used to become more specific, the trie is traversed",
            " * downwards. The last node in the traversal that is a non-intermediate one is",
            " * returned.",
            " */",
            ""
          ],
          "function_name": null,
          "description": "定义了LPM Trie的数据结构，包含节点（带子节点指针、前缀长度和标志位）和树结构（根节点、最大前缀长度、锁等）。该结构用于实现最长前缀匹配算法，支持IP地址范围查找，节点数据按大端存储，中间节点用于区分不同分支。",
          "similarity": 0.4797600209712982
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/lpm_trie.c",
          "start_line": 452,
          "end_line": 586,
          "content": [
            "static long trie_delete_elem(struct bpf_map *map, void *_key)",
            "{",
            "\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);",
            "\tstruct lpm_trie_node *free_node = NULL, *free_parent = NULL;",
            "\tstruct bpf_lpm_trie_key_u8 *key = _key;",
            "\tstruct lpm_trie_node __rcu **trim, **trim2;",
            "\tstruct lpm_trie_node *node, *parent;",
            "\tunsigned long irq_flags;",
            "\tunsigned int next_bit;",
            "\tsize_t matchlen = 0;",
            "\tint ret = 0;",
            "",
            "\tif (key->prefixlen > trie->max_prefixlen)",
            "\t\treturn -EINVAL;",
            "",
            "\tspin_lock_irqsave(&trie->lock, irq_flags);",
            "",
            "\t/* Walk the tree looking for an exact key/length match and keeping",
            "\t * track of the path we traverse.  We will need to know the node",
            "\t * we wish to delete, and the slot that points to the node we want",
            "\t * to delete.  We may also need to know the nodes parent and the",
            "\t * slot that contains it.",
            "\t */",
            "\ttrim = &trie->root;",
            "\ttrim2 = trim;",
            "\tparent = NULL;",
            "\twhile ((node = rcu_dereference_protected(",
            "\t\t       *trim, lockdep_is_held(&trie->lock)))) {",
            "\t\tmatchlen = longest_prefix_match(trie, node, key);",
            "",
            "\t\tif (node->prefixlen != matchlen ||",
            "\t\t    node->prefixlen == key->prefixlen)",
            "\t\t\tbreak;",
            "",
            "\t\tparent = node;",
            "\t\ttrim2 = trim;",
            "\t\tnext_bit = extract_bit(key->data, node->prefixlen);",
            "\t\ttrim = &node->child[next_bit];",
            "\t}",
            "",
            "\tif (!node || node->prefixlen != key->prefixlen ||",
            "\t    node->prefixlen != matchlen ||",
            "\t    (node->flags & LPM_TREE_NODE_FLAG_IM)) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\ttrie->n_entries--;",
            "",
            "\t/* If the node we are removing has two children, simply mark it",
            "\t * as intermediate and we are done.",
            "\t */",
            "\tif (rcu_access_pointer(node->child[0]) &&",
            "\t    rcu_access_pointer(node->child[1])) {",
            "\t\tnode->flags |= LPM_TREE_NODE_FLAG_IM;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* If the parent of the node we are about to delete is an intermediate",
            "\t * node, and the deleted node doesn't have any children, we can delete",
            "\t * the intermediate parent as well and promote its other child",
            "\t * up the tree.  Doing this maintains the invariant that all",
            "\t * intermediate nodes have exactly 2 children and that there are no",
            "\t * unnecessary intermediate nodes in the tree.",
            "\t */",
            "\tif (parent && (parent->flags & LPM_TREE_NODE_FLAG_IM) &&",
            "\t    !node->child[0] && !node->child[1]) {",
            "\t\tif (node == rcu_access_pointer(parent->child[0]))",
            "\t\t\trcu_assign_pointer(",
            "\t\t\t\t*trim2, rcu_access_pointer(parent->child[1]));",
            "\t\telse",
            "\t\t\trcu_assign_pointer(",
            "\t\t\t\t*trim2, rcu_access_pointer(parent->child[0]));",
            "\t\tfree_parent = parent;",
            "\t\tfree_node = node;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/* The node we are removing has either zero or one child. If there",
            "\t * is a child, move it into the removed node's slot then delete",
            "\t * the node.  Otherwise just clear the slot and delete the node.",
            "\t */",
            "\tif (node->child[0])",
            "\t\trcu_assign_pointer(*trim, rcu_access_pointer(node->child[0]));",
            "\telse if (node->child[1])",
            "\t\trcu_assign_pointer(*trim, rcu_access_pointer(node->child[1]));",
            "\telse",
            "\t\tRCU_INIT_POINTER(*trim, NULL);",
            "\tfree_node = node;",
            "",
            "out:",
            "\tspin_unlock_irqrestore(&trie->lock, irq_flags);",
            "\tkfree_rcu(free_parent, rcu);",
            "\tkfree_rcu(free_node, rcu);",
            "",
            "\treturn ret;",
            "}",
            "static void trie_free(struct bpf_map *map)",
            "{",
            "\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);",
            "\tstruct lpm_trie_node __rcu **slot;",
            "\tstruct lpm_trie_node *node;",
            "",
            "\t/* Always start at the root and walk down to a node that has no",
            "\t * children. Then free that node, nullify its reference in the parent",
            "\t * and start over.",
            "\t */",
            "",
            "\tfor (;;) {",
            "\t\tslot = &trie->root;",
            "",
            "\t\tfor (;;) {",
            "\t\t\tnode = rcu_dereference_protected(*slot, 1);",
            "\t\t\tif (!node)",
            "\t\t\t\tgoto out;",
            "",
            "\t\t\tif (rcu_access_pointer(node->child[0])) {",
            "\t\t\t\tslot = &node->child[0];",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\tif (rcu_access_pointer(node->child[1])) {",
            "\t\t\t\tslot = &node->child[1];",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\tkfree(node);",
            "\t\t\tRCU_INIT_POINTER(*slot, NULL);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "out:",
            "\tbpf_map_area_free(trie);",
            "}"
          ],
          "function_name": "trie_delete_elem, trie_free",
          "description": "提供了删除元素（trie_delete_elem）和销毁树（trie_free）的功能。删除时会判断节点是否为中间节点并进行相应调整，销毁时通过RCU机制安全地遍历并释放所有节点内存。",
          "similarity": 0.44711410999298096
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/lpm_trie.c",
          "start_line": 741,
          "end_line": 749,
          "content": [
            "static u64 trie_mem_usage(const struct bpf_map *map)",
            "{",
            "\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);",
            "\tu64 elem_size;",
            "",
            "\telem_size = sizeof(struct lpm_trie_node) + trie->data_size +",
            "\t\t\t    trie->map.value_size;",
            "\treturn elem_size * READ_ONCE(trie->n_entries);",
            "}"
          ],
          "function_name": "trie_mem_usage",
          "description": "计算并返回当前Trie占用的内存量（trie_mem_usage），基于节点大小（含动态数据区域）与元素数量的乘积，用于监控内存使用情况。",
          "similarity": 0.44150829315185547
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_events_filter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:18:57\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_events_filter.c`\n\n---\n\n# trace_events_filter.c 技术文档\n\n## 1. 文件概述\n\n`trace_events_filter.c` 是 Linux 内核中用于实现通用事件过滤（event filtering）功能的核心文件。它为 ftrace 事件跟踪系统提供了一套灵活的表达式解析和执行机制，允许用户通过逻辑表达式（支持 `&&`、`||`、`!` 等操作符）对跟踪事件进行动态过滤。该模块支持对事件字段进行数值比较、字符串匹配、位运算以及 CPU 掩码过滤等多种操作，广泛应用于性能分析、调试和系统监控场景。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct filter_pred`**  \n  表示一个过滤谓词（predicate），包含：\n  - 字段指针（`field`）\n  - 比较值（`val`, `val2`）\n  - 操作符（`op`，如 `==`, `<`, `&` 等）\n  - 谓词执行函数类型（`fn_num`）\n  - 正则表达式（`regex`）或 CPU 掩码（`mask`）\n  - 取反标志（`not`）\n\n- **`struct prog_entry`**  \n  表示过滤程序中的一个指令条目，用于构建基于跳转的执行逻辑：\n  - `pred`：关联的谓词\n  - `when_to_branch`：分支条件（0 或 1）\n  - `target`：跳转目标索引\n\n- **`struct filter_parse_error`**  \n  用于记录表达式解析过程中的错误类型和位置。\n\n- **`enum filter_op_ids` 和 `enum filter_pred_fn`**  \n  定义支持的操作符（如 `OP_EQ`, `OP_GT`）和谓词执行函数类型（如 `FILTER_PRED_FN_U64`, `FILTER_PRED_FN_STRING`）。\n\n- **错误码枚举（`FILT_ERR_*`）**  \n  定义了 20 余种解析和语义错误，如 `FIELD_NOT_FOUND`、`INVALID_OP`、`MISSING_QUOTE` 等。\n\n### 关键函数/逻辑\n\n- **`is_not()`**  \n  判断 `!` 是否表示逻辑取反（排除 `!=` 和 `!~` 的情况）。\n\n- **`update_preds()`**  \n  在构建过滤程序时动态更新跳转目标，用于处理 `&&` 和 `||` 的优先级和短路求值。\n\n- **`free_predicate()`**  \n  释放谓词结构及其关联资源（正则、CPU 掩码等）。\n\n- **表达式解析器框架**  \n  支持回调函数 `parse_pred_fn`，允许不同事件类型自定义谓词解析逻辑。\n\n## 3. 关键实现\n\n### 表达式解析与程序生成\n\n该文件实现了一个两阶段的逻辑表达式处理机制：\n\n1. **词法与语法解析**：将用户输入的字符串（如 `\"pid > 100 && comm == 'bash'\"`）解析为操作符、字段名和值的序列。\n2. **程序生成**：将逻辑表达式转换为线性“程序”（`prog_entry` 数组），通过条件跳转模拟 `&&`（短路与）和 `||`（短路或）的语义。\n\n例如，表达式 `a && !b || c` 被编译为类似以下的跳转逻辑：\n```text\neval a; if false goto L2\neval b; if true  goto L2\nreturn true\nL2: eval c; if false goto FAIL\nreturn true\nFAIL: return false\n```\n\n### 操作符优先级处理\n\n通过宏 `OPS` 定义操作符顺序，特别要求 `<=` 在 `<` 之前、`>=` 在 `>` 之前，以确保词法分析时长操作符优先匹配。\n\n### 取反逻辑（`!`）处理\n\n使用栈和 `invert` 标志跟踪当前作用域内的取反层数。每遇到一个 `!` 就翻转 `invert`，括号会将当前 `invert` 值压栈，确保作用域隔离。\n\n### 多类型谓词支持\n\n通过 `filter_pred_fn` 枚举区分不同数据类型的比较函数（如 8/16/32/64 位有无符号整数、字符串、CPU 掩码、函数指针等），实现类型安全的字段比较。\n\n### 错误报告机制\n\n提供详细的错误码和位置信息（`filter_parse_error`），便于用户调试无效过滤表达式。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `trace.h` / `trace_output.h`：ftrace 核心接口和事件定义\n  - `linux/slab.h`：内存分配（`kmalloc`/`kfree`）\n  - `linux/ctype.h`：字符处理\n  - `linux/perf_event.h`：与 perf 事件子系统集成\n  - `linux/uaccess.h`：用户空间数据访问\n\n- **模块依赖**：\n  - 依赖 ftrace 事件注册机制（`ftrace_event_field`）\n  - 与 `trace_events.c` 协同工作，提供过滤能力\n  - 被 perf 和 ftrace 用户接口（如 `/sys/kernel/debug/tracing/events/.../filter`）调用\n\n## 5. 使用场景\n\n- **动态事件过滤**：用户通过写入 `/sys/kernel/debug/tracing/events/<subsys>/<event>/filter` 设置过滤条件，仅记录满足条件的事件。\n- **全局过滤**：通过 `set_event_filter` 设置跨多个事件的统一过滤规则。\n- **性能分析**：在高负载系统中减少无关事件的记录开销，提升跟踪效率。\n- **调试特定行为**：例如 `filter='pid == 1234'` 仅跟踪指定进程的事件，或 `filter='latency > 1000'` 捕获高延迟操作。\n- **安全与审计**：结合字段值过滤实现细粒度的系统行为监控。",
      "similarity": 0.5393797755241394,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 862,
          "end_line": 968,
          "content": [
            "static int filter_pred_pchar(struct filter_pred *pred, void *event)",
            "{",
            "\tchar **addr = (char **)(event + pred->offset);",
            "\tchar *str;",
            "",
            "\tstr = test_string(*addr);",
            "\tif (!str)",
            "\t\treturn 0;",
            "",
            "\treturn filter_pchar(pred, str);",
            "}",
            "static int filter_pred_pchar_user(struct filter_pred *pred, void *event)",
            "{",
            "\tchar **addr = (char **)(event + pred->offset);",
            "\tchar *str;",
            "",
            "\tstr = test_ustring(*addr);",
            "\tif (!str)",
            "\t\treturn 0;",
            "",
            "\treturn filter_pchar(pred, str);",
            "}",
            "static int filter_pred_strloc(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 str_item = *(u32 *)(event + pred->offset);",
            "\tint str_loc = str_item & 0xffff;",
            "\tint str_len = str_item >> 16;",
            "\tchar *addr = (char *)(event + str_loc);",
            "\tint cmp, match;",
            "",
            "\tcmp = pred->regex->match(addr, pred->regex, str_len);",
            "",
            "\tmatch = cmp ^ pred->not;",
            "",
            "\treturn match;",
            "}",
            "static int filter_pred_strrelloc(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 *item = (u32 *)(event + pred->offset);",
            "\tu32 str_item = *item;",
            "\tint str_loc = str_item & 0xffff;",
            "\tint str_len = str_item >> 16;",
            "\tchar *addr = (char *)(&item[1]) + str_loc;",
            "\tint cmp, match;",
            "",
            "\tcmp = pred->regex->match(addr, pred->regex, str_len);",
            "",
            "\tmatch = cmp ^ pred->not;",
            "",
            "\treturn match;",
            "}",
            "static int filter_pred_cpu(struct filter_pred *pred, void *event)",
            "{",
            "\tint cpu, cmp;",
            "",
            "\tcpu = raw_smp_processor_id();",
            "\tcmp = pred->val;",
            "",
            "\tswitch (pred->op) {",
            "\tcase OP_EQ:",
            "\t\treturn cpu == cmp;",
            "\tcase OP_NE:",
            "\t\treturn cpu != cmp;",
            "\tcase OP_LT:",
            "\t\treturn cpu < cmp;",
            "\tcase OP_LE:",
            "\t\treturn cpu <= cmp;",
            "\tcase OP_GT:",
            "\t\treturn cpu > cmp;",
            "\tcase OP_GE:",
            "\t\treturn cpu >= cmp;",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}",
            "static int filter_pred_cpu_cpumask(struct filter_pred *pred, void *event)",
            "{",
            "\tint cpu = raw_smp_processor_id();",
            "",
            "\treturn do_filter_scalar_cpumask(pred->op, cpu, pred->mask);",
            "}",
            "static int filter_pred_cpumask(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 item = *(u32 *)(event + pred->offset);",
            "\tint loc = item & 0xffff;",
            "\tconst struct cpumask *mask = (event + loc);",
            "\tconst struct cpumask *cmp = pred->mask;",
            "",
            "\treturn do_filter_cpumask(pred->op, mask, cmp);",
            "}",
            "static int filter_pred_cpumask_cpu(struct filter_pred *pred, void *event)",
            "{",
            "\tu32 item = *(u32 *)(event + pred->offset);",
            "\tint loc = item & 0xffff;",
            "\tconst struct cpumask *mask = (event + loc);",
            "\tunsigned int cpu = pred->val;",
            "",
            "\treturn do_filter_cpumask_scalar(pred->op, mask, cpu);",
            "}",
            "static int filter_pred_comm(struct filter_pred *pred, void *event)",
            "{",
            "\tint cmp;",
            "",
            "\tcmp = pred->regex->match(current->comm, pred->regex,",
            "\t\t\t\tTASK_COMM_LEN);",
            "\treturn cmp ^ pred->not;",
            "}"
          ],
          "function_name": "filter_pred_pchar, filter_pred_pchar_user, filter_pred_strloc, filter_pred_strrelloc, filter_pred_cpu, filter_pred_cpu_cpumask, filter_pred_cpumask, filter_pred_cpumask_cpu, filter_pred_comm",
          "description": "提供针对字符串、位置、进程名等特殊数据类型的过滤实现，处理指针解引用和内存地址匹配。",
          "similarity": 0.5606563091278076
        },
        {
          "chunk_id": 11,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 2543,
          "end_line": 2647,
          "content": [
            "static int ftrace_function_set_filter_pred(struct filter_pred *pred,",
            "\t\t\t\t\t   struct function_filter_data *data)",
            "{",
            "\tint ret;",
            "",
            "\t/* Checking the node is valid for function trace. */",
            "\tret = ftrace_function_check_pred(pred);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn __ftrace_function_set_filter(pred->op == OP_EQ,",
            "\t\t\t\t\t    pred->regex->pattern,",
            "\t\t\t\t\t    pred->regex->len,",
            "\t\t\t\t\t    data);",
            "}",
            "static bool is_or(struct prog_entry *prog, int i)",
            "{",
            "\tint target;",
            "",
            "\t/*",
            "\t * Only \"||\" is allowed for function events, thus,",
            "\t * all true branches should jump to true, and any",
            "\t * false branch should jump to false.",
            "\t */",
            "\ttarget = prog[i].target + 1;",
            "\t/* True and false have NULL preds (all prog entries should jump to one */",
            "\tif (prog[target].pred)",
            "\t\treturn false;",
            "",
            "\t/* prog[target].target is 1 for TRUE, 0 for FALSE */",
            "\treturn prog[i].when_to_branch == prog[target].target;",
            "}",
            "static int ftrace_function_set_filter(struct perf_event *event,",
            "\t\t\t\t      struct event_filter *filter)",
            "{",
            "\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,",
            "\t\t\t\t\t\tlockdep_is_held(&event_mutex));",
            "\tstruct function_filter_data data = {",
            "\t\t.first_filter  = 1,",
            "\t\t.first_notrace = 1,",
            "\t\t.ops           = &event->ftrace_ops,",
            "\t};",
            "\tint i;",
            "",
            "\tfor (i = 0; prog[i].pred; i++) {",
            "\t\tstruct filter_pred *pred = prog[i].pred;",
            "",
            "\t\tif (!is_or(prog, i))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (ftrace_function_set_filter_pred(pred, &data) < 0)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int ftrace_function_set_filter(struct perf_event *event,",
            "\t\t\t\t      struct event_filter *filter)",
            "{",
            "\treturn -ENODEV;",
            "}",
            "int ftrace_profile_set_filter(struct perf_event *event, int event_id,",
            "\t\t\t      char *filter_str)",
            "{",
            "\tint err;",
            "\tstruct event_filter *filter = NULL;",
            "\tstruct trace_event_call *call;",
            "",
            "\tmutex_lock(&event_mutex);",
            "",
            "\tcall = event->tp_event;",
            "",
            "\terr = -EINVAL;",
            "\tif (!call)",
            "\t\tgoto out_unlock;",
            "",
            "\terr = -EEXIST;",
            "\tif (event->filter)",
            "\t\tgoto out_unlock;",
            "",
            "\terr = create_filter(NULL, call, filter_str, false, &filter);",
            "\tif (err)",
            "\t\tgoto free_filter;",
            "",
            "\tif (ftrace_event_is_function(call))",
            "\t\terr = ftrace_function_set_filter(event, filter);",
            "\telse",
            "\t\tevent->filter = filter;",
            "",
            "free_filter:",
            "\tif (err || ftrace_event_is_function(call))",
            "\t\t__free_filter(filter);",
            "",
            "out_unlock:",
            "\tmutex_unlock(&event_mutex);",
            "",
            "\treturn err;",
            "}",
            "static int test_pred_visited_fn(struct filter_pred *pred, void *event)",
            "{",
            "\tstruct ftrace_event_field *field = pred->field;",
            "",
            "\ttest_pred_visited = 1;",
            "\tprintk(KERN_INFO \"\\npred visited %s\\n\", field->name);",
            "\treturn 1;",
            "}"
          ],
          "function_name": "ftrace_function_set_filter_pred, is_or, ftrace_function_set_filter, ftrace_function_set_filter, ftrace_profile_set_filter, test_pred_visited_fn",
          "description": "ftrace_function_set_filter_pred 将谓词转换为正则表达式并调用底层设置函数；is_or 检查程序流图中节点是否为OR逻辑分支；ftrace_function_set_filter 遍历过滤器谓词链表，校验逻辑结构后应用到函数跟踪；ftrace_profile_set_filter 创建事件过滤器并根据事件类型选择设置方式；test_pred_visited_fn 标记谓词访问状态用于测试",
          "similarity": 0.5279632806777954
        },
        {
          "chunk_id": 10,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 2400,
          "end_line": 2508,
          "content": [
            "int apply_subsystem_event_filter(struct trace_subsystem_dir *dir,",
            "\t\t\t\t char *filter_string)",
            "{",
            "\tstruct event_subsystem *system = dir->subsystem;",
            "\tstruct trace_array *tr = dir->tr;",
            "\tstruct event_filter *filter = NULL;",
            "\tint err = 0;",
            "",
            "\tmutex_lock(&event_mutex);",
            "",
            "\t/* Make sure the system still has events */",
            "\tif (!dir->nr_events) {",
            "\t\terr = -ENODEV;",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\tif (!strcmp(strstrip(filter_string), \"0\")) {",
            "\t\tfilter_free_subsystem_preds(dir, tr);",
            "\t\tremove_filter_string(system->filter);",
            "\t\tfilter = system->filter;",
            "\t\tsystem->filter = NULL;",
            "\t\t/* Ensure all filters are no longer used */",
            "\t\ttracepoint_synchronize_unregister();",
            "\t\tfilter_free_subsystem_filters(dir, tr);",
            "\t\t__free_filter(filter);",
            "\t\tgoto out_unlock;",
            "\t}",
            "",
            "\terr = create_system_filter(dir, filter_string, &filter);",
            "\tif (filter) {",
            "\t\t/*",
            "\t\t * No event actually uses the system filter",
            "\t\t * we can free it without synchronize_rcu().",
            "\t\t */",
            "\t\t__free_filter(system->filter);",
            "\t\tsystem->filter = filter;",
            "\t}",
            "out_unlock:",
            "\tmutex_unlock(&event_mutex);",
            "",
            "\treturn err;",
            "}",
            "void ftrace_profile_free_filter(struct perf_event *event)",
            "{",
            "\tstruct event_filter *filter = event->filter;",
            "",
            "\tevent->filter = NULL;",
            "\t__free_filter(filter);",
            "}",
            "static int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,",
            "\t\t\t\t      int reset, char *re, int len)",
            "{",
            "\tint ret;",
            "",
            "\tif (filter)",
            "\t\tret = ftrace_set_filter(ops, re, len, reset);",
            "\telse",
            "\t\tret = ftrace_set_notrace(ops, re, len, reset);",
            "",
            "\treturn ret;",
            "}",
            "static int __ftrace_function_set_filter(int filter, char *buf, int len,",
            "\t\t\t\t\tstruct function_filter_data *data)",
            "{",
            "\tint i, re_cnt, ret = -EINVAL;",
            "\tint *reset;",
            "\tchar **re;",
            "",
            "\treset = filter ? &data->first_filter : &data->first_notrace;",
            "",
            "\t/*",
            "\t * The 'ip' field could have multiple filters set, separated",
            "\t * either by space or comma. We first cut the filter and apply",
            "\t * all pieces separately.",
            "\t */",
            "\tre = ftrace_function_filter_re(buf, len, &re_cnt);",
            "\tif (!re)",
            "\t\treturn -EINVAL;",
            "",
            "\tfor (i = 0; i < re_cnt; i++) {",
            "\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,",
            "\t\t\t\t\t\t re[i], strlen(re[i]));",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "",
            "\t\tif (*reset)",
            "\t\t\t*reset = 0;",
            "\t}",
            "",
            "\targv_free(re);",
            "\treturn ret;",
            "}",
            "static int ftrace_function_check_pred(struct filter_pred *pred)",
            "{",
            "\tstruct ftrace_event_field *field = pred->field;",
            "",
            "\t/*",
            "\t * Check the predicate for function trace, verify:",
            "\t *  - only '==' and '!=' is used",
            "\t *  - the 'ip' field is used",
            "\t */",
            "\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (strcmp(field->name, \"ip\"))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "apply_subsystem_event_filter, ftrace_profile_free_filter, ftrace_function_set_regexp, __ftrace_function_set_filter, ftrace_function_check_pred",
          "description": "apply_subsystem_event_filter 根据过滤字符串设置子系统级事件过滤器，处理过滤器创建、释放及错误返回；ftrace_profile_free_filter 释放perf_event的过滤器指针；__ftrace_function_set_filter 将过滤字符串分割后依次应用正则表达式到函数跟踪操作；ftrace_function_check_pred 验证谓词操作类型和字段是否符合函数跟踪要求",
          "similarity": 0.5226642489433289
        },
        {
          "chunk_id": 12,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 2741,
          "end_line": 2822,
          "content": [
            "static void update_pred_fn(struct event_filter *filter, char *fields)",
            "{",
            "\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,",
            "\t\t\t\t\t\tlockdep_is_held(&event_mutex));",
            "\tint i;",
            "",
            "\tfor (i = 0; prog[i].pred; i++) {",
            "\t\tstruct filter_pred *pred = prog[i].pred;",
            "\t\tstruct ftrace_event_field *field = pred->field;",
            "",
            "\t\tWARN_ON_ONCE(pred->fn_num == FILTER_PRED_FN_NOP);",
            "",
            "\t\tif (!field) {",
            "\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tif (!strchr(fields, *field->name))",
            "\t\t\tcontinue;",
            "",
            "\t\tpred->fn_num = FILTER_PRED_TEST_VISITED;",
            "\t}",
            "}",
            "static __init int ftrace_test_event_filter(void)",
            "{",
            "\tint i;",
            "",
            "\tprintk(KERN_INFO \"Testing ftrace filter: \");",
            "",
            "\tfor (i = 0; i < DATA_CNT; i++) {",
            "\t\tstruct event_filter *filter = NULL;",
            "\t\tstruct test_filter_data_t *d = &test_filter_data[i];",
            "\t\tint err;",
            "",
            "\t\terr = create_filter(NULL, &event_ftrace_test_filter,",
            "\t\t\t\t    d->filter, false, &filter);",
            "\t\tif (err) {",
            "\t\t\tprintk(KERN_INFO",
            "\t\t\t       \"Failed to get filter for '%s', err %d\\n\",",
            "\t\t\t       d->filter, err);",
            "\t\t\t__free_filter(filter);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* Needed to dereference filter->prog */",
            "\t\tmutex_lock(&event_mutex);",
            "\t\t/*",
            "\t\t * The preemption disabling is not really needed for self",
            "\t\t * tests, but the rcu dereference will complain without it.",
            "\t\t */",
            "\t\tpreempt_disable();",
            "\t\tif (*d->not_visited)",
            "\t\t\tupdate_pred_fn(filter, d->not_visited);",
            "",
            "\t\ttest_pred_visited = 0;",
            "\t\terr = filter_match_preds(filter, &d->rec);",
            "\t\tpreempt_enable();",
            "",
            "\t\tmutex_unlock(&event_mutex);",
            "",
            "\t\t__free_filter(filter);",
            "",
            "\t\tif (test_pred_visited) {",
            "\t\t\tprintk(KERN_INFO",
            "\t\t\t       \"Failed, unwanted pred visited for filter %s\\n\",",
            "\t\t\t       d->filter);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (err != d->match) {",
            "\t\t\tprintk(KERN_INFO",
            "\t\t\t       \"Failed to match filter '%s', expected %d\\n\",",
            "\t\t\t       d->filter, d->match);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tif (i == DATA_CNT)",
            "\t\tprintk(KERN_CONT \"OK\\n\");",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "update_pred_fn, ftrace_test_event_filter",
          "description": "update_pred_fn 更新谓词节点的函数号标记已访问字段；ftrace_test_event_filter 自动测试过滤器匹配逻辑，通过创建过滤器、遍历谓词节点并验证匹配结果判断测试是否通过",
          "similarity": 0.5184466242790222
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/trace_events_filter.c",
          "start_line": 1281,
          "end_line": 1422,
          "content": [
            "static void free_prog(struct event_filter *filter)",
            "{",
            "\tstruct prog_entry *prog;",
            "\tint i;",
            "",
            "\tprog = rcu_access_pointer(filter->prog);",
            "\tif (!prog)",
            "\t\treturn;",
            "",
            "\tfor (i = 0; prog[i].pred; i++)",
            "\t\tfree_predicate(prog[i].pred);",
            "\tkfree(prog);",
            "}",
            "static void filter_disable(struct trace_event_file *file)",
            "{",
            "\tunsigned long old_flags = file->flags;",
            "",
            "\tfile->flags &= ~EVENT_FILE_FL_FILTERED;",
            "",
            "\tif (old_flags != file->flags)",
            "\t\ttrace_buffered_event_disable();",
            "}",
            "static void __free_filter(struct event_filter *filter)",
            "{",
            "\tif (!filter)",
            "\t\treturn;",
            "",
            "\tfree_prog(filter);",
            "\tkfree(filter->filter_string);",
            "\tkfree(filter);",
            "}",
            "void free_event_filter(struct event_filter *filter)",
            "{",
            "\t__free_filter(filter);",
            "}",
            "static inline void __remove_filter(struct trace_event_file *file)",
            "{",
            "\tfilter_disable(file);",
            "\tremove_filter_string(file->filter);",
            "}",
            "static void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,",
            "\t\t\t\t\tstruct trace_array *tr)",
            "{",
            "\tstruct trace_event_file *file;",
            "",
            "\tlist_for_each_entry(file, &tr->events, list) {",
            "\t\tif (file->system != dir)",
            "\t\t\tcontinue;",
            "\t\t__remove_filter(file);",
            "\t}",
            "}",
            "static inline void __free_subsystem_filter(struct trace_event_file *file)",
            "{",
            "\t__free_filter(file->filter);",
            "\tfile->filter = NULL;",
            "}",
            "static void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,",
            "\t\t\t\t\t  struct trace_array *tr)",
            "{",
            "\tstruct trace_event_file *file;",
            "",
            "\tlist_for_each_entry(file, &tr->events, list) {",
            "\t\tif (file->system != dir)",
            "\t\t\tcontinue;",
            "\t\t__free_subsystem_filter(file);",
            "\t}",
            "}",
            "int filter_assign_type(const char *type)",
            "{",
            "\tif (strstr(type, \"__data_loc\")) {",
            "\t\tif (strstr(type, \"char\"))",
            "\t\t\treturn FILTER_DYN_STRING;",
            "\t\tif (strstr(type, \"cpumask_t\"))",
            "\t\t\treturn FILTER_CPUMASK;",
            "\t}",
            "",
            "\tif (strstr(type, \"__rel_loc\") && strstr(type, \"char\"))",
            "\t\treturn FILTER_RDYN_STRING;",
            "",
            "\tif (strchr(type, '[') && strstr(type, \"char\"))",
            "\t\treturn FILTER_STATIC_STRING;",
            "",
            "\tif (strcmp(type, \"char *\") == 0 || strcmp(type, \"const char *\") == 0)",
            "\t\treturn FILTER_PTR_STRING;",
            "",
            "\treturn FILTER_OTHER;",
            "}",
            "static enum filter_pred_fn select_comparison_fn(enum filter_op_ids op,",
            "\t\t\t\t\t\tint field_size, int field_is_signed)",
            "{",
            "\tenum filter_pred_fn fn = FILTER_PRED_FN_NOP;",
            "\tint pred_func_index = -1;",
            "",
            "\tswitch (op) {",
            "\tcase OP_EQ:",
            "\tcase OP_NE:",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))",
            "\t\t\treturn fn;",
            "\t\tpred_func_index = op - PRED_FUNC_START;",
            "\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))",
            "\t\t\treturn fn;",
            "\t}",
            "",
            "\tswitch (field_size) {",
            "\tcase 8:",
            "\t\tif (pred_func_index < 0)",
            "\t\t\tfn = FILTER_PRED_FN_64;",
            "\t\telse if (field_is_signed)",
            "\t\t\tfn = FILTER_PRED_FN_S64;",
            "\t\telse",
            "\t\t\tfn = FILTER_PRED_FN_U64;",
            "\t\tbreak;",
            "\tcase 4:",
            "\t\tif (pred_func_index < 0)",
            "\t\t\tfn = FILTER_PRED_FN_32;",
            "\t\telse if (field_is_signed)",
            "\t\t\tfn = FILTER_PRED_FN_S32;",
            "\t\telse",
            "\t\t\tfn = FILTER_PRED_FN_U32;",
            "\t\tbreak;",
            "\tcase 2:",
            "\t\tif (pred_func_index < 0)",
            "\t\t\tfn = FILTER_PRED_FN_16;",
            "\t\telse if (field_is_signed)",
            "\t\t\tfn = FILTER_PRED_FN_S16;",
            "\t\telse",
            "\t\t\tfn = FILTER_PRED_FN_U16;",
            "\t\tbreak;",
            "\tcase 1:",
            "\t\tif (pred_func_index < 0)",
            "\t\t\tfn = FILTER_PRED_FN_8;",
            "\t\telse if (field_is_signed)",
            "\t\t\tfn = FILTER_PRED_FN_S8;",
            "\t\telse",
            "\t\t\tfn = FILTER_PRED_FN_U8;",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn fn;",
            "}"
          ],
          "function_name": "free_prog, filter_disable, __free_filter, free_event_filter, __remove_filter, filter_free_subsystem_preds, __free_subsystem_filter, filter_free_subsystem_filters, filter_assign_type, select_comparison_fn",
          "description": "实现事件过滤器资源释放逻辑，包括释放predicate、过滤字符串和过滤器结构体，处理子系统过滤器的遍历和销毁，定义字段类型判断函数及比较函数选择逻辑",
          "similarity": 0.5164380073547363
        }
      ]
    }
  ]
}