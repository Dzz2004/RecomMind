{
  "query": "kernel module replacement",
  "timestamp": "2025-12-26 01:56:42",
  "retrieved_files": [
    {
      "source_file": "kernel/kexec_core.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:23:56\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `kexec_core.c`\n\n---\n\n# kexec_core.c 技术文档\n\n## 1. 文件概述\n\n`kexec_core.c` 是 Linux 内核中 `kexec` 系统调用的核心实现文件，负责管理内核热替换（kexec）过程中的内存布局、段验证、控制结构初始化等关键逻辑。该文件为用户空间通过 `kexec_load` 或 `kexec_file_load` 系统调用加载新内核镜像提供底层支持，并确保加载过程的安全性和正确性。kexec 允许在不经过固件（如 BIOS/UEFI）重启的情况下直接跳转到新内核，常用于快速重启、崩溃转储（crash dump）等场景。\n\n## 2. 核心功能\n\n### 主要全局变量\n- `atomic_t __kexec_lock`：原子锁，用于防止多个 kexec 操作并发执行。\n- `bool kexec_in_progress`：标志位，指示当前是否正在进行 kexec 操作。\n- `bool kexec_file_dbg_print`：调试开关，控制是否打印 kexec 文件加载的调试信息。\n\n### 主要宏定义\n- `KIMAGE_NO_DEST`：表示无需指定目标地址的特殊值（`-1UL`）。\n- `PAGE_COUNT(x)`：计算给定字节数所需的页数。\n\n### 主要函数\n- `sanity_check_segment_list(struct kimage *image)`：验证用户提供的内核镜像段列表的合法性，包括地址对齐、范围限制、重叠检测、内存用量限制等。\n- `do_kimage_alloc_init(void)`：分配并初始化 `kimage` 控制结构，用于描述待加载的新内核镜像。\n- `kimage_is_destination_range(struct kimage *image, unsigned long start, unsigned long end)`：检查指定物理地址范围是否与镜像的目标加载段重叠（函数未完整，但用途明确）。\n\n### 核心数据结构\n- `struct kimage`：kexec 镜像的核心控制结构，包含段信息、控制页、目标页、不可用页等列表，以及镜像类型（普通或崩溃转储）等元数据。\n\n## 3. 关键实现\n\n### 段合法性验证（`sanity_check_segment_list`）\n该函数执行多层验证：\n1. **地址对齐与范围检查**：所有段的起始/结束地址必须页对齐，且不能超过架构定义的 `KEXEC_DESTINATION_MEMORY_LIMIT`。\n2. **段间重叠检测**：遍历所有段对，确保任意两个段的目标内存区域不重叠。\n3. **缓冲区大小约束**：每个段的源数据大小（`bufsz`）不得超过目标内存大小（`memsz`）。\n4. **内存用量限制**：单个段或所有段总页数不得超过系统总 RAM 页数的一半，防止因过度分配导致软锁定（soft lockup）。\n5. **崩溃内核特殊处理**（`CONFIG_CRASH_DUMP`）：若为崩溃转储类型（`KEXEC_TYPE_CRASH`），所有段必须严格位于预留的崩溃内核内存区域（`crashk_res`）内。\n\n### kimage 结构初始化（`do_kimage_alloc_init`）\n- 分配零初始化的 `kimage` 结构。\n- 初始化段链表头（`head`, `entry`, `last_entry`）。\n- 初始化三个关键页列表：\n  - `control_pages`：存放跳转到新内核所需的汇编 stub 代码页。\n  - `dest_pages`：存放新内核的目标加载页。\n  - `unusable_pages`：存放因冲突等原因无法使用的页。\n- 若启用 `CONFIG_CRASH_HOTPLUG`，初始化热插拔相关字段。\n\n### 内存模型约束\n- kexec 跳转阶段要求物理地址与虚拟地址一一映射（identity mapping），因此控制代码必须位于 `0 - TASK_SIZE` 范围内。\n- 仅支持物理地址可表示为 `unsigned long` 的内存（即 `(pfn << PAGE_SHIFT) <= ULONG_MAX`）。\n- 架构可通过 `KEXEC_SOURCE_MEMORY_LIMIT` 和 `KEXEC_DEST_MEMORY_LIMIT` 进一步限制内存使用范围。\n\n## 4. 依赖关系\n\n### 头文件依赖\n- **内核核心子系统**：`mm.h`（内存管理）、`fs.h`（文件系统）、`slab.h`（内存分配）、`reboot.h`（重启逻辑）、`cpu.h`（CPU 热插拔）。\n- **架构相关**：`asm/page.h`、`asm/sections.h`、`asm/kexec.h`（提供 `KEXEC_*_MEMORY_LIMIT` 等宏）。\n- **安全与能力**：`capability.h`（权限检查）、`crypto/hash.h`（镜像校验）。\n- **调试与日志**：`kmsg_dump.h`（崩溃日志转储）、`console.h`（控制台管理）。\n- **内部头文件**：`kexec_internal.h`（kexec 内部接口）。\n\n### 配置选项依赖\n- `CONFIG_KEXEC`：kexec 基础功能。\n- `CONFIG_CRASH_DUMP`：崩溃转储支持，影响段验证逻辑。\n- `CONFIG_CRASH_HOTPLUG`：崩溃内核热插拔支持，扩展 `kimage` 结构。\n\n## 5. 使用场景\n\n1. **常规内核热替换**：通过 `kexec_load` 系统调用加载新内核，执行快速重启（绕过固件初始化）。\n2. **崩溃转储（kdump）**：系统崩溃时，通过预加载的 `KEXEC_TYPE_CRASH` 类型镜像捕获内存转储（vmcore），用于事后分析。\n3. **内核更新与测试**：开发或运维中快速切换内核版本，无需硬件重启。\n4. **高可用系统**：在关键服务中实现内核级故障恢复，减少停机时间。\n\n该文件作为 kexec 机制的核心，为上述场景提供安全、可靠的内存管理和镜像加载基础，确保新内核能正确接管系统控制权。",
      "similarity": 0.5149083137512207,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/kexec_core.c",
          "start_line": 847,
          "end_line": 1014,
          "content": [
            "int kimage_load_segment(struct kimage *image,",
            "\t\t\t\tstruct kexec_segment *segment)",
            "{",
            "\tint result = -ENOMEM;",
            "",
            "\tswitch (image->type) {",
            "\tcase KEXEC_TYPE_DEFAULT:",
            "\t\tresult = kimage_load_normal_segment(image, segment);",
            "\t\tbreak;",
            "#ifdef CONFIG_CRASH_DUMP",
            "\tcase KEXEC_TYPE_CRASH:",
            "\t\tresult = kimage_load_crash_segment(image, segment);",
            "\t\tbreak;",
            "#endif",
            "\t}",
            "",
            "\treturn result;",
            "}",
            "static int kexec_limit_handler(struct ctl_table *table, int write,",
            "\t\t\t       void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct kexec_load_limit *limit = table->data;",
            "\tint val;",
            "\tstruct ctl_table tmp = {",
            "\t\t.data = &val,",
            "\t\t.maxlen = sizeof(val),",
            "\t\t.mode = table->mode,",
            "\t};",
            "\tint ret;",
            "",
            "\tif (write) {",
            "\t\tret = proc_dointvec(&tmp, write, buffer, lenp, ppos);",
            "\t\tif (ret)",
            "\t\t\treturn ret;",
            "",
            "\t\tif (val < 0)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tmutex_lock(&limit->mutex);",
            "\t\tif (limit->limit != -1 && val >= limit->limit)",
            "\t\t\tret = -EINVAL;",
            "\t\telse",
            "\t\t\tlimit->limit = val;",
            "\t\tmutex_unlock(&limit->mutex);",
            "",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tmutex_lock(&limit->mutex);",
            "\tval = limit->limit;",
            "\tmutex_unlock(&limit->mutex);",
            "",
            "\treturn proc_dointvec(&tmp, write, buffer, lenp, ppos);",
            "}",
            "static int __init kexec_core_sysctl_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel\", kexec_core_sysctls);",
            "\treturn 0;",
            "}",
            "bool kexec_load_permitted(int kexec_image_type)",
            "{",
            "\tstruct kexec_load_limit *limit;",
            "",
            "\t/*",
            "\t * Only the superuser can use the kexec syscall and if it has not",
            "\t * been disabled.",
            "\t */",
            "\tif (!capable(CAP_SYS_BOOT) || kexec_load_disabled)",
            "\t\treturn false;",
            "",
            "\t/* Check limit counter and decrease it.*/",
            "\tlimit = (kexec_image_type == KEXEC_TYPE_CRASH) ?",
            "\t\t&load_limit_panic : &load_limit_reboot;",
            "\tmutex_lock(&limit->mutex);",
            "\tif (!limit->limit) {",
            "\t\tmutex_unlock(&limit->mutex);",
            "\t\treturn false;",
            "\t}",
            "\tif (limit->limit != -1)",
            "\t\tlimit->limit--;",
            "\tmutex_unlock(&limit->mutex);",
            "",
            "\treturn true;",
            "}",
            "int kernel_kexec(void)",
            "{",
            "\tint error = 0;",
            "",
            "\tif (!kexec_trylock())",
            "\t\treturn -EBUSY;",
            "\tif (!kexec_image) {",
            "\t\terror = -EINVAL;",
            "\t\tgoto Unlock;",
            "\t}",
            "",
            "#ifdef CONFIG_KEXEC_JUMP",
            "\tif (kexec_image->preserve_context) {",
            "\t\tpm_prepare_console();",
            "\t\terror = freeze_processes();",
            "\t\tif (error) {",
            "\t\t\terror = -EBUSY;",
            "\t\t\tgoto Restore_console;",
            "\t\t}",
            "\t\tsuspend_console();",
            "\t\terror = dpm_suspend_start(PMSG_FREEZE);",
            "\t\tif (error)",
            "\t\t\tgoto Resume_console;",
            "\t\t/* At this point, dpm_suspend_start() has been called,",
            "\t\t * but *not* dpm_suspend_end(). We *must* call",
            "\t\t * dpm_suspend_end() now.  Otherwise, drivers for",
            "\t\t * some devices (e.g. interrupt controllers) become",
            "\t\t * desynchronized with the actual state of the",
            "\t\t * hardware at resume time, and evil weirdness ensues.",
            "\t\t */",
            "\t\terror = dpm_suspend_end(PMSG_FREEZE);",
            "\t\tif (error)",
            "\t\t\tgoto Resume_devices;",
            "\t\terror = suspend_disable_secondary_cpus();",
            "\t\tif (error)",
            "\t\t\tgoto Enable_cpus;",
            "\t\tlocal_irq_disable();",
            "\t\terror = syscore_suspend();",
            "\t\tif (error)",
            "\t\t\tgoto Enable_irqs;",
            "\t} else",
            "#endif",
            "\t{",
            "\t\tkexec_in_progress = true;",
            "\t\tkernel_restart_prepare(\"kexec reboot\");",
            "\t\tmigrate_to_reboot_cpu();",
            "\t\tsyscore_shutdown();",
            "",
            "\t\t/*",
            "\t\t * migrate_to_reboot_cpu() disables CPU hotplug assuming that",
            "\t\t * no further code needs to use CPU hotplug (which is true in",
            "\t\t * the reboot case). However, the kexec path depends on using",
            "\t\t * CPU hotplug again; so re-enable it here.",
            "\t\t */",
            "\t\tcpu_hotplug_enable();",
            "\t\tpr_notice(\"Starting new kernel\\n\");",
            "\t\tmachine_shutdown();",
            "\t}",
            "",
            "\tkmsg_dump(KMSG_DUMP_SHUTDOWN);",
            "\tmachine_kexec(kexec_image);",
            "",
            "#ifdef CONFIG_KEXEC_JUMP",
            "\tif (kexec_image->preserve_context) {",
            "\t\tsyscore_resume();",
            " Enable_irqs:",
            "\t\tlocal_irq_enable();",
            " Enable_cpus:",
            "\t\tsuspend_enable_secondary_cpus();",
            "\t\tdpm_resume_start(PMSG_RESTORE);",
            " Resume_devices:",
            "\t\tdpm_resume_end(PMSG_RESTORE);",
            " Resume_console:",
            "\t\tresume_console();",
            "\t\tthaw_processes();",
            " Restore_console:",
            "\t\tpm_restore_console();",
            "\t}",
            "#endif",
            "",
            " Unlock:",
            "\tkexec_unlock();",
            "\treturn error;",
            "}"
          ],
          "function_name": "kimage_load_segment, kexec_limit_handler, kexec_core_sysctl_init, kexec_load_permitted, kernel_kexec",
          "description": "整合kexec核心流程，包含段加载调度、系统控制参数限制管理、权限验证及实际重启执行路径，协调硬件状态转换和内核切换操作。",
          "similarity": 0.5014373064041138
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/kexec_core.c",
          "start_line": 709,
          "end_line": 842,
          "content": [
            "static int kimage_load_normal_segment(struct kimage *image,",
            "\t\t\t\t\t struct kexec_segment *segment)",
            "{",
            "\tunsigned long maddr;",
            "\tsize_t ubytes, mbytes;",
            "\tint result;",
            "\tunsigned char __user *buf = NULL;",
            "\tunsigned char *kbuf = NULL;",
            "",
            "\tif (image->file_mode)",
            "\t\tkbuf = segment->kbuf;",
            "\telse",
            "\t\tbuf = segment->buf;",
            "\tubytes = segment->bufsz;",
            "\tmbytes = segment->memsz;",
            "\tmaddr = segment->mem;",
            "",
            "\tresult = kimage_set_destination(image, maddr);",
            "\tif (result < 0)",
            "\t\tgoto out;",
            "",
            "\twhile (mbytes) {",
            "\t\tstruct page *page;",
            "\t\tchar *ptr;",
            "\t\tsize_t uchunk, mchunk;",
            "",
            "\t\tpage = kimage_alloc_page(image, GFP_HIGHUSER, maddr);",
            "\t\tif (!page) {",
            "\t\t\tresult  = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tresult = kimage_add_page(image, page_to_boot_pfn(page)",
            "\t\t\t\t\t\t\t\t<< PAGE_SHIFT);",
            "\t\tif (result < 0)",
            "\t\t\tgoto out;",
            "",
            "\t\tptr = kmap_local_page(page);",
            "\t\t/* Start with a clear page */",
            "\t\tclear_page(ptr);",
            "\t\tptr += maddr & ~PAGE_MASK;",
            "\t\tmchunk = min_t(size_t, mbytes,",
            "\t\t\t\tPAGE_SIZE - (maddr & ~PAGE_MASK));",
            "\t\tuchunk = min(ubytes, mchunk);",
            "",
            "\t\t/* For file based kexec, source pages are in kernel memory */",
            "\t\tif (image->file_mode)",
            "\t\t\tmemcpy(ptr, kbuf, uchunk);",
            "\t\telse",
            "\t\t\tresult = copy_from_user(ptr, buf, uchunk);",
            "\t\tkunmap_local(ptr);",
            "\t\tif (result) {",
            "\t\t\tresult = -EFAULT;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tubytes -= uchunk;",
            "\t\tmaddr  += mchunk;",
            "\t\tif (image->file_mode)",
            "\t\t\tkbuf += mchunk;",
            "\t\telse",
            "\t\t\tbuf += mchunk;",
            "\t\tmbytes -= mchunk;",
            "",
            "\t\tcond_resched();",
            "\t}",
            "out:",
            "\treturn result;",
            "}",
            "static int kimage_load_crash_segment(struct kimage *image,",
            "\t\t\t\t\tstruct kexec_segment *segment)",
            "{",
            "\t/* For crash dumps kernels we simply copy the data from",
            "\t * user space to it's destination.",
            "\t * We do things a page at a time for the sake of kmap.",
            "\t */",
            "\tunsigned long maddr;",
            "\tsize_t ubytes, mbytes;",
            "\tint result;",
            "\tunsigned char __user *buf = NULL;",
            "\tunsigned char *kbuf = NULL;",
            "",
            "\tresult = 0;",
            "\tif (image->file_mode)",
            "\t\tkbuf = segment->kbuf;",
            "\telse",
            "\t\tbuf = segment->buf;",
            "\tubytes = segment->bufsz;",
            "\tmbytes = segment->memsz;",
            "\tmaddr = segment->mem;",
            "\twhile (mbytes) {",
            "\t\tstruct page *page;",
            "\t\tchar *ptr;",
            "\t\tsize_t uchunk, mchunk;",
            "",
            "\t\tpage = boot_pfn_to_page(maddr >> PAGE_SHIFT);",
            "\t\tif (!page) {",
            "\t\t\tresult  = -ENOMEM;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tarch_kexec_post_alloc_pages(page_address(page), 1, 0);",
            "\t\tptr = kmap_local_page(page);",
            "\t\tptr += maddr & ~PAGE_MASK;",
            "\t\tmchunk = min_t(size_t, mbytes,",
            "\t\t\t\tPAGE_SIZE - (maddr & ~PAGE_MASK));",
            "\t\tuchunk = min(ubytes, mchunk);",
            "\t\tif (mchunk > uchunk) {",
            "\t\t\t/* Zero the trailing part of the page */",
            "\t\t\tmemset(ptr + uchunk, 0, mchunk - uchunk);",
            "\t\t}",
            "",
            "\t\t/* For file based kexec, source pages are in kernel memory */",
            "\t\tif (image->file_mode)",
            "\t\t\tmemcpy(ptr, kbuf, uchunk);",
            "\t\telse",
            "\t\t\tresult = copy_from_user(ptr, buf, uchunk);",
            "\t\tkexec_flush_icache_page(page);",
            "\t\tkunmap_local(ptr);",
            "\t\tarch_kexec_pre_free_pages(page_address(page), 1);",
            "\t\tif (result) {",
            "\t\t\tresult = -EFAULT;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tubytes -= uchunk;",
            "\t\tmaddr  += mchunk;",
            "\t\tif (image->file_mode)",
            "\t\t\tkbuf += mchunk;",
            "\t\telse",
            "\t\t\tbuf += mchunk;",
            "\t\tmbytes -= mchunk;",
            "",
            "\t\tcond_resched();",
            "\t}",
            "out:",
            "\treturn result;",
            "}"
          ],
          "function_name": "kimage_load_normal_segment, kimage_load_crash_segment",
          "description": "实现两种模式下的内存段加载逻辑，normal模式直接复制内核镜像到目标地址，crash模式针对崩溃转储进行特殊内存处理和数据填充。",
          "similarity": 0.4821302592754364
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/kexec_core.c",
          "start_line": 1,
          "end_line": 107,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * kexec.c - kexec system call core code.",
            " * Copyright (C) 2002-2004 Eric Biederman  <ebiederm@xmission.com>",
            " */",
            "",
            "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
            "",
            "#include <linux/btf.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kexec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ioport.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/elf.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/utsname.h>",
            "#include <linux/numa.h>",
            "#include <linux/suspend.h>",
            "#include <linux/device.h>",
            "#include <linux/freezer.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/pm.h>",
            "#include <linux/cpu.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/io.h>",
            "#include <linux/console.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/objtool.h>",
            "#include <linux/kmsg_dump.h>",
            "",
            "#include <asm/page.h>",
            "#include <asm/sections.h>",
            "",
            "#include <crypto/hash.h>",
            "#include \"kexec_internal.h\"",
            "",
            "atomic_t __kexec_lock = ATOMIC_INIT(0);",
            "",
            "/* Flag to indicate we are going to kexec a new kernel */",
            "bool kexec_in_progress = false;",
            "",
            "bool kexec_file_dbg_print;",
            "",
            "/*",
            " * When kexec transitions to the new kernel there is a one-to-one",
            " * mapping between physical and virtual addresses.  On processors",
            " * where you can disable the MMU this is trivial, and easy.  For",
            " * others it is still a simple predictable page table to setup.",
            " *",
            " * In that environment kexec copies the new kernel to its final",
            " * resting place.  This means I can only support memory whose",
            " * physical address can fit in an unsigned long.  In particular",
            " * addresses where (pfn << PAGE_SHIFT) > ULONG_MAX cannot be handled.",
            " * If the assembly stub has more restrictive requirements",
            " * KEXEC_SOURCE_MEMORY_LIMIT and KEXEC_DEST_MEMORY_LIMIT can be",
            " * defined more restrictively in <asm/kexec.h>.",
            " *",
            " * The code for the transition from the current kernel to the",
            " * new kernel is placed in the control_code_buffer, whose size",
            " * is given by KEXEC_CONTROL_PAGE_SIZE.  In the best case only a single",
            " * page of memory is necessary, but some architectures require more.",
            " * Because this memory must be identity mapped in the transition from",
            " * virtual to physical addresses it must live in the range",
            " * 0 - TASK_SIZE, as only the user space mappings are arbitrarily",
            " * modifiable.",
            " *",
            " * The assembly stub in the control code buffer is passed a linked list",
            " * of descriptor pages detailing the source pages of the new kernel,",
            " * and the destination addresses of those source pages.  As this data",
            " * structure is not used in the context of the current OS, it must",
            " * be self-contained.",
            " *",
            " * The code has been made to work with highmem pages and will use a",
            " * destination page in its final resting place (if it happens",
            " * to allocate it).  The end product of this is that most of the",
            " * physical address space, and most of RAM can be used.",
            " *",
            " * Future directions include:",
            " *  - allocating a page table with the control code buffer identity",
            " *    mapped, to simplify machine_kexec and make kexec_on_panic more",
            " *    reliable.",
            " */",
            "",
            "/*",
            " * KIMAGE_NO_DEST is an impossible destination address..., for",
            " * allocating pages whose destination address we do not care about.",
            " */",
            "#define KIMAGE_NO_DEST (-1UL)",
            "#define PAGE_COUNT(x) (((x) + PAGE_SIZE - 1) >> PAGE_SHIFT)",
            "",
            "static struct page *kimage_alloc_page(struct kimage *image,",
            "\t\t\t\t       gfp_t gfp_mask,",
            "\t\t\t\t       unsigned long dest);",
            ""
          ],
          "function_name": null,
          "description": "定义了kexec核心模块的全局变量和常量，声明了kimage_alloc_page函数，用于内存段分配和初始化，为后续kexec操作提供基础支持。",
          "similarity": 0.46137094497680664
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/kexec_core.c",
          "start_line": 108,
          "end_line": 214,
          "content": [
            "int sanity_check_segment_list(struct kimage *image)",
            "{",
            "\tint i;",
            "\tunsigned long nr_segments = image->nr_segments;",
            "\tunsigned long total_pages = 0;",
            "\tunsigned long nr_pages = totalram_pages();",
            "",
            "\t/*",
            "\t * Verify we have good destination addresses.  The caller is",
            "\t * responsible for making certain we don't attempt to load",
            "\t * the new image into invalid or reserved areas of RAM.  This",
            "\t * just verifies it is an address we can use.",
            "\t *",
            "\t * Since the kernel does everything in page size chunks ensure",
            "\t * the destination addresses are page aligned.  Too many",
            "\t * special cases crop of when we don't do this.  The most",
            "\t * insidious is getting overlapping destination addresses",
            "\t * simply because addresses are changed to page size",
            "\t * granularity.",
            "\t */",
            "\tfor (i = 0; i < nr_segments; i++) {",
            "\t\tunsigned long mstart, mend;",
            "",
            "\t\tmstart = image->segment[i].mem;",
            "\t\tmend   = mstart + image->segment[i].memsz;",
            "\t\tif (mstart > mend)",
            "\t\t\treturn -EADDRNOTAVAIL;",
            "\t\tif ((mstart & ~PAGE_MASK) || (mend & ~PAGE_MASK))",
            "\t\t\treturn -EADDRNOTAVAIL;",
            "\t\tif (mend >= KEXEC_DESTINATION_MEMORY_LIMIT)",
            "\t\t\treturn -EADDRNOTAVAIL;",
            "\t}",
            "",
            "\t/* Verify our destination addresses do not overlap.",
            "\t * If we alloed overlapping destination addresses",
            "\t * through very weird things can happen with no",
            "\t * easy explanation as one segment stops on another.",
            "\t */",
            "\tfor (i = 0; i < nr_segments; i++) {",
            "\t\tunsigned long mstart, mend;",
            "\t\tunsigned long j;",
            "",
            "\t\tmstart = image->segment[i].mem;",
            "\t\tmend   = mstart + image->segment[i].memsz;",
            "\t\tfor (j = 0; j < i; j++) {",
            "\t\t\tunsigned long pstart, pend;",
            "",
            "\t\t\tpstart = image->segment[j].mem;",
            "\t\t\tpend   = pstart + image->segment[j].memsz;",
            "\t\t\t/* Do the segments overlap ? */",
            "\t\t\tif ((mend > pstart) && (mstart < pend))",
            "\t\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Ensure our buffer sizes are strictly less than",
            "\t * our memory sizes.  This should always be the case,",
            "\t * and it is easier to check up front than to be surprised",
            "\t * later on.",
            "\t */",
            "\tfor (i = 0; i < nr_segments; i++) {",
            "\t\tif (image->segment[i].bufsz > image->segment[i].memsz)",
            "\t\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/*",
            "\t * Verify that no more than half of memory will be consumed. If the",
            "\t * request from userspace is too large, a large amount of time will be",
            "\t * wasted allocating pages, which can cause a soft lockup.",
            "\t */",
            "\tfor (i = 0; i < nr_segments; i++) {",
            "\t\tif (PAGE_COUNT(image->segment[i].memsz) > nr_pages / 2)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\ttotal_pages += PAGE_COUNT(image->segment[i].memsz);",
            "\t}",
            "",
            "\tif (total_pages > nr_pages / 2)",
            "\t\treturn -EINVAL;",
            "",
            "#ifdef CONFIG_CRASH_DUMP",
            "\t/*",
            "\t * Verify we have good destination addresses.  Normally",
            "\t * the caller is responsible for making certain we don't",
            "\t * attempt to load the new image into invalid or reserved",
            "\t * areas of RAM.  But crash kernels are preloaded into a",
            "\t * reserved area of ram.  We must ensure the addresses",
            "\t * are in the reserved area otherwise preloading the",
            "\t * kernel could corrupt things.",
            "\t */",
            "",
            "\tif (image->type == KEXEC_TYPE_CRASH) {",
            "\t\tfor (i = 0; i < nr_segments; i++) {",
            "\t\t\tunsigned long mstart, mend;",
            "",
            "\t\t\tmstart = image->segment[i].mem;",
            "\t\t\tmend = mstart + image->segment[i].memsz - 1;",
            "\t\t\t/* Ensure we are within the crash kernel limits */",
            "\t\t\tif ((mstart < phys_to_boot_phys(crashk_res.start)) ||",
            "\t\t\t    (mend > phys_to_boot_phys(crashk_res.end)))",
            "\t\t\t\treturn -EADDRNOTAVAIL;",
            "\t\t}",
            "\t}",
            "#endif",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "sanity_check_segment_list",
          "description": "验证内存段列表的有效性，检查地址对齐、范围不重叠及内存容量限制，确保新内核加载不会导致物理内存冲突或越界。",
          "similarity": 0.4577615261077881
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/kexec_core.c",
          "start_line": 249,
          "end_line": 395,
          "content": [
            "int kimage_is_destination_range(struct kimage *image,",
            "\t\t\t\t\tunsigned long start,",
            "\t\t\t\t\tunsigned long end)",
            "{",
            "\tunsigned long i;",
            "",
            "\tfor (i = 0; i < image->nr_segments; i++) {",
            "\t\tunsigned long mstart, mend;",
            "",
            "\t\tmstart = image->segment[i].mem;",
            "\t\tmend = mstart + image->segment[i].memsz;",
            "\t\tif ((end > mstart) && (start < mend))",
            "\t\t\treturn 1;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void kimage_free_pages(struct page *page)",
            "{",
            "\tunsigned int order, count, i;",
            "",
            "\torder = page_private(page);",
            "\tcount = 1 << order;",
            "",
            "\tarch_kexec_pre_free_pages(page_address(page), count);",
            "",
            "\tfor (i = 0; i < count; i++)",
            "\t\tClearPageReserved(page + i);",
            "\t__free_pages(page, order);",
            "}",
            "void kimage_free_page_list(struct list_head *list)",
            "{",
            "\tstruct page *page, *next;",
            "",
            "\tlist_for_each_entry_safe(page, next, list, lru) {",
            "\t\tlist_del(&page->lru);",
            "\t\tkimage_free_pages(page);",
            "\t}",
            "}",
            "static int kimage_add_entry(struct kimage *image, kimage_entry_t entry)",
            "{",
            "\tif (*image->entry != 0)",
            "\t\timage->entry++;",
            "",
            "\tif (image->entry == image->last_entry) {",
            "\t\tkimage_entry_t *ind_page;",
            "\t\tstruct page *page;",
            "",
            "\t\tpage = kimage_alloc_page(image, GFP_KERNEL, KIMAGE_NO_DEST);",
            "\t\tif (!page)",
            "\t\t\treturn -ENOMEM;",
            "",
            "\t\tind_page = page_address(page);",
            "\t\t*image->entry = virt_to_boot_phys(ind_page) | IND_INDIRECTION;",
            "\t\timage->entry = ind_page;",
            "\t\timage->last_entry = ind_page +",
            "\t\t\t\t      ((PAGE_SIZE/sizeof(kimage_entry_t)) - 1);",
            "\t}",
            "\t*image->entry = entry;",
            "\timage->entry++;",
            "\t*image->entry = 0;",
            "",
            "\treturn 0;",
            "}",
            "static int kimage_set_destination(struct kimage *image,",
            "\t\t\t\t   unsigned long destination)",
            "{",
            "\tdestination &= PAGE_MASK;",
            "",
            "\treturn kimage_add_entry(image, destination | IND_DESTINATION);",
            "}",
            "static int kimage_add_page(struct kimage *image, unsigned long page)",
            "{",
            "\tpage &= PAGE_MASK;",
            "",
            "\treturn kimage_add_entry(image, page | IND_SOURCE);",
            "}",
            "static void kimage_free_extra_pages(struct kimage *image)",
            "{",
            "\t/* Walk through and free any extra destination pages I may have */",
            "\tkimage_free_page_list(&image->dest_pages);",
            "",
            "\t/* Walk through and free any unusable pages I have cached */",
            "\tkimage_free_page_list(&image->unusable_pages);",
            "",
            "}",
            "void kimage_terminate(struct kimage *image)",
            "{",
            "\tif (*image->entry != 0)",
            "\t\timage->entry++;",
            "",
            "\t*image->entry = IND_DONE;",
            "}",
            "static void kimage_free_entry(kimage_entry_t entry)",
            "{",
            "\tstruct page *page;",
            "",
            "\tpage = boot_pfn_to_page(entry >> PAGE_SHIFT);",
            "\tkimage_free_pages(page);",
            "}",
            "void kimage_free(struct kimage *image)",
            "{",
            "\tkimage_entry_t *ptr, entry;",
            "\tkimage_entry_t ind = 0;",
            "",
            "\tif (!image)",
            "\t\treturn;",
            "",
            "#ifdef CONFIG_CRASH_DUMP",
            "\tif (image->vmcoreinfo_data_copy) {",
            "\t\tcrash_update_vmcoreinfo_safecopy(NULL);",
            "\t\tvunmap(image->vmcoreinfo_data_copy);",
            "\t}",
            "#endif",
            "",
            "\tkimage_free_extra_pages(image);",
            "\tfor_each_kimage_entry(image, ptr, entry) {",
            "\t\tif (entry & IND_INDIRECTION) {",
            "\t\t\t/* Free the previous indirection page */",
            "\t\t\tif (ind & IND_INDIRECTION)",
            "\t\t\t\tkimage_free_entry(ind);",
            "\t\t\t/* Save this indirection page until we are",
            "\t\t\t * done with it.",
            "\t\t\t */",
            "\t\t\tind = entry;",
            "\t\t} else if (entry & IND_SOURCE)",
            "\t\t\tkimage_free_entry(entry);",
            "\t}",
            "\t/* Free the final indirection page */",
            "\tif (ind & IND_INDIRECTION)",
            "\t\tkimage_free_entry(ind);",
            "",
            "\t/* Handle any machine specific cleanup */",
            "\tmachine_kexec_cleanup(image);",
            "",
            "\t/* Free the kexec control pages... */",
            "\tkimage_free_page_list(&image->control_pages);",
            "",
            "\t/*",
            "\t * Free up any temporary buffers allocated. This might hit if",
            "\t * error occurred much later after buffer allocation.",
            "\t */",
            "\tif (image->file_mode)",
            "\t\tkimage_file_post_load_cleanup(image);",
            "",
            "\tkfree(image);",
            "}"
          ],
          "function_name": "kimage_is_destination_range, kimage_free_pages, kimage_free_page_list, kimage_add_entry, kimage_set_destination, kimage_add_page, kimage_free_extra_pages, kimage_terminate, kimage_free_entry, kimage_free",
          "description": "管理kimage结构的内存页分配与释放，通过链表维护页表项，处理异常页和控制页的生命周期，构建多级间接页表结构。",
          "similarity": 0.4475897252559662
        }
      ]
    },
    {
      "source_file": "kernel/module/debug_kmemleak.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:58:25\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\debug_kmemleak.c`\n\n---\n\n# module/debug_kmemleak.c 技术文档\n\n## 1. 文件概述\n\n该文件为 Linux 内核模块系统提供对 **kmemleak**（内核内存泄漏检测器）的支持。其主要作用是在模块加载过程中，将模块相关的可写、非可执行内存区域注册到 kmemleak 扫描机制中，以便 kmemleak 能够追踪这些区域中的指针引用，从而避免将仍在使用的动态分配内存误判为泄漏。\n\n## 2. 核心功能\n\n- **函数**：\n  - `void kmemleak_load_module(const struct module *mod, const struct load_info *info)`  \n    在模块加载时，向 kmemleak 注册模块结构体本身以及模块中所有可写且非可执行的已分配节（section）作为扫描区域。\n\n- **数据结构（引用）**：\n  - `struct module`：内核模块的核心描述结构。\n  - `struct load_info`：模块加载过程中的临时信息结构，包含 ELF 头、节头表等。\n  - `Elf_Shdr`（通过 `info->sechdrs` 访问）：ELF 节头描述符，用于判断节的属性。\n\n## 3. 关键实现\n\n- **模块结构体扫描**：  \n  首先调用 `kmemleak_scan_area(mod, sizeof(struct module), GFP_KERNEL)`，将整个 `struct module` 实例标记为 kmemleak 的扫描区域，确保模块元数据中的指针不会被误判为泄漏。\n\n- **节（Section）筛选逻辑**：  \n  遍历 ELF 文件的所有节（从索引 1 开始，跳过空节），仅对同时满足以下条件的节进行扫描注册：\n  - `SHF_ALLOC`：该节在运行时需要被加载到内存中。\n  - `SHF_WRITE`：该节是可写的（通常包含数据段，如 `.data`、`.bss` 等）。\n  - **非** `SHF_EXECINSTR`：该节**不是**可执行的（排除代码段如 `.text`）。\n\n- **内存区域注册**：  \n  对符合条件的节，调用 `kmemleak_scan_area()`，传入节在内核空间的虚拟地址（`sh_addr`）和大小（`sh_size`），通知 kmemleak 在后续的内存泄漏扫描中将该区域视为“根指针”来源，用于追踪潜在的内存引用。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/module.h>`：提供模块系统相关定义。\n  - `<linux/kmemleak.h>`：提供 `kmemleak_scan_area()` 等 kmemleak 接口。\n  - `\"internal.h\"`：模块子系统内部头文件，定义 `struct load_info` 等内部结构。\n\n- **功能依赖**：\n  - 依赖 **kmemleak 子系统**（需在内核配置中启用 `CONFIG_DEBUG_KMEMLEAK`）。\n  - 与 **模块加载器**（`load_module()` 流程）紧密集成，在模块布局完成后、正式启用前调用此函数。\n\n## 5. 使用场景\n\n- 当内核启用 **kmemleak 内存泄漏检测功能** 且动态加载模块（通过 `insmod` 或 `modprobe`）时，此函数会被模块加载流程自动调用。\n- 用于确保模块自身的数据段（如全局变量、静态变量等）中的指针能被 kmemleak 正确识别为有效引用，防止将模块仍在使用的动态分配内存（如通过 `kmalloc()` 分配）错误报告为内存泄漏。\n- 仅在 `CONFIG_DEBUG_KMEMLEAK` 配置选项启用时编译进内核，对正常系统运行无影响。",
      "similarity": 0.5047677755355835,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/module/debug_kmemleak.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * Module kmemleak support",
            " *",
            " * Copyright (C) 2009 Catalin Marinas",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/kmemleak.h>",
            "#include \"internal.h\"",
            ""
          ],
          "function_name": null,
          "description": "此代码块定义了kmemleak模块的调试支持，声明GPL许可证并引入相关头文件，为后续内存泄漏检测功能提供基础框架。",
          "similarity": 0.5070068836212158
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/module/debug_kmemleak.c",
          "start_line": 12,
          "end_line": 30,
          "content": [
            "void kmemleak_load_module(const struct module *mod,",
            "\t\t\t  const struct load_info *info)",
            "{",
            "\tunsigned int i;",
            "",
            "\t/* only scan the sections containing data */",
            "\tkmemleak_scan_area(mod, sizeof(struct module), GFP_KERNEL);",
            "",
            "\tfor (i = 1; i < info->hdr->e_shnum; i++) {",
            "\t\t/* Scan all writable sections that's not executable */",
            "\t\tif (!(info->sechdrs[i].sh_flags & SHF_ALLOC) ||",
            "\t\t    !(info->sechdrs[i].sh_flags & SHF_WRITE) ||",
            "\t\t    (info->sechdrs[i].sh_flags & SHF_EXECINSTR))",
            "\t\t\tcontinue;",
            "",
            "\t\tkmemleak_scan_area((void *)info->sechdrs[i].sh_addr,",
            "\t\t\t\t   info->sechdrs[i].sh_size, GFP_KERNEL);",
            "\t}",
            "}"
          ],
          "function_name": "kmemleak_load_module",
          "description": "该函数在模块加载时扫描模块的可写数据段，通过检查section属性过滤出需分析的内存区域，调用kmemleak接口进行泄漏检测。",
          "similarity": 0.477864146232605
        }
      ]
    },
    {
      "source_file": "kernel/module/kmod.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:03:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `module\\kmod.c`\n\n---\n\n# `module/kmod.c` 技术文档\n\n## 1. 文件概述\n\n`kmod.c` 是 Linux 内核中负责**内核模块自动加载机制**的核心实现文件。它提供了从内核空间调用用户态 `modprobe` 工具以动态加载缺失模块的能力。该机制允许内核在运行时按需加载驱动或功能模块（例如当设备被探测到但对应驱动未加载时），从而提升系统灵活性和资源利用率。\n\n该文件实现了 `__request_module()` 接口，作为内核其他子系统请求模块加载的统一入口，并通过 `call_usermodehelper` 机制安全地调用用户空间的 `/sbin/modprobe`（或由 `modprobe_path` 指定的路径）。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`__request_module(bool wait, const char *fmt, ...)`**  \n  内核模块加载的主入口函数。支持格式化模块名，可选择同步（`wait=true`）或异步（`wait=false`）执行。返回值为 0 表示成功启动加载过程，负值为错误码，正值为 `modprobe` 的退出码。\n\n- **`call_modprobe(char *orig_module_name, int wait)`**  \n  封装对用户态 `modprobe` 的调用。构造命令行参数（`modprobe -q -- <module_name>`）和环境变量，通过 `call_usermodehelper_setup()` 和 `call_usermodehelper_exec()` 执行。\n\n- **`free_modprobe_argv(struct subprocess_info *info)`**  \n  释放 `call_modprobe` 中分配的参数内存，作为 `call_usermodehelper_setup()` 的清理回调。\n\n### 关键数据结构与变量\n\n- **`modprobe_path[KMOD_PATH_LEN]`**  \n  全局可配置的 `modprobe` 可执行文件路径，默认为 `CONFIG_MODPROBE_PATH`（通常为 `\"/sbin/modprobe\"`），可通过 `/proc/sys/kernel/modprobe` 修改。\n\n- **`kmod_concurrent_max`**  \n  信号量，限制同时进行的模块加载请求数量，上限为 `MAX_KMOD_CONCURRENT`（50），防止资源耗尽或递归依赖导致的死锁。\n\n- **`MAX_KMOD_ALL_BUSY_TIMEOUT`**  \n  超时阈值（5 秒），当所有并发槽位被占用超过此时间，判定为可能的模块依赖循环，拒绝新请求。\n\n## 3. 关键实现\n\n### 并发控制与死锁预防\n\n- 使用 `down_timeout(&kmod_concurrent_max, ...)` 限制并发加载线程数，避免系统资源（如内存、进程数）被大量 `modprobe` 进程耗尽。\n- 若所有 50 个并发槽位在 5 秒内未释放，内核判定为**模块依赖循环**（如 A 依赖 B，B 又依赖 A），主动拒绝请求并打印警告，防止无限递归。\n- 通过 `WARN_ON_ONCE(wait && current_is_async())` 禁止在异步上下文（如 workqueue、async 任务）中执行**同步**模块加载，避免与 `async_synchronize_full()` 产生死锁。\n\n### 安全与资源管理\n\n- 调用 `security_kernel_module_request()` 执行 LSM（Linux Security Module）安全检查，允许安全模块（如 SELinux、AppArmor）控制模块加载权限。\n- 使用 `UMH_KILLABLE` 标志使 `modprobe` 进程可被信号中断，提升系统响应性。\n- 通过 `kmod_dup_request_exists_wait()` 检测重复的模块加载请求，避免对同一模块发起多次 `modprobe` 调用，提升效率。\n\n### 用户态交互\n\n- 构造标准环境变量（`HOME=/`, `PATH=/sbin:/usr/sbin:/bin:/usr/bin`）确保 `modprobe` 在受限但可用的环境中执行。\n- 使用 `call_usermodehelper` 子系统创建内核线程执行用户态程序，该机制处理了凭证（cred）、文件描述符、挂载命名空间等上下文隔离。\n\n### 跟踪与调试\n\n- 集成 `trace_module_request` 跟踪点，可通过 ftrace 或 perf 监控模块加载请求。\n- 调用 `kmod_dup_request_announce()` 记录重复请求或失败事件，便于诊断。\n\n## 4. 依赖关系\n\n- **内核子系统依赖**：\n  - `call_usermodehelper`（`<linux/unistd.h>`, `<linux/binfmts.h>`）：用于执行用户态 helper 程序。\n  - LSM 框架（`<linux/security.h>`）：执行模块加载安全策略。\n  - 内存管理（`<linux/slab.h>`）：动态分配参数字符串。\n  - 同步原语（`<linux/semaphore.h>` via `DEFINE_SEMAPHORE`）：并发控制。\n  - 调试与跟踪（`<trace/events/module.h>`）：性能分析支持。\n- **配置依赖**：\n  - `CONFIG_MODULES`：模块支持必须启用。\n  - `CONFIG_MODPROBE_PATH`：定义默认 `modprobe` 路径。\n- **内部依赖**：\n  - `internal.h`：包含模块子系统内部声明（如 `kmod_dup_request_exists_wait`）。\n\n## 5. 使用场景\n\n- **设备驱动自动加载**：当内核探测到新硬件（如 USB 设备）但无对应驱动时，通过 `__request_module(\"usb:vXXXXpXXXX...\")` 触发驱动加载。\n- **文件系统按需挂载**：挂载未知文件系统类型时（如 `mount -t foo`），内核调用 `__request_module(\"fs-foo\")` 加载文件系统模块。\n- **网络协议模块加载**：使用未加载的网络协议（如 `AF_PHONET`）时自动加载对应模块。\n- **内核特性动态扩展**：如加密算法、压缩模块等在首次使用时按需加载。\n- **内核模块依赖解析**：当模块 A 依赖模块 B，而 B 未加载时，`insmod`/`modprobe` 内部会通过此机制加载 B。\n\n> **注意**：成功返回仅表示 `modprobe` 已启动，不保证模块最终加载成功。调用者必须验证所需功能是否可用。",
      "similarity": 0.5013329386711121,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/module/kmod.c",
          "start_line": 66,
          "end_line": 161,
          "content": [
            "static void free_modprobe_argv(struct subprocess_info *info)",
            "{",
            "\tkfree(info->argv[3]); /* check call_modprobe() */",
            "\tkfree(info->argv);",
            "}",
            "static int call_modprobe(char *orig_module_name, int wait)",
            "{",
            "\tstruct subprocess_info *info;",
            "\tstatic char *envp[] = {",
            "\t\t\"HOME=/\",",
            "\t\t\"TERM=linux\",",
            "\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",",
            "\t\tNULL",
            "\t};",
            "\tchar *module_name;",
            "\tint ret;",
            "",
            "\tchar **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);",
            "\tif (!argv)",
            "\t\tgoto out;",
            "",
            "\tmodule_name = kstrdup(orig_module_name, GFP_KERNEL);",
            "\tif (!module_name)",
            "\t\tgoto free_argv;",
            "",
            "\targv[0] = modprobe_path;",
            "\targv[1] = \"-q\";",
            "\targv[2] = \"--\";",
            "\targv[3] = module_name;\t/* check free_modprobe_argv() */",
            "\targv[4] = NULL;",
            "",
            "\tinfo = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,",
            "\t\t\t\t\t NULL, free_modprobe_argv, NULL);",
            "\tif (!info)",
            "\t\tgoto free_module_name;",
            "",
            "\tret = call_usermodehelper_exec(info, wait | UMH_KILLABLE);",
            "\tkmod_dup_request_announce(orig_module_name, ret);",
            "\treturn ret;",
            "",
            "free_module_name:",
            "\tkfree(module_name);",
            "free_argv:",
            "\tkfree(argv);",
            "out:",
            "\tkmod_dup_request_announce(orig_module_name, -ENOMEM);",
            "\treturn -ENOMEM;",
            "}",
            "int __request_module(bool wait, const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "\tchar module_name[MODULE_NAME_LEN];",
            "\tint ret, dup_ret;",
            "",
            "\t/*",
            "\t * We don't allow synchronous module loading from async.  Module",
            "\t * init may invoke async_synchronize_full() which will end up",
            "\t * waiting for this task which already is waiting for the module",
            "\t * loading to complete, leading to a deadlock.",
            "\t */",
            "\tWARN_ON_ONCE(wait && current_is_async());",
            "",
            "\tif (!modprobe_path[0])",
            "\t\treturn -ENOENT;",
            "",
            "\tva_start(args, fmt);",
            "\tret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);",
            "\tva_end(args);",
            "\tif (ret >= MODULE_NAME_LEN)",
            "\t\treturn -ENAMETOOLONG;",
            "",
            "\tret = security_kernel_module_request(module_name);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tret = down_timeout(&kmod_concurrent_max, MAX_KMOD_ALL_BUSY_TIMEOUT * HZ);",
            "\tif (ret) {",
            "\t\tpr_warn_ratelimited(\"request_module: modprobe %s cannot be processed, kmod busy with %d threads for more than %d seconds now\",",
            "\t\t\t\t    module_name, MAX_KMOD_CONCURRENT, MAX_KMOD_ALL_BUSY_TIMEOUT);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ttrace_module_request(module_name, wait, _RET_IP_);",
            "",
            "\tif (kmod_dup_request_exists_wait(module_name, wait, &dup_ret)) {",
            "\t\tret = dup_ret;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);",
            "",
            "out:",
            "\tup(&kmod_concurrent_max);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "free_modprobe_argv, call_modprobe, __request_module",
          "description": "实现模块请求处理逻辑，通过调用modprobe执行模块加载，包含参数构造、子进程管理及并发控制机制",
          "similarity": 0.49484163522720337
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/module/kmod.c",
          "start_line": 1,
          "end_line": 65,
          "content": [
            "/*",
            " * kmod - the kernel module loader",
            " *",
            " * Copyright (C) 2023 Luis Chamberlain <mcgrof@kernel.org>",
            " */",
            "",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/unistd.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/cred.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/resource.h>",
            "#include <linux/notifier.h>",
            "#include <linux/suspend.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/async.h>",
            "#include <linux/uaccess.h>",
            "",
            "#include <trace/events/module.h>",
            "#include \"internal.h\"",
            "",
            "/*",
            " * Assuming:",
            " *",
            " * threads = div64_u64((u64) totalram_pages * (u64) PAGE_SIZE,",
            " *\t\t       (u64) THREAD_SIZE * 8UL);",
            " *",
            " * If you need less than 50 threads would mean we're dealing with systems",
            " * smaller than 3200 pages. This assumes you are capable of having ~13M memory,",
            " * and this would only be an upper limit, after which the OOM killer would take",
            " * effect. Systems like these are very unlikely if modules are enabled.",
            " */",
            "#define MAX_KMOD_CONCURRENT 50",
            "static DEFINE_SEMAPHORE(kmod_concurrent_max, MAX_KMOD_CONCURRENT);",
            "",
            "/*",
            " * This is a restriction on having *all* MAX_KMOD_CONCURRENT threads",
            " * running at the same time without returning. When this happens we",
            " * believe you've somehow ended up with a recursive module dependency",
            " * creating a loop.",
            " *",
            " * We have no option but to fail.",
            " *",
            " * Userspace should proactively try to detect and prevent these.",
            " */",
            "#define MAX_KMOD_ALL_BUSY_TIMEOUT 5",
            "",
            "/*",
            "\tmodprobe_path is set via /proc/sys.",
            "*/",
            "char modprobe_path[KMOD_PATH_LEN] = CONFIG_MODPROBE_PATH;",
            ""
          ],
          "function_name": null,
          "description": "定义模块加载并发控制相关常量与全局变量，包含模块加载所需头文件并初始化modprobe路径",
          "similarity": 0.4539091885089874
        }
      ]
    }
  ]
}