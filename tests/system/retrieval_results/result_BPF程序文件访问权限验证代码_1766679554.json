{
  "query": "BPF程序文件访问权限验证代码",
  "timestamp": "2025-12-26 00:19:14",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/token.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:36:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\token.c`\n\n---\n\n# `bpf/token.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/token.c` 实现了 BPF（Berkeley Packet Filter）令牌（token）机制，用于在受限环境中安全地委托 BPF 操作权限。该机制允许用户空间程序通过文件描述符形式的令牌，将特定的 BPF 命令、映射类型、程序类型和附加类型权限委托给其他进程，同时结合用户命名空间（user namespace）和 LSM（Linux Security Module）安全策略进行细粒度访问控制。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `bpf_ns_capable()`：检查用户命名空间是否具备指定能力，或具备 `CAP_SYS_ADMIN`（除 `CAP_SYS_ADMIN` 自身外）。\n- `bpf_token_capable()`：结合用户命名空间能力和 LSM 安全钩子，判断令牌是否具备指定能力。\n- `bpf_token_inc()` / `bpf_token_put()`：引用计数管理，支持延迟释放。\n- `bpf_token_free()`：释放令牌资源，包括用户命名空间引用和安全模块数据。\n- `bpf_token_create()`：创建 BPF 令牌文件描述符，基于挂载在 BPF 文件系统上的委托配置。\n- `bpf_token_get_from_fd()`：从文件描述符获取并增加引用计数的 `bpf_token` 结构。\n- `bpf_token_allow_cmd()` / `bpf_token_allow_map_type()` / `bpf_token_allow_prog_type()`：检查令牌是否允许执行特定 BPF 操作。\n\n### 关键数据结构\n\n- `struct bpf_token`：表示 BPF 令牌，包含：\n  - `refcnt`：引用计数（`atomic64_t`）\n  - `userns`：关联的用户命名空间\n  - `allowed_cmds` / `allowed_maps` / `allowed_progs` / `allowed_attachs`：位掩码，分别表示允许的 BPF 命令、映射类型、程序类型和附加类型\n  - `work`：用于延迟释放的工作队列项\n\n### 文件操作接口\n\n- `bpf_token_fops`：定义了 `release` 和 `show_fdinfo` 回调，用于文件关闭和 `/proc/pid/fdinfo/` 信息展示。\n\n## 3. 关键实现\n\n### 令牌创建流程 (`bpf_token_create`)\n\n1. **验证输入**：检查传入的 `bpffs_fd` 是否指向 BPF 文件系统的根目录。\n2. **权限校验**：\n   - 要求调用者与 BPF 文件系统实例处于同一用户命名空间。\n   - 必须具备 `CAP_BPF` 能力。\n   - 禁止在 `init_user_ns` 中创建令牌。\n3. **委托配置检查**：确保 BPF 文件系统挂载时已通过挂载选项设置了至少一项委托权限（`delegate_*` 字段非零）。\n4. **资源分配**：\n   - 创建匿名 inode 和文件。\n   - 分配 `bpf_token` 结构并初始化引用计数为 1。\n   - 复制挂载选项中的委托位掩码到令牌。\n5. **安全模块集成**：调用 `security_bpf_token_create()` 允许 LSM 进行额外策略检查。\n6. **返回文件描述符**：安装文件到进程 fd 表并返回。\n\n### 安全能力检查 (`bpf_token_capable`)\n\n- 默认允许 `CAP_SYS_ADMIN` 作为“超级能力”覆盖其他能力检查（但 `CAP_SYS_ADMIN` 本身仍需显式授权）。\n- 调用 `security_bpf_token_capable()` 允许 LSM 对令牌能力进行二次验证。\n\n### 引用计数与延迟释放\n\n- 使用 `atomic64_t refcnt` 管理生命周期。\n- 当引用计数归零时，通过 `schedule_work()` 将释放操作推迟到工作队列执行，避免在中断或原子上下文中调用可能睡眠的 `put_user_ns()` 和 `kfree()`。\n\n### `/proc/pid/fdinfo/` 支持\n\n- `bpf_token_show_fdinfo()` 将令牌的委托权限以十六进制或 \"any\" 形式输出，便于调试和审计。\n\n### 权限位掩码设计\n\n- 所有委托权限（命令、映射、程序、附加类型）均使用 64 位无符号整数位掩码表示。\n- 通过 `BUILD_BUG_ON()` 确保枚举类型数量不超过 64，防止位移溢出。\n- 若掩码全为 1，则显示为 \"any\"，表示无限制。\n\n## 4. 依赖关系\n\n- **BPF 子系统**：依赖 `bpf_super_ops`、`bpf_get_inode()` 等 BPF 文件系统接口。\n- **用户命名空间**：通过 `user_namespace` 和 `ns_capable()` 实现能力隔离。\n- **安全模块 (LSM)**：集成 `security_bpf_token_*` 钩子，支持 SELinux、AppArmor 等策略扩展。\n- **VFS 层**：使用 `inode`、`file`、`path`、`fdtable` 等通用文件系统抽象。\n- **内存管理**：使用 `kzalloc()`/`kfree()` 和 `vmalloc.h`（虽未直接使用，但为潜在扩展预留）。\n- **工作队列**：通过 `schedule_work()` 实现延迟释放。\n\n## 5. 使用场景\n\n- **容器化环境中的 BPF 权限委托**：在用户命名空间隔离的容器中，特权进程可创建 BPF 令牌并传递给非特权子进程，使其在受限范围内使用 BPF 功能（如 eBPF 程序加载、映射操作）。\n- **安全沙箱**：应用程序可通过令牌机制将特定 BPF 操作权限委托给插件或子模块，避免授予完整 `CAP_BPF` 或 `CAP_SYS_ADMIN`。\n- **审计与调试**：通过 `/proc/pid/fdinfo/` 查看进程持有的 BPF 令牌权限，辅助安全分析。\n- **LSM 策略集成**：安全模块可基于令牌内容实施更细粒度的访问控制，例如限制特定程序类型只能在特定挂载点使用。",
      "similarity": 0.7122166156768799,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/token.c",
          "start_line": 230,
          "end_line": 254,
          "content": [
            "bool bpf_token_allow_cmd(const struct bpf_token *token, enum bpf_cmd cmd)",
            "{",
            "\tif (!token)",
            "\t\treturn false;",
            "\tif (!(token->allowed_cmds & (1ULL << cmd)))",
            "\t\treturn false;",
            "\treturn security_bpf_token_cmd(token, cmd) == 0;",
            "}",
            "bool bpf_token_allow_map_type(const struct bpf_token *token, enum bpf_map_type type)",
            "{",
            "\tif (!token || type >= __MAX_BPF_MAP_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn token->allowed_maps & (1ULL << type);",
            "}",
            "bool bpf_token_allow_prog_type(const struct bpf_token *token,",
            "\t\t\t       enum bpf_prog_type prog_type,",
            "\t\t\t       enum bpf_attach_type attach_type)",
            "{",
            "\tif (!token || prog_type >= __MAX_BPF_PROG_TYPE || attach_type >= __MAX_BPF_ATTACH_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn (token->allowed_progs & (1ULL << prog_type)) &&",
            "\t       (token->allowed_attachs & (1ULL << attach_type));",
            "}"
          ],
          "function_name": "bpf_token_allow_cmd, bpf_token_allow_map_type, bpf_token_allow_prog_type",
          "description": "提供对BPF命令、映射类型和程序类型的访问控制检查，通过位掩码匹配并结合安全模块验证权限。",
          "similarity": 0.7463701963424683
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/token.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "#include <linux/bpf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            ""
          ],
          "function_name": null,
          "description": "包含BPF令牌功能所需的各种内核头文件，如用户命名空间、安全策略、文件操作及BPF相关定义。",
          "similarity": 0.6435941457748413
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/token.c",
          "start_line": 12,
          "end_line": 195,
          "content": [
            "static bool bpf_ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable(ns, cap) || (cap != CAP_SYS_ADMIN && ns_capable(ns, CAP_SYS_ADMIN));",
            "}",
            "bool bpf_token_capable(const struct bpf_token *token, int cap)",
            "{",
            "\tstruct user_namespace *userns;",
            "",
            "\t/* BPF token allows ns_capable() level of capabilities */",
            "\tuserns = token ? token->userns : &init_user_ns;",
            "\tif (!bpf_ns_capable(userns, cap))",
            "\t\treturn false;",
            "\tif (token && security_bpf_token_capable(token, cap) < 0)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "void bpf_token_inc(struct bpf_token *token)",
            "{",
            "\tatomic64_inc(&token->refcnt);",
            "}",
            "static void bpf_token_free(struct bpf_token *token)",
            "{",
            "\tsecurity_bpf_token_free(token);",
            "\tput_user_ns(token->userns);",
            "\tkfree(token);",
            "}",
            "static void bpf_token_put_deferred(struct work_struct *work)",
            "{",
            "\tstruct bpf_token *token = container_of(work, struct bpf_token, work);",
            "",
            "\tbpf_token_free(token);",
            "}",
            "void bpf_token_put(struct bpf_token *token)",
            "{",
            "\tif (!token)",
            "\t\treturn;",
            "",
            "\tif (!atomic64_dec_and_test(&token->refcnt))",
            "\t\treturn;",
            "",
            "\tINIT_WORK(&token->work, bpf_token_put_deferred);",
            "\tschedule_work(&token->work);",
            "}",
            "static int bpf_token_release(struct inode *inode, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "",
            "\tbpf_token_put(token);",
            "\treturn 0;",
            "}",
            "static void bpf_token_show_fdinfo(struct seq_file *m, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "\tu64 mask;",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_CMD >= 64);",
            "\tmask = (1ULL << __MAX_BPF_CMD) - 1;",
            "\tif ((token->allowed_cmds & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_cmds:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_cmds:\\t0x%llx\\n\", token->allowed_cmds);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_MAP_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_MAP_TYPE) - 1;",
            "\tif ((token->allowed_maps & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_maps:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_maps:\\t0x%llx\\n\", token->allowed_maps);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_PROG_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_PROG_TYPE) - 1;",
            "\tif ((token->allowed_progs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_progs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_progs:\\t0x%llx\\n\", token->allowed_progs);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_ATTACH_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_ATTACH_TYPE) - 1;",
            "\tif ((token->allowed_attachs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_attachs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_attachs:\\t0x%llx\\n\", token->allowed_attachs);",
            "}",
            "int bpf_token_create(union bpf_attr *attr)",
            "{",
            "\tstruct bpf_mount_opts *mnt_opts;",
            "\tstruct bpf_token *token = NULL;",
            "\tstruct user_namespace *userns;",
            "\tstruct inode *inode;",
            "\tstruct file *file;",
            "\tCLASS(fd, f)(attr->token_create.bpffs_fd);",
            "\tstruct path path;",
            "\tstruct super_block *sb;",
            "\tumode_t mode;",
            "\tint err, fd;",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "",
            "\tpath = fd_file(f)->f_path;",
            "\tsb = path.dentry->d_sb;",
            "",
            "\tif (path.dentry != sb->s_root)",
            "\t\treturn -EINVAL;",
            "\tif (sb->s_op != &bpf_super_ops)",
            "\t\treturn -EINVAL;",
            "\terr = path_permission(&path, MAY_ACCESS);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tuserns = sb->s_user_ns;",
            "\t/*",
            "\t * Enforce that creators of BPF tokens are in the same user",
            "\t * namespace as the BPF FS instance. This makes reasoning about",
            "\t * permissions a lot easier and we can always relax this later.",
            "\t */",
            "\tif (current_user_ns() != userns)",
            "\t\treturn -EPERM;",
            "\tif (!ns_capable(userns, CAP_BPF))",
            "\t\treturn -EPERM;",
            "",
            "\t/* Creating BPF token in init_user_ns doesn't make much sense. */",
            "\tif (current_user_ns() == &init_user_ns)",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\tmnt_opts = sb->s_fs_info;",
            "\tif (mnt_opts->delegate_cmds == 0 &&",
            "\t    mnt_opts->delegate_maps == 0 &&",
            "\t    mnt_opts->delegate_progs == 0 &&",
            "\t    mnt_opts->delegate_attachs == 0)",
            "\t\treturn -ENOENT; /* no BPF token delegation is set up */",
            "",
            "\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());",
            "\tinode = bpf_get_inode(sb, NULL, mode);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = &bpf_token_iops;",
            "\tinode->i_fop = &bpf_token_fops;",
            "\tclear_nlink(inode); /* make sure it is unlinked */",
            "",
            "\tfile = alloc_file_pseudo(inode, path.mnt, BPF_TOKEN_INODE_NAME, O_RDWR, &bpf_token_fops);",
            "\tif (IS_ERR(file)) {",
            "\t\tiput(inode);",
            "\t\treturn PTR_ERR(file);",
            "\t}",
            "",
            "\ttoken = kzalloc(sizeof(*token), GFP_USER);",
            "\tif (!token) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto out_file;",
            "\t}",
            "",
            "\tatomic64_set(&token->refcnt, 1);",
            "",
            "\t/* remember bpffs owning userns for future ns_capable() checks */",
            "\ttoken->userns = get_user_ns(userns);",
            "",
            "\ttoken->allowed_cmds = mnt_opts->delegate_cmds;",
            "\ttoken->allowed_maps = mnt_opts->delegate_maps;",
            "\ttoken->allowed_progs = mnt_opts->delegate_progs;",
            "\ttoken->allowed_attachs = mnt_opts->delegate_attachs;",
            "",
            "\terr = security_bpf_token_create(token, attr, &path);",
            "\tif (err)",
            "\t\tgoto out_token;",
            "",
            "\tfd = get_unused_fd_flags(O_CLOEXEC);",
            "\tif (fd < 0) {",
            "\t\terr = fd;",
            "\t\tgoto out_token;",
            "\t}",
            "",
            "\tfile->private_data = token;",
            "\tfd_install(fd, file);",
            "",
            "\treturn fd;",
            "",
            "out_token:",
            "\tbpf_token_free(token);",
            "out_file:",
            "\tfput(file);",
            "\treturn err;",
            "}"
          ],
          "function_name": "bpf_ns_capable, bpf_token_capable, bpf_token_inc, bpf_token_free, bpf_token_put_deferred, bpf_token_put, bpf_token_release, bpf_token_show_fdinfo, bpf_token_create",
          "description": "实现BPF令牌的权限检查、引用计数管理、延迟释放及创建逻辑，包括基于挂载选项的令牌初始化和安全策略校验。",
          "similarity": 0.6332582235336304
        }
      ]
    },
    {
      "source_file": "kernel/bpf/verifier.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:37:51\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\verifier.c`\n\n---\n\n# bpf/verifier.c 技术文档\n\n## 1. 文件概述\n\n`bpf/verifier.c` 是 Linux 内核 eBPF（extended Berkeley Packet Filter）子系统中的核心验证器实现文件。该文件实现了 **eBPF 程序静态验证器（verifier）**，负责在 eBPF 程序加载到内核前对其进行**安全性、正确性和合法性检查**。验证器通过模拟执行 eBPF 字节码，跟踪寄存器和栈的状态变化，确保程序不会导致内核崩溃、内存越界访问、无限循环或信息泄露等安全问题。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`bpf_verifier_stack_elem`**  \n  验证器在分析分支指令时使用的栈元素结构，用于保存程序状态快照（`bpf_verifier_state`）、当前指令索引（`insn_idx`）和前一条指令索引（`prev_insn_idx`），支持深度优先搜索和路径回溯。\n\n- **`bpf_verifier_ops[]`**  \n  全局数组，通过宏 `BPF_PROG_TYPE` 自动生成，为每种 eBPF 程序类型（如 socket filter、tc、tracepoint、LSM 等）关联对应的验证器操作集（`bpf_verifier_ops`），实现程序类型特定的验证逻辑。\n\n- **`bpf_global_percpu_ma`**  \n  全局 per-CPU 内存分配器，用于验证过程中高效分配临时内存。\n\n### 主要函数（基于注释推断）\n\n- **`bpf_check()`**  \n  验证器主入口函数，执行两阶段分析：\n  1. **第一阶段（DAG 检查）**：深度优先搜索，验证程序为有向无环图（DAG），拒绝包含循环、不可达指令、越界跳转或超过 `BPF_MAXINSNS` 指令数的程序。\n  2. **第二阶段（路径模拟）**：遍历所有可能执行路径，模拟寄存器和栈状态变化，检查内存访问合法性、函数调用参数合规性及资源引用管理。\n\n## 3. 关键实现\n\n### 寄存器状态跟踪\n- 所有寄存器（R0-R10）均为 64 位，具有**动态类型**（如 `SCALAR_VALUE`、`PTR_TO_CTX`、`PTR_TO_STACK`、`PTR_TO_MAP_VALUE` 等）。\n- 验证器根据指令语义更新寄存器类型。例如：\n  - `BPF_MOV64_REG(R1, R10)` 将 R10 的 `FRAME_PTR` 类型复制到 R1。\n  - `BPF_ALU64_IMM(BPF_ADD, R1, -20)` 将 R1 转换为 `PTR_TO_STACK` 类型，并记录偏移量 `-20` 用于后续栈边界检查。\n\n### 内存访问验证\n- 仅允许通过四种指针类型访问内存：`PTR_TO_MAP_VALUE`、`PTR_TO_CTX`、`PTR_TO_STACK`、`PTR_TO_SOCKET`。\n- 对 `PTR_TO_STACK` 访问，验证器检查：\n  - 访问范围是否在栈边界内。\n  - 相关栈内存是否已初始化。\n\n### 辅助函数调用验证\n- 基于辅助函数原型（如 `bpf_map_lookup_elem`）的参数约束（如 `ARG_CONST_MAP_PTR`、`ARG_PTR_TO_MAP_KEY`）验证寄存器类型和内存状态。\n- 返回值类型（如 `RET_PTR_TO_MAP_VALUE_OR_NULL`）影响 R0 的类型，并在条件分支中动态转换（如 `PTR_TO_MAP_VALUE_OR_NULL` → `PTR_TO_MAP_VALUE` 或 `CONST_IMM`）。\n\n### 资源引用管理\n- 对返回引用类型（如 `PTR_TO_SOCKET_OR_NULL`）的辅助函数，验证器分配唯一指针 ID 并跟踪其生命周期。\n- 引用必须通过显式释放函数（如 `bpf_sk_release`）或 NULL 检查分支释放，否则程序被拒绝。\n\n### 路径分析限制\n- 单次路径分析指令数上限：64K。\n- 分支分析数量上限：1K，防止路径爆炸导致验证器超时。\n\n## 4. 依赖关系\n\n### 内核头文件依赖\n- **eBPF 核心**：`<linux/bpf.h>`, `<linux/bpf_verifier.h>`, `<linux/filter.h>`\n- **BTF（BPF Type Format）**：`<uapi/linux/btf.h>`, `<linux/btf.h>`\n- **内存管理**：`<linux/slab.h>`, `<linux/vmalloc.h>`, `<linux/bpf_mem_alloc.h>`\n- **网络子系统**：`<net/netlink.h>`, `<net/xdp.h>`\n- **安全模块**：`<linux/bpf_lsm.h>`, `<linux/bpf-cgroup.h>`\n- **其他**：`<linux/perf_event.h>`, `<linux/cpumask.h>`, `<linux/error-injection.h>`\n\n### 内部依赖\n- **`disasm.h`**：提供 eBPF 指令反汇编支持，用于生成人类可读的验证错误日志。\n- **`bpf_types.h`**：通过宏定义生成 `bpf_verifier_ops` 数组，关联程序类型与验证逻辑。\n\n## 5. 使用场景\n\n- **eBPF 程序加载**：当用户空间通过 `bpf(BPF_PROG_LOAD, ...)` 系统调用加载 eBPF 程序时，内核调用 `bpf_check()` 执行验证。\n- **安全沙箱**：确保任意 eBPF 程序（包括来自非特权用户的程序）无法破坏内核稳定性或绕过安全策略。\n- **程序类型适配**：通过 `bpf_verifier_ops` 为不同程序类型（如网络过滤、跟踪、安全策略）提供定制化验证规则。\n- **资源泄漏防护**：强制 eBPF 程序正确管理内核资源（如 socket、map 引用），防止资源耗尽。",
      "similarity": 0.7041274309158325,
      "chunks": [
        {
          "chunk_id": 73,
          "file_path": "kernel/bpf/verifier.c",
          "start_line": 12208,
          "end_line": 12333,
          "content": [
            "static int process_irq_flag(struct bpf_verifier_env *env, int regno,",
            "\t\t\t     struct bpf_kfunc_call_arg_meta *meta)",
            "{",
            "\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];",
            "\tbool irq_save;",
            "\tint err;",
            "",
            "\tif (meta->func_id == special_kfunc_list[KF_bpf_local_irq_save]) {",
            "\t\tirq_save = true;",
            "\t} else if (meta->func_id == special_kfunc_list[KF_bpf_local_irq_restore]) {",
            "\t\tirq_save = false;",
            "\t} else {",
            "\t\tverbose(env, \"verifier internal error: unknown irq flags kfunc\\n\");",
            "\t\treturn -EFAULT;",
            "\t}",
            "",
            "\tif (irq_save) {",
            "\t\tif (!is_irq_flag_reg_valid_uninit(env, reg)) {",
            "\t\t\tverbose(env, \"expected uninitialized irq flag as arg#%d\\n\", regno - 1);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\terr = check_mem_access(env, env->insn_idx, regno, 0, BPF_DW, BPF_WRITE, -1, false, false);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "",
            "\t\terr = mark_stack_slot_irq_flag(env, meta, reg, env->insn_idx);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t} else {",
            "\t\terr = is_irq_flag_reg_valid_init(env, reg);",
            "\t\tif (err) {",
            "\t\t\tverbose(env, \"expected an initialized irq flag as arg#%d\\n\", regno - 1);",
            "\t\t\treturn err;",
            "\t\t}",
            "",
            "\t\terr = mark_irq_flag_read(env, reg);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "",
            "\t\terr = unmark_stack_slot_irq_flag(env, reg);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int ref_set_non_owning(struct bpf_verifier_env *env, struct bpf_reg_state *reg)",
            "{",
            "\tstruct btf_record *rec = reg_btf_record(reg);",
            "",
            "\tif (!env->cur_state->active_locks) {",
            "\t\tverbose(env, \"verifier internal error: ref_set_non_owning w/o active lock\\n\");",
            "\t\treturn -EFAULT;",
            "\t}",
            "",
            "\tif (type_flag(reg->type) & NON_OWN_REF) {",
            "\t\tverbose(env, \"verifier internal error: NON_OWN_REF already set\\n\");",
            "\t\treturn -EFAULT;",
            "\t}",
            "",
            "\treg->type |= NON_OWN_REF;",
            "\tif (rec->refcount_off >= 0)",
            "\t\treg->type |= MEM_RCU;",
            "",
            "\treturn 0;",
            "}",
            "static int ref_convert_owning_non_owning(struct bpf_verifier_env *env, u32 ref_obj_id)",
            "{",
            "\tstruct bpf_verifier_state *state = env->cur_state;",
            "\tstruct bpf_func_state *unused;",
            "\tstruct bpf_reg_state *reg;",
            "\tint i;",
            "",
            "\tif (!ref_obj_id) {",
            "\t\tverbose(env, \"verifier internal error: ref_obj_id is zero for \"",
            "\t\t\t     \"owning -> non-owning conversion\\n\");",
            "\t\treturn -EFAULT;",
            "\t}",
            "",
            "\tfor (i = 0; i < state->acquired_refs; i++) {",
            "\t\tif (state->refs[i].id != ref_obj_id)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Clear ref_obj_id here so release_reference doesn't clobber",
            "\t\t * the whole reg",
            "\t\t */",
            "\t\tbpf_for_each_reg_in_vstate(env->cur_state, unused, reg, ({",
            "\t\t\tif (reg->ref_obj_id == ref_obj_id) {",
            "\t\t\t\treg->ref_obj_id = 0;",
            "\t\t\t\tref_set_non_owning(env, reg);",
            "\t\t\t}",
            "\t\t}));",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tverbose(env, \"verifier internal error: ref state missing for ref_obj_id\\n\");",
            "\treturn -EFAULT;",
            "}",
            "static int check_reg_allocation_locked(struct bpf_verifier_env *env, struct bpf_reg_state *reg)",
            "{",
            "\tstruct bpf_reference_state *s;",
            "\tvoid *ptr;",
            "\tu32 id;",
            "",
            "\tswitch ((int)reg->type) {",
            "\tcase PTR_TO_MAP_VALUE:",
            "\t\tptr = reg->map_ptr;",
            "\t\tbreak;",
            "\tcase PTR_TO_BTF_ID | MEM_ALLOC:",
            "\t\tptr = reg->btf;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tverbose(env, \"verifier internal error: unknown reg type for lock check\\n\");",
            "\t\treturn -EFAULT;",
            "\t}",
            "\tid = reg->id;",
            "",
            "\tif (!env->cur_state->active_locks)",
            "\t\treturn -EINVAL;",
            "\ts = find_lock_state(env->cur_state, REF_TYPE_LOCK, id, ptr);",
            "\tif (!s) {",
            "\t\tverbose(env, \"held lock and object are not in the same allocation\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "process_irq_flag, ref_set_non_owning, ref_convert_owning_non_owning, check_reg_allocation_locked",
          "description": "处理中断标志位的操作验证、引用所有权转换及锁状态检查，确保BPF程序在操作硬件中断标志或引用计数时遵循正确的同步规则。",
          "similarity": 0.6984394788742065
        },
        {
          "chunk_id": 113,
          "file_path": "kernel/bpf/verifier.c",
          "start_line": 20023,
          "end_line": 20134,
          "content": [
            "static void release_maps(struct bpf_verifier_env *env)",
            "{",
            "\t__bpf_free_used_maps(env->prog->aux, env->used_maps,",
            "\t\t\t     env->used_map_cnt);",
            "}",
            "static void release_btfs(struct bpf_verifier_env *env)",
            "{",
            "\t__bpf_free_used_btfs(env->prog->aux, env->used_btfs,",
            "\t\t\t     env->used_btf_cnt);",
            "}",
            "static void convert_pseudo_ld_imm64(struct bpf_verifier_env *env)",
            "{",
            "\tstruct bpf_insn *insn = env->prog->insnsi;",
            "\tint insn_cnt = env->prog->len;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < insn_cnt; i++, insn++) {",
            "\t\tif (insn->code != (BPF_LD | BPF_IMM | BPF_DW))",
            "\t\t\tcontinue;",
            "\t\tif (insn->src_reg == BPF_PSEUDO_FUNC)",
            "\t\t\tcontinue;",
            "\t\tinsn->src_reg = 0;",
            "\t}",
            "}",
            "static void adjust_insn_aux_data(struct bpf_verifier_env *env,",
            "\t\t\t\t struct bpf_insn_aux_data *new_data,",
            "\t\t\t\t struct bpf_prog *new_prog, u32 off, u32 cnt)",
            "{",
            "\tstruct bpf_insn_aux_data *old_data = env->insn_aux_data;",
            "\tstruct bpf_insn *insn = new_prog->insnsi;",
            "\tu32 old_seen = old_data[off].seen;",
            "\tu32 prog_len;",
            "\tint i;",
            "",
            "\t/* aux info at OFF always needs adjustment, no matter fast path",
            "\t * (cnt == 1) is taken or not. There is no guarantee INSN at OFF is the",
            "\t * original insn at old prog.",
            "\t */",
            "\told_data[off].zext_dst = insn_has_def32(env, insn + off + cnt - 1);",
            "",
            "\tif (cnt == 1)",
            "\t\treturn;",
            "\tprog_len = new_prog->len;",
            "",
            "\tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);",
            "\tmemcpy(new_data + off + cnt - 1, old_data + off,",
            "\t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));",
            "\tfor (i = off; i < off + cnt - 1; i++) {",
            "\t\t/* Expand insni[off]'s seen count to the patched range. */",
            "\t\tnew_data[i].seen = old_seen;",
            "\t\tnew_data[i].zext_dst = insn_has_def32(env, insn + i);",
            "\t}",
            "\tenv->insn_aux_data = new_data;",
            "\tvfree(old_data);",
            "}",
            "static void adjust_subprog_starts(struct bpf_verifier_env *env, u32 off, u32 len)",
            "{",
            "\tint i;",
            "",
            "\tif (len == 1)",
            "\t\treturn;",
            "\t/* NOTE: fake 'exit' subprog should be updated as well. */",
            "\tfor (i = 0; i <= env->subprog_cnt; i++) {",
            "\t\tif (env->subprog_info[i].start <= off)",
            "\t\t\tcontinue;",
            "\t\tenv->subprog_info[i].start += len - 1;",
            "\t}",
            "}",
            "static void adjust_poke_descs(struct bpf_prog *prog, u32 off, u32 len)",
            "{",
            "\tstruct bpf_jit_poke_descriptor *tab = prog->aux->poke_tab;",
            "\tint i, sz = prog->aux->size_poke_tab;",
            "\tstruct bpf_jit_poke_descriptor *desc;",
            "",
            "\tfor (i = 0; i < sz; i++) {",
            "\t\tdesc = &tab[i];",
            "\t\tif (desc->insn_idx <= off)",
            "\t\t\tcontinue;",
            "\t\tdesc->insn_idx += len - 1;",
            "\t}",
            "}",
            "static int adjust_jmp_off(struct bpf_prog *prog, u32 tgt_idx, u32 delta)",
            "{",
            "\tstruct bpf_insn *insn = prog->insnsi;",
            "\tu32 insn_cnt = prog->len, i;",
            "",
            "\tfor (i = 0; i < insn_cnt; i++, insn++) {",
            "\t\tu8 code = insn->code;",
            "",
            "\t\tif (tgt_idx <= i && i < tgt_idx + delta)",
            "\t\t\tcontinue;",
            "",
            "\t\tif ((BPF_CLASS(code) != BPF_JMP && BPF_CLASS(code) != BPF_JMP32) ||",
            "\t\t    BPF_OP(code) == BPF_CALL || BPF_OP(code) == BPF_EXIT)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (insn->code == (BPF_JMP32 | BPF_JA)) {",
            "\t\t\tif (i + 1 + insn->imm != tgt_idx)",
            "\t\t\t\tcontinue;",
            "\t\t\tif (signed_add32_overflows(insn->imm, delta))",
            "\t\t\t\treturn -ERANGE;",
            "\t\t\tinsn->imm += delta;",
            "\t\t} else {",
            "\t\t\tif (i + 1 + insn->off != tgt_idx)",
            "\t\t\t\tcontinue;",
            "\t\t\tif (signed_add16_overflows(insn->off, delta))",
            "\t\t\t\treturn -ERANGE;",
            "\t\t\tinsn->off += delta;",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "release_maps, release_btfs, convert_pseudo_ld_imm64, adjust_insn_aux_data, adjust_subprog_starts, adjust_poke_descs, adjust_jmp_off",
          "description": "该代码段实现BPF验证器在程序修改后的资源清理与结构调整。  \n`release_maps`和`release_btfs`用于释放验证过程中分配的map和BTF对象；`convert_pseudo_ld_imm64`将伪立即数加载指令转换为标准格式；其余函数通过调整辅助数据、子程序起始地址、POKE描述符及跳转偏移量，保证程序修改后各元数据与新指令集一致。",
          "similarity": 0.6933469772338867
        },
        {
          "chunk_id": 67,
          "file_path": "kernel/bpf/verifier.c",
          "start_line": 10936,
          "end_line": 11052,
          "content": [
            "static int check_resource_leak(struct bpf_verifier_env *env, bool exception_exit, bool check_lock, const char *prefix)",
            "{",
            "\tint err;",
            "",
            "\tif (check_lock && env->cur_state->active_locks) {",
            "\t\tverbose(env, \"%s cannot be used inside bpf_spin_lock-ed region\\n\", prefix);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\terr = check_reference_leak(env, exception_exit);",
            "\tif (err) {",
            "\t\tverbose(env, \"%s would lead to reference leak\\n\", prefix);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tif (check_lock && env->cur_state->active_irq_id) {",
            "\t\tverbose(env, \"%s cannot be used inside bpf_local_irq_save-ed region\\n\", prefix);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (check_lock && env->cur_state->active_rcu_lock) {",
            "\t\tverbose(env, \"%s cannot be used inside bpf_rcu_read_lock-ed region\\n\", prefix);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (check_lock && env->cur_state->active_preempt_locks) {",
            "\t\tverbose(env, \"%s cannot be used inside bpf_preempt_disable-ed region\\n\", prefix);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int check_bpf_snprintf_call(struct bpf_verifier_env *env,",
            "\t\t\t\t   struct bpf_reg_state *regs)",
            "{",
            "\tstruct bpf_reg_state *fmt_reg = &regs[BPF_REG_3];",
            "\tstruct bpf_reg_state *data_len_reg = &regs[BPF_REG_5];",
            "\tstruct bpf_map *fmt_map = fmt_reg->map_ptr;",
            "\tstruct bpf_bprintf_data data = {};",
            "\tint err, fmt_map_off, num_args;",
            "\tu64 fmt_addr;",
            "\tchar *fmt;",
            "",
            "\t/* data must be an array of u64 */",
            "\tif (data_len_reg->var_off.value % 8)",
            "\t\treturn -EINVAL;",
            "\tnum_args = data_len_reg->var_off.value / 8;",
            "",
            "\t/* fmt being ARG_PTR_TO_CONST_STR guarantees that var_off is const",
            "\t * and map_direct_value_addr is set.",
            "\t */",
            "\tfmt_map_off = fmt_reg->off + fmt_reg->var_off.value;",
            "\terr = fmt_map->ops->map_direct_value_addr(fmt_map, &fmt_addr,",
            "\t\t\t\t\t\t  fmt_map_off);",
            "\tif (err) {",
            "\t\tverbose(env, \"verifier bug\\n\");",
            "\t\treturn -EFAULT;",
            "\t}",
            "\tfmt = (char *)(long)fmt_addr + fmt_map_off;",
            "",
            "\t/* We are also guaranteed that fmt+fmt_map_off is NULL terminated, we",
            "\t * can focus on validating the format specifiers.",
            "\t */",
            "\terr = bpf_bprintf_prepare(fmt, UINT_MAX, NULL, num_args, &data);",
            "\tif (err < 0)",
            "\t\tverbose(env, \"Invalid format string\\n\");",
            "",
            "\treturn err;",
            "}",
            "static int check_get_func_ip(struct bpf_verifier_env *env)",
            "{",
            "\tenum bpf_prog_type type = resolve_prog_type(env->prog);",
            "\tint func_id = BPF_FUNC_get_func_ip;",
            "",
            "\tif (type == BPF_PROG_TYPE_TRACING) {",
            "\t\tif (!bpf_prog_has_trampoline(env->prog)) {",
            "\t\t\tverbose(env, \"func %s#%d supported only for fentry/fexit/fmod_ret programs\\n\",",
            "\t\t\t\tfunc_id_name(func_id), func_id);",
            "\t\t\treturn -ENOTSUPP;",
            "\t\t}",
            "\t\treturn 0;",
            "\t} else if (type == BPF_PROG_TYPE_KPROBE) {",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tverbose(env, \"func %s#%d not supported for program type %d\\n\",",
            "\t\tfunc_id_name(func_id), func_id, type);",
            "\treturn -ENOTSUPP;",
            "}",
            "static bool loop_flag_is_zero(struct bpf_verifier_env *env)",
            "{",
            "\tstruct bpf_reg_state *regs = cur_regs(env);",
            "\tstruct bpf_reg_state *reg = &regs[BPF_REG_4];",
            "\tbool reg_is_null = register_is_null(reg);",
            "",
            "\tif (reg_is_null)",
            "\t\tmark_chain_precision(env, BPF_REG_4);",
            "",
            "\treturn reg_is_null;",
            "}",
            "static void update_loop_inline_state(struct bpf_verifier_env *env, u32 subprogno)",
            "{",
            "\tstruct bpf_loop_inline_state *state = &cur_aux(env)->loop_inline_state;",
            "",
            "\tif (!state->initialized) {",
            "\t\tstate->initialized = 1;",
            "\t\tstate->fit_for_inline = loop_flag_is_zero(env);",
            "\t\tstate->callback_subprogno = subprogno;",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (!state->fit_for_inline)",
            "\t\treturn;",
            "",
            "\tstate->fit_for_inline = (loop_flag_is_zero(env) &&",
            "\t\t\t\t state->callback_subprogno == subprogno);",
            "}"
          ],
          "function_name": "check_resource_leak, check_bpf_snprintf_call, check_get_func_ip, loop_flag_is_zero, update_loop_inline_state",
          "description": "该代码段主要实现BPF程序验证中的资源管理和格式校验逻辑。  \n`check_resource_leak` 检查锁状态及引用泄漏，防止在受保护区域使用非法操作；`check_bpf_snprintf_call` 验证`snprintf`调用的格式字符串合法性；`check_get_func_ip` 根据程序类型限制`get_func_ip`函数的使用场景；`loop_flag_is_zero`与`update_loop_inline_state`协同判断循环展开条件是否满足。",
          "similarity": 0.6928983926773071
        },
        {
          "chunk_id": 111,
          "file_path": "kernel/bpf/verifier.c",
          "start_line": 19655,
          "end_line": 19816,
          "content": [
            "static int check_pseudo_btf_id(struct bpf_verifier_env *env,",
            "\t\t\t       struct bpf_insn *insn,",
            "\t\t\t       struct bpf_insn_aux_data *aux)",
            "{",
            "\tstruct btf *btf;",
            "\tint btf_fd;",
            "\tint err;",
            "",
            "\tbtf_fd = insn[1].imm;",
            "\tif (btf_fd) {",
            "\t\tCLASS(fd, f)(btf_fd);",
            "",
            "\t\tbtf = __btf_get_by_fd(f);",
            "\t\tif (IS_ERR(btf)) {",
            "\t\t\tverbose(env, \"invalid module BTF object FD specified.\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t} else {",
            "\t\tif (!btf_vmlinux) {",
            "\t\t\tverbose(env, \"kernel is missing BTF, make sure CONFIG_DEBUG_INFO_BTF=y is specified in Kconfig.\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t\tbtf = btf_vmlinux;",
            "\t}",
            "",
            "\terr = __check_pseudo_btf_id(env, insn, aux, btf);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = __add_used_btf(env, btf);",
            "\tif (err < 0)",
            "\t\treturn err;",
            "\treturn 0;",
            "}",
            "static bool is_tracing_prog_type(enum bpf_prog_type type)",
            "{",
            "\tswitch (type) {",
            "\tcase BPF_PROG_TYPE_KPROBE:",
            "\tcase BPF_PROG_TYPE_TRACEPOINT:",
            "\tcase BPF_PROG_TYPE_PERF_EVENT:",
            "\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:",
            "\tcase BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE:",
            "\t\treturn true;",
            "\tdefault:",
            "\t\treturn false;",
            "\t}",
            "}",
            "static bool bpf_map_is_cgroup_storage(struct bpf_map *map)",
            "{",
            "\treturn (map->map_type == BPF_MAP_TYPE_CGROUP_STORAGE ||",
            "\t\tmap->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE);",
            "}",
            "static int check_map_prog_compatibility(struct bpf_verifier_env *env,",
            "\t\t\t\t\tstruct bpf_map *map,",
            "\t\t\t\t\tstruct bpf_prog *prog)",
            "",
            "{",
            "\tenum bpf_prog_type prog_type = resolve_prog_type(prog);",
            "",
            "\tif (btf_record_has_field(map->record, BPF_LIST_HEAD) ||",
            "\t    btf_record_has_field(map->record, BPF_RB_ROOT)) {",
            "\t\tif (is_tracing_prog_type(prog_type)) {",
            "\t\t\tverbose(env, \"tracing progs cannot use bpf_{list_head,rb_root} yet\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "",
            "\tif (btf_record_has_field(map->record, BPF_SPIN_LOCK)) {",
            "\t\tif (prog_type == BPF_PROG_TYPE_SOCKET_FILTER) {",
            "\t\t\tverbose(env, \"socket filter progs cannot use bpf_spin_lock yet\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (is_tracing_prog_type(prog_type)) {",
            "\t\t\tverbose(env, \"tracing progs cannot use bpf_spin_lock yet\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "",
            "\tif (btf_record_has_field(map->record, BPF_TIMER)) {",
            "\t\tif (is_tracing_prog_type(prog_type)) {",
            "\t\t\tverbose(env, \"tracing progs cannot use bpf_timer yet\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "",
            "\tif (btf_record_has_field(map->record, BPF_WORKQUEUE)) {",
            "\t\tif (is_tracing_prog_type(prog_type)) {",
            "\t\t\tverbose(env, \"tracing progs cannot use bpf_wq yet\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "",
            "\tif ((bpf_prog_is_offloaded(prog->aux) || bpf_map_is_offloaded(map)) &&",
            "\t    !bpf_offload_prog_map_match(prog, map)) {",
            "\t\tverbose(env, \"offload device mismatch between prog and map\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {",
            "\t\tverbose(env, \"bpf_struct_ops map cannot be used in prog\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (prog->sleepable)",
            "\t\tswitch (map->map_type) {",
            "\t\tcase BPF_MAP_TYPE_HASH:",
            "\t\tcase BPF_MAP_TYPE_LRU_HASH:",
            "\t\tcase BPF_MAP_TYPE_ARRAY:",
            "\t\tcase BPF_MAP_TYPE_PERCPU_HASH:",
            "\t\tcase BPF_MAP_TYPE_PERCPU_ARRAY:",
            "\t\tcase BPF_MAP_TYPE_LRU_PERCPU_HASH:",
            "\t\tcase BPF_MAP_TYPE_ARRAY_OF_MAPS:",
            "\t\tcase BPF_MAP_TYPE_HASH_OF_MAPS:",
            "\t\tcase BPF_MAP_TYPE_RINGBUF:",
            "\t\tcase BPF_MAP_TYPE_USER_RINGBUF:",
            "\t\tcase BPF_MAP_TYPE_INODE_STORAGE:",
            "\t\tcase BPF_MAP_TYPE_SK_STORAGE:",
            "\t\tcase BPF_MAP_TYPE_TASK_STORAGE:",
            "\t\tcase BPF_MAP_TYPE_CGRP_STORAGE:",
            "\t\tcase BPF_MAP_TYPE_QUEUE:",
            "\t\tcase BPF_MAP_TYPE_STACK:",
            "\t\tcase BPF_MAP_TYPE_ARENA:",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tverbose(env,",
            "\t\t\t\t\"Sleepable programs can only use array, hash, ringbuf and local storage maps\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\tif (bpf_map_is_cgroup_storage(map) &&",
            "\t    bpf_cgroup_storage_assign(env->prog->aux, map)) {",
            "\t\tverbose(env, \"only one cgroup storage of each type is allowed\\n\");",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\tif (map->map_type == BPF_MAP_TYPE_ARENA) {",
            "\t\tif (env->prog->aux->arena) {",
            "\t\t\tverbose(env, \"Only one arena per program\\n\");",
            "\t\t\treturn -EBUSY;",
            "\t\t}",
            "\t\tif (!env->allow_ptr_leaks || !env->bpf_capable) {",
            "\t\t\tverbose(env, \"CAP_BPF and CAP_PERFMON are required to use arena\\n\");",
            "\t\t\treturn -EPERM;",
            "\t\t}",
            "\t\tif (!env->prog->jit_requested) {",
            "\t\t\tverbose(env, \"JIT is required to use arena\\n\");",
            "\t\t\treturn -EOPNOTSUPP;",
            "\t\t}",
            "\t\tif (!bpf_jit_supports_arena()) {",
            "\t\t\tverbose(env, \"JIT doesn't support arena\\n\");",
            "\t\t\treturn -EOPNOTSUPP;",
            "\t\t}",
            "\t\tenv->prog->aux->arena = (void *)map;",
            "\t\tif (!bpf_arena_get_user_vm_start(env->prog->aux->arena)) {",
            "\t\t\tverbose(env, \"arena's user address must be set via map_extra or mmap()\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "check_pseudo_btf_id, is_tracing_prog_type, bpf_map_is_cgroup_storage, check_map_prog_compatibility",
          "description": "该代码段主要实现BPF程序与map的兼容性校验及BTF相关验证。  \n`check_pseudo_btf_id`验证伪BTF ID有效性并绑定BTF数据，`is_tracing_prog_type`判断是否为跟踪类程序类型，`bpf_map_is_cgroup_storage`检测CGroup存储map类型，而`check_map_prog_compatibility`校验程序与map的字段兼容性、离线设备匹配、资源限制等规则。  \n代码片段完整展示各函数核心逻辑，未缺失关键上下文。",
          "similarity": 0.683319628238678
        },
        {
          "chunk_id": 68,
          "file_path": "kernel/bpf/verifier.c",
          "start_line": 11063,
          "end_line": 11599,
          "content": [
            "static int get_helper_proto(struct bpf_verifier_env *env, int func_id,",
            "\t\t\t    const struct bpf_func_proto **ptr)",
            "{",
            "\tif (func_id < 0 || func_id >= __BPF_FUNC_MAX_ID)",
            "\t\treturn -ERANGE;",
            "",
            "\tif (!env->ops->get_func_proto)",
            "\t\treturn -EINVAL;",
            "",
            "\t*ptr = env->ops->get_func_proto(func_id, env->prog);",
            "\treturn *ptr ? 0 : -EINVAL;",
            "}",
            "static int check_helper_call(struct bpf_verifier_env *env, struct bpf_insn *insn,",
            "\t\t\t     int *insn_idx_p)",
            "{",
            "\tenum bpf_prog_type prog_type = resolve_prog_type(env->prog);",
            "\tbool returns_cpu_specific_alloc_ptr = false;",
            "\tconst struct bpf_func_proto *fn = NULL;",
            "\tenum bpf_return_type ret_type;",
            "\tenum bpf_type_flag ret_flag;",
            "\tstruct bpf_reg_state *regs;",
            "\tstruct bpf_call_arg_meta meta;",
            "\tint insn_idx = *insn_idx_p;",
            "\tbool changes_data;",
            "\tint i, err, func_id;",
            "",
            "\t/* find function prototype */",
            "\tfunc_id = insn->imm;",
            "\terr = get_helper_proto(env, insn->imm, &fn);",
            "\tif (err == -ERANGE) {",
            "\t\tverbose(env, \"invalid func %s#%d\\n\", func_id_name(func_id), func_id);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (err) {",
            "\t\tverbose(env, \"program of this type cannot use helper %s#%d\\n\",",
            "\t\t\tfunc_id_name(func_id), func_id);",
            "\t\treturn err;",
            "\t}",
            "",
            "\t/* eBPF programs must be GPL compatible to use GPL-ed functions */",
            "\tif (!env->prog->gpl_compatible && fn->gpl_only) {",
            "\t\tverbose(env, \"cannot call GPL-restricted function from non-GPL compatible program\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (fn->allowed && !fn->allowed(env->prog)) {",
            "\t\tverbose(env, \"helper call is not allowed in probe\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (!in_sleepable(env) && fn->might_sleep) {",
            "\t\tverbose(env, \"helper call might sleep in a non-sleepable prog\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* With LD_ABS/IND some JITs save/restore skb from r1. */",
            "\tchanges_data = bpf_helper_changes_pkt_data(func_id);",
            "\tif (changes_data && fn->arg1_type != ARG_PTR_TO_CTX) {",
            "\t\tverbose(env, \"kernel subsystem misconfigured func %s#%d: r1 != ctx\\n\",",
            "\t\t\tfunc_id_name(func_id), func_id);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tmemset(&meta, 0, sizeof(meta));",
            "\tmeta.pkt_access = fn->pkt_access;",
            "",
            "\terr = check_func_proto(fn, func_id);",
            "\tif (err) {",
            "\t\tverbose(env, \"kernel subsystem misconfigured func %s#%d\\n\",",
            "\t\t\tfunc_id_name(func_id), func_id);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tif (env->cur_state->active_rcu_lock) {",
            "\t\tif (fn->might_sleep) {",
            "\t\t\tverbose(env, \"sleepable helper %s#%d in rcu_read_lock region\\n\",",
            "\t\t\t\tfunc_id_name(func_id), func_id);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (in_sleepable(env) && is_storage_get_function(func_id))",
            "\t\t\tenv->insn_aux_data[insn_idx].storage_get_func_atomic = true;",
            "\t}",
            "",
            "\tif (env->cur_state->active_preempt_locks) {",
            "\t\tif (fn->might_sleep) {",
            "\t\t\tverbose(env, \"sleepable helper %s#%d in non-preemptible region\\n\",",
            "\t\t\t\tfunc_id_name(func_id), func_id);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (in_sleepable(env) && is_storage_get_function(func_id))",
            "\t\t\tenv->insn_aux_data[insn_idx].storage_get_func_atomic = true;",
            "\t}",
            "",
            "\tif (env->cur_state->active_irq_id) {",
            "\t\tif (fn->might_sleep) {",
            "\t\t\tverbose(env, \"sleepable helper %s#%d in IRQ-disabled region\\n\",",
            "\t\t\t\tfunc_id_name(func_id), func_id);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (in_sleepable(env) && is_storage_get_function(func_id))",
            "\t\t\tenv->insn_aux_data[insn_idx].storage_get_func_atomic = true;",
            "\t}",
            "",
            "\tmeta.func_id = func_id;",
            "\t/* check args */",
            "\tfor (i = 0; i < MAX_BPF_FUNC_REG_ARGS; i++) {",
            "\t\terr = check_func_arg(env, i, &meta, fn, insn_idx);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t}",
            "",
            "\terr = record_func_map(env, &meta, func_id, insn_idx);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = record_func_key(env, &meta, func_id, insn_idx);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\t/* Mark slots with STACK_MISC in case of raw mode, stack offset",
            "\t * is inferred from register state.",
            "\t */",
            "\tfor (i = 0; i < meta.access_size; i++) {",
            "\t\terr = check_mem_access(env, insn_idx, meta.regno, i, BPF_B,",
            "\t\t\t\t       BPF_WRITE, -1, false, false);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t}",
            "",
            "\tregs = cur_regs(env);",
            "",
            "\tif (meta.release_regno) {",
            "\t\terr = -EINVAL;",
            "\t\t/* This can only be set for PTR_TO_STACK, as CONST_PTR_TO_DYNPTR cannot",
            "\t\t * be released by any dynptr helper. Hence, unmark_stack_slots_dynptr",
            "\t\t * is safe to do directly.",
            "\t\t */",
            "\t\tif (arg_type_is_dynptr(fn->arg_type[meta.release_regno - BPF_REG_1])) {",
            "\t\t\tif (regs[meta.release_regno].type == CONST_PTR_TO_DYNPTR) {",
            "\t\t\t\tverbose(env, \"verifier internal error: CONST_PTR_TO_DYNPTR cannot be released\\n\");",
            "\t\t\t\treturn -EFAULT;",
            "\t\t\t}",
            "\t\t\terr = unmark_stack_slots_dynptr(env, &regs[meta.release_regno]);",
            "\t\t} else if (func_id == BPF_FUNC_kptr_xchg && meta.ref_obj_id) {",
            "\t\t\tu32 ref_obj_id = meta.ref_obj_id;",
            "\t\t\tbool in_rcu = in_rcu_cs(env);",
            "\t\t\tstruct bpf_func_state *state;",
            "\t\t\tstruct bpf_reg_state *reg;",
            "",
            "\t\t\terr = release_reference_nomark(env->cur_state, ref_obj_id);",
            "\t\t\tif (!err) {",
            "\t\t\t\tbpf_for_each_reg_in_vstate(env->cur_state, state, reg, ({",
            "\t\t\t\t\tif (reg->ref_obj_id == ref_obj_id) {",
            "\t\t\t\t\t\tif (in_rcu && (reg->type & MEM_ALLOC) && (reg->type & MEM_PERCPU)) {",
            "\t\t\t\t\t\t\treg->ref_obj_id = 0;",
            "\t\t\t\t\t\t\treg->type &= ~MEM_ALLOC;",
            "\t\t\t\t\t\t\treg->type |= MEM_RCU;",
            "\t\t\t\t\t\t} else {",
            "\t\t\t\t\t\t\tmark_reg_invalid(env, reg);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t}));",
            "\t\t\t}",
            "\t\t} else if (meta.ref_obj_id) {",
            "\t\t\terr = release_reference(env, meta.ref_obj_id);",
            "\t\t} else if (register_is_null(&regs[meta.release_regno])) {",
            "\t\t\t/* meta.ref_obj_id can only be 0 if register that is meant to be",
            "\t\t\t * released is NULL, which must be > R0.",
            "\t\t\t */",
            "\t\t\terr = 0;",
            "\t\t}",
            "\t\tif (err) {",
            "\t\t\tverbose(env, \"func %s#%d reference has not been acquired before\\n\",",
            "\t\t\t\tfunc_id_name(func_id), func_id);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t}",
            "",
            "\tswitch (func_id) {",
            "\tcase BPF_FUNC_tail_call:",
            "\t\terr = check_resource_leak(env, false, true, \"tail_call\");",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t\tbreak;",
            "\tcase BPF_FUNC_get_local_storage:",
            "\t\t/* check that flags argument in get_local_storage(map, flags) is 0,",
            "\t\t * this is required because get_local_storage() can't return an error.",
            "\t\t */",
            "\t\tif (!register_is_null(&regs[BPF_REG_2])) {",
            "\t\t\tverbose(env, \"get_local_storage() doesn't support non-zero flags\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase BPF_FUNC_for_each_map_elem:",
            "\t\terr = push_callback_call(env, insn, insn_idx, meta.subprogno,",
            "\t\t\t\t\t set_map_elem_callback_state);",
            "\t\tbreak;",
            "\tcase BPF_FUNC_timer_set_callback:",
            "\t\terr = push_callback_call(env, insn, insn_idx, meta.subprogno,",
            "\t\t\t\t\t set_timer_callback_state);",
            "\t\tbreak;",
            "\tcase BPF_FUNC_find_vma:",
            "\t\terr = push_callback_call(env, insn, insn_idx, meta.subprogno,",
            "\t\t\t\t\t set_find_vma_callback_state);",
            "\t\tbreak;",
            "\tcase BPF_FUNC_snprintf:",
            "\t\terr = check_bpf_snprintf_call(env, regs);",
            "\t\tbreak;",
            "\tcase BPF_FUNC_loop:",
            "\t\tupdate_loop_inline_state(env, meta.subprogno);",
            "\t\t/* Verifier relies on R1 value to determine if bpf_loop() iteration",
            "\t\t * is finished, thus mark it precise.",
            "\t\t */",
            "\t\terr = mark_chain_precision(env, BPF_REG_1);",
            "\t\tif (err)",
            "\t\t\treturn err;",
            "\t\tif (cur_func(env)->callback_depth < regs[BPF_REG_1].umax_value) {",
            "\t\t\terr = push_callback_call(env, insn, insn_idx, meta.subprogno,",
            "\t\t\t\t\t\t set_loop_callback_state);",
            "\t\t} else {",
            "\t\t\tcur_func(env)->callback_depth = 0;",
            "\t\t\tif (env->log.level & BPF_LOG_LEVEL2)",
            "\t\t\t\tverbose(env, \"frame%d bpf_loop iteration limit reached\\n\",",
            "\t\t\t\t\tenv->cur_state->curframe);",
            "\t\t}",
            "\t\tbreak;",
            "\tcase BPF_FUNC_dynptr_from_mem:",
            "\t\tif (regs[BPF_REG_1].type != PTR_TO_MAP_VALUE) {",
            "\t\t\tverbose(env, \"Unsupported reg type %s for bpf_dynptr_from_mem data\\n\",",
            "\t\t\t\treg_type_str(env, regs[BPF_REG_1].type));",
            "\t\t\treturn -EACCES;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase BPF_FUNC_set_retval:",
            "\t\tif (prog_type == BPF_PROG_TYPE_LSM &&",
            "\t\t    env->prog->expected_attach_type == BPF_LSM_CGROUP) {",
            "\t\t\tif (!env->prog->aux->attach_func_proto->type) {",
            "\t\t\t\t/* Make sure programs that attach to void",
            "\t\t\t\t * hooks don't try to modify return value.",
            "\t\t\t\t */",
            "\t\t\t\tverbose(env, \"BPF_LSM_CGROUP that attach to void LSM hooks can't modify return value!\\n\");",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "\t\t}",
            "\t\tbreak;",
            "\tcase BPF_FUNC_dynptr_data:",
            "\t{",
            "\t\tstruct bpf_reg_state *reg;",
            "\t\tint id, ref_obj_id;",
            "",
            "\t\treg = get_dynptr_arg_reg(env, fn, regs);",
            "\t\tif (!reg)",
            "\t\t\treturn -EFAULT;",
            "",
            "",
            "\t\tif (meta.dynptr_id) {",
            "\t\t\tverbose(env, \"verifier internal error: meta.dynptr_id already set\\n\");",
            "\t\t\treturn -EFAULT;",
            "\t\t}",
            "\t\tif (meta.ref_obj_id) {",
            "\t\t\tverbose(env, \"verifier internal error: meta.ref_obj_id already set\\n\");",
            "\t\t\treturn -EFAULT;",
            "\t\t}",
            "",
            "\t\tid = dynptr_id(env, reg);",
            "\t\tif (id < 0) {",
            "\t\t\tverbose(env, \"verifier internal error: failed to obtain dynptr id\\n\");",
            "\t\t\treturn id;",
            "\t\t}",
            "",
            "\t\tref_obj_id = dynptr_ref_obj_id(env, reg);",
            "\t\tif (ref_obj_id < 0) {",
            "\t\t\tverbose(env, \"verifier internal error: failed to obtain dynptr ref_obj_id\\n\");",
            "\t\t\treturn ref_obj_id;",
            "\t\t}",
            "",
            "\t\tmeta.dynptr_id = id;",
            "\t\tmeta.ref_obj_id = ref_obj_id;",
            "",
            "\t\tbreak;",
            "\t}",
            "\tcase BPF_FUNC_dynptr_write:",
            "\t{",
            "\t\tenum bpf_dynptr_type dynptr_type;",
            "\t\tstruct bpf_reg_state *reg;",
            "",
            "\t\treg = get_dynptr_arg_reg(env, fn, regs);",
            "\t\tif (!reg)",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tdynptr_type = dynptr_get_type(env, reg);",
            "\t\tif (dynptr_type == BPF_DYNPTR_TYPE_INVALID)",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tif (dynptr_type == BPF_DYNPTR_TYPE_SKB)",
            "\t\t\t/* this will trigger clear_all_pkt_pointers(), which will",
            "\t\t\t * invalidate all dynptr slices associated with the skb",
            "\t\t\t */",
            "\t\t\tchanges_data = true;",
            "",
            "\t\tbreak;",
            "\t}",
            "\tcase BPF_FUNC_per_cpu_ptr:",
            "\tcase BPF_FUNC_this_cpu_ptr:",
            "\t{",
            "\t\tstruct bpf_reg_state *reg = &regs[BPF_REG_1];",
            "\t\tconst struct btf_type *type;",
            "",
            "\t\tif (reg->type & MEM_RCU) {",
            "\t\t\ttype = btf_type_by_id(reg->btf, reg->btf_id);",
            "\t\t\tif (!type || !btf_type_is_struct(type)) {",
            "\t\t\t\tverbose(env, \"Helper has invalid btf/btf_id in R1\\n\");",
            "\t\t\t\treturn -EFAULT;",
            "\t\t\t}",
            "\t\t\treturns_cpu_specific_alloc_ptr = true;",
            "\t\t\tenv->insn_aux_data[insn_idx].call_with_percpu_alloc_ptr = true;",
            "\t\t}",
            "\t\tbreak;",
            "\t}",
            "\tcase BPF_FUNC_user_ringbuf_drain:",
            "\t\terr = push_callback_call(env, insn, insn_idx, meta.subprogno,",
            "\t\t\t\t\t set_user_ringbuf_callback_state);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\t/* reset caller saved regs */",
            "\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {",
            "\t\tmark_reg_not_init(env, regs, caller_saved[i]);",
            "\t\tcheck_reg_arg(env, caller_saved[i], DST_OP_NO_MARK);",
            "\t}",
            "",
            "\t/* helper call returns 64-bit value. */",
            "\tregs[BPF_REG_0].subreg_def = DEF_NOT_SUBREG;",
            "",
            "\t/* update return register (already marked as written above) */",
            "\tret_type = fn->ret_type;",
            "\tret_flag = type_flag(ret_type);",
            "",
            "\tswitch (base_type(ret_type)) {",
            "\tcase RET_INTEGER:",
            "\t\t/* sets type to SCALAR_VALUE */",
            "\t\tmark_reg_unknown(env, regs, BPF_REG_0);",
            "\t\tbreak;",
            "\tcase RET_VOID:",
            "\t\tregs[BPF_REG_0].type = NOT_INIT;",
            "\t\tbreak;",
            "\tcase RET_PTR_TO_MAP_VALUE:",
            "\t\t/* There is no offset yet applied, variable or fixed */",
            "\t\tmark_reg_known_zero(env, regs, BPF_REG_0);",
            "\t\t/* remember map_ptr, so that check_map_access()",
            "\t\t * can check 'value_size' boundary of memory access",
            "\t\t * to map element returned from bpf_map_lookup_elem()",
            "\t\t */",
            "\t\tif (meta.map_ptr == NULL) {",
            "\t\t\tverbose(env,",
            "\t\t\t\t\"kernel subsystem misconfigured verifier\\n\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t\tregs[BPF_REG_0].map_ptr = meta.map_ptr;",
            "\t\tregs[BPF_REG_0].map_uid = meta.map_uid;",
            "\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE | ret_flag;",
            "\t\tif (!type_may_be_null(ret_type) &&",
            "\t\t    btf_record_has_field(meta.map_ptr->record, BPF_SPIN_LOCK)) {",
            "\t\t\tregs[BPF_REG_0].id = ++env->id_gen;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase RET_PTR_TO_SOCKET:",
            "\t\tmark_reg_known_zero(env, regs, BPF_REG_0);",
            "\t\tregs[BPF_REG_0].type = PTR_TO_SOCKET | ret_flag;",
            "\t\tbreak;",
            "\tcase RET_PTR_TO_SOCK_COMMON:",
            "\t\tmark_reg_known_zero(env, regs, BPF_REG_0);",
            "\t\tregs[BPF_REG_0].type = PTR_TO_SOCK_COMMON | ret_flag;",
            "\t\tbreak;",
            "\tcase RET_PTR_TO_TCP_SOCK:",
            "\t\tmark_reg_known_zero(env, regs, BPF_REG_0);",
            "\t\tregs[BPF_REG_0].type = PTR_TO_TCP_SOCK | ret_flag;",
            "\t\tbreak;",
            "\tcase RET_PTR_TO_MEM:",
            "\t\tmark_reg_known_zero(env, regs, BPF_REG_0);",
            "\t\tregs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;",
            "\t\tregs[BPF_REG_0].mem_size = meta.mem_size;",
            "\t\tbreak;",
            "\tcase RET_PTR_TO_MEM_OR_BTF_ID:",
            "\t{",
            "\t\tconst struct btf_type *t;",
            "",
            "\t\tmark_reg_known_zero(env, regs, BPF_REG_0);",
            "\t\tt = btf_type_skip_modifiers(meta.ret_btf, meta.ret_btf_id, NULL);",
            "\t\tif (!btf_type_is_struct(t)) {",
            "\t\t\tu32 tsize;",
            "\t\t\tconst struct btf_type *ret;",
            "\t\t\tconst char *tname;",
            "",
            "\t\t\t/* resolve the type size of ksym. */",
            "\t\t\tret = btf_resolve_size(meta.ret_btf, t, &tsize);",
            "\t\t\tif (IS_ERR(ret)) {",
            "\t\t\t\ttname = btf_name_by_offset(meta.ret_btf, t->name_off);",
            "\t\t\t\tverbose(env, \"unable to resolve the size of type '%s': %ld\\n\",",
            "\t\t\t\t\ttname, PTR_ERR(ret));",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "\t\t\tregs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;",
            "\t\t\tregs[BPF_REG_0].mem_size = tsize;",
            "\t\t} else {",
            "\t\t\tif (returns_cpu_specific_alloc_ptr) {",
            "\t\t\t\tregs[BPF_REG_0].type = PTR_TO_BTF_ID | MEM_ALLOC | MEM_RCU;",
            "\t\t\t} else {",
            "\t\t\t\t/* MEM_RDONLY may be carried from ret_flag, but it",
            "\t\t\t\t * doesn't apply on PTR_TO_BTF_ID. Fold it, otherwise",
            "\t\t\t\t * it will confuse the check of PTR_TO_BTF_ID in",
            "\t\t\t\t * check_mem_access().",
            "\t\t\t\t */",
            "\t\t\t\tret_flag &= ~MEM_RDONLY;",
            "\t\t\t\tregs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;",
            "\t\t\t}",
            "",
            "\t\t\tregs[BPF_REG_0].btf = meta.ret_btf;",
            "\t\t\tregs[BPF_REG_0].btf_id = meta.ret_btf_id;",
            "\t\t}",
            "\t\tbreak;",
            "\t}",
            "\tcase RET_PTR_TO_BTF_ID:",
            "\t{",
            "\t\tstruct btf *ret_btf;",
            "\t\tint ret_btf_id;",
            "",
            "\t\tmark_reg_known_zero(env, regs, BPF_REG_0);",
            "\t\tregs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;",
            "\t\tif (func_id == BPF_FUNC_kptr_xchg) {",
            "\t\t\tret_btf = meta.kptr_field->kptr.btf;",
            "\t\t\tret_btf_id = meta.kptr_field->kptr.btf_id;",
            "\t\t\tif (!btf_is_kernel(ret_btf)) {",
            "\t\t\t\tregs[BPF_REG_0].type |= MEM_ALLOC;",
            "\t\t\t\tif (meta.kptr_field->type == BPF_KPTR_PERCPU)",
            "\t\t\t\t\tregs[BPF_REG_0].type |= MEM_PERCPU;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tif (fn->ret_btf_id == BPF_PTR_POISON) {",
            "\t\t\t\tverbose(env, \"verifier internal error:\");",
            "\t\t\t\tverbose(env, \"func %s has non-overwritten BPF_PTR_POISON return type\\n\",",
            "\t\t\t\t\tfunc_id_name(func_id));",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "\t\t\tret_btf = btf_vmlinux;",
            "\t\t\tret_btf_id = *fn->ret_btf_id;",
            "\t\t}",
            "\t\tif (ret_btf_id == 0) {",
            "\t\t\tverbose(env, \"invalid return type %u of func %s#%d\\n\",",
            "\t\t\t\tbase_type(ret_type), func_id_name(func_id),",
            "\t\t\t\tfunc_id);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t\tregs[BPF_REG_0].btf = ret_btf;",
            "\t\tregs[BPF_REG_0].btf_id = ret_btf_id;",
            "\t\tbreak;",
            "\t}",
            "\tdefault:",
            "\t\tverbose(env, \"unknown return type %u of func %s#%d\\n\",",
            "\t\t\tbase_type(ret_type), func_id_name(func_id), func_id);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (type_may_be_null(regs[BPF_REG_0].type))",
            "\t\tregs[BPF_REG_0].id = ++env->id_gen;",
            "",
            "\tif (helper_multiple_ref_obj_use(func_id, meta.map_ptr)) {",
            "\t\tverbose(env, \"verifier internal error: func %s#%d sets ref_obj_id more than once\\n\",",
            "\t\t\tfunc_id_name(func_id), func_id);",
            "\t\treturn -EFAULT;",
            "\t}",
            "",
            "\tif (is_dynptr_ref_function(func_id))",
            "\t\tregs[BPF_REG_0].dynptr_id = meta.dynptr_id;",
            "",
            "\tif (is_ptr_cast_function(func_id) || is_dynptr_ref_function(func_id)) {",
            "\t\t/* For release_reference() */",
            "\t\tregs[BPF_REG_0].ref_obj_id = meta.ref_obj_id;",
            "\t} else if (is_acquire_function(func_id, meta.map_ptr)) {",
            "\t\tint id = acquire_reference(env, insn_idx);",
            "",
            "\t\tif (id < 0)",
            "\t\t\treturn id;",
            "\t\t/* For mark_ptr_or_null_reg() */",
            "\t\tregs[BPF_REG_0].id = id;",
            "\t\t/* For release_reference() */",
            "\t\tregs[BPF_REG_0].ref_obj_id = id;",
            "\t}",
            "",
            "\terr = do_refine_retval_range(env, regs, fn->ret_type, func_id, &meta);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\terr = check_map_func_compatibility(env, meta.map_ptr, func_id);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif ((func_id == BPF_FUNC_get_stack ||",
            "\t     func_id == BPF_FUNC_get_task_stack) &&",
            "\t    !env->prog->has_callchain_buf) {",
            "\t\tconst char *err_str;",
            "",
            "#ifdef CONFIG_PERF_EVENTS",
            "\t\terr = get_callchain_buffers(sysctl_perf_event_max_stack);",
            "\t\terr_str = \"cannot get callchain buffer for func %s#%d\\n\";",
            "#else",
            "\t\terr = -ENOTSUPP;",
            "\t\terr_str = \"func %s#%d not supported without CONFIG_PERF_EVENTS\\n\";",
            "#endif",
            "\t\tif (err) {",
            "\t\t\tverbose(env, err_str, func_id_name(func_id), func_id);",
            "\t\t\treturn err;",
            "\t\t}",
            "",
            "\t\tenv->prog->has_callchain_buf = true;",
            "\t}",
            "",
            "\tif (func_id == BPF_FUNC_get_stackid || func_id == BPF_FUNC_get_stack)",
            "\t\tenv->prog->call_get_stack = true;",
            "",
            "\tif (func_id == BPF_FUNC_get_func_ip) {",
            "\t\tif (check_get_func_ip(env))",
            "\t\t\treturn -ENOTSUPP;",
            "\t\tenv->prog->call_get_func_ip = true;",
            "\t}",
            "",
            "\tif (changes_data)",
            "\t\tclear_all_pkt_pointers(env);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_helper_proto, check_helper_call",
          "description": "代码段涉及BPF验证器中两个关键函数：  \n1. `get_helper_proto` 核心功能是通过函数ID查找对应的helper函数原型，确保其有效性并返回；若函数ID越界或未注册，则返回错误码。  \n2. `check_helper_call` 实现对BPF程序中helper函数调用的全面验证，包括：检查GPL兼容性、睡眠安全性、参数类型匹配、动态指针操作、内存访问限制等，并根据具体helper函数更新寄存器状态及类型信息，确保调用符合内核安全策略。",
          "similarity": 0.6722761392593384
        }
      ]
    },
    {
      "source_file": "kernel/bpf/btf.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:03:30\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\btf.c`\n\n---\n\n# `bpf/btf.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/btf.c` 是 Linux 内核中实现 **BPF Type Format (BTF)** 核心功能的源文件。BTF 是一种用于描述 BPF 程序和映射（map）中数据类型的元数据格式，本质上是对 C 语言类型系统的紧凑二进制编码。该文件负责 BTF 数据的解析、验证、内存管理、引用计数、ID 分配以及与 BPF 子系统（如验证器、结构体操作、kfunc 调用等）的集成。BTF 使得 BPF 程序能够进行类型安全检查、CO-RE（Compile Once – Run Everywhere）重定位，并支持高级调试和内省功能。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct btf`**  \n  BTF 对象的核心结构体，包含：\n  - 原始 BTF 数据 (`data`, `nohdr_data`)\n  - 解析后的类型指针数组 (`types`)\n  - 已解析类型的 ID 和大小缓存 (`resolved_ids`, `resolved_sizes`)\n  - 字符串表指针 (`strings`)\n  - BTF 头部信息 (`hdr`)\n  - 类型数量、数据大小等元信息\n  - 引用计数 (`refcnt`) 和 RCU 回收机制 (`rcu`)\n  - kfunc 集合表 (`kfunc_set_tab`)\n  - 析构函数表 (`dtor_kfunc_tab`)\n  - 结构体操作描述符表 (`struct_ops` 相关字段，代码截断)\n\n- **`struct btf_kfunc_set_tab`**  \n  管理不同 BPF 钩子上下文（如 XDP、TC、Tracing 等）下允许调用的内核函数（kfunc）集合。\n\n- **`struct btf_id_dtor_kfunc_tab`**  \n  存储与特定类型关联的析构函数（destructor kfunc），用于资源自动清理。\n\n- **`enum btf_kfunc_hook`**  \n  定义 BPF 程序可挂载的不同执行上下文类型，用于 kfunc 权限控制。\n\n- **`DEFINE_IDR(btf_idr)` 和 `btf_idr_lock`**  \n  全局 IDR（Integer ID Allocator）用于为每个加载的 BTF 对象分配唯一 ID，并配合自旋锁保证并发安全。\n\n### 关键宏定义\n\n- **BTF 验证与布局宏**  \n  - `BTF_MAX_SIZE`: BTF 数据最大允许大小（16MB）\n  - `BTF_TYPE_ID_VALID`, `BTF_STR_OFFSET_VALID`: 类型 ID 和字符串偏移合法性检查\n  - `BITS_ROUNDUP_BYTES` 等：位宽与字节转换工具\n\n- **遍历宏**  \n  - `for_each_member_from`: 遍历结构体/联合体成员\n  - `for_each_vsi_from`: 遍历变量段信息（Variable Section Info）\n\n## 3. 关键实现\n\n### BTF 验证两阶段模型\n\n- **第一阶段（收集与初步验证）**  \n  遍历原始 BTF 类型段，将每个 `struct btf_type` 及其附属数据（如数组、函数参数等）按 4 字节对齐解析，并存入 `btf->types[]` 数组。此阶段验证：\n  - 类型结构完整性\n  - 字符串偏移是否在合法范围内\n  - 基本类型属性合法性\n\n- **第二阶段（类型解析与循环检测）**  \n  对需要解析的类型（如结构体、指针、数组等）执行深度优先搜索（DFS）：\n  - 递归解析类型引用链\n  - 检测类型定义中的循环依赖（如结构体 A 包含结构体 B，B 又包含 A）\n  - 特殊处理指针类型：允许 `struct A { struct A *next; }` 这类合法递归\n  - 缓存已解析类型的大小和最终类型 ID，避免重复计算\n\n### BTF 对象生命周期管理\n\n- 使用 `refcount_t` 实现引用计数\n- 通过 RCU 机制安全释放内存，确保在 BPF 程序或映射仍在使用 BTF 时不会被提前销毁\n- 全局 `btf_idr` 提供 BTF 对象的全局唯一标识，支持通过 `bpf_btf_get_fd_by_id()` 等系统调用访问\n\n### kfunc 与析构函数集成\n\n- `btf_kfunc_set_tab` 为不同 BPF 钩子上下文维护允许调用的内核函数白名单\n- `dtor_kfunc_tab` 支持为特定类型注册析构函数，在 BPF map 元素删除时自动调用，实现资源管理\n- 通过 `btf_kfunc_hook_filter` 支持对 kfunc 调用进行额外过滤（如 LSM 策略）\n\n### CO-RE 与重定位支持\n\n- BTF 为 `libbpf` 的 CO-RE 重定位提供类型信息基础\n- 内核通过解析 BTF 中的类型结构，理解 BPF 程序期望访问的内核数据结构布局，从而在运行时进行字段偏移调整\n\n## 4. 依赖关系\n\n- **BPF 子系统**  \n  - `bpf_verifier.c`: BPF 验证器依赖 BTF 进行类型检查和内存安全分析\n  - `bpf_map.c`: BPF 映射使用 BTF 描述 key/value 类型\n  - `bpf_struct_ops.c`: 基于 BTF 定义内核结构体操作接口\n  - `bpf_lsm.c`: LSM 钩子使用 BTF 类型信息进行策略匹配\n\n- **网络子系统**  \n  - XDP、TC、Socket、Netfilter 等网络 BPF 钩子通过 BTF 注册和验证 kfunc\n\n- **用户空间接口**  \n  - 通过 `bpf(BPF_BTF_LOAD)` 系统调用加载 BTF\n  - `/sys/kernel/btf/` sysfs 接口暴露内核 BTF（vmlinux BTF）\n\n- **工具链依赖**  \n  - 依赖 `../tools/lib/bpf/relo_core.h` 中的 CO-RE 重定位定义\n\n- **内核通用机制**  \n  - IDR（ID 分配）、RCU（内存回收）、SLAB（内存分配）、Sysfs（调试接口）\n\n## 5. 使用场景\n\n- **BPF 程序加载**  \n  用户空间通过 `bpf(BPF_PROG_LOAD)` 加载程序时，可附带 BTF 信息，供验证器进行类型检查。\n\n- **BPF Map 类型描述**  \n  创建 BPF map 时指定 `btf_key_type_id` 和 `btf_value_type_id`，使内核理解 map 中存储的数据结构。\n\n- **内核函数调用（kfunc）**  \n  BPF 程序通过 `bpf_call` 调用内核函数时，BTF 用于验证函数签名、参数类型及调用上下文合法性。\n\n- **结构体操作（struct_ops）**  \n  定义 BPF 可实现的内核回调接口（如 TCP congestion control），BTF 描述接口结构体布局。\n\n- **CO-RE 程序运行**  \n  在不同内核版本上运行预编译的 BPF 程序时，内核 BTF（`vmlinux BTF`）与程序 BTF 对比，自动重定位字段访问。\n\n- **调试与内省**  \n  通过 `bpftool btf dump` 等工具查看 BTF 内容，辅助 BPF 程序开发和问题诊断。\n\n- **安全策略实施**  \n  LSM 模块利用 BTF 类型信息对 BPF 程序行为进行细粒度访问控制。",
      "similarity": 0.6940241456031799,
      "chunks": [
        {
          "chunk_id": 40,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 7408,
          "end_line": 7707,
          "content": [
            "int btf_check_type_match(struct bpf_verifier_log *log, const struct bpf_prog *prog,",
            "\t\t\t struct btf *btf2, const struct btf_type *t2)",
            "{",
            "\tstruct btf *btf1 = prog->aux->btf;",
            "\tconst struct btf_type *t1;",
            "\tu32 btf_id = 0;",
            "",
            "\tif (!prog->aux->func_info) {",
            "\t\tbpf_log(log, \"Program extension requires BTF\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tbtf_id = prog->aux->func_info[0].type_id;",
            "\tif (!btf_id)",
            "\t\treturn -EFAULT;",
            "",
            "\tt1 = btf_type_by_id(btf1, btf_id);",
            "\tif (!t1 || !btf_type_is_func(t1))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn btf_check_func_type_match(log, btf1, t1, btf2, t2);",
            "}",
            "static bool btf_is_dynptr_ptr(const struct btf *btf, const struct btf_type *t)",
            "{",
            "\tconst char *name;",
            "",
            "\tt = btf_type_by_id(btf, t->type); /* skip PTR */",
            "",
            "\twhile (btf_type_is_modifier(t))",
            "\t\tt = btf_type_by_id(btf, t->type);",
            "",
            "\t/* allow either struct or struct forward declaration */",
            "\tif (btf_type_is_struct(t) ||",
            "\t    (btf_type_is_fwd(t) && btf_type_kflag(t) == 0)) {",
            "\t\tname = btf_str_by_offset(btf, t->name_off);",
            "\t\treturn name && strcmp(name, \"bpf_dynptr\") == 0;",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "static int btf_get_ptr_to_btf_id(struct bpf_verifier_log *log, int arg_idx,",
            "\t\t\t\t const struct btf *btf, const struct btf_type *t)",
            "{",
            "\tstruct bpf_cand_cache *cc;",
            "\tstruct bpf_core_ctx ctx = {",
            "\t\t.btf = btf,",
            "\t\t.log = log,",
            "\t};",
            "\tu32 kern_type_id, type_id;",
            "\tint err = 0;",
            "",
            "\t/* skip PTR and modifiers */",
            "\ttype_id = t->type;",
            "\tt = btf_type_by_id(btf, t->type);",
            "\twhile (btf_type_is_modifier(t)) {",
            "\t\ttype_id = t->type;",
            "\t\tt = btf_type_by_id(btf, t->type);",
            "\t}",
            "",
            "\tmutex_lock(&cand_cache_mutex);",
            "\tcc = bpf_core_find_cands(&ctx, type_id);",
            "\tif (IS_ERR(cc)) {",
            "\t\terr = PTR_ERR(cc);",
            "\t\tbpf_log(log, \"arg#%d reference type('%s %s') candidate matching error: %d\\n\",",
            "\t\t\targ_idx, btf_type_str(t), __btf_name_by_offset(btf, t->name_off),",
            "\t\t\terr);",
            "\t\tgoto cand_cache_unlock;",
            "\t}",
            "\tif (cc->cnt != 1) {",
            "\t\tbpf_log(log, \"arg#%d reference type('%s %s') %s\\n\",",
            "\t\t\targ_idx, btf_type_str(t), __btf_name_by_offset(btf, t->name_off),",
            "\t\t\tcc->cnt == 0 ? \"has no matches\" : \"is ambiguous\");",
            "\t\terr = cc->cnt == 0 ? -ENOENT : -ESRCH;",
            "\t\tgoto cand_cache_unlock;",
            "\t}",
            "\tif (btf_is_module(cc->cands[0].btf)) {",
            "\t\tbpf_log(log, \"arg#%d reference type('%s %s') points to kernel module type (unsupported)\\n\",",
            "\t\t\targ_idx, btf_type_str(t), __btf_name_by_offset(btf, t->name_off));",
            "\t\terr = -EOPNOTSUPP;",
            "\t\tgoto cand_cache_unlock;",
            "\t}",
            "\tkern_type_id = cc->cands[0].id;",
            "",
            "cand_cache_unlock:",
            "\tmutex_unlock(&cand_cache_mutex);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\treturn kern_type_id;",
            "}",
            "int btf_prepare_func_args(struct bpf_verifier_env *env, int subprog)",
            "{",
            "\tbool is_global = subprog_aux(env, subprog)->linkage == BTF_FUNC_GLOBAL;",
            "\tstruct bpf_subprog_info *sub = subprog_info(env, subprog);",
            "\tstruct bpf_verifier_log *log = &env->log;",
            "\tstruct bpf_prog *prog = env->prog;",
            "\tenum bpf_prog_type prog_type = prog->type;",
            "\tstruct btf *btf = prog->aux->btf;",
            "\tconst struct btf_param *args;",
            "\tconst struct btf_type *t, *ref_t, *fn_t;",
            "\tu32 i, nargs, btf_id;",
            "\tconst char *tname;",
            "",
            "\tif (sub->args_cached)",
            "\t\treturn 0;",
            "",
            "\tif (!prog->aux->func_info) {",
            "\t\tbpf_log(log, \"Verifier bug\\n\");",
            "\t\treturn -EFAULT;",
            "\t}",
            "",
            "\tbtf_id = prog->aux->func_info[subprog].type_id;",
            "\tif (!btf_id) {",
            "\t\tif (!is_global) /* not fatal for static funcs */",
            "\t\t\treturn -EINVAL;",
            "\t\tbpf_log(log, \"Global functions need valid BTF\\n\");",
            "\t\treturn -EFAULT;",
            "\t}",
            "",
            "\tfn_t = btf_type_by_id(btf, btf_id);",
            "\tif (!fn_t || !btf_type_is_func(fn_t)) {",
            "\t\t/* These checks were already done by the verifier while loading",
            "\t\t * struct bpf_func_info",
            "\t\t */",
            "\t\tbpf_log(log, \"BTF of func#%d doesn't point to KIND_FUNC\\n\",",
            "\t\t\tsubprog);",
            "\t\treturn -EFAULT;",
            "\t}",
            "\ttname = btf_name_by_offset(btf, fn_t->name_off);",
            "",
            "\tif (prog->aux->func_info_aux[subprog].unreliable) {",
            "\t\tbpf_log(log, \"Verifier bug in function %s()\\n\", tname);",
            "\t\treturn -EFAULT;",
            "\t}",
            "\tif (prog_type == BPF_PROG_TYPE_EXT)",
            "\t\tprog_type = prog->aux->dst_prog->type;",
            "",
            "\tt = btf_type_by_id(btf, fn_t->type);",
            "\tif (!t || !btf_type_is_func_proto(t)) {",
            "\t\tbpf_log(log, \"Invalid type of function %s()\\n\", tname);",
            "\t\treturn -EFAULT;",
            "\t}",
            "\targs = (const struct btf_param *)(t + 1);",
            "\tnargs = btf_type_vlen(t);",
            "\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {",
            "\t\tif (!is_global)",
            "\t\t\treturn -EINVAL;",
            "\t\tbpf_log(log, \"Global function %s() with %d > %d args. Buggy compiler.\\n\",",
            "\t\t\ttname, nargs, MAX_BPF_FUNC_REG_ARGS);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\t/* check that function returns int, exception cb also requires this */",
            "\tt = btf_type_by_id(btf, t->type);",
            "\twhile (btf_type_is_modifier(t))",
            "\t\tt = btf_type_by_id(btf, t->type);",
            "\tif (!btf_type_is_int(t) && !btf_is_any_enum(t)) {",
            "\t\tif (!is_global)",
            "\t\t\treturn -EINVAL;",
            "\t\tbpf_log(log,",
            "\t\t\t\"Global function %s() doesn't return scalar. Only those are supported.\\n\",",
            "\t\t\ttname);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\t/* Convert BTF function arguments into verifier types.",
            "\t * Only PTR_TO_CTX and SCALAR are supported atm.",
            "\t */",
            "\tfor (i = 0; i < nargs; i++) {",
            "\t\tu32 tags = 0;",
            "\t\tint id = 0;",
            "",
            "\t\t/* 'arg:<tag>' decl_tag takes precedence over derivation of",
            "\t\t * register type from BTF type itself",
            "\t\t */",
            "\t\twhile ((id = btf_find_next_decl_tag(btf, fn_t, i, \"arg:\", id)) > 0) {",
            "\t\t\tconst struct btf_type *tag_t = btf_type_by_id(btf, id);",
            "\t\t\tconst char *tag = __btf_name_by_offset(btf, tag_t->name_off) + 4;",
            "",
            "\t\t\t/* disallow arg tags in static subprogs */",
            "\t\t\tif (!is_global) {",
            "\t\t\t\tbpf_log(log, \"arg#%d type tag is not supported in static functions\\n\", i);",
            "\t\t\t\treturn -EOPNOTSUPP;",
            "\t\t\t}",
            "",
            "\t\t\tif (strcmp(tag, \"ctx\") == 0) {",
            "\t\t\t\ttags |= ARG_TAG_CTX;",
            "\t\t\t} else if (strcmp(tag, \"trusted\") == 0) {",
            "\t\t\t\ttags |= ARG_TAG_TRUSTED;",
            "\t\t\t} else if (strcmp(tag, \"nonnull\") == 0) {",
            "\t\t\t\ttags |= ARG_TAG_NONNULL;",
            "\t\t\t} else if (strcmp(tag, \"nullable\") == 0) {",
            "\t\t\t\ttags |= ARG_TAG_NULLABLE;",
            "\t\t\t} else if (strcmp(tag, \"arena\") == 0) {",
            "\t\t\t\ttags |= ARG_TAG_ARENA;",
            "\t\t\t} else {",
            "\t\t\t\tbpf_log(log, \"arg#%d has unsupported set of tags\\n\", i);",
            "\t\t\t\treturn -EOPNOTSUPP;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (id != -ENOENT) {",
            "\t\t\tbpf_log(log, \"arg#%d type tag fetching failure: %d\\n\", i, id);",
            "\t\t\treturn id;",
            "\t\t}",
            "",
            "\t\tt = btf_type_by_id(btf, args[i].type);",
            "\t\twhile (btf_type_is_modifier(t))",
            "\t\t\tt = btf_type_by_id(btf, t->type);",
            "\t\tif (!btf_type_is_ptr(t))",
            "\t\t\tgoto skip_pointer;",
            "",
            "\t\tif ((tags & ARG_TAG_CTX) || btf_is_prog_ctx_type(log, btf, t, prog_type, i)) {",
            "\t\t\tif (tags & ~ARG_TAG_CTX) {",
            "\t\t\t\tbpf_log(log, \"arg#%d has invalid combination of tags\\n\", i);",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "\t\t\tif ((tags & ARG_TAG_CTX) &&",
            "\t\t\t    btf_validate_prog_ctx_type(log, btf, t, i, prog_type,",
            "\t\t\t\t\t\t       prog->expected_attach_type))",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\tsub->args[i].arg_type = ARG_PTR_TO_CTX;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (btf_is_dynptr_ptr(btf, t)) {",
            "\t\t\tif (tags) {",
            "\t\t\t\tbpf_log(log, \"arg#%d has invalid combination of tags\\n\", i);",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "\t\t\tsub->args[i].arg_type = ARG_PTR_TO_DYNPTR | MEM_RDONLY;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (tags & ARG_TAG_TRUSTED) {",
            "\t\t\tint kern_type_id;",
            "",
            "\t\t\tif (tags & ARG_TAG_NONNULL) {",
            "\t\t\t\tbpf_log(log, \"arg#%d has invalid combination of tags\\n\", i);",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "",
            "\t\t\tkern_type_id = btf_get_ptr_to_btf_id(log, i, btf, t);",
            "\t\t\tif (kern_type_id < 0)",
            "\t\t\t\treturn kern_type_id;",
            "",
            "\t\t\tsub->args[i].arg_type = ARG_PTR_TO_BTF_ID | PTR_TRUSTED;",
            "\t\t\tif (tags & ARG_TAG_NULLABLE)",
            "\t\t\t\tsub->args[i].arg_type |= PTR_MAYBE_NULL;",
            "\t\t\tsub->args[i].btf_id = kern_type_id;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (tags & ARG_TAG_ARENA) {",
            "\t\t\tif (tags & ~ARG_TAG_ARENA) {",
            "\t\t\t\tbpf_log(log, \"arg#%d arena cannot be combined with any other tags\\n\", i);",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "\t\t\tsub->args[i].arg_type = ARG_PTR_TO_ARENA;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (is_global) { /* generic user data pointer */",
            "\t\t\tu32 mem_size;",
            "",
            "\t\t\tif (tags & ARG_TAG_NULLABLE) {",
            "\t\t\t\tbpf_log(log, \"arg#%d has invalid combination of tags\\n\", i);",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "",
            "\t\t\tt = btf_type_skip_modifiers(btf, t->type, NULL);",
            "\t\t\tref_t = btf_resolve_size(btf, t, &mem_size);",
            "\t\t\tif (IS_ERR(ref_t)) {",
            "\t\t\t\tbpf_log(log, \"arg#%d reference type('%s %s') size cannot be determined: %ld\\n\",",
            "\t\t\t\t\ti, btf_type_str(t), btf_name_by_offset(btf, t->name_off),",
            "\t\t\t\t\tPTR_ERR(ref_t));",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "",
            "\t\t\tsub->args[i].arg_type = ARG_PTR_TO_MEM | PTR_MAYBE_NULL;",
            "\t\t\tif (tags & ARG_TAG_NONNULL)",
            "\t\t\t\tsub->args[i].arg_type &= ~PTR_MAYBE_NULL;",
            "\t\t\tsub->args[i].mem_size = mem_size;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "skip_pointer:",
            "\t\tif (tags) {",
            "\t\t\tbpf_log(log, \"arg#%d has pointer tag, but is not a pointer type\\n\", i);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t\tif (btf_type_is_int(t) || btf_is_any_enum(t)) {",
            "\t\t\tsub->args[i].arg_type = ARG_ANYTHING;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (!is_global)",
            "\t\t\treturn -EINVAL;",
            "\t\tbpf_log(log, \"Arg#%d type %s in %s() is not supported yet.\\n\",",
            "\t\t\ti, btf_type_str(t), tname);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tsub->arg_cnt = nargs;",
            "\tsub->args_cached = true;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "btf_check_type_match, btf_is_dynptr_ptr, btf_get_ptr_to_btf_id, btf_prepare_func_args",
          "description": "该代码块实现了BPF程序验证过程中对函数参数类型的匹配检查，包括动态指针类型识别、指向BTF类型的解析及参数标签处理，核心功能是将BTF类型转换为verifier可识别的arg_type标识",
          "similarity": 0.6844112873077393
        },
        {
          "chunk_id": 35,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 6539,
          "end_line": 6786,
          "content": [
            "bool btf_ctx_access(int off, int size, enum bpf_access_type type,",
            "\t\t    const struct bpf_prog *prog,",
            "\t\t    struct bpf_insn_access_aux *info)",
            "{",
            "\tconst struct btf_type *t = prog->aux->attach_func_proto;",
            "\tstruct bpf_prog *tgt_prog = prog->aux->dst_prog;",
            "\tstruct btf *btf = bpf_prog_get_target_btf(prog);",
            "\tconst char *tname = prog->aux->attach_func_name;",
            "\tstruct bpf_verifier_log *log = info->log;",
            "\tconst struct btf_param *args;",
            "\tbool ptr_err_raw_tp = false;",
            "\tconst char *tag_value;",
            "\tu32 nr_args, arg;",
            "\tint i, ret;",
            "",
            "\tif (off % 8) {",
            "\t\tbpf_log(log, \"func '%s' offset %d is not multiple of 8\\n\",",
            "\t\t\ttname, off);",
            "\t\treturn false;",
            "\t}",
            "\targ = btf_ctx_arg_idx(btf, t, off);",
            "\targs = (const struct btf_param *)(t + 1);",
            "\t/* if (t == NULL) Fall back to default BPF prog with",
            "\t * MAX_BPF_FUNC_REG_ARGS u64 arguments.",
            "\t */",
            "\tnr_args = t ? btf_type_vlen(t) : MAX_BPF_FUNC_REG_ARGS;",
            "\tif (prog->aux->attach_btf_trace) {",
            "\t\t/* skip first 'void *__data' argument in btf_trace_##name typedef */",
            "\t\targs++;",
            "\t\tnr_args--;",
            "\t}",
            "",
            "\tif (arg > nr_args) {",
            "\t\tbpf_log(log, \"func '%s' doesn't have %d-th argument\\n\",",
            "\t\t\ttname, arg + 1);",
            "\t\treturn false;",
            "\t}",
            "",
            "\tif (arg == nr_args) {",
            "\t\tswitch (prog->expected_attach_type) {",
            "\t\tcase BPF_LSM_MAC:",
            "\t\t\t/* mark we are accessing the return value */",
            "\t\t\tinfo->is_retval = true;",
            "\t\t\tfallthrough;",
            "\t\tcase BPF_LSM_CGROUP:",
            "\t\tcase BPF_TRACE_FEXIT:",
            "\t\t\t/* When LSM programs are attached to void LSM hooks",
            "\t\t\t * they use FEXIT trampolines and when attached to",
            "\t\t\t * int LSM hooks, they use MODIFY_RETURN trampolines.",
            "\t\t\t *",
            "\t\t\t * While the LSM programs are BPF_MODIFY_RETURN-like",
            "\t\t\t * the check:",
            "\t\t\t *",
            "\t\t\t *\tif (ret_type != 'int')",
            "\t\t\t *\t\treturn -EINVAL;",
            "\t\t\t *",
            "\t\t\t * is _not_ done here. This is still safe as LSM hooks",
            "\t\t\t * have only void and int return types.",
            "\t\t\t */",
            "\t\t\tif (!t)",
            "\t\t\t\treturn true;",
            "\t\t\tt = btf_type_by_id(btf, t->type);",
            "\t\t\tbreak;",
            "\t\tcase BPF_MODIFY_RETURN:",
            "\t\t\t/* For now the BPF_MODIFY_RETURN can only be attached to",
            "\t\t\t * functions that return an int.",
            "\t\t\t */",
            "\t\t\tif (!t)",
            "\t\t\t\treturn false;",
            "",
            "\t\t\tt = btf_type_skip_modifiers(btf, t->type, NULL);",
            "\t\t\tif (!btf_type_is_small_int(t)) {",
            "\t\t\t\tbpf_log(log,",
            "\t\t\t\t\t\"ret type %s not allowed for fmod_ret\\n\",",
            "\t\t\t\t\tbtf_type_str(t));",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbpf_log(log, \"func '%s' doesn't have %d-th argument\\n\",",
            "\t\t\t\ttname, arg + 1);",
            "\t\t\treturn false;",
            "\t\t}",
            "\t} else {",
            "\t\tif (!t)",
            "\t\t\t/* Default prog with MAX_BPF_FUNC_REG_ARGS args */",
            "\t\t\treturn true;",
            "\t\tt = btf_type_by_id(btf, args[arg].type);",
            "\t}",
            "",
            "\t/* skip modifiers */",
            "\twhile (btf_type_is_modifier(t))",
            "\t\tt = btf_type_by_id(btf, t->type);",
            "\tif (btf_type_is_small_int(t) || btf_is_any_enum(t) || __btf_type_is_struct(t))",
            "\t\t/* accessing a scalar */",
            "\t\treturn true;",
            "\tif (!btf_type_is_ptr(t)) {",
            "\t\tbpf_log(log,",
            "\t\t\t\"func '%s' arg%d '%s' has type %s. Only pointer access is allowed\\n\",",
            "\t\t\ttname, arg,",
            "\t\t\t__btf_name_by_offset(btf, t->name_off),",
            "\t\t\tbtf_type_str(t));",
            "\t\treturn false;",
            "\t}",
            "",
            "\tif (size != sizeof(u64)) {",
            "\t\tbpf_log(log, \"func '%s' size %d must be 8\\n\",",
            "\t\t\ttname, size);",
            "\t\treturn false;",
            "\t}",
            "",
            "\t/* check for PTR_TO_RDONLY_BUF_OR_NULL or PTR_TO_RDWR_BUF_OR_NULL */",
            "\tfor (i = 0; i < prog->aux->ctx_arg_info_size; i++) {",
            "\t\tconst struct bpf_ctx_arg_aux *ctx_arg_info = &prog->aux->ctx_arg_info[i];",
            "\t\tu32 type, flag;",
            "",
            "\t\ttype = base_type(ctx_arg_info->reg_type);",
            "\t\tflag = type_flag(ctx_arg_info->reg_type);",
            "\t\tif (ctx_arg_info->offset == off && type == PTR_TO_BUF &&",
            "\t\t    (flag & PTR_MAYBE_NULL)) {",
            "\t\t\tinfo->reg_type = ctx_arg_info->reg_type;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\tif (t->type == 0)",
            "\t\t/* This is a pointer to void.",
            "\t\t * It is the same as scalar from the verifier safety pov.",
            "\t\t * No further pointer walking is allowed.",
            "\t\t */",
            "\t\treturn true;",
            "",
            "\tif (is_int_ptr(btf, t))",
            "\t\treturn true;",
            "",
            "\t/* this is a pointer to another type */",
            "\tfor (i = 0; i < prog->aux->ctx_arg_info_size; i++) {",
            "\t\tconst struct bpf_ctx_arg_aux *ctx_arg_info = &prog->aux->ctx_arg_info[i];",
            "",
            "\t\tif (ctx_arg_info->offset == off) {",
            "\t\t\tif (!ctx_arg_info->btf_id) {",
            "\t\t\t\tbpf_log(log,\"invalid btf_id for context argument offset %u\\n\", off);",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "",
            "\t\t\tinfo->reg_type = ctx_arg_info->reg_type;",
            "\t\t\tinfo->btf = ctx_arg_info->btf ? : btf_vmlinux;",
            "\t\t\tinfo->btf_id = ctx_arg_info->btf_id;",
            "\t\t\tinfo->ref_obj_id = ctx_arg_info->ref_obj_id;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\tinfo->reg_type = PTR_TO_BTF_ID;",
            "\tif (prog_args_trusted(prog))",
            "\t\tinfo->reg_type |= PTR_TRUSTED;",
            "",
            "\tif (btf_param_match_suffix(btf, &args[arg], \"__nullable\"))",
            "\t\tinfo->reg_type |= PTR_MAYBE_NULL;",
            "",
            "\tif (prog->expected_attach_type == BPF_TRACE_RAW_TP) {",
            "\t\tstruct btf *btf = prog->aux->attach_btf;",
            "\t\tconst struct btf_type *t;",
            "\t\tconst char *tname;",
            "",
            "\t\t/* BTF lookups cannot fail, return false on error */",
            "\t\tt = btf_type_by_id(btf, prog->aux->attach_btf_id);",
            "\t\tif (!t)",
            "\t\t\treturn false;",
            "\t\ttname = btf_name_by_offset(btf, t->name_off);",
            "\t\tif (!tname)",
            "\t\t\treturn false;",
            "\t\t/* Checked by bpf_check_attach_target */",
            "\t\ttname += sizeof(\"btf_trace_\") - 1;",
            "\t\tfor (i = 0; i < ARRAY_SIZE(raw_tp_null_args); i++) {",
            "\t\t\t/* Is this a func with potential NULL args? */",
            "\t\t\tif (strcmp(tname, raw_tp_null_args[i].func))",
            "\t\t\t\tcontinue;",
            "\t\t\tif (raw_tp_null_args[i].mask & (0x1 << (arg * 4)))",
            "\t\t\t\tinfo->reg_type |= PTR_MAYBE_NULL;",
            "\t\t\t/* Is the current arg IS_ERR? */",
            "\t\t\tif (raw_tp_null_args[i].mask & (0x2 << (arg * 4)))",
            "\t\t\t\tptr_err_raw_tp = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\t/* If we don't know NULL-ness specification and the tracepoint",
            "\t\t * is coming from a loadable module, be conservative and mark",
            "\t\t * argument as PTR_MAYBE_NULL.",
            "\t\t */",
            "\t\tif (i == ARRAY_SIZE(raw_tp_null_args) && btf_is_module(btf))",
            "\t\t\tinfo->reg_type |= PTR_MAYBE_NULL;",
            "\t}",
            "",
            "\tif (tgt_prog) {",
            "\t\tenum bpf_prog_type tgt_type;",
            "",
            "\t\tif (tgt_prog->type == BPF_PROG_TYPE_EXT)",
            "\t\t\ttgt_type = tgt_prog->aux->saved_dst_prog_type;",
            "\t\telse",
            "\t\t\ttgt_type = tgt_prog->type;",
            "",
            "\t\tret = btf_translate_to_vmlinux(log, btf, t, tgt_type, arg);",
            "\t\tif (ret > 0) {",
            "\t\t\tinfo->btf = btf_vmlinux;",
            "\t\t\tinfo->btf_id = ret;",
            "\t\t\treturn true;",
            "\t\t} else {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t}",
            "",
            "\tinfo->btf = btf;",
            "\tinfo->btf_id = t->type;",
            "\tt = btf_type_by_id(btf, t->type);",
            "",
            "\tif (btf_type_is_type_tag(t)) {",
            "\t\ttag_value = __btf_name_by_offset(btf, t->name_off);",
            "\t\tif (strcmp(tag_value, \"user\") == 0)",
            "\t\t\tinfo->reg_type |= MEM_USER;",
            "\t\tif (strcmp(tag_value, \"percpu\") == 0)",
            "\t\t\tinfo->reg_type |= MEM_PERCPU;",
            "\t}",
            "",
            "\t/* skip modifiers */",
            "\twhile (btf_type_is_modifier(t)) {",
            "\t\tinfo->btf_id = t->type;",
            "\t\tt = btf_type_by_id(btf, t->type);",
            "\t}",
            "\tif (!btf_type_is_struct(t)) {",
            "\t\tbpf_log(log,",
            "\t\t\t\"func '%s' arg%d type %s is not a struct\\n\",",
            "\t\t\ttname, arg, btf_type_str(t));",
            "\t\treturn false;",
            "\t}",
            "\tbpf_log(log, \"func '%s' arg%d has btf_id %d type %s '%s'\\n\",",
            "\t\ttname, arg, info->btf_id, btf_type_str(t),",
            "\t\t__btf_name_by_offset(btf, t->name_off));",
            "",
            "\t/* Perform all checks on the validity of type for this argument, but if",
            "\t * we know it can be IS_ERR at runtime, scrub pointer type and mark as",
            "\t * scalar.",
            "\t */",
            "\tif (ptr_err_raw_tp) {",
            "\t\tbpf_log(log, \"marking pointer arg%d as scalar as it may encode error\", arg);",
            "\t\tinfo->reg_type = SCALAR_VALUE;",
            "\t}",
            "\treturn true;",
            "}"
          ],
          "function_name": "btf_ctx_access",
          "description": "函数btf_ctx_access用于验证BPF程序对上下文指针的访问合法性，检查偏移量是否对齐、参数是否存在、类型是否为指针，并根据目标函数签名确定寄存器类型和BTF标识符。",
          "similarity": 0.6720278263092041
        },
        {
          "chunk_id": 33,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 6004,
          "end_line": 6136,
          "content": [
            "static int btf_validate_prog_ctx_type(struct bpf_verifier_log *log, const struct btf *btf,",
            "\t\t\t\t      const struct btf_type *t, int arg,",
            "\t\t\t\t      enum bpf_prog_type prog_type,",
            "\t\t\t\t      enum bpf_attach_type attach_type)",
            "{",
            "\tconst struct btf_type *ctx_type;",
            "\tconst char *tname, *ctx_tname;",
            "",
            "\tif (!btf_is_ptr(t)) {",
            "\t\tbpf_log(log, \"arg#%d type isn't a pointer\\n\", arg);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\tt = btf_type_by_id(btf, t->type);",
            "",
            "\t/* KPROBE and PERF_EVENT programs allow bpf_user_pt_regs_t typedef */",
            "\tif (prog_type == BPF_PROG_TYPE_KPROBE || prog_type == BPF_PROG_TYPE_PERF_EVENT) {",
            "\t\twhile (btf_type_is_modifier(t) && !btf_type_is_typedef(t))",
            "\t\t\tt = btf_type_by_id(btf, t->type);",
            "",
            "\t\tif (btf_type_is_typedef(t)) {",
            "\t\t\ttname = btf_name_by_offset(btf, t->name_off);",
            "\t\t\tif (tname && strcmp(tname, \"bpf_user_pt_regs_t\") == 0)",
            "\t\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            "\t/* all other program types don't use typedefs for context type */",
            "\twhile (btf_type_is_modifier(t))",
            "\t\tt = btf_type_by_id(btf, t->type);",
            "",
            "\t/* `void *ctx __arg_ctx` is always valid */",
            "\tif (btf_type_is_void(t))",
            "\t\treturn 0;",
            "",
            "\ttname = btf_name_by_offset(btf, t->name_off);",
            "\tif (str_is_empty(tname)) {",
            "\t\tbpf_log(log, \"arg#%d type doesn't have a name\\n\", arg);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* special cases */",
            "\tswitch (prog_type) {",
            "\tcase BPF_PROG_TYPE_KPROBE:",
            "\t\tif (__btf_type_is_struct(t) && strcmp(tname, \"pt_regs\") == 0)",
            "\t\t\treturn 0;",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_PERF_EVENT:",
            "\t\tif (__builtin_types_compatible_p(bpf_user_pt_regs_t, struct pt_regs) &&",
            "\t\t    __btf_type_is_struct(t) && strcmp(tname, \"pt_regs\") == 0)",
            "\t\t\treturn 0;",
            "\t\tif (__builtin_types_compatible_p(bpf_user_pt_regs_t, struct user_pt_regs) &&",
            "\t\t    __btf_type_is_struct(t) && strcmp(tname, \"user_pt_regs\") == 0)",
            "\t\t\treturn 0;",
            "\t\tif (__builtin_types_compatible_p(bpf_user_pt_regs_t, struct user_regs_struct) &&",
            "\t\t    __btf_type_is_struct(t) && strcmp(tname, \"user_regs_struct\") == 0)",
            "\t\t\treturn 0;",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:",
            "\tcase BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE:",
            "\t\t/* allow u64* as ctx */",
            "\t\tif (btf_is_int(t) && t->size == 8)",
            "\t\t\treturn 0;",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_TRACING:",
            "\t\tswitch (attach_type) {",
            "\t\tcase BPF_TRACE_RAW_TP:",
            "\t\t\t/* tp_btf program is TRACING, so need special case here */",
            "\t\t\tif (__btf_type_is_struct(t) &&",
            "\t\t\t    strcmp(tname, \"bpf_raw_tracepoint_args\") == 0)",
            "\t\t\t\treturn 0;",
            "\t\t\t/* allow u64* as ctx */",
            "\t\t\tif (btf_is_int(t) && t->size == 8)",
            "\t\t\t\treturn 0;",
            "\t\t\tbreak;",
            "\t\tcase BPF_TRACE_ITER:",
            "\t\t\t/* allow struct bpf_iter__xxx types only */",
            "\t\t\tif (__btf_type_is_struct(t) &&",
            "\t\t\t    strncmp(tname, \"bpf_iter__\", sizeof(\"bpf_iter__\") - 1) == 0)",
            "\t\t\t\treturn 0;",
            "\t\t\tbreak;",
            "\t\tcase BPF_TRACE_FENTRY:",
            "\t\tcase BPF_TRACE_FEXIT:",
            "\t\tcase BPF_MODIFY_RETURN:",
            "\t\t\t/* allow u64* as ctx */",
            "\t\t\tif (btf_is_int(t) && t->size == 8)",
            "\t\t\t\treturn 0;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_LSM:",
            "\tcase BPF_PROG_TYPE_STRUCT_OPS:",
            "\t\t/* allow u64* as ctx */",
            "\t\tif (btf_is_int(t) && t->size == 8)",
            "\t\t\treturn 0;",
            "\t\tbreak;",
            "\tcase BPF_PROG_TYPE_TRACEPOINT:",
            "\tcase BPF_PROG_TYPE_SYSCALL:",
            "\tcase BPF_PROG_TYPE_EXT:",
            "\t\treturn 0; /* anything goes */",
            "\tdefault:",
            "\t\tbreak;",
            "\t}",
            "",
            "\tctx_type = find_canonical_prog_ctx_type(prog_type);",
            "\tif (!ctx_type) {",
            "\t\t/* should not happen */",
            "\t\tbpf_log(log, \"btf_vmlinux is malformed\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* resolve typedefs and check that underlying structs are matching as well */",
            "\twhile (btf_type_is_modifier(ctx_type))",
            "\t\tctx_type = btf_type_by_id(btf_vmlinux, ctx_type->type);",
            "",
            "\t/* if program type doesn't have distinctly named struct type for",
            "\t * context, then __arg_ctx argument can only be `void *`, which we",
            "\t * already checked above",
            "\t */",
            "\tif (!__btf_type_is_struct(ctx_type)) {",
            "\t\tbpf_log(log, \"arg#%d should be void pointer\\n\", arg);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tctx_tname = btf_name_by_offset(btf_vmlinux, ctx_type->name_off);",
            "\tif (!__btf_type_is_struct(t) || strcmp(ctx_tname, tname) != 0) {",
            "\t\tbpf_log(log, \"arg#%d should be `struct %s *`\\n\", arg, ctx_tname);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "btf_validate_prog_ctx_type",
          "description": "验证BPF程序上下文类型有效性，针对不同程序类型处理特殊指针类型兼容性检查，确保类型与内核期望的上下文结构匹配。",
          "similarity": 0.6650973558425903
        },
        {
          "chunk_id": 24,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 4396,
          "end_line": 4514,
          "content": [
            "static s32 btf_enum64_check_meta(struct btf_verifier_env *env,",
            "\t\t\t\t const struct btf_type *t,",
            "\t\t\t\t u32 meta_left)",
            "{",
            "\tconst struct btf_enum64 *enums = btf_type_enum64(t);",
            "\tstruct btf *btf = env->btf;",
            "\tconst char *fmt_str;",
            "\tu16 i, nr_enums;",
            "\tu32 meta_needed;",
            "",
            "\tnr_enums = btf_type_vlen(t);",
            "\tmeta_needed = nr_enums * sizeof(*enums);",
            "",
            "\tif (meta_left < meta_needed) {",
            "\t\tbtf_verifier_log_basic(env, t,",
            "\t\t\t\t       \"meta_left:%u meta_needed:%u\",",
            "\t\t\t\t       meta_left, meta_needed);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (t->size > 8 || !is_power_of_2(t->size)) {",
            "\t\tbtf_verifier_log_type(env, t, \"Unexpected size\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* enum type either no name or a valid one */",
            "\tif (t->name_off &&",
            "\t    !btf_name_valid_identifier(env->btf, t->name_off)) {",
            "\t\tbtf_verifier_log_type(env, t, \"Invalid name\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tbtf_verifier_log_type(env, t, NULL);",
            "",
            "\tfor (i = 0; i < nr_enums; i++) {",
            "\t\tif (!btf_name_offset_valid(btf, enums[i].name_off)) {",
            "\t\t\tbtf_verifier_log(env, \"\\tInvalid name_offset:%u\",",
            "\t\t\t\t\t enums[i].name_off);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\t/* enum member must have a valid name */",
            "\t\tif (!enums[i].name_off ||",
            "\t\t    !btf_name_valid_identifier(btf, enums[i].name_off)) {",
            "\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (env->log.level == BPF_LOG_KERNEL)",
            "\t\t\tcontinue;",
            "",
            "\t\tfmt_str = btf_type_kflag(t) ? \"\\t%s val=%lld\\n\" : \"\\t%s val=%llu\\n\";",
            "\t\tbtf_verifier_log(env, fmt_str,",
            "\t\t\t\t __btf_name_by_offset(btf, enums[i].name_off),",
            "\t\t\t\t btf_enum64_value(enums + i));",
            "\t}",
            "",
            "\treturn meta_needed;",
            "}",
            "static void btf_enum64_show(const struct btf *btf, const struct btf_type *t,",
            "\t\t\t    u32 type_id, void *data, u8 bits_offset,",
            "\t\t\t    struct btf_show *show)",
            "{",
            "\tconst struct btf_enum64 *enums = btf_type_enum64(t);",
            "\tu32 i, nr_enums = btf_type_vlen(t);",
            "\tvoid *safe_data;",
            "\ts64 v;",
            "",
            "\tsafe_data = btf_show_start_type(show, t, type_id, data);",
            "\tif (!safe_data)",
            "\t\treturn;",
            "",
            "\tv = *(u64 *)safe_data;",
            "",
            "\tfor (i = 0; i < nr_enums; i++) {",
            "\t\tif (v != btf_enum64_value(enums + i))",
            "\t\t\tcontinue;",
            "",
            "\t\tbtf_show_type_value(show, \"%s\",",
            "\t\t\t\t    __btf_name_by_offset(btf,",
            "\t\t\t\t\t\t\t enums[i].name_off));",
            "",
            "\t\tbtf_show_end_type(show);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (btf_type_kflag(t))",
            "\t\tbtf_show_type_value(show, \"%lld\", v);",
            "\telse",
            "\t\tbtf_show_type_value(show, \"%llu\", v);",
            "\tbtf_show_end_type(show);",
            "}",
            "static s32 btf_func_proto_check_meta(struct btf_verifier_env *env,",
            "\t\t\t\t     const struct btf_type *t,",
            "\t\t\t\t     u32 meta_left)",
            "{",
            "\tu32 meta_needed = btf_type_vlen(t) * sizeof(struct btf_param);",
            "",
            "\tif (meta_left < meta_needed) {",
            "\t\tbtf_verifier_log_basic(env, t,",
            "\t\t\t\t       \"meta_left:%u meta_needed:%u\",",
            "\t\t\t\t       meta_left, meta_needed);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (t->name_off) {",
            "\t\tbtf_verifier_log_type(env, t, \"Invalid name\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (btf_type_kflag(t)) {",
            "\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tbtf_verifier_log_type(env, t, NULL);",
            "",
            "\treturn meta_needed;",
            "}"
          ],
          "function_name": "btf_enum64_check_meta, btf_enum64_show, btf_func_proto_check_meta",
          "description": "该代码段实现了BTF（Binary Toolchain Format）中对枚举类型和函数原型的元数据校验与展示功能。  \n`btf_enum64_check_meta` 校验枚举类型元数据完整性，确保大小合法且名称有效；`btf_enum64_show` 将枚举值映射到对应的符号名以供调试展示；`btf_func_proto_check_meta` 验证函数原型参数元数据的有效性。  \n所有函数均通过日志记录异常并返回错误码，核心目标是保障BPF程序在加载时的类型安全性。",
          "similarity": 0.6390421390533447
        },
        {
          "chunk_id": 23,
          "file_path": "kernel/bpf/btf.c",
          "start_line": 4253,
          "end_line": 4382,
          "content": [
            "static int btf_enum_check_kflag_member(struct btf_verifier_env *env,",
            "\t\t\t\t       const struct btf_type *struct_type,",
            "\t\t\t\t       const struct btf_member *member,",
            "\t\t\t\t       const struct btf_type *member_type)",
            "{",
            "\tu32 struct_bits_off, nr_bits, bytes_end, struct_size;",
            "\tu32 int_bitsize = sizeof(int) * BITS_PER_BYTE;",
            "",
            "\tstruct_bits_off = BTF_MEMBER_BIT_OFFSET(member->offset);",
            "\tnr_bits = BTF_MEMBER_BITFIELD_SIZE(member->offset);",
            "\tif (!nr_bits) {",
            "\t\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {",
            "\t\t\tbtf_verifier_log_member(env, struct_type, member,",
            "\t\t\t\t\t\t\"Member is not byte aligned\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tnr_bits = int_bitsize;",
            "\t} else if (nr_bits > int_bitsize) {",
            "\t\tbtf_verifier_log_member(env, struct_type, member,",
            "\t\t\t\t\t\"Invalid member bitfield_size\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tstruct_size = struct_type->size;",
            "\tbytes_end = BITS_ROUNDUP_BYTES(struct_bits_off + nr_bits);",
            "\tif (struct_size < bytes_end) {",
            "\t\tbtf_verifier_log_member(env, struct_type, member,",
            "\t\t\t\t\t\"Member exceeds struct_size\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static s32 btf_enum_check_meta(struct btf_verifier_env *env,",
            "\t\t\t       const struct btf_type *t,",
            "\t\t\t       u32 meta_left)",
            "{",
            "\tconst struct btf_enum *enums = btf_type_enum(t);",
            "\tstruct btf *btf = env->btf;",
            "\tconst char *fmt_str;",
            "\tu16 i, nr_enums;",
            "\tu32 meta_needed;",
            "",
            "\tnr_enums = btf_type_vlen(t);",
            "\tmeta_needed = nr_enums * sizeof(*enums);",
            "",
            "\tif (meta_left < meta_needed) {",
            "\t\tbtf_verifier_log_basic(env, t,",
            "\t\t\t\t       \"meta_left:%u meta_needed:%u\",",
            "\t\t\t\t       meta_left, meta_needed);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (t->size > 8 || !is_power_of_2(t->size)) {",
            "\t\tbtf_verifier_log_type(env, t, \"Unexpected size\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* enum type either no name or a valid one */",
            "\tif (t->name_off &&",
            "\t    !btf_name_valid_identifier(env->btf, t->name_off)) {",
            "\t\tbtf_verifier_log_type(env, t, \"Invalid name\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tbtf_verifier_log_type(env, t, NULL);",
            "",
            "\tfor (i = 0; i < nr_enums; i++) {",
            "\t\tif (!btf_name_offset_valid(btf, enums[i].name_off)) {",
            "\t\t\tbtf_verifier_log(env, \"\\tInvalid name_offset:%u\",",
            "\t\t\t\t\t enums[i].name_off);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\t/* enum member must have a valid name */",
            "\t\tif (!enums[i].name_off ||",
            "\t\t    !btf_name_valid_identifier(btf, enums[i].name_off)) {",
            "\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tif (env->log.level == BPF_LOG_KERNEL)",
            "\t\t\tcontinue;",
            "\t\tfmt_str = btf_type_kflag(t) ? \"\\t%s val=%d\\n\" : \"\\t%s val=%u\\n\";",
            "\t\tbtf_verifier_log(env, fmt_str,",
            "\t\t\t\t __btf_name_by_offset(btf, enums[i].name_off),",
            "\t\t\t\t enums[i].val);",
            "\t}",
            "",
            "\treturn meta_needed;",
            "}",
            "static void btf_enum_log(struct btf_verifier_env *env,",
            "\t\t\t const struct btf_type *t)",
            "{",
            "\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));",
            "}",
            "static void btf_enum_show(const struct btf *btf, const struct btf_type *t,",
            "\t\t\t  u32 type_id, void *data, u8 bits_offset,",
            "\t\t\t  struct btf_show *show)",
            "{",
            "\tconst struct btf_enum *enums = btf_type_enum(t);",
            "\tu32 i, nr_enums = btf_type_vlen(t);",
            "\tvoid *safe_data;",
            "\tint v;",
            "",
            "\tsafe_data = btf_show_start_type(show, t, type_id, data);",
            "\tif (!safe_data)",
            "\t\treturn;",
            "",
            "\tv = *(int *)safe_data;",
            "",
            "\tfor (i = 0; i < nr_enums; i++) {",
            "\t\tif (v != enums[i].val)",
            "\t\t\tcontinue;",
            "",
            "\t\tbtf_show_type_value(show, \"%s\",",
            "\t\t\t\t    __btf_name_by_offset(btf,",
            "\t\t\t\t\t\t\t enums[i].name_off));",
            "",
            "\t\tbtf_show_end_type(show);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (btf_type_kflag(t))",
            "\t\tbtf_show_type_value(show, \"%d\", v);",
            "\telse",
            "\t\tbtf_show_type_value(show, \"%u\", v);",
            "\tbtf_show_end_type(show);",
            "}"
          ],
          "function_name": "btf_enum_check_kflag_member, btf_enum_check_meta, btf_enum_log, btf_enum_show",
          "description": "该代码段实现了BPF（Berkeley Packet Filter）中对枚举类型（enum）的验证与展示逻辑。  \n`btf_enum_check_kflag_member` 检查枚举成员的位域对齐及大小合法性，确保其符合BPF运行时约束；`btf_enum_check_meta` 验证枚举元数据完整性，包括名称有效性及类型尺寸合规性；其余两个函数用于日志记录和格式化输出枚举值对应名称。  \n上下文完整，无编造API。",
          "similarity": 0.6388760805130005
        }
      ]
    }
  ]
}