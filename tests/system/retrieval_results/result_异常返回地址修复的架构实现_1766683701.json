{
  "query": "异常返回地址修复的架构实现",
  "timestamp": "2025-12-26 01:28:21",
  "retrieved_files": [
    {
      "source_file": "kernel/trace/rethook.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:06:37\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\rethook.c`\n\n---\n\n# `trace/rethook.c` 技术文档\n\n## 1. 文件概述\n\n`rethook.c` 实现了 Linux 内核中的 **rethook（Return Hook）** 机制，这是一种通用的函数返回拦截框架，用于在函数返回时执行回调处理。该机制为 kretprobes、ftrace 等动态追踪工具提供底层支持，允许在函数返回点安全地插入处理逻辑，同时管理返回地址的重写与恢复。rethook 使用 per-task 的无锁链表（LLIST）作为“影子栈”来跟踪活跃的 hook 节点，并结合 RCU 和引用计数实现内存安全的生命周期管理。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct rethook`：rethook 实例，包含回调函数指针、私有数据、节点池（freelist）和引用计数。\n- `struct rethook_node`：单个 hook 节点，嵌入在用户数据结构中，包含返回地址、帧指针、所属 rethook 指针及链表/空闲链表节点。\n\n### 主要函数\n| 函数 | 功能描述 |\n|------|--------|\n| `rethook_alloc()` | 分配并初始化一个新的 `rethook` 实例 |\n| `rethook_free()` / `rethook_stop()` | 停止并异步释放 `rethook` 实例 |\n| `rethook_add_node()` | 向 rethook 添加预分配的节点 |\n| `rethook_try_get()` | 从 rethook 的空闲池中获取一个未使用的节点（需禁用抢占） |\n| `rethook_hook()` | 在函数入口处注册返回 hook，将节点加入当前任务的 rethook 链表 |\n| `rethook_recycle()` | 回收 hook 节点：若 rethook 有效则归还到空闲池，否则异步释放 |\n| `rethook_find_ret_addr()` | 在指定任务的 rethook 链表中查找与给定帧指针对应的真实返回地址 |\n| `rethook_flush_task()` | 在任务退出时清理其所有未返回的 rethook 节点 |\n\n## 3. 关键实现\n\n### 影子栈与任务绑定\n- 每个 `task_struct` 包含一个 `rethooks` 字段（`struct llist_head`），用于存储该任务当前活跃的所有 `rethook_node`。\n- 使用无锁链表（LLIST）实现高效、并发安全的插入（`__llist_add`）和批量删除（`__llist_del_all`）。\n\n### 内存与生命周期管理\n- **引用计数**：`rethook` 的 `ref` 字段初始为 1，每添加一个节点加 1；节点回收时减 1。当引用归零且节点池清空后，`rethook` 本体被释放。\n- **RCU 安全**：通过 `rcu_assign_pointer()` 和 `rcu_dereference_check()` 管理 `handler` 指针的读写，确保在 RCU 读侧临界区内安全访问。\n- **延迟释放**：`rethook_free()` 和无效节点的回收均通过 `call_rcu()` 异步执行，避免在中断或原子上下文中释放内存。\n\n### 上下文感知的 Hook 注入\n- `rethook_hook()` 接收 `mcount` 参数区分调用上下文（ftrace vs kprobe），由架构相关代码（`arch_rethook_prepare()`）决定如何修改返回地址（例如插入 trampoline）。\n- 要求调用者处于 RCU 可用上下文（`rcu_is_watching()`），确保后续的 RCU 回调能正确执行。\n\n### 返回地址恢复\n- `rethook_find_ret_addr()` 遍历任务的 rethook 链表，跳过 trampoline 地址，返回与指定栈帧匹配的真实返回地址，用于栈回溯修正。\n\n## 4. 依赖关系\n\n- **架构依赖**：依赖 `arch_rethook_prepare()` 和 `arch_rethook_trampoline`（由各架构实现），用于实际修改返回地址和提供 trampoline 函数。\n- **内核子系统**：\n  - `<linux/rcu.h>`：RCU 同步机制\n  - `<linux/slab.h>`：动态内存分配\n  - `<linux/preempt.h>`：抢占控制\n  - `<linux/kprobes.h>`：与 kretprobes 集成\n  - `<linux/freelist.h>`：无锁空闲链表实现\n- **任务管理**：依赖 `task_struct::rethooks` 字段和 `delayed_put_task_struct()` 回调。\n\n## 5. 使用场景\n\n- **kretprobes 实现**：作为 kretprobe 的底层机制，拦截函数返回并执行用户定义的处理函数。\n- **ftrace 动态追踪**：在 function graph tracer 等场景中，用于捕获函数返回事件。\n- **内核栈回溯修正**：当函数返回地址被 trampoline 覆盖时，通过 `rethook_find_ret_addr()` 恢复原始调用栈。\n- **安全监控与性能分析**：第三方模块可基于 rethook 框架实现函数级的返回行为监控或统计。",
      "similarity": 0.6422936916351318,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/rethook.c",
          "start_line": 267,
          "end_line": 334,
          "content": [
            "void __weak arch_rethook_fixup_return(struct pt_regs *regs,",
            "\t\t\t\t      unsigned long correct_ret_addr)",
            "{",
            "\t/*",
            "\t * Do nothing by default. If the architecture which uses a",
            "\t * frame pointer to record real return address on the stack,",
            "\t * it should fill this function to fixup the return address",
            "\t * so that stacktrace works from the rethook handler.",
            "\t */",
            "}",
            "unsigned long rethook_trampoline_handler(struct pt_regs *regs,",
            "\t\t\t\t\t unsigned long frame)",
            "{",
            "\tstruct llist_node *first, *node = NULL;",
            "\tunsigned long correct_ret_addr;",
            "\trethook_handler_t handler;",
            "\tstruct rethook_node *rhn;",
            "",
            "\tcorrect_ret_addr = __rethook_find_ret_addr(current, &node);",
            "\tif (!correct_ret_addr) {",
            "\t\tpr_err(\"rethook: Return address not found! Maybe there is a bug in the kernel\\n\");",
            "\t\tBUG_ON(1);",
            "\t}",
            "",
            "\tinstruction_pointer_set(regs, correct_ret_addr);",
            "",
            "\t/*",
            "\t * These loops must be protected from rethook_free_rcu() because those",
            "\t * are accessing 'rhn->rethook'.",
            "\t */",
            "\tpreempt_disable_notrace();",
            "",
            "\t/*",
            "\t * Run the handler on the shadow stack. Do not unlink the list here because",
            "\t * stackdump inside the handlers needs to decode it.",
            "\t */",
            "\tfirst = current->rethooks.first;",
            "\twhile (first) {",
            "\t\trhn = container_of(first, struct rethook_node, llist);",
            "\t\tif (WARN_ON_ONCE(rhn->frame != frame))",
            "\t\t\tbreak;",
            "\t\thandler = rethook_get_handler(rhn->rethook);",
            "\t\tif (handler)",
            "\t\t\thandler(rhn, rhn->rethook->data,",
            "\t\t\t\tcorrect_ret_addr, regs);",
            "",
            "\t\tif (first == node)",
            "\t\t\tbreak;",
            "\t\tfirst = first->next;",
            "\t}",
            "",
            "\t/* Fixup registers for returning to correct address. */",
            "\tarch_rethook_fixup_return(regs, correct_ret_addr);",
            "",
            "\t/* Unlink used shadow stack */",
            "\tfirst = current->rethooks.first;",
            "\tcurrent->rethooks.first = node->next;",
            "\tnode->next = NULL;",
            "",
            "\twhile (first) {",
            "\t\trhn = container_of(first, struct rethook_node, llist);",
            "\t\tfirst = first->next;",
            "\t\trethook_recycle(rhn);",
            "\t}",
            "\tpreempt_enable_notrace();",
            "",
            "\treturn correct_ret_addr;",
            "}"
          ],
          "function_name": "arch_rethook_fixup_return, rethook_trampoline_handler",
          "description": "提供架构无关的返回地址修复接口与trampoline处理函数，协调影子堆栈遍历、处理程序执行及寄存器状态恢复流程",
          "similarity": 0.7556743621826172
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/rethook.c",
          "start_line": 22,
          "end_line": 131,
          "content": [
            "void rethook_flush_task(struct task_struct *tk)",
            "{",
            "\tstruct rethook_node *rhn;",
            "\tstruct llist_node *node;",
            "",
            "\tnode = __llist_del_all(&tk->rethooks);",
            "\twhile (node) {",
            "\t\trhn = container_of(node, struct rethook_node, llist);",
            "\t\tnode = node->next;",
            "\t\tpreempt_disable();",
            "\t\trethook_recycle(rhn);",
            "\t\tpreempt_enable();",
            "\t}",
            "}",
            "static void rethook_free_rcu(struct rcu_head *head)",
            "{",
            "\tstruct rethook *rh = container_of(head, struct rethook, rcu);",
            "\tobjpool_fini(&rh->pool);",
            "}",
            "void rethook_stop(struct rethook *rh)",
            "{",
            "\trcu_assign_pointer(rh->handler, NULL);",
            "}",
            "void rethook_free(struct rethook *rh)",
            "{",
            "\trethook_stop(rh);",
            "",
            "\tcall_rcu(&rh->rcu, rethook_free_rcu);",
            "}",
            "static int rethook_init_node(void *nod, void *context)",
            "{",
            "\tstruct rethook_node *node = nod;",
            "",
            "\tnode->rethook = context;",
            "\treturn 0;",
            "}",
            "static int rethook_fini_pool(struct objpool_head *head, void *context)",
            "{",
            "\tkfree(context);",
            "\treturn 0;",
            "}",
            "static inline rethook_handler_t rethook_get_handler(struct rethook *rh)",
            "{",
            "\treturn (rethook_handler_t)rcu_dereference_check(rh->handler,",
            "\t\t\t\t\t\t\trcu_read_lock_any_held());",
            "}",
            "static void free_rethook_node_rcu(struct rcu_head *head)",
            "{",
            "\tstruct rethook_node *node = container_of(head, struct rethook_node, rcu);",
            "\tstruct rethook *rh = node->rethook;",
            "",
            "\tobjpool_drop(node, &rh->pool);",
            "}",
            "void rethook_recycle(struct rethook_node *node)",
            "{",
            "\trethook_handler_t handler;",
            "",
            "\thandler = rethook_get_handler(node->rethook);",
            "\tif (likely(handler))",
            "\t\tobjpool_push(node, &node->rethook->pool);",
            "\telse",
            "\t\tcall_rcu(&node->rcu, free_rethook_node_rcu);",
            "}",
            "void rethook_hook(struct rethook_node *node, struct pt_regs *regs, bool mcount)",
            "{",
            "\tarch_rethook_prepare(node, regs, mcount);",
            "\t__llist_add(&node->llist, &current->rethooks);",
            "}",
            "static unsigned long __rethook_find_ret_addr(struct task_struct *tsk,",
            "\t\t\t\t\t     struct llist_node **cur)",
            "{",
            "\tstruct rethook_node *rh = NULL;",
            "\tstruct llist_node *node = *cur;",
            "",
            "\tif (!node)",
            "\t\tnode = tsk->rethooks.first;",
            "\telse",
            "\t\tnode = node->next;",
            "",
            "\twhile (node) {",
            "\t\trh = container_of(node, struct rethook_node, llist);",
            "\t\tif (rh->ret_addr != (unsigned long)arch_rethook_trampoline) {",
            "\t\t\t*cur = node;",
            "\t\t\treturn rh->ret_addr;",
            "\t\t}",
            "\t\tnode = node->next;",
            "\t}",
            "\treturn 0;",
            "}",
            "unsigned long rethook_find_ret_addr(struct task_struct *tsk, unsigned long frame,",
            "\t\t\t\t    struct llist_node **cur)",
            "{",
            "\tstruct rethook_node *rhn = NULL;",
            "\tunsigned long ret;",
            "",
            "\tif (WARN_ON_ONCE(!cur))",
            "\t\treturn 0;",
            "",
            "\tif (WARN_ON_ONCE(tsk != current && task_is_running(tsk)))",
            "\t\treturn 0;",
            "",
            "\tdo {",
            "\t\tret = __rethook_find_ret_addr(tsk, cur);",
            "\t\tif (!ret)",
            "\t\t\tbreak;",
            "\t\trhn = container_of(*cur, struct rethook_node, llist);",
            "\t} while (rhn->frame != frame);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "rethook_flush_task, rethook_free_rcu, rethook_stop, rethook_free, rethook_init_node, rethook_fini_pool, rethook_get_handler, free_rethook_node_rcu, rethook_recycle, rethook_hook, __rethook_find_ret_addr, rethook_find_ret_addr",
          "description": "实现rethook节点的生命周期管理，包含RCU安全释放、池化内存管理、影子堆栈操作及异常返回地址查找逻辑",
          "similarity": 0.6012983322143555
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/rethook.c",
          "start_line": 1,
          "end_line": 21,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "#define pr_fmt(fmt) \"rethook: \" fmt",
            "",
            "#include <linux/bug.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/preempt.h>",
            "#include <linux/rethook.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "",
            "/* Return hook list (shadow stack by list) */",
            "",
            "/*",
            " * This function is called from delayed_put_task_struct() when a task is",
            " * dead and cleaned up to recycle any kretprobe instances associated with",
            " * this task. These left over instances represent probed functions that",
            " * have been called but will never return.",
            " */"
          ],
          "function_name": null,
          "description": "定义rethook模块的基础结构及函数声明，用于在任务终止时回收关联的kretprobe实例，防止僵尸探针残留",
          "similarity": 0.5651736259460449
        }
      ]
    },
    {
      "source_file": "kernel/extable.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:28:12\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `extable.c`\n\n---\n\n# extable.c 技术文档\n\n## 文件概述\n\n`extable.c` 是 Linux 内核中用于管理**异常表（exception table）**的核心实现文件。异常表记录了内核中可能触发页错误（如访问用户空间地址失败）的指令地址及其对应的异常处理程序地址。该文件提供了对内核内置异常表、模块异常表和 BPF 异常表的统一搜索接口，并负责在内核初始化阶段对内置异常表进行排序，以支持高效的二分查找。此外，该文件还包含用于判断地址是否位于内核可执行文本段（text section）的辅助函数，以及在支持函数描述符（function descriptors）的架构上对函数指针进行解引用的逻辑。\n\n## 核心功能\n\n### 主要数据结构\n- `struct exception_table_entry`：异常表项，包含故障指令地址和对应的修复处理程序地址（定义在 `<linux/extable.h>` 中）。\n- `text_mutex`：互斥锁，用于保护对内核文本段的动态修改（如热补丁、ftrace、kprobes 等）。\n\n### 主要函数\n- `sort_main_extable(void)`：在内核初始化阶段对内置异常表 `__ex_table` 进行排序。\n- `search_kernel_exception_table(unsigned long addr)`：在内核内置异常表中搜索指定地址对应的异常处理项。\n- `search_exception_tables(unsigned long addr)`：统一接口，在内核、模块和 BPF 的异常表中搜索指定地址。\n- `core_kernel_text(unsigned long addr)`：判断地址是否属于内核核心文本段（包括 init 段，在初始化内存释放前）。\n- `kernel_text_address(unsigned long addr)`：判断地址是否属于任何内核可执行文本（包括模块、kprobes、BPF、ftrace 等）。\n- `__kernel_text_address(unsigned long addr)`：扩展版的 `kernel_text_address`，特别包含 init 段符号以支持栈回溯。\n- `dereference_function_descriptor(void *ptr)`（仅 `CONFIG_HAVE_FUNCTION_DESCRIPTORS`）：解引用函数描述符，获取真实函数地址。\n- `dereference_kernel_function_descriptor(void *ptr)`（仅 `CONFIG_HAVE_FUNCTION_DESCRIPTORS`）：仅对内核 OPD 段中的函数描述符进行解引用。\n- `func_ptr_is_kernel_text(void *ptr)`：判断函数指针（可能为描述符）是否指向内核文本。\n\n## 关键实现\n\n### 异常表管理\n- 内核链接脚本将所有 `.ex_table` 段合并为 `__start___ex_table` 到 `__stop___ex_table` 的连续区域。\n- 构建工具（如 `sortextable`）可能已在编译时对异常表排序；若未排序，则 `main_extable_sort_needed` 为 1，内核在 `sort_main_extable()` 中调用 `sort_extable()` 进行运行时排序。\n- `search_extable()`（定义在别处）依赖表已排序，使用二分查找实现 O(log n) 查询效率。\n\n### 文本段地址判断\n- `kernel_text_address()` 是核心判断函数，依次检查：\n  1. 内核核心文本（`core_kernel_text()`）\n  2. 模块文本（`is_module_text_address()`）\n  3. ftrace 跳板（`is_ftrace_trampoline()`）\n  4. kprobes 指令槽（`is_kprobe_*_slot()`）\n  5. BPF 文本（`is_bpf_text_address()`）\n- 由于部分检查（如模块地址）依赖 RCU 机制，在 RCU 不活跃上下文（如 NMI、idle 退出）中，函数会临时通过 `ct_nmi_enter/exit()` 通知 RCU 子系统。\n\n### 函数描述符支持\n- 在 PowerPC64、IA-64、PARISC 等架构上，函数指针实际指向描述符（OPD），其中包含真实入口地址。\n- `dereference_function_descriptor()` 使用 `get_kernel_nofault()` 安全读取描述符中的地址，避免因无效指针导致崩溃。\n- `func_ptr_is_kernel_text()` 先解引用描述符，再判断真实地址是否在内核文本中。\n\n### 并发控制\n- `text_mutex` 保护所有对内核 `.text` 段的运行时修改操作（如 ftrace、kprobes、alternatives），防止并发写入导致不一致。\n- 该锁**不导出给内核模块**，强调内核文本修改的高风险性。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/extable.h>`：异常表数据结构和操作函数声明\n  - `<linux/module.h>`：模块异常表搜索（`search_module_extables`）\n  - `<linux/filter.h>`：BPF 异常表搜索（`search_bpf_extables`）\n  - `<linux/kprobes.h>`：kprobes 指令槽判断\n  - `<linux/ftrace.h>`：ftrace 跳板判断\n  - `<asm/sections.h>`：内核段边界符号（`__start___ex_table` 等）\n  - `<linux/uaccess.h>`：`get_kernel_nofault()` 安全内存访问\n- **架构依赖**：\n  - `CONFIG_HAVE_FUNCTION_DESCRIPTORS`：启用函数描述符解引用逻辑\n  - 架构特定的 `is_*_text_address()` 实现（如 x86 的 `is_module_text_address`）\n- **内核子系统**：\n  - 内存管理（页错误处理）\n  - 模块加载（模块异常表注册）\n  - BPF JIT（BPF 异常表）\n  - 动态追踪（ftrace、kprobes）\n\n## 使用场景\n\n1. **页错误处理**：当内核执行 `copy_from_user()` 等函数访问无效用户地址时，CPU 触发页错误，`do_page_fault()` 调用 `search_exception_tables()` 查找修复地址，跳转执行错误处理逻辑（如返回 `-EFAULT`）。\n2. **内核调试与追踪**：\n   - 栈回溯（stack unwinding）时通过 `__kernel_text_address()` 过滤有效内核符号\n   - 锁依赖检测（lockdep）等子系统依赖准确的文本段地址判断\n3. **动态代码修改**：\n   - ftrace、kprobes、livepatch 等机制在修改内核代码前需获取 `text_mutex`\n   - SMP alternatives（x86）使用同一互斥锁保证多核一致性\n4. **架构兼容性**：\n   - 在使用函数描述符的架构上，`kallsyms`、`perf` 等工具通过 `dereference_kernel_function_descriptor()` 获取真实函数地址\n   - 函数指针比较或验证时调用 `func_ptr_is_kernel_text()` 确保安全性",
      "similarity": 0.628709614276886,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/extable.c",
          "start_line": 36,
          "end_line": 117,
          "content": [
            "void __init sort_main_extable(void)",
            "{",
            "\tif (main_extable_sort_needed &&",
            "\t    &__stop___ex_table > &__start___ex_table) {",
            "\t\tpr_notice(\"Sorting __ex_table...\\n\");",
            "\t\tsort_extable(__start___ex_table, __stop___ex_table);",
            "\t}",
            "}",
            "int notrace core_kernel_text(unsigned long addr)",
            "{",
            "\tif (is_kernel_text(addr))",
            "\t\treturn 1;",
            "",
            "\tif (system_state < SYSTEM_FREEING_INITMEM &&",
            "\t    is_kernel_inittext(addr))",
            "\t\treturn 1;",
            "\treturn 0;",
            "}",
            "int __kernel_text_address(unsigned long addr)",
            "{",
            "\tif (kernel_text_address(addr))",
            "\t\treturn 1;",
            "\t/*",
            "\t * There might be init symbols in saved stacktraces.",
            "\t * Give those symbols a chance to be printed in",
            "\t * backtraces (such as lockdep traces).",
            "\t *",
            "\t * Since we are after the module-symbols check, there's",
            "\t * no danger of address overlap:",
            "\t */",
            "\tif (is_kernel_inittext(addr))",
            "\t\treturn 1;",
            "\treturn 0;",
            "}",
            "int kernel_text_address(unsigned long addr)",
            "{",
            "\tbool no_rcu;",
            "\tint ret = 1;",
            "",
            "\tif (core_kernel_text(addr))",
            "\t\treturn 1;",
            "",
            "\t/*",
            "\t * If a stack dump happens while RCU is not watching, then",
            "\t * RCU needs to be notified that it requires to start",
            "\t * watching again. This can happen either by tracing that",
            "\t * triggers a stack trace, or a WARN() that happens during",
            "\t * coming back from idle, or cpu on or offlining.",
            "\t *",
            "\t * is_module_text_address() as well as the kprobe slots,",
            "\t * is_bpf_text_address() and is_bpf_image_address require",
            "\t * RCU to be watching.",
            "\t */",
            "\tno_rcu = !rcu_is_watching();",
            "",
            "\t/* Treat this like an NMI as it can happen anywhere */",
            "\tif (no_rcu)",
            "\t\tct_nmi_enter();",
            "",
            "\tif (is_module_text_address(addr))",
            "\t\tgoto out;",
            "\tif (is_ftrace_trampoline(addr))",
            "\t\tgoto out;",
            "\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))",
            "\t\tgoto out;",
            "\tif (is_bpf_text_address(addr))",
            "\t\tgoto out;",
            "\tret = 0;",
            "out:",
            "\tif (no_rcu)",
            "\t\tct_nmi_exit();",
            "",
            "\treturn ret;",
            "}",
            "int func_ptr_is_kernel_text(void *ptr)",
            "{",
            "\tunsigned long addr;",
            "\taddr = (unsigned long) dereference_function_descriptor(ptr);",
            "\tif (core_kernel_text(addr))",
            "\t\treturn 1;",
            "\treturn is_module_text_address(addr);",
            "}"
          ],
          "function_name": "sort_main_extable, core_kernel_text, __kernel_text_address, kernel_text_address, func_ptr_is_kernel_text",
          "description": "实现异常表排序函数sort_main_extable及地址有效性检测函数，其中core_kernel_text判断地址是否为核心或初始化文本，kernel_text_address综合判断地址是否属于内核文本、模块文本或BPF文本并处理RCU状态，func_ptr_is_kernel_text检查函数指针指向的地址是否为内核文本",
          "similarity": 0.5940107107162476
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/extable.c",
          "start_line": 1,
          "end_line": 35,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/* Rewritten by Rusty Russell, on the backs of many others...",
            "   Copyright (C) 2001 Rusty Russell, 2002 Rusty Russell IBM.",
            "",
            "*/",
            "#include <linux/elf.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/extable.h>",
            "#include <linux/module.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/filter.h>",
            "",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "",
            "/*",
            " * mutex protecting text section modification (dynamic code patching).",
            " * some users need to sleep (allocating memory...) while they hold this lock.",
            " *",
            " * Note: Also protects SMP-alternatives modification on x86.",
            " *",
            " * NOT exported to modules - patching kernel text is a really delicate matter.",
            " */",
            "DEFINE_MUTEX(text_mutex);",
            "",
            "extern struct exception_table_entry __start___ex_table[];",
            "extern struct exception_table_entry __stop___ex_table[];",
            "",
            "/* Cleared by build time tools if the table is already sorted. */",
            "u32 __initdata __visible main_extable_sort_needed = 1;",
            "",
            "/* Sort the kernel's built-in exception table */"
          ],
          "function_name": null,
          "description": "定义保护动态代码修补的互斥锁text_mutex，声明异常表的起始/终止地址符号__start___ex_table/__stop___ex_table，并设置主异常表排序标志位main_extable_sort_needed，用于后续排序操作",
          "similarity": 0.5608264207839966
        }
      ]
    },
    {
      "source_file": "kernel/cfi.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:40:01\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cfi.c`\n\n---\n\n# cfi.c 技术文档\n\n## 文件概述\n\n`cfi.c` 是 Linux 内核中用于处理 **Clang Control Flow Integrity（CFI，控制流完整性）** 安全机制失败事件的核心错误处理模块。该文件定义了 CFI 验证失败时的报告逻辑，并在启用特定架构支持时提供对 CFI 陷阱（trap）地址的识别功能，用于区分合法的 CFI 中断点与真正的控制流劫持攻击。该机制由 Google 在 2022 年引入，旨在增强内核对面向返回编程（ROP）等控制流攻击的防御能力。\n\n## 核心功能\n\n### 主要函数\n\n- `report_cfi_failure(struct pt_regs *regs, unsigned long addr, unsigned long *target, u32 type)`  \n  报告 CFI 验证失败事件，根据配置决定是仅发出警告（`WARN`）还是触发内核错误（`BUG`）。\n\n- `module_cfi_finalize(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs, struct module *mod)`（仅当 `CONFIG_MODULES` 启用）  \n  在模块加载过程中解析并记录模块中 `__kcfi_traps` 节区的位置，用于后续 CFI 陷阱地址的识别。\n\n- `is_cfi_trap(unsigned long addr)`（仅当 `CONFIG_ARCH_USES_CFI_TRAPS` 启用）  \n  判断给定地址是否为合法的 CFI 陷阱地址（即编译器插入的用于 CFI 检查的跳转目标）。\n\n- `is_module_cfi_trap(unsigned long addr)`（内部辅助函数）  \n  检查地址是否属于某个已加载内核模块中的 CFI 陷阱。\n\n- `is_trap(unsigned long addr, s32 *start, s32 *end)`（静态内联辅助函数）  \n  在指定地址范围内查找是否存在指向 `addr` 的 CFI 陷阱条目。\n\n- `trap_address(s32 *p)`（静态内联辅助函数）  \n  根据相对偏移计算 CFI 陷阱的实际目标地址。\n\n### 关键数据结构与符号\n\n- `__start___kcfi_traps[]` / `__stop___kcfi_traps[]`  \n  链接器生成的符号，标记内核镜像中 `__kcfi_traps` 节区的起始和结束位置，该节区由 Clang 编译器在启用 CFI 时生成，包含所有合法间接调用目标的地址偏移。\n\n- `struct module` 中的 `kcfi_traps` 和 `kcfi_traps_end` 字段  \n  用于存储每个内核模块中 `__kcfi_traps` 节区的地址范围。\n\n## 关键实现\n\n### CFI 失败报告机制\n\n- `report_cfi_failure()` 函数首先通过 `pr_err()` 打印详细的 CFI 失败信息，包括发生位置、目标地址（若有）和期望的类型标识。\n- 若内核配置了 `CONFIG_CFI_PERMISSIVE`（宽容模式），则调用 `__warn()` 仅记录警告并返回 `BUG_TRAP_TYPE_WARN`，允许系统继续运行（用于调试或兼容性场景）。\n- 否则返回 `BUG_TRAP_TYPE_BUG`，触发内核 panic，防止潜在的控制流劫持被利用。\n\n### CFI 陷阱地址识别\n\n- Clang 在启用 CFI（如 `-fsanitize=cfi`）时，会为每个间接调用目标生成一个唯一的类型哈希，并在 `__kcfi_traps` 节区中存储相对地址偏移（以 `s32` 类型表示）。\n- `trap_address(p)` 通过 `p + *p` 计算出实际的目标函数地址（PC-relative 寻址）。\n- `is_trap()` 遍历 `__kcfi_traps` 节区中的所有条目，检查是否有条目指向传入的 `addr`。\n- `is_cfi_trap()` 同时检查内核镜像和所有已加载模块的 `__kcfi_traps` 节区，确保对模块代码的 CFI 保护同样有效。\n- 模块支持通过 `module_cfi_finalize()` 在模块加载时解析 ELF 节区，提取 `__kcfi_traps` 的运行时地址。\n\n### 并发安全\n\n- 在检查模块地址时，使用 `rcu_read_lock_sched_notrace()` 保护对模块链表的遍历，避免在中断上下文或调度器跟踪中引入额外开销。\n\n## 依赖关系\n\n- **头文件依赖**：  \n  - `<linux/cfi.h>`：定义 `report_cfi_failure` 的声明、`BUG_TRAP_TYPE_*` 枚举等。\n- **配置依赖**：  \n  - `CONFIG_CFI_CLANG`：启用 Clang CFI 支持（隐含本文件的编译）。\n  - `CONFIG_CFI_PERMISSIVE`：控制 CFI 失败时的行为（警告 vs panic）。\n  - `CONFIG_ARCH_USES_CFI_TRAPS`：决定是否启用陷阱地址识别逻辑（目前主要在 arm64 上使用）。\n  - `CONFIG_MODULES`：决定是否支持对内核模块的 CFI 陷阱识别。\n- **架构依赖**：  \n  - 依赖架构提供对 CFI 陷阱指令的支持（如 arm64 使用 `brk #0x400` 作为 CFI 中断点）。\n- **链接器脚本依赖**：  \n  - 依赖 vmlinux.lds 等链接脚本定义 `__start___kcfi_traps` 和 `__stop___kcfi_traps` 符号。\n\n## 使用场景\n\n1. **CFI 验证失败处理**：  \n   当内核执行间接函数调用（如通过函数指针）时，若目标地址的类型签名与预期不符（例如被攻击者篡改为恶意 gadget），硬件或软件 CFI 机制会触发异常，调用 `report_cfi_failure()` 进行错误处理。\n\n2. **合法 CFI 陷阱识别**：  \n   在某些架构（如 arm64）上，Clang 会将 CFI 检查实现为对特定断点指令（如 `brk`）的调用。异常处理程序需调用 `is_cfi_trap()` 判断该断点是否为编译器插入的合法 CFI 检查点，若是则执行类型验证逻辑；否则视为非法访问。\n\n3. **内核模块 CFI 支持**：  \n   当加载使用 Clang CFI 编译的内核模块时，`module_cfi_finalize()` 被调用以注册模块的 `__kcfi_traps` 节区，使得模块内的间接调用也能受到 CFI 保护，并在失败时被正确识别和处理。\n\n4. **调试与生产部署**：  \n   - 开发阶段可启用 `CONFIG_CFI_PERMISSIVE` 以收集 CFI 违规日志而不导致系统崩溃。\n   - 生产环境通常关闭该选项，确保任何 CFI 违规立即终止系统，防止安全漏洞被利用。",
      "similarity": 0.5970191955566406,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/cfi.c",
          "start_line": 10,
          "end_line": 87,
          "content": [
            "enum bug_trap_type report_cfi_failure(struct pt_regs *regs, unsigned long addr,",
            "\t\t\t\t      unsigned long *target, u32 type)",
            "{",
            "\tif (target)",
            "\t\tpr_err(\"CFI failure at %pS (target: %pS; expected type: 0x%08x)\\n\",",
            "\t\t       (void *)addr, (void *)*target, type);",
            "\telse",
            "\t\tpr_err(\"CFI failure at %pS (no target information)\\n\",",
            "\t\t       (void *)addr);",
            "",
            "\tif (IS_ENABLED(CONFIG_CFI_PERMISSIVE)) {",
            "\t\t__warn(NULL, 0, (void *)addr, 0, regs, NULL);",
            "\t\treturn BUG_TRAP_TYPE_WARN;",
            "\t}",
            "",
            "\treturn BUG_TRAP_TYPE_BUG;",
            "}",
            "static inline unsigned long trap_address(s32 *p)",
            "{",
            "\treturn (unsigned long)((long)p + (long)*p);",
            "}",
            "static bool is_trap(unsigned long addr, s32 *start, s32 *end)",
            "{",
            "\ts32 *p;",
            "",
            "\tfor (p = start; p < end; ++p) {",
            "\t\tif (trap_address(p) == addr)",
            "\t\t\treturn true;",
            "\t}",
            "",
            "\treturn false;",
            "}",
            "void module_cfi_finalize(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,",
            "\t\t\t struct module *mod)",
            "{",
            "\tchar *secstrings;",
            "\tunsigned int i;",
            "",
            "\tmod->kcfi_traps = NULL;",
            "\tmod->kcfi_traps_end = NULL;",
            "",
            "\tsecstrings = (char *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;",
            "",
            "\tfor (i = 1; i < hdr->e_shnum; i++) {",
            "\t\tif (strcmp(secstrings + sechdrs[i].sh_name, \"__kcfi_traps\"))",
            "\t\t\tcontinue;",
            "",
            "\t\tmod->kcfi_traps = (s32 *)sechdrs[i].sh_addr;",
            "\t\tmod->kcfi_traps_end = (s32 *)(sechdrs[i].sh_addr + sechdrs[i].sh_size);",
            "\t\tbreak;",
            "\t}",
            "}",
            "static bool is_module_cfi_trap(unsigned long addr)",
            "{",
            "\tstruct module *mod;",
            "\tbool found = false;",
            "",
            "\trcu_read_lock_sched_notrace();",
            "",
            "\tmod = __module_address(addr);",
            "\tif (mod)",
            "\t\tfound = is_trap(addr, mod->kcfi_traps, mod->kcfi_traps_end);",
            "",
            "\trcu_read_unlock_sched_notrace();",
            "",
            "\treturn found;",
            "}",
            "static inline bool is_module_cfi_trap(unsigned long addr)",
            "{",
            "\treturn false;",
            "}",
            "bool is_cfi_trap(unsigned long addr)",
            "{",
            "\tif (is_trap(addr, __start___kcfi_traps, __stop___kcfi_traps))",
            "\t\treturn true;",
            "",
            "\treturn is_module_cfi_trap(addr);",
            "}"
          ],
          "function_name": "report_cfi_failure, trap_address, is_trap, module_cfi_finalize, is_module_cfi_trap, is_module_cfi_trap, is_cfi_trap",
          "description": "实现CFI失败报告与陷阱检测机制，包含陷阱地址解析、模块陷阱表处理及全局陷阱检查逻辑，其中is_module_cfi_trap存在重复定义",
          "similarity": 0.6098247766494751
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/cfi.c",
          "start_line": 1,
          "end_line": 9,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Clang Control Flow Integrity (CFI) error handling.",
            " *",
            " * Copyright (C) 2022 Google LLC",
            " */",
            "",
            "#include <linux/cfi.h>",
            ""
          ],
          "function_name": null,
          "description": "CFI错误处理模块头部，声明GPL许可证并引入cfi.h头文件",
          "similarity": 0.5585547089576721
        }
      ]
    }
  ]
}