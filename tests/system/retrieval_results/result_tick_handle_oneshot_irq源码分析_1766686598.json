{
  "query": "tick_handle_oneshot_irq源码分析",
  "timestamp": "2025-12-26 02:16:38",
  "retrieved_files": [
    {
      "source_file": "kernel/irq/handle.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:55:29\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\handle.c`\n\n---\n\n# `irq/handle.c` 技术文档\n\n## 1. 文件概述\n\n`irq/handle.c` 是 Linux 内核通用中断子系统（Generic IRQ）的核心实现文件之一，负责中断事件的高层处理逻辑。该文件实现了中断处理流程中的关键函数，包括中断动作（`irqaction`）的调用、线程化中断的唤醒机制、未处理或异常中断的处理，以及架构无关的中断入口封装。其目标是为不同硬件架构提供统一、可扩展的中断处理框架。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`handle_bad_irq(struct irq_desc *desc)`**  \n  处理伪中断（spurious IRQ）或未注册处理函数的中断，记录统计信息并调用架构相关的 `ack_bad_irq()`。\n\n- **`no_action(int cpl, void *dev_id)`**  \n  空中断处理函数，返回 `IRQ_NONE`，常用于占位或测试。\n\n- **`__irq_wake_thread(struct irq_desc *desc, struct irqaction *action)`**  \n  唤醒与中断动作关联的内核线程（用于线程化中断），管理 `threads_oneshot` 和 `threads_active` 状态。\n\n- **`__handle_irq_event_percpu(struct irq_desc *desc)`**  \n  在当前 CPU 上遍历并执行该中断描述符关联的所有 `irqaction` 处理函数，支持 `IRQ_WAKE_THREAD` 返回值以触发线程化处理。\n\n- **`handle_irq_event_percpu(struct irq_desc *desc)`**  \n  对 `__handle_irq_event_percpu` 的封装，附加中断随机数注入（`add_interrupt_randomness`）和调试记录（`note_interrupt`）。\n\n- **`handle_irq_event(struct irq_desc *desc)`**  \n  中断事件处理的顶层入口，负责清除 `IRQS_PENDING` 状态、设置 `IRQD_IRQ_INPROGRESS` 标志，并在释放 `desc->lock` 后调用 per-CPU 处理函数，最后恢复锁和状态。\n\n- **`generic_handle_arch_irq(struct pt_regs *regs)`**（仅当 `CONFIG_GENERIC_IRQ_MULTI_HANDLER` 启用）  \n  架构无关的通用中断入口点，封装 `irq_enter()`/`irq_exit()` 和寄存器上下文切换。\n\n- **`set_handle_irq(void (*handle_irq)(struct pt_regs *))`**（仅当 `CONFIG_GENERIC_IRQ_MULTI_HANDLER` 启用）  \n  初始化架构特定的底层中断处理函数指针 `handle_arch_irq`。\n\n### 关键数据结构（引用）\n\n- `struct irq_desc`：中断描述符，包含中断状态、动作链表、锁等。\n- `struct irqaction`：中断动作，包含处理函数 `handler`、线程函数 `thread_fn`、设备 ID、标志等。\n- `handle_arch_irq`：函数指针，指向架构特定的底层中断分发函数（仅在 `CONFIG_GENERIC_IRQ_MULTI_HANDLER` 下定义）。\n\n## 3. 关键实现\n\n### 线程化中断唤醒机制\n\n当硬中断处理函数返回 `IRQ_WAKE_THREAD` 时，内核需唤醒对应的线程处理下半部。`__irq_wake_thread` 实现了以下关键逻辑：\n\n- 检查线程是否已退出（`PF_EXITING`），若是则忽略。\n- 使用原子位操作 `test_and_set_bit(IRQTF_RUNTHREAD, ...)` 避免重复唤醒。\n- 通过 `desc->threads_oneshot |= action->thread_mask` 标记需运行的线程。\n- 原子递增 `desc->threads_active`，供 `synchronize_irq()` 等同步原语使用。\n- 调用 `wake_up_process()` 唤醒内核线程。\n\n该机制通过 `IRQS_INPROGRESS` 状态和 `desc->lock` 实现硬中断上下文与中断线程之间的同步，确保 `threads_oneshot` 的读写安全。\n\n### 中断处理流程控制\n\n`handle_irq_event` 是中断流控的关键：\n\n1. 清除 `IRQS_PENDING`（表示中断已开始处理）。\n2. 设置 `IRQD_IRQ_INPROGRESS`（防止嵌套处理）。\n3. 释放 `desc->lock`，允许中断线程或其他 CPU 并发访问。\n4. 调用 `handle_irq_event_percpu` 执行实际处理。\n5. 重新获取锁，清除 `IRQD_IRQ_INPROGRESS`。\n\n此设计解耦了中断流控（如电平触发中断的 EOI）与具体处理逻辑，提高并发性。\n\n### 架构无关中断入口（`CONFIG_GENERIC_IRQ_MULTI_HANDLER`）\n\n该配置允许架构代码注册一个统一的中断入口函数 `handle_arch_irq`。`generic_handle_arch_irq` 作为通用包装器：\n\n- 调用 `irq_enter()` 进入中断上下文。\n- 使用 `set_irq_regs()` 切换当前 CPU 的中断寄存器上下文。\n- 调用注册的 `handle_arch_irq` 进行实际分发。\n- 恢复寄存器上下文并调用 `irq_exit()`。\n\n适用于不自行管理中断入口计数和上下文的架构（如 ARM64）。\n\n### 安全与调试\n\n- **中断使能检查**：在调用 `action->handler` 后，检查中断是否被意外使能（`WARN_ONCE(!irqs_disabled(), ...)`），若发现则强制禁用。\n- **伪中断处理**：`handle_bad_irq` 提供统一的异常中断处理路径，便于调试和统计。\n- **随机数注入**：通过 `add_interrupt_randomness()` 利用中断时间戳增强内核熵池。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`、`<linux/interrupt.h>`：中断核心 API 和数据结构。\n  - `<linux/kernel_stat.h>`：中断统计（`kstat_incr_irqs_this_cpu`）。\n  - `<linux/random.h>`：中断随机数注入。\n  - `<asm/irq_regs.h>`：架构相关的中断寄存器上下文管理。\n  - `\"internals.h\"`：中断子系统内部实现细节。\n  - `<trace/events/irq.h>`：中断事件跟踪点。\n\n- **模块依赖**：\n  - **Generic IRQ 子系统**：依赖 `irqdesc.c`、`irqchip.c` 等提供的 `irq_desc` 管理。\n  - **调度器**：`wake_up_process()` 依赖进程调度。\n  - **RCU 与同步原语**：`synchronize_irq()` 依赖 `threads_active` 计数。\n  - **架构代码**：`ack_bad_irq()`、`handle_arch_irq` 由具体架构实现。\n\n## 5. 使用场景\n\n- **设备驱动注册中断处理函数**：驱动通过 `request_irq()` 注册 `irqaction`，中断触发时由 `handle_irq_event_percpu` 调用其 `handler`。\n- **线程化中断处理**：驱动设置 `IRQF_ONESHOT` 并提供 `thread_fn`，硬中断返回 `IRQ_WAKE_THREAD` 后由 `__irq_wake_thread` 唤醒线程。\n- **伪中断或未处理中断**：硬件误触发或未注册处理函数的中断由 `handle_bad_irq` 统一处理。\n- **架构中断入口**：在 `CONFIG_GENERIC_IRQ_MULTI_HANDLER` 架构（如 ARM64）中，异常向量表直接跳转至 `generic_handle_arch_irq`。\n- **中断同步**：`synchronize_irq()` 等函数依赖 `threads_active` 计数等待线程化中断完成。\n- **内核调试与监控**：通过 `note_interrupt()` 记录异常中断，通过 ftrace 的 `irq_handler_entry/exit` 跟踪点监控中断处理性能。",
      "similarity": 0.6224135160446167,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/handle.c",
          "start_line": 1,
          "end_line": 32,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992, 1998-2006 Linus Torvalds, Ingo Molnar",
            " * Copyright (C) 2005-2006, Thomas Gleixner, Russell King",
            " *",
            " * This file contains the core interrupt handling code. Detailed",
            " * information is available in Documentation/core-api/genericirq.rst",
            " *",
            " */",
            "",
            "#include <linux/irq.h>",
            "#include <linux/random.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "",
            "#include <asm/irq_regs.h>",
            "",
            "#include <trace/events/irq.h>",
            "",
            "#include \"internals.h\"",
            "",
            "#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER",
            "void (*handle_arch_irq)(struct pt_regs *) __ro_after_init;",
            "#endif",
            "",
            "/**",
            " * handle_bad_irq - handle spurious and unhandled irqs",
            " * @desc:      description of the interrupt",
            " *",
            " * Handles spurious and unhandled IRQ's. It also prints a debugmessage.",
            " */"
          ],
          "function_name": null,
          "description": "定义了处理异常中断的函数handle_bad_irq，用于处理未处理或误触发的中断，打印调试信息并更新中断统计",
          "similarity": 0.5836387276649475
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/irq/handle.c",
          "start_line": 189,
          "end_line": 232,
          "content": [
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc)",
            "{",
            "\tirqreturn_t retval;",
            "",
            "\tretval = __handle_irq_event_percpu(desc);",
            "",
            "\tadd_interrupt_randomness(desc->irq_data.irq);",
            "",
            "\tif (!irq_settings_no_debug(desc))",
            "\t\tnote_interrupt(desc, retval);",
            "\treturn retval;",
            "}",
            "irqreturn_t handle_irq_event(struct irq_desc *desc)",
            "{",
            "\tirqreturn_t ret;",
            "",
            "\tdesc->istate &= ~IRQS_PENDING;",
            "\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);",
            "\traw_spin_unlock(&desc->lock);",
            "",
            "\tret = handle_irq_event_percpu(desc);",
            "",
            "\traw_spin_lock(&desc->lock);",
            "\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);",
            "\treturn ret;",
            "}",
            "int __init set_handle_irq(void (*handle_irq)(struct pt_regs *))",
            "{",
            "\tif (handle_arch_irq)",
            "\t\treturn -EBUSY;",
            "",
            "\thandle_arch_irq = handle_irq;",
            "\treturn 0;",
            "}",
            "asmlinkage void noinstr generic_handle_arch_irq(struct pt_regs *regs)",
            "{",
            "\tstruct pt_regs *old_regs;",
            "",
            "\tirq_enter();",
            "\told_regs = set_irq_regs(regs);",
            "\thandle_arch_irq(regs);",
            "\tset_irq_regs(old_regs);",
            "\tirq_exit();",
            "}"
          ],
          "function_name": "handle_irq_event_percpu, handle_irq_event, set_handle_irq, generic_handle_arch_irq",
          "description": "提供中断事件处理接口，包含通用架构中断入口点generic_handle_arch_irq，管理中断处理流程并集成随机化干扰注入功能",
          "similarity": 0.5788090825080872
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/handle.c",
          "start_line": 33,
          "end_line": 178,
          "content": [
            "void handle_bad_irq(struct irq_desc *desc)",
            "{",
            "\tunsigned int irq = irq_desc_get_irq(desc);",
            "",
            "\tprint_irq_desc(irq, desc);",
            "\tkstat_incr_irqs_this_cpu(desc);",
            "\tack_bad_irq(irq);",
            "}",
            "irqreturn_t no_action(int cpl, void *dev_id)",
            "{",
            "\treturn IRQ_NONE;",
            "}",
            "static void warn_no_thread(unsigned int irq, struct irqaction *action)",
            "{",
            "\tif (test_and_set_bit(IRQTF_WARNED, &action->thread_flags))",
            "\t\treturn;",
            "",
            "\tprintk(KERN_WARNING \"IRQ %d device %s returned IRQ_WAKE_THREAD \"",
            "\t       \"but no thread function available.\", irq, action->name);",
            "}",
            "void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action)",
            "{",
            "\t/*",
            "\t * In case the thread crashed and was killed we just pretend that",
            "\t * we handled the interrupt. The hardirq handler has disabled the",
            "\t * device interrupt, so no irq storm is lurking.",
            "\t */",
            "\tif (action->thread->flags & PF_EXITING)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * Wake up the handler thread for this action. If the",
            "\t * RUNTHREAD bit is already set, nothing to do.",
            "\t */",
            "\tif (test_and_set_bit(IRQTF_RUNTHREAD, &action->thread_flags))",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * It's safe to OR the mask lockless here. We have only two",
            "\t * places which write to threads_oneshot: This code and the",
            "\t * irq thread.",
            "\t *",
            "\t * This code is the hard irq context and can never run on two",
            "\t * cpus in parallel. If it ever does we have more serious",
            "\t * problems than this bitmask.",
            "\t *",
            "\t * The irq threads of this irq which clear their \"running\" bit",
            "\t * in threads_oneshot are serialized via desc->lock against",
            "\t * each other and they are serialized against this code by",
            "\t * IRQS_INPROGRESS.",
            "\t *",
            "\t * Hard irq handler:",
            "\t *",
            "\t *\tspin_lock(desc->lock);",
            "\t *\tdesc->state |= IRQS_INPROGRESS;",
            "\t *\tspin_unlock(desc->lock);",
            "\t *\tset_bit(IRQTF_RUNTHREAD, &action->thread_flags);",
            "\t *\tdesc->threads_oneshot |= mask;",
            "\t *\tspin_lock(desc->lock);",
            "\t *\tdesc->state &= ~IRQS_INPROGRESS;",
            "\t *\tspin_unlock(desc->lock);",
            "\t *",
            "\t * irq thread:",
            "\t *",
            "\t * again:",
            "\t *\tspin_lock(desc->lock);",
            "\t *\tif (desc->state & IRQS_INPROGRESS) {",
            "\t *\t\tspin_unlock(desc->lock);",
            "\t *\t\twhile(desc->state & IRQS_INPROGRESS)",
            "\t *\t\t\tcpu_relax();",
            "\t *\t\tgoto again;",
            "\t *\t}",
            "\t *\tif (!test_bit(IRQTF_RUNTHREAD, &action->thread_flags))",
            "\t *\t\tdesc->threads_oneshot &= ~mask;",
            "\t *\tspin_unlock(desc->lock);",
            "\t *",
            "\t * So either the thread waits for us to clear IRQS_INPROGRESS",
            "\t * or we are waiting in the flow handler for desc->lock to be",
            "\t * released before we reach this point. The thread also checks",
            "\t * IRQTF_RUNTHREAD under desc->lock. If set it leaves",
            "\t * threads_oneshot untouched and runs the thread another time.",
            "\t */",
            "\tdesc->threads_oneshot |= action->thread_mask;",
            "",
            "\t/*",
            "\t * We increment the threads_active counter in case we wake up",
            "\t * the irq thread. The irq thread decrements the counter when",
            "\t * it returns from the handler or in the exit path and wakes",
            "\t * up waiters which are stuck in synchronize_irq() when the",
            "\t * active count becomes zero. synchronize_irq() is serialized",
            "\t * against this code (hard irq handler) via IRQS_INPROGRESS",
            "\t * like the finalize_oneshot() code. See comment above.",
            "\t */",
            "\tatomic_inc(&desc->threads_active);",
            "",
            "\twake_up_process(action->thread);",
            "}",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc)",
            "{",
            "\tirqreturn_t retval = IRQ_NONE;",
            "\tunsigned int irq = desc->irq_data.irq;",
            "\tstruct irqaction *action;",
            "",
            "\trecord_irq_time(desc);",
            "",
            "\tfor_each_action_of_desc(desc, action) {",
            "\t\tirqreturn_t res;",
            "",
            "\t\t/*",
            "\t\t * If this IRQ would be threaded under force_irqthreads, mark it so.",
            "\t\t */",
            "\t\tif (irq_settings_can_thread(desc) &&",
            "\t\t    !(action->flags & (IRQF_NO_THREAD | IRQF_PERCPU | IRQF_ONESHOT)))",
            "\t\t\tlockdep_hardirq_threaded();",
            "",
            "\t\ttrace_irq_handler_entry(irq, action);",
            "\t\tres = action->handler(irq, action->dev_id);",
            "\t\ttrace_irq_handler_exit(irq, action, res);",
            "",
            "\t\tif (WARN_ONCE(!irqs_disabled(),\"irq %u handler %pS enabled interrupts\\n\",",
            "\t\t\t      irq, action->handler))",
            "\t\t\tlocal_irq_disable();",
            "",
            "\t\tswitch (res) {",
            "\t\tcase IRQ_WAKE_THREAD:",
            "\t\t\t/*",
            "\t\t\t * Catch drivers which return WAKE_THREAD but",
            "\t\t\t * did not set up a thread function",
            "\t\t\t */",
            "\t\t\tif (unlikely(!action->thread_fn)) {",
            "\t\t\t\twarn_no_thread(irq, action);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "",
            "\t\t\t__irq_wake_thread(desc, action);",
            "\t\t\tbreak;",
            "",
            "\t\tdefault:",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tretval |= res;",
            "\t}",
            "",
            "\treturn retval;",
            "}"
          ],
          "function_name": "handle_bad_irq, no_action, warn_no_thread, __irq_wake_thread, __handle_irq_event_percpu",
          "description": "实现中断处理核心逻辑，包括错误中断处理、唤醒线程函数、事件分发及中断处理结果收集，包含中断线程唤醒与状态同步机制",
          "similarity": 0.46656155586242676
        }
      ]
    },
    {
      "source_file": "kernel/irq/internals.h",
      "md_summary": "> 自动生成时间: 2025-10-25 13:56:46\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\internals.h`\n\n---\n\n# `irq/internals.h` 技术文档\n\n## 1. 文件概述\n\n`irq/internals.h` 是 Linux 内核中断子系统（IRQ subsystem）的内部头文件，**仅供 `kernel/irq/` 目录下的源文件使用**。该文件定义了中断描述符（`irq_desc`）和中断数据（`irq_data`）的内部状态标志、核心辅助函数、锁操作接口以及中断生命周期管理的关键函数。其内容属于中断子系统的实现细节，**严禁在非核心代码中直接引用或依赖**。\n\n## 2. 核心功能\n\n### 2.1 关键宏定义\n- `MAX_SPARSE_IRQS`：根据是否启用 `CONFIG_SPARSE_IRQ`，定义最大支持的 IRQ 数量（`INT_MAX` 或 `NR_IRQS`）。\n- `istate`：`irq_desc` 中内部状态字段的别名（`core_internal_state__do_not_mess_with_it`），强调其私有性。\n- `IRQ_RESEND` / `IRQ_NORESEND`：控制中断是否需要重发的布尔常量。\n- `IRQ_START_FORCE` / `IRQ_START_COND`：控制中断启动行为的标志。\n- `_IRQ_DESC_CHECK` / `_IRQ_DESC_PERCPU`：用于描述符获取时的检查类型标志。\n\n### 2.2 内部状态标志\n- **线程处理标志（`IRQTF_*`）**：\n  - `IRQTF_RUNTHREAD`：通知中断处理线程运行。\n  - `IRQTF_WARNED`：已打印缺少线程函数的警告。\n  - `IRQTF_AFFINITY`：请求调整线程亲和性。\n  - `IRQTF_FORCED_THREAD`：该 action 被强制线程化。\n  - `IRQTF_READY`：中断线程已就绪。\n  \n- **描述符核心状态标志（`IRQS_*`）**：\n  - `IRQS_AUTODETECT`：自动检测进行中。\n  - `IRQS_SPURIOUS_DISABLED`：因伪中断被禁用。\n  - `IRQS_POLL_INPROGRESS`：轮询进行中。\n  - `IRQS_ONESHOT`：主处理函数不自动解屏蔽。\n  - `IRQS_REPLAY` / `IRQS_PENDING`：控制中断重发逻辑。\n  - `IRQS_SUSPENDED`：中断处于挂起状态。\n  - `IRQS_NMI`：该 IRQ 用于传递 NMI。\n  - `IRQS_SYSFS`：已注册到 sysfs。\n\n### 2.3 核心函数\n- **中断生命周期管理**：\n  - `irq_activate()` / `irq_activate_and_startup()` / `irq_startup()`：激活并启动中断。\n  - `irq_shutdown()` / `irq_shutdown_and_deactivate()`：关闭并停用中断。\n  - `irq_enable()` / `irq_disable()`：启用/禁用中断。\n  - `irq_percpu_enable()` / `irq_percpu_disable()`：针对 per-CPU 中断的启停。\n  - `mask_irq()` / `unmask_irq()` / `unmask_threaded_irq()`：屏蔽/解屏蔽中断。\n\n- **中断处理与重发**：\n  - `handle_irq_event()` / `handle_irq_event_percpu()`：处理中断事件。\n  - `check_irq_resend()` / `clear_irq_resend()` / `irq_resend_init()`：管理中断重发逻辑。\n  - `irq_wait_for_poll()`：等待轮询完成。\n\n- **线程管理**：\n  - `__irq_wake_thread()`：唤醒中断处理线程。\n  - `wake_threads_waitq()`：唤醒所有等待的中断线程。\n  - `irq_set_thread_affinity()`：设置中断线程的 CPU 亲和性。\n\n- **描述符锁操作**：\n  - `irq_get_desc_lock()` / `irq_put_desc_unlock()`：获取/释放描述符自旋锁。\n  - `irq_get_desc_buslock()` / `irq_put_desc_busunlock()`：获取/释放带总线锁的描述符锁。\n\n- **状态访问与操作**：\n  - `irqd_set()` / `irqd_clear()` / `irqd_has_set()`：操作 `irq_data` 的状态位。\n  - `irq_state_set_disabled()` / `irq_state_set_masked()`：设置描述符的禁用/屏蔽状态。\n\n- **辅助功能**：\n  - `kstat_irqs_desc()`：获取指定 CPU 掩码下的中断统计。\n  - `irq_mark_irq()`：标记 IRQ（非稀疏 IRQ 模式下使用）。\n  - `irq_can_set_affinity_usr()`：检查用户空间是否可设置亲和性。\n  - `irq_setup_affinity()`：设置中断亲和性（SMP 模式下）。\n\n### 2.4 总线锁支持\n- `chip_bus_lock()` / `chip_bus_sync_unlock()`：调用 IRQ 芯片的总线锁/解锁回调，用于慢速总线（如 I2C）上的 IRQ 芯片操作同步。\n\n### 2.5 Procfs 接口（条件编译）\n- `register_irq_proc()` / `unregister_irq_proc()`：注册/注销 `/proc/interrupts` 条目。\n- `register_handler_proc()` / `unregister_handler_proc()`：注册/注销中断处理函数的 proc 条目。\n\n## 3. 关键实现\n\n### 3.1 状态管理\n- 使用位掩码（bitmask）高效管理中断描述符和数据的多种状态。\n- 通过 `ACCESS_PRIVATE` 宏（在 `__irqd_to_state` 中）安全访问 `irq_data` 的私有状态字段，防止直接操作。\n\n### 3.2 锁机制\n- 提供两套描述符获取/释放接口：\n  - 普通锁：仅获取描述符自旋锁。\n  - 总线锁：在获取描述符锁前后调用芯片的 `irq_bus_lock`/`irq_bus_sync_unlock` 回调，确保慢速总线操作的原子性。\n\n### 3.3 中断重发机制\n- 通过 `IRQS_PENDING` 和 `IRQS_REPLAY` 标志协同工作：\n  - 当中断在屏蔽状态下触发时，设置 `IRQS_PENDING`。\n  - 在解屏蔽时检查 `IRQS_PENDING`，若置位则触发重发（`IRQS_REPLAY`），并在处理后清除。\n\n### 3.4 线程化中断\n- 使用 `IRQTF_*` 标志协调主处理函数与中断线程的交互。\n- `__irq_wake_thread()` 负责唤醒对应的处理线程，并通过标志位传递控制信息（如亲和性调整请求）。\n\n### 3.5 稀疏 IRQ 支持\n- 通过 `CONFIG_SPARSE_IRQ` 条件编译，优化 IRQ 描述符的内存布局（稀疏模式下使用 radix tree，非稀疏模式下使用数组）。\n- `irq_mark_irq()` 在非稀疏模式下用于标记已分配的 IRQ。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irqdesc.h>`：中断描述符定义。\n  - `<linux/kernel_stat.h>`：中断统计。\n  - `<linux/pm_runtime.h>`：运行时电源管理。\n  - `<linux/sched/clock.h>`：调度时钟。\n  - `\"debug.h\"` / `\"settings.h\"`：IRQ 子系统内部调试和配置。\n\n- **模块依赖**：\n  - **IRQ Core**：所有函数均服务于中断核心逻辑。\n  - **IRQ Chips**：通过 `irq_data.chip` 回调与具体硬件交互。\n  - **SMP Subsystem**：亲和性设置依赖 SMP 支持。\n  - **Procfs**：条件编译依赖 `CONFIG_PROC_FS`。\n  - **Sparse IRQ**：条件编译依赖 `CONFIG_SPARSE_IRQ`。\n\n## 5. 使用场景\n\n- **中断子系统初始化**：在 `kernel/irq/` 目录下的初始化代码中调用 `irq_activate()` 等函数。\n- **中断处理流程**：`handle_irq_event()` 等函数在中断上下文中被调用，处理中断事件。\n- **中断配置**：设备驱动通过公共 API（如 `request_irq()`）间接调用内部函数（如 `__irq_set_trigger()`）配置中断。\n- **电源管理**：在系统挂起/恢复时，通过 `irq_suspend()`/`irq_resume()`（未在本文件直接定义，但依赖本文件状态）管理 `IRQS_SUSPENDED` 状态。\n- **调试与监控**：通过 `/proc/interrupts`（依赖 `register_irq_proc()`）和内核日志提供中断信息。\n- **慢速总线设备**：I2C/SPI 等设备的 IRQ 芯片驱动使用 `chip_bus_lock()` 确保操作原子性。",
      "similarity": 0.6040682792663574,
      "chunks": []
    },
    {
      "source_file": "kernel/irq/irqdesc.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:59:49\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `irq\\irqdesc.c`\n\n---\n\n# `irq/irqdesc.c` 技术文档\n\n## 1. 文件概述\n\n`irq/irqdesc.c` 是 Linux 内核通用中断子系统（Generic IRQ）的核心实现文件之一，负责中断描述符（`struct irq_desc`）的分配、初始化、管理和释放。该文件实现了中断描述符的生命周期管理，包括在稀疏 IRQ（`CONFIG_SPARSE_IRQ`）配置下的动态分配机制，以及与 SMP（对称多处理）相关的中断亲和性（affinity）管理。它为上层中断处理（如设备驱动注册中断处理函数）和底层硬件中断控制器（通过 `irq_chip`）之间提供了统一的抽象层。\n\n## 2. 核心功能\n\n### 主要数据结构\n- **`struct irq_desc`**：中断描述符，代表一个逻辑中断号（IRQ number），包含中断状态、处理函数、统计信息、锁、亲和性掩码等。\n- **`struct irq_data`**：嵌入在 `irq_desc` 中，包含与硬件中断控制器相关的数据（如 `irq_chip`、`hwirq`、`irq_domain` 等）。\n- **`struct irq_common_data`**：`irq_desc` 和 `irq_data` 共享的数据，如 MSI 描述符、亲和性掩码等。\n- **`sparse_irqs`**：基于 Maple Tree 的稀疏 IRQ 描述符存储结构，用于动态分配 IRQ 号。\n\n### 主要函数\n- **`init_desc()`**：初始化一个 `irq_desc` 实例，包括分配 per-CPU 统计结构、SMP 掩码、初始化锁和默认值。\n- **`desc_set_defaults()`**：设置 `irq_desc` 的默认初始状态（如禁用、屏蔽、默认处理函数为 `handle_bad_irq`）。\n- **`alloc_masks()` / `free_masks()` / `desc_smp_init()`**：SMP 相关的亲和性掩码（affinity、effective_affinity、pending_mask）的分配、释放和初始化。\n- **`irq_find_free_area()` / `irq_find_at_or_after()`**：在稀疏 IRQ 模式下查找可用的 IRQ 号范围或下一个可用 IRQ。\n- **`irq_insert_desc()` / `delete_irq_desc()`**：将 `irq_desc` 插入或从稀疏 IRQ 的 Maple Tree 中删除。\n- **`init_irq_default_affinity()`**：初始化默认的中断亲和性掩码（通常为所有 CPU）。\n- **`irq_kobj_release()` 及相关 sysfs 属性函数**：实现 IRQ 描述符的 sysfs 接口（如 `per_cpu_count`、`chip_name`、`hwirq` 等）。\n\n### 全局变量\n- **`nr_irqs`**：系统支持的最大 IRQ 数量，可被平台代码覆盖。\n- **`irq_default_affinity`**：默认的中断亲和性 CPU 掩码（SMP 模式下）。\n- **`irq_desc_lock_class`**：用于 lockdep 的 IRQ 描述符自旋锁的统一锁类。\n\n## 3. 关键实现\n\n### 稀疏 IRQ 管理（`CONFIG_SPARSE_IRQ`）\n- 使用 **Maple Tree** 数据结构（`sparse_irqs`）替代传统的静态数组，支持动态分配 IRQ 描述符。\n- `irq_find_free_area()` 利用 Maple Tree 的空闲区间查找功能，高效分配连续的 IRQ 号。\n- `irq_insert_desc()` 和 `delete_irq_desc()` 通过 RCU 安全地插入/删除描述符，支持运行时 IRQ 的动态增删。\n- 每个 `irq_desc` 作为独立的 kobject，通过 sysfs 暴露属性（如中断计数、芯片名称等）。\n\n### SMP 中断亲和性\n- **亲和性掩码**：每个 IRQ 可配置其允许运行的 CPU 集合（`affinity`），支持负载均衡和局部性优化。\n- **有效亲和性**（`effective_affinity`）：实际生效的亲和性（可能受中断迁移或 pending 状态影响）。\n- **Pending 掩码**（`pending_mask`）：用于在中断迁移过程中暂存中断事件。\n- 启动参数 `irqaffinity=` 可设置全局默认亲和性，但至少包含引导 CPU 以防配置错误。\n\n### 描述符初始化\n- `init_desc()` 完成描述符的完整初始化：\n  - 分配 per-CPU 中断统计结构（`kstat_irqs`）。\n  - 初始化 SMP 相关掩码（若启用）。\n  - 设置自旋锁（带 lockdep 类）和互斥锁（`request_mutex`）。\n  - 调用 `desc_set_defaults()` 设置默认状态（禁用、屏蔽、无效处理函数）。\n  - 初始化 RCU 回调（用于稀疏 IRQ 的延迟释放）。\n\n### 锁与并发控制\n- **`desc->lock`**：raw spinlock，保护描述符关键字段（如状态、处理函数），在中断上下文中使用。\n- **`desc->request_mutex`**：mutex，用于串行化中断请求/释放操作（如 `request_irq()`）。\n- **Maple Tree 操作**：通过外部互斥锁（`sparse_irq_lock`）和 RCU 保证并发安全。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/irq.h>`、`<linux/interrupt.h>`：IRQ 子系统核心 API 和数据结构。\n  - `<linux/irqdomain.h>`：硬件中断号（hwirq）到逻辑 IRQ 号的映射。\n  - `<linux/maple_tree.h>`：稀疏 IRQ 的底层存储实现。\n  - `<linux/sysfs.h>`：sysfs 属性支持。\n  - `\"internals.h\"`：IRQ 子系统内部函数和宏。\n- **配置依赖**：\n  - `CONFIG_SMP`：启用多处理器支持（亲和性掩码管理）。\n  - `CONFIG_SPARSE_IRQ`：启用动态 IRQ 分配（替代静态数组）。\n  - `CONFIG_GENERIC_PENDING_IRQ` / `CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK`：扩展的 SMP 中断管理功能。\n- **模块交互**：\n  - **中断控制器驱动**：通过 `irq_chip` 操作硬件，依赖 `irq_desc` 提供的抽象。\n  - **设备驱动**：通过 `request_irq()` 等接口注册中断处理函数，操作 `irq_desc`。\n  - **电源管理**：通过 `wakeup` 属性控制中断的唤醒能力。\n\n## 5. 使用场景\n\n- **系统启动阶段**：\n  - 初始化默认中断亲和性（`init_irq_default_affinity()`）。\n  - 预分配或动态创建平台所需的 IRQ 描述符（通过 `alloc_descs()` 等）。\n- **设备驱动加载/卸载**：\n  - 动态分配 IRQ 描述符（稀疏 IRQ 模式下通过 `irq_alloc_desc()`）。\n  - 注册/注销中断处理函数（修改 `handle_irq` 和 action 链表）。\n- **运行时中断管理**：\n  - 修改中断亲和性（`/proc/irq/<n>/smp_affinity`）。\n  - 查询中断统计信息（`/proc/interrupts`，通过 per-CPU 计数）。\n  - 通过 sysfs 查看 IRQ 属性（芯片名称、硬件 IRQ 号、触发类型等）。\n- **中断迁移**（SMP）：\n  - 在 CPU 热插拔或负载均衡时，更新 `affinity` 和 `pending_mask`。\n- **错误处理**：\n  - 未处理的中断由 `handle_bad_irq` 处理，记录到 `irqs_unhandled`。",
      "similarity": 0.5969584584236145,
      "chunks": [
        {
          "chunk_id": 6,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 705,
          "end_line": 824,
          "content": [
            "int generic_handle_irq(unsigned int irq)",
            "{",
            "\treturn handle_irq_desc(irq_to_desc(irq));",
            "}",
            "int generic_handle_irq_safe(unsigned int irq)",
            "{",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\tlocal_irq_save(flags);",
            "\tret = handle_irq_desc(irq_to_desc(irq));",
            "\tlocal_irq_restore(flags);",
            "\treturn ret;",
            "}",
            "int generic_handle_domain_irq(struct irq_domain *domain, unsigned int hwirq)",
            "{",
            "\treturn handle_irq_desc(irq_resolve_mapping(domain, hwirq));",
            "}",
            "int generic_handle_domain_irq_safe(struct irq_domain *domain, unsigned int hwirq)",
            "{",
            "\tunsigned long flags;",
            "\tint ret;",
            "",
            "\tlocal_irq_save(flags);",
            "\tret = handle_irq_desc(irq_resolve_mapping(domain, hwirq));",
            "\tlocal_irq_restore(flags);",
            "\treturn ret;",
            "}",
            "int generic_handle_domain_nmi(struct irq_domain *domain, unsigned int hwirq)",
            "{",
            "\tWARN_ON_ONCE(!in_nmi());",
            "\treturn handle_irq_desc(irq_resolve_mapping(domain, hwirq));",
            "}",
            "void irq_free_descs(unsigned int from, unsigned int cnt)",
            "{",
            "\tint i;",
            "",
            "\tif (from >= nr_irqs || (from + cnt) > nr_irqs)",
            "\t\treturn;",
            "",
            "\tmutex_lock(&sparse_irq_lock);",
            "\tfor (i = 0; i < cnt; i++)",
            "\t\tfree_desc(from + i);",
            "",
            "\tmutex_unlock(&sparse_irq_lock);",
            "}",
            "int __ref",
            "__irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,",
            "\t\t  struct module *owner, const struct irq_affinity_desc *affinity)",
            "{",
            "\tint start, ret;",
            "",
            "\tif (!cnt)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (irq >= 0) {",
            "\t\tif (from > irq)",
            "\t\t\treturn -EINVAL;",
            "\t\tfrom = irq;",
            "\t} else {",
            "\t\t/*",
            "\t\t * For interrupts which are freely allocated the",
            "\t\t * architecture can force a lower bound to the @from",
            "\t\t * argument. x86 uses this to exclude the GSI space.",
            "\t\t */",
            "\t\tfrom = arch_dynirq_lower_bound(from);",
            "\t}",
            "",
            "\tmutex_lock(&sparse_irq_lock);",
            "",
            "\tstart = irq_find_free_area(from, cnt);",
            "\tret = -EEXIST;",
            "\tif (irq >=0 && start != irq)",
            "\t\tgoto unlock;",
            "",
            "\tif (start + cnt > nr_irqs) {",
            "\t\tret = irq_expand_nr_irqs(start + cnt);",
            "\t\tif (ret)",
            "\t\t\tgoto unlock;",
            "\t}",
            "\tret = alloc_descs(start, cnt, node, affinity, owner);",
            "unlock:",
            "\tmutex_unlock(&sparse_irq_lock);",
            "\treturn ret;",
            "}",
            "unsigned int irq_get_next_irq(unsigned int offset)",
            "{",
            "\treturn irq_find_at_or_after(offset);",
            "}",
            "void __irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags, bool bus)",
            "\t__releases(&desc->lock)",
            "{",
            "\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "\tif (bus)",
            "\t\tchip_bus_sync_unlock(desc);",
            "}",
            "int irq_set_percpu_devid_partition(unsigned int irq,",
            "\t\t\t\t   const struct cpumask *affinity)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (desc->percpu_enabled)",
            "\t\treturn -EINVAL;",
            "",
            "\tdesc->percpu_enabled = kzalloc(sizeof(*desc->percpu_enabled), GFP_KERNEL);",
            "",
            "\tif (!desc->percpu_enabled)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (affinity)",
            "\t\tdesc->percpu_affinity = affinity;",
            "\telse",
            "\t\tdesc->percpu_affinity = cpu_possible_mask;",
            "",
            "\tirq_set_percpu_devid_flags(irq);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "generic_handle_irq, generic_handle_irq_safe, generic_handle_domain_irq, generic_handle_domain_irq_safe, generic_handle_domain_nmi, irq_free_descs, __irq_alloc_descs, irq_get_next_irq, __irq_put_desc_unlock, irq_set_percpu_devid_partition",
          "description": "generic_handle_irq 安全处理通用中断，调用handle_irq_desc。generic_handle_domain_irq 处理IRQ domain映射的硬件中断。irq_free_descs 释放指定范围的中断描述符。__irq_alloc_descs 动态分配连续中断号并初始化描述符。irq_get_next_irq 获取下一个可用中断号。__irq_put_desc_unlock 解锁中断描述符并同步总线。irq_set_percpu_devid_partition 设置中断亲和性分区。",
          "similarity": 0.5650225877761841
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 1,
          "end_line": 26,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 1992, 1998-2006 Linus Torvalds, Ingo Molnar",
            " * Copyright (C) 2005-2006, Thomas Gleixner, Russell King",
            " *",
            " * This file contains the interrupt descriptor management code. Detailed",
            " * information is available in Documentation/core-api/genericirq.rst",
            " *",
            " */",
            "#include <linux/irq.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/maple_tree.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/sysfs.h>",
            "",
            "#include \"internals.h\"",
            "",
            "/*",
            " * lockdep: we want to handle all irq_desc locks as a single lock-class:",
            " */",
            "static struct lock_class_key irq_desc_lock_class;",
            "",
            "#if defined(CONFIG_SMP)"
          ],
          "function_name": null,
          "description": "此代码块定义了中断描述符管理模块的头部信息，声明了用于锁分类的key变量irq_desc_lock_class，并包含SMP支持的相关代码片段。由于上下文不完整，无法确定所有功能细节。",
          "similarity": 0.5561295747756958
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 562,
          "end_line": 667,
          "content": [
            "int __init early_irq_init(void)",
            "{",
            "\tint i, initcnt, node = first_online_node;",
            "\tstruct irq_desc *desc;",
            "",
            "\tinit_irq_default_affinity();",
            "",
            "\t/* Let arch update nr_irqs and return the nr of preallocated irqs */",
            "\tinitcnt = arch_probe_nr_irqs();",
            "\tprintk(KERN_INFO \"NR_IRQS: %d, nr_irqs: %d, preallocated irqs: %d\\n\",",
            "\t       NR_IRQS, nr_irqs, initcnt);",
            "",
            "\tif (WARN_ON(nr_irqs > MAX_SPARSE_IRQS))",
            "\t\tnr_irqs = MAX_SPARSE_IRQS;",
            "",
            "\tif (WARN_ON(initcnt > MAX_SPARSE_IRQS))",
            "\t\tinitcnt = MAX_SPARSE_IRQS;",
            "",
            "\tif (initcnt > nr_irqs)",
            "\t\tnr_irqs = initcnt;",
            "",
            "\tfor (i = 0; i < initcnt; i++) {",
            "\t\tdesc = alloc_desc(i, node, 0, NULL, NULL);",
            "\t\tirq_insert_desc(i, desc);",
            "\t}",
            "\treturn arch_early_irq_init();",
            "}",
            "int __init early_irq_init(void)",
            "{",
            "\tint count, i, node = first_online_node;",
            "\tint ret;",
            "",
            "\tinit_irq_default_affinity();",
            "",
            "\tprintk(KERN_INFO \"NR_IRQS: %d\\n\", NR_IRQS);",
            "",
            "\tcount = ARRAY_SIZE(irq_desc);",
            "",
            "\tfor (i = 0; i < count; i++) {",
            "\t\tret = init_desc(irq_desc + i, i, node, 0, NULL, NULL);",
            "\t\tif (unlikely(ret))",
            "\t\t\tgoto __free_desc_res;",
            "\t}",
            "",
            "\treturn arch_early_irq_init();",
            "",
            "__free_desc_res:",
            "\twhile (--i >= 0) {",
            "\t\tfree_masks(irq_desc + i);",
            "\t\tfree_percpu(irq_desc[i].kstat_irqs);",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static void free_desc(unsigned int irq)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&desc->lock, flags);",
            "\tdesc_set_defaults(irq, desc, irq_desc_get_node(desc), NULL, NULL);",
            "\traw_spin_unlock_irqrestore(&desc->lock, flags);",
            "\tdelete_irq_desc(irq);",
            "}",
            "static inline int alloc_descs(unsigned int start, unsigned int cnt, int node,",
            "\t\t\t      const struct irq_affinity_desc *affinity,",
            "\t\t\t      struct module *owner)",
            "{",
            "\tu32 i;",
            "",
            "\tfor (i = 0; i < cnt; i++) {",
            "\t\tstruct irq_desc *desc = irq_to_desc(start + i);",
            "",
            "\t\tdesc->owner = owner;",
            "\t\tirq_insert_desc(start + i, desc);",
            "\t}",
            "\treturn start;",
            "}",
            "static int irq_expand_nr_irqs(unsigned int nr)",
            "{",
            "\treturn -ENOMEM;",
            "}",
            "void irq_mark_irq(unsigned int irq)",
            "{",
            "\tmutex_lock(&sparse_irq_lock);",
            "\tirq_insert_desc(irq, irq_desc + irq);",
            "\tmutex_unlock(&sparse_irq_lock);",
            "}",
            "void irq_init_desc(unsigned int irq)",
            "{",
            "\tfree_desc(irq);",
            "}",
            "int handle_irq_desc(struct irq_desc *desc)",
            "{",
            "\tstruct irq_data *data;",
            "",
            "\tif (!desc)",
            "\t\treturn -EINVAL;",
            "",
            "\tdata = irq_desc_get_irq_data(desc);",
            "\tif (WARN_ON_ONCE(!in_hardirq() && handle_enforce_irqctx(data)))",
            "\t\treturn -EPERM;",
            "",
            "\tgeneric_handle_irq_desc(desc);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "early_irq_init, early_irq_init, free_desc, alloc_descs, irq_expand_nr_irqs, irq_mark_irq, irq_init_desc, handle_irq_desc",
          "description": "early_irq_init 初始化早期中断描述符，调用架构特定函数确定中断数量并分配初始中断描述符。free_desc 释放中断描述符并重置为其默认状态。alloc_descs 批量分配中断描述符到指定范围。irq_mark_irq 将中断标记为已初始化。irq_init_desc 初始化指定中断描述符。handle_irq_desc 处理中断描述符，检查硬中断上下文并调用通用处理函数。",
          "similarity": 0.5155797004699707
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 938,
          "end_line": 1027,
          "content": [
            "int irq_set_percpu_devid(unsigned int irq)",
            "{",
            "\treturn irq_set_percpu_devid_partition(irq, NULL);",
            "}",
            "int irq_get_percpu_devid_partition(unsigned int irq, struct cpumask *affinity)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (!desc || !desc->percpu_enabled)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (affinity)",
            "\t\tcpumask_copy(affinity, desc->percpu_affinity);",
            "",
            "\treturn 0;",
            "}",
            "void kstat_incr_irq_this_cpu(unsigned int irq)",
            "{",
            "\tkstat_incr_irqs_this_cpu(irq_to_desc(irq));",
            "}",
            "unsigned int kstat_irqs_cpu(unsigned int irq, int cpu)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\treturn desc && desc->kstat_irqs ? per_cpu(desc->kstat_irqs->cnt, cpu) : 0;",
            "}",
            "static bool irq_is_nmi(struct irq_desc *desc)",
            "{",
            "\treturn desc->istate & IRQS_NMI;",
            "}",
            "unsigned int kstat_irqs_desc(struct irq_desc *desc, const struct cpumask *cpumask)",
            "{",
            "\tunsigned int sum = 0;",
            "\tint cpu;",
            "",
            "\tif (!irq_settings_is_per_cpu_devid(desc) &&",
            "\t    !irq_settings_is_per_cpu(desc) &&",
            "\t    !irq_is_nmi(desc))",
            "\t\treturn data_race(desc->tot_count);",
            "",
            "\tfor_each_cpu(cpu, cpumask)",
            "\t\tsum += data_race(per_cpu(desc->kstat_irqs->cnt, cpu));",
            "\treturn sum;",
            "}",
            "static unsigned int kstat_irqs(unsigned int irq)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (!desc || !desc->kstat_irqs)",
            "\t\treturn 0;",
            "\treturn kstat_irqs_desc(desc, cpu_possible_mask);",
            "}",
            "void kstat_snapshot_irqs(void)",
            "{",
            "\tstruct irq_desc *desc;",
            "\tunsigned int irq;",
            "",
            "\tfor_each_irq_desc(irq, desc) {",
            "\t\tif (!desc->kstat_irqs)",
            "\t\t\tcontinue;",
            "\t\tthis_cpu_write(desc->kstat_irqs->ref, this_cpu_read(desc->kstat_irqs->cnt));",
            "\t}",
            "}",
            "unsigned int kstat_get_irq_since_snapshot(unsigned int irq)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (!desc || !desc->kstat_irqs)",
            "\t\treturn 0;",
            "\treturn this_cpu_read(desc->kstat_irqs->cnt) - this_cpu_read(desc->kstat_irqs->ref);",
            "}",
            "unsigned int kstat_irqs_usr(unsigned int irq)",
            "{",
            "\tunsigned int sum;",
            "",
            "\trcu_read_lock();",
            "\tsum = kstat_irqs(irq);",
            "\trcu_read_unlock();",
            "\treturn sum;",
            "}",
            "void __irq_set_lockdep_class(unsigned int irq, struct lock_class_key *lock_class,",
            "\t\t\t     struct lock_class_key *request_class)",
            "{",
            "\tstruct irq_desc *desc = irq_to_desc(irq);",
            "",
            "\tif (desc) {",
            "\t\tlockdep_set_class(&desc->lock, lock_class);",
            "\t\tlockdep_set_class(&desc->request_mutex, request_class);",
            "\t}",
            "}"
          ],
          "function_name": "irq_set_percpu_devid, irq_get_percpu_devid_partition, kstat_incr_irq_this_cpu, kstat_irqs_cpu, irq_is_nmi, kstat_irqs_desc, kstat_irqs, kstat_snapshot_irqs, kstat_get_irq_since_snapshot, kstat_irqs_usr, __irq_set_lockdep_class",
          "description": "irq_set_percpu_devid 设置中断为每个CPU专用模式。irq_get_percpu_devid_partition 获取中断的亲和性掩码。kstat_incr_irq_this_cpu 增加当前CPU的中断统计计数。kstat_irqs_cpu 查询指定CPU的中断次数。irq_is_nmi 判断中断是否为NMI。kstat_irqs_desc 计算指定CPU掩码下的中断总数。kstat_snapshot_irqs 快照中断统计数据。kstat_get_irq_since_snapshot 获取自快照后的中断次数。__irq_set_lockdep_class 设置中断描述符锁的锁跟踪类别。",
          "similarity": 0.505527913570404
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/irq/irqdesc.c",
          "start_line": 27,
          "end_line": 127,
          "content": [
            "static int __init irq_affinity_setup(char *str)",
            "{",
            "\talloc_bootmem_cpumask_var(&irq_default_affinity);",
            "\tcpulist_parse(str, irq_default_affinity);",
            "\t/*",
            "\t * Set at least the boot cpu. We don't want to end up with",
            "\t * bugreports caused by random commandline masks",
            "\t */",
            "\tcpumask_set_cpu(smp_processor_id(), irq_default_affinity);",
            "\treturn 1;",
            "}",
            "static void __init init_irq_default_affinity(void)",
            "{",
            "\tif (!cpumask_available(irq_default_affinity))",
            "\t\tzalloc_cpumask_var(&irq_default_affinity, GFP_NOWAIT);",
            "\tif (cpumask_empty(irq_default_affinity))",
            "\t\tcpumask_setall(irq_default_affinity);",
            "}",
            "static void __init init_irq_default_affinity(void)",
            "{",
            "}",
            "static int alloc_masks(struct irq_desc *desc, int node)",
            "{",
            "\tif (!zalloc_cpumask_var_node(&desc->irq_common_data.affinity,",
            "\t\t\t\t     GFP_KERNEL, node))",
            "\t\treturn -ENOMEM;",
            "",
            "#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK",
            "\tif (!zalloc_cpumask_var_node(&desc->irq_common_data.effective_affinity,",
            "\t\t\t\t     GFP_KERNEL, node)) {",
            "\t\tfree_cpumask_var(desc->irq_common_data.affinity);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "#endif",
            "",
            "#ifdef CONFIG_GENERIC_PENDING_IRQ",
            "\tif (!zalloc_cpumask_var_node(&desc->pending_mask, GFP_KERNEL, node)) {",
            "#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK",
            "\t\tfree_cpumask_var(desc->irq_common_data.effective_affinity);",
            "#endif",
            "\t\tfree_cpumask_var(desc->irq_common_data.affinity);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "#endif",
            "\treturn 0;",
            "}",
            "static void desc_smp_init(struct irq_desc *desc, int node,",
            "\t\t\t  const struct cpumask *affinity)",
            "{",
            "\tif (!affinity)",
            "\t\taffinity = irq_default_affinity;",
            "\tcpumask_copy(desc->irq_common_data.affinity, affinity);",
            "",
            "#ifdef CONFIG_GENERIC_PENDING_IRQ",
            "\tcpumask_clear(desc->pending_mask);",
            "#endif",
            "#ifdef CONFIG_NUMA",
            "\tdesc->irq_common_data.node = node;",
            "#endif",
            "}",
            "static void free_masks(struct irq_desc *desc)",
            "{",
            "#ifdef CONFIG_GENERIC_PENDING_IRQ",
            "\tfree_cpumask_var(desc->pending_mask);",
            "#endif",
            "\tfree_cpumask_var(desc->irq_common_data.affinity);",
            "#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK",
            "\tfree_cpumask_var(desc->irq_common_data.effective_affinity);",
            "#endif",
            "}",
            "static inline int",
            "alloc_masks(struct irq_desc *desc, int node) { return 0; }",
            "static inline void",
            "desc_smp_init(struct irq_desc *desc, int node, const struct cpumask *affinity) { }",
            "static inline void free_masks(struct irq_desc *desc) { }",
            "static void desc_set_defaults(unsigned int irq, struct irq_desc *desc, int node,",
            "\t\t\t      const struct cpumask *affinity, struct module *owner)",
            "{",
            "\tint cpu;",
            "",
            "\tdesc->irq_common_data.handler_data = NULL;",
            "\tdesc->irq_common_data.msi_desc = NULL;",
            "",
            "\tdesc->irq_data.common = &desc->irq_common_data;",
            "\tdesc->irq_data.irq = irq;",
            "\tdesc->irq_data.chip = &no_irq_chip;",
            "\tdesc->irq_data.chip_data = NULL;",
            "\tirq_settings_clr_and_set(desc, ~0, _IRQ_DEFAULT_INIT_FLAGS);",
            "\tirqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);",
            "\tirqd_set(&desc->irq_data, IRQD_IRQ_MASKED);",
            "\tdesc->handle_irq = handle_bad_irq;",
            "\tdesc->depth = 1;",
            "\tdesc->irq_count = 0;",
            "\tdesc->irqs_unhandled = 0;",
            "\tdesc->tot_count = 0;",
            "\tdesc->name = NULL;",
            "\tdesc->owner = owner;",
            "\tfor_each_possible_cpu(cpu)",
            "\t\t*per_cpu_ptr(desc->kstat_irqs, cpu) = (struct irqstat) { };",
            "\tdesc_smp_init(desc, node, affinity);",
            "}"
          ],
          "function_name": "irq_affinity_setup, init_irq_default_affinity, init_irq_default_affinity, alloc_masks, desc_smp_init, free_masks, alloc_masks, desc_smp_init, free_masks, desc_set_defaults",
          "description": "包含中断亲和性初始化与内存分配相关函数，负责设置默认CPU亲和掩码、分配irq_desc结构体的affinity字段、初始化SMP相关信息及释放相关资源。存在多处函数重载实现，体现不同配置条件下的差异化处理。",
          "similarity": 0.4924514889717102
        }
      ]
    }
  ]
}