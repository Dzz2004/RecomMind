{
  "query": "引导程序传递启动参数的机制",
  "timestamp": "2025-12-26 00:36:01",
  "retrieved_files": [
    {
      "source_file": "kernel/entry/syscall_user_dispatch.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:20:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `entry\\syscall_user_dispatch.c`\n\n---\n\n# entry/syscall_user_dispatch.c 技术文档\n\n## 1. 文件概述\n\n`entry/syscall_user_dispatch.c` 实现了 **系统调用用户分发（Syscall User Dispatch, SUD）** 机制，该机制允许用户空间程序通过 `prctl()` 系统调用配置一个“选择器”（selector），用于在特定条件下拦截或允许系统调用的执行。当系统调用指令指针位于指定区域之外且选择器状态为“阻塞”时，内核会回滚该系统调用并向进程发送 `SIGSYS` 信号，从而实现对系统调用的细粒度控制。此功能常用于沙箱、安全监控或调试场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `trigger_sigsys(struct pt_regs *regs)`  \n  构造并强制发送 `SIGSYS` 信号，携带被拦截系统调用的详细信息（如地址、系统调用号、架构等）。\n\n- `syscall_user_dispatch(struct pt_regs *regs)`  \n  系统调用入口处的分发判断逻辑。根据当前指令指针位置和用户选择器状态决定是否拦截系统调用。\n\n- `task_set_syscall_user_dispatch(struct task_struct *task, ...)`  \n  为指定任务设置系统调用用户分发配置（开启/关闭、偏移、长度、选择器地址）。\n\n- `set_syscall_user_dispatch(...)`  \n  为当前任务设置系统调用用户分发配置的封装接口，供 `prctl()` 调用。\n\n- `syscall_user_dispatch_get_config(...)`  \n  通过 `ptrace` 获取指定任务的 SUD 配置。\n\n- `syscall_user_dispatch_set_config(...)`  \n  通过 `ptrace` 设置指定任务的 SUD 配置。\n\n### 关键数据结构\n\n- `struct syscall_user_dispatch`（定义在 `<linux/syscall_user_dispatch.h>`）  \n  存储每个任务的 SUD 配置：\n  - `selector`：指向用户空间选择器字节的指针\n  - `offset` / `len`：允许直接执行系统调用的代码区域（[offset, offset+len)）\n  - `on_dispatch`：标志位，表示当前是否处于分发拦截状态\n\n- `struct ptrace_sud_config`  \n  用于 `ptrace` 接口传递 SUD 配置的结构体，包含 `mode`、`offset`、`len` 和 `selector`。\n\n## 3. 关键实现\n\n### 系统调用拦截逻辑\n\n1. **区域检查**：若当前指令指针（`instruction_pointer(regs)`）落在 `[offset, offset + len)` 范围内，则**允许**系统调用直接执行，不进行拦截。\n2. **vdso 例外**：若系统调用来自 vDSO 中的 `sigreturn`（如 `arch_syscall_is_vdso_sigreturn()` 返回 true），则跳过拦截，避免干扰信号返回路径。\n3. **选择器读取**：若配置了 `selector`，则从用户空间读取一个字节的状态值：\n   - `SYSCALL_DISPATCH_FILTER_ALLOW`（0）：允许系统调用\n   - `SYSCALL_DISPATCH_FILTER_BLOCK`（1）：触发拦截\n   - 其他值：视为非法，发送 `SIGSYS`\n4. **拦截处理**：\n   - 设置 `on_dispatch = true`\n   - 调用 `syscall_rollback()` 回滚系统调用（恢复寄存器状态）\n   - 调用 `trigger_sigsys()` 发送 `SIGSYS` 信号\n\n### 安全与健壮性设计\n\n- **地址合法性校验**：在设置 `selector` 时使用 `access_ok(untagged_addr(selector), ...)`，确保地址可访问，并处理内存标记（如 ARM MTE）场景下调试器（tracer）与被调试进程（tracee）地址标记不一致的问题。\n- **溢出防护**：检查 `offset + len <= offset` 防止整数溢出导致无效区域。\n- **权限隔离**：`ptrace` 接口允许调试器配置其他进程的 SUD，但需具备相应权限。\n\n### 信号信息构造\n\n`trigger_sigsys()` 构造的 `siginfo_t` 包含：\n- `si_signo = SIGSYS`\n- `si_code = SYS_USER_DISPATCH`\n- `si_call_addr`：触发系统调用的用户空间地址\n- `si_syscall`：系统调用号\n- `si_arch`：系统调用架构（如 x86_64、AArch64）\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/prctl.h>`：定义 `PR_SYS_DISPATCH_*` 常量\n  - `<linux/syscall_user_dispatch.h>`：定义 `struct syscall_user_dispatch` 和相关常量\n  - `<asm/syscall.h>`：提供 `syscall_get_arch()`、`syscall_get_nr()` 等架构相关接口\n  - `\"common.h\"`：可能包含内核入口通用辅助函数\n- **内核子系统**：\n  - **调度器（sched）**：访问 `current` 任务结构\n  - **信号子系统（signal）**：发送 `SIGSYS` 信号\n  - **内存管理（uaccess）**：用户空间内存访问（`__get_user`, `access_ok`）\n  - **ptrace**：支持调试器配置 SUD\n  - **ELF**：可能用于架构识别（间接依赖）\n\n## 5. 使用场景\n\n- **沙箱环境**：限制应用只能在特定代码段发起系统调用，防止恶意代码绕过安全策略。\n- **动态二进制插桩（DBI）**：工具（如 Valgrind、Intel Pin）可拦截系统调用进行分析或重定向。\n- **安全监控**：监控程序可配置选择器为“阻塞”，在 `SIGSYS` 信号处理程序中记录或审查系统调用。\n- **调试与测试**：通过 `ptrace` 动态启用/禁用 SUD，用于测试系统调用拦截逻辑。\n- **W^X 策略增强**：结合代码段只读与 SUD，确保只有可信代码路径可发起系统调用。",
      "similarity": 0.6078277826309204,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 127,
          "end_line": 163,
          "content": [
            "int syscall_user_dispatch_get_config(struct task_struct *task, unsigned long size,",
            "\t\t\t\t     void __user *data)",
            "{",
            "\tstruct syscall_user_dispatch *sd = &task->syscall_dispatch;",
            "\tstruct ptrace_sud_config cfg;",
            "",
            "\tif (size != sizeof(cfg))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (test_task_syscall_work(task, SYSCALL_USER_DISPATCH))",
            "\t\tcfg.mode = PR_SYS_DISPATCH_ON;",
            "\telse",
            "\t\tcfg.mode = PR_SYS_DISPATCH_OFF;",
            "",
            "\tcfg.offset = sd->offset;",
            "\tcfg.len = sd->len;",
            "\tcfg.selector = (__u64)(uintptr_t)sd->selector;",
            "",
            "\tif (copy_to_user(data, &cfg, sizeof(cfg)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn 0;",
            "}",
            "int syscall_user_dispatch_set_config(struct task_struct *task, unsigned long size,",
            "\t\t\t\t     void __user *data)",
            "{",
            "\tstruct ptrace_sud_config cfg;",
            "",
            "\tif (size != sizeof(cfg))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (copy_from_user(&cfg, data, sizeof(cfg)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn task_set_syscall_user_dispatch(task, cfg.mode, cfg.offset, cfg.len,",
            "\t\t\t\t\t      (char __user *)(uintptr_t)cfg.selector);",
            "}"
          ],
          "function_name": "syscall_user_dispatch_get_config, syscall_user_dispatch_set_config",
          "description": "提供系统调用分发配置的获取与设置接口，通过用户态指针操作实现配置参数的双向传递",
          "similarity": 0.6348708868026733
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 20,
          "end_line": 122,
          "content": [
            "static void trigger_sigsys(struct pt_regs *regs)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGSYS;",
            "\tinfo.si_code = SYS_USER_DISPATCH;",
            "\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_arch = syscall_get_arch(current);",
            "\tinfo.si_syscall = syscall_get_nr(current, regs);",
            "",
            "\tforce_sig_info(&info);",
            "}",
            "bool syscall_user_dispatch(struct pt_regs *regs)",
            "{",
            "\tstruct syscall_user_dispatch *sd = &current->syscall_dispatch;",
            "\tchar state;",
            "",
            "\tif (likely(instruction_pointer(regs) - sd->offset < sd->len))",
            "\t\treturn false;",
            "",
            "\tif (unlikely(arch_syscall_is_vdso_sigreturn(regs)))",
            "\t\treturn false;",
            "",
            "\tif (likely(sd->selector)) {",
            "\t\t/*",
            "\t\t * access_ok() is performed once, at prctl time, when",
            "\t\t * the selector is loaded by userspace.",
            "\t\t */",
            "\t\tif (unlikely(__get_user(state, sd->selector))) {",
            "\t\t\tforce_exit_sig(SIGSEGV);",
            "\t\t\treturn true;",
            "\t\t}",
            "",
            "\t\tif (likely(state == SYSCALL_DISPATCH_FILTER_ALLOW))",
            "\t\t\treturn false;",
            "",
            "\t\tif (state != SYSCALL_DISPATCH_FILTER_BLOCK) {",
            "\t\t\tforce_exit_sig(SIGSYS);",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\tsd->on_dispatch = true;",
            "\tsyscall_rollback(current, regs);",
            "\ttrigger_sigsys(regs);",
            "",
            "\treturn true;",
            "}",
            "static int task_set_syscall_user_dispatch(struct task_struct *task, unsigned long mode,",
            "\t\t\t\t\t  unsigned long offset, unsigned long len,",
            "\t\t\t\t\t  char __user *selector)",
            "{",
            "\tswitch (mode) {",
            "\tcase PR_SYS_DISPATCH_OFF:",
            "\t\tif (offset || len || selector)",
            "\t\t\treturn -EINVAL;",
            "\t\tbreak;",
            "\tcase PR_SYS_DISPATCH_ON:",
            "\t\t/*",
            "\t\t * Validate the direct dispatcher region just for basic",
            "\t\t * sanity against overflow and a 0-sized dispatcher",
            "\t\t * region.  If the user is able to submit a syscall from",
            "\t\t * an address, that address is obviously valid.",
            "\t\t */",
            "\t\tif (offset && offset + len <= offset)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\t/*",
            "\t\t * access_ok() will clear memory tags for tagged addresses",
            "\t\t * if current has memory tagging enabled.",
            "",
            "\t\t * To enable a tracer to set a tracees selector the",
            "\t\t * selector address must be untagged for access_ok(),",
            "\t\t * otherwise an untagged tracer will always fail to set a",
            "\t\t * tagged tracees selector.",
            "\t\t */",
            "\t\tif (selector && !access_ok(untagged_addr(selector), sizeof(*selector)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttask->syscall_dispatch.selector = selector;",
            "\ttask->syscall_dispatch.offset = offset;",
            "\ttask->syscall_dispatch.len = len;",
            "\ttask->syscall_dispatch.on_dispatch = false;",
            "",
            "\tif (mode == PR_SYS_DISPATCH_ON)",
            "\t\tset_task_syscall_work(task, SYSCALL_USER_DISPATCH);",
            "\telse",
            "\t\tclear_task_syscall_work(task, SYSCALL_USER_DISPATCH);",
            "",
            "\treturn 0;",
            "}",
            "int set_syscall_user_dispatch(unsigned long mode, unsigned long offset,",
            "\t\t\t      unsigned long len, char __user *selector)",
            "{",
            "\treturn task_set_syscall_user_dispatch(current, mode, offset, len, selector);",
            "}"
          ],
          "function_name": "trigger_sigsys, syscall_user_dispatch, task_set_syscall_user_dispatch, set_syscall_user_dispatch",
          "description": "实现系统调用用户分发核心逻辑，包含触发SIGSYS信号处理、配置验证、拦截判断及模式切换功能",
          "similarity": 0.5752797722816467
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2020 Collabora Ltd.",
            " */",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscall_user_dispatch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/signal.h>",
            "#include <linux/elf.h>",
            "",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task_stack.h>",
            "",
            "#include <asm/syscall.h>",
            "",
            "#include \"common.h\"",
            ""
          ],
          "function_name": null,
          "description": "包含系统调用用户分发功能所需头文件及通用定义，提供架构相关接口和内核调度必要声明",
          "similarity": 0.5102924108505249
        }
      ]
    },
    {
      "source_file": "kernel/user-return-notifier.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:45:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user-return-notifier.c`\n\n---\n\n# user-return-notifier.c 技术文档\n\n## 1. 文件概述\n\n`user-return-notifier.c` 实现了用户态返回通知机制（User Return Notifier），允许内核子系统在当前 CPU 即将从内核态返回用户态时注册回调函数。该机制用于在特定内核事件（如安全策略更新、性能监控等）发生后，延迟执行某些操作，直到进程真正返回用户空间，从而避免在关键内核路径中引入额外开销或竞态条件。\n\n## 2. 核心功能\n\n### 数据结构\n- `return_notifier_list`：每 CPU 变量（per-CPU variable），类型为 `struct hlist_head`，用于存储当前 CPU 上注册的所有用户返回通知器链表。\n\n### 主要函数\n- `user_return_notifier_register(struct user_return_notifier *urn)`  \n  注册一个用户返回通知器，将其加入当前 CPU 的通知链表，并设置当前任务的 `TIF_USER_RETURN_NOTIFY` 标志位。\n\n- `user_return_notifier_unregister(struct user_return_notifier *urn)`  \n  从当前 CPU 的通知链表中移除指定的通知器；若链表变为空，则清除当前任务的 `TIF_USER_RETURN_NOTIFY` 标志位。\n\n- `fire_user_return_notifiers(void)`  \n  遍历并调用当前 CPU 上所有已注册的通知器的回调函数 `on_user_return`，通常在内核即将返回用户态前由调度或系统调用退出路径调用。\n\n## 3. 关键实现\n\n- **每 CPU 链表设计**：使用 `DEFINE_PER_CPU` 定义 per-CPU 的哈希链表头，确保每个 CPU 维护独立的通知器列表，避免跨 CPU 同步开销。\n  \n- **原子上下文要求**：注册和注销操作必须在原子上下文中执行（不可睡眠），因为它们操作 per-CPU 数据且可能在中断或调度关键路径中被调用。\n\n- **线程标志位控制**：通过设置/清除任务结构体中的 `TIF_USER_RETURN_NOTIFY` 标志位（`TIF_` 表示 Thread Info Flag），通知内核在返回用户态前需调用 `fire_user_return_notifiers()`。\n\n- **安全遍历与调用**：`fire_user_return_notifiers()` 使用 `hlist_for_each_entry_safe` 安全遍历链表，允许回调函数在执行过程中注销自身或其他通知器。\n\n- **CPU 变量访问**：使用 `get_cpu_var()` 和 `put_cpu_var()` 保证在访问 per-CPU 变量期间禁止内核抢占，确保操作的 CPU 一致性。\n\n## 4. 依赖关系\n\n- `<linux/user-return-notifier.h>`：定义 `struct user_return_notifier` 及相关 API。\n- `<linux/percpu.h>`：提供 per-CPU 变量支持。\n- `<linux/sched.h>`：提供任务结构体（`current`）和线程标志位操作函数（如 `set_tsk_thread_flag`）。\n- `<linux/export.h>`：导出符号供其他内核模块使用（`EXPORT_SYMBOL_GPL`）。\n- 依赖架构相关的线程信息标志（`TIF_USER_RETURN_NOTIFY`）在 `thread_info` 中的定义。\n\n## 5. 使用场景\n\n- **安全模块**：如 SELinux 或 LSM 框架在策略更新后，需通知用户态进程重新评估权限，可延迟到返回用户态时触发。\n- **性能监控与跟踪**：在系统调用或中断处理完成后，于返回用户态前收集上下文切换或延迟信息。\n- **延迟工作调度**：某些不适合在中断或原子上下文中执行的操作，可注册为用户返回通知，在安全的用户态切换点执行。\n- **虚拟化与容器**：在客户机或容器退出内核时同步状态或注入事件。\n\n该机制是内核“延迟通知”模式的典型实现，确保高优先级内核路径不受回调逻辑影响，同时保证通知在正确的执行上下文中触发。",
      "similarity": 0.6034437417984009,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/user-return-notifier.c",
          "start_line": 15,
          "end_line": 36,
          "content": [
            "void user_return_notifier_register(struct user_return_notifier *urn)",
            "{",
            "\tset_tsk_thread_flag(current, TIF_USER_RETURN_NOTIFY);",
            "\thlist_add_head(&urn->link, this_cpu_ptr(&return_notifier_list));",
            "}",
            "void user_return_notifier_unregister(struct user_return_notifier *urn)",
            "{",
            "\thlist_del(&urn->link);",
            "\tif (hlist_empty(this_cpu_ptr(&return_notifier_list)))",
            "\t\tclear_tsk_thread_flag(current, TIF_USER_RETURN_NOTIFY);",
            "}",
            "void fire_user_return_notifiers(void)",
            "{",
            "\tstruct user_return_notifier *urn;",
            "\tstruct hlist_node *tmp2;",
            "\tstruct hlist_head *head;",
            "",
            "\thead = &get_cpu_var(return_notifier_list);",
            "\thlist_for_each_entry_safe(urn, tmp2, head, link)",
            "\t\turn->on_user_return(urn);",
            "\tput_cpu_var(return_notifier_list);",
            "}"
          ],
          "function_name": "user_return_notifier_register, user_return_notifier_unregister, fire_user_return_notifiers",
          "description": "实现用户态返回通知器的注册/注销与触发机制。register 函数将通知器链接到当前 CPU 的链表并设置 TIF_USER_RETURN_NOTIFY 标志；unregister 函数移除节点并清理标志；fire 函数遍历当前 CPU 链表执行所有注册的 on_user_return 回调函数。",
          "similarity": 0.5517188906669617
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/user-return-notifier.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "",
            "static DEFINE_PER_CPU(struct hlist_head, return_notifier_list);",
            "",
            "/*",
            " * Request a notification when the current cpu returns to userspace.  Must be",
            " * called in atomic context.  The notifier will also be called in atomic",
            " * context.",
            " */"
          ],
          "function_name": null,
          "description": "定义了一个 per-CPU 的哈希列表头结构 return_notifier_list，用于存储用户态返回通知器注册项。该结构通过 DEFINE_PER_CPU 宏为每个 CPU 创建独立的链表头，支持多 CPU 环境下的并发访问。",
          "similarity": 0.4952230453491211
        }
      ]
    },
    {
      "source_file": "kernel/params.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:15:19\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `params.c`\n\n---\n\n# params.c 技术文档\n\n## 1. 文件概述\n\n`params.c` 是 Linux 内核中用于解析内核命令行参数（kernel command line）和模块参数（module parameters）的核心辅助文件。它提供了一套通用的参数解析框架，支持从字符串形式的参数值转换为内核内部数据类型，并允许注册自定义参数处理函数。该文件实现了参数的设置、获取、内存管理、安全检查以及未知参数的回调处理机制，是内核启动参数和模块参数系统的基础组件。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `parameq(const char *a, const char *b)` / `parameqn(...)`：比较两个参数名是否相等，将 `-` 视为 `_`（兼容命令行习惯）。\n- `parse_one(...)`：解析单个参数（如 `foo=bar`），在参数表中查找匹配项并调用其 `set` 操作。\n- `parse_args(...)`：解析完整的参数字符串（如 `\"foo=bar,baz=1\"`），按逗号或空格分隔，逐个调用 `parse_one`。\n- `param_set_*` / `param_get_*` 系列函数：为标准数据类型（byte、int、ulong 等）提供参数设置和获取操作。\n- `param_set_charp` / `param_get_charp` / `param_free_charp`：处理字符串类型参数，支持动态内存分配与释放。\n- `param_set_bool` / `param_get_bool`：处理布尔类型参数，支持 `y/n/Y/N/0/1` 等输入格式。\n- `param_check_unsafe(...)`：检查参数是否为“危险”或“硬件相关”，并在安全锁定（lockdown）模式下限制访问。\n\n### 主要数据结构\n\n- `struct kernel_param`：描述一个内核参数，包含名称、操作函数集（`ops`）、参数地址（`arg`）、所属模块（`mod`）和安全标志（`flags`）。\n- `struct kernel_param_ops`：定义参数的操作接口，包括 `set`（设置）、`get`（获取）和可选的 `free`（释放）函数。\n- `struct kmalloced_param`：用于跟踪通过 `kmalloc` 分配的字符串参数内存，便于统一释放。\n\n### 宏定义\n\n- `STANDARD_PARAM_DEF(name, type, format, strtolfn)`：用于快速定义标准类型参数的 `set`/`get` 函数和 `ops` 结构体。\n\n## 3. 关键实现\n\n### 参数名等价处理\n函数 `dash2underscore()` 将连字符 `-` 转换为下划线 `_`，使得命令行中 `foo-bar=1` 可以匹配内核中名为 `foo_bar` 的参数，提升用户友好性。\n\n### 内存管理机制\n对于字符串参数（`charp` 类型），使用 `kmalloced_param` 链表跟踪所有动态分配的内存。在早期启动阶段（slab 分配器不可用时），直接使用命令行字符串指针；后期则分配新内存并复制内容。`maybe_kfree_parameter()` 在参数重设或模块卸载时安全释放内存。\n\n### 并发与锁机制\n在 `CONFIG_SYSFS` 启用时，使用互斥锁（`param_lock` 或模块私有 `param_lock`）保护参数设置操作，防止并发修改。`check_kparam_locked()` 在调试模式下验证锁状态。\n\n### 安全限制\n通过 `param_check_unsafe()` 检查参数标志：\n- 若参数标记为 `KERNEL_PARAM_FL_HWPARAM` 且系统处于 `LOCKDOWN_MODULE_PARAMETERS` 锁定状态，则拒绝设置（返回 `-EPERM`）。\n- 若参数标记为 `KERNEL_PARAM_FL_UNSAFE`，则设置时打印警告并污染内核（`add_taint(TAINT_USER)`）。\n\n### 参数解析流程\n`parse_args()` 使用 `next_arg()` 拆分参数字符串，对每个 `param=val` 调用 `parse_one()`。若未找到匹配参数且提供了 `unknown` 回调，则交由回调处理；否则报错。支持以 `--` 终止解析。\n\n### 标准类型支持\n通过 `STANDARD_PARAM_DEF` 宏自动生成多种整数类型（byte/short/int/long/ulong/ullong/hexint）的参数操作函数，统一使用 `kstrto*` 系列函数进行字符串到数值的转换。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/kernel.h>`：基础内核 API\n  - `<linux/kstrtox.h>`：字符串转数值函数（`kstrtoull` 等）\n  - `<linux/module.h>` / `<linux/moduleparam.h>`：模块参数相关定义\n  - `<linux/security.h>`：安全锁定（lockdown）检查\n  - `<linux/slab.h>`：内存分配（`kmalloc`/`kfree`）\n  - `<linux/ctype.h>`：字符处理（`skip_spaces` 等）\n\n- **配置依赖**：\n  - `CONFIG_SYSFS`：启用参数锁机制\n  - `CONFIG_MODULES`：区分内置参数与模块参数的锁\n\n- **导出符号**：\n  - 所有 `param_set_*`、`param_get_*`、`param_ops_*` 均通过 `EXPORT_SYMBOL` 导出，供模块使用。\n  - `param_set_uint_minmax` 通过 `EXPORT_SYMBOL_GPL` 导出，用于带范围检查的无符号整数参数。\n\n## 5. 使用场景\n\n- **内核启动参数解析**：在 `start_kernel()` 阶段，通过 `parse_args()` 解析 `boot_command_line`，设置内核全局变量（如 `initcall_debug`、`loglevel` 等）。\n- **内核模块参数处理**：模块加载时（`init_module` 系统调用），解析用户传入的参数字符串，调用对应参数的 `set` 函数初始化模块变量。\n- **sysfs 参数接口**：当 `CONFIG_SYSFS` 启用时，模块参数会暴露在 `/sys/module/<modname>/parameters/` 下，读写操作分别调用 `get` 和 `set` 函数。\n- **动态参数调整**：运行时可通过 `sysfs` 或 `modprobe` 修改模块参数值，触发 `param_set_*` 函数执行。\n- **安全敏感系统**：在启用了内核锁定（lockdown）的系统中，阻止用户空间修改关键硬件参数，增强系统安全性。",
      "similarity": 0.6002713441848755,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/params.c",
          "start_line": 463,
          "end_line": 621,
          "content": [
            "static int param_array_set(const char *val, const struct kernel_param *kp)",
            "{",
            "\tconst struct kparam_array *arr = kp->arr;",
            "\tunsigned int temp_num;",
            "",
            "\treturn param_array(kp->mod, kp->name, val, 1, arr->max, arr->elem,",
            "\t\t\t   arr->elemsize, arr->ops->set, kp->level,",
            "\t\t\t   arr->num ?: &temp_num);",
            "}",
            "static int param_array_get(char *buffer, const struct kernel_param *kp)",
            "{",
            "\tint i, off, ret;",
            "\tconst struct kparam_array *arr = kp->arr;",
            "\tstruct kernel_param p = *kp;",
            "",
            "\tfor (i = off = 0; i < (arr->num ? *arr->num : arr->max); i++) {",
            "\t\t/* Replace \\n with comma */",
            "\t\tif (i)",
            "\t\t\tbuffer[off - 1] = ',';",
            "\t\tp.arg = arr->elem + arr->elemsize * i;",
            "\t\tcheck_kparam_locked(p.mod);",
            "\t\tret = arr->ops->get(buffer + off, &p);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t\toff += ret;",
            "\t}",
            "\tbuffer[off] = '\\0';",
            "\treturn off;",
            "}",
            "static void param_array_free(void *arg)",
            "{",
            "\tunsigned int i;",
            "\tconst struct kparam_array *arr = arg;",
            "",
            "\tif (arr->ops->free)",
            "\t\tfor (i = 0; i < (arr->num ? *arr->num : arr->max); i++)",
            "\t\t\tarr->ops->free(arr->elem + arr->elemsize * i);",
            "}",
            "int param_set_copystring(const char *val, const struct kernel_param *kp)",
            "{",
            "\tconst struct kparam_string *kps = kp->str;",
            "",
            "\tif (strlen(val)+1 > kps->maxlen) {",
            "\t\tpr_err(\"%s: string doesn't fit in %u chars.\\n\",",
            "\t\t       kp->name, kps->maxlen-1);",
            "\t\treturn -ENOSPC;",
            "\t}",
            "\tstrcpy(kps->string, val);",
            "\treturn 0;",
            "}",
            "int param_get_string(char *buffer, const struct kernel_param *kp)",
            "{",
            "\tconst struct kparam_string *kps = kp->str;",
            "\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", kps->string);",
            "}",
            "static ssize_t param_attr_show(struct module_attribute *mattr,",
            "\t\t\t       struct module_kobject *mk, char *buf)",
            "{",
            "\tint count;",
            "\tstruct param_attribute *attribute = to_param_attr(mattr);",
            "",
            "\tif (!attribute->param->ops->get)",
            "\t\treturn -EPERM;",
            "",
            "\tkernel_param_lock(mk->mod);",
            "\tcount = attribute->param->ops->get(buf, attribute->param);",
            "\tkernel_param_unlock(mk->mod);",
            "\treturn count;",
            "}",
            "static ssize_t param_attr_store(struct module_attribute *mattr,",
            "\t\t\t\tstruct module_kobject *mk,",
            "\t\t\t\tconst char *buf, size_t len)",
            "{",
            " \tint err;",
            "\tstruct param_attribute *attribute = to_param_attr(mattr);",
            "",
            "\tif (!attribute->param->ops->set)",
            "\t\treturn -EPERM;",
            "",
            "\tkernel_param_lock(mk->mod);",
            "\tif (param_check_unsafe(attribute->param))",
            "\t\terr = attribute->param->ops->set(buf, attribute->param);",
            "\telse",
            "\t\terr = -EPERM;",
            "\tkernel_param_unlock(mk->mod);",
            "\tif (!err)",
            "\t\treturn len;",
            "\treturn err;",
            "}",
            "void kernel_param_lock(struct module *mod)",
            "{",
            "\tmutex_lock(KPARAM_MUTEX(mod));",
            "}",
            "void kernel_param_unlock(struct module *mod)",
            "{",
            "\tmutex_unlock(KPARAM_MUTEX(mod));",
            "}",
            "static __modinit int add_sysfs_param(struct module_kobject *mk,",
            "\t\t\t\t     const struct kernel_param *kp,",
            "\t\t\t\t     const char *name)",
            "{",
            "\tstruct module_param_attrs *new_mp;",
            "\tstruct attribute **new_attrs;",
            "\tunsigned int i;",
            "",
            "\t/* We don't bother calling this with invisible parameters. */",
            "\tBUG_ON(!kp->perm);",
            "",
            "\tif (!mk->mp) {",
            "\t\t/* First allocation. */",
            "\t\tmk->mp = kzalloc(sizeof(*mk->mp), GFP_KERNEL);",
            "\t\tif (!mk->mp)",
            "\t\t\treturn -ENOMEM;",
            "\t\tmk->mp->grp.name = \"parameters\";",
            "\t\t/* NULL-terminated attribute array. */",
            "\t\tmk->mp->grp.attrs = kzalloc(sizeof(mk->mp->grp.attrs[0]),",
            "\t\t\t\t\t    GFP_KERNEL);",
            "\t\t/* Caller will cleanup via free_module_param_attrs */",
            "\t\tif (!mk->mp->grp.attrs)",
            "\t\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\t/* Enlarge allocations. */",
            "\tnew_mp = krealloc(mk->mp,",
            "\t\t\t  sizeof(*mk->mp) +",
            "\t\t\t  sizeof(mk->mp->attrs[0]) * (mk->mp->num + 1),",
            "\t\t\t  GFP_KERNEL);",
            "\tif (!new_mp)",
            "\t\treturn -ENOMEM;",
            "\tmk->mp = new_mp;",
            "",
            "\t/* Extra pointer for NULL terminator */",
            "\tnew_attrs = krealloc(mk->mp->grp.attrs,",
            "\t\t\t     sizeof(mk->mp->grp.attrs[0]) * (mk->mp->num + 2),",
            "\t\t\t     GFP_KERNEL);",
            "\tif (!new_attrs)",
            "\t\treturn -ENOMEM;",
            "\tmk->mp->grp.attrs = new_attrs;",
            "",
            "\t/* Tack new one on the end. */",
            "\tmemset(&mk->mp->attrs[mk->mp->num], 0, sizeof(mk->mp->attrs[0]));",
            "\tsysfs_attr_init(&mk->mp->attrs[mk->mp->num].mattr.attr);",
            "\tmk->mp->attrs[mk->mp->num].param = kp;",
            "\tmk->mp->attrs[mk->mp->num].mattr.show = param_attr_show;",
            "\t/* Do not allow runtime DAC changes to make param writable. */",
            "\tif ((kp->perm & (S_IWUSR | S_IWGRP | S_IWOTH)) != 0)",
            "\t\tmk->mp->attrs[mk->mp->num].mattr.store = param_attr_store;",
            "\telse",
            "\t\tmk->mp->attrs[mk->mp->num].mattr.store = NULL;",
            "\tmk->mp->attrs[mk->mp->num].mattr.attr.name = (char *)name;",
            "\tmk->mp->attrs[mk->mp->num].mattr.attr.mode = kp->perm;",
            "\tmk->mp->num++;",
            "",
            "\t/* Fix up all the pointers, since krealloc can move us */",
            "\tfor (i = 0; i < mk->mp->num; i++)",
            "\t\tmk->mp->grp.attrs[i] = &mk->mp->attrs[i].mattr.attr;",
            "\tmk->mp->grp.attrs[mk->mp->num] = NULL;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "param_array_set, param_array_get, param_array_free, param_set_copystring, param_get_string, param_attr_show, param_attr_store, kernel_param_lock, kernel_param_unlock, add_sysfs_param",
          "description": "实现sysfs接口参数暴露机制，包含参数属性展示/存储方法、数组参数处理、字符串拷贝等操作，支持模块参数的动态配置与监控。",
          "similarity": 0.5633357167243958
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/params.c",
          "start_line": 1,
          "end_line": 28,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/* Helpers for initial module or kernel cmdline parsing",
            "   Copyright (C) 2001 Rusty Russell.",
            "",
            "*/",
            "#include <linux/kernel.h>",
            "#include <linux/kstrtox.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/device.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "",
            "#ifdef CONFIG_SYSFS",
            "/* Protects all built-in parameters, modules use their own param_lock */",
            "static DEFINE_MUTEX(param_lock);",
            "",
            "/* Use the module's mutex, or if built-in use the built-in mutex */",
            "#ifdef CONFIG_MODULES",
            "#define KPARAM_MUTEX(mod)\t((mod) ? &(mod)->param_lock : &param_lock)",
            "#else",
            "#define KPARAM_MUTEX(mod)\t(&param_lock)",
            "#endif",
            ""
          ],
          "function_name": null,
          "description": "定义模块参数的互斥锁机制，用于保护内核参数在模块加载/卸载期间的并发访问，根据是否启用模块动态加载选择不同的锁对象。",
          "similarity": 0.5553188323974609
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/params.c",
          "start_line": 265,
          "end_line": 406,
          "content": [
            "int param_set_charp(const char *val, const struct kernel_param *kp)",
            "{",
            "\tif (strlen(val) > 1024) {",
            "\t\tpr_err(\"%s: string parameter too long\\n\", kp->name);",
            "\t\treturn -ENOSPC;",
            "\t}",
            "",
            "\tmaybe_kfree_parameter(*(char **)kp->arg);",
            "",
            "\t/* This is a hack.  We can't kmalloc in early boot, and we",
            "\t * don't need to; this mangled commandline is preserved. */",
            "\tif (slab_is_available()) {",
            "\t\t*(char **)kp->arg = kmalloc_parameter(strlen(val)+1);",
            "\t\tif (!*(char **)kp->arg)",
            "\t\t\treturn -ENOMEM;",
            "\t\tstrcpy(*(char **)kp->arg, val);",
            "\t} else",
            "\t\t*(const char **)kp->arg = val;",
            "",
            "\treturn 0;",
            "}",
            "int param_get_charp(char *buffer, const struct kernel_param *kp)",
            "{",
            "\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", *((char **)kp->arg));",
            "}",
            "void param_free_charp(void *arg)",
            "{",
            "\tmaybe_kfree_parameter(*((char **)arg));",
            "}",
            "int param_set_bool(const char *val, const struct kernel_param *kp)",
            "{",
            "\t/* No equals means \"set\"... */",
            "\tif (!val) val = \"1\";",
            "",
            "\t/* One of =[yYnN01] */",
            "\treturn kstrtobool(val, kp->arg);",
            "}",
            "int param_get_bool(char *buffer, const struct kernel_param *kp)",
            "{",
            "\t/* Y and N chosen as being relatively non-coder friendly */",
            "\treturn sprintf(buffer, \"%c\\n\", *(bool *)kp->arg ? 'Y' : 'N');",
            "}",
            "int param_set_bool_enable_only(const char *val, const struct kernel_param *kp)",
            "{",
            "\tint err;",
            "\tbool new_value;",
            "\tbool orig_value = *(bool *)kp->arg;",
            "\tstruct kernel_param dummy_kp = *kp;",
            "",
            "\tdummy_kp.arg = &new_value;",
            "",
            "\terr = param_set_bool(val, &dummy_kp);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\t/* Don't let them unset it once it's set! */",
            "\tif (!new_value && orig_value)",
            "\t\treturn -EROFS;",
            "",
            "\tif (new_value)",
            "\t\terr = param_set_bool(val, kp);",
            "",
            "\treturn err;",
            "}",
            "int param_set_invbool(const char *val, const struct kernel_param *kp)",
            "{",
            "\tint ret;",
            "\tbool boolval;",
            "\tstruct kernel_param dummy;",
            "",
            "\tdummy.arg = &boolval;",
            "\tret = param_set_bool(val, &dummy);",
            "\tif (ret == 0)",
            "\t\t*(bool *)kp->arg = !boolval;",
            "\treturn ret;",
            "}",
            "int param_get_invbool(char *buffer, const struct kernel_param *kp)",
            "{",
            "\treturn sprintf(buffer, \"%c\\n\", (*(bool *)kp->arg) ? 'N' : 'Y');",
            "}",
            "int param_set_bint(const char *val, const struct kernel_param *kp)",
            "{",
            "\t/* Match bool exactly, by re-using it. */",
            "\tstruct kernel_param boolkp = *kp;",
            "\tbool v;",
            "\tint ret;",
            "",
            "\tboolkp.arg = &v;",
            "",
            "\tret = param_set_bool(val, &boolkp);",
            "\tif (ret == 0)",
            "\t\t*(int *)kp->arg = v;",
            "\treturn ret;",
            "}",
            "static int param_array(struct module *mod,",
            "\t\t       const char *name,",
            "\t\t       const char *val,",
            "\t\t       unsigned int min, unsigned int max,",
            "\t\t       void *elem, int elemsize,",
            "\t\t       int (*set)(const char *, const struct kernel_param *kp),",
            "\t\t       s16 level,",
            "\t\t       unsigned int *num)",
            "{",
            "\tint ret;",
            "\tstruct kernel_param kp;",
            "\tchar save;",
            "",
            "\t/* Get the name right for errors. */",
            "\tkp.name = name;",
            "\tkp.arg = elem;",
            "\tkp.level = level;",
            "",
            "\t*num = 0;",
            "\t/* We expect a comma-separated list of values. */",
            "\tdo {",
            "\t\tint len;",
            "",
            "\t\tif (*num == max) {",
            "\t\t\tpr_err(\"%s: can only take %i arguments\\n\", name, max);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t\tlen = strcspn(val, \",\");",
            "",
            "\t\t/* nul-terminate and parse */",
            "\t\tsave = val[len];",
            "\t\t((char *)val)[len] = '\\0';",
            "\t\tcheck_kparam_locked(mod);",
            "\t\tret = set(val, &kp);",
            "",
            "\t\tif (ret != 0)",
            "\t\t\treturn ret;",
            "\t\tkp.arg += elemsize;",
            "\t\tval += len+1;",
            "\t\t(*num)++;",
            "\t} while (save == ',');",
            "",
            "\tif (*num < min) {",
            "\t\tpr_err(\"%s: needs at least %i arguments\\n\", name, min);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "param_set_charp, param_get_charp, param_free_charp, param_set_bool, param_get_bool, param_set_bool_enable_only, param_set_invbool, param_get_invbool, param_set_bint, param_array",
          "description": "提供特定参数类型的处理实现，包括字符串参数分配、布尔值转换、数组参数处理等，包含内存管理、格式化输出等辅助功能。",
          "similarity": 0.544463574886322
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/params.c",
          "start_line": 868,
          "end_line": 955,
          "content": [
            "static void __init version_sysfs_builtin(void)",
            "{",
            "\tconst struct module_version_attribute *vattr;",
            "\tstruct module_kobject *mk;",
            "\tint err;",
            "",
            "\tfor (vattr = __start___modver; vattr < __stop___modver; vattr++) {",
            "\t\tmk = lookup_or_create_module_kobject(vattr->module_name);",
            "\t\tif (mk) {",
            "\t\t\terr = sysfs_create_file(&mk->kobj, &vattr->mattr.attr);",
            "\t\t\tWARN_ON_ONCE(err);",
            "\t\t\tkobject_uevent(&mk->kobj, KOBJ_ADD);",
            "\t\t\tkobject_put(&mk->kobj);",
            "\t\t}",
            "\t}",
            "}",
            "static ssize_t module_attr_show(struct kobject *kobj,",
            "\t\t\t\tstruct attribute *attr,",
            "\t\t\t\tchar *buf)",
            "{",
            "\tstruct module_attribute *attribute;",
            "\tstruct module_kobject *mk;",
            "\tint ret;",
            "",
            "\tattribute = to_module_attr(attr);",
            "\tmk = to_module_kobject(kobj);",
            "",
            "\tif (!attribute->show)",
            "\t\treturn -EIO;",
            "",
            "\tret = attribute->show(attribute, mk, buf);",
            "",
            "\treturn ret;",
            "}",
            "static ssize_t module_attr_store(struct kobject *kobj,",
            "\t\t\t\tstruct attribute *attr,",
            "\t\t\t\tconst char *buf, size_t len)",
            "{",
            "\tstruct module_attribute *attribute;",
            "\tstruct module_kobject *mk;",
            "\tint ret;",
            "",
            "\tattribute = to_module_attr(attr);",
            "\tmk = to_module_kobject(kobj);",
            "",
            "\tif (!attribute->store)",
            "\t\treturn -EIO;",
            "",
            "\tret = attribute->store(attribute, mk, buf, len);",
            "",
            "\treturn ret;",
            "}",
            "static int uevent_filter(const struct kobject *kobj)",
            "{",
            "\tconst struct kobj_type *ktype = get_ktype(kobj);",
            "",
            "\tif (ktype == &module_ktype)",
            "\t\treturn 1;",
            "\treturn 0;",
            "}",
            "static void module_kobj_release(struct kobject *kobj)",
            "{",
            "\tstruct module_kobject *mk = to_module_kobject(kobj);",
            "",
            "\tif (mk->kobj_completion)",
            "\t\tcomplete(mk->kobj_completion);",
            "}",
            "static int __init param_sysfs_init(void)",
            "{",
            "\tmodule_kset = kset_create_and_add(\"module\", &module_uevent_ops, NULL);",
            "\tif (!module_kset) {",
            "\t\tprintk(KERN_WARNING \"%s (%d): error creating kset\\n\",",
            "\t\t\t__FILE__, __LINE__);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __init param_sysfs_builtin_init(void)",
            "{",
            "\tif (!module_kset)",
            "\t\treturn -ENOMEM;",
            "",
            "\tversion_sysfs_builtin();",
            "\tparam_sysfs_builtin();",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "version_sysfs_builtin, module_attr_show, module_attr_store, uevent_filter, module_kobj_release, param_sysfs_init, param_sysfs_builtin_init",
          "description": "该代码段主要实现模块参数的SysFS接口初始化与管理，包含以下功能：  \n1. `version_sysfs_builtin` 初始化模块版本属性到SysFS，创建对应文件并触发设备添加事件；  \n2. `module_attr_show/store` 定义模块属性的通用读写接口，通过回调函数实现具体逻辑；  \n3. `param_sysfs_init` 创建模块KSet并注册UEVENT过滤规则，`param_sysfs_builtin_init` 统一调用版本相关初始化函数。",
          "similarity": 0.5434603691101074
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/params.c",
          "start_line": 690,
          "end_line": 795,
          "content": [
            "static void free_module_param_attrs(struct module_kobject *mk)",
            "{",
            "\tif (mk->mp)",
            "\t\tkfree(mk->mp->grp.attrs);",
            "\tkfree(mk->mp);",
            "\tmk->mp = NULL;",
            "}",
            "int module_param_sysfs_setup(struct module *mod,",
            "\t\t\t     const struct kernel_param *kparam,",
            "\t\t\t     unsigned int num_params)",
            "{",
            "\tint i, err;",
            "\tbool params = false;",
            "",
            "\tfor (i = 0; i < num_params; i++) {",
            "\t\tif (kparam[i].perm == 0)",
            "\t\t\tcontinue;",
            "\t\terr = add_sysfs_param(&mod->mkobj, &kparam[i], kparam[i].name);",
            "\t\tif (err) {",
            "\t\t\tfree_module_param_attrs(&mod->mkobj);",
            "\t\t\treturn err;",
            "\t\t}",
            "\t\tparams = true;",
            "\t}",
            "",
            "\tif (!params)",
            "\t\treturn 0;",
            "",
            "\t/* Create the param group. */",
            "\terr = sysfs_create_group(&mod->mkobj.kobj, &mod->mkobj.mp->grp);",
            "\tif (err)",
            "\t\tfree_module_param_attrs(&mod->mkobj);",
            "\treturn err;",
            "}",
            "void module_param_sysfs_remove(struct module *mod)",
            "{",
            "\tif (mod->mkobj.mp) {",
            "\t\tsysfs_remove_group(&mod->mkobj.kobj, &mod->mkobj.mp->grp);",
            "\t\t/* We are positive that no one is using any param",
            "\t\t * attrs at this point.  Deallocate immediately. */",
            "\t\tfree_module_param_attrs(&mod->mkobj);",
            "\t}",
            "}",
            "void destroy_params(const struct kernel_param *params, unsigned num)",
            "{",
            "\tunsigned int i;",
            "",
            "\tfor (i = 0; i < num; i++)",
            "\t\tif (params[i].ops->free)",
            "\t\t\tparams[i].ops->free(params[i].arg);",
            "}",
            "static void __init kernel_add_sysfs_param(const char *name,",
            "\t\t\t\t\t  const struct kernel_param *kparam,",
            "\t\t\t\t\t  unsigned int name_skip)",
            "{",
            "\tstruct module_kobject *mk;",
            "\tint err;",
            "",
            "\tmk = lookup_or_create_module_kobject(name);",
            "\tif (!mk)",
            "\t\treturn;",
            "",
            "\t/* We need to remove old parameters before adding more. */",
            "\tif (mk->mp)",
            "\t\tsysfs_remove_group(&mk->kobj, &mk->mp->grp);",
            "",
            "\t/* These should not fail at boot. */",
            "\terr = add_sysfs_param(mk, kparam, kparam->name + name_skip);",
            "\tBUG_ON(err);",
            "\terr = sysfs_create_group(&mk->kobj, &mk->mp->grp);",
            "\tBUG_ON(err);",
            "\tkobject_uevent(&mk->kobj, KOBJ_ADD);",
            "\tkobject_put(&mk->kobj);",
            "}",
            "static void __init param_sysfs_builtin(void)",
            "{",
            "\tconst struct kernel_param *kp;",
            "\tunsigned int name_len;",
            "\tchar modname[MODULE_NAME_LEN];",
            "",
            "\tfor (kp = __start___param; kp < __stop___param; kp++) {",
            "\t\tchar *dot;",
            "",
            "\t\tif (kp->perm == 0)",
            "\t\t\tcontinue;",
            "",
            "\t\tdot = strchr(kp->name, '.');",
            "\t\tif (!dot) {",
            "\t\t\t/* This happens for core_param() */",
            "\t\t\tstrcpy(modname, \"kernel\");",
            "\t\t\tname_len = 0;",
            "\t\t} else {",
            "\t\t\tname_len = dot - kp->name + 1;",
            "\t\t\tstrscpy(modname, kp->name, name_len);",
            "\t\t}",
            "\t\tkernel_add_sysfs_param(modname, kp, name_len);",
            "\t}",
            "}",
            "ssize_t __modver_version_show(struct module_attribute *mattr,",
            "\t\t\t      struct module_kobject *mk, char *buf)",
            "{",
            "\tstruct module_version_attribute *vattr =",
            "\t\tcontainer_of(mattr, struct module_version_attribute, mattr);",
            "",
            "\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", vattr->version);",
            "}"
          ],
          "function_name": "free_module_param_attrs, module_param_sysfs_setup, module_param_sysfs_remove, destroy_params, kernel_add_sysfs_param, param_sysfs_builtin, __modver_version_show",
          "description": "管理模块参数的sysfs节点生命周期，包含参数组创建/移除、参数释放、内核内置参数注册等基础设施，负责模块参数的系统级集成。",
          "similarity": 0.5406784415245056
        }
      ]
    }
  ]
}