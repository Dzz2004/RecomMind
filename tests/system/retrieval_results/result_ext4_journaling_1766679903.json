{
  "query": "ext4 journaling",
  "timestamp": "2025-12-26 00:25:03",
  "retrieved_files": [
    {
      "source_file": "kernel/trace/ring_buffer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:07:21\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\ring_buffer.c`\n\n---\n\n# `trace/ring_buffer.c` 技术文档\n\n## 1. 文件概述\n\n`trace/ring_buffer.c` 实现了 Linux 内核中通用的高性能环形缓冲区（ring buffer）机制，主要用于跟踪（tracing）子系统。该缓冲区支持多 CPU 并发写入、单读者或多读者无锁读取，并通过时间戳压缩、事件类型编码和页面交换等技术优化内存使用和性能。该实现是 ftrace、perf 和其他内核跟踪工具的核心基础设施。\n\n## 2. 核心功能\n\n### 主要函数\n- `ring_buffer_print_entry_header()`：输出环形缓冲区条目头部格式说明，用于调试或用户空间解析。\n- `ring_buffer_event_length()`：返回事件有效载荷（payload）的长度，对 TIME_EXTEND 类型自动跳过扩展头。\n- `rb_event_data()`（内联）：返回指向事件实际数据的指针，处理 TIME_EXTEND 和不同长度编码。\n- `rb_event_length()`：返回完整事件结构（含头部）的字节长度。\n- `rb_event_ts_length()`：返回 TIME_EXTEND 事件及其后续数据事件的总长度。\n- `rb_event_data_length()`：计算数据类型事件的总长度（含头部）。\n- `rb_null_event()` / `rb_event_set_padding()`：判断或设置空/填充事件。\n\n### 关键数据结构（隐含或引用）\n- `struct ring_buffer_event`：环形缓冲区中每个事件的通用头部结构。\n- `struct buffer_data_page`：每个 CPU 缓冲区页面的封装，包含数据和元数据。\n- 每 CPU 页面链表：每个 CPU 拥有独立的环形页面链，写者仅写本地 CPU 缓冲区。\n\n### 核心常量与宏\n- `RINGBUF_TYPE_PADDING`、`RINGBUF_TYPE_TIME_EXTEND`、`RINGBUF_TYPE_TIME_STAMP`、`RINGBUF_TYPE_DATA`：事件类型标识。\n- `RB_ALIGNMENT` / `RB_ARCH_ALIGNMENT`：数据对齐策略，根据架构是否支持 64 位对齐访问调整。\n- `RB_MAX_SMALL_DATA`：小数据事件的最大长度（基于 4 字节对齐和类型长度上限）。\n- `TS_MSB` / `ABS_TS_MASK`：用于处理 59 位时间戳的高位截断与恢复。\n\n## 3. 关键实现\n\n### 无锁读写架构\n- **写者**：每个 CPU 只能写入其对应的 per-CPU 缓冲区，通过原子操作和内存屏障保证写入一致性，无需全局锁。\n- **读者**：每个 per-CPU 缓冲区维护一个独立的“reader page”。当 reader page 被读完后，通过原子交换（未来使用 `cmpxchg`）将其与环形缓冲区中的一个页面互换。交换后，原 reader page 不再被写者访问，读者可安全地将其用于 splice、复制或释放。\n\n### 事件编码与压缩\n- 事件头部使用紧凑位域编码：\n  - `type_len`（5 位）：事件类型或小数据长度（≤31）。\n  - `time_delta`（27 位）：相对于前一事件的时间增量。\n  - `array`（32 位）：用于存储大长度值或事件数据。\n- **TIME_EXTEND 事件**：当时间增量超出 27 位或需要绝对时间戳时，插入一个 8 字节的 TIME_EXTEND 事件，后跟实际数据事件。\n- **数据长度编码**：\n  - 若 `type_len > 0` 且 ≤ `RINGBUF_TYPE_DATA_TYPE_LEN_MAX`，则数据长度 = `type_len * RB_ALIGNMENT`，数据从 `array[0]` 开始。\n  - 否则，数据长度存储在 `array[0]`，实际数据从 `array[1]` 开始。\n\n### 时间戳处理\n- 绝对时间戳仅保留低 59 位（`ABS_TS_MASK`），高 5 位（`TS_MSB`）若非零需单独保存并在读取时恢复，以支持长时间运行的跟踪。\n\n### 内存对齐优化\n- 在支持 64 位对齐访问的架构上（`CONFIG_HAVE_64BIT_ALIGNED_ACCESS`），强制 8 字节对齐（`RB_FORCE_8BYTE_ALIGNMENT`），提升访问性能；否则使用 4 字节对齐。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/ring_buffer.h>`：定义公共 API 和数据结构。\n  - `<linux/trace_clock.h>`、`<linux/sched/clock.h>`：提供高精度时间戳源。\n  - `<linux/percpu.h>`：支持 per-CPU 缓冲区分配。\n  - `<linux/spinlock.h>`、`<asm/local.h>`：提供底层原子操作和锁原语。\n  - `<linux/trace_recursion.h>`：防止跟踪递归。\n- **子系统依赖**：\n  - **ftrace**：主要消费者，用于函数跟踪、事件跟踪等。\n  - **perf**：通过 ring buffer 获取性能事件数据。\n  - **Security Module**：通过 `<linux/security.h>` 集成 LSM 钩子（如 trace 访问控制）。\n- **架构依赖**：依赖 `CONFIG_HAVE_64BIT_ALIGNED_ACCESS` 配置项优化对齐策略。\n\n## 5. 使用场景\n\n- **内核跟踪（ftrace）**：记录函数调用、上下文切换、中断等事件，数据写入 per-CPU ring buffer，用户通过 `tracefs` 读取。\n- **性能分析（perf）**：perf 工具通过 ring buffer 接收内核采样事件（如 PMU 中断、软件事件）。\n- **实时监控与调试**：开发者或运维人员通过读取 ring buffer 内容分析系统行为、延迟或错误。\n- **自测试（selftest）**：文件包含自测试逻辑（依赖 `<linux/kthread.h>`），用于验证 ring buffer 功能正确性。\n- **低开销事件记录**：由于其无锁设计和压缩编码，适用于高频事件记录场景（如每秒百万级事件）。",
      "similarity": 0.5456413626670837,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/ring_buffer.c",
          "start_line": 357,
          "end_line": 461,
          "content": [
            "static __always_inline unsigned int rb_page_commit(struct buffer_page *bpage)",
            "{",
            "\treturn local_read(&bpage->page->commit);",
            "}",
            "static void free_buffer_page(struct buffer_page *bpage)",
            "{",
            "\tfree_page((unsigned long)bpage->page);",
            "\tkfree(bpage);",
            "}",
            "static inline bool test_time_stamp(u64 delta)",
            "{",
            "\treturn !!(delta & TS_DELTA_TEST);",
            "}",
            "int ring_buffer_print_page_header(struct trace_seq *s)",
            "{",
            "\tstruct buffer_data_page field;",
            "",
            "\ttrace_seq_printf(s, \"\\tfield: u64 timestamp;\\t\"",
            "\t\t\t \"offset:0;\\tsize:%u;\\tsigned:%u;\\n\",",
            "\t\t\t (unsigned int)sizeof(field.time_stamp),",
            "\t\t\t (unsigned int)is_signed_type(u64));",
            "",
            "\ttrace_seq_printf(s, \"\\tfield: local_t commit;\\t\"",
            "\t\t\t \"offset:%u;\\tsize:%u;\\tsigned:%u;\\n\",",
            "\t\t\t (unsigned int)offsetof(typeof(field), commit),",
            "\t\t\t (unsigned int)sizeof(field.commit),",
            "\t\t\t (unsigned int)is_signed_type(long));",
            "",
            "\ttrace_seq_printf(s, \"\\tfield: int overwrite;\\t\"",
            "\t\t\t \"offset:%u;\\tsize:%u;\\tsigned:%u;\\n\",",
            "\t\t\t (unsigned int)offsetof(typeof(field), commit),",
            "\t\t\t 1,",
            "\t\t\t (unsigned int)is_signed_type(long));",
            "",
            "\ttrace_seq_printf(s, \"\\tfield: char data;\\t\"",
            "\t\t\t \"offset:%u;\\tsize:%u;\\tsigned:%u;\\n\",",
            "\t\t\t (unsigned int)offsetof(typeof(field), data),",
            "\t\t\t (unsigned int)BUF_PAGE_SIZE,",
            "\t\t\t (unsigned int)is_signed_type(char));",
            "",
            "\treturn !trace_seq_has_overflowed(s);",
            "}",
            "static inline int rb_time_cnt(unsigned long val)",
            "{",
            "\treturn (val >> RB_TIME_SHIFT) & 3;",
            "}",
            "static inline u64 rb_time_val(unsigned long top, unsigned long bottom)",
            "{",
            "\tu64 val;",
            "",
            "\tval = top & RB_TIME_VAL_MASK;",
            "\tval <<= RB_TIME_SHIFT;",
            "\tval |= bottom & RB_TIME_VAL_MASK;",
            "",
            "\treturn val;",
            "}",
            "static inline bool __rb_time_read(rb_time_t *t, u64 *ret, unsigned long *cnt)",
            "{",
            "\tunsigned long top, bottom, msb;",
            "\tunsigned long c;",
            "",
            "\t/*",
            "\t * If the read is interrupted by a write, then the cnt will",
            "\t * be different. Loop until both top and bottom have been read",
            "\t * without interruption.",
            "\t */",
            "\tdo {",
            "\t\tc = local_read(&t->cnt);",
            "\t\ttop = local_read(&t->top);",
            "\t\tbottom = local_read(&t->bottom);",
            "\t\tmsb = local_read(&t->msb);",
            "\t} while (c != local_read(&t->cnt));",
            "",
            "\t*cnt = rb_time_cnt(top);",
            "",
            "\t/* If top, msb or bottom counts don't match, this interrupted a write */",
            "\tif (*cnt != rb_time_cnt(msb) || *cnt != rb_time_cnt(bottom))",
            "\t\treturn false;",
            "",
            "\t/* The shift to msb will lose its cnt bits */",
            "\t*ret = rb_time_val(top, bottom) | ((u64)msb << RB_TIME_MSB_SHIFT);",
            "\treturn true;",
            "}",
            "static bool rb_time_read(rb_time_t *t, u64 *ret)",
            "{",
            "\tunsigned long cnt;",
            "",
            "\treturn __rb_time_read(t, ret, &cnt);",
            "}",
            "static inline unsigned long rb_time_val_cnt(unsigned long val, unsigned long cnt)",
            "{",
            "\treturn (val & RB_TIME_VAL_MASK) | ((cnt & 3) << RB_TIME_SHIFT);",
            "}",
            "static inline void rb_time_split(u64 val, unsigned long *top, unsigned long *bottom,",
            "\t\t\t\t unsigned long *msb)",
            "{",
            "\t*top = (unsigned long)((val >> RB_TIME_SHIFT) & RB_TIME_VAL_MASK);",
            "\t*bottom = (unsigned long)(val & RB_TIME_VAL_MASK);",
            "\t*msb = (unsigned long)(val >> RB_TIME_MSB_SHIFT);",
            "}",
            "static inline void rb_time_val_set(local_t *t, unsigned long val, unsigned long cnt)",
            "{",
            "\tval = rb_time_val_cnt(val, cnt);",
            "\tlocal_set(t, val);",
            "}"
          ],
          "function_name": "rb_page_commit, free_buffer_page, test_time_stamp, ring_buffer_print_page_header, rb_time_cnt, rb_time_val, __rb_time_read, rb_time_read, rb_time_val_cnt, rb_time_split, rb_time_val_set",
          "description": "实现缓冲页提交计数器读取、页面释放、时间戳字段解析与组合操作，包含原子操作辅助函数用于安全的时间戳读写，支持多处理器环境下时间戳的精确捕获",
          "similarity": 0.5327233672142029
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/ring_buffer.c",
          "start_line": 837,
          "end_line": 965,
          "content": [
            "size_t ring_buffer_nr_pages(struct trace_buffer *buffer, int cpu)",
            "{",
            "\treturn buffer->buffers[cpu]->nr_pages;",
            "}",
            "size_t ring_buffer_nr_dirty_pages(struct trace_buffer *buffer, int cpu)",
            "{",
            "\tsize_t read;",
            "\tsize_t lost;",
            "\tsize_t cnt;",
            "",
            "\tread = local_read(&buffer->buffers[cpu]->pages_read);",
            "\tlost = local_read(&buffer->buffers[cpu]->pages_lost);",
            "\tcnt = local_read(&buffer->buffers[cpu]->pages_touched);",
            "",
            "\tif (WARN_ON_ONCE(cnt < lost))",
            "\t\treturn 0;",
            "",
            "\tcnt -= lost;",
            "",
            "\t/* The reader can read an empty page, but not more than that */",
            "\tif (cnt < read) {",
            "\t\tWARN_ON_ONCE(read > cnt + 1);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\treturn cnt - read;",
            "}",
            "static __always_inline bool full_hit(struct trace_buffer *buffer, int cpu, int full)",
            "{",
            "\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];",
            "\tsize_t nr_pages;",
            "\tsize_t dirty;",
            "",
            "\tnr_pages = cpu_buffer->nr_pages;",
            "\tif (!nr_pages || !full)",
            "\t\treturn true;",
            "",
            "\t/*",
            "\t * Add one as dirty will never equal nr_pages, as the sub-buffer",
            "\t * that the writer is on is not counted as dirty.",
            "\t * This is needed if \"buffer_percent\" is set to 100.",
            "\t */",
            "\tdirty = ring_buffer_nr_dirty_pages(buffer, cpu) + 1;",
            "",
            "\treturn (dirty * 100) >= (full * nr_pages);",
            "}",
            "static void rb_wake_up_waiters(struct irq_work *work)",
            "{",
            "\tstruct rb_irq_work *rbwork = container_of(work, struct rb_irq_work, work);",
            "",
            "\twake_up_all(&rbwork->waiters);",
            "\tif (rbwork->full_waiters_pending || rbwork->wakeup_full) {",
            "\t\t/* Only cpu_buffer sets the above flags */",
            "\t\tstruct ring_buffer_per_cpu *cpu_buffer =",
            "\t\t\tcontainer_of(rbwork, struct ring_buffer_per_cpu, irq_work);",
            "",
            "\t\t/* Called from interrupt context */",
            "\t\traw_spin_lock(&cpu_buffer->reader_lock);",
            "\t\trbwork->wakeup_full = false;",
            "\t\trbwork->full_waiters_pending = false;",
            "",
            "\t\t/* Waking up all waiters, they will reset the shortest full */",
            "\t\tcpu_buffer->shortest_full = 0;",
            "\t\traw_spin_unlock(&cpu_buffer->reader_lock);",
            "",
            "\t\twake_up_all(&rbwork->full_waiters);",
            "\t}",
            "}",
            "void ring_buffer_wake_waiters(struct trace_buffer *buffer, int cpu)",
            "{",
            "\tstruct ring_buffer_per_cpu *cpu_buffer;",
            "\tstruct rb_irq_work *rbwork;",
            "",
            "\tif (!buffer)",
            "\t\treturn;",
            "",
            "\tif (cpu == RING_BUFFER_ALL_CPUS) {",
            "",
            "\t\t/* Wake up individual ones too. One level recursion */",
            "\t\tfor_each_buffer_cpu(buffer, cpu)",
            "\t\t\tring_buffer_wake_waiters(buffer, cpu);",
            "",
            "\t\trbwork = &buffer->irq_work;",
            "\t} else {",
            "\t\tif (WARN_ON_ONCE(!buffer->buffers))",
            "\t\t\treturn;",
            "\t\tif (WARN_ON_ONCE(cpu >= nr_cpu_ids))",
            "\t\t\treturn;",
            "",
            "\t\tcpu_buffer = buffer->buffers[cpu];",
            "\t\t/* The CPU buffer may not have been initialized yet */",
            "\t\tif (!cpu_buffer)",
            "\t\t\treturn;",
            "\t\trbwork = &cpu_buffer->irq_work;",
            "\t}",
            "",
            "\t/* This can be called in any context */",
            "\tirq_work_queue(&rbwork->work);",
            "}",
            "static bool rb_watermark_hit(struct trace_buffer *buffer, int cpu, int full)",
            "{",
            "\tstruct ring_buffer_per_cpu *cpu_buffer;",
            "\tbool ret = false;",
            "",
            "\t/* Reads of all CPUs always waits for any data */",
            "\tif (cpu == RING_BUFFER_ALL_CPUS)",
            "\t\treturn !ring_buffer_empty(buffer);",
            "",
            "\tcpu_buffer = buffer->buffers[cpu];",
            "",
            "\tif (!ring_buffer_empty_cpu(buffer, cpu)) {",
            "\t\tunsigned long flags;",
            "\t\tbool pagebusy;",
            "",
            "\t\tif (!full)",
            "\t\t\treturn true;",
            "",
            "\t\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);",
            "\t\tpagebusy = cpu_buffer->reader_page == cpu_buffer->commit_page;",
            "\t\tret = !pagebusy && full_hit(buffer, cpu, full);",
            "",
            "\t\tif (!ret && (!cpu_buffer->shortest_full ||",
            "\t\t\t     cpu_buffer->shortest_full > full)) {",
            "\t\t    cpu_buffer->shortest_full = full;",
            "\t\t}",
            "\t\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);",
            "\t}",
            "\treturn ret;",
            "}"
          ],
          "function_name": "ring_buffer_nr_pages, ring_buffer_nr_dirty_pages, full_hit, rb_wake_up_waiters, ring_buffer_wake_waiters, rb_watermark_hit",
          "description": "实现缓冲区页数统计功能，包含满状态检测算法，提供唤醒等待者的中断处理函数，支持全CPU模式和特定CPU的唤醒操作，包含水位标记判断逻辑控制缓冲区回收行为",
          "similarity": 0.5139877796173096
        },
        {
          "chunk_id": 27,
          "file_path": "kernel/trace/ring_buffer.c",
          "start_line": 6041,
          "end_line": 6232,
          "content": [
            "static __init int rb_test(void *arg)",
            "{",
            "\tstruct rb_test_data *data = arg;",
            "",
            "\twhile (!kthread_should_stop()) {",
            "\t\trb_write_something(data, false);",
            "\t\tdata->cnt++;",
            "",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\t/* Now sleep between a min of 100-300us and a max of 1ms */",
            "\t\tusleep_range(((data->cnt % 3) + 1) * 100, 1000);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static __init void rb_ipi(void *ignore)",
            "{",
            "\tstruct rb_test_data *data;",
            "\tint cpu = smp_processor_id();",
            "",
            "\tdata = &rb_data[cpu];",
            "\trb_write_something(data, true);",
            "}",
            "static __init int rb_hammer_test(void *arg)",
            "{",
            "\twhile (!kthread_should_stop()) {",
            "",
            "\t\t/* Send an IPI to all cpus to write data! */",
            "\t\tsmp_call_function(rb_ipi, NULL, 1);",
            "\t\t/* No sleep, but for non preempt, let others run */",
            "\t\tschedule();",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static __init int test_ringbuffer(void)",
            "{",
            "\tstruct task_struct *rb_hammer;",
            "\tstruct trace_buffer *buffer;",
            "\tint cpu;",
            "\tint ret = 0;",
            "",
            "\tif (security_locked_down(LOCKDOWN_TRACEFS)) {",
            "\t\tpr_warn(\"Lockdown is enabled, skipping ring buffer tests\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tpr_info(\"Running ring buffer tests...\\n\");",
            "",
            "\tbuffer = ring_buffer_alloc(RB_TEST_BUFFER_SIZE, RB_FL_OVERWRITE);",
            "\tif (WARN_ON(!buffer))",
            "\t\treturn 0;",
            "",
            "\t/* Disable buffer so that threads can't write to it yet */",
            "\tring_buffer_record_off(buffer);",
            "",
            "\tfor_each_online_cpu(cpu) {",
            "\t\trb_data[cpu].buffer = buffer;",
            "\t\trb_data[cpu].cpu = cpu;",
            "\t\trb_data[cpu].cnt = cpu;",
            "\t\trb_threads[cpu] = kthread_run_on_cpu(rb_test, &rb_data[cpu],",
            "\t\t\t\t\t\t     cpu, \"rbtester/%u\");",
            "\t\tif (WARN_ON(IS_ERR(rb_threads[cpu]))) {",
            "\t\t\tpr_cont(\"FAILED\\n\");",
            "\t\t\tret = PTR_ERR(rb_threads[cpu]);",
            "\t\t\tgoto out_free;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Now create the rb hammer! */",
            "\trb_hammer = kthread_run(rb_hammer_test, NULL, \"rbhammer\");",
            "\tif (WARN_ON(IS_ERR(rb_hammer))) {",
            "\t\tpr_cont(\"FAILED\\n\");",
            "\t\tret = PTR_ERR(rb_hammer);",
            "\t\tgoto out_free;",
            "\t}",
            "",
            "\tring_buffer_record_on(buffer);",
            "\t/*",
            "\t * Show buffer is enabled before setting rb_test_started.",
            "\t * Yes there's a small race window where events could be",
            "\t * dropped and the thread wont catch it. But when a ring",
            "\t * buffer gets enabled, there will always be some kind of",
            "\t * delay before other CPUs see it. Thus, we don't care about",
            "\t * those dropped events. We care about events dropped after",
            "\t * the threads see that the buffer is active.",
            "\t */",
            "\tsmp_wmb();",
            "\trb_test_started = true;",
            "",
            "\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t/* Just run for 10 seconds */;",
            "\tschedule_timeout(10 * HZ);",
            "",
            "\tkthread_stop(rb_hammer);",
            "",
            " out_free:",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tif (!rb_threads[cpu])",
            "\t\t\tbreak;",
            "\t\tkthread_stop(rb_threads[cpu]);",
            "\t}",
            "\tif (ret) {",
            "\t\tring_buffer_free(buffer);",
            "\t\treturn ret;",
            "\t}",
            "",
            "\t/* Report! */",
            "\tpr_info(\"finished\\n\");",
            "\tfor_each_online_cpu(cpu) {",
            "\t\tstruct ring_buffer_event *event;",
            "\t\tstruct rb_test_data *data = &rb_data[cpu];",
            "\t\tstruct rb_item *item;",
            "\t\tunsigned long total_events;",
            "\t\tunsigned long total_dropped;",
            "\t\tunsigned long total_written;",
            "\t\tunsigned long total_alloc;",
            "\t\tunsigned long total_read = 0;",
            "\t\tunsigned long total_size = 0;",
            "\t\tunsigned long total_len = 0;",
            "\t\tunsigned long total_lost = 0;",
            "\t\tunsigned long lost;",
            "\t\tint big_event_size;",
            "\t\tint small_event_size;",
            "",
            "\t\tret = -1;",
            "",
            "\t\ttotal_events = data->events + data->events_nested;",
            "\t\ttotal_written = data->bytes_written + data->bytes_written_nested;",
            "\t\ttotal_alloc = data->bytes_alloc + data->bytes_alloc_nested;",
            "\t\ttotal_dropped = data->bytes_dropped + data->bytes_dropped_nested;",
            "",
            "\t\tbig_event_size = data->max_size + data->max_size_nested;",
            "\t\tsmall_event_size = data->min_size + data->min_size_nested;",
            "",
            "\t\tpr_info(\"CPU %d:\\n\", cpu);",
            "\t\tpr_info(\"              events:    %ld\\n\", total_events);",
            "\t\tpr_info(\"       dropped bytes:    %ld\\n\", total_dropped);",
            "\t\tpr_info(\"       alloced bytes:    %ld\\n\", total_alloc);",
            "\t\tpr_info(\"       written bytes:    %ld\\n\", total_written);",
            "\t\tpr_info(\"       biggest event:    %d\\n\", big_event_size);",
            "\t\tpr_info(\"      smallest event:    %d\\n\", small_event_size);",
            "",
            "\t\tif (RB_WARN_ON(buffer, total_dropped))",
            "\t\t\tbreak;",
            "",
            "\t\tret = 0;",
            "",
            "\t\twhile ((event = ring_buffer_consume(buffer, cpu, NULL, &lost))) {",
            "\t\t\ttotal_lost += lost;",
            "\t\t\titem = ring_buffer_event_data(event);",
            "\t\t\ttotal_len += ring_buffer_event_length(event);",
            "\t\t\ttotal_size += item->size + sizeof(struct rb_item);",
            "\t\t\tif (memcmp(&item->str[0], rb_string, item->size) != 0) {",
            "\t\t\t\tpr_info(\"FAILED!\\n\");",
            "\t\t\t\tpr_info(\"buffer had: %.*s\\n\", item->size, item->str);",
            "\t\t\t\tpr_info(\"expected:   %.*s\\n\", item->size, rb_string);",
            "\t\t\t\tRB_WARN_ON(buffer, 1);",
            "\t\t\t\tret = -1;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\ttotal_read++;",
            "\t\t}",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "",
            "\t\tret = -1;",
            "",
            "\t\tpr_info(\"         read events:   %ld\\n\", total_read);",
            "\t\tpr_info(\"         lost events:   %ld\\n\", total_lost);",
            "\t\tpr_info(\"        total events:   %ld\\n\", total_lost + total_read);",
            "\t\tpr_info(\"  recorded len bytes:   %ld\\n\", total_len);",
            "\t\tpr_info(\" recorded size bytes:   %ld\\n\", total_size);",
            "\t\tif (total_lost) {",
            "\t\t\tpr_info(\" With dropped events, record len and size may not match\\n\"",
            "\t\t\t\t\" alloced and written from above\\n\");",
            "\t\t} else {",
            "\t\t\tif (RB_WARN_ON(buffer, total_len != total_alloc ||",
            "\t\t\t\t       total_size != total_written))",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tif (RB_WARN_ON(buffer, total_lost + total_read != total_events))",
            "\t\t\tbreak;",
            "",
            "\t\tret = 0;",
            "\t}",
            "\tif (!ret)",
            "\t\tpr_info(\"Ring buffer PASSED!\\n\");",
            "",
            "\tring_buffer_free(buffer);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "rb_test, rb_ipi, rb_hammer_test, test_ringbuffer",
          "description": "rb_test 循环执行写入操作并休眠；rb_ipi 通过IPI触发其他CPU写入；rb_hammer_test 连续发送IPI进行并发写入；test_ringbuffer 初始化缓冲区，启动测试线程，运行测试用例并验证数据完整性，统计事件数量、丢弃情况及数据一致性",
          "similarity": 0.5139241814613342
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/ring_buffer.c",
          "start_line": 45,
          "end_line": 148,
          "content": [
            "int ring_buffer_print_entry_header(struct trace_seq *s)",
            "{",
            "\ttrace_seq_puts(s, \"# compressed entry header\\n\");",
            "\ttrace_seq_puts(s, \"\\ttype_len    :    5 bits\\n\");",
            "\ttrace_seq_puts(s, \"\\ttime_delta  :   27 bits\\n\");",
            "\ttrace_seq_puts(s, \"\\tarray       :   32 bits\\n\");",
            "\ttrace_seq_putc(s, '\\n');",
            "\ttrace_seq_printf(s, \"\\tpadding     : type == %d\\n\",",
            "\t\t\t RINGBUF_TYPE_PADDING);",
            "\ttrace_seq_printf(s, \"\\ttime_extend : type == %d\\n\",",
            "\t\t\t RINGBUF_TYPE_TIME_EXTEND);",
            "\ttrace_seq_printf(s, \"\\ttime_stamp : type == %d\\n\",",
            "\t\t\t RINGBUF_TYPE_TIME_STAMP);",
            "\ttrace_seq_printf(s, \"\\tdata max type_len  == %d\\n\",",
            "\t\t\t RINGBUF_TYPE_DATA_TYPE_LEN_MAX);",
            "",
            "\treturn !trace_seq_has_overflowed(s);",
            "}",
            "static inline bool rb_null_event(struct ring_buffer_event *event)",
            "{",
            "\treturn event->type_len == RINGBUF_TYPE_PADDING && !event->time_delta;",
            "}",
            "static void rb_event_set_padding(struct ring_buffer_event *event)",
            "{",
            "\t/* padding has a NULL time_delta */",
            "\tevent->type_len = RINGBUF_TYPE_PADDING;",
            "\tevent->time_delta = 0;",
            "}",
            "static unsigned",
            "rb_event_data_length(struct ring_buffer_event *event)",
            "{",
            "\tunsigned length;",
            "",
            "\tif (event->type_len)",
            "\t\tlength = event->type_len * RB_ALIGNMENT;",
            "\telse",
            "\t\tlength = event->array[0];",
            "\treturn length + RB_EVNT_HDR_SIZE;",
            "}",
            "static inline unsigned",
            "rb_event_length(struct ring_buffer_event *event)",
            "{",
            "\tswitch (event->type_len) {",
            "\tcase RINGBUF_TYPE_PADDING:",
            "\t\tif (rb_null_event(event))",
            "\t\t\t/* undefined */",
            "\t\t\treturn -1;",
            "\t\treturn  event->array[0] + RB_EVNT_HDR_SIZE;",
            "",
            "\tcase RINGBUF_TYPE_TIME_EXTEND:",
            "\t\treturn RB_LEN_TIME_EXTEND;",
            "",
            "\tcase RINGBUF_TYPE_TIME_STAMP:",
            "\t\treturn RB_LEN_TIME_STAMP;",
            "",
            "\tcase RINGBUF_TYPE_DATA:",
            "\t\treturn rb_event_data_length(event);",
            "\tdefault:",
            "\t\tWARN_ON_ONCE(1);",
            "\t}",
            "\t/* not hit */",
            "\treturn 0;",
            "}",
            "static inline unsigned",
            "rb_event_ts_length(struct ring_buffer_event *event)",
            "{",
            "\tunsigned len = 0;",
            "",
            "\tif (extended_time(event)) {",
            "\t\t/* time extends include the data event after it */",
            "\t\tlen = RB_LEN_TIME_EXTEND;",
            "\t\tevent = skip_time_extend(event);",
            "\t}",
            "\treturn len + rb_event_length(event);",
            "}",
            "unsigned ring_buffer_event_length(struct ring_buffer_event *event)",
            "{",
            "\tunsigned length;",
            "",
            "\tif (extended_time(event))",
            "\t\tevent = skip_time_extend(event);",
            "",
            "\tlength = rb_event_length(event);",
            "\tif (event->type_len > RINGBUF_TYPE_DATA_TYPE_LEN_MAX)",
            "\t\treturn length;",
            "\tlength -= RB_EVNT_HDR_SIZE;",
            "\tif (length > RB_MAX_SMALL_DATA + sizeof(event->array[0]))",
            "                length -= sizeof(event->array[0]);",
            "\treturn length;",
            "}",
            "static u64 rb_event_time_stamp(struct ring_buffer_event *event)",
            "{",
            "\tu64 ts;",
            "",
            "\tts = event->array[0];",
            "\tts <<= TS_SHIFT;",
            "\tts += event->time_delta;",
            "",
            "\treturn ts;",
            "}",
            "static void rb_init_page(struct buffer_data_page *bpage)",
            "{",
            "\tlocal_set(&bpage->commit, 0);",
            "}"
          ],
          "function_name": "ring_buffer_print_entry_header, rb_null_event, rb_event_set_padding, rb_event_data_length, rb_event_length, rb_event_ts_length, ring_buffer_event_length, rb_event_time_stamp, rb_init_page",
          "description": "实现环形缓冲区事件解析功能，包括打印事件头信息、识别空事件、设置填充事件、计算不同事件类型的数据长度及时间戳，提供事件长度和时间戳读取接口",
          "similarity": 0.5135136246681213
        },
        {
          "chunk_id": 26,
          "file_path": "kernel/trace/ring_buffer.c",
          "start_line": 5883,
          "end_line": 5985,
          "content": [
            "int trace_rb_cpu_prepare(unsigned int cpu, struct hlist_node *node)",
            "{",
            "\tstruct trace_buffer *buffer;",
            "\tlong nr_pages_same;",
            "\tint cpu_i;",
            "\tunsigned long nr_pages;",
            "",
            "\tbuffer = container_of(node, struct trace_buffer, node);",
            "\tif (cpumask_test_cpu(cpu, buffer->cpumask))",
            "\t\treturn 0;",
            "",
            "\tnr_pages = 0;",
            "\tnr_pages_same = 1;",
            "\t/* check if all cpu sizes are same */",
            "\tfor_each_buffer_cpu(buffer, cpu_i) {",
            "\t\t/* fill in the size from first enabled cpu */",
            "\t\tif (nr_pages == 0)",
            "\t\t\tnr_pages = buffer->buffers[cpu_i]->nr_pages;",
            "\t\tif (nr_pages != buffer->buffers[cpu_i]->nr_pages) {",
            "\t\t\tnr_pages_same = 0;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\t/* allocate minimum pages, user can later expand it */",
            "\tif (!nr_pages_same)",
            "\t\tnr_pages = 2;",
            "\tbuffer->buffers[cpu] =",
            "\t\trb_allocate_cpu_buffer(buffer, nr_pages, cpu);",
            "\tif (!buffer->buffers[cpu]) {",
            "\t\tWARN(1, \"failed to allocate ring buffer on CPU %u\\n\",",
            "\t\t     cpu);",
            "\t\treturn -ENOMEM;",
            "\t}",
            "\tsmp_wmb();",
            "\tcpumask_set_cpu(cpu, buffer->cpumask);",
            "\treturn 0;",
            "}",
            "static __init int rb_write_something(struct rb_test_data *data, bool nested)",
            "{",
            "\tstruct ring_buffer_event *event;",
            "\tstruct rb_item *item;",
            "\tbool started;",
            "\tint event_len;",
            "\tint size;",
            "\tint len;",
            "\tint cnt;",
            "",
            "\t/* Have nested writes different that what is written */",
            "\tcnt = data->cnt + (nested ? 27 : 0);",
            "",
            "\t/* Multiply cnt by ~e, to make some unique increment */",
            "\tsize = (cnt * 68 / 25) % (sizeof(rb_string) - 1);",
            "",
            "\tlen = size + sizeof(struct rb_item);",
            "",
            "\tstarted = rb_test_started;",
            "\t/* read rb_test_started before checking buffer enabled */",
            "\tsmp_rmb();",
            "",
            "\tevent = ring_buffer_lock_reserve(data->buffer, len);",
            "\tif (!event) {",
            "\t\t/* Ignore dropped events before test starts. */",
            "\t\tif (started) {",
            "\t\t\tif (nested)",
            "\t\t\t\tdata->bytes_dropped_nested += len;",
            "\t\t\telse",
            "\t\t\t\tdata->bytes_dropped += len;",
            "\t\t}",
            "\t\treturn len;",
            "\t}",
            "",
            "\tevent_len = ring_buffer_event_length(event);",
            "",
            "\tif (RB_WARN_ON(data->buffer, event_len < len))",
            "\t\tgoto out;",
            "",
            "\titem = ring_buffer_event_data(event);",
            "\titem->size = size;",
            "\tmemcpy(item->str, rb_string, size);",
            "",
            "\tif (nested) {",
            "\t\tdata->bytes_alloc_nested += event_len;",
            "\t\tdata->bytes_written_nested += len;",
            "\t\tdata->events_nested++;",
            "\t\tif (!data->min_size_nested || len < data->min_size_nested)",
            "\t\t\tdata->min_size_nested = len;",
            "\t\tif (len > data->max_size_nested)",
            "\t\t\tdata->max_size_nested = len;",
            "\t} else {",
            "\t\tdata->bytes_alloc += event_len;",
            "\t\tdata->bytes_written += len;",
            "\t\tdata->events++;",
            "\t\tif (!data->min_size || len < data->min_size)",
            "\t\t\tdata->max_size = len;",
            "\t\tif (len > data->max_size)",
            "\t\t\tdata->max_size = len;",
            "\t}",
            "",
            " out:",
            "\tring_buffer_unlock_commit(data->buffer);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "trace_rb_cpu_prepare, rb_write_something",
          "description": "trace_rb_cpu_prepare 函数为指定CPU分配环形缓冲区实例，确保各CPU缓冲区页数一致；rb_write_something 函数模拟测试写入流程，根据嵌套标志区分普通写入和嵌套写入，记录事件大小及丢弃统计信息，处理事件数据拷贝和内存分配",
          "similarity": 0.5109568238258362
        }
      ]
    },
    {
      "source_file": "mm/mapping_dirty_helpers.c",
      "md_summary": "> 自动生成时间: 2025-12-07 16:37:26\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `mapping_dirty_helpers.c`\n\n---\n\n# mapping_dirty_helpers.c 技术文档\n\n## 1. 文件概述\n\n`mapping_dirty_helpers.c` 是 Linux 内核中用于管理共享映射（shared mapping）页面脏状态和写保护的核心辅助模块。该文件提供了一组基于页表遍历（pagewalk）机制的函数，用于在指定地址空间范围内对 PTE（页表项）执行写保护（write-protect）或清理脏位（clean dirty bit）操作，并高效地记录受影响的虚拟地址范围以进行 TLB 刷新和 MMU 通知。此功能主要用于内存管理子系统中的脏页跟踪、回写控制和 COW（Copy-On-Write）优化等场景。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct wp_walk`**  \n  页表遍历回调的私有上下文结构，用于记录：\n  - `range`：MMU 通知器作用范围\n  - `tlbflush_start` / `tlbflush_end`：需要刷新 TLB 的最小/最大虚拟地址\n  - `total`：被修改的 PTE 总数\n\n- **`struct clean_walk`**  \n  继承自 `wp_walk`，专用于 `clean_record_pte` 场景，额外包含：\n  - `bitmap_pgoff`：位图对应的起始页偏移\n  - `bitmap`：记录脏页偏移的位图\n  - `start` / `end`：位图中被设置位的最小/最大偏移（相对 `bitmap_pgoff`）\n\n### 主要函数\n\n- **`wp_pte()`**  \n  对可写的 PTE 执行写保护操作，更新 TLB 刷新范围并计数。\n\n- **`clean_record_pte()`**  \n  清除 PTE 的脏位，同时将对应页偏移记录到位图中，并更新 TLB 刷新范围。\n\n- **`wp_clean_pmd_entry()` / `wp_clean_pud_entry()`**  \n  处理 PMD/PUD 级别的巨页（huge page）条目，**不拆分巨页**，仅对可写或脏的巨页发出警告。\n\n- **`wp_clean_pre_vma()` / `wp_clean_post_vma()`**  \n  VMA 遍历前/后回调：初始化 MMU 通知、缓存刷新、TLB 刷新准备与执行。\n\n- **`wp_clean_test_walk()`**  \n  过滤不适用的 VMA：仅处理具有 `VM_SHARED | VM_MAYWRITE` 且非 `VM_HUGETLB` 的共享可写映射。\n\n- **`wp_shared_mapping_range()`**（未完整展示）  \n  公共接口函数，对指定地址空间范围内的所有 PTE 执行写保护。\n\n### 操作集定义\n\n- **`clean_walk_ops`**：用于清理脏位并记录位图的页表遍历操作集。\n- **`wp_walk_ops`**：仅执行写保护的页表遍历操作集。\n\n## 3. 关键实现\n\n### 页表遍历与原子修改\n- 使用 `ptep_get()` 安全读取 PTE。\n- 通过 `ptep_modify_prot_start()` / `ptep_modify_prot_commit()` 原子地修改 PTE 的保护属性，确保 SMP 和并发访问安全。\n- 对于写保护：调用 `pte_wrprotect()`；对于清理脏位：调用 `pte_mkclean()`。\n\n### TLB 刷新优化\n- 不使用 `tlb_gather_mmu()`（因其记录整个 VMA 范围），而是动态维护实际修改的最小/最大地址 (`tlbflush_start`/`end`)。\n- 在 `post_vma` 阶段根据是否发生嵌套 TLB 刷新 (`mm_tlb_flush_nested()`) 决定刷新整个 VMA 范围还是精确子范围。\n\n### 巨页处理策略\n- **明确禁止拆分透明巨页（THP）**：在 PMD/PUD 回调中检测到可写或脏的巨页时仅发出 `WARN_ON`，依赖缺页异常处理器后续处理。\n- 此设计避免在遍历过程中因拆分巨页导致脏信息丢失。\n\n### 位图记录机制\n- `clean_record_pte` 将虚拟地址转换为地址空间页偏移（`pgoff`），再相对于位图起始偏移计算位索引。\n- 使用 `__set_bit()` 设置位图，并维护被设置位的连续范围 (`start`/`end`)，便于后续高效处理。\n\n### VMA 过滤逻辑\n- 仅处理满足 `(VM_SHARED | VM_MAYWRITE)` 且 **不包含** `VM_HUGETLB` 的 VMA，确保操作对象是普通共享可写映射。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/pagewalk.h>`：页表遍历框架\n  - `<linux/hugetlb.h>`：巨页相关宏（如 `pmd_trans_huge`）\n  - `<linux/bitops.h>`：位图操作（`__set_bit`）\n  - `<linux/mmu_notifier.h>`：MMU 通知机制\n  - `<linux/mm_inline.h>`：内联内存管理函数\n  - `<asm/cacheflush.h>` / `<asm/tlbflush.h>`：体系结构相关的缓存和 TLB 刷新\n\n- **内核子系统**：\n  - 内存管理（MM）子系统：VMA、页表、PTE 操作\n  - 虚拟内存区域（VMA）管理\n  - MMU 通知框架\n  - 透明巨页（THP）支持\n\n## 5. 使用场景\n\n- **脏页跟踪（Dirty Tracking）**：在回写（writeback）或检查点（checkpointing）前，清除 PTE 脏位并记录哪些页被修改过。\n- **写时复制（COW）优化**：对共享映射执行写保护，使得后续写入触发缺页异常，从而实现 COW。\n- **内存快照/迁移**：在创建内存快照或迁移页面前，暂停写入并捕获脏页信息。\n- **文件系统一致性**：某些文件系统（如 NFS、CIFS）可能利用此机制跟踪共享映射的修改，确保数据一致性。\n- **用户态内存监控工具**：通过内核接口对特定映射范围进行写保护，监控应用程序的写行为。",
      "similarity": 0.5298146605491638,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "mm/mapping_dirty_helpers.c",
          "start_line": 34,
          "end_line": 141,
          "content": [
            "static int wp_pte(pte_t *pte, unsigned long addr, unsigned long end,",
            "\t\t  struct mm_walk *walk)",
            "{",
            "\tstruct wp_walk *wpwalk = walk->private;",
            "\tpte_t ptent = ptep_get(pte);",
            "",
            "\tif (pte_write(ptent)) {",
            "\t\tpte_t old_pte = ptep_modify_prot_start(walk->vma, addr, pte);",
            "",
            "\t\tptent = pte_wrprotect(old_pte);",
            "\t\tptep_modify_prot_commit(walk->vma, addr, pte, old_pte, ptent);",
            "\t\twpwalk->total++;",
            "\t\twpwalk->tlbflush_start = min(wpwalk->tlbflush_start, addr);",
            "\t\twpwalk->tlbflush_end = max(wpwalk->tlbflush_end,",
            "\t\t\t\t\t   addr + PAGE_SIZE);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int clean_record_pte(pte_t *pte, unsigned long addr,",
            "\t\t\t    unsigned long end, struct mm_walk *walk)",
            "{",
            "\tstruct wp_walk *wpwalk = walk->private;",
            "\tstruct clean_walk *cwalk = to_clean_walk(wpwalk);",
            "\tpte_t ptent = ptep_get(pte);",
            "",
            "\tif (pte_dirty(ptent)) {",
            "\t\tpgoff_t pgoff = ((addr - walk->vma->vm_start) >> PAGE_SHIFT) +",
            "\t\t\twalk->vma->vm_pgoff - cwalk->bitmap_pgoff;",
            "\t\tpte_t old_pte = ptep_modify_prot_start(walk->vma, addr, pte);",
            "",
            "\t\tptent = pte_mkclean(old_pte);",
            "\t\tptep_modify_prot_commit(walk->vma, addr, pte, old_pte, ptent);",
            "",
            "\t\twpwalk->total++;",
            "\t\twpwalk->tlbflush_start = min(wpwalk->tlbflush_start, addr);",
            "\t\twpwalk->tlbflush_end = max(wpwalk->tlbflush_end,",
            "\t\t\t\t\t   addr + PAGE_SIZE);",
            "",
            "\t\t__set_bit(pgoff, cwalk->bitmap);",
            "\t\tcwalk->start = min(cwalk->start, pgoff);",
            "\t\tcwalk->end = max(cwalk->end, pgoff + 1);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int wp_clean_pmd_entry(pmd_t *pmd, unsigned long addr, unsigned long end,",
            "\t\t\t      struct mm_walk *walk)",
            "{",
            "\tpmd_t pmdval = pmdp_get_lockless(pmd);",
            "",
            "\t/* Do not split a huge pmd, present or migrated */",
            "\tif (pmd_trans_huge(pmdval) || pmd_devmap(pmdval)) {",
            "\t\tWARN_ON(pmd_write(pmdval) || pmd_dirty(pmdval));",
            "\t\twalk->action = ACTION_CONTINUE;",
            "\t}",
            "\treturn 0;",
            "}",
            "static int wp_clean_pud_entry(pud_t *pud, unsigned long addr, unsigned long end,",
            "\t\t\t      struct mm_walk *walk)",
            "{",
            "#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD",
            "\tpud_t pudval = READ_ONCE(*pud);",
            "",
            "\t/* Do not split a huge pud */",
            "\tif (pud_trans_huge(pudval) || pud_devmap(pudval)) {",
            "\t\tWARN_ON(pud_write(pudval) || pud_dirty(pudval));",
            "\t\twalk->action = ACTION_CONTINUE;",
            "\t}",
            "#endif",
            "\treturn 0;",
            "}",
            "static int wp_clean_pre_vma(unsigned long start, unsigned long end,",
            "\t\t\t    struct mm_walk *walk)",
            "{",
            "\tstruct wp_walk *wpwalk = walk->private;",
            "",
            "\twpwalk->tlbflush_start = end;",
            "\twpwalk->tlbflush_end = start;",
            "",
            "\tmmu_notifier_range_init(&wpwalk->range, MMU_NOTIFY_PROTECTION_PAGE, 0,",
            "\t\t\t\twalk->mm, start, end);",
            "\tmmu_notifier_invalidate_range_start(&wpwalk->range);",
            "\tflush_cache_range(walk->vma, start, end);",
            "",
            "\t/*",
            "\t * We're not using tlb_gather_mmu() since typically",
            "\t * only a small subrange of PTEs are affected, whereas",
            "\t * tlb_gather_mmu() records the full range.",
            "\t */",
            "\tinc_tlb_flush_pending(walk->mm);",
            "",
            "\treturn 0;",
            "}",
            "static void wp_clean_post_vma(struct mm_walk *walk)",
            "{",
            "\tstruct wp_walk *wpwalk = walk->private;",
            "",
            "\tif (mm_tlb_flush_nested(walk->mm))",
            "\t\tflush_tlb_range(walk->vma, wpwalk->range.start,",
            "\t\t\t\twpwalk->range.end);",
            "\telse if (wpwalk->tlbflush_end > wpwalk->tlbflush_start)",
            "\t\tflush_tlb_range(walk->vma, wpwalk->tlbflush_start,",
            "\t\t\t\twpwalk->tlbflush_end);",
            "",
            "\tmmu_notifier_invalidate_range_end(&wpwalk->range);",
            "\tdec_tlb_flush_pending(walk->mm);",
            "}"
          ],
          "function_name": "wp_pte, clean_record_pte, wp_clean_pmd_entry, wp_clean_pud_entry, wp_clean_pre_vma, wp_clean_post_vma",
          "description": "实现页表项写保护与脏页清除逻辑，通过遍历页表修改PTE标志位，处理huge pmd/pud避免拆分，预/后处理VMA时设置TLB刷新范围并触发缓存/TLB无效操作。",
          "similarity": 0.5465683341026306
        },
        {
          "chunk_id": 2,
          "file_path": "mm/mapping_dirty_helpers.c",
          "start_line": 218,
          "end_line": 267,
          "content": [
            "static int wp_clean_test_walk(unsigned long start, unsigned long end,",
            "\t\t\t      struct mm_walk *walk)",
            "{",
            "\tunsigned long vm_flags = READ_ONCE(walk->vma->vm_flags);",
            "",
            "\t/* Skip non-applicable VMAs */",
            "\tif ((vm_flags & (VM_SHARED | VM_MAYWRITE | VM_HUGETLB)) !=",
            "\t    (VM_SHARED | VM_MAYWRITE))",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "unsigned long wp_shared_mapping_range(struct address_space *mapping,",
            "\t\t\t\t      pgoff_t first_index, pgoff_t nr)",
            "{",
            "\tstruct wp_walk wpwalk = { .total = 0 };",
            "",
            "\ti_mmap_lock_read(mapping);",
            "\tWARN_ON(walk_page_mapping(mapping, first_index, nr, &wp_walk_ops,",
            "\t\t\t\t  &wpwalk));",
            "\ti_mmap_unlock_read(mapping);",
            "",
            "\treturn wpwalk.total;",
            "}",
            "unsigned long clean_record_shared_mapping_range(struct address_space *mapping,",
            "\t\t\t\t\t\tpgoff_t first_index, pgoff_t nr,",
            "\t\t\t\t\t\tpgoff_t bitmap_pgoff,",
            "\t\t\t\t\t\tunsigned long *bitmap,",
            "\t\t\t\t\t\tpgoff_t *start,",
            "\t\t\t\t\t\tpgoff_t *end)",
            "{",
            "\tbool none_set = (*start >= *end);",
            "\tstruct clean_walk cwalk = {",
            "\t\t.base = { .total = 0 },",
            "\t\t.bitmap_pgoff = bitmap_pgoff,",
            "\t\t.bitmap = bitmap,",
            "\t\t.start = none_set ? nr : *start,",
            "\t\t.end = none_set ? 0 : *end,",
            "\t};",
            "",
            "\ti_mmap_lock_read(mapping);",
            "\tWARN_ON(walk_page_mapping(mapping, first_index, nr, &clean_walk_ops,",
            "\t\t\t\t  &cwalk.base));",
            "\ti_mmap_unlock_read(mapping);",
            "",
            "\t*start = cwalk.start;",
            "\t*end = cwalk.end;",
            "",
            "\treturn cwalk.base.total;",
            "}"
          ],
          "function_name": "wp_clean_test_walk, wp_shared_mapping_range, clean_record_shared_mapping_range",
          "description": "提供共享映射范围检测函数，统计共享页面数量并记录脏页偏移至位图，通过i_mmap锁保护遍历页面映射关系，支持批量清理共享内存的脏页追踪。",
          "similarity": 0.4868939220905304
        },
        {
          "chunk_id": 0,
          "file_path": "mm/mapping_dirty_helpers.c",
          "start_line": 1,
          "end_line": 33,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/pagewalk.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/tlbflush.h>",
            "",
            "/**",
            " * struct wp_walk - Private struct for pagetable walk callbacks",
            " * @range: Range for mmu notifiers",
            " * @tlbflush_start: Address of first modified pte",
            " * @tlbflush_end: Address of last modified pte + 1",
            " * @total: Total number of modified ptes",
            " */",
            "struct wp_walk {",
            "\tstruct mmu_notifier_range range;",
            "\tunsigned long tlbflush_start;",
            "\tunsigned long tlbflush_end;",
            "\tunsigned long total;",
            "};",
            "",
            "/**",
            " * wp_pte - Write-protect a pte",
            " * @pte: Pointer to the pte",
            " * @addr: The start of protecting virtual address",
            " * @end: The end of protecting virtual address",
            " * @walk: pagetable walk callback argument",
            " *",
            " * The function write-protects a pte and records the range in",
            " * virtual address space of touched ptes for efficient range TLB flushes.",
            " */"
          ],
          "function_name": null,
          "description": "定义wp_walk结构体，用于在页表遍历回调中记录MMU通知范围、TLB刷新地址区间及修改的页表项数量，并声明wp_pte函数用于写保护页表项并记录修改范围。",
          "similarity": 0.4208536148071289
        }
      ]
    },
    {
      "source_file": "kernel/trace/trace_printk.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:32:29\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\trace_printk.c`\n\n---\n\n# trace_printk.c 技术文档\n\n## 文件概述\n\n`trace_printk.c` 是 Linux 内核追踪子系统（ftrace）中的一个核心组件，用于实现高效的二进制格式化打印（`trace_printk`）功能。该文件主要负责管理 `trace_printk()` 所使用的格式字符串（format strings），特别是在内核模块动态加载/卸载时对格式字符串的生命周期进行管理，并提供调试接口（通过 debugfs）供用户空间工具解析追踪缓冲区中的二进制事件。\n\n与传统的 `printk` 不同，`trace_printk` 将格式字符串地址和参数以二进制形式记录到追踪环形缓冲区中，从而减少运行时开销。用户空间工具（如 `trace-cmd`）需通过 `/sys/kernel/debug/tracing/printk_formats` 文件将格式字符串地址映射回原始格式文本，以正确解析追踪数据。\n\n## 核心功能\n\n### 主要函数\n\n- `__trace_bprintk()` / `__ftrace_vbprintk()`：  \n  二进制格式的 `trace_printk` 入口函数，将格式字符串指针和变参记录到追踪缓冲区。\n  \n- `__trace_printk()` / `__ftrace_vprintk()`：  \n  文本格式的 `trace_printk` 入口函数（较少使用），直接格式化为字符串写入缓冲区。\n\n- `hold_module_trace_bprintk_format()`：  \n  在模块加载时（`MODULE_STATE_COMING`），将模块中 `__trace_printk_fmt` 段的格式字符串复制到内核堆中，并加入全局链表管理，防止模块卸载后格式字符串失效。\n\n- `find_next()` / `t_start()` / `t_next()` / `t_show()`：  \n  实现 `/sys/kernel/debug/tracing/printk_formats` 的 seq_file 接口，遍历并输出所有有效的格式字符串及其地址（包括内核静态段、tracepoint 字符串段和模块动态注册的格式）。\n\n- `trace_printk_control()`：  \n  全局开关，用于启用或禁用 `trace_printk` 功能。\n\n- `trace_is_tracepoint_string()`：  \n  判断给定字符串是否属于 tracepoint 使用的静态字符串段（`__tracepoint_str`）。\n\n### 主要数据结构\n\n- `struct trace_bprintk_fmt`：  \n  用于封装模块中动态注册的格式字符串，包含链表节点和指向堆分配格式字符串的指针。\n\n- `trace_bprintk_fmt_list`：  \n  全局链表，存储所有由内核模块注册的 `trace_bprintk_fmt` 实例。\n\n- `btrace_mutex`：  \n  保护 `trace_bprintk_fmt_list` 的互斥锁，确保多线程/模块并发访问时的安全性。\n\n- `module_trace_bprintk_format_nb`：  \n  模块状态通知块，监听模块加载事件以触发格式字符串的注册。\n\n## 关键实现\n\n### 模块格式字符串生命周期管理\n\n当内核配置 `CONFIG_MODULES=y` 时，模块中的 `trace_printk` 格式字符串位于模块的 `__trace_printk_fmt` 段。若模块卸载，该段内存将被释放，导致追踪缓冲区中的格式地址悬空。为解决此问题：\n\n1. **注册阶段**：在模块加载时（通过 `module_notifier`），`hold_module_trace_bprintk_format()` 被调用。\n2. **去重与复制**：遍历模块提供的格式字符串数组，对每个格式字符串：\n   - 若已在全局链表中存在，则复用已有条目；\n   - 否则，从内核堆中分配内存复制格式字符串，并创建 `trace_bprintk_fmt` 节点加入链表。\n3. **地址替换**：将模块原始格式字符串指针替换为堆中副本的地址，确保后续 `trace_bprintk` 使用持久有效的地址。\n\n### printk_formats 调试接口\n\n`/sys/kernel/debug/tracing/printk_formats` 文件按顺序输出三类格式字符串：\n\n1. **内核静态格式**：来自 `__start___trace_bprintk_fmt` 到 `__stop___trace_bprintk_fmt` 的编译时内嵌格式。\n2. **Tracepoint 字符串**：来自 `__start___tracepoint_str` 到 `__stop___tracepoint_str` 的 tracepoint 静态字符串（同样用于二进制追踪）。\n3. **模块动态格式**：来自 `trace_bprintk_fmt_list` 链表的模块注册格式。\n\n`find_next()` 函数根据当前遍历位置（`*pos`）决定返回哪一类格式的地址。对于模块格式，通过 `container_of` 从格式字符串地址反推 `trace_bprintk_fmt` 结构，实现链表遍历。\n\n### 安全与性能优化\n\n- **全局开关**：`trace_printk_enabled` 允许在运行时完全禁用 `trace_printk`，避免不必要的性能开销。\n- **延迟初始化**：`trace_printk_init_buffers()` 仅在首次使用 `trace_printk` 时分配 per-CPU 缓冲区。\n- **格式转义**：在 `t_show()` 中对 `\\n`、`\\t`、`\"` 等特殊字符进行转义，确保 debugfs 输出格式正确。\n\n## 依赖关系\n\n- **ftrace 核心**：依赖 `trace.h` 中定义的 `trace_vbprintk()`、`trace_vprintk()` 等底层追踪写入函数。\n- **模块子系统**：通过 `module_notifier` 机制监听模块状态变化（`MODULE_STATE_COMING`）。\n- **内存管理**：使用 `kmalloc`/`kfree` 管理模块格式字符串的动态内存。\n- **debugfs**：通过 `seq_file` 接口向用户空间暴露格式字符串映射信息。\n- **编译器支持**：依赖链接脚本生成的 `__start___trace_bprintk_fmt`、`__stop___trace_bprintk_fmt` 等符号。\n\n## 使用场景\n\n1. **内核开发者调试**：  \n   在内核代码中插入 `trace_printk(\"var=%d\", val)`，通过 `trace-cmd record -e printk` 捕获低开销的二进制追踪事件。\n\n2. **动态模块追踪**：  \n   内核模块使用 `trace_printk` 时，其格式字符串被自动持久化，即使模块卸载后，历史追踪数据仍可被正确解析。\n\n3. **用户空间工具解析**：  \n   `trace-cmd`、`perf` 等工具读取 `/sys/kernel/debug/tracing/printk_formats`，将追踪缓冲区中的格式地址转换为可读字符串。\n\n4. **生产环境控制**：  \n   通过 `trace_printk_control(false)` 在生产系统中禁用 `trace_printk`，避免意外启用导致的性能损耗或缓冲区污染。",
      "similarity": 0.5295677185058594,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/trace/trace_printk.c",
          "start_line": 245,
          "end_line": 329,
          "content": [
            "int __ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap)",
            "{",
            "\tif (!trace_printk_enabled)",
            "\t\treturn 0;",
            "",
            "\treturn trace_vprintk(ip, fmt, ap);",
            "}",
            "bool trace_is_tracepoint_string(const char *str)",
            "{",
            "\tconst char **ptr = __start___tracepoint_str;",
            "",
            "\tfor (ptr = __start___tracepoint_str; ptr < __stop___tracepoint_str; ptr++) {",
            "\t\tif (str == *ptr)",
            "\t\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "static int t_show(struct seq_file *m, void *v)",
            "{",
            "\tconst char **fmt = v;",
            "\tconst char *str = *fmt;",
            "\tint i;",
            "",
            "\tif (!*fmt)",
            "\t\treturn 0;",
            "",
            "\tseq_printf(m, \"0x%lx : \\\"\", *(unsigned long *)fmt);",
            "",
            "\t/*",
            "\t * Tabs and new lines need to be converted.",
            "\t */",
            "\tfor (i = 0; str[i]; i++) {",
            "\t\tswitch (str[i]) {",
            "\t\tcase '\\n':",
            "\t\t\tseq_puts(m, \"\\\\n\");",
            "\t\t\tbreak;",
            "\t\tcase '\\t':",
            "\t\t\tseq_puts(m, \"\\\\t\");",
            "\t\t\tbreak;",
            "\t\tcase '\\\\':",
            "\t\t\tseq_putc(m, '\\\\');",
            "\t\t\tbreak;",
            "\t\tcase '\"':",
            "\t\t\tseq_puts(m, \"\\\\\\\"\");",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tseq_putc(m, str[i]);",
            "\t\t}",
            "\t}",
            "\tseq_puts(m, \"\\\"\\n\");",
            "",
            "\treturn 0;",
            "}",
            "static void t_stop(struct seq_file *m, void *p)",
            "{",
            "\tformat_mod_stop();",
            "}",
            "static int",
            "ftrace_formats_open(struct inode *inode, struct file *file)",
            "{",
            "\tint ret;",
            "",
            "\tret = security_locked_down(LOCKDOWN_TRACEFS);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn seq_open(file, &show_format_seq_ops);",
            "}",
            "static __init int init_trace_printk_function_export(void)",
            "{",
            "\tint ret;",
            "",
            "\tret = tracing_init_dentry();",
            "\tif (ret)",
            "\t\treturn 0;",
            "",
            "\ttrace_create_file(\"printk_formats\", TRACE_MODE_READ, NULL,",
            "\t\t\t\t    NULL, &ftrace_formats_fops);",
            "",
            "\treturn 0;",
            "}",
            "static __init int init_trace_printk(void)",
            "{",
            "\treturn register_module_notifier(&module_trace_bprintk_format_nb);",
            "}"
          ],
          "function_name": "__ftrace_vprintk, trace_is_tracepoint_string, t_show, t_stop, ftrace_formats_open, init_trace_printk_function_export, init_trace_printk",
          "description": "提供了跟踪点字符串验证、格式展示序列化操作、文件系统节点创建及初始化入口点，支持跟踪格式的动态加载与访问。",
          "similarity": 0.5500489473342896
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/trace_printk.c",
          "start_line": 52,
          "end_line": 158,
          "content": [
            "static",
            "void hold_module_trace_bprintk_format(const char **start, const char **end)",
            "{",
            "\tconst char **iter;",
            "\tchar *fmt;",
            "",
            "\t/* allocate the trace_printk per cpu buffers */",
            "\tif (start != end)",
            "\t\ttrace_printk_init_buffers();",
            "",
            "\tmutex_lock(&btrace_mutex);",
            "\tfor (iter = start; iter < end; iter++) {",
            "\t\tstruct trace_bprintk_fmt *tb_fmt = lookup_format(*iter);",
            "\t\tif (tb_fmt) {",
            "\t\t\tif (!IS_ERR(tb_fmt))",
            "\t\t\t\t*iter = tb_fmt->fmt;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tfmt = NULL;",
            "\t\ttb_fmt = kmalloc(sizeof(*tb_fmt), GFP_KERNEL);",
            "\t\tif (tb_fmt) {",
            "\t\t\tfmt = kmalloc(strlen(*iter) + 1, GFP_KERNEL);",
            "\t\t\tif (fmt) {",
            "\t\t\t\tlist_add_tail(&tb_fmt->list, &trace_bprintk_fmt_list);",
            "\t\t\t\tstrcpy(fmt, *iter);",
            "\t\t\t\ttb_fmt->fmt = fmt;",
            "\t\t\t} else",
            "\t\t\t\tkfree(tb_fmt);",
            "\t\t}",
            "\t\t*iter = fmt;",
            "",
            "\t}",
            "\tmutex_unlock(&btrace_mutex);",
            "}",
            "static int module_trace_bprintk_format_notify(struct notifier_block *self,",
            "\t\tunsigned long val, void *data)",
            "{",
            "\tstruct module *mod = data;",
            "\tif (mod->num_trace_bprintk_fmt) {",
            "\t\tconst char **start = mod->trace_bprintk_fmt_start;",
            "\t\tconst char **end = start + mod->num_trace_bprintk_fmt;",
            "",
            "\t\tif (val == MODULE_STATE_COMING)",
            "\t\t\thold_module_trace_bprintk_format(start, end);",
            "\t}",
            "\treturn NOTIFY_OK;",
            "}",
            "static void format_mod_start(void)",
            "{",
            "\tmutex_lock(&btrace_mutex);",
            "}",
            "static void format_mod_stop(void)",
            "{",
            "\tmutex_unlock(&btrace_mutex);",
            "}",
            "__init static int",
            "module_trace_bprintk_format_notify(struct notifier_block *self,",
            "\t\tunsigned long val, void *data)",
            "{",
            "\treturn NOTIFY_OK;",
            "}",
            "static inline void format_mod_start(void) { }",
            "static inline void format_mod_stop(void) { }",
            "void trace_printk_control(bool enabled)",
            "{",
            "\ttrace_printk_enabled = enabled;",
            "}",
            "int __trace_bprintk(unsigned long ip, const char *fmt, ...)",
            "{",
            "\tint ret;",
            "\tva_list ap;",
            "",
            "\tif (unlikely(!fmt))",
            "\t\treturn 0;",
            "",
            "\tif (!trace_printk_enabled)",
            "\t\treturn 0;",
            "",
            "\tva_start(ap, fmt);",
            "\tret = trace_vbprintk(ip, fmt, ap);",
            "\tva_end(ap);",
            "\treturn ret;",
            "}",
            "int __ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap)",
            "{",
            "\tif (unlikely(!fmt))",
            "\t\treturn 0;",
            "",
            "\tif (!trace_printk_enabled)",
            "\t\treturn 0;",
            "",
            "\treturn trace_vbprintk(ip, fmt, ap);",
            "}",
            "int __trace_printk(unsigned long ip, const char *fmt, ...)",
            "{",
            "\tint ret;",
            "\tva_list ap;",
            "",
            "\tif (!trace_printk_enabled)",
            "\t\treturn 0;",
            "",
            "\tva_start(ap, fmt);",
            "\tret = trace_vprintk(ip, fmt, ap);",
            "\tva_end(ap);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "hold_module_trace_bprintk_format, module_trace_bprintk_format_notify, format_mod_start, format_mod_stop, module_trace_bprintk_format_notify, format_mod_start, format_mod_stop, trace_printk_control, __trace_bprintk, __ftrace_vbprintk, __trace_printk",
          "description": "实现了模块格式动态注册与追踪控制逻辑，包含格式缓存管理、打印使能开关、以及多层级的打印函数实现。",
          "similarity": 0.5446280241012573
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/trace/trace_printk.c",
          "start_line": 1,
          "end_line": 51,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * trace binary printk",
            " *",
            " * Copyright (C) 2008 Lai Jiangshan <laijs@cn.fujitsu.com>",
            " *",
            " */",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "",
            "#include \"trace.h\"",
            "",
            "#ifdef CONFIG_MODULES",
            "",
            "/*",
            " * modules trace_printk()'s formats are autosaved in struct trace_bprintk_fmt",
            " * which are queued on trace_bprintk_fmt_list.",
            " */",
            "static LIST_HEAD(trace_bprintk_fmt_list);",
            "",
            "/* serialize accesses to trace_bprintk_fmt_list */",
            "static DEFINE_MUTEX(btrace_mutex);",
            "",
            "struct trace_bprintk_fmt {",
            "\tstruct list_head list;",
            "\tconst char *fmt;",
            "};",
            "",
            "static inline struct trace_bprintk_fmt *lookup_format(const char *fmt)",
            "{",
            "\tstruct trace_bprintk_fmt *pos;",
            "",
            "\tif (!fmt)",
            "\t\treturn ERR_PTR(-EINVAL);",
            "",
            "\tlist_for_each_entry(pos, &trace_bprintk_fmt_list, list) {",
            "\t\tif (!strcmp(pos->fmt, fmt))",
            "\t\t\treturn pos;",
            "\t}",
            "\treturn NULL;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了用于管理模块中trace printk格式的链表结构和相关辅助函数，包括格式查找逻辑及线程安全互斥锁保护。",
          "similarity": 0.4775797128677368
        }
      ]
    }
  ]
}