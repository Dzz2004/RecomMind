{
  "query": "DMA在驱动程序中的作用",
  "timestamp": "2025-12-25 23:50:52",
  "retrieved_files": [
    {
      "source_file": "kernel/dma/debug.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:11:41\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `dma\\debug.c`\n\n---\n\n# `dma/debug.c` 技术文档\n\n## 1. 文件概述\n\n`dma/debug.c` 是 Linux 内核中用于调试 DMA（Direct Memory Access）API 使用错误的核心模块。该文件实现了对 `dma_map_*`、`dma_unmap_*`、`dma_alloc_coherent` 等 DMA 操作的运行时跟踪与验证机制，旨在检测常见的 DMA 编程错误，例如：\n\n- 重复映射或重复释放\n- 未配对的映射/解除映射操作\n- 越界访问\n- 未检查 `dma_mapping_error()` 返回值\n\n当检测到违规行为时，该模块会输出详细的错误信息（包括设备信息、DMA 地址、操作类型、调用栈等），帮助开发者定位问题。该功能通过 `CONFIG_DMA_API_DEBUG` 配置选项启用，主要用于开发和调试阶段。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct dma_debug_entry`**  \n  表示一个 DMA 映射记录，包含设备指针、DMA 地址、大小、方向、类型（single/sg/coherent/resource）、页帧号、偏移量、错误检查状态及调用栈信息。\n\n- **`struct hash_bucket`**  \n  哈希桶结构，包含一个链表头和自旋锁，用于并发安全地管理哈希表中的 DMA 条目。\n\n- **全局变量**\n  - `dma_entry_hash[HASH_SIZE]`：哈希表，用于快速查找 DMA 映射条目。\n  - `free_entries`：预分配的空闲 `dma_debug_entry` 链表。\n  - `global_disable`：全局禁用标志，一旦发生严重错误即关闭调试功能。\n  - `error_count`：累计错误计数。\n  - `show_num_errors` / `show_all_errors`：控制错误输出数量。\n  - `current_driver_name` / `current_driver`：支持按驱动名称过滤错误输出。\n\n### 主要函数与宏\n\n- **`hash_fn()`**：基于 DMA 地址的哈希函数（使用 bits 20–27）。\n- **`get_hash_bucket()` / `put_hash_bucket()`**：获取/释放哈希桶的自旋锁，支持中断上下文安全。\n- **`exact_match()` / `containing_match()`**：用于在哈希链表中匹配条目（精确匹配或包含匹配）。\n- **`driver_filter()`**：根据当前设置的驱动名过滤错误报告。\n- **`err_printk()`**：错误打印宏，自动递增错误计数、应用过滤规则、打印警告及调用栈。\n- **`dump_entry_trace()`**：在支持 `CONFIG_STACKTRACE` 时打印 DMA 映射时的调用栈。\n\n### 枚举类型\n\n- **DMA 类型枚举**：\n  - `dma_debug_single`\n  - `dma_debug_sg`\n  - `dma_debug_coherent`\n  - `dma_debug_resource`\n\n- **映射错误检查状态**：\n  - `MAP_ERR_CHECK_NOT_APPLICABLE`\n  - `MAP_ERR_NOT_CHECKED`\n  - `MAP_ERR_CHECKED`\n\n## 3. 关键实现\n\n### 哈希表设计\n\n- 使用大小为 16384（`HASH_SIZE`）的静态哈希表。\n- 哈希函数 `hash_fn()` 通过右移 13 位（`HASH_FN_SHIFT`）并掩码 `0x3FFF` 提取地址中间位，以减少冲突。\n- 每个桶（`hash_bucket`）配备独立自旋锁，支持高并发访问。\n\n### 内存管理\n\n- 启动时预分配 `PREALLOC_DMA_DEBUG_ENTRIES`（65536）个 `dma_debug_entry`。\n- 若池耗尽，动态按页分配（每页可容纳 `DMA_DEBUG_DYNAMIC_ENTRIES` 个条目）。\n- 使用 `free_entries` 链表和 `free_entries_lock` 管理空闲条目。\n\n### 错误抑制与过滤\n\n- 通过 `show_num_errors` 限制初始错误输出数量（默认 1），避免日志爆炸。\n- 支持通过 debugfs 动态设置 `show_all_errors` 以显示所有错误。\n- `driver_filter()` 允许用户指定只监控特定驱动的 DMA 操作，提升调试效率。\n\n### 调用栈追踪\n\n- 在 `CONFIG_STACKTRACE` 启用时，每个 `dma_debug_entry` 记录最多 5 层调用栈（`DMA_DEBUG_STACKTRACE_ENTRIES`）。\n- 出错时通过 `dump_entry_trace()` 打印映射发生的位置，极大提升问题定位能力。\n\n### 线程安全\n\n- 哈希桶使用 `spin_lock_irqsave`/`spin_unlock_irqrestore` 保证中断上下文安全。\n- 全局状态变量（如 `error_count`）虽存在竞态，但设计上容忍轻微不一致（如少计错误），以避免性能开销。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/dma-map-ops.h>`：DMA 映射操作接口。\n  - `<linux/stacktrace.h>`：调用栈记录支持。\n  - `<linux/debugfs.h>`：用于暴露调试参数（如错误数量、驱动过滤器）。\n  - `<linux/scatterlist.h>`：SG 列表相关定义。\n  - `<asm/sections.h>`：内核段信息（可能用于地址合法性检查）。\n\n- **配置依赖**：\n  - 由 `CONFIG_DMA_API_DEBUG` 控制编译。\n  - `CONFIG_STACKTRACE` 决定是否启用调用栈记录。\n\n- **与其他模块交互**：\n  - 与 `dma-mapping.c` 紧密集成，在 `dma_map_*` / `dma_unmap_*` 等函数中调用本模块的钩子函数（如 `dma_debug_add()`、`dma_debug_remove()` 等，虽未在本片段中展示）。\n  - 通过 `device` 和 `device_driver` 结构与设备模型交互，实现驱动级过滤。\n\n## 5. 使用场景\n\n- **内核开发与调试**：在开发新驱动或修改 DMA 代码时启用，检测潜在的 DMA 使用错误。\n- **系统稳定性分析**：在出现内存损坏、设备异常时，开启 DMA 调试以排查是否由 DMA 操作不当引起。\n- **CI/测试环境**：在自动化测试中启用 `CONFIG_DMA_API_DEBUG`，作为静态检查的补充，捕获运行时错误。\n- **生产环境（谨慎）**：通常不在生产内核中启用，因其带来显著内存与性能开销；但在特定高可靠性场景下可临时开启用于问题复现。\n\n该模块是 Linux 内核 DMA 子系统的重要调试基础设施，显著提升了 DMA 相关 bug 的可发现性和可诊断性。",
      "similarity": 0.6667143702507019,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/dma/debug.c",
          "start_line": 105,
          "end_line": 209,
          "content": [
            "static inline bool dma_debug_disabled(void)",
            "{",
            "\treturn global_disable || !dma_debug_initialized;",
            "}",
            "static inline void dump_entry_trace(struct dma_debug_entry *entry)",
            "{",
            "#ifdef CONFIG_STACKTRACE",
            "\tif (entry) {",
            "\t\tpr_warn(\"Mapped at:\\n\");",
            "\t\tstack_trace_print(entry->stack_entries, entry->stack_len, 0);",
            "\t}",
            "#endif",
            "}",
            "static bool driver_filter(struct device *dev)",
            "{",
            "\tstruct device_driver *drv;",
            "\tunsigned long flags;",
            "\tbool ret;",
            "",
            "\t/* driver filter off */",
            "\tif (likely(!current_driver_name[0]))",
            "\t\treturn true;",
            "",
            "\t/* driver filter on and initialized */",
            "\tif (current_driver && dev && dev->driver == current_driver)",
            "\t\treturn true;",
            "",
            "\t/* driver filter on, but we can't filter on a NULL device... */",
            "\tif (!dev)",
            "\t\treturn false;",
            "",
            "\tif (current_driver || !current_driver_name[0])",
            "\t\treturn false;",
            "",
            "\t/* driver filter on but not yet initialized */",
            "\tdrv = dev->driver;",
            "\tif (!drv)",
            "\t\treturn false;",
            "",
            "\t/* lock to protect against change of current_driver_name */",
            "\tread_lock_irqsave(&driver_name_lock, flags);",
            "",
            "\tret = false;",
            "\tif (drv->name &&",
            "\t    strncmp(current_driver_name, drv->name, NAME_MAX_LEN - 1) == 0) {",
            "\t\tcurrent_driver = drv;",
            "\t\tret = true;",
            "\t}",
            "",
            "\tread_unlock_irqrestore(&driver_name_lock, flags);",
            "",
            "\treturn ret;",
            "}",
            "static int hash_fn(struct dma_debug_entry *entry)",
            "{",
            "\t/*",
            "\t * Hash function is based on the dma address.",
            "\t * We use bits 20-27 here as the index into the hash",
            "\t */",
            "\treturn (entry->dev_addr >> HASH_FN_SHIFT) & HASH_FN_MASK;",
            "}",
            "static void put_hash_bucket(struct hash_bucket *bucket,",
            "\t\t\t    unsigned long flags)",
            "\t__releases(&bucket->lock)",
            "{",
            "\tspin_unlock_irqrestore(&bucket->lock, flags);",
            "}",
            "static bool exact_match(struct dma_debug_entry *a, struct dma_debug_entry *b)",
            "{",
            "\treturn ((a->dev_addr == b->dev_addr) &&",
            "\t\t(a->dev == b->dev)) ? true : false;",
            "}",
            "static bool containing_match(struct dma_debug_entry *a,",
            "\t\t\t     struct dma_debug_entry *b)",
            "{",
            "\tif (a->dev != b->dev)",
            "\t\treturn false;",
            "",
            "\tif ((b->dev_addr <= a->dev_addr) &&",
            "\t    ((b->dev_addr + b->size) >= (a->dev_addr + a->size)))",
            "\t\treturn true;",
            "",
            "\treturn false;",
            "}",
            "static void hash_bucket_add(struct hash_bucket *bucket,",
            "\t\t\t    struct dma_debug_entry *entry)",
            "{",
            "\tlist_add_tail(&entry->list, &bucket->list);",
            "}",
            "static void hash_bucket_del(struct dma_debug_entry *entry)",
            "{",
            "\tlist_del(&entry->list);",
            "}",
            "static unsigned long long phys_addr(struct dma_debug_entry *entry)",
            "{",
            "\tif (entry->type == dma_debug_resource)",
            "\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;",
            "",
            "\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;",
            "}",
            "static phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)",
            "{",
            "\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +",
            "\t\t(entry->offset >> L1_CACHE_SHIFT);",
            "}"
          ],
          "function_name": "dma_debug_disabled, dump_entry_trace, driver_filter, hash_fn, put_hash_bucket, exact_match, containing_match, hash_bucket_add, hash_bucket_del, phys_addr, to_cacheline_number",
          "description": "实现DMA调试的核心控制逻辑，包括驱动过滤判断、哈希函数计算、缓存行重叠检测及映射条目增删操作，支持对DMA地址的快速查找与冲突检测。",
          "similarity": 0.6267791390419006
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/dma/debug.c",
          "start_line": 1063,
          "end_line": 1169,
          "content": [
            "static void check_for_stack(struct device *dev,",
            "\t\t\t    struct page *page, size_t offset)",
            "{",
            "\tvoid *addr;",
            "\tstruct vm_struct *stack_vm_area = task_stack_vm_area(current);",
            "",
            "\tif (!stack_vm_area) {",
            "\t\t/* Stack is direct-mapped. */",
            "\t\tif (PageHighMem(page))",
            "\t\t\treturn;",
            "\t\taddr = page_address(page) + offset;",
            "\t\tif (object_is_on_stack(addr))",
            "\t\t\terr_printk(dev, NULL, \"device driver maps memory from stack [addr=%p]\\n\", addr);",
            "\t} else {",
            "\t\t/* Stack is vmalloced. */",
            "\t\tint i;",
            "",
            "\t\tfor (i = 0; i < stack_vm_area->nr_pages; i++) {",
            "\t\t\tif (page != stack_vm_area->pages[i])",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\taddr = (u8 *)current->stack + i * PAGE_SIZE + offset;",
            "\t\t\terr_printk(dev, NULL, \"device driver maps memory from stack [probable addr=%p]\\n\", addr);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "}",
            "static void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)",
            "{",
            "\tif (memory_intersects(_stext, _etext, addr, len) ||",
            "\t    memory_intersects(__start_rodata, __end_rodata, addr, len))",
            "\t\terr_printk(dev, NULL, \"device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\", addr, len);",
            "}",
            "static void check_sync(struct device *dev,",
            "\t\t       struct dma_debug_entry *ref,",
            "\t\t       bool to_cpu)",
            "{",
            "\tstruct dma_debug_entry *entry;",
            "\tstruct hash_bucket *bucket;",
            "\tunsigned long flags;",
            "",
            "\tbucket = get_hash_bucket(ref, &flags);",
            "",
            "\tentry = bucket_find_contain(&bucket, ref, &flags);",
            "",
            "\tif (!entry) {",
            "\t\terr_printk(dev, NULL, \"device driver tries \"",
            "\t\t\t\t\"to sync DMA memory it has not allocated \"",
            "\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",",
            "\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (ref->size > entry->size) {",
            "\t\terr_printk(dev, entry, \"device driver syncs\"",
            "\t\t\t\t\" DMA memory outside allocated range \"",
            "\t\t\t\t\"[device address=0x%016llx] \"",
            "\t\t\t\t\"[allocation size=%llu bytes] \"",
            "\t\t\t\t\"[sync offset+size=%llu]\\n\",",
            "\t\t\t\tentry->dev_addr, entry->size,",
            "\t\t\t\tref->size);",
            "\t}",
            "",
            "\tif (entry->direction == DMA_BIDIRECTIONAL)",
            "\t\tgoto out;",
            "",
            "\tif (ref->direction != entry->direction) {",
            "\t\terr_printk(dev, entry, \"device driver syncs \"",
            "\t\t\t\t\"DMA memory with different direction \"",
            "\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"",
            "\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",",
            "\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,",
            "\t\t\t\tdir2name[entry->direction],",
            "\t\t\t\tdir2name[ref->direction]);",
            "\t}",
            "",
            "\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&",
            "\t\t      !(ref->direction == DMA_TO_DEVICE))",
            "\t\terr_printk(dev, entry, \"device driver syncs \"",
            "\t\t\t\t\"device read-only DMA memory for cpu \"",
            "\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"",
            "\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",",
            "\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,",
            "\t\t\t\tdir2name[entry->direction],",
            "\t\t\t\tdir2name[ref->direction]);",
            "",
            "\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&",
            "\t\t       !(ref->direction == DMA_FROM_DEVICE))",
            "\t\terr_printk(dev, entry, \"device driver syncs \"",
            "\t\t\t\t\"device write-only DMA memory to device \"",
            "\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"",
            "\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",",
            "\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,",
            "\t\t\t\tdir2name[entry->direction],",
            "\t\t\t\tdir2name[ref->direction]);",
            "",
            "\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&",
            "\t    ref->sg_call_ents != entry->sg_call_ents) {",
            "\t\terr_printk(ref->dev, entry, \"device driver syncs \"",
            "\t\t\t   \"DMA sg list with different entry count \"",
            "\t\t\t   \"[map count=%d] [sync count=%d]\\n\",",
            "\t\t\t   entry->sg_call_ents, ref->sg_call_ents);",
            "\t}",
            "",
            "out:",
            "\tput_hash_bucket(bucket, flags);",
            "}"
          ],
          "function_name": "check_for_stack, check_for_illegal_area, check_sync",
          "description": "检查DMA映射是否来自栈内存或内核只读区，验证同步操作的方向一致性，防止非法内存访问和错误的DMA同步行为",
          "similarity": 0.6096843481063843
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/dma/debug.c",
          "start_line": 1394,
          "end_line": 1510,
          "content": [
            "void debug_dma_alloc_coherent(struct device *dev, size_t size,",
            "\t\t\t      dma_addr_t dma_addr, void *virt,",
            "\t\t\t      unsigned long attrs)",
            "{",
            "\tstruct dma_debug_entry *entry;",
            "",
            "\tif (unlikely(dma_debug_disabled()))",
            "\t\treturn;",
            "",
            "\tif (unlikely(virt == NULL))",
            "\t\treturn;",
            "",
            "\t/* handle vmalloc and linear addresses */",
            "\tif (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))",
            "\t\treturn;",
            "",
            "\tentry = dma_entry_alloc();",
            "\tif (!entry)",
            "\t\treturn;",
            "",
            "\tentry->type      = dma_debug_coherent;",
            "\tentry->dev       = dev;",
            "\tentry->offset\t = offset_in_page(virt);",
            "\tentry->size      = size;",
            "\tentry->dev_addr  = dma_addr;",
            "\tentry->direction = DMA_BIDIRECTIONAL;",
            "",
            "\tif (is_vmalloc_addr(virt))",
            "\t\tentry->pfn = vmalloc_to_pfn(virt);",
            "\telse",
            "\t\tentry->pfn = page_to_pfn(virt_to_page(virt));",
            "",
            "\tadd_dma_entry(entry, attrs);",
            "}",
            "void debug_dma_free_coherent(struct device *dev, size_t size,",
            "\t\t\t void *virt, dma_addr_t dma_addr)",
            "{",
            "\tstruct dma_debug_entry ref = {",
            "\t\t.type           = dma_debug_coherent,",
            "\t\t.dev            = dev,",
            "\t\t.offset\t\t= offset_in_page(virt),",
            "\t\t.dev_addr       = dma_addr,",
            "\t\t.size           = size,",
            "\t\t.direction      = DMA_BIDIRECTIONAL,",
            "\t};",
            "",
            "\t/* handle vmalloc and linear addresses */",
            "\tif (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))",
            "\t\treturn;",
            "",
            "\tif (is_vmalloc_addr(virt))",
            "\t\tref.pfn = vmalloc_to_pfn(virt);",
            "\telse",
            "\t\tref.pfn = page_to_pfn(virt_to_page(virt));",
            "",
            "\tif (unlikely(dma_debug_disabled()))",
            "\t\treturn;",
            "",
            "\tcheck_unmap(&ref);",
            "}",
            "void debug_dma_map_resource(struct device *dev, phys_addr_t addr, size_t size,",
            "\t\t\t    int direction, dma_addr_t dma_addr,",
            "\t\t\t    unsigned long attrs)",
            "{",
            "\tstruct dma_debug_entry *entry;",
            "",
            "\tif (unlikely(dma_debug_disabled()))",
            "\t\treturn;",
            "",
            "\tentry = dma_entry_alloc();",
            "\tif (!entry)",
            "\t\treturn;",
            "",
            "\tentry->type\t\t= dma_debug_resource;",
            "\tentry->dev\t\t= dev;",
            "\tentry->pfn\t\t= PHYS_PFN(addr);",
            "\tentry->offset\t\t= offset_in_page(addr);",
            "\tentry->size\t\t= size;",
            "\tentry->dev_addr\t\t= dma_addr;",
            "\tentry->direction\t= direction;",
            "\tentry->map_err_type\t= MAP_ERR_NOT_CHECKED;",
            "",
            "\tadd_dma_entry(entry, attrs);",
            "}",
            "void debug_dma_unmap_resource(struct device *dev, dma_addr_t dma_addr,",
            "\t\t\t      size_t size, int direction)",
            "{",
            "\tstruct dma_debug_entry ref = {",
            "\t\t.type           = dma_debug_resource,",
            "\t\t.dev            = dev,",
            "\t\t.dev_addr       = dma_addr,",
            "\t\t.size           = size,",
            "\t\t.direction      = direction,",
            "\t};",
            "",
            "\tif (unlikely(dma_debug_disabled()))",
            "\t\treturn;",
            "",
            "\tcheck_unmap(&ref);",
            "}",
            "void debug_dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle,",
            "\t\t\t\t   size_t size, int direction)",
            "{",
            "\tstruct dma_debug_entry ref;",
            "",
            "\tif (unlikely(dma_debug_disabled()))",
            "\t\treturn;",
            "",
            "\tref.type         = dma_debug_single;",
            "\tref.dev          = dev;",
            "\tref.dev_addr     = dma_handle;",
            "\tref.size         = size;",
            "\tref.direction    = direction;",
            "\tref.sg_call_ents = 0;",
            "",
            "\tcheck_sync(dev, &ref, true);",
            "}"
          ],
          "function_name": "debug_dma_alloc_coherent, debug_dma_free_coherent, debug_dma_map_resource, debug_dma_unmap_resource, debug_dma_sync_single_for_cpu",
          "description": "追踪一致性内存和资源映射操作，验证CPU-设备数据同步方向，确保DMA资源分配/释放与映射记录的一致性",
          "similarity": 0.6007137298583984
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/dma/debug.c",
          "start_line": 1,
          "end_line": 104,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (C) 2008 Advanced Micro Devices, Inc.",
            " *",
            " * Author: Joerg Roedel <joerg.roedel@amd.com>",
            " */",
            "",
            "#define pr_fmt(fmt)\t\"DMA-API: \" fmt",
            "",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <asm/sections.h>",
            "#include \"debug.h\"",
            "",
            "#define HASH_SIZE       16384ULL",
            "#define HASH_FN_SHIFT   13",
            "#define HASH_FN_MASK    (HASH_SIZE - 1)",
            "",
            "#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)",
            "/* If the pool runs out, add this many new entries at once */",
            "#define DMA_DEBUG_DYNAMIC_ENTRIES (PAGE_SIZE / sizeof(struct dma_debug_entry))",
            "",
            "enum {",
            "\tdma_debug_single,",
            "\tdma_debug_sg,",
            "\tdma_debug_coherent,",
            "\tdma_debug_resource,",
            "};",
            "",
            "enum map_err_types {",
            "\tMAP_ERR_CHECK_NOT_APPLICABLE,",
            "\tMAP_ERR_NOT_CHECKED,",
            "\tMAP_ERR_CHECKED,",
            "};",
            "",
            "#define DMA_DEBUG_STACKTRACE_ENTRIES 5",
            "",
            "/**",
            " * struct dma_debug_entry - track a dma_map* or dma_alloc_coherent mapping",
            " * @list: node on pre-allocated free_entries list",
            " * @dev: 'dev' argument to dma_map_{page|single|sg} or dma_alloc_coherent",
            " * @dev_addr: dma address",
            " * @size: length of the mapping",
            " * @type: single, page, sg, coherent",
            " * @direction: enum dma_data_direction",
            " * @sg_call_ents: 'nents' from dma_map_sg",
            " * @sg_mapped_ents: 'mapped_ents' from dma_map_sg",
            " * @pfn: page frame of the start address",
            " * @offset: offset of mapping relative to pfn",
            " * @map_err_type: track whether dma_mapping_error() was checked",
            " * @stacktrace: support backtraces when a violation is detected",
            " */",
            "struct dma_debug_entry {",
            "\tstruct list_head list;",
            "\tstruct device    *dev;",
            "\tu64              dev_addr;",
            "\tu64              size;",
            "\tint              type;",
            "\tint              direction;",
            "\tint\t\t sg_call_ents;",
            "\tint\t\t sg_mapped_ents;",
            "\tunsigned long\t pfn;",
            "\tsize_t\t\t offset;",
            "\tenum map_err_types  map_err_type;",
            "#ifdef CONFIG_STACKTRACE",
            "\tunsigned int\tstack_len;",
            "\tunsigned long\tstack_entries[DMA_DEBUG_STACKTRACE_ENTRIES];",
            "#endif",
            "} ____cacheline_aligned_in_smp;",
            "",
            "typedef bool (*match_fn)(struct dma_debug_entry *, struct dma_debug_entry *);",
            "",
            "struct hash_bucket {",
            "\tstruct list_head list;",
            "\tspinlock_t lock;",
            "};",
            "",
            "/* Hash list to save the allocated dma addresses */",
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];",
            "/* List of pre-allocated dma_debug_entry's */",
            "static LIST_HEAD(free_entries);",
            "/* Lock for the list above */",
            "static DEFINE_SPINLOCK(free_entries_lock);",
            "",
            "/* Global disable flag - will be set in case of an error */",
            "static bool global_disable __read_mostly;",
            "",
            "/* Early initialization disable flag, set at the end of dma_debug_init */",
            "static bool dma_debug_initialized __read_mostly;",
            ""
          ],
          "function_name": null,
          "description": "定义DMA调试模块的全局数据结构和基础配置，包括哈希表参数、预分配条目池及用于跟踪DMA映射的链表结构，声明dma_debug_entry结构体以保存映射信息，并初始化相关锁和哈希桶数组。",
          "similarity": 0.5858322381973267
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/dma/debug.c",
          "start_line": 882,
          "end_line": 1053,
          "content": [
            "void dma_debug_add_bus(const struct bus_type *bus)",
            "{",
            "\tstruct notifier_block *nb;",
            "",
            "\tif (dma_debug_disabled())",
            "\t\treturn;",
            "",
            "\tnb = kzalloc(sizeof(struct notifier_block), GFP_KERNEL);",
            "\tif (nb == NULL) {",
            "\t\tpr_err(\"dma_debug_add_bus: out of memory\\n\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tnb->notifier_call = dma_debug_device_change;",
            "",
            "\tbus_register_notifier(bus, nb);",
            "}",
            "static int dma_debug_init(void)",
            "{",
            "\tint i, nr_pages;",
            "",
            "\t/* Do not use dma_debug_initialized here, since we really want to be",
            "\t * called to set dma_debug_initialized",
            "\t */",
            "\tif (global_disable)",
            "\t\treturn 0;",
            "",
            "\tfor (i = 0; i < HASH_SIZE; ++i) {",
            "\t\tINIT_LIST_HEAD(&dma_entry_hash[i].list);",
            "\t\tspin_lock_init(&dma_entry_hash[i].lock);",
            "\t}",
            "",
            "\tnr_pages = DIV_ROUND_UP(nr_prealloc_entries, DMA_DEBUG_DYNAMIC_ENTRIES);",
            "\tfor (i = 0; i < nr_pages; ++i)",
            "\t\tdma_debug_create_entries(GFP_KERNEL);",
            "\tif (num_free_entries >= nr_prealloc_entries) {",
            "\t\tpr_info(\"preallocated %d debug entries\\n\", nr_total_entries);",
            "\t} else if (num_free_entries > 0) {",
            "\t\tpr_warn(\"%d debug entries requested but only %d allocated\\n\",",
            "\t\t\tnr_prealloc_entries, nr_total_entries);",
            "\t} else {",
            "\t\tpr_err(\"debugging out of memory error - disabled\\n\");",
            "\t\tglobal_disable = true;",
            "",
            "\t\treturn 0;",
            "\t}",
            "\tmin_free_entries = num_free_entries;",
            "",
            "\tdma_debug_initialized = true;",
            "",
            "\tpr_info(\"debugging enabled by kernel config\\n\");",
            "\treturn 0;",
            "}",
            "static __init int dma_debug_cmdline(char *str)",
            "{",
            "\tif (!str)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (strncmp(str, \"off\", 3) == 0) {",
            "\t\tpr_info(\"debugging disabled on kernel command line\\n\");",
            "\t\tglobal_disable = true;",
            "\t}",
            "",
            "\treturn 1;",
            "}",
            "static __init int dma_debug_entries_cmdline(char *str)",
            "{",
            "\tif (!str)",
            "\t\treturn -EINVAL;",
            "\tif (!get_option(&str, &nr_prealloc_entries))",
            "\t\tnr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;",
            "\treturn 1;",
            "}",
            "static void check_unmap(struct dma_debug_entry *ref)",
            "{",
            "\tstruct dma_debug_entry *entry;",
            "\tstruct hash_bucket *bucket;",
            "\tunsigned long flags;",
            "",
            "\tbucket = get_hash_bucket(ref, &flags);",
            "\tentry = bucket_find_exact(bucket, ref);",
            "",
            "\tif (!entry) {",
            "\t\t/* must drop lock before calling dma_mapping_error */",
            "\t\tput_hash_bucket(bucket, flags);",
            "",
            "\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {",
            "\t\t\terr_printk(ref->dev, NULL,",
            "\t\t\t\t   \"device driver tries to free an \"",
            "\t\t\t\t   \"invalid DMA memory address\\n\");",
            "\t\t} else {",
            "\t\t\terr_printk(ref->dev, NULL,",
            "\t\t\t\t   \"device driver tries to free DMA \"",
            "\t\t\t\t   \"memory it has not allocated [device \"",
            "\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",",
            "\t\t\t\t   ref->dev_addr, ref->size);",
            "\t\t}",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (ref->size != entry->size) {",
            "\t\terr_printk(ref->dev, entry, \"device driver frees \"",
            "\t\t\t   \"DMA memory with different size \"",
            "\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"",
            "\t\t\t   \"[unmap size=%llu bytes]\\n\",",
            "\t\t\t   ref->dev_addr, entry->size, ref->size);",
            "\t}",
            "",
            "\tif (ref->type != entry->type) {",
            "\t\terr_printk(ref->dev, entry, \"device driver frees \"",
            "\t\t\t   \"DMA memory with wrong function \"",
            "\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"",
            "\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",",
            "\t\t\t   ref->dev_addr, ref->size,",
            "\t\t\t   type2name[entry->type], type2name[ref->type]);",
            "\t} else if ((entry->type == dma_debug_coherent) &&",
            "\t\t   (phys_addr(ref) != phys_addr(entry))) {",
            "\t\terr_printk(ref->dev, entry, \"device driver frees \"",
            "\t\t\t   \"DMA memory with different CPU address \"",
            "\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"",
            "\t\t\t   \"[cpu alloc address=0x%016llx] \"",
            "\t\t\t   \"[cpu free address=0x%016llx]\",",
            "\t\t\t   ref->dev_addr, ref->size,",
            "\t\t\t   phys_addr(entry),",
            "\t\t\t   phys_addr(ref));",
            "\t}",
            "",
            "\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&",
            "\t    ref->sg_call_ents != entry->sg_call_ents) {",
            "\t\terr_printk(ref->dev, entry, \"device driver frees \"",
            "\t\t\t   \"DMA sg list with different entry count \"",
            "\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",",
            "\t\t\t   entry->sg_call_ents, ref->sg_call_ents);",
            "\t}",
            "",
            "\t/*",
            "\t * This may be no bug in reality - but most implementations of the",
            "\t * DMA API don't handle this properly, so check for it here",
            "\t */",
            "\tif (ref->direction != entry->direction) {",
            "\t\terr_printk(ref->dev, entry, \"device driver frees \"",
            "\t\t\t   \"DMA memory with different direction \"",
            "\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"",
            "\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",",
            "\t\t\t   ref->dev_addr, ref->size,",
            "\t\t\t   dir2name[entry->direction],",
            "\t\t\t   dir2name[ref->direction]);",
            "\t}",
            "",
            "\t/*",
            "\t * Drivers should use dma_mapping_error() to check the returned",
            "\t * addresses of dma_map_single() and dma_map_page().",
            "\t * If not, print this warning message. See Documentation/core-api/dma-api.rst.",
            "\t */",
            "\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {",
            "\t\terr_printk(ref->dev, entry,",
            "\t\t\t   \"device driver failed to check map error\"",
            "\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"",
            "\t\t\t   \"[mapped as %s]\",",
            "\t\t\t   ref->dev_addr, ref->size,",
            "\t\t\t   type2name[entry->type]);",
            "\t}",
            "",
            "\thash_bucket_del(entry);",
            "\tput_hash_bucket(bucket, flags);",
            "",
            "\t/*",
            "\t * Free the entry outside of bucket_lock to avoid ABBA deadlocks",
            "\t * between that and radix_lock.",
            "\t */",
            "\tdma_entry_free(entry);",
            "}"
          ],
          "function_name": "dma_debug_add_bus, dma_debug_init, dma_debug_cmdline, dma_debug_entries_cmdline, check_unmap",
          "description": "注册DMA调试总线通知块，初始化调试条目缓存并处理命令行参数，通过check_unmap验证DMA解除映射操作的合法性，检测地址有效性及方向/大小不匹配等问题",
          "similarity": 0.5814239978790283
        }
      ]
    },
    {
      "source_file": "kernel/dma.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:09:28\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `dma.c`\n\n---\n\n# `dma.c` 技术文档\n\n## 1. 文件概述\n\n`dma.c` 是 Linux 内核中用于管理系统 DMA（Direct Memory Access，直接内存访问）通道分配的核心文件。它提供了一套简单的资源管理机制，允许多个设备驱动程序以互斥方式请求和释放有限的系统 DMA 通道资源。该实现灵感来源于 `irq.c`，主要用于传统的 ISA 架构下的 DMA 控制器（如 Intel 8237），在现代系统中主要用于兼容旧硬件或特定嵌入式平台。文件还支持通过 `/proc/dma` 接口向用户空间暴露当前 DMA 通道的使用情况。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct dma_chan`**  \n  表示一个 DMA 通道的状态：\n  - `int lock`：标志位，非零表示通道已被占用。\n  - `const char *device_id`：占用该通道的设备标识字符串，用于 `/proc/dma` 显示。\n\n- **`dma_chan_busy[MAX_DMA_CHANNELS]`**  \n  全局静态数组，记录每个 DMA 通道的占用状态。其中通道 4 被预设为 `\"cascade\"`（用于级联主从 DMA 控制器），并标记为已占用。\n\n- **`dma_spin_lock`**  \n  全局自旋锁（`DEFINE_SPINLOCK`），用于保护 DMA 通道分配/释放操作的原子性（尽管当前实现未显式使用该锁，但供外部模块使用）。\n\n### 主要函数\n\n- **`request_dma(unsigned int dmanr, const char *device_id)`**  \n  请求指定编号的 DMA 通道。若通道有效且空闲，则标记为占用并记录设备 ID；否则返回 `-EINVAL`（通道号越界）或 `-EBUSY`（已被占用）。\n\n- **`free_dma(unsigned int dmanr)`**  \n  释放指定编号的 DMA 通道。若通道已被占用，则将其标记为空闲；若尝试释放未占用或无效通道，会打印警告信息。\n\n- **`proc_dma_show(struct seq_file *m, void *v)`**  \n  用于生成 `/proc/dma` 文件内容，遍历 `dma_chan_busy` 数组，输出所有被占用通道的编号及其设备 ID。\n\n- **`proc_dma_init(void)`**  \n  初始化函数，在内核启动时注册 `/proc/dma` 文件。\n\n## 3. 关键实现\n\n- **原子性保障**：  \n  使用 `xchg()` 原子操作实现对 `dma_chan_busy[].lock` 的读-改-写，确保多 CPU 环境下 DMA 通道分配/释放的线程安全，避免竞态条件。\n\n- **资源分配策略**：  \n  采用简单的位标志数组管理通道状态。通道 4 固定保留用于 DMA 控制器级联（cascade），不可被普通设备申请。\n\n- **条件编译支持**：  \n  通过 `#ifdef MAX_DMA_CHANNELS` 判断平台是否支持传统 DMA。若未定义（如纯现代平台），则 `request_dma()` 直接返回 `-EINVAL`，`free_dma()` 为空操作。\n\n- **/proc 接口**：  \n  仅在 `CONFIG_PROC_FS` 启用时编译 `/proc/dma` 支持。使用 `proc_create_single()` 创建只读文件，通过 `seq_printf()` 安全输出通道使用信息。\n\n- **资源释放顺序建议**：  \n  注释中强调：若同时使用 DMA 和 IRQ，应先申请 IRQ 再申请 DMA，释放时则先释放 DMA 再释放 IRQ，以避免不必要的分配失败（尤其在引入更复杂同步机制后）。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<asm/dma.h>`：定义平台相关的 `MAX_DMA_CHANNELS` 等宏。\n  - `<linux/spinlock.h>`：提供自旋锁和原子操作支持。\n  - `<linux/proc_fs.h>`、`<linux/seq_file.h>`：用于 `/proc/dma` 实现。\n  - 其他通用内核头文件（如 `kernel.h`、`errno.h` 等）。\n\n- **导出符号**：  \n  通过 `EXPORT_SYMBOL` 导出以下符号供其他内核模块使用：\n  - `request_dma`\n  - `free_dma`\n  - `dma_spin_lock`（虽未在本文件中使用，但供外部同步）\n\n- **架构依赖**：  \n  仅在定义了 `MAX_DMA_CHANNELS` 的架构（如 x86、部分 ARM 平台）上启用实际功能；否则提供空实现。\n\n## 5. 使用场景\n\n- **传统 ISA 设备驱动**：  \n  如声卡（Sound Blaster）、软盘控制器、早期网卡等依赖 ISA DMA 通道的设备，在初始化时调用 `request_dma()` 获取通道，退出时调用 `free_dma()` 释放。\n\n- **内核调试与监控**：  \n  用户可通过 `cat /proc/dma` 查看当前系统中 DMA 通道的占用情况，辅助硬件调试或资源冲突排查。\n\n- **嵌入式或兼容性平台**：  \n  在仍使用传统 DMA 控制器的嵌入式系统中，作为底层 DMA 资源管理的基础组件。\n\n- **资源协调**：  \n  在多设备共享有限 DMA 通道的系统中，确保设备驱动按规范申请/释放资源，避免冲突。",
      "similarity": 0.6612467765808105,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/dma.c",
          "start_line": 1,
          "end_line": 69,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * linux/kernel/dma.c: A DMA channel allocator. Inspired by linux/kernel/irq.c.",
            " *",
            " * Written by Hennus Bergman, 1992.",
            " *",
            " * 1994/12/26: Changes by Alex Nash to fix a minor bug in /proc/dma.",
            " *   In the previous version the reported device could end up being wrong,",
            " *   if a device requested a DMA channel that was already in use.",
            " *   [It also happened to remove the sizeof(char *) == sizeof(int)",
            " *   assumption introduced because of those /proc/dma patches. -- Hennus]",
            " */",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/init.h>",
            "#include <asm/dma.h>",
            "",
            "",
            "",
            "/* A note on resource allocation:",
            " *",
            " * All drivers needing DMA channels, should allocate and release them",
            " * through the public routines `request_dma()' and `free_dma()'.",
            " *",
            " * In order to avoid problems, all processes should allocate resources in",
            " * the same sequence and release them in the reverse order.",
            " *",
            " * So, when allocating DMAs and IRQs, first allocate the IRQ, then the DMA.",
            " * When releasing them, first release the DMA, then release the IRQ.",
            " * If you don't, you may cause allocation requests to fail unnecessarily.",
            " * This doesn't really matter now, but it will once we get real semaphores",
            " * in the kernel.",
            " */",
            "",
            "",
            "DEFINE_SPINLOCK(dma_spin_lock);",
            "",
            "/*",
            " *\tIf our port doesn't define this it has no PC like DMA",
            " */",
            "",
            "#ifdef MAX_DMA_CHANNELS",
            "",
            "",
            "/* Channel n is busy iff dma_chan_busy[n].lock != 0.",
            " * DMA0 used to be reserved for DRAM refresh, but apparently not any more...",
            " * DMA4 is reserved for cascading.",
            " */",
            "",
            "struct dma_chan {",
            "\tint  lock;",
            "\tconst char *device_id;",
            "};",
            "",
            "static struct dma_chan dma_chan_busy[MAX_DMA_CHANNELS] = {",
            "\t[4] = { 1, \"cascade\" },",
            "};",
            "",
            "",
            "/**",
            " * request_dma - request and reserve a system DMA channel",
            " * @dmanr: DMA channel number",
            " * @device_id: reserving device ID string, used in /proc/dma",
            " */"
          ],
          "function_name": null,
          "description": "定义DMA通道管理的全局数据结构和辅助函数声明，包含DMA通道忙状态数组、锁变量及设备ID字符串，提供DMA资源分配与释放的公共接口原型",
          "similarity": 0.5963647961616516
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/dma.c",
          "start_line": 70,
          "end_line": 124,
          "content": [
            "int request_dma(unsigned int dmanr, const char * device_id)",
            "{",
            "\tif (dmanr >= MAX_DMA_CHANNELS)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (xchg(&dma_chan_busy[dmanr].lock, 1) != 0)",
            "\t\treturn -EBUSY;",
            "",
            "\tdma_chan_busy[dmanr].device_id = device_id;",
            "",
            "\t/* old flag was 0, now contains 1 to indicate busy */",
            "\treturn 0;",
            "} /* request_dma */",
            "void free_dma(unsigned int dmanr)",
            "{",
            "\tif (dmanr >= MAX_DMA_CHANNELS) {",
            "\t\tprintk(KERN_WARNING \"Trying to free DMA%d\\n\", dmanr);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (xchg(&dma_chan_busy[dmanr].lock, 0) == 0) {",
            "\t\tprintk(KERN_WARNING \"Trying to free free DMA%d\\n\", dmanr);",
            "\t\treturn;",
            "\t}",
            "",
            "} /* free_dma */",
            "int request_dma(unsigned int dmanr, const char *device_id)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "void free_dma(unsigned int dmanr)",
            "{",
            "}",
            "static int proc_dma_show(struct seq_file *m, void *v)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0 ; i < MAX_DMA_CHANNELS ; i++) {",
            "\t\tif (dma_chan_busy[i].lock) {",
            "\t\t\tseq_printf(m, \"%2d: %s\\n\", i,",
            "\t\t\t\t   dma_chan_busy[i].device_id);",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}",
            "static int proc_dma_show(struct seq_file *m, void *v)",
            "{",
            "\tseq_puts(m, \"No DMA\\n\");",
            "\treturn 0;",
            "}",
            "static int __init proc_dma_init(void)",
            "{",
            "\tproc_create_single(\"dma\", 0, NULL, proc_dma_show);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "request_dma, free_dma, request_dma, free_dma, proc_dma_show, proc_dma_show, proc_dma_init",
          "description": "实现DMA通道分配与释放逻辑，通过原子操作管理通道占用状态，包含/proc/dma接口实现但存在函数重复定义导致上下文不完整",
          "similarity": 0.5842716097831726
        }
      ]
    },
    {
      "source_file": "kernel/dma/dummy.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:13:04\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `dma\\dummy.c`\n\n---\n\n# `dma/dummy.c` 技术文档\n\n## 1. 文件概述\n\n`dma/dummy.c` 实现了一组“虚拟”或“占位符”式的 DMA（Direct Memory Access）操作函数集合（`dma_map_ops`），这些函数在被调用时总是返回失败状态。该文件用于在系统不支持 DMA 或尚未初始化有效 DMA 操作时，提供一个安全的默认实现，防止内核因空指针调用或未定义行为而崩溃。\n\n## 2. 核心功能\n\n### 主要函数\n- `dma_dummy_mmap`：尝试将 DMA 映射区域映射到用户空间，始终返回 `-ENXIO`（无此类设备或地址）。\n- `dma_dummy_map_page`：尝试映射单个页面用于 DMA 传输，始终返回 `DMA_MAPPING_ERROR`。\n- `dma_dummy_map_sg`：尝试映射 scatterlist（分散/聚集列表）用于 DMA 传输，始终返回 `-EINVAL`（无效参数）。\n- `dma_dummy_supported`：检查设备是否支持指定的 DMA 地址掩码，始终返回 `0`（表示不支持）。\n\n### 数据结构\n- `dma_dummy_ops`：类型为 `const struct dma_map_ops` 的全局常量结构体，包含上述所有 dummy 函数的指针，作为无效 DMA 操作的默认实现。\n\n## 3. 关键实现\n\n- 所有 DMA 操作函数均不执行任何实际内存映射或硬件操作，而是直接返回代表“失败”或“不支持”的错误码：\n  - `dma_dummy_mmap` 返回 `-ENXIO`，表明设备或资源不存在。\n  - `dma_dummy_map_page` 返回 `DMA_MAPPING_ERROR`（通常定义为 `~(dma_addr_t)0`），这是内核中表示 DMA 映射失败的标准值。\n  - `dma_dummy_map_sg` 返回 `-EINVAL`，表示传入的 scatterlist 或参数无效。\n  - `dma_dummy_supported` 返回 `0`，明确表示该设备不支持任何 DMA 地址掩码。\n- 该实现确保在 DMA 子系统未正确初始化或平台不支持 DMA 时，调用者能安全地检测到失败并采取相应措施（如回退到非 DMA 路径或报错）。\n\n## 4. 依赖关系\n\n- 依赖头文件 `<linux/dma-map-ops.h>`，该头文件定义了 `struct dma_map_ops` 及相关类型（如 `dma_addr_t`、`enum dma_data_direction` 等）。\n- 该文件通常被架构特定的 DMA 初始化代码或设备驱动框架引用，作为默认或后备的 `dma_map_ops` 实现。\n- 不依赖其他内核模块的具体实现，仅使用标准内核数据结构和错误码。\n\n## 5. 使用场景\n\n- 在不支持 DMA 的平台（如某些纯软件模拟环境或早期启动阶段）中，作为默认的 DMA 操作集。\n- 在设备驱动尚未绑定有效 DMA 引擎时，防止对空或未初始化的 `dma_map_ops` 进行调用。\n- 用于调试或测试，强制使 DMA 操作失败以验证驱动的错误处理路径。\n- 在某些虚拟化或容器环境中，当物理 DMA 不可用时提供安全的占位实现。",
      "similarity": 0.6535668969154358,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/dma/dummy.c",
          "start_line": 1,
          "end_line": 6,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Dummy DMA ops that always fail.",
            " */",
            "#include <linux/dma-map-ops.h>",
            ""
          ],
          "function_name": null,
          "description": "定义一组始终失败的DMA操作函数，用于在设备不支持DMA时提供默认错误行为",
          "similarity": 0.6317650675773621
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/dma/dummy.c",
          "start_line": 7,
          "end_line": 28,
          "content": [
            "static int dma_dummy_mmap(struct device *dev, struct vm_area_struct *vma,",
            "\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,",
            "\t\tunsigned long attrs)",
            "{",
            "\treturn -ENXIO;",
            "}",
            "static dma_addr_t dma_dummy_map_page(struct device *dev, struct page *page,",
            "\t\tunsigned long offset, size_t size, enum dma_data_direction dir,",
            "\t\tunsigned long attrs)",
            "{",
            "\treturn DMA_MAPPING_ERROR;",
            "}",
            "static int dma_dummy_map_sg(struct device *dev, struct scatterlist *sgl,",
            "\t\tint nelems, enum dma_data_direction dir,",
            "\t\tunsigned long attrs)",
            "{",
            "\treturn -EINVAL;",
            "}",
            "static int dma_dummy_supported(struct device *hwdev, u64 mask)",
            "{",
            "\treturn 0;",
            "}"
          ],
          "function_name": "dma_dummy_mmap, dma_dummy_map_page, dma_dummy_map_sg, dma_dummy_supported",
          "description": "实现始终返回错误的DMA操作函数，用于处理不支持DMA的设备的内存映射和地址转换请求",
          "similarity": 0.6244653463363647
        }
      ]
    }
  ]
}