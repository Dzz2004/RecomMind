{
  "query": "system call number",
  "timestamp": "2025-12-26 02:03:41",
  "retrieved_files": [
    {
      "source_file": "kernel/entry/syscall_user_dispatch.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:20:47\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `entry\\syscall_user_dispatch.c`\n\n---\n\n# entry/syscall_user_dispatch.c 技术文档\n\n## 1. 文件概述\n\n`entry/syscall_user_dispatch.c` 实现了 **系统调用用户分发（Syscall User Dispatch, SUD）** 机制，该机制允许用户空间程序通过 `prctl()` 系统调用配置一个“选择器”（selector），用于在特定条件下拦截或允许系统调用的执行。当系统调用指令指针位于指定区域之外且选择器状态为“阻塞”时，内核会回滚该系统调用并向进程发送 `SIGSYS` 信号，从而实现对系统调用的细粒度控制。此功能常用于沙箱、安全监控或调试场景。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `trigger_sigsys(struct pt_regs *regs)`  \n  构造并强制发送 `SIGSYS` 信号，携带被拦截系统调用的详细信息（如地址、系统调用号、架构等）。\n\n- `syscall_user_dispatch(struct pt_regs *regs)`  \n  系统调用入口处的分发判断逻辑。根据当前指令指针位置和用户选择器状态决定是否拦截系统调用。\n\n- `task_set_syscall_user_dispatch(struct task_struct *task, ...)`  \n  为指定任务设置系统调用用户分发配置（开启/关闭、偏移、长度、选择器地址）。\n\n- `set_syscall_user_dispatch(...)`  \n  为当前任务设置系统调用用户分发配置的封装接口，供 `prctl()` 调用。\n\n- `syscall_user_dispatch_get_config(...)`  \n  通过 `ptrace` 获取指定任务的 SUD 配置。\n\n- `syscall_user_dispatch_set_config(...)`  \n  通过 `ptrace` 设置指定任务的 SUD 配置。\n\n### 关键数据结构\n\n- `struct syscall_user_dispatch`（定义在 `<linux/syscall_user_dispatch.h>`）  \n  存储每个任务的 SUD 配置：\n  - `selector`：指向用户空间选择器字节的指针\n  - `offset` / `len`：允许直接执行系统调用的代码区域（[offset, offset+len)）\n  - `on_dispatch`：标志位，表示当前是否处于分发拦截状态\n\n- `struct ptrace_sud_config`  \n  用于 `ptrace` 接口传递 SUD 配置的结构体，包含 `mode`、`offset`、`len` 和 `selector`。\n\n## 3. 关键实现\n\n### 系统调用拦截逻辑\n\n1. **区域检查**：若当前指令指针（`instruction_pointer(regs)`）落在 `[offset, offset + len)` 范围内，则**允许**系统调用直接执行，不进行拦截。\n2. **vdso 例外**：若系统调用来自 vDSO 中的 `sigreturn`（如 `arch_syscall_is_vdso_sigreturn()` 返回 true），则跳过拦截，避免干扰信号返回路径。\n3. **选择器读取**：若配置了 `selector`，则从用户空间读取一个字节的状态值：\n   - `SYSCALL_DISPATCH_FILTER_ALLOW`（0）：允许系统调用\n   - `SYSCALL_DISPATCH_FILTER_BLOCK`（1）：触发拦截\n   - 其他值：视为非法，发送 `SIGSYS`\n4. **拦截处理**：\n   - 设置 `on_dispatch = true`\n   - 调用 `syscall_rollback()` 回滚系统调用（恢复寄存器状态）\n   - 调用 `trigger_sigsys()` 发送 `SIGSYS` 信号\n\n### 安全与健壮性设计\n\n- **地址合法性校验**：在设置 `selector` 时使用 `access_ok(untagged_addr(selector), ...)`，确保地址可访问，并处理内存标记（如 ARM MTE）场景下调试器（tracer）与被调试进程（tracee）地址标记不一致的问题。\n- **溢出防护**：检查 `offset + len <= offset` 防止整数溢出导致无效区域。\n- **权限隔离**：`ptrace` 接口允许调试器配置其他进程的 SUD，但需具备相应权限。\n\n### 信号信息构造\n\n`trigger_sigsys()` 构造的 `siginfo_t` 包含：\n- `si_signo = SIGSYS`\n- `si_code = SYS_USER_DISPATCH`\n- `si_call_addr`：触发系统调用的用户空间地址\n- `si_syscall`：系统调用号\n- `si_arch`：系统调用架构（如 x86_64、AArch64）\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/prctl.h>`：定义 `PR_SYS_DISPATCH_*` 常量\n  - `<linux/syscall_user_dispatch.h>`：定义 `struct syscall_user_dispatch` 和相关常量\n  - `<asm/syscall.h>`：提供 `syscall_get_arch()`、`syscall_get_nr()` 等架构相关接口\n  - `\"common.h\"`：可能包含内核入口通用辅助函数\n- **内核子系统**：\n  - **调度器（sched）**：访问 `current` 任务结构\n  - **信号子系统（signal）**：发送 `SIGSYS` 信号\n  - **内存管理（uaccess）**：用户空间内存访问（`__get_user`, `access_ok`）\n  - **ptrace**：支持调试器配置 SUD\n  - **ELF**：可能用于架构识别（间接依赖）\n\n## 5. 使用场景\n\n- **沙箱环境**：限制应用只能在特定代码段发起系统调用，防止恶意代码绕过安全策略。\n- **动态二进制插桩（DBI）**：工具（如 Valgrind、Intel Pin）可拦截系统调用进行分析或重定向。\n- **安全监控**：监控程序可配置选择器为“阻塞”，在 `SIGSYS` 信号处理程序中记录或审查系统调用。\n- **调试与测试**：通过 `ptrace` 动态启用/禁用 SUD，用于测试系统调用拦截逻辑。\n- **W^X 策略增强**：结合代码段只读与 SUD，确保只有可信代码路径可发起系统调用。",
      "similarity": 0.5204831957817078,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 20,
          "end_line": 122,
          "content": [
            "static void trigger_sigsys(struct pt_regs *regs)",
            "{",
            "\tstruct kernel_siginfo info;",
            "",
            "\tclear_siginfo(&info);",
            "\tinfo.si_signo = SIGSYS;",
            "\tinfo.si_code = SYS_USER_DISPATCH;",
            "\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);",
            "\tinfo.si_errno = 0;",
            "\tinfo.si_arch = syscall_get_arch(current);",
            "\tinfo.si_syscall = syscall_get_nr(current, regs);",
            "",
            "\tforce_sig_info(&info);",
            "}",
            "bool syscall_user_dispatch(struct pt_regs *regs)",
            "{",
            "\tstruct syscall_user_dispatch *sd = &current->syscall_dispatch;",
            "\tchar state;",
            "",
            "\tif (likely(instruction_pointer(regs) - sd->offset < sd->len))",
            "\t\treturn false;",
            "",
            "\tif (unlikely(arch_syscall_is_vdso_sigreturn(regs)))",
            "\t\treturn false;",
            "",
            "\tif (likely(sd->selector)) {",
            "\t\t/*",
            "\t\t * access_ok() is performed once, at prctl time, when",
            "\t\t * the selector is loaded by userspace.",
            "\t\t */",
            "\t\tif (unlikely(__get_user(state, sd->selector))) {",
            "\t\t\tforce_exit_sig(SIGSEGV);",
            "\t\t\treturn true;",
            "\t\t}",
            "",
            "\t\tif (likely(state == SYSCALL_DISPATCH_FILTER_ALLOW))",
            "\t\t\treturn false;",
            "",
            "\t\tif (state != SYSCALL_DISPATCH_FILTER_BLOCK) {",
            "\t\t\tforce_exit_sig(SIGSYS);",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "",
            "\tsd->on_dispatch = true;",
            "\tsyscall_rollback(current, regs);",
            "\ttrigger_sigsys(regs);",
            "",
            "\treturn true;",
            "}",
            "static int task_set_syscall_user_dispatch(struct task_struct *task, unsigned long mode,",
            "\t\t\t\t\t  unsigned long offset, unsigned long len,",
            "\t\t\t\t\t  char __user *selector)",
            "{",
            "\tswitch (mode) {",
            "\tcase PR_SYS_DISPATCH_OFF:",
            "\t\tif (offset || len || selector)",
            "\t\t\treturn -EINVAL;",
            "\t\tbreak;",
            "\tcase PR_SYS_DISPATCH_ON:",
            "\t\t/*",
            "\t\t * Validate the direct dispatcher region just for basic",
            "\t\t * sanity against overflow and a 0-sized dispatcher",
            "\t\t * region.  If the user is able to submit a syscall from",
            "\t\t * an address, that address is obviously valid.",
            "\t\t */",
            "\t\tif (offset && offset + len <= offset)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\t/*",
            "\t\t * access_ok() will clear memory tags for tagged addresses",
            "\t\t * if current has memory tagging enabled.",
            "",
            "\t\t * To enable a tracer to set a tracees selector the",
            "\t\t * selector address must be untagged for access_ok(),",
            "\t\t * otherwise an untagged tracer will always fail to set a",
            "\t\t * tagged tracees selector.",
            "\t\t */",
            "\t\tif (selector && !access_ok(untagged_addr(selector), sizeof(*selector)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbreak;",
            "\tdefault:",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttask->syscall_dispatch.selector = selector;",
            "\ttask->syscall_dispatch.offset = offset;",
            "\ttask->syscall_dispatch.len = len;",
            "\ttask->syscall_dispatch.on_dispatch = false;",
            "",
            "\tif (mode == PR_SYS_DISPATCH_ON)",
            "\t\tset_task_syscall_work(task, SYSCALL_USER_DISPATCH);",
            "\telse",
            "\t\tclear_task_syscall_work(task, SYSCALL_USER_DISPATCH);",
            "",
            "\treturn 0;",
            "}",
            "int set_syscall_user_dispatch(unsigned long mode, unsigned long offset,",
            "\t\t\t      unsigned long len, char __user *selector)",
            "{",
            "\treturn task_set_syscall_user_dispatch(current, mode, offset, len, selector);",
            "}"
          ],
          "function_name": "trigger_sigsys, syscall_user_dispatch, task_set_syscall_user_dispatch, set_syscall_user_dispatch",
          "description": "实现系统调用用户分发核心逻辑，包含触发SIGSYS信号处理、配置验证、拦截判断及模式切换功能",
          "similarity": 0.543464183807373
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 127,
          "end_line": 163,
          "content": [
            "int syscall_user_dispatch_get_config(struct task_struct *task, unsigned long size,",
            "\t\t\t\t     void __user *data)",
            "{",
            "\tstruct syscall_user_dispatch *sd = &task->syscall_dispatch;",
            "\tstruct ptrace_sud_config cfg;",
            "",
            "\tif (size != sizeof(cfg))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (test_task_syscall_work(task, SYSCALL_USER_DISPATCH))",
            "\t\tcfg.mode = PR_SYS_DISPATCH_ON;",
            "\telse",
            "\t\tcfg.mode = PR_SYS_DISPATCH_OFF;",
            "",
            "\tcfg.offset = sd->offset;",
            "\tcfg.len = sd->len;",
            "\tcfg.selector = (__u64)(uintptr_t)sd->selector;",
            "",
            "\tif (copy_to_user(data, &cfg, sizeof(cfg)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn 0;",
            "}",
            "int syscall_user_dispatch_set_config(struct task_struct *task, unsigned long size,",
            "\t\t\t\t     void __user *data)",
            "{",
            "\tstruct ptrace_sud_config cfg;",
            "",
            "\tif (size != sizeof(cfg))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (copy_from_user(&cfg, data, sizeof(cfg)))",
            "\t\treturn -EFAULT;",
            "",
            "\treturn task_set_syscall_user_dispatch(task, cfg.mode, cfg.offset, cfg.len,",
            "\t\t\t\t\t      (char __user *)(uintptr_t)cfg.selector);",
            "}"
          ],
          "function_name": "syscall_user_dispatch_get_config, syscall_user_dispatch_set_config",
          "description": "提供系统调用分发配置的获取与设置接口，通过用户态指针操作实现配置参数的双向传递",
          "similarity": 0.4803921580314636
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/entry/syscall_user_dispatch.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Copyright (C) 2020 Collabora Ltd.",
            " */",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscall_user_dispatch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/signal.h>",
            "#include <linux/elf.h>",
            "",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task_stack.h>",
            "",
            "#include <asm/syscall.h>",
            "",
            "#include \"common.h\"",
            ""
          ],
          "function_name": null,
          "description": "包含系统调用用户分发功能所需头文件及通用定义，提供架构相关接口和内核调度必要声明",
          "similarity": 0.45582640171051025
        }
      ]
    },
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.5182065963745117,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.4954249858856201
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.4871164560317993
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.4292944669723511
        }
      ]
    },
    {
      "source_file": "kernel/futex/syscalls.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:35:43\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `futex\\syscalls.c`\n\n---\n\n# futex/syscalls.c 技术文档\n\n## 1. 文件概述\n\n`futex/syscalls.c` 是 Linux 内核中实现 futex（Fast Userspace muTEX）系统调用的核心文件之一。该文件主要负责处理与 futex 相关的用户空间系统调用接口，包括基础 futex 操作、健壮 futex（robust futex）支持以及多 futex 等待（`futex_waitv`）功能。futex 是一种高效的用户态同步原语，内核仅在必要时（如竞争或阻塞）介入，从而在无竞争场景下实现零内核开销。\n\n## 2. 核心功能\n\n### 主要系统调用函数：\n\n- `sys_set_robust_list()`：为当前任务设置健壮 futex 列表头指针。\n- `sys_get_robust_list()`：获取指定任务（或当前任务）的健壮 futex 列表头指针。\n- `sys_futex()`：主 futex 系统调用，支持多种操作（如 `FUTEX_WAIT`、`FUTEX_WAKE`、`FUTEX_LOCK_PI` 等）。\n- `sys_futex_waitv()`：等待多个 futex 中任意一个被唤醒（尚未完整实现，仅声明）。\n\n### 辅助函数：\n\n- `do_futex()`：统一调度所有 futex 操作的核心分发函数。\n- `futex_cmd_has_timeout()`：判断指定 futex 命令是否支持超时。\n- `futex_init_timeout()`：解析并转换用户提供的超时时间（支持 `CLOCK_REALTIME` 和 `CLOCK_MONOTONIC`）。\n- `futex_parse_waitv()`：从用户空间解析 `futex_waitv` 数组，验证并初始化内核侧等待结构。\n- `futex2_setup_timeout()` / `futex2_destroy_timeout()`：为 `futex_waitv` 设置和销毁高精度定时器。\n\n### 关键数据结构（引用）：\n\n- `struct robust_list_head`：健壮 futex 列表头，由用户空间维护。\n- `struct futex_waitv`：用于 `futex_waitv` 的用户空间输入结构，包含地址、期望值和标志。\n- `struct futex_vector`：内核侧表示多个 futex 等待项的结构。\n\n## 3. 关键实现\n\n### 健壮 Futex（Robust Futex）机制\n- 用户空间为每个线程维护一个持有锁的链表（`robust_list`）。\n- 当线程异常退出时，内核遍历该链表，将所有属于该线程的 futex 标记为 `FUTEX_OWNER_DIED` 并唤醒等待者。\n- 通过 `list_op_pending` 字段处理“已加锁但尚未加入链表”的临界状态，确保清理完整性。\n- `set_robust_list` / `get_robust_list` 系统调用用于注册和查询该链表。\n\n### Futex 操作分发\n- `do_futex()` 根据操作码（`op & FUTEX_CMD_MASK`）分发到具体实现函数（如 `futex_wait`、`futex_wake`、`futex_lock_pi` 等）。\n- 支持多种 futex 类型：普通 futex、PI（优先级继承）futex、bitset futex、requeue 操作等。\n- 对于带超时的操作（如 `FUTEX_WAIT`），根据是否使用 `FUTEX_CLOCK_REALTIME` 标志决定使用绝对时间还是相对时间，并进行时间命名空间转换（`timens_ktime_to_host`）。\n\n### 多 Futex 等待（`futex_waitv`）\n- 允许线程同时等待多个 futex，任一 futex 被唤醒即返回。\n- 用户传入 `futex_waitv` 数组，每个元素包含独立的地址、期望值和标志（如私有/共享、size）。\n- 使用 `futex2_to_flags()` 将用户标志转换为内核内部标志，并验证合法性。\n- 超时使用高精度定时器（`hrtimer`），支持 `CLOCK_REALTIME` 或 `CLOCK_MONOTONIC`。\n\n### 时间处理\n- 超时参数通过 `__kernel_timespec` 传入，经 `get_timespec64()` 转换为 `timespec64`。\n- `futex_init_timeout()` 根据命令类型和时钟标志，将用户时间转换为内核 `ktime_t`，并处理绝对/相对时间语义。\n- 时间命名空间支持：非 `REALTIME` 的单调时钟时间会通过 `timens_ktime_to_host()` 转换为主机时间。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/syscalls.h>`：系统调用宏定义（如 `SYSCALL_DEFINE*`）。\n  - `<linux/time_namespace.h>`：时间命名空间支持（`timens_ktime_to_host`）。\n  - `\"futex.h\"`：futex 内部实现头文件，包含核心函数声明、标志定义和数据结构。\n\n- **内核模块依赖**：\n  - **Futex 核心逻辑**：实际的等待、唤醒、锁操作由 `futex.c` 中的函数（如 `futex_wait`、`futex_wake`）实现。\n  - **调度器与 PI 机制**：PI futex 依赖内核的优先级继承和 RT 调度支持。\n  - **高精度定时器（hrtimer）**：用于实现精确超时。\n  - **RCU 机制**：`get_robust_list` 使用 RCU 保护任务结构体访问。\n  - **Ptrace 安全检查**：`get_robust_list` 调用 `ptrace_may_access` 验证权限。\n\n## 5. 使用场景\n\n- **用户态同步原语实现**：glibc 的 `pthread_mutex`、`semaphore` 等在无竞争时完全在用户态运行，仅在需要阻塞或唤醒时调用 `futex` 系统调用。\n- **健壮互斥锁**：当持有互斥锁的线程崩溃时，其他线程可通过 `FUTEX_OWNER_DIED` 检测并恢复锁状态，避免死锁。\n- **高性能事件通知**：一个线程可等待多个事件源（如 I/O 完成、信号量、条件变量），通过 `futex_waitv` 实现“任一触发即返回”的语义。\n- **实时应用**：通过 `FUTEX_CLOCK_REALTIME` 支持基于系统实时钟的绝对超时，适用于需要与外部时间对齐的场景。\n- **容器与命名空间**：时间命名空间支持确保容器内 futex 超时行为符合容器视角的时间。",
      "similarity": 0.5113170146942139,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/futex/syscalls.c",
          "start_line": 1,
          "end_line": 83,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "",
            "#include <linux/syscalls.h>",
            "#include <linux/time_namespace.h>",
            "",
            "#include \"futex.h\"",
            "",
            "/*",
            " * Support for robust futexes: the kernel cleans up held futexes at",
            " * thread exit time.",
            " *",
            " * Implementation: user-space maintains a per-thread list of locks it",
            " * is holding. Upon do_exit(), the kernel carefully walks this list,",
            " * and marks all locks that are owned by this thread with the",
            " * FUTEX_OWNER_DIED bit, and wakes up a waiter (if any). The list is",
            " * always manipulated with the lock held, so the list is private and",
            " * per-thread. Userspace also maintains a per-thread 'list_op_pending'",
            " * field, to allow the kernel to clean up if the thread dies after",
            " * acquiring the lock, but just before it could have added itself to",
            " * the list. There can only be one such pending lock.",
            " */",
            "",
            "/**",
            " * sys_set_robust_list() - Set the robust-futex list head of a task",
            " * @head:\tpointer to the list-head",
            " * @len:\tlength of the list-head, as userspace expects",
            " */",
            "SYSCALL_DEFINE2(set_robust_list, struct robust_list_head __user *, head,",
            "\t\tsize_t, len)",
            "{",
            "\t/*",
            "\t * The kernel knows only one size for now:",
            "\t */",
            "\tif (unlikely(len != sizeof(*head)))",
            "\t\treturn -EINVAL;",
            "",
            "\tcurrent->robust_list = head;",
            "",
            "\treturn 0;",
            "}",
            "",
            "/**",
            " * sys_get_robust_list() - Get the robust-futex list head of a task",
            " * @pid:\tpid of the process [zero for current task]",
            " * @head_ptr:\tpointer to a list-head pointer, the kernel fills it in",
            " * @len_ptr:\tpointer to a length field, the kernel fills in the header size",
            " */",
            "SYSCALL_DEFINE3(get_robust_list, int, pid,",
            "\t\tstruct robust_list_head __user * __user *, head_ptr,",
            "\t\tsize_t __user *, len_ptr)",
            "{",
            "\tstruct robust_list_head __user *head;",
            "\tunsigned long ret;",
            "\tstruct task_struct *p;",
            "",
            "\trcu_read_lock();",
            "",
            "\tret = -ESRCH;",
            "\tif (!pid)",
            "\t\tp = current;",
            "\telse {",
            "\t\tp = find_task_by_vpid(pid);",
            "\t\tif (!p)",
            "\t\t\tgoto err_unlock;",
            "\t}",
            "",
            "\tret = -EPERM;",
            "\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))",
            "\t\tgoto err_unlock;",
            "",
            "\thead = p->robust_list;",
            "\trcu_read_unlock();",
            "",
            "\tif (put_user(sizeof(*head), len_ptr))",
            "\t\treturn -EFAULT;",
            "\treturn put_user(head, head_ptr);",
            "",
            "err_unlock:",
            "\trcu_read_unlock();",
            "",
            "\treturn ret;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "实现set_robust_list和get_robust_list系统调用，用于设置/获取当前任务的robust-futex列表头，支持线程退出时自动清理持有锁的机制",
          "similarity": 0.4626502990722656
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/futex/syscalls.c",
          "start_line": 224,
          "end_line": 261,
          "content": [
            "static int futex2_setup_timeout(struct __kernel_timespec __user *timeout,",
            "\t\t\t\tclockid_t clockid, struct hrtimer_sleeper *to)",
            "{",
            "\tint flag_clkid = 0, flag_init = 0;",
            "\tstruct timespec64 ts;",
            "\tktime_t time;",
            "\tint ret;",
            "",
            "\tif (!timeout)",
            "\t\treturn 0;",
            "",
            "\tif (clockid == CLOCK_REALTIME) {",
            "\t\tflag_clkid = FLAGS_CLOCKRT;",
            "\t\tflag_init = FUTEX_CLOCK_REALTIME;",
            "\t}",
            "",
            "\tif (clockid != CLOCK_REALTIME && clockid != CLOCK_MONOTONIC)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (get_timespec64(&ts, timeout))",
            "\t\treturn -EFAULT;",
            "",
            "\t/*",
            "\t * Since there's no opcode for futex_waitv, use",
            "\t * FUTEX_WAIT_BITSET that uses absolute timeout as well",
            "\t */",
            "\tret = futex_init_timeout(FUTEX_WAIT_BITSET, flag_init, &ts, &time);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tfutex_setup_timer(&time, to, flag_clkid, 0);",
            "\treturn 0;",
            "}",
            "static inline void futex2_destroy_timeout(struct hrtimer_sleeper *to)",
            "{",
            "\thrtimer_cancel(&to->timer);",
            "\tdestroy_hrtimer_on_stack(&to->timer);",
            "}"
          ],
          "function_name": "futex2_setup_timeout, futex2_destroy_timeout",
          "description": "futex2_setup_timeout将用户态超时参数转换为内核时间戳并初始化定时器，futex2_destroy_timeout负责安全地取消和销毁定时器资源",
          "similarity": 0.3869810998439789
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/futex/syscalls.c",
          "start_line": 84,
          "end_line": 187,
          "content": [
            "long do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout,",
            "\t\tu32 __user *uaddr2, u32 val2, u32 val3)",
            "{",
            "\tunsigned int flags = futex_to_flags(op);",
            "\tint cmd = op & FUTEX_CMD_MASK;",
            "",
            "\tif (flags & FLAGS_CLOCKRT) {",
            "\t\tif (cmd != FUTEX_WAIT_BITSET &&",
            "\t\t    cmd != FUTEX_WAIT_REQUEUE_PI &&",
            "\t\t    cmd != FUTEX_LOCK_PI2)",
            "\t\t\treturn -ENOSYS;",
            "\t}",
            "",
            "\tswitch (cmd) {",
            "\tcase FUTEX_WAIT:",
            "\t\tval3 = FUTEX_BITSET_MATCH_ANY;",
            "\t\tfallthrough;",
            "\tcase FUTEX_WAIT_BITSET:",
            "\t\treturn futex_wait(uaddr, flags, val, timeout, val3);",
            "\tcase FUTEX_WAKE:",
            "\t\tval3 = FUTEX_BITSET_MATCH_ANY;",
            "\t\tfallthrough;",
            "\tcase FUTEX_WAKE_BITSET:",
            "\t\treturn futex_wake(uaddr, flags, val, val3);",
            "\tcase FUTEX_REQUEUE:",
            "\t\treturn futex_requeue(uaddr, flags, uaddr2, flags, val, val2, NULL, 0);",
            "\tcase FUTEX_CMP_REQUEUE:",
            "\t\treturn futex_requeue(uaddr, flags, uaddr2, flags, val, val2, &val3, 0);",
            "\tcase FUTEX_WAKE_OP:",
            "\t\treturn futex_wake_op(uaddr, flags, uaddr2, val, val2, val3);",
            "\tcase FUTEX_LOCK_PI:",
            "\t\tflags |= FLAGS_CLOCKRT;",
            "\t\tfallthrough;",
            "\tcase FUTEX_LOCK_PI2:",
            "\t\treturn futex_lock_pi(uaddr, flags, timeout, 0);",
            "\tcase FUTEX_UNLOCK_PI:",
            "\t\treturn futex_unlock_pi(uaddr, flags);",
            "\tcase FUTEX_TRYLOCK_PI:",
            "\t\treturn futex_lock_pi(uaddr, flags, NULL, 1);",
            "\tcase FUTEX_WAIT_REQUEUE_PI:",
            "\t\tval3 = FUTEX_BITSET_MATCH_ANY;",
            "\t\treturn futex_wait_requeue_pi(uaddr, flags, val, timeout, val3,",
            "\t\t\t\t\t     uaddr2);",
            "\tcase FUTEX_CMP_REQUEUE_PI:",
            "\t\treturn futex_requeue(uaddr, flags, uaddr2, flags, val, val2, &val3, 1);",
            "\t}",
            "\treturn -ENOSYS;",
            "}",
            "static __always_inline bool futex_cmd_has_timeout(u32 cmd)",
            "{",
            "\tswitch (cmd) {",
            "\tcase FUTEX_WAIT:",
            "\tcase FUTEX_LOCK_PI:",
            "\tcase FUTEX_LOCK_PI2:",
            "\tcase FUTEX_WAIT_BITSET:",
            "\tcase FUTEX_WAIT_REQUEUE_PI:",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}",
            "static __always_inline int",
            "futex_init_timeout(u32 cmd, u32 op, struct timespec64 *ts, ktime_t *t)",
            "{",
            "\tif (!timespec64_valid(ts))",
            "\t\treturn -EINVAL;",
            "",
            "\t*t = timespec64_to_ktime(*ts);",
            "\tif (cmd == FUTEX_WAIT)",
            "\t\t*t = ktime_add_safe(ktime_get(), *t);",
            "\telse if (cmd != FUTEX_LOCK_PI && !(op & FUTEX_CLOCK_REALTIME))",
            "\t\t*t = timens_ktime_to_host(CLOCK_MONOTONIC, *t);",
            "\treturn 0;",
            "}",
            "static int futex_parse_waitv(struct futex_vector *futexv,",
            "\t\t\t     struct futex_waitv __user *uwaitv,",
            "\t\t\t     unsigned int nr_futexes)",
            "{",
            "\tstruct futex_waitv aux;",
            "\tunsigned int i;",
            "",
            "\tfor (i = 0; i < nr_futexes; i++) {",
            "\t\tunsigned int flags;",
            "",
            "\t\tif (copy_from_user(&aux, &uwaitv[i], sizeof(aux)))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tif ((aux.flags & ~FUTEX2_VALID_MASK) || aux.__reserved)",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tflags = futex2_to_flags(aux.flags);",
            "\t\tif (!futex_flags_valid(flags))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tif (!futex_validate_input(flags, aux.val))",
            "\t\t\treturn -EINVAL;",
            "",
            "\t\tfutexv[i].w.flags = flags;",
            "\t\tfutexv[i].w.val = aux.val;",
            "\t\tfutexv[i].w.uaddr = aux.uaddr;",
            "\t\tfutexv[i].q = futex_q_init;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "do_futex, futex_cmd_has_timeout, futex_init_timeout, futex_parse_waitv",
          "description": "do_futex处理各类futex操作命令，包含超时检测逻辑和waitv参数解析，通过条件判断分发到相应子函数实现不同操作",
          "similarity": 0.37800586223602295
        }
      ]
    }
  ]
}