{
  "query": "如何用信号量实现银行家算法",
  "timestamp": "2025-12-26 01:03:52",
  "retrieved_files": [
    {
      "source_file": "kernel/locking/semaphore.c",
      "md_summary": "> 自动生成时间: 2025-10-25 14:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `locking\\semaphore.c`\n\n---\n\n# `locking/semaphore.c` 技术文档\n\n## 1. 文件概述\n\n`locking/semaphore.c` 实现了 Linux 内核中的**计数信号量（counting semaphore）**机制。计数信号量允许多个任务（最多为初始计数值）同时持有该锁，当计数值耗尽时，后续请求者将被阻塞，直到有其他任务释放信号量。与互斥锁（mutex）不同，信号量支持更灵活的并发控制，适用于资源池、限流等场景。该文件提供了多种获取和释放信号量的接口，包括可中断、可超时、不可中断等变体，并支持在中断上下文中调用部分函数。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数名 | 功能描述 |\n|--------|--------|\n| `down(struct semaphore *sem)` | 不可中断地获取信号量，若不可用则睡眠。**已弃用**，建议使用可中断版本。 |\n| `down_interruptible(struct semaphore *sem)` | 可被普通信号中断的获取操作，成功返回 0，被信号中断返回 `-EINTR`。 |\n| `down_killable(struct semaphore *sem)` | 可被致命信号（fatal signal）中断的获取操作，返回值同上。 |\n| `down_trylock(struct semaphore *sem)` | 非阻塞尝试获取信号量，成功返回 0，失败返回 1（**注意返回值与 mutex/spinlock 相反**）。 |\n| `down_timeout(struct semaphore *sem, long timeout)` | 带超时的获取操作，超时返回 `-ETIME`，成功返回 0。 |\n| `up(struct semaphore *sem)` | 释放信号量，可由任意上下文（包括中断）调用，唤醒等待队列中的任务。 |\n\n### 静态辅助函数\n\n- `__down*()` 系列：处理信号量争用时的阻塞逻辑。\n- `__up()`：在有等待者时执行唤醒逻辑。\n- `___down_common()`：通用的阻塞等待实现，支持不同睡眠状态和超时。\n- `__sem_acquire()`：原子减少计数并记录持有者（用于 hung task 检测）。\n\n### 数据结构\n\n- `struct semaphore`（定义在 `<linux/semaphore.h>`）：\n  - `count`：当前可用资源数（>0 表示可立即获取）。\n  - `wait_list`：等待该信号量的任务链表。\n  - `lock`：保护上述成员的原始自旋锁（`raw_spinlock_t`）。\n  - `last_holder`（条件编译）：记录最后持有者，用于 `CONFIG_DETECT_HUNG_TASK_BLOCKER`。\n\n- `struct semaphore_waiter`：\n  - 用于将任务加入等待队列，包含任务指针和唤醒标志（`up`）。\n\n## 3. 关键实现\n\n### 中断安全与自旋锁\n- 所有对外接口（包括 `down*` 和 `up`）均使用 `raw_spin_lock_irqsave()` 获取自旋锁，确保在中断上下文安全。\n- 即使 `down()` 等函数通常在进程上下文调用，也使用 `irqsave` 变体，因为内核某些部分依赖在中断上下文成功调用 `down()`（当确定信号量可用时）。\n\n### 计数语义\n- `sem->count` 表示**还可被获取的次数**。初始值由 `sema_init()` 设置。\n- 获取时：若 `count > 0`，直接减 1；否则加入等待队列。\n- 释放时：若等待队列为空，`count++`；否则唤醒队首任务。\n\n### 等待与唤醒机制\n- 使用 `wake_q`（批量唤醒队列）优化唤醒路径，避免在持有自旋锁时调用 `wake_up_process()`。\n- 等待任务通过 `schedule_timeout()` 睡眠，并在循环中检查：\n  - 是否收到信号（根据睡眠状态判断）。\n  - 是否超时。\n  - 是否被 `__up()` 标记为 `waiter.up = true`（表示已被选中唤醒）。\n\n### Hung Task 支持\n- 当启用 `CONFIG_DETECT_HUNG_TASK_BLOCKER` 时：\n  - 获取信号量时记录当前任务为 `last_holder`。\n  - 释放时若当前任务是持有者，则清除记录。\n  - 提供 `sem_last_holder()` 供 hung task 检测模块查询阻塞源头。\n\n### 返回值约定\n- `down_trylock()` 返回 **0 表示成功**，**1 表示失败**，这与 `mutex_trylock()` 和 `spin_trylock()` **相反**，需特别注意。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/semaphore.h>`：信号量结构体和 API 声明。\n  - `<linux/spinlock.h>`：原始自旋锁实现。\n  - `<linux/sched.h>`、`<linux/sched/wake_q.h>`：任务调度和批量唤醒。\n  - `<trace/events/lock.h>`：锁争用跟踪点。\n  - `<linux/hung_task.h>`：hung task 检测支持。\n\n- **内核配置依赖**：\n  - `CONFIG_DETECT_HUNG_TASK_BLOCKER`：启用信号量持有者跟踪。\n\n- **与其他同步原语关系**：\n  - 与 `mutex.c` 形成对比：mutex 是二值、不可递归、带调试信息的互斥锁；信号量是计数、可被任意任务释放、更轻量。\n  - 底层依赖调度器（`schedule_timeout`）和中断管理（`irqsave`）。\n\n## 5. 使用场景\n\n- **资源池管理**：如限制同时访问某类硬件设备的任务数量。\n- **读写并发控制**：配合其他机制实现多读者/单写者模型。\n- **内核驱动**：设备驱动中控制对共享资源的并发访问。\n- **中断上下文释放**：因 `up()` 可在中断中调用，适用于中断处理程序释放资源的场景。\n- **不可睡眠路径**：使用 `down_trylock()` 在原子上下文尝试获取资源。\n\n> **注意**：由于信号量不强制所有权（任意任务可调用 `up()`），且缺乏死锁检测等调试特性，现代内核开发中更推荐使用 `mutex` 或 `rwsem`，除非明确需要计数语义或多释放者特性。",
      "similarity": 0.5333161950111389,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 252,
          "end_line": 323,
          "content": [
            "static inline int __sched ___down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\t\t\t\tlong timeout)",
            "{",
            "\tstruct semaphore_waiter waiter;",
            "",
            "\tlist_add_tail(&waiter.list, &sem->wait_list);",
            "\twaiter.task = current;",
            "\twaiter.up = false;",
            "",
            "\tfor (;;) {",
            "\t\tif (signal_pending_state(state, current))",
            "\t\t\tgoto interrupted;",
            "\t\tif (unlikely(timeout <= 0))",
            "\t\t\tgoto timed_out;",
            "\t\t__set_current_state(state);",
            "\t\traw_spin_unlock_irq(&sem->lock);",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\traw_spin_lock_irq(&sem->lock);",
            "\t\tif (waiter.up) {",
            "\t\t\thung_task_sem_set_holder(sem);",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t}",
            "",
            " timed_out:",
            "\tlist_del(&waiter.list);",
            "\treturn -ETIME;",
            "",
            " interrupted:",
            "\tlist_del(&waiter.list);",
            "\treturn -EINTR;",
            "}",
            "static inline int __sched __down_common(struct semaphore *sem, long state,",
            "\t\t\t\t\tlong timeout)",
            "{",
            "\tint ret;",
            "",
            "\thung_task_set_blocker(sem, BLOCKER_TYPE_SEM);",
            "",
            "\ttrace_contention_begin(sem, 0);",
            "\tret = ___down_common(sem, state, timeout);",
            "\ttrace_contention_end(sem, ret);",
            "",
            "\thung_task_clear_blocker();",
            "",
            "\treturn ret;",
            "}",
            "static noinline void __sched __down(struct semaphore *sem)",
            "{",
            "\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_interruptible(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_killable(struct semaphore *sem)",
            "{",
            "\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);",
            "}",
            "static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);",
            "}",
            "static noinline void __sched __up(struct semaphore *sem,",
            "\t\t\t\t  struct wake_q_head *wake_q)",
            "{",
            "\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,",
            "\t\t\t\t\t\tstruct semaphore_waiter, list);",
            "\tlist_del(&waiter->list);",
            "\twaiter->up = true;",
            "\twake_q_add(wake_q, waiter->task);",
            "}"
          ],
          "function_name": "___down_common, __down_common, __down, __down_interruptible, __down_killable, __down_timeout, __up",
          "description": "实现了信号量的阻塞等待通用逻辑，包含___down_common/__down_common等辅助函数，处理信号量不足时的任务挂起、超时检测、信号处理及唤醒机制，通过循环等待并结合schedule_timeout实现阻塞式资源竞争解决",
          "similarity": 0.5470196008682251
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 1,
          "end_line": 45,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Copyright (c) 2008 Intel Corporation",
            " * Author: Matthew Wilcox <willy@linux.intel.com>",
            " *",
            " * This file implements counting semaphores.",
            " * A counting semaphore may be acquired 'n' times before sleeping.",
            " * See mutex.c for single-acquisition sleeping locks which enforce",
            " * rules which allow code to be debugged more easily.",
            " */",
            "",
            "/*",
            " * Some notes on the implementation:",
            " *",
            " * The spinlock controls access to the other members of the semaphore.",
            " * down_trylock() and up() can be called from interrupt context, so we",
            " * have to disable interrupts when taking the lock.  It turns out various",
            " * parts of the kernel expect to be able to use down() on a semaphore in",
            " * interrupt context when they know it will succeed, so we have to use",
            " * irqsave variants for down(), down_interruptible() and down_killable()",
            " * too.",
            " *",
            " * The ->count variable represents how many more tasks can acquire this",
            " * semaphore.  If it's zero, there may be tasks waiting on the wait_list.",
            " */",
            "",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ftrace.h>",
            "#include <trace/events/lock.h>",
            "#include <linux/hung_task.h>",
            "",
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline int __down_timeout(struct semaphore *sem, long timeout);",
            "static noinline void __up(struct semaphore *sem, struct wake_q_head *wake_q);",
            "",
            "#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER"
          ],
          "function_name": null,
          "description": "此代码块定义了计数信号量的基础框架，包含实现计数信号量所需的头文件和注释，声明了多个内联函数及辅助函数，用于处理信号量的获取、释放及Hung Task检测相关逻辑，但由于代码截断，CONFIG_DETECT_HUNG_TASK_BLOCKER部分缺失，上下文不完整",
          "similarity": 0.5441508293151855
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/locking/semaphore.c",
          "start_line": 46,
          "end_line": 160,
          "content": [
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "\tWRITE_ONCE((sem)->last_holder, (unsigned long)current);",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "\tif (READ_ONCE((sem)->last_holder) == (unsigned long)current)",
            "\t\tWRITE_ONCE((sem)->last_holder, 0UL);",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn READ_ONCE(sem->last_holder);",
            "}",
            "static inline void hung_task_sem_set_holder(struct semaphore *sem)",
            "{",
            "}",
            "static inline void hung_task_sem_clear_if_holder(struct semaphore *sem)",
            "{",
            "}",
            "unsigned long sem_last_holder(struct semaphore *sem)",
            "{",
            "\treturn 0UL;",
            "}",
            "static inline void __sem_acquire(struct semaphore *sem)",
            "{",
            "\tsem->count--;",
            "\thung_task_sem_set_holder(sem);",
            "}",
            "void __sched down(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\t__down(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "}",
            "int __sched down_interruptible(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_interruptible(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_killable(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_killable(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "int __sched down_trylock(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tint count;",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tcount = sem->count - 1;",
            "\tif (likely(count >= 0))",
            "\t\t__sem_acquire(sem);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn (count < 0);",
            "}",
            "int __sched down_timeout(struct semaphore *sem, long timeout)",
            "{",
            "\tunsigned long flags;",
            "\tint result = 0;",
            "",
            "\tmight_sleep();",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "\tif (likely(sem->count > 0))",
            "\t\t__sem_acquire(sem);",
            "\telse",
            "\t\tresult = __down_timeout(sem, timeout);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "",
            "\treturn result;",
            "}",
            "void __sched up(struct semaphore *sem)",
            "{",
            "\tunsigned long flags;",
            "\tDEFINE_WAKE_Q(wake_q);",
            "",
            "\traw_spin_lock_irqsave(&sem->lock, flags);",
            "",
            "\thung_task_sem_clear_if_holder(sem);",
            "",
            "\tif (likely(list_empty(&sem->wait_list)))",
            "\t\tsem->count++;",
            "\telse",
            "\t\t__up(sem, &wake_q);",
            "\traw_spin_unlock_irqrestore(&sem->lock, flags);",
            "\tif (!wake_q_empty(&wake_q))",
            "\t\twake_up_q(&wake_q);",
            "}"
          ],
          "function_name": "hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, hung_task_sem_set_holder, hung_task_sem_clear_if_holder, sem_last_holder, __sem_acquire, down, down_interruptible, down_killable, down_trylock, down_timeout, up",
          "description": "实现了信号量的获取与释放核心逻辑，包括down/down_interruptible/down_killable/down_trylock/down_timeout等接口，通过spinlock保护共享资源，维护等待队列并处理任务状态变更，其中包含Hung Task检测相关函数的条件性实现",
          "similarity": 0.5297321081161499
        }
      ]
    },
    {
      "source_file": "kernel/signal.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:24:03\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `signal.c`\n\n---\n\n# signal.c 技术文档\n\n## 1. 文件概述\n\n`signal.c` 是 Linux 内核中信号子系统的核心实现文件，负责管理进程间信号的发送、接收、排队、处理以及相关状态的维护。该文件实现了 POSIX 信号语义，包括标准信号和实时信号（通过 sigqueue），并处理信号的阻塞、忽略、默认行为及用户自定义处理函数的调用逻辑。它还集成了对 ptrace 调试、作业控制（job control）、冻结（freezer）和 cgroup 等子系统的支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `sigqueue_cachep`：用于分配 `sigqueue` 结构的 slab 缓存，支持可靠信号排队。\n- `task_struct::pending`：每个任务私有的挂起信号队列。\n- `signal_struct::shared_pending`：线程组共享的挂起信号队列。\n- `task_struct::blocked` / `real_blocked`：信号阻塞掩码。\n- `task_struct::jobctl`：作业控制相关状态位（如停止、陷阱等）。\n\n### 主要函数\n- `sig_handler()`：获取指定信号的处理函数指针。\n- `sig_handler_ignored()`：判断信号是否被显式或隐式忽略。\n- `sig_task_ignored()` / `sig_ignored()`：判断任务是否忽略某信号（考虑 init、kthread、ptrace 等特殊情况）。\n- `has_pending_signals()`：检查在给定阻塞掩码下是否存在可投递的挂起信号。\n- `recalc_sigpending_tsk()` / `recalc_sigpending()` / `recalc_sigpending_and_wake()`：重新计算并设置 `TIF_SIGPENDING` 线程标志。\n- `next_signal()`：从挂起信号中选择下一个应被处理的信号，优先处理同步信号（如 SIGSEGV、SIGILL 等）。\n- `task_set_jobctl_pending()`：设置任务的作业控制挂起状态（如停止请求）。\n- `task_clear_jobctl_trapping()`：清除作业控制陷阱状态并唤醒跟踪者（ptracer）。\n- `print_dropped_signal()`：当日志开启且达到 `RLIMIT_SIGPENDING` 限制时，记录被丢弃的信号。\n\n## 3. 关键实现\n\n### 信号忽略逻辑\n信号是否被忽略不仅取决于处理函数是否为 `SIG_IGN` 或默认且内核定义为可忽略（`sig_kernel_ignore()`），还需考虑：\n- 全局 init 进程不能接收 `SIGKILL`/`SIGSTOP`。\n- `SIGNAL_UNKILLABLE` 任务对默认处理的内核信号有特殊豁免。\n- 内核线程（`PF_KTHREAD`）仅响应强制（`force=true`）的内核信号。\n- 若任务被 ptrace 跟踪，除 `SIGKILL` 外，即使信号被忽略也需通知调试器。\n\n### 挂起信号检测优化\n`has_pending_signals()` 使用位运算高效检查 `signal & ~blocked` 是否非零，并针对 `_NSIG_WORDS` 的常见值（1、2、4）进行展开优化，避免循环开销。\n\n### 信号选择策略\n`next_signal()` 优先处理同步信号（定义在 `SYNCHRONOUS_MASK` 中），确保如段错误、非法指令等异常能被及时响应，符合 POSIX 对同步信号“立即投递”的要求。\n\n### TIF_SIGPENDING 标志管理\n- `recalc_sigpending_tsk()` 综合检查私有/共享挂起信号、作业控制状态和 cgroup 冻结状态，决定是否设置 `TIF_SIGPENDING`。\n- 为避免竞态，**不清除**该标志，仅由明确知道安全的调用者（如 `recalc_sigpending()`）在适当上下文中清除。\n- `recalc_sigpending_and_wake()` 在设置标志后主动唤醒任务，确保其能及时处理信号。\n\n### 作业控制集成\n通过 `jobctl` 字段和 `JOBCTL_*` 位掩码，支持 ptrace 和作业控制的复杂状态机（如停止、陷阱、信号消费），并在 `siglock` 保护下安全更新。\n\n## 4. 依赖关系\n\n- **调度子系统**：依赖 `task_struct`、`thread_info` 标志（如 `TIF_SIGPENDING`）、`PF_EXITING` 等。\n- **内存管理**：使用 slab 分配器（`kmem_cache`）管理 `sigqueue`。\n- **进程管理**：与 `fork`/`exec`/`exit` 流程交互（如 `calculate_sigpending` 在 fork 后调用）。\n- **ptrace**：通过 `ptrace` 字段和 `JOBCTL_TRAPPING` 支持调试器信号拦截。\n- **cgroup/freezer**：检查 `cgroup_task_frozen()` 状态影响信号挂起判断。\n- **安全模块**：通过 `security_task_kill()` 等钩子（虽未在片段中体现，但完整文件包含）。\n- **tracepoint**：定义 `trace/events/signal.h` 中的跟踪点用于调试。\n- **架构相关代码**：依赖 `asm/siginfo.h`、`uaccess.h` 等处理用户空间信号帧。\n\n## 5. 使用场景\n\n- **系统调用处理**：`kill()`、`tkill()`、`rt_sigqueueinfo()` 等信号发送系统调用最终调用本文件逻辑。\n- **异常处理**：CPU 异常（如页错误、除零）触发同步信号（SIGSEGV、SIGFPE），由本文件选择并准备投递。\n- **进程生命周期管理**：在 `do_exit()`、`flush_old_exec()` 等路径中清理或重置信号状态。\n- **调试器支持**：ptrace 在注入信号或单步执行时依赖作业控制状态和信号忽略逻辑。\n- **资源限制**：当信号队列达到 `RLIMIT_SIGPENDING` 限制时，调用 `print_dropped_signal()` 记录丢弃事件。\n- **冻结/恢复**：cgroup freezer 或 suspend 流程通过 `cgroup_task_frozen()` 影响信号挂起状态，确保任务在冻结期间不处理信号。",
      "similarity": 0.49576592445373535,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/signal.c",
          "start_line": 394,
          "end_line": 495,
          "content": [
            "void task_join_group_stop(struct task_struct *task)",
            "{",
            "\tunsigned long mask = current->jobctl & JOBCTL_STOP_SIGMASK;",
            "\tstruct signal_struct *sig = current->signal;",
            "",
            "\tif (sig->group_stop_count) {",
            "\t\tsig->group_stop_count++;",
            "\t\tmask |= JOBCTL_STOP_CONSUME;",
            "\t} else if (!(sig->flags & SIGNAL_STOP_STOPPED))",
            "\t\treturn;",
            "",
            "\t/* Have the new thread join an on-going signal group stop */",
            "\ttask_set_jobctl_pending(task, mask | JOBCTL_STOP_PENDING);",
            "}",
            "static void __sigqueue_free(struct sigqueue *q)",
            "{",
            "\tif (q->flags & SIGQUEUE_PREALLOC)",
            "\t\treturn;",
            "\tif (q->ucounts) {",
            "\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);",
            "\t\tq->ucounts = NULL;",
            "\t}",
            "\tkmem_cache_free(sigqueue_cachep, q);",
            "}",
            "void flush_sigqueue(struct sigpending *queue)",
            "{",
            "\tstruct sigqueue *q;",
            "",
            "\tsigemptyset(&queue->signal);",
            "\twhile (!list_empty(&queue->list)) {",
            "\t\tq = list_entry(queue->list.next, struct sigqueue , list);",
            "\t\tlist_del_init(&q->list);",
            "\t\t__sigqueue_free(q);",
            "\t}",
            "}",
            "void flush_signals(struct task_struct *t)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&t->sighand->siglock, flags);",
            "\tclear_tsk_thread_flag(t, TIF_SIGPENDING);",
            "\tflush_sigqueue(&t->pending);",
            "\tflush_sigqueue(&t->signal->shared_pending);",
            "\tspin_unlock_irqrestore(&t->sighand->siglock, flags);",
            "}",
            "static void __flush_itimer_signals(struct sigpending *pending)",
            "{",
            "\tsigset_t signal, retain;",
            "\tstruct sigqueue *q, *n;",
            "",
            "\tsignal = pending->signal;",
            "\tsigemptyset(&retain);",
            "",
            "\tlist_for_each_entry_safe(q, n, &pending->list, list) {",
            "\t\tint sig = q->info.si_signo;",
            "",
            "\t\tif (likely(q->info.si_code != SI_TIMER)) {",
            "\t\t\tsigaddset(&retain, sig);",
            "\t\t} else {",
            "\t\t\tsigdelset(&signal, sig);",
            "\t\t\tlist_del_init(&q->list);",
            "\t\t\t__sigqueue_free(q);",
            "\t\t}",
            "\t}",
            "",
            "\tsigorsets(&pending->signal, &signal, &retain);",
            "}",
            "void flush_itimer_signals(void)",
            "{",
            "\tstruct task_struct *tsk = current;",
            "\tunsigned long flags;",
            "",
            "\tspin_lock_irqsave(&tsk->sighand->siglock, flags);",
            "\t__flush_itimer_signals(&tsk->pending);",
            "\t__flush_itimer_signals(&tsk->signal->shared_pending);",
            "\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);",
            "}",
            "void ignore_signals(struct task_struct *t)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < _NSIG; ++i)",
            "\t\tt->sighand->action[i].sa.sa_handler = SIG_IGN;",
            "",
            "\tflush_signals(t);",
            "}",
            "void",
            "flush_signal_handlers(struct task_struct *t, int force_default)",
            "{",
            "\tint i;",
            "\tstruct k_sigaction *ka = &t->sighand->action[0];",
            "\tfor (i = _NSIG ; i != 0 ; i--) {",
            "\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)",
            "\t\t\tka->sa.sa_handler = SIG_DFL;",
            "\t\tka->sa.sa_flags = 0;",
            "#ifdef __ARCH_HAS_SA_RESTORER",
            "\t\tka->sa.sa_restorer = NULL;",
            "#endif",
            "\t\tsigemptyset(&ka->sa.sa_mask);",
            "\t\tka++;",
            "\t}",
            "}"
          ],
          "function_name": "task_join_group_stop, __sigqueue_free, flush_sigqueue, flush_signals, __flush_itimer_signals, flush_itimer_signals, ignore_signals, flush_signal_handlers",
          "description": "实现信号队列清空操作，处理定时器信号过滤，强制忽略所有信号，并重置信号处理动作到默认行为。",
          "similarity": 0.58623206615448
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/signal.c",
          "start_line": 210,
          "end_line": 327,
          "content": [
            "int next_signal(struct sigpending *pending, sigset_t *mask)",
            "{",
            "\tunsigned long i, *s, *m, x;",
            "\tint sig = 0;",
            "",
            "\ts = pending->signal.sig;",
            "\tm = mask->sig;",
            "",
            "\t/*",
            "\t * Handle the first word specially: it contains the",
            "\t * synchronous signals that need to be dequeued first.",
            "\t */",
            "\tx = *s &~ *m;",
            "\tif (x) {",
            "\t\tif (x & SYNCHRONOUS_MASK)",
            "\t\t\tx &= SYNCHRONOUS_MASK;",
            "\t\tsig = ffz(~x) + 1;",
            "\t\treturn sig;",
            "\t}",
            "",
            "\tswitch (_NSIG_WORDS) {",
            "\tdefault:",
            "\t\tfor (i = 1; i < _NSIG_WORDS; ++i) {",
            "\t\t\tx = *++s &~ *++m;",
            "\t\t\tif (!x)",
            "\t\t\t\tcontinue;",
            "\t\t\tsig = ffz(~x) + i*_NSIG_BPW + 1;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tbreak;",
            "",
            "\tcase 2:",
            "\t\tx = s[1] &~ m[1];",
            "\t\tif (!x)",
            "\t\t\tbreak;",
            "\t\tsig = ffz(~x) + _NSIG_BPW + 1;",
            "\t\tbreak;",
            "",
            "\tcase 1:",
            "\t\t/* Nothing to do */",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn sig;",
            "}",
            "static inline void print_dropped_signal(int sig)",
            "{",
            "\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);",
            "",
            "\tif (!print_fatal_signals)",
            "\t\treturn;",
            "",
            "\tif (!__ratelimit(&ratelimit_state))",
            "\t\treturn;",
            "",
            "\tpr_info(\"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\",",
            "\t\t\t\tcurrent->comm, current->pid, sig);",
            "}",
            "bool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)",
            "{",
            "\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |",
            "\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));",
            "\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));",
            "",
            "\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))",
            "\t\treturn false;",
            "",
            "\tif (mask & JOBCTL_STOP_SIGMASK)",
            "\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;",
            "",
            "\ttask->jobctl |= mask;",
            "\treturn true;",
            "}",
            "void task_clear_jobctl_trapping(struct task_struct *task)",
            "{",
            "\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {",
            "\t\ttask->jobctl &= ~JOBCTL_TRAPPING;",
            "\t\tsmp_mb();\t/* advised by wake_up_bit() */",
            "\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);",
            "\t}",
            "}",
            "void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)",
            "{",
            "\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);",
            "",
            "\tif (mask & JOBCTL_STOP_PENDING)",
            "\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;",
            "",
            "\ttask->jobctl &= ~mask;",
            "",
            "\tif (!(task->jobctl & JOBCTL_PENDING_MASK))",
            "\t\ttask_clear_jobctl_trapping(task);",
            "}",
            "static bool task_participate_group_stop(struct task_struct *task)",
            "{",
            "\tstruct signal_struct *sig = task->signal;",
            "\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;",
            "",
            "\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));",
            "",
            "\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);",
            "",
            "\tif (!consume)",
            "\t\treturn false;",
            "",
            "\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))",
            "\t\tsig->group_stop_count--;",
            "",
            "\t/*",
            "\t * Tell the caller to notify completion iff we are entering into a",
            "\t * fresh group stop.  Read comment in do_signal_stop() for details.",
            "\t */",
            "\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {",
            "\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);",
            "\t\treturn true;",
            "\t}",
            "\treturn false;",
            "}"
          ],
          "function_name": "next_signal, print_dropped_signal, task_set_jobctl_pending, task_clear_jobctl_trapping, task_clear_jobctl_pending, task_participate_group_stop",
          "description": "实现信号选择算法和作业控制标志位管理，包含信号丢弃日志记录、停止状态标记清除及组停止参与检测等功能。",
          "similarity": 0.5644711852073669
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/signal.c",
          "start_line": 1,
          "end_line": 74,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/kernel/signal.c",
            " *",
            " *  Copyright (C) 1991, 1992  Linus Torvalds",
            " *",
            " *  1997-11-02  Modified for POSIX.1b signals by Richard Henderson",
            " *",
            " *  2003-06-02  Jim Houston - Concurrent Computer Corp.",
            " *\t\tChanges to use preallocated sigqueue structures",
            " *\t\tto allow signals to be sent reliably.",
            " */",
            "",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/tty.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/coredump.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/signal.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/task_work.h>",
            "#include <linux/capability.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compiler.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <uapi/linux/pidfd.h>",
            "",
            "#define CREATE_TRACE_POINTS",
            "#include <trace/events/signal.h>",
            "",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/unistd.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "",
            "/*",
            " * SLAB caches for signal bits.",
            " */",
            "",
            "static struct kmem_cache *sigqueue_cachep;",
            "",
            "int print_fatal_signals __read_mostly;",
            "",
            "static void __user *sig_handler(struct task_struct *t, int sig)",
            "{",
            "\treturn t->sighand->action[sig - 1].sa.sa_handler;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义信号队列缓存sigqueue_cachep并声明信号处理相关函数，提供信号处理动作查找函数sig_handler。",
          "similarity": 0.5518609285354614
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/signal.c",
          "start_line": 559,
          "end_line": 706,
          "content": [
            "bool unhandled_signal(struct task_struct *tsk, int sig)",
            "{",
            "\tvoid __user *handler = tsk->sighand->action[sig-1].sa.sa_handler;",
            "\tif (is_global_init(tsk))",
            "\t\treturn true;",
            "",
            "\tif (handler != SIG_IGN && handler != SIG_DFL)",
            "\t\treturn false;",
            "",
            "\t/* If dying, we handle all new signals by ignoring them */",
            "\tif (fatal_signal_pending(tsk))",
            "\t\treturn false;",
            "",
            "\t/* if ptraced, let the tracer determine */",
            "\treturn !tsk->ptrace;",
            "}",
            "static void collect_signal(int sig, struct sigpending *list, kernel_siginfo_t *info,",
            "\t\t\t   bool *resched_timer)",
            "{",
            "\tstruct sigqueue *q, *first = NULL;",
            "",
            "\t/*",
            "\t * Collect the siginfo appropriate to this signal.  Check if",
            "\t * there is another siginfo for the same signal.",
            "\t*/",
            "\tlist_for_each_entry(q, &list->list, list) {",
            "\t\tif (q->info.si_signo == sig) {",
            "\t\t\tif (first)",
            "\t\t\t\tgoto still_pending;",
            "\t\t\tfirst = q;",
            "\t\t}",
            "\t}",
            "",
            "\tsigdelset(&list->signal, sig);",
            "",
            "\tif (first) {",
            "still_pending:",
            "\t\tlist_del_init(&first->list);",
            "\t\tcopy_siginfo(info, &first->info);",
            "",
            "\t\t*resched_timer =",
            "\t\t\t(first->flags & SIGQUEUE_PREALLOC) &&",
            "\t\t\t(info->si_code == SI_TIMER) &&",
            "\t\t\t(info->si_sys_private);",
            "",
            "\t\t__sigqueue_free(first);",
            "\t} else {",
            "\t\t/*",
            "\t\t * Ok, it wasn't in the queue.  This must be",
            "\t\t * a fast-pathed signal or we must have been",
            "\t\t * out of queue space.  So zero out the info.",
            "\t\t */",
            "\t\tclear_siginfo(info);",
            "\t\tinfo->si_signo = sig;",
            "\t\tinfo->si_errno = 0;",
            "\t\tinfo->si_code = SI_USER;",
            "\t\tinfo->si_pid = 0;",
            "\t\tinfo->si_uid = 0;",
            "\t}",
            "}",
            "static int __dequeue_signal(struct sigpending *pending, sigset_t *mask,",
            "\t\t\tkernel_siginfo_t *info, bool *resched_timer)",
            "{",
            "\tint sig = next_signal(pending, mask);",
            "",
            "\tif (sig)",
            "\t\tcollect_signal(sig, pending, info, resched_timer);",
            "\treturn sig;",
            "}",
            "int dequeue_signal(struct task_struct *tsk, sigset_t *mask,",
            "\t\t   kernel_siginfo_t *info, enum pid_type *type)",
            "{",
            "\tbool resched_timer = false;",
            "\tint signr;",
            "",
            "\t/* We only dequeue private signals from ourselves, we don't let",
            "\t * signalfd steal them",
            "\t */",
            "\t*type = PIDTYPE_PID;",
            "\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);",
            "\tif (!signr) {",
            "\t\t*type = PIDTYPE_TGID;",
            "\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,",
            "\t\t\t\t\t mask, info, &resched_timer);",
            "#ifdef CONFIG_POSIX_TIMERS",
            "\t\t/*",
            "\t\t * itimer signal ?",
            "\t\t *",
            "\t\t * itimers are process shared and we restart periodic",
            "\t\t * itimers in the signal delivery path to prevent DoS",
            "\t\t * attacks in the high resolution timer case. This is",
            "\t\t * compliant with the old way of self-restarting",
            "\t\t * itimers, as the SIGALRM is a legacy signal and only",
            "\t\t * queued once. Changing the restart behaviour to",
            "\t\t * restart the timer in the signal dequeue path is",
            "\t\t * reducing the timer noise on heavy loaded !highres",
            "\t\t * systems too.",
            "\t\t */",
            "\t\tif (unlikely(signr == SIGALRM)) {",
            "\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;",
            "",
            "\t\t\tif (!hrtimer_is_queued(tmr) &&",
            "\t\t\t    tsk->signal->it_real_incr != 0) {",
            "\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),",
            "\t\t\t\t\t\ttsk->signal->it_real_incr);",
            "\t\t\t\thrtimer_restart(tmr);",
            "\t\t\t}",
            "\t\t}",
            "#endif",
            "\t}",
            "",
            "\trecalc_sigpending();",
            "\tif (!signr)",
            "\t\treturn 0;",
            "",
            "\tif (unlikely(sig_kernel_stop(signr))) {",
            "\t\t/*",
            "\t\t * Set a marker that we have dequeued a stop signal.  Our",
            "\t\t * caller might release the siglock and then the pending",
            "\t\t * stop signal it is about to process is no longer in the",
            "\t\t * pending bitmasks, but must still be cleared by a SIGCONT",
            "\t\t * (and overruled by a SIGKILL).  So those cases clear this",
            "\t\t * shared flag after we've set it.  Note that this flag may",
            "\t\t * remain set after the signal we return is ignored or",
            "\t\t * handled.  That doesn't matter because its only purpose",
            "\t\t * is to alert stop-signal processing code when another",
            "\t\t * processor has come along and cleared the flag.",
            "\t\t */",
            "\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;",
            "\t}",
            "#ifdef CONFIG_POSIX_TIMERS",
            "\tif (resched_timer) {",
            "\t\t/*",
            "\t\t * Release the siglock to ensure proper locking order",
            "\t\t * of timer locks outside of siglocks.  Note, we leave",
            "\t\t * irqs disabled here, since the posix-timers code is",
            "\t\t * about to disable them again anyway.",
            "\t\t */",
            "\t\tspin_unlock(&tsk->sighand->siglock);",
            "\t\tposixtimer_rearm(info);",
            "\t\tspin_lock(&tsk->sighand->siglock);",
            "",
            "\t\t/* Don't expose the si_sys_private value to userspace */",
            "\t\tinfo->si_sys_private = 0;",
            "\t}",
            "#endif",
            "\treturn signr;",
            "}"
          ],
          "function_name": "unhandled_signal, collect_signal, __dequeue_signal, dequeue_signal",
          "description": "实现信号处理路径，包含未处理信号判定、信号信息收集、信号队列弹出操作及特殊信号（如SIGALRM）的处理逻辑。",
          "similarity": 0.5432927012443542
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/signal.c",
          "start_line": 1081,
          "end_line": 1200,
          "content": [
            "static inline bool legacy_queue(struct sigpending *signals, int sig)",
            "{",
            "\treturn (sig < SIGRTMIN) && sigismember(&signals->signal, sig);",
            "}",
            "static int __send_signal_locked(int sig, struct kernel_siginfo *info,",
            "\t\t\t\tstruct task_struct *t, enum pid_type type, bool force)",
            "{",
            "\tstruct sigpending *pending;",
            "\tstruct sigqueue *q;",
            "\tint override_rlimit;",
            "\tint ret = 0, result;",
            "",
            "\tlockdep_assert_held(&t->sighand->siglock);",
            "",
            "\tresult = TRACE_SIGNAL_IGNORED;",
            "\tif (!prepare_signal(sig, t, force))",
            "\t\tgoto ret;",
            "",
            "\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;",
            "\t/*",
            "\t * Short-circuit ignored signals and support queuing",
            "\t * exactly one non-rt signal, so that we can get more",
            "\t * detailed information about the cause of the signal.",
            "\t */",
            "\tresult = TRACE_SIGNAL_ALREADY_PENDING;",
            "\tif (legacy_queue(pending, sig))",
            "\t\tgoto ret;",
            "",
            "\tresult = TRACE_SIGNAL_DELIVERED;",
            "\t/*",
            "\t * Skip useless siginfo allocation for SIGKILL and kernel threads.",
            "\t */",
            "\tif ((sig == SIGKILL) || (t->flags & PF_KTHREAD))",
            "\t\tgoto out_set;",
            "",
            "\t/*",
            "\t * Real-time signals must be queued if sent by sigqueue, or",
            "\t * some other real-time mechanism.  It is implementation",
            "\t * defined whether kill() does so.  We attempt to do so, on",
            "\t * the principle of least surprise, but since kill is not",
            "\t * allowed to fail with EAGAIN when low on memory we just",
            "\t * make sure at least one signal gets delivered and don't",
            "\t * pass on the info struct.",
            "\t */",
            "\tif (sig < SIGRTMIN)",
            "\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);",
            "\telse",
            "\t\toverride_rlimit = 0;",
            "",
            "\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, 0);",
            "",
            "\tif (q) {",
            "\t\tlist_add_tail(&q->list, &pending->list);",
            "\t\tswitch ((unsigned long) info) {",
            "\t\tcase (unsigned long) SEND_SIG_NOINFO:",
            "\t\t\tclear_siginfo(&q->info);",
            "\t\t\tq->info.si_signo = sig;",
            "\t\t\tq->info.si_errno = 0;",
            "\t\t\tq->info.si_code = SI_USER;",
            "\t\t\tq->info.si_pid = task_tgid_nr_ns(current,",
            "\t\t\t\t\t\t\ttask_active_pid_ns(t));",
            "\t\t\trcu_read_lock();",
            "\t\t\tq->info.si_uid =",
            "\t\t\t\tfrom_kuid_munged(task_cred_xxx(t, user_ns),",
            "\t\t\t\t\t\t current_uid());",
            "\t\t\trcu_read_unlock();",
            "\t\t\tbreak;",
            "\t\tcase (unsigned long) SEND_SIG_PRIV:",
            "\t\t\tclear_siginfo(&q->info);",
            "\t\t\tq->info.si_signo = sig;",
            "\t\t\tq->info.si_errno = 0;",
            "\t\t\tq->info.si_code = SI_KERNEL;",
            "\t\t\tq->info.si_pid = 0;",
            "\t\t\tq->info.si_uid = 0;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tcopy_siginfo(&q->info, info);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t} else if (!is_si_special(info) &&",
            "\t\t   sig >= SIGRTMIN && info->si_code != SI_USER) {",
            "\t\t/*",
            "\t\t * Queue overflow, abort.  We may abort if the",
            "\t\t * signal was rt and sent by user using something",
            "\t\t * other than kill().",
            "\t\t */",
            "\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;",
            "\t\tret = -EAGAIN;",
            "\t\tgoto ret;",
            "\t} else {",
            "\t\t/*",
            "\t\t * This is a silent loss of information.  We still",
            "\t\t * send the signal, but the *info bits are lost.",
            "\t\t */",
            "\t\tresult = TRACE_SIGNAL_LOSE_INFO;",
            "\t}",
            "",
            "out_set:",
            "\tsignalfd_notify(t, sig);",
            "\tsigaddset(&pending->signal, sig);",
            "",
            "\t/* Let multiprocess signals appear after on-going forks */",
            "\tif (type > PIDTYPE_TGID) {",
            "\t\tstruct multiprocess_signals *delayed;",
            "\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {",
            "\t\t\tsigset_t *signal = &delayed->signal;",
            "\t\t\t/* Can't queue both a stop and a continue signal */",
            "\t\t\tif (sig == SIGCONT)",
            "\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);",
            "\t\t\telse if (sig_kernel_stop(sig))",
            "\t\t\t\tsigdelset(signal, SIGCONT);",
            "\t\t\tsigaddset(signal, sig);",
            "\t\t}",
            "\t}",
            "",
            "\tcomplete_signal(sig, t, type);",
            "ret:",
            "\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "legacy_queue, __send_signal_locked",
          "description": "legacy_queue 判断是否为传统非实时信号队列。__send_signal_locked 发送信号到目标进程，分配信号队列项，设置信号信息并触发信号处理流程，处理信号队列溢出情况。",
          "similarity": 0.5329029560089111
        }
      ]
    },
    {
      "source_file": "kernel/time/tick-broadcast-hrtimer.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:47:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\tick-broadcast-hrtimer.c`\n\n---\n\n# `time/tick-broadcast-hrtimer.c` 技术文档\n\n## 1. 文件概述\n\n该文件实现了基于高分辨率定时器（hrtimer）的广播时钟事件设备（tick broadcast device）模拟机制。在某些系统（如无本地 APIC 或本地时钟事件设备不支持唤醒 CPU 的平台）中，当 CPU 进入深度空闲状态时，无法接收本地定时器中断，此时需要一个全局的“广播”定时器来代替本地时钟事件设备，在需要时唤醒所有等待广播事件的 CPU。本文件通过一个全局的 hrtimer 实例，模拟出一个虚拟的广播时钟事件设备，用于在单 CPU 或多 CPU 系统中提供统一的广播定时服务。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`bctimer`**：全局静态的 `hrtimer` 实例，作为广播定时器的核心实现。\n- **`ce_broadcast_hrtimer`**：`clock_event_device` 类型的结构体，代表一个虚拟的广播时钟事件设备，注册到内核时钟事件子系统中。\n\n### 主要函数\n\n- **`bc_shutdown()`**：实现广播设备的关闭操作，调用 `hrtimer_try_to_cancel()` 尝试取消定时器，避免死锁。\n- **`bc_set_next()`**：设置下一次广播事件的到期时间，调用 `hrtimer_start()` 启动高分辨率定时器，并更新设备绑定的 CPU（`bound_on` 字段）。\n- **`bc_handler()`**：hrtimer 到期时的回调函数，触发广播设备的事件处理函数（`event_handler`），进而调用通用的广播处理逻辑（如 `tick_handle_oneshot_broadcast()`）。\n- **`tick_setup_hrtimer_broadcast()`**：初始化广播 hrtimer 并注册虚拟时钟事件设备到内核。\n\n## 3. 关键实现\n\n- **避免死锁的设计**：  \n  在 `bc_shutdown()` 和 `bc_set_next()` 中，均避免直接调用 `hrtimer_cancel()`，因为该函数可能等待回调执行完毕，而回调函数（`bc_handler`）内部会尝试获取 `tick_broadcast_lock`，若调用者已持有该锁，则会导致死锁。因此使用非阻塞的 `hrtimer_try_to_cancel()`。\n\n- **CPU 绑定机制**：  \n  `bc_set_next()` 在启动 hrtimer 时使用 `HRTIMER_MODE_ABS_PINNED_HARD` 模式，确保定时器在当前 CPU 上执行（若回调未运行）。随后通过读取 `bctimer.base->cpu_base->cpu` 设置 `ce_broadcast_hrtimer.bound_on`，告知 tick 广播子系统该广播定时器当前绑定在哪个 CPU 上，防止该 CPU 进入无法被唤醒的深度空闲状态。\n\n- **线程安全性**：  \n  所有对 `bctimer` 的操作（如 `hrtimer_start` 和 `hrtimer_try_to_cancel`）均在持有 `tick_broadcast_lock` 的上下文中执行，保证了对广播设备状态修改的原子性。同时，由于该锁的存在，`bound_on` 的读取无需额外加锁。\n\n- **事件分发**：  \n  hrtimer 到期后，`bc_handler()` 调用 `ce_broadcast_hrtimer.event_handler()`，该回调由 tick 广播子系统在注册设备时设置（通常指向 `tick_handle_oneshot_broadcast`），负责唤醒所有等待广播事件的 CPU 并处理 pending 的 tick。\n\n## 4. 依赖关系\n\n- **`<linux/hrtimer.h>`**：依赖高分辨率定时器子系统，用于实现精确的单次广播事件。\n- **`<linux/clockchips.h>`**：依赖时钟事件设备框架，用于注册虚拟的广播设备。\n- **`\"tick-internal.h\"`**：依赖内核 tick 管理内部接口，特别是广播 tick 相关的锁和处理函数。\n- **`tick-broadcast.c`**：与通用 tick 广播逻辑紧密耦合，本设备作为其后备实现之一，由 `tick_broadcast_setup_hrtimer()` 调用 `tick_setup_hrtimer_broadcast()` 进行初始化。\n\n## 5. 使用场景\n\n- **无本地时钟事件设备的系统**：在某些嵌入式或虚拟化环境中，CPU 可能缺乏支持唤醒的本地定时器，此时必须依赖广播机制维持系统 tick。\n- **深度 C-state 电源管理**：当 CPU 进入 C3 或更深的空闲状态时，本地 APIC 定时器可能被关闭，需由广播设备代替其功能。\n- **单 CPU 系统的简化实现**：在单核系统中，可直接使用此 hrtimer 广播设备作为 tick 源，无需复杂的多 CPU 同步逻辑。\n- **作为通用广播后备方案**：当系统未配置硬件广播设备（如 HPET 或 IO-APIC）时，内核可回退到此基于 hrtimer 的软件实现。",
      "similarity": 0.49314022064208984,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/time/tick-broadcast-hrtimer.c",
          "start_line": 20,
          "end_line": 81,
          "content": [
            "static int bc_shutdown(struct clock_event_device *evt)",
            "{",
            "\t/*",
            "\t * Note, we cannot cancel the timer here as we might",
            "\t * run into the following live lock scenario:",
            "\t *",
            "\t * cpu 0\t\tcpu1",
            "\t * lock(broadcast_lock);",
            "\t *\t\t\thrtimer_interrupt()",
            "\t *\t\t\tbc_handler()",
            "\t *\t\t\t   tick_handle_oneshot_broadcast();",
            "\t *\t\t\t    lock(broadcast_lock);",
            "\t * hrtimer_cancel()",
            "\t *  wait_for_callback()",
            "\t */",
            "\thrtimer_try_to_cancel(&bctimer);",
            "\treturn 0;",
            "}",
            "static int bc_set_next(ktime_t expires, struct clock_event_device *bc)",
            "{",
            "\t/*",
            "\t * This is called either from enter/exit idle code or from the",
            "\t * broadcast handler. In all cases tick_broadcast_lock is held.",
            "\t *",
            "\t * hrtimer_cancel() cannot be called here neither from the",
            "\t * broadcast handler nor from the enter/exit idle code. The idle",
            "\t * code can run into the problem described in bc_shutdown() and the",
            "\t * broadcast handler cannot wait for itself to complete for obvious",
            "\t * reasons.",
            "\t *",
            "\t * Each caller tries to arm the hrtimer on its own CPU, but if the",
            "\t * hrtimer callback function is currently running, then",
            "\t * hrtimer_start() cannot move it and the timer stays on the CPU on",
            "\t * which it is assigned at the moment.",
            "\t */",
            "\thrtimer_start(&bctimer, expires, HRTIMER_MODE_ABS_PINNED_HARD);",
            "\t/*",
            "\t * The core tick broadcast mode expects bc->bound_on to be set",
            "\t * correctly to prevent a CPU which has the broadcast hrtimer",
            "\t * armed from going deep idle.",
            "\t *",
            "\t * As tick_broadcast_lock is held, nothing can change the cpu",
            "\t * base which was just established in hrtimer_start() above. So",
            "\t * the below access is safe even without holding the hrtimer",
            "\t * base lock.",
            "\t */",
            "\tbc->bound_on = bctimer.base->cpu_base->cpu;",
            "",
            "\treturn 0;",
            "}",
            "static enum hrtimer_restart bc_handler(struct hrtimer *t)",
            "{",
            "\tce_broadcast_hrtimer.event_handler(&ce_broadcast_hrtimer);",
            "",
            "\treturn HRTIMER_NORESTART;",
            "}",
            "void tick_setup_hrtimer_broadcast(void)",
            "{",
            "\thrtimer_init(&bctimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD);",
            "\tbctimer.function = bc_handler;",
            "\tclockevents_register_device(&ce_broadcast_hrtimer);",
            "}"
          ],
          "function_name": "bc_shutdown, bc_set_next, bc_handler, tick_setup_hrtimer_broadcast",
          "description": "实现广播定时器控制逻辑，包含关闭定时器防止死锁、设置下次超时时间、处理中断回调及初始化广播定时器设备的函数集合",
          "similarity": 0.48091837763786316
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/time/tick-broadcast-hrtimer.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Emulate a local clock event device via a pseudo clock device.",
            " */",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/clockchips.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "",
            "#include \"tick-internal.h\"",
            "",
            "static struct hrtimer bctimer;",
            ""
          ],
          "function_name": null,
          "description": "定义用于广播式高精度定时器的全局hrtimer结构体实例，作为伪时钟设备实现基础",
          "similarity": 0.4342701733112335
        }
      ]
    }
  ]
}