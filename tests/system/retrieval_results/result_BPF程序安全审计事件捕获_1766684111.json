{
  "query": "BPF程序安全审计事件捕获",
  "timestamp": "2025-12-26 01:35:11",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/cpumask.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:07:30\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\cpumask.c`\n\n---\n\n# `bpf/cpumask.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/cpumask.c` 实现了 BPF（Berkeley Packet Filter）子系统中用于 CPU 掩码（cpumask）操作的一组内核函数（kfuncs）。该文件定义了一个引用计数的 `struct bpf_cpumask` 结构体，并提供了一系列安全、非阻塞的 BPF 可调用接口，用于创建、操作、查询和释放 cpumask 对象。这些接口专为 BPF 程序设计，确保与 BPF 验证器兼容，并通过 BPF 内存分配器实现 RCU 安全的内存管理。\n\n## 2. 核心功能\n\n### 数据结构\n\n- **`struct bpf_cpumask`**  \n  引用计数的 BPF cpumask 包装结构体：\n  - `cpumask_t cpumask`：嵌入的实际 cpumask 位图。\n  - `refcount_t usage`：引用计数器，归零时通过 RCU 回调释放内存。\n\n### 主要函数（BPF kfuncs）\n\n| 函数 | 功能 |\n|------|------|\n| `bpf_cpumask_create()` | 创建一个新的可变 BPF cpumask 对象 |\n| `bpf_cpumask_acquire()` | 增加 cpumask 引用计数 |\n| `bpf_cpumask_release()` | 减少引用计数，归零时异步释放内存 |\n| `bpf_cpumask_first()` | 返回 cpumask 中第一个设置的 CPU 编号 |\n| `bpf_cpumask_first_zero()` | 返回 cpumask 中第一个未设置的 CPU 编号 |\n| `bpf_cpumask_first_and()` | 返回两个 cpumask 按位与后第一个设置的 CPU 编号 |\n| `bpf_cpumask_set_cpu()` | 设置指定 CPU 位 |\n| `bpf_cpumask_clear_cpu()` | 清除指定 CPU 位 |\n| `bpf_cpumask_test_cpu()` | 测试指定 CPU 是否被设置 |\n| `bpf_cpumask_test_and_set_cpu()` | 原子地测试并设置指定 CPU 位 |\n| `bpf_cpumask_test_and_clear_cpu()` | 原子地测试并清除指定 CPU 位 |\n| `bpf_cpumask_setall()` | 设置所有有效 CPU 位 |\n| `bpf_cpumask_clear()` | 清除所有 CPU 位 |\n| `bpf_cpumask_and()` | 对两个 cpumask 执行按位与操作并存入目标 |\n\n> 所有函数均使用 `__bpf_kfunc` 标记，表示其为 BPF 程序可安全调用的内核函数。\n\n## 3. 关键实现\n\n### 内存管理与引用计数\n- 使用 `bpf_mem_alloc` 子系统（`bpf_cpumask_ma`）进行非阻塞内存分配。\n- `bpf_cpumask_release()` 在引用计数归零时调用 `bpf_mem_cache_free_rcu()`，确保在 RCU 宽限期后释放内存，避免并发访问问题。\n- 释放前调用 `migrate_disable()`/`migrate_enable()` 禁用 CPU 迁移，保证 RCU 回调上下文安全。\n\n### 与 cpumask 类型兼容性\n- 显式嵌入 `cpumask_t`（而非 `cpumask_var_t`），避免因 `CONFIG_CPUMASK_OFFSTACK` 配置差异导致 BPF 验证器类型混淆。\n- 通过 `BUILD_BUG_ON(offsetof(...) != 0)` 确保 `cpumask` 成员位于结构体起始位置，允许安全地将 `struct bpf_cpumask *` 强制转换为 `struct cpumask *`。\n\n### CPU 有效性检查\n- 所有涉及 CPU 编号的操作（如 `set_cpu`、`test_cpu` 等）均先调用 `cpu_valid(u32 cpu)` 验证 `cpu < nr_cpu_ids`，防止越界访问。\n\n### BPF 验证器兼容性\n- 所有导出函数使用 `__bpf_kfunc` 宏声明，确保被 BPF 验证器识别为合法调用目标。\n- 参数类型设计（如接受 `const struct cpumask *`）允许 BPF 程序传入 `struct bpf_cpumask *` 指针，利用结构体布局兼容性。\n\n## 4. 依赖关系\n\n- **`<linux/bpf.h>`**：BPF 核心头文件，提供 kfunc 声明宏。\n- **`<linux/bpf_mem_alloc.h>`**：BPF 内存分配器接口，用于 RCU 安全的对象分配与释放。\n- **`<linux/cpumask.h>`**：标准 cpumask 操作函数（如 `cpumask_set_cpu`、`cpumask_first` 等）。\n- **`<linux/refcount.h>`**：引用计数原语（通过 `refcount_t` 和相关操作）。\n- **`<linux/btf.h>` / `<linux/btf_ids.h>`**：支持 BTF（BPF Type Format）类型信息生成，用于 kfunc 元数据。\n\n## 5. 使用场景\n\n- **BPF 程序中的 CPU 亲和性控制**：例如在调度器 BPF 程序中动态构造或修改任务的 CPU 亲和掩码。\n- **资源隔离与负载均衡**：网络或跟踪 BPF 程序可根据系统状态动态生成 CPU 掩码，用于指导工作线程绑定。\n- **安全策略实施**：限制某些 BPF 程序仅在特定 CPU 集合上执行。\n- **与 BPF map 集成**：通过 `kptr`（内核指针）将 `struct bpf_cpumask` 存入 BPF map，实现跨 BPF 程序实例共享或持久化 cpumask 状态。\n- **原子操作支持**：`test_and_set`/`test_and_clear` 等接口适用于需要无锁并发修改 cpumask 的场景。",
      "similarity": 0.6156890988349915,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/cpumask.c",
          "start_line": 374,
          "end_line": 467,
          "content": [
            "__bpf_kfunc bool bpf_cpumask_full(const struct cpumask *cpumask)",
            "{",
            "\treturn cpumask_full(cpumask);",
            "}",
            "__bpf_kfunc void bpf_cpumask_copy(struct bpf_cpumask *dst, const struct cpumask *src)",
            "{",
            "\tcpumask_copy((struct cpumask *)dst, src);",
            "}",
            "__bpf_kfunc u32 bpf_cpumask_any_distribute(const struct cpumask *cpumask)",
            "{",
            "\treturn cpumask_any_distribute(cpumask);",
            "}",
            "__bpf_kfunc u32 bpf_cpumask_any_and_distribute(const struct cpumask *src1,",
            "\t\t\t\t\t       const struct cpumask *src2)",
            "{",
            "\treturn cpumask_any_and_distribute(src1, src2);",
            "}",
            "__bpf_kfunc u32 bpf_cpumask_weight(const struct cpumask *cpumask)",
            "{",
            "\treturn cpumask_weight(cpumask);",
            "}",
            "__bpf_kfunc int bpf_cpumask_populate(struct cpumask *cpumask, void *src, size_t src__sz)",
            "{",
            "\tunsigned long source = (unsigned long)src;",
            "",
            "\t/* The memory region must be large enough to populate the entire CPU mask. */",
            "\tif (src__sz < bitmap_size(nr_cpu_ids))",
            "\t\treturn -EACCES;",
            "",
            "\t/* If avoiding unaligned accesses, the input region must be aligned to the nearest long. */",
            "\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) &&",
            "\t\t!IS_ALIGNED(source, sizeof(long)))",
            "\t\treturn -EINVAL;",
            "",
            "\tbitmap_copy(cpumask_bits(cpumask), src, nr_cpu_ids);",
            "",
            "\treturn 0;",
            "}",
            "BTF_KFUNCS_START(cpumask_kfunc_btf_ids)",
            "BTF_ID_FLAGS(func, bpf_cpumask_create, KF_ACQUIRE | KF_RET_NULL)",
            "BTF_ID_FLAGS(func, bpf_cpumask_release, KF_RELEASE)",
            "BTF_ID_FLAGS(func, bpf_cpumask_acquire, KF_ACQUIRE | KF_TRUSTED_ARGS)",
            "BTF_ID_FLAGS(func, bpf_cpumask_first, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_first_zero, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_first_and, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_set_cpu, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_clear_cpu, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_test_cpu, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_test_and_set_cpu, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_test_and_clear_cpu, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_setall, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_clear, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_and, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_or, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_xor, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_equal, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_intersects, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_subset, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_empty, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_full, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_copy, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_any_distribute, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_any_and_distribute, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_weight, KF_RCU)",
            "BTF_ID_FLAGS(func, bpf_cpumask_populate, KF_RCU)",
            "BTF_KFUNCS_END(cpumask_kfunc_btf_ids)",
            "",
            "static const struct btf_kfunc_id_set cpumask_kfunc_set = {",
            "\t.owner = THIS_MODULE,",
            "\t.set   = &cpumask_kfunc_btf_ids,",
            "};",
            "",
            "BTF_ID_LIST(cpumask_dtor_ids)",
            "BTF_ID(struct, bpf_cpumask)",
            "BTF_ID(func, bpf_cpumask_release)",
            "",
            "static int __init cpumask_kfunc_init(void)",
            "{",
            "\tint ret;",
            "\tconst struct btf_id_dtor_kfunc cpumask_dtors[] = {",
            "\t\t{",
            "\t\t\t.btf_id\t      = cpumask_dtor_ids[0],",
            "\t\t\t.kfunc_btf_id = cpumask_dtor_ids[1]",
            "\t\t},",
            "\t};",
            "",
            "\tret = bpf_mem_alloc_init(&bpf_cpumask_ma, sizeof(struct bpf_cpumask), false);",
            "\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_TRACING, &cpumask_kfunc_set);",
            "\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_STRUCT_OPS, &cpumask_kfunc_set);",
            "\tret = ret ?: register_btf_kfunc_id_set(BPF_PROG_TYPE_SYSCALL, &cpumask_kfunc_set);",
            "\treturn  ret ?: register_btf_id_dtor_kfuncs(cpumask_dtors,",
            "\t\t\t\t\t\t   ARRAY_SIZE(cpumask_dtors),",
            "\t\t\t\t\t\t   THIS_MODULE);",
            "}"
          ],
          "function_name": "bpf_cpumask_full, bpf_cpumask_copy, bpf_cpumask_any_distribute, bpf_cpumask_any_and_distribute, bpf_cpumask_weight, bpf_cpumask_populate, BTF_ID_FLAGS",
          "description": "提供了CPU掩码数据填充、权重计算等扩展功能，并通过BTF ID标注系统注册所有kfunc到指定ID集合，包含内存分配器初始化、KFUNC集注册及析构函数注册逻辑，实现BPF程序对CPU掩码对象的全生命周期管理。",
          "similarity": 0.596794843673706
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/cpumask.c",
          "start_line": 32,
          "end_line": 134,
          "content": [
            "static bool cpu_valid(u32 cpu)",
            "{",
            "\treturn cpu < nr_cpu_ids;",
            "}",
            "__bpf_kfunc void bpf_cpumask_release(struct bpf_cpumask *cpumask)",
            "{",
            "\tif (!refcount_dec_and_test(&cpumask->usage))",
            "\t\treturn;",
            "",
            "\tmigrate_disable();",
            "\tbpf_mem_cache_free_rcu(&bpf_cpumask_ma, cpumask);",
            "\tmigrate_enable();",
            "}",
            "__bpf_kfunc u32 bpf_cpumask_first(const struct cpumask *cpumask)",
            "{",
            "\treturn cpumask_first(cpumask);",
            "}",
            "__bpf_kfunc u32 bpf_cpumask_first_zero(const struct cpumask *cpumask)",
            "{",
            "\treturn cpumask_first_zero(cpumask);",
            "}",
            "__bpf_kfunc u32 bpf_cpumask_first_and(const struct cpumask *src1,",
            "\t\t\t\t      const struct cpumask *src2)",
            "{",
            "\treturn cpumask_first_and(src1, src2);",
            "}",
            "__bpf_kfunc void bpf_cpumask_set_cpu(u32 cpu, struct bpf_cpumask *cpumask)",
            "{",
            "\tif (!cpu_valid(cpu))",
            "\t\treturn;",
            "",
            "\tcpumask_set_cpu(cpu, (struct cpumask *)cpumask);",
            "}",
            "__bpf_kfunc void bpf_cpumask_clear_cpu(u32 cpu, struct bpf_cpumask *cpumask)",
            "{",
            "\tif (!cpu_valid(cpu))",
            "\t\treturn;",
            "",
            "\tcpumask_clear_cpu(cpu, (struct cpumask *)cpumask);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_test_cpu(u32 cpu, const struct cpumask *cpumask)",
            "{",
            "\tif (!cpu_valid(cpu))",
            "\t\treturn false;",
            "",
            "\treturn cpumask_test_cpu(cpu, (struct cpumask *)cpumask);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_test_and_set_cpu(u32 cpu, struct bpf_cpumask *cpumask)",
            "{",
            "\tif (!cpu_valid(cpu))",
            "\t\treturn false;",
            "",
            "\treturn cpumask_test_and_set_cpu(cpu, (struct cpumask *)cpumask);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_test_and_clear_cpu(u32 cpu, struct bpf_cpumask *cpumask)",
            "{",
            "\tif (!cpu_valid(cpu))",
            "\t\treturn false;",
            "",
            "\treturn cpumask_test_and_clear_cpu(cpu, (struct cpumask *)cpumask);",
            "}",
            "__bpf_kfunc void bpf_cpumask_setall(struct bpf_cpumask *cpumask)",
            "{",
            "\tcpumask_setall((struct cpumask *)cpumask);",
            "}",
            "__bpf_kfunc void bpf_cpumask_clear(struct bpf_cpumask *cpumask)",
            "{",
            "\tcpumask_clear((struct cpumask *)cpumask);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_and(struct bpf_cpumask *dst,",
            "\t\t\t\t const struct cpumask *src1,",
            "\t\t\t\t const struct cpumask *src2)",
            "{",
            "\treturn cpumask_and((struct cpumask *)dst, src1, src2);",
            "}",
            "__bpf_kfunc void bpf_cpumask_or(struct bpf_cpumask *dst,",
            "\t\t\t\tconst struct cpumask *src1,",
            "\t\t\t\tconst struct cpumask *src2)",
            "{",
            "\tcpumask_or((struct cpumask *)dst, src1, src2);",
            "}",
            "__bpf_kfunc void bpf_cpumask_xor(struct bpf_cpumask *dst,",
            "\t\t\t\t const struct cpumask *src1,",
            "\t\t\t\t const struct cpumask *src2)",
            "{",
            "\tcpumask_xor((struct cpumask *)dst, src1, src2);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_equal(const struct cpumask *src1, const struct cpumask *src2)",
            "{",
            "\treturn cpumask_equal(src1, src2);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_intersects(const struct cpumask *src1, const struct cpumask *src2)",
            "{",
            "\treturn cpumask_intersects(src1, src2);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_subset(const struct cpumask *src1, const struct cpumask *src2)",
            "{",
            "\treturn cpumask_subset(src1, src2);",
            "}",
            "__bpf_kfunc bool bpf_cpumask_empty(const struct cpumask *cpumask)",
            "{",
            "\treturn cpumask_empty(cpumask);",
            "}"
          ],
          "function_name": "cpu_valid, bpf_cpumask_release, bpf_cpumask_first, bpf_cpumask_first_zero, bpf_cpumask_first_and, bpf_cpumask_set_cpu, bpf_cpumask_clear_cpu, bpf_cpumask_test_cpu, bpf_cpumask_test_and_set_cpu, bpf_cpumask_test_and_clear_cpu, bpf_cpumask_setall, bpf_cpumask_clear, bpf_cpumask_and, bpf_cpumask_or, bpf_cpumask_xor, bpf_cpumask_equal, bpf_cpumask_intersects, bpf_cpumask_subset, bpf_cpumask_empty",
          "description": "实现了针对bpf_cpumask的各类CPU掩码操作函数，包括引用计数释放、位操作、集合运算及状态查询等功能，所有函数均通过__bpf_kfunc声明为可被BPF程序调用的内核接口，其中release函数负责RCU安全的内存回收。",
          "similarity": 0.5951409339904785
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/cpumask.c",
          "start_line": 1,
          "end_line": 31,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2023 Meta, Inc */",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_mem_alloc.h>",
            "#include <linux/btf.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/cpumask.h>",
            "",
            "/**",
            " * struct bpf_cpumask - refcounted BPF cpumask wrapper structure",
            " * @cpumask:\tThe actual cpumask embedded in the struct.",
            " * @usage:\tObject reference counter. When the refcount goes to 0, the",
            " *\t\tmemory is released back to the BPF allocator, which provides",
            " *\t\tRCU safety.",
            " *",
            " * Note that we explicitly embed a cpumask_t rather than a cpumask_var_t.  This",
            " * is done to avoid confusing the verifier due to the typedef of cpumask_var_t",
            " * changing depending on whether CONFIG_CPUMASK_OFFSTACK is defined or not. See",
            " * the details in <linux/cpumask.h>. The consequence is that this structure is",
            " * likely a bit larger than it needs to be when CONFIG_CPUMASK_OFFSTACK is",
            " * defined due to embedding the whole NR_CPUS-size bitmap, but the extra memory",
            " * overhead is minimal. For the more typical case of CONFIG_CPUMASK_OFFSTACK",
            " * not being defined, the structure is the same size regardless.",
            " */",
            "struct bpf_cpumask {",
            "\tcpumask_t cpumask;",
            "\trefcount_t usage;",
            "};",
            "",
            "static struct bpf_mem_alloc bpf_cpumask_ma;",
            ""
          ],
          "function_name": null,
          "description": "定义了bpf_cpumask结构体，包含cpumask_t类型的cpumask字段和引用计数器usage，用于包装并管理BPF程序中的CPU掩码对象，通过引用计数控制内存生命周期，避免直接使用typedef可能引起的验证器混淆问题。",
          "similarity": 0.5267738699913025
        }
      ]
    },
    {
      "source_file": "kernel/trace/bpf_trace.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:00:33\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `trace\\bpf_trace.c`\n\n---\n\n# `trace/bpf_trace.c` 技术文档\n\n## 1. 文件概述\n\n`trace/bpf_trace.c` 是 Linux 内核中 BPF（Berkeley Packet Filter）子系统与跟踪（tracing）基础设施集成的核心实现文件。该文件主要负责：\n\n- 提供 BPF 程序在 tracepoint、kprobe、uprobe 等动态跟踪点上执行的通用调用机制\n- 实现 BPF 程序可调用的辅助函数（helpers），用于安全地从用户空间或内核空间读取内存\n- 支持 BPF 程序对函数返回值的覆盖（override）功能（需配置 `CONFIG_BPF_KPROBE_OVERRIDE`）\n- 管理模块中定义的原始跟踪点（raw tracepoint）的查找与引用\n- 为 BPF 程序提供上下文信息（如栈信息、cookie、入口地址等）\n\n该文件是 BPF tracing 功能的关键桥梁，连接了 BPF 执行引擎与内核的动态跟踪子系统。\n\n## 2. 核心功能\n\n### 主要函数\n\n| 函数 | 功能描述 |\n|------|--------|\n| `trace_call_bpf()` | 在指定 tracepoint 上执行关联的 BPF 程序数组，返回过滤结果 |\n| `bpf_probe_read_user()` | BPF 辅助函数：从用户空间安全读取任意内存 |\n| `bpf_probe_read_user_str()` | BPF 辅助函数：从用户空间安全读取以 null 结尾的字符串 |\n| `bpf_probe_read_kernel()` | BPF 辅助函数：从内核空间安全读取任意内存 |\n| `bpf_probe_read_kernel_str()` | BPF 辅助函数：从内核空间安全读取以 null 结尾的字符串 |\n| `bpf_override_return()` | BPF 辅助函数：覆盖被探测函数的返回值（仅限 kprobe） |\n| `bpf_get_raw_tracepoint_module()` | 在已加载内核模块中查找指定名称的原始跟踪点 |\n\n### 主要数据结构\n\n- `bpf_trace_module`：用于跟踪已注册 BPF 原始跟踪点的内核模块\n- `bpf_func_proto` 实例（如 `bpf_probe_read_user_proto`）：定义 BPF 辅助函数的类型签名和权限\n\n### 宏与常量\n\n- `MAX_UPROBE_MULTI_CNT` / `MAX_KPROBE_MULTI_CNT`：限制 multi-uprobe/kprobe 的最大数量（1M）\n- `bpf_event_rcu_dereference()`：带锁依赖检查的 RCU 解引用宏\n- `CREATE_TRACE_POINTS`：触发 `bpf_trace.h` 中跟踪点的实例化\n\n## 3. 关键实现\n\n### BPF 程序执行机制 (`trace_call_bpf`)\n\n- 使用 per-CPU 计数器 `bpf_prog_active` 防止 BPF 程序递归执行（避免死锁或栈溢出）\n- 通过 RCU 机制安全访问 `call->prog_array`（BPF 程序数组）\n- 若已有 BPF 程序在当前 CPU 上运行，则跳过执行并增加 miss 计数器\n- 返回值语义：`0` 表示过滤事件，非 `0` 表示保留事件（通常为 `1`）\n\n### 安全内存读取\n\n- **用户空间读取**：使用 `copy_from_user_nofault()` 和 `strncpy_from_user_nofault()`，即使地址无效也不会导致 oops\n- **内核空间读取**：使用 `probe_kernel_read()` 或 `strncpy_from_kernel_nofault()`（未在片段中显示但被调用）\n- **错误处理**：读取失败时清零目标缓冲区，防止信息泄露\n- **字符串处理**：特别注意 `strncpy_*_nofault` 不会自动清零缓冲区剩余部分，依赖调用者处理\n\n### 模块跟踪点管理\n\n- 在 `CONFIG_MODULES` 启用时，维护全局链表 `bpf_trace_modules`\n- 通过 `mutex` 保护模块列表遍历\n- 使用 `try_module_get()` 增加模块引用计数，防止卸载时访问非法内存\n\n### BPF 辅助函数注册\n\n- 所有 `bpf_probe_read_*` 函数标记为 `GPL-only`（`gpl_only = true`）\n- 参数类型严格校验：\n  - `ARG_PTR_TO_UNINIT_MEM`：目标缓冲区（BPF verifier 会验证大小）\n  - `ARG_CONST_SIZE_OR_ZERO`：读取大小（编译时常量或零）\n  - `ARG_ANYTHING`：源地址（由运行时检查有效性）\n\n## 4. 依赖关系\n\n### 内核子系统依赖\n\n- **BPF 核心**：`<linux/bpf.h>`, `bpf_prog_run_array()`, `bpf_prog_active`\n- **跟踪子系统**：`trace_event_call`, `trace_probe.h`, `trace.h`\n- **内存管理**：`copy_from_user_nofault`, `probe_kernel_read`\n- **模块系统**：`struct module`, `try_module_get`（条件编译）\n- **RCU 机制**：用于无锁访问 BPF 程序数组\n- **Kprobe/Uprobe**：`<linux/kprobes.h>`, `override_function_with_return`\n- **BTF（BPF Type Format）**：用于类型安全的内存访问（`bpf_btf_printf_prepare`）\n\n### 头文件依赖\n\n- 内核内部头文件：`trace_probe.h`, `trace.h`, `bpf_trace.h`\n- UAPI 头文件：`<uapi/linux/bpf.h>`, `<uapi/linux/btf.h>`\n- 架构相关：`<asm/tlb.h>`（可能用于内存屏障）\n\n## 5. 使用场景\n\n### BPF 程序开发\n\n- 用户通过 `bpf()` 系统调用加载 BPF 程序，并将其附加到：\n  - **Tracepoints**：通过 `BPF_PROG_TYPE_TRACEPOINT`\n  - **Kprobes/Uprobes**：通过 `BPF_PROG_TYPE_KPROBE`\n  - **Raw Tracepoints**：通过 `BPF_PROG_TYPE_RAW_TRACEPOINT`\n- 程序中调用 `bpf_probe_read_*` 安全访问进程内存或内核数据结构\n\n### 动态追踪\n\n- **性能分析**：在函数入口/出口收集栈信息、参数、返回值\n- **安全监控**：拦截敏感系统调用（如 `execve`）并检查参数\n- **故障注入**：使用 `bpf_override_return` 模拟错误返回（需 `CONFIG_BPF_KPROBE_OVERRIDE`）\n\n### 内核模块扩展\n\n- 第三方内核模块可通过 `EXPORT_BPF_RAW_TRACEPOINT()` 导出原始跟踪点\n- BPF 程序可在模块加载后动态附加到这些跟踪点\n\n### 调试与可观测性\n\n- 结合 `bpf_get_stackid()` / `bpf_get_stack()` 获取调用栈\n- 通过 `bpf_perf_event_output()` 将读取的数据发送到用户空间环形缓冲区",
      "similarity": 0.6130463480949402,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/trace/bpf_trace.c",
          "start_line": 110,
          "end_line": 217,
          "content": [
            "unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)",
            "{",
            "\tunsigned int ret;",
            "",
            "\tcant_sleep();",
            "",
            "\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {",
            "\t\t/*",
            "\t\t * since some bpf program is already running on this cpu,",
            "\t\t * don't call into another bpf program (same or different)",
            "\t\t * and don't send kprobe event into ring-buffer,",
            "\t\t * so return zero here",
            "\t\t */",
            "\t\trcu_read_lock();",
            "\t\tbpf_prog_inc_misses_counters(rcu_dereference(call->prog_array));",
            "\t\trcu_read_unlock();",
            "\t\tret = 0;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock",
            "\t * to all call sites, we did a bpf_prog_array_valid() there to check",
            "\t * whether call->prog_array is empty or not, which is",
            "\t * a heuristic to speed up execution.",
            "\t *",
            "\t * If bpf_prog_array_valid() fetched prog_array was",
            "\t * non-NULL, we go into trace_call_bpf() and do the actual",
            "\t * proper rcu_dereference() under RCU lock.",
            "\t * If it turns out that prog_array is NULL then, we bail out.",
            "\t * For the opposite, if the bpf_prog_array_valid() fetched pointer",
            "\t * was NULL, you'll skip the prog_array with the risk of missing",
            "\t * out of events when it was updated in between this and the",
            "\t * rcu_dereference() which is accepted risk.",
            "\t */",
            "\trcu_read_lock();",
            "\tret = bpf_prog_run_array(rcu_dereference(call->prog_array),",
            "\t\t\t\t ctx, bpf_prog_run);",
            "\trcu_read_unlock();",
            "",
            " out:",
            "\t__this_cpu_dec(bpf_prog_active);",
            "",
            "\treturn ret;",
            "}",
            "static __always_inline int",
            "bpf_probe_read_user_common(void *dst, u32 size, const void __user *unsafe_ptr)",
            "{",
            "\tint ret;",
            "",
            "\tret = copy_from_user_nofault(dst, unsafe_ptr, size);",
            "\tif (unlikely(ret < 0))",
            "\t\tmemset(dst, 0, size);",
            "\treturn ret;",
            "}",
            "static __always_inline int",
            "bpf_probe_read_user_str_common(void *dst, u32 size,",
            "\t\t\t       const void __user *unsafe_ptr)",
            "{",
            "\tint ret;",
            "",
            "\t/*",
            "\t * NB: We rely on strncpy_from_user() not copying junk past the NUL",
            "\t * terminator into `dst`.",
            "\t *",
            "\t * strncpy_from_user() does long-sized strides in the fast path. If the",
            "\t * strncpy does not mask out the bytes after the NUL in `unsafe_ptr`,",
            "\t * then there could be junk after the NUL in `dst`. If user takes `dst`",
            "\t * and keys a hash map with it, then semantically identical strings can",
            "\t * occupy multiple entries in the map.",
            "\t */",
            "\tret = strncpy_from_user_nofault(dst, unsafe_ptr, size);",
            "\tif (unlikely(ret < 0))",
            "\t\tmemset(dst, 0, size);",
            "\treturn ret;",
            "}",
            "static __always_inline int",
            "bpf_probe_read_kernel_str_common(void *dst, u32 size, const void *unsafe_ptr)",
            "{",
            "\tint ret;",
            "",
            "\t/*",
            "\t * The strncpy_from_kernel_nofault() call will likely not fill the",
            "\t * entire buffer, but that's okay in this circumstance as we're probing",
            "\t * arbitrary memory anyway similar to bpf_probe_read_*() and might",
            "\t * as well probe the stack. Thus, memory is explicitly cleared",
            "\t * only in error case, so that improper users ignoring return",
            "\t * code altogether don't copy garbage; otherwise length of string",
            "\t * is returned that can be used for bpf_perf_event_output() et al.",
            "\t */",
            "\tret = strncpy_from_kernel_nofault(dst, unsafe_ptr, size);",
            "\tif (unlikely(ret < 0))",
            "\t\tmemset(dst, 0, size);",
            "\treturn ret;",
            "}",
            "static void __set_printk_clr_event(struct work_struct *work)",
            "{",
            "\t/*",
            "\t * This program might be calling bpf_trace_printk,",
            "\t * so enable the associated bpf_trace/bpf_trace_printk event.",
            "\t * Repeat this each time as it is possible a user has",
            "\t * disabled bpf_trace_printk events.  By loading a program",
            "\t * calling bpf_trace_printk() however the user has expressed",
            "\t * the intent to see such events.",
            "\t */",
            "\tif (trace_set_clr_event(\"bpf_trace\", \"bpf_trace_printk\", 1))",
            "\t\tpr_warn_ratelimited(\"could not enable bpf_trace_printk events\");",
            "}"
          ],
          "function_name": "trace_call_bpf, bpf_probe_read_user_common, bpf_probe_read_user_str_common, bpf_probe_read_kernel_str_common, __set_printk_clr_event",
          "description": "实现了BPF程序调用入口trace_call_bpf，包含RCU保护下的程序数组执行逻辑，提供用户空间内存探测的通用辅助函数，并包含启用bpf_trace_printk事件的工作队列处理逻辑。",
          "similarity": 0.6645507216453552
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/trace/bpf_trace.c",
          "start_line": 2265,
          "end_line": 2409,
          "content": [
            "int perf_event_query_prog_array(struct perf_event *event, void __user *info)",
            "{",
            "\tstruct perf_event_query_bpf __user *uquery = info;",
            "\tstruct perf_event_query_bpf query = {};",
            "\tstruct bpf_prog_array *progs;",
            "\tu32 *ids, prog_cnt, ids_len;",
            "\tint ret;",
            "",
            "\tif (!perfmon_capable())",
            "\t\treturn -EPERM;",
            "\tif (event->attr.type != PERF_TYPE_TRACEPOINT)",
            "\t\treturn -EINVAL;",
            "\tif (copy_from_user(&query, uquery, sizeof(query)))",
            "\t\treturn -EFAULT;",
            "",
            "\tids_len = query.ids_len;",
            "\tif (ids_len > BPF_TRACE_MAX_PROGS)",
            "\t\treturn -E2BIG;",
            "\tids = kcalloc(ids_len, sizeof(u32), GFP_USER | __GFP_NOWARN);",
            "\tif (!ids)",
            "\t\treturn -ENOMEM;",
            "\t/*",
            "\t * The above kcalloc returns ZERO_SIZE_PTR when ids_len = 0, which",
            "\t * is required when user only wants to check for uquery->prog_cnt.",
            "\t * There is no need to check for it since the case is handled",
            "\t * gracefully in bpf_prog_array_copy_info.",
            "\t */",
            "",
            "\tmutex_lock(&bpf_event_mutex);",
            "\tprogs = bpf_event_rcu_dereference(event->tp_event->prog_array);",
            "\tret = bpf_prog_array_copy_info(progs, ids, ids_len, &prog_cnt);",
            "\tmutex_unlock(&bpf_event_mutex);",
            "",
            "\tif (copy_to_user(&uquery->prog_cnt, &prog_cnt, sizeof(prog_cnt)) ||",
            "\t    copy_to_user(uquery->ids, ids, ids_len * sizeof(u32)))",
            "\t\tret = -EFAULT;",
            "",
            "\tkfree(ids);",
            "\treturn ret;",
            "}",
            "void bpf_put_raw_tracepoint(struct bpf_raw_event_map *btp)",
            "{",
            "\tstruct module *mod;",
            "",
            "\tpreempt_disable();",
            "\tmod = __module_address((unsigned long)btp);",
            "\tmodule_put(mod);",
            "\tpreempt_enable();",
            "}",
            "static __always_inline",
            "void __bpf_trace_run(struct bpf_raw_tp_link *link, u64 *args)",
            "{",
            "\tstruct bpf_prog *prog = link->link.prog;",
            "\tstruct bpf_run_ctx *old_run_ctx;",
            "\tstruct bpf_trace_run_ctx run_ctx;",
            "",
            "\tcant_sleep();",
            "\tif (unlikely(this_cpu_inc_return(*(prog->active)) != 1)) {",
            "\t\tbpf_prog_inc_misses_counter(prog);",
            "\t\tgoto out;",
            "\t}",
            "",
            "\trun_ctx.bpf_cookie = link->cookie;",
            "\told_run_ctx = bpf_set_run_ctx(&run_ctx.run_ctx);",
            "",
            "\trcu_read_lock();",
            "\t(void) bpf_prog_run(prog, args);",
            "\trcu_read_unlock();",
            "",
            "\tbpf_reset_run_ctx(old_run_ctx);",
            "out:",
            "\tthis_cpu_dec(*(prog->active));",
            "}",
            "int bpf_probe_register(struct bpf_raw_event_map *btp, struct bpf_raw_tp_link *link)",
            "{",
            "\tstruct tracepoint *tp = btp->tp;",
            "\tstruct bpf_prog *prog = link->link.prog;",
            "",
            "\t/*",
            "\t * check that program doesn't access arguments beyond what's",
            "\t * available in this tracepoint",
            "\t */",
            "\tif (prog->aux->max_ctx_offset > btp->num_args * sizeof(u64))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (prog->aux->max_tp_access > btp->writable_size)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn tracepoint_probe_register_may_exist(tp, (void *)btp->bpf_func, link);",
            "}",
            "int bpf_probe_unregister(struct bpf_raw_event_map *btp, struct bpf_raw_tp_link *link)",
            "{",
            "\treturn tracepoint_probe_unregister(btp->tp, (void *)btp->bpf_func, link);",
            "}",
            "int bpf_get_perf_event_info(const struct perf_event *event, u32 *prog_id,",
            "\t\t\t    u32 *fd_type, const char **buf,",
            "\t\t\t    u64 *probe_offset, u64 *probe_addr,",
            "\t\t\t    unsigned long *missed)",
            "{",
            "\tbool is_tracepoint, is_syscall_tp;",
            "\tstruct bpf_prog *prog;",
            "\tint flags, err = 0;",
            "",
            "\tprog = event->prog;",
            "\tif (!prog)",
            "\t\treturn -ENOENT;",
            "",
            "\t/* not supporting BPF_PROG_TYPE_PERF_EVENT yet */",
            "\tif (prog->type == BPF_PROG_TYPE_PERF_EVENT)",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\t*prog_id = prog->aux->id;",
            "\tflags = event->tp_event->flags;",
            "\tis_tracepoint = flags & TRACE_EVENT_FL_TRACEPOINT;",
            "\tis_syscall_tp = is_syscall_trace_event(event->tp_event);",
            "",
            "\tif (is_tracepoint || is_syscall_tp) {",
            "\t\t*buf = is_tracepoint ? event->tp_event->tp->name",
            "\t\t\t\t     : event->tp_event->name;",
            "\t\t/* We allow NULL pointer for tracepoint */",
            "\t\tif (fd_type)",
            "\t\t\t*fd_type = BPF_FD_TYPE_TRACEPOINT;",
            "\t\tif (probe_offset)",
            "\t\t\t*probe_offset = 0x0;",
            "\t\tif (probe_addr)",
            "\t\t\t*probe_addr = 0x0;",
            "\t} else {",
            "\t\t/* kprobe/uprobe */",
            "\t\terr = -EOPNOTSUPP;",
            "#ifdef CONFIG_KPROBE_EVENTS",
            "\t\tif (flags & TRACE_EVENT_FL_KPROBE)",
            "\t\t\terr = bpf_get_kprobe_info(event, fd_type, buf,",
            "\t\t\t\t\t\t  probe_offset, probe_addr, missed,",
            "\t\t\t\t\t\t  event->attr.type == PERF_TYPE_TRACEPOINT);",
            "#endif",
            "#ifdef CONFIG_UPROBE_EVENTS",
            "\t\tif (flags & TRACE_EVENT_FL_UPROBE)",
            "\t\t\terr = bpf_get_uprobe_info(event, fd_type, buf,",
            "\t\t\t\t\t\t  probe_offset, probe_addr,",
            "\t\t\t\t\t\t  event->attr.type == PERF_TYPE_TRACEPOINT);",
            "#endif",
            "\t}",
            "",
            "\treturn err;",
            "}"
          ],
          "function_name": "perf_event_query_prog_array, bpf_put_raw_tracepoint, __bpf_trace_run, bpf_probe_register, bpf_probe_unregister, bpf_get_perf_event_info",
          "description": "实现perf事件程序数组查询接口，支持获取当前挂载的BPF程序ID列表；提供原始tracepoint释放函数；实现BPF跟踪执行核心函数__bpf_trace_run；包含BPF探测器注册/注销接口及获取性能事件元数据的辅助函数",
          "similarity": 0.6253498196601868
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/trace/bpf_trace.c",
          "start_line": 2136,
          "end_line": 2248,
          "content": [
            "static u32 pe_prog_convert_ctx_access(enum bpf_access_type type,",
            "\t\t\t\t      const struct bpf_insn *si,",
            "\t\t\t\t      struct bpf_insn *insn_buf,",
            "\t\t\t\t      struct bpf_prog *prog, u32 *target_size)",
            "{",
            "\tstruct bpf_insn *insn = insn_buf;",
            "",
            "\tswitch (si->off) {",
            "\tcase offsetof(struct bpf_perf_event_data, sample_period):",
            "\t\t*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct bpf_perf_event_data_kern,",
            "\t\t\t\t\t\t       data), si->dst_reg, si->src_reg,",
            "\t\t\t\t      offsetof(struct bpf_perf_event_data_kern, data));",
            "\t\t*insn++ = BPF_LDX_MEM(BPF_DW, si->dst_reg, si->dst_reg,",
            "\t\t\t\t      bpf_target_off(struct perf_sample_data, period, 8,",
            "\t\t\t\t\t\t     target_size));",
            "\t\tbreak;",
            "\tcase offsetof(struct bpf_perf_event_data, addr):",
            "\t\t*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct bpf_perf_event_data_kern,",
            "\t\t\t\t\t\t       data), si->dst_reg, si->src_reg,",
            "\t\t\t\t      offsetof(struct bpf_perf_event_data_kern, data));",
            "\t\t*insn++ = BPF_LDX_MEM(BPF_DW, si->dst_reg, si->dst_reg,",
            "\t\t\t\t      bpf_target_off(struct perf_sample_data, addr, 8,",
            "\t\t\t\t\t\t     target_size));",
            "\t\tbreak;",
            "\tdefault:",
            "\t\t*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct bpf_perf_event_data_kern,",
            "\t\t\t\t\t\t       regs), si->dst_reg, si->src_reg,",
            "\t\t\t\t      offsetof(struct bpf_perf_event_data_kern, regs));",
            "\t\t*insn++ = BPF_LDX_MEM(BPF_SIZEOF(long), si->dst_reg, si->dst_reg,",
            "\t\t\t\t      si->off);",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn insn - insn_buf;",
            "}",
            "int perf_event_attach_bpf_prog(struct perf_event *event,",
            "\t\t\t       struct bpf_prog *prog,",
            "\t\t\t       u64 bpf_cookie)",
            "{",
            "\tstruct bpf_prog_array *old_array;",
            "\tstruct bpf_prog_array *new_array;",
            "\tint ret = -EEXIST;",
            "",
            "\t/*",
            "\t * Kprobe override only works if they are on the function entry,",
            "\t * and only if they are on the opt-in list.",
            "\t */",
            "\tif (prog->kprobe_override &&",
            "\t    (!trace_kprobe_on_func_entry(event->tp_event) ||",
            "\t     !trace_kprobe_error_injectable(event->tp_event)))",
            "\t\treturn -EINVAL;",
            "",
            "\tmutex_lock(&bpf_event_mutex);",
            "",
            "\tif (event->prog)",
            "\t\tgoto unlock;",
            "",
            "\told_array = bpf_event_rcu_dereference(event->tp_event->prog_array);",
            "\tif (old_array &&",
            "\t    bpf_prog_array_length(old_array) >= BPF_TRACE_MAX_PROGS) {",
            "\t\tret = -E2BIG;",
            "\t\tgoto unlock;",
            "\t}",
            "",
            "\tret = bpf_prog_array_copy(old_array, NULL, prog, bpf_cookie, &new_array);",
            "\tif (ret < 0)",
            "\t\tgoto unlock;",
            "",
            "\t/* set the new array to event->tp_event and set event->prog */",
            "\tevent->prog = prog;",
            "\tevent->bpf_cookie = bpf_cookie;",
            "\trcu_assign_pointer(event->tp_event->prog_array, new_array);",
            "\tbpf_prog_array_free_sleepable(old_array);",
            "",
            "unlock:",
            "\tmutex_unlock(&bpf_event_mutex);",
            "\treturn ret;",
            "}",
            "void perf_event_detach_bpf_prog(struct perf_event *event)",
            "{",
            "\tstruct bpf_prog_array *old_array;",
            "\tstruct bpf_prog_array *new_array;",
            "\tint ret;",
            "",
            "\tmutex_lock(&bpf_event_mutex);",
            "",
            "\tif (!event->prog)",
            "\t\tgoto unlock;",
            "",
            "\told_array = bpf_event_rcu_dereference(event->tp_event->prog_array);",
            "\tif (!old_array)",
            "\t\tgoto put;",
            "",
            "\tret = bpf_prog_array_copy(old_array, event->prog, NULL, 0, &new_array);",
            "\tif (ret < 0) {",
            "\t\tbpf_prog_array_delete_safe(old_array, event->prog);",
            "\t} else {",
            "\t\trcu_assign_pointer(event->tp_event->prog_array, new_array);",
            "\t\tbpf_prog_array_free_sleepable(old_array);",
            "\t}",
            "put:",
            "    /*",
            "\t * It could be that the bpf_prog is not sleepable (and will be freed",
            "\t * via normal RCU), but is called from a point that supports sleepable",
            "\t * programs and uses tasks-trace-RCU.",
            "\t */",
            "\tsynchronize_rcu_tasks_trace();",
            "\tbpf_prog_put(event->prog);",
            "\tevent->prog = NULL;",
            "",
            "unlock:",
            "\tmutex_unlock(&bpf_event_mutex);",
            "}"
          ],
          "function_name": "pe_prog_convert_ctx_access, perf_event_attach_bpf_prog, perf_event_detach_bpf_prog",
          "description": "实现perf event数据结构中BPF上下文访问转换逻辑；提供perf事件与BPF程序的绑定接口，包含锁保护、数组复制、引用计数等管理；实现BPF程序从perf事件的解绑逻辑，包含旧数组回收、新数组创建及RCU安全赋值",
          "similarity": 0.6123881936073303
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/trace/bpf_trace.c",
          "start_line": 1572,
          "end_line": 1686,
          "content": [
            "static bool is_kprobe_multi(const struct bpf_prog *prog)",
            "{",
            "\treturn prog->expected_attach_type == BPF_TRACE_KPROBE_MULTI ||",
            "\t       prog->expected_attach_type == BPF_TRACE_KPROBE_SESSION;",
            "}",
            "static inline bool is_kprobe_session(const struct bpf_prog *prog)",
            "{",
            "\treturn prog->expected_attach_type == BPF_TRACE_KPROBE_SESSION;",
            "}",
            "static bool kprobe_prog_is_valid_access(int off, int size, enum bpf_access_type type,",
            "\t\t\t\t\tconst struct bpf_prog *prog,",
            "\t\t\t\t\tstruct bpf_insn_access_aux *info)",
            "{",
            "\tif (off < 0 || off >= sizeof(struct pt_regs))",
            "\t\treturn false;",
            "\tif (type != BPF_READ)",
            "\t\treturn false;",
            "\tif (off % size != 0)",
            "\t\treturn false;",
            "\t/*",
            "\t * Assertion for 32 bit to make sure last 8 byte access",
            "\t * (BPF_DW) to the last 4 byte member is disallowed.",
            "\t */",
            "\tif (off + size > sizeof(struct pt_regs))",
            "\t\treturn false;",
            "",
            "\treturn true;",
            "}",
            "static bool tp_prog_is_valid_access(int off, int size, enum bpf_access_type type,",
            "\t\t\t\t    const struct bpf_prog *prog,",
            "\t\t\t\t    struct bpf_insn_access_aux *info)",
            "{",
            "\tif (off < sizeof(void *) || off >= PERF_MAX_TRACE_SIZE)",
            "\t\treturn false;",
            "\tif (type != BPF_READ)",
            "\t\treturn false;",
            "\tif (off % size != 0)",
            "\t\treturn false;",
            "",
            "\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(__u64));",
            "\treturn true;",
            "}",
            "static void put_bpf_raw_tp_regs(void)",
            "{",
            "\tthis_cpu_dec(bpf_raw_tp_nest_level);",
            "}",
            "static bool raw_tp_prog_is_valid_access(int off, int size,",
            "\t\t\t\t\tenum bpf_access_type type,",
            "\t\t\t\t\tconst struct bpf_prog *prog,",
            "\t\t\t\t\tstruct bpf_insn_access_aux *info)",
            "{",
            "\treturn bpf_tracing_ctx_access(off, size, type);",
            "}",
            "static bool tracing_prog_is_valid_access(int off, int size,",
            "\t\t\t\t\t enum bpf_access_type type,",
            "\t\t\t\t\t const struct bpf_prog *prog,",
            "\t\t\t\t\t struct bpf_insn_access_aux *info)",
            "{",
            "\treturn bpf_tracing_btf_ctx_access(off, size, type, prog, info);",
            "}",
            "int __weak bpf_prog_test_run_tracing(struct bpf_prog *prog,",
            "\t\t\t\t     const union bpf_attr *kattr,",
            "\t\t\t\t     union bpf_attr __user *uattr)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "static bool raw_tp_writable_prog_is_valid_access(int off, int size,",
            "\t\t\t\t\t\t enum bpf_access_type type,",
            "\t\t\t\t\t\t const struct bpf_prog *prog,",
            "\t\t\t\t\t\t struct bpf_insn_access_aux *info)",
            "{",
            "\tif (off == 0) {",
            "\t\tif (size != sizeof(u64) || type != BPF_READ)",
            "\t\t\treturn false;",
            "\t\tinfo->reg_type = PTR_TO_TP_BUFFER;",
            "\t}",
            "\treturn raw_tp_prog_is_valid_access(off, size, type, prog, info);",
            "}",
            "static bool pe_prog_is_valid_access(int off, int size, enum bpf_access_type type,",
            "\t\t\t\t    const struct bpf_prog *prog,",
            "\t\t\t\t    struct bpf_insn_access_aux *info)",
            "{",
            "\tconst int size_u64 = sizeof(u64);",
            "",
            "\tif (off < 0 || off >= sizeof(struct bpf_perf_event_data))",
            "\t\treturn false;",
            "\tif (type != BPF_READ)",
            "\t\treturn false;",
            "\tif (off % size != 0) {",
            "\t\tif (sizeof(unsigned long) != 4)",
            "\t\t\treturn false;",
            "\t\tif (size != 8)",
            "\t\t\treturn false;",
            "\t\tif (off % size != 4)",
            "\t\t\treturn false;",
            "\t}",
            "",
            "\tswitch (off) {",
            "\tcase bpf_ctx_range(struct bpf_perf_event_data, sample_period):",
            "\t\tbpf_ctx_record_field_size(info, size_u64);",
            "\t\tif (!bpf_ctx_narrow_access_ok(off, size, size_u64))",
            "\t\t\treturn false;",
            "\t\tbreak;",
            "\tcase bpf_ctx_range(struct bpf_perf_event_data, addr):",
            "\t\tbpf_ctx_record_field_size(info, size_u64);",
            "\t\tif (!bpf_ctx_narrow_access_ok(off, size, size_u64))",
            "\t\t\treturn false;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tif (size != sizeof(long))",
            "\t\t\treturn false;",
            "\t}",
            "",
            "\treturn true;",
            "}"
          ],
          "function_name": "is_kprobe_multi, is_kprobe_session, kprobe_prog_is_valid_access, tp_prog_is_valid_access, put_bpf_raw_tp_regs, raw_tp_prog_is_valid_access, tracing_prog_is_valid_access, bpf_prog_test_run_tracing, raw_tp_writable_prog_is_valid_access, pe_prog_is_valid_access",
          "description": "定义用于检查BPF程序是否关联到多kprobe或会话kprobe的辅助函数；实现对kprobe、tracepoint等场景下BPF程序访问合法性校验的系列函数；包含针对raw TP、可写TP、perf event等不同上下文的访问验证逻辑；声明弱符号bpf_prog_test_run_tracing用于后续扩展",
          "similarity": 0.6061426401138306
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/trace/bpf_trace.c",
          "start_line": 1054,
          "end_line": 1254,
          "content": [
            "static unsigned long get_entry_ip(unsigned long fentry_ip)",
            "{",
            "\tu32 instr;",
            "",
            "\t/* Being extra safe in here in case entry ip is on the page-edge. */",
            "\tif (get_kernel_nofault(instr, (u32 *) fentry_ip - 1))",
            "\t\treturn fentry_ip;",
            "\tif (is_endbr(instr))",
            "\t\tfentry_ip -= ENDBR_INSN_SIZE;",
            "\treturn fentry_ip;",
            "}",
            "__bpf_kfunc void bpf_key_put(struct bpf_key *bkey)",
            "{",
            "\tif (bkey->has_ref)",
            "\t\tkey_put(bkey->key);",
            "",
            "\tkfree(bkey);",
            "}",
            "__bpf_kfunc int bpf_verify_pkcs7_signature(struct bpf_dynptr *data_p,",
            "\t\t\t       struct bpf_dynptr *sig_p,",
            "\t\t\t       struct bpf_key *trusted_keyring)",
            "{",
            "\tstruct bpf_dynptr_kern *data_ptr = (struct bpf_dynptr_kern *)data_p;",
            "\tstruct bpf_dynptr_kern *sig_ptr = (struct bpf_dynptr_kern *)sig_p;",
            "\tconst void *data, *sig;",
            "\tu32 data_len, sig_len;",
            "\tint ret;",
            "",
            "\tif (trusted_keyring->has_ref) {",
            "\t\t/*",
            "\t\t * Do the permission check deferred in bpf_lookup_user_key().",
            "\t\t * See bpf_lookup_user_key() for more details.",
            "\t\t *",
            "\t\t * A call to key_task_permission() here would be redundant, as",
            "\t\t * it is already done by keyring_search() called by",
            "\t\t * find_asymmetric_key().",
            "\t\t */",
            "\t\tret = key_validate(trusted_keyring->key);",
            "\t\tif (ret < 0)",
            "\t\t\treturn ret;",
            "\t}",
            "",
            "\tdata_len = __bpf_dynptr_size(data_ptr);",
            "\tdata = __bpf_dynptr_data(data_ptr, data_len);",
            "\tsig_len = __bpf_dynptr_size(sig_ptr);",
            "\tsig = __bpf_dynptr_data(sig_ptr, sig_len);",
            "",
            "\treturn verify_pkcs7_signature(data, data_len, sig, sig_len,",
            "\t\t\t\t      trusted_keyring->key,",
            "\t\t\t\t      VERIFYING_UNSPECIFIED_SIGNATURE, NULL,",
            "\t\t\t\t      NULL);",
            "}",
            "BTF_KFUNCS_START(key_sig_kfunc_set)",
            "BTF_ID_FLAGS(func, bpf_lookup_user_key, KF_ACQUIRE | KF_RET_NULL | KF_SLEEPABLE)",
            "BTF_ID_FLAGS(func, bpf_lookup_system_key, KF_ACQUIRE | KF_RET_NULL)",
            "BTF_ID_FLAGS(func, bpf_key_put, KF_RELEASE)",
            "#ifdef CONFIG_SYSTEM_DATA_VERIFICATION",
            "BTF_ID_FLAGS(func, bpf_verify_pkcs7_signature, KF_SLEEPABLE)",
            "#endif",
            "BTF_KFUNCS_END(key_sig_kfunc_set)",
            "",
            "static const struct btf_kfunc_id_set bpf_key_sig_kfunc_set = {",
            "\t.owner = THIS_MODULE,",
            "\t.set = &key_sig_kfunc_set,",
            "};",
            "",
            "static int __init bpf_key_sig_kfuncs_init(void)",
            "{",
            "\treturn register_btf_kfunc_id_set(BPF_PROG_TYPE_TRACING,",
            "\t\t\t\t\t &bpf_key_sig_kfunc_set);",
            "}",
            "",
            "late_initcall(bpf_key_sig_kfuncs_init);",
            "#endif /* CONFIG_KEYS */",
            "",
            "static const struct bpf_func_proto *",
            "bpf_tracing_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)",
            "{",
            "\tswitch (func_id) {",
            "\tcase BPF_FUNC_map_lookup_elem:",
            "\t\treturn &bpf_map_lookup_elem_proto;",
            "\tcase BPF_FUNC_map_update_elem:",
            "\t\treturn &bpf_map_update_elem_proto;",
            "\tcase BPF_FUNC_map_delete_elem:",
            "\t\treturn &bpf_map_delete_elem_proto;",
            "\tcase BPF_FUNC_map_push_elem:",
            "\t\treturn &bpf_map_push_elem_proto;",
            "\tcase BPF_FUNC_map_pop_elem:",
            "\t\treturn &bpf_map_pop_elem_proto;",
            "\tcase BPF_FUNC_map_peek_elem:",
            "\t\treturn &bpf_map_peek_elem_proto;",
            "\tcase BPF_FUNC_map_lookup_percpu_elem:",
            "\t\treturn &bpf_map_lookup_percpu_elem_proto;",
            "\tcase BPF_FUNC_ktime_get_ns:",
            "\t\treturn &bpf_ktime_get_ns_proto;",
            "\tcase BPF_FUNC_ktime_get_boot_ns:",
            "\t\treturn &bpf_ktime_get_boot_ns_proto;",
            "\tcase BPF_FUNC_tail_call:",
            "\t\treturn &bpf_tail_call_proto;",
            "\tcase BPF_FUNC_get_current_task:",
            "\t\treturn &bpf_get_current_task_proto;",
            "\tcase BPF_FUNC_get_current_task_btf:",
            "\t\treturn &bpf_get_current_task_btf_proto;",
            "\tcase BPF_FUNC_task_pt_regs:",
            "\t\treturn &bpf_task_pt_regs_proto;",
            "\tcase BPF_FUNC_get_current_uid_gid:",
            "\t\treturn &bpf_get_current_uid_gid_proto;",
            "\tcase BPF_FUNC_get_current_comm:",
            "\t\treturn &bpf_get_current_comm_proto;",
            "\tcase BPF_FUNC_trace_printk:",
            "\t\treturn bpf_get_trace_printk_proto();",
            "\tcase BPF_FUNC_get_smp_processor_id:",
            "\t\treturn &bpf_get_smp_processor_id_proto;",
            "\tcase BPF_FUNC_get_numa_node_id:",
            "\t\treturn &bpf_get_numa_node_id_proto;",
            "\tcase BPF_FUNC_perf_event_read:",
            "\t\treturn &bpf_perf_event_read_proto;",
            "\tcase BPF_FUNC_get_prandom_u32:",
            "\t\treturn &bpf_get_prandom_u32_proto;",
            "\tcase BPF_FUNC_probe_write_user:",
            "\t\treturn security_locked_down(LOCKDOWN_BPF_WRITE_USER) < 0 ?",
            "\t\t       NULL : bpf_get_probe_write_proto();",
            "\tcase BPF_FUNC_probe_read_user:",
            "\t\treturn &bpf_probe_read_user_proto;",
            "\tcase BPF_FUNC_probe_read_kernel:",
            "\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?",
            "\t\t       NULL : &bpf_probe_read_kernel_proto;",
            "\tcase BPF_FUNC_probe_read_user_str:",
            "\t\treturn &bpf_probe_read_user_str_proto;",
            "\tcase BPF_FUNC_probe_read_kernel_str:",
            "\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?",
            "\t\t       NULL : &bpf_probe_read_kernel_str_proto;",
            "#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE",
            "\tcase BPF_FUNC_probe_read:",
            "\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?",
            "\t\t       NULL : &bpf_probe_read_compat_proto;",
            "\tcase BPF_FUNC_probe_read_str:",
            "\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?",
            "\t\t       NULL : &bpf_probe_read_compat_str_proto;",
            "#endif",
            "#ifdef CONFIG_CGROUPS",
            "\tcase BPF_FUNC_cgrp_storage_get:",
            "\t\treturn &bpf_cgrp_storage_get_proto;",
            "\tcase BPF_FUNC_cgrp_storage_delete:",
            "\t\treturn &bpf_cgrp_storage_delete_proto;",
            "\tcase BPF_FUNC_current_task_under_cgroup:",
            "\t\treturn &bpf_current_task_under_cgroup_proto;",
            "#endif",
            "\tcase BPF_FUNC_send_signal:",
            "\t\treturn &bpf_send_signal_proto;",
            "\tcase BPF_FUNC_send_signal_thread:",
            "\t\treturn &bpf_send_signal_thread_proto;",
            "\tcase BPF_FUNC_perf_event_read_value:",
            "\t\treturn &bpf_perf_event_read_value_proto;",
            "\tcase BPF_FUNC_ringbuf_output:",
            "\t\treturn &bpf_ringbuf_output_proto;",
            "\tcase BPF_FUNC_ringbuf_reserve:",
            "\t\treturn &bpf_ringbuf_reserve_proto;",
            "\tcase BPF_FUNC_ringbuf_submit:",
            "\t\treturn &bpf_ringbuf_submit_proto;",
            "\tcase BPF_FUNC_ringbuf_discard:",
            "\t\treturn &bpf_ringbuf_discard_proto;",
            "\tcase BPF_FUNC_ringbuf_query:",
            "\t\treturn &bpf_ringbuf_query_proto;",
            "\tcase BPF_FUNC_jiffies64:",
            "\t\treturn &bpf_jiffies64_proto;",
            "\tcase BPF_FUNC_get_task_stack:",
            "\t\treturn &bpf_get_task_stack_proto;",
            "\tcase BPF_FUNC_copy_from_user:",
            "\t\treturn &bpf_copy_from_user_proto;",
            "\tcase BPF_FUNC_copy_from_user_task:",
            "\t\treturn &bpf_copy_from_user_task_proto;",
            "\tcase BPF_FUNC_snprintf_btf:",
            "\t\treturn &bpf_snprintf_btf_proto;",
            "\tcase BPF_FUNC_per_cpu_ptr:",
            "\t\treturn &bpf_per_cpu_ptr_proto;",
            "\tcase BPF_FUNC_this_cpu_ptr:",
            "\t\treturn &bpf_this_cpu_ptr_proto;",
            "\tcase BPF_FUNC_task_storage_get:",
            "\t\tif (bpf_prog_check_recur(prog))",
            "\t\t\treturn &bpf_task_storage_get_recur_proto;",
            "\t\treturn &bpf_task_storage_get_proto;",
            "\tcase BPF_FUNC_task_storage_delete:",
            "\t\tif (bpf_prog_check_recur(prog))",
            "\t\t\treturn &bpf_task_storage_delete_recur_proto;",
            "\t\treturn &bpf_task_storage_delete_proto;",
            "\tcase BPF_FUNC_for_each_map_elem:",
            "\t\treturn &bpf_for_each_map_elem_proto;",
            "\tcase BPF_FUNC_snprintf:",
            "\t\treturn &bpf_snprintf_proto;",
            "\tcase BPF_FUNC_get_func_ip:",
            "\t\treturn &bpf_get_func_ip_proto_tracing;",
            "\tcase BPF_FUNC_get_branch_snapshot:",
            "\t\treturn &bpf_get_branch_snapshot_proto;",
            "\tcase BPF_FUNC_find_vma:",
            "\t\treturn &bpf_find_vma_proto;",
            "\tcase BPF_FUNC_trace_vprintk:",
            "\t\treturn bpf_get_trace_vprintk_proto();",
            "\tdefault:",
            "\t\treturn bpf_base_func_proto(func_id, prog);",
            "\t}"
          ],
          "function_name": "get_entry_ip, bpf_key_put, bpf_verify_pkcs7_signature, BTF_ID_FLAGS",
          "description": "实现BPF函数集注册机制，包含入口IP获取、键值释放、PKCS7签名验证等功能，通过BTF_KFUNCS定义关键函数属性，并注册到BPF函数原型解析系统中，核心功能是BPF扩展功能的注册与调用规范定义。",
          "similarity": 0.5953769087791443
        }
      ]
    },
    {
      "source_file": "kernel/bpf/bpf_lsm.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:01:09\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bpf_lsm.c`\n\n---\n\n# `bpf/bpf_lsm.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/bpf_lsm.c` 是 Linux 内核中实现 **BPF LSM（Linux Security Module）** 支持的核心文件。该文件为 BPF 程序提供了一种机制，使其能够挂载（attach）到 LSM 安全钩子上，在系统关键安全决策点执行自定义策略。通过将 BPF 程序与 LSM 钩子集成，用户可以在不修改内核代码或加载传统 LSM 模块的情况下，动态实现细粒度的安全控制（如访问控制、审计、完整性度量等）。\n\n该文件主要完成以下任务：\n- 自动生成所有可被 BPF 附加的 LSM 钩子桩函数（stub functions）\n- 定义哪些 LSM 钩子被禁用（不可附加 BPF 程序）\n- 实现 BPF 程序在 LSM 钩子上的验证逻辑\n- 提供 LSM BPF 程序可调用的辅助函数（helpers）\n- 支持基于 cgroup 的 LSM BPF 程序上下文查找\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`bpf_lsm_hooks`**：BTF ID 集合，包含所有允许 BPF 程序附加的 LSM 钩子对应的桩函数。\n- **`bpf_lsm_disabled_hooks`**：BTF ID 集合，列出明确禁止 BPF 程序附加的 LSM 钩子（如涉及安全敏感或语义不兼容的钩子）。\n- **`bpf_lsm_current_hooks`**：BTF ID 集合，标识那些应始终在 `current` 进程的 cgroup 上下文中执行的 LSM 钩子（即使函数签名不包含 cgroup 参数）。\n- **`bpf_lsm_locked_sockopt_hooks` / `bpf_lsm_unlocked_sockopt_hooks`**：分别标识在 socket 已加锁或未加锁但处于初始化阶段时可安全调用 `bpf_{get,set}sockopt` 的网络 LSM 钩子。\n\n### 主要函数\n\n- **`bpf_lsm_verify_prog()`**：验证 BPF LSM 程序的合法性，包括许可证（必须为 GPL 兼容）、附加目标是否在允许列表中且不在禁用列表中。\n- **`bpf_lsm_func_proto()`**：为 BPF LSM 程序提供可用的辅助函数原型（`bpf_func_proto`），根据程序类型和附加钩子动态返回支持的 helpers。\n- **`bpf_lsm_find_cgroup_shim()`**（条件编译）：为 cgroup 类型的 LSM BPF 程序选择合适的运行时 shim 函数（`__cgroup_bpf_run_lsm_*`），依据附加钩子的第一个参数类型（如 socket、sock 或其他）决定执行上下文。\n- **辅助函数实现**：\n  - `bpf_bprm_opts_set()`：允许 LSM BPF 程序设置 `linux_binprm` 的 `secureexec` 标志。\n  - `bpf_ima_inode_hash()` / `bpf_ima_file_hash()`：封装 IMA（Integrity Measurement Architecture）接口，用于获取 inode 或文件的哈希值（可能睡眠）。\n  - `bpf_get_attach_cookie()`：获取附加到当前 LSM 钩子的 BPF 程序的 cookie 值。\n\n## 3. 关键实现\n\n### 自动生成 LSM 桩函数\n通过两次包含 `linux/lsm_hook_defs.h` 宏定义文件，结合 `LSM_HOOK` 宏：\n1. 第一次展开生成所有 `bpf_lsm_<hook_name>()` 桩函数，函数体仅返回默认值（如 0 或 -ENOSYS）。\n2. 第二次展开生成 `bpf_lsm_hooks` BTF ID 集合，收集所有桩函数的 BTF ID，用于后续验证和查找。\n\n### 钩子分类管理\n使用 BTF ID 集合对 LSM 钩子进行精细分类：\n- **禁用钩子**：如 `vm_enough_memory`、`inode_getsecurity` 等，因语义冲突、性能敏感或安全原因禁止 BPF 附加。\n- **cgroup 上下文钩子**：如 `sk_alloc_security`，虽无 cgroup 参数，但需在 `current` cgroup 中执行。\n- **socket 选项钩子**：区分 socket 是否已加锁，以决定是否允许调用 `bpf_{get,set}sockopt`。\n\n### BPF 辅助函数支持\n- **上下文感知**：`bpf_lsm_func_proto()` 根据 `prog->expected_attach_type`（如 `BPF_LSM_CGROUP`）和 `attach_btf_id` 动态启用特定 helpers。\n- **安全限制**：如 `bpf_ima_*_hash` 仅允许在可睡眠的 LSM 钩子中使用（通过 `bpf_lsm_is_sleepable_hook()` 判断）。\n- **网络支持**：条件编译下提供 socket 存储（`sk_storage`）和 socket 选项操作 helpers。\n\n### 验证机制\n`bpf_lsm_verify_prog()` 确保：\n- 程序许可证为 GPL 兼容（LSM BPF 要求开源）。\n- 附加目标 BTF ID 必须在 `bpf_lsm_hooks` 中且不在 `bpf_lsm_disabled_hooks` 中。\n\n## 4. 依赖关系\n\n- **LSM 框架**：依赖 `<linux/lsm_hooks.h>` 和 `lsm_hook_defs.h` 定义的 LSM 钩子接口。\n- **BPF 核心**：依赖 `<linux/bpf.h>`、`<linux/filter.h>` 提供 BPF 程序模型、验证器和辅助函数机制。\n- **BTF（BPF Type Format）**：使用 `<linux/btf.h>` 和 `BTF_ID` 宏进行类型安全的钩子标识和验证。\n- **cgroup BPF**：条件依赖 `CONFIG_CGROUP_BPF`，用于 cgroup 上下文的 LSM BPF 支持。\n- **网络子系统**：条件依赖 `CONFIG_SECURITY_NETWORK` 和 `CONFIG_NET`，提供 socket 相关的 LSM 钩子和 helpers。\n- **IMA（完整性度量架构）**：依赖 `<linux/ima.h>`，为 BPF 程序提供文件/ inode 哈希计算能力。\n- **BPF 存储**：依赖 `bpf_local_storage` 和 `bpf_sk_storage`，提供 inode 和 socket 的本地存储访问。\n\n## 5. 使用场景\n\n- **动态安全策略实施**：管理员或安全工具可加载 BPF LSM 程序，在文件访问、进程执行、网络连接等关键点实施自定义访问控制策略，无需重启或加载内核模块。\n- **系统审计与监控**：通过附加到 LSM 钩子（如 `file_open`、`task_alloc`），BPF 程序可收集安全相关事件并上报。\n- **容器安全隔离**：结合 cgroup BPF，可在容器边界（如 socket 创建、二进制执行）实施额外的安全检查。\n- **完整性度量集成**：利用 `bpf_ima_*_hash` helpers，在 LSM 钩子中触发 IMA 度量，实现基于 BPF 的完整性策略。\n- **安全研究与原型开发**：为安全研究人员提供灵活、安全的 LSM 扩展机制，快速验证新安全模型。",
      "similarity": 0.6062796115875244,
      "chunks": [
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/bpf_lsm.c",
          "start_line": 398,
          "end_line": 424,
          "content": [
            "bool bpf_lsm_is_trusted(const struct bpf_prog *prog)",
            "{",
            "\treturn !btf_id_set_contains(&untrusted_lsm_hooks, prog->aux->attach_btf_id);",
            "}",
            "BTF_SET_END(bool_lsm_hooks)",
            "",
            "int bpf_lsm_get_retval_range(const struct bpf_prog *prog,",
            "\t\t\t     struct bpf_retval_range *retval_range)",
            "{",
            "\t/* no return value range for void hooks */",
            "\tif (!prog->aux->attach_func_proto->type)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (btf_id_set_contains(&bool_lsm_hooks, prog->aux->attach_btf_id)) {",
            "\t\tretval_range->minval = 0;",
            "\t\tretval_range->maxval = 1;",
            "\t} else {",
            "\t\t/* All other available LSM hooks, except task_prctl, return 0",
            "\t\t * on success and negative error code on failure.",
            "\t\t * To keep things simple, we only allow bpf progs to return 0",
            "\t\t * or negative errno for task_prctl too.",
            "\t\t */",
            "\t\tretval_range->minval = -MAX_ERRNO;",
            "\t\tretval_range->maxval = 0;",
            "\t}",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_lsm_is_trusted, bpf_lsm_get_retval_range",
          "description": "实现钩子可信性检查及返回值范围解析，判断钩子是否属于不可信集合，并根据钩子类型设定BPF程序允许的返回值范围限制",
          "similarity": 0.6167788505554199
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/bpf_lsm.c",
          "start_line": 169,
          "end_line": 283,
          "content": [
            "static bool bpf_ima_inode_hash_allowed(const struct bpf_prog *prog)",
            "{",
            "\treturn bpf_lsm_is_sleepable_hook(prog->aux->attach_btf_id);",
            "}",
            "BTF_SET_START(sleepable_lsm_hooks)",
            "BTF_ID(func, bpf_lsm_bpf)",
            "BTF_ID(func, bpf_lsm_bpf_map)",
            "BTF_ID(func, bpf_lsm_bpf_map_create)",
            "BTF_ID(func, bpf_lsm_bpf_map_free)",
            "BTF_ID(func, bpf_lsm_bpf_prog)",
            "BTF_ID(func, bpf_lsm_bpf_prog_load)",
            "BTF_ID(func, bpf_lsm_bpf_prog_free)",
            "BTF_ID(func, bpf_lsm_bpf_token_create)",
            "BTF_ID(func, bpf_lsm_bpf_token_free)",
            "BTF_ID(func, bpf_lsm_bpf_token_cmd)",
            "BTF_ID(func, bpf_lsm_bpf_token_capable)",
            "BTF_ID(func, bpf_lsm_bprm_check_security)",
            "BTF_ID(func, bpf_lsm_bprm_committed_creds)",
            "BTF_ID(func, bpf_lsm_bprm_committing_creds)",
            "BTF_ID(func, bpf_lsm_bprm_creds_for_exec)",
            "BTF_ID(func, bpf_lsm_bprm_creds_from_file)",
            "BTF_ID(func, bpf_lsm_capget)",
            "BTF_ID(func, bpf_lsm_capset)",
            "BTF_ID(func, bpf_lsm_cred_prepare)",
            "BTF_ID(func, bpf_lsm_file_ioctl)",
            "BTF_ID(func, bpf_lsm_file_lock)",
            "BTF_ID(func, bpf_lsm_file_open)",
            "BTF_ID(func, bpf_lsm_file_receive)",
            "",
            "#ifdef CONFIG_SECURITY_NETWORK",
            "BTF_ID(func, bpf_lsm_inet_conn_established)",
            "#endif /* CONFIG_SECURITY_NETWORK */",
            "",
            "BTF_ID(func, bpf_lsm_inode_create)",
            "BTF_ID(func, bpf_lsm_inode_free_security)",
            "BTF_ID(func, bpf_lsm_inode_getattr)",
            "BTF_ID(func, bpf_lsm_inode_getxattr)",
            "BTF_ID(func, bpf_lsm_inode_mknod)",
            "BTF_ID(func, bpf_lsm_inode_need_killpriv)",
            "BTF_ID(func, bpf_lsm_inode_post_setxattr)",
            "BTF_ID(func, bpf_lsm_inode_post_removexattr)",
            "BTF_ID(func, bpf_lsm_inode_readlink)",
            "BTF_ID(func, bpf_lsm_inode_removexattr)",
            "BTF_ID(func, bpf_lsm_inode_rename)",
            "BTF_ID(func, bpf_lsm_inode_rmdir)",
            "BTF_ID(func, bpf_lsm_inode_setattr)",
            "BTF_ID(func, bpf_lsm_inode_setxattr)",
            "BTF_ID(func, bpf_lsm_inode_symlink)",
            "BTF_ID(func, bpf_lsm_inode_unlink)",
            "BTF_ID(func, bpf_lsm_kernel_module_request)",
            "BTF_ID(func, bpf_lsm_kernel_read_file)",
            "BTF_ID(func, bpf_lsm_kernfs_init_security)",
            "",
            "#ifdef CONFIG_KEYS",
            "BTF_ID(func, bpf_lsm_key_free)",
            "#endif /* CONFIG_KEYS */",
            "",
            "BTF_ID(func, bpf_lsm_mmap_file)",
            "BTF_ID(func, bpf_lsm_netlink_send)",
            "BTF_ID(func, bpf_lsm_path_notify)",
            "BTF_ID(func, bpf_lsm_release_secctx)",
            "BTF_ID(func, bpf_lsm_sb_alloc_security)",
            "BTF_ID(func, bpf_lsm_sb_eat_lsm_opts)",
            "BTF_ID(func, bpf_lsm_sb_kern_mount)",
            "BTF_ID(func, bpf_lsm_sb_mount)",
            "BTF_ID(func, bpf_lsm_sb_remount)",
            "BTF_ID(func, bpf_lsm_sb_set_mnt_opts)",
            "BTF_ID(func, bpf_lsm_sb_show_options)",
            "BTF_ID(func, bpf_lsm_sb_statfs)",
            "BTF_ID(func, bpf_lsm_sb_umount)",
            "BTF_ID(func, bpf_lsm_settime)",
            "",
            "#ifdef CONFIG_SECURITY_NETWORK",
            "BTF_ID(func, bpf_lsm_socket_accept)",
            "BTF_ID(func, bpf_lsm_socket_bind)",
            "BTF_ID(func, bpf_lsm_socket_connect)",
            "BTF_ID(func, bpf_lsm_socket_create)",
            "BTF_ID(func, bpf_lsm_socket_getpeername)",
            "BTF_ID(func, bpf_lsm_socket_getpeersec_dgram)",
            "BTF_ID(func, bpf_lsm_socket_getsockname)",
            "BTF_ID(func, bpf_lsm_socket_getsockopt)",
            "BTF_ID(func, bpf_lsm_socket_listen)",
            "BTF_ID(func, bpf_lsm_socket_post_create)",
            "BTF_ID(func, bpf_lsm_socket_recvmsg)",
            "BTF_ID(func, bpf_lsm_socket_sendmsg)",
            "BTF_ID(func, bpf_lsm_socket_shutdown)",
            "BTF_ID(func, bpf_lsm_socket_socketpair)",
            "#endif /* CONFIG_SECURITY_NETWORK */",
            "",
            "BTF_ID(func, bpf_lsm_syslog)",
            "BTF_ID(func, bpf_lsm_task_alloc)",
            "BTF_ID(func, bpf_lsm_current_getsecid_subj)",
            "BTF_ID(func, bpf_lsm_task_getsecid_obj)",
            "BTF_ID(func, bpf_lsm_task_prctl)",
            "BTF_ID(func, bpf_lsm_task_setscheduler)",
            "BTF_ID(func, bpf_lsm_task_to_inode)",
            "BTF_ID(func, bpf_lsm_userns_create)",
            "BTF_SET_END(sleepable_lsm_hooks)",
            "",
            "BTF_SET_START(untrusted_lsm_hooks)",
            "BTF_ID(func, bpf_lsm_bpf_map_free)",
            "BTF_ID(func, bpf_lsm_bpf_prog_free)",
            "BTF_ID(func, bpf_lsm_file_alloc_security)",
            "BTF_ID(func, bpf_lsm_file_free_security)",
            "#ifdef CONFIG_SECURITY_NETWORK",
            "BTF_ID(func, bpf_lsm_sk_alloc_security)",
            "BTF_ID(func, bpf_lsm_sk_free_security)",
            "#endif /* CONFIG_SECURITY_NETWORK */",
            "BTF_ID(func, bpf_lsm_task_free)",
            "BTF_SET_END(untrusted_lsm_hooks)",
            "",
            "bool bpf_lsm_is_sleepable_hook(u32 btf_id)",
            "{",
            "\treturn btf_id_set_contains(&sleepable_lsm_hooks, btf_id);",
            "}"
          ],
          "function_name": "bpf_ima_inode_hash_allowed, BTF_ID",
          "description": "定义sleepable和untrusted LSM钩子集合，通过BTF_ID收集支持睡眠操作及不可信的钩子函数，辅助判断BPF程序是否可睡眠及是否受信任",
          "similarity": 0.6043154001235962
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bpf_lsm.c",
          "start_line": 36,
          "end_line": 137,
          "content": [
            "BTF_SET_END(bpf_lsm_hooks)",
            "",
            "BTF_SET_START(bpf_lsm_disabled_hooks)",
            "BTF_ID(func, bpf_lsm_vm_enough_memory)",
            "BTF_ID(func, bpf_lsm_inode_need_killpriv)",
            "BTF_ID(func, bpf_lsm_inode_getsecurity)",
            "BTF_ID(func, bpf_lsm_inode_listsecurity)",
            "BTF_ID(func, bpf_lsm_inode_copy_up_xattr)",
            "BTF_ID(func, bpf_lsm_getselfattr)",
            "BTF_ID(func, bpf_lsm_getprocattr)",
            "BTF_ID(func, bpf_lsm_setprocattr)",
            "#ifdef CONFIG_KEYS",
            "BTF_ID(func, bpf_lsm_key_getsecurity)",
            "#endif",
            "#ifdef CONFIG_AUDIT",
            "BTF_ID(func, bpf_lsm_audit_rule_match)",
            "#endif",
            "BTF_ID(func, bpf_lsm_ismaclabel)",
            "BTF_SET_END(bpf_lsm_disabled_hooks)",
            "",
            "/* List of LSM hooks that should operate on 'current' cgroup regardless",
            " * of function signature.",
            " */",
            "BTF_SET_START(bpf_lsm_current_hooks)",
            "/* operate on freshly allocated sk without any cgroup association */",
            "#ifdef CONFIG_SECURITY_NETWORK",
            "BTF_ID(func, bpf_lsm_sk_alloc_security)",
            "BTF_ID(func, bpf_lsm_sk_free_security)",
            "#endif",
            "BTF_SET_END(bpf_lsm_current_hooks)",
            "",
            "/* List of LSM hooks that trigger while the socket is properly locked.",
            " */",
            "BTF_SET_START(bpf_lsm_locked_sockopt_hooks)",
            "#ifdef CONFIG_SECURITY_NETWORK",
            "BTF_ID(func, bpf_lsm_sock_graft)",
            "BTF_ID(func, bpf_lsm_inet_csk_clone)",
            "BTF_ID(func, bpf_lsm_inet_conn_established)",
            "#endif",
            "BTF_SET_END(bpf_lsm_locked_sockopt_hooks)",
            "",
            "/* List of LSM hooks that trigger while the socket is _not_ locked,",
            " * but it's ok to call bpf_{g,s}etsockopt because the socket is still",
            " * in the early init phase.",
            " */",
            "BTF_SET_START(bpf_lsm_unlocked_sockopt_hooks)",
            "#ifdef CONFIG_SECURITY_NETWORK",
            "BTF_ID(func, bpf_lsm_socket_post_create)",
            "BTF_ID(func, bpf_lsm_socket_socketpair)",
            "#endif",
            "BTF_SET_END(bpf_lsm_unlocked_sockopt_hooks)",
            "",
            "#ifdef CONFIG_CGROUP_BPF",
            "void bpf_lsm_find_cgroup_shim(const struct bpf_prog *prog,",
            "\t\t\t     bpf_func_t *bpf_func)",
            "{",
            "\tconst struct btf_param *args __maybe_unused;",
            "",
            "\tif (btf_type_vlen(prog->aux->attach_func_proto) < 1 ||",
            "\t    btf_id_set_contains(&bpf_lsm_current_hooks,",
            "\t\t\t\tprog->aux->attach_btf_id)) {",
            "\t\t*bpf_func = __cgroup_bpf_run_lsm_current;",
            "\t\treturn;",
            "\t}",
            "",
            "#ifdef CONFIG_NET",
            "\targs = btf_params(prog->aux->attach_func_proto);",
            "",
            "\tif (args[0].type == btf_sock_ids[BTF_SOCK_TYPE_SOCKET])",
            "\t\t*bpf_func = __cgroup_bpf_run_lsm_socket;",
            "\telse if (args[0].type == btf_sock_ids[BTF_SOCK_TYPE_SOCK])",
            "\t\t*bpf_func = __cgroup_bpf_run_lsm_sock;",
            "\telse",
            "#endif",
            "\t\t*bpf_func = __cgroup_bpf_run_lsm_current;",
            "}",
            "int bpf_lsm_verify_prog(struct bpf_verifier_log *vlog,",
            "\t\t\tconst struct bpf_prog *prog)",
            "{",
            "\tu32 btf_id = prog->aux->attach_btf_id;",
            "\tconst char *func_name = prog->aux->attach_func_name;",
            "",
            "\tif (!prog->gpl_compatible) {",
            "\t\tbpf_log(vlog,",
            "\t\t\t\"LSM programs must have a GPL compatible license\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (btf_id_set_contains(&bpf_lsm_disabled_hooks, btf_id)) {",
            "\t\tbpf_log(vlog, \"attach_btf_id %u points to disabled hook %s\\n\",",
            "\t\t\tbtf_id, func_name);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\tif (!btf_id_set_contains(&bpf_lsm_hooks, btf_id)) {",
            "\t\tbpf_log(vlog, \"attach_btf_id %u points to wrong type name %s\\n\",",
            "\t\t\tbtf_id, func_name);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "BTF_SET_START, bpf_lsm_verify_prog",
          "description": "实现BPF LSM程序验证逻辑，检查钩子ID是否在禁用列表或无效类型列表中，并定位cgroup shim函数以匹配不同socket状态下的钩子调用",
          "similarity": 0.6011447310447693
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bpf_lsm.c",
          "start_line": 1,
          "end_line": 35,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "",
            "/*",
            " * Copyright (C) 2020 Google LLC.",
            " */",
            "",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/btf.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/kallsyms.h>",
            "#include <net/bpf_sk_storage.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/ima.h>",
            "#include <linux/bpf-cgroup.h>",
            "",
            "/* For every LSM hook that allows attachment of BPF programs, declare a nop",
            " * function where a BPF program can be attached.",
            " */",
            "#define LSM_HOOK(RET, DEFAULT, NAME, ...)\t\\",
            "noinline RET bpf_lsm_##NAME(__VA_ARGS__)\t\\",
            "{\t\t\t\t\t\t\\",
            "\treturn DEFAULT;\t\t\t\t\\",
            "}",
            "",
            "#include <linux/lsm_hook_defs.h>",
            "#undef LSM_HOOK",
            "",
            "#define LSM_HOOK(RET, DEFAULT, NAME, ...) BTF_ID(func, bpf_lsm_##NAME)",
            "BTF_SET_START(bpf_lsm_hooks)",
            "#include <linux/lsm_hook_defs.h>",
            "#undef LSM_HOOK"
          ],
          "function_name": null,
          "description": "定义LSM钩子的BTF标识符集合，通过宏展开生成各个LSM钩子的BTF_ID并组织到bpf_lsm_hooks集合中，为BPF程序附加提供类型信息",
          "similarity": 0.5102259516716003
        }
      ]
    }
  ]
}