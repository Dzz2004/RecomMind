{
  "query": "BIOS和UEFI引导程序的区别",
  "timestamp": "2025-12-26 00:36:01",
  "retrieved_files": [
    {
      "source_file": "kernel/usermode_driver.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:47:16\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `usermode_driver.c`\n\n---\n\n# usermode_driver.c 技术文档\n\n## 文件概述\n\n`usermode_driver.c` 实现了 Linux 内核中用户态驱动（User Mode Driver, UMD）的支持机制。该文件提供了一套 API，允许内核模块将一段可执行的二进制数据（blob）加载为临时文件系统中的可执行文件，并以此为基础 fork 出一个用户态进程作为驱动程序运行。该机制常用于需要在用户空间执行复杂逻辑但又需与内核紧密协作的驱动场景（如某些固件加载器、安全模块或虚拟设备驱动）。\n\n## 核心功能\n\n### 主要函数\n\n- `blob_to_mnt(const void *data, size_t len, const char *name)`  \n  将二进制数据写入 tmpfs 文件系统中，返回挂载点（vfsmount）。\n\n- `umd_load_blob(struct umd_info *info, const void *data, size_t len)`  \n  将给定的二进制 blob 加载为可执行文件，并关联到 `umd_info` 结构中。\n\n- `umd_unload_blob(struct umd_info *info)`  \n  卸载之前加载的 blob，释放相关文件系统资源。\n\n- `fork_usermode_driver(struct umd_info *info)`  \n  基于已加载的 blob fork 并执行一个用户态驱动进程。\n\n- `umd_setup(struct subprocess_info *info, struct cred *new)`  \n  在子进程中设置执行环境，包括创建通信管道、设置工作目录等。\n\n- `umd_cleanup(struct subprocess_info *info)`  \n  子进程执行失败时的清理回调。\n\n- `umd_cleanup_helper(struct umd_info *info)`  \n  释放 `umd_setup` 中分配的资源（管道、PID 等）。\n\n### 关键数据结构\n\n- `struct umd_info`  \n  描述用户态驱动的上下文信息，包含：\n  - `wd`：工作目录（`struct path`），指向 tmpfs 中的可执行文件所在目录\n  - `driver_name`：驱动程序在 tmpfs 中的文件名\n  - `pipe_to_umh` / `pipe_from_umh`：与用户态进程通信的双向管道\n  - `tgid`：用户态驱动进程的线程组 ID（用于后续管理）\n\n## 关键实现\n\n### Blob 到可执行文件的转换\n\n`blob_to_mnt()` 函数通过以下步骤将内存中的二进制数据转换为可执行文件：\n\n1. 挂载 `tmpfs` 文件系统（使用 `kern_mount()`）\n2. 在挂载点根目录下以指定名称创建文件（权限 `0700`）\n3. 使用 `kernel_write()` 将数据写入文件\n4. 调用 `flush_delayed_fput()` 和 `task_work_run()` 确保文件描述符延迟释放完成，以便后续 `exec` 能以只读方式打开该文件\n\n此机制避免了将驱动二进制写入磁盘，提高了安全性和灵活性。\n\n### 用户态驱动进程的启动\n\n`fork_usermode_driver()` 利用内核的 `call_usermodehelper` 机制：\n\n- 使用 `call_usermodehelper_setup()` 注册 `umd_setup` 作为子进程初始化回调\n- 在 `umd_setup` 中：\n  - 创建两个匿名管道：一个用于内核向用户态发送数据（stdin 重定向），一个用于用户态向内核返回数据（stdout 重定向）\n  - 使用 `replace_fd()` 将标准输入/输出重定向到管道端点\n  - 设置当前进程的 pwd（工作目录）为 tmpfs 挂载点，使 `exec` 能直接以相对路径执行驱动文件\n  - 保存管道文件指针和子进程 TGID 到 `umd_info`\n- 执行 `call_usermodehelper_exec()` 启动进程\n\n### 资源管理与错误处理\n\n- `umd_load_blob()` 和 `umd_unload_blob()` 通过 `WARN_ON_ONCE` 确保状态一致性（避免重复加载/卸载）\n- 若 `exec` 失败，`umd_cleanup` 回调会调用 `umd_cleanup_helper` 释放管道和 PID\n- 所有资源（vfsmount、file、pipe、pid）均通过内核标准接口分配和释放，确保无泄漏\n\n## 依赖关系\n\n- **文件系统**：依赖 `tmpfs`（通过 `get_fs_type(\"tmpfs\")`），用于临时存储可执行 blob\n- **进程管理**：依赖 `call_usermodehelper` 子系统（`linux/kmod.h` 隐式包含），用于 fork/exec 用户态进程\n- **VFS 层**：使用 `kern_mount`/`kern_unmount`、`file_open_root_mnt`、`kernel_write` 等 VFS 接口\n- **IPC 机制**：依赖管道（`create_pipe_files`）实现内核与用户态驱动的双向通信\n- **内存管理**：依赖 `shmem_fs.h`（tmpfs 底层基于共享内存）\n- **任务工作队列**：调用 `task_work_run()` 确保文件描述符及时释放\n\n## 使用场景\n\n1. **动态用户态驱动加载**  \n   内核模块可将嵌入的 ELF 二进制或脚本作为 blob 加载，无需预先安装到文件系统。\n\n2. **安全隔离驱动**  \n   将可能含漏洞的驱动逻辑移至用户空间运行，通过管道与内核通信，降低内核攻击面。\n\n3. **固件或微码加载器**  \n   某些设备需要复杂的固件初始化逻辑，可通过 UMD 在用户态执行，避免内核复杂性。\n\n4. **虚拟设备后端**  \n   如 virtio-user、vhost-user 等场景，内核前端通过 UMD 与用户态后端进程协作。\n\n5. **测试与原型开发**  \n   快速验证驱动逻辑，无需频繁编译内核模块，提高开发效率。\n\n> **注意**：调用者需负责用户态进程的生命周期管理（健康检查、信号终止、管道关闭等）。",
      "similarity": 0.560783326625824,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 60,
          "end_line": 161,
          "content": [
            "int umd_load_blob(struct umd_info *info, const void *data, size_t len)",
            "{",
            "\tstruct vfsmount *mnt;",
            "",
            "\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))",
            "\t\treturn -EBUSY;",
            "",
            "\tmnt = blob_to_mnt(data, len, info->driver_name);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn PTR_ERR(mnt);",
            "",
            "\tinfo->wd.mnt = mnt;",
            "\tinfo->wd.dentry = mnt->mnt_root;",
            "\treturn 0;",
            "}",
            "int umd_unload_blob(struct umd_info *info)",
            "{",
            "\tif (WARN_ON_ONCE(!info->wd.mnt ||",
            "\t\t\t !info->wd.dentry ||",
            "\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))",
            "\t\treturn -EINVAL;",
            "",
            "\tkern_unmount(info->wd.mnt);",
            "\tinfo->wd.mnt = NULL;",
            "\tinfo->wd.dentry = NULL;",
            "\treturn 0;",
            "}",
            "static int umd_setup(struct subprocess_info *info, struct cred *new)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "\tstruct file *from_umh[2];",
            "\tstruct file *to_umh[2];",
            "\tint err;",
            "",
            "\t/* create pipe to send data to umh */",
            "\terr = create_pipe_files(to_umh, 0);",
            "\tif (err)",
            "\t\treturn err;",
            "\terr = replace_fd(0, to_umh[0], 0);",
            "\tfput(to_umh[0]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\t/* create pipe to receive data from umh */",
            "\terr = create_pipe_files(from_umh, 0);",
            "\tif (err) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\treturn err;",
            "\t}",
            "\terr = replace_fd(1, from_umh[1], 0);",
            "\tfput(from_umh[1]);",
            "\tif (err < 0) {",
            "\t\tfput(to_umh[1]);",
            "\t\treplace_fd(0, NULL, 0);",
            "\t\tfput(from_umh[0]);",
            "\t\treturn err;",
            "\t}",
            "",
            "\tset_fs_pwd(current->fs, &umd_info->wd);",
            "\tumd_info->pipe_to_umh = to_umh[1];",
            "\tumd_info->pipe_from_umh = from_umh[0];",
            "\tumd_info->tgid = get_pid(task_tgid(current));",
            "\treturn 0;",
            "}",
            "static void umd_cleanup(struct subprocess_info *info)",
            "{",
            "\tstruct umd_info *umd_info = info->data;",
            "",
            "\t/* cleanup if umh_setup() was successful but exec failed */",
            "\tif (info->retval)",
            "\t\tumd_cleanup_helper(umd_info);",
            "}",
            "void umd_cleanup_helper(struct umd_info *info)",
            "{",
            "\tfput(info->pipe_to_umh);",
            "\tfput(info->pipe_from_umh);",
            "\tput_pid(info->tgid);",
            "\tinfo->tgid = NULL;",
            "}",
            "int fork_usermode_driver(struct umd_info *info)",
            "{",
            "\tstruct subprocess_info *sub_info;",
            "\tconst char *argv[] = { info->driver_name, NULL };",
            "\tint err;",
            "",
            "\tif (WARN_ON_ONCE(info->tgid))",
            "\t\treturn -EBUSY;",
            "",
            "\terr = -ENOMEM;",
            "\tsub_info = call_usermodehelper_setup(info->driver_name,",
            "\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,",
            "\t\t\t\t\t     umd_setup, umd_cleanup, info);",
            "\tif (!sub_info)",
            "\t\tgoto out;",
            "",
            "\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);",
            "out:",
            "\treturn err;",
            "}"
          ],
          "function_name": "umd_load_blob, umd_unload_blob, umd_setup, umd_cleanup, umd_cleanup_helper, fork_usermode_driver",
          "description": "提供用户模式驱动程序的数据加载/卸载及子进程管理功能，包括挂载tmpfs、建立进程间管道通信、设置工作目录及清理资源，最终通过call_usermodehelper启动用户态驱动程序",
          "similarity": 0.5116069912910461
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/usermode_driver.c",
          "start_line": 1,
          "end_line": 59,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * umd - User mode driver support",
            " */",
            "#include <linux/shmem_fs.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/usermode_driver.h>",
            "",
            "static struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)",
            "{",
            "\tstruct file_system_type *type;",
            "\tstruct vfsmount *mnt;",
            "\tstruct file *file;",
            "\tssize_t written;",
            "\tloff_t pos = 0;",
            "",
            "\ttype = get_fs_type(\"tmpfs\");",
            "\tif (!type)",
            "\t\treturn ERR_PTR(-ENODEV);",
            "",
            "\tmnt = kern_mount(type);",
            "\tput_filesystem(type);",
            "\tif (IS_ERR(mnt))",
            "\t\treturn mnt;",
            "",
            "\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);",
            "\tif (IS_ERR(file)) {",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_CAST(file);",
            "\t}",
            "",
            "\twritten = kernel_write(file, data, len, &pos);",
            "\tif (written != len) {",
            "\t\tint err = written;",
            "\t\tif (err >= 0)",
            "\t\t\terr = -ENOMEM;",
            "\t\tfilp_close(file, NULL);",
            "\t\tkern_unmount(mnt);",
            "\t\treturn ERR_PTR(err);",
            "\t}",
            "",
            "\tfput(file);",
            "",
            "\t/* Flush delayed fput so exec can open the file read-only */",
            "\tflush_delayed_fput();",
            "\ttask_work_run();",
            "\treturn mnt;",
            "}",
            "",
            "/**",
            " * umd_load_blob - Remember a blob of bytes for fork_usermode_driver",
            " * @info: information about usermode driver",
            " * @data: a blob of bytes that can be executed as a file",
            " * @len:  The lentgh of the blob",
            " *",
            " */"
          ],
          "function_name": null,
          "description": "创建并挂载tmpfs文件系统以存储二进制数据，通过文件操作将输入数据写入新挂载点的指定名称文件，返回对应的vfsmount结构指针",
          "similarity": 0.39516282081604004
        }
      ]
    },
    {
      "source_file": "kernel/umh.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:44:17\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `umh.c`\n\n---\n\n# umh.c 技术文档\n\n## 文件概述\n\n`umh.c` 实现了 Linux 内核的 **用户模式辅助程序（Usermode Helper, UMH）** 机制，允许内核在需要时安全地启动用户空间进程。该机制广泛用于模块自动加载、热插拔事件处理、固件加载等场景。文件提供了同步与异步执行用户空间程序的能力，并支持在系统挂起/休眠期间禁用该功能以确保系统状态一致性。\n\n## 核心功能\n\n### 主要数据结构\n\n- `struct subprocess_info`：封装用户模式辅助程序执行所需的所有信息，包括路径、参数、环境变量、初始化/清理回调、等待模式等。\n- `enum umh_disable_depth`：控制 UMH 功能的启用/禁用状态，用于系统挂起等场景。\n\n### 关键全局变量\n\n- `usermodehelper_bset` / `usermodehelper_inheritable`：控制 UMH 进程的初始能力集（capabilities）。\n- `umhelper_sem`（读写信号量）：保护 UMH 全局状态，协调禁用/启用操作。\n- `usermodehelper_disabled`：标识 UMH 是否被禁用。\n- `running_helpers`：原子计数器，跟踪当前正在运行的 UMH 实例数量。\n\n### 核心函数\n\n- `call_usermodehelper_exec_async()`：UMH 工作线程的主函数，负责设置执行环境并调用 `kernel_execve()`。\n- `call_usermodehelper_exec_sync()`：同步执行 UMH，等待子进程结束。\n- `call_usermodehelper_exec_work()`：工作队列回调函数，根据等待模式选择同步或异步执行。\n- `usermodehelper_read_trylock()` / `usermodehelper_read_lock_wait()` / `usermodehelper_read_unlock()`：提供对 UMH 状态的读锁机制，用于检查是否可安全启动 UMH。\n- `__usermodehelper_set_disable_depth()` / `__usermodehelper_disable()`：控制 UMH 的禁用状态，并等待现有实例完成。\n\n## 关键实现\n\n### 执行环境隔离与安全\n\n- **能力集限制**：通过 `usermodehelper_bset` 和 `usermodehelper_inheritable` 限制 UMH 进程的初始能力，防止权限过度提升。\n- **凭证设置**：使用 `prepare_kernel_cred()` 创建新凭证，并通过 `commit_creds()` 应用，确保与调用者隔离。\n- **信号处理**：重置信号处理程序（`flush_signal_handlers`），避免继承内核线程的信号配置。\n- **调度优先级**：显式将 nice 值设为 0，避免继承高优先级工作队列的调度属性。\n- **umask 重置**：将文件创建掩码设为默认值 `0022`。\n\n### 执行模式\n\n- **异步模式（UMH_NO_WAIT）**：通过 `user_mode_thread()` 创建子进程后立即返回，子进程结束后自动清理资源。\n- **同步模式（UMH_WAIT_PROC）**：使用 `kernel_wait()` 阻塞等待子进程结束，适用于需要获取执行结果的场景。\n\n### 资源管理与生命周期\n\n- **自动清理**：通过 `umh_complete()` 统一处理子进程结束后的资源释放，支持同步/异步两种路径。\n- **工作队列执行**：所有 UMH 请求均通过 **无边界工作队列（unbound workqueue）** 执行，确保 CPU 亲和性宽泛，避免在繁忙 CPU 上竞争。\n\n### 系统挂起支持\n\n- **禁用机制**：通过 `usermodehelper_disabled` 标志和读写信号量 `umhelper_sem`，在系统挂起/休眠期间阻止新 UMH 启动。\n- **等待完成**：`__usermodehelper_disable()` 会等待所有正在运行的 UMH 实例结束（超时 5 秒），确保系统状态干净。\n\n## 依赖关系\n\n- **核心调度子系统**：依赖 `user_mode_thread()`、`kernel_execve()`、`kernel_wait()` 等接口。\n- **凭证与安全子系统**：使用 `cred` 结构、`security` LSM 接口、`capabilities` 管理。\n- **工作队列子系统**：通过 `work_struct` 和无边界工作队列执行 UMH 任务。\n- **内存管理**：使用 `kmalloc`/`kfree` 管理 `subprocess_info` 结构。\n- **信号与进程管理**：操作信号处理、进程创建与等待。\n- **电源管理**：与系统挂起/休眠框架集成，通过 `freezer.h` 支持冻结用户空间进程。\n\n## 使用场景\n\n1. **内核模块自动加载**：当内核需要某个未加载的模块时，通过 UMH 调用 `modprobe`。\n2. **热插拔事件处理**：设备插入/移除时，内核通过 UMH 通知用户空间（如 `udev`）。\n3. **固件加载**：设备驱动请求固件时，内核调用用户空间工具（如 `firmware_class`）。\n4. **网络子系统**：如 `netfilter` 的 `nfnetlink_queue` 使用 UMH 启动用户空间处理程序。\n5. **系统挂起/恢复**：在挂起前禁用 UMH，防止用户空间进程干扰系统状态；恢复后重新启用。",
      "similarity": 0.5299698114395142,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/umh.c",
          "start_line": 168,
          "end_line": 279,
          "content": [
            "static void call_usermodehelper_exec_work(struct work_struct *work)",
            "{",
            "\tstruct subprocess_info *sub_info =",
            "\t\tcontainer_of(work, struct subprocess_info, work);",
            "",
            "\tif (sub_info->wait & UMH_WAIT_PROC) {",
            "\t\tcall_usermodehelper_exec_sync(sub_info);",
            "\t} else {",
            "\t\tpid_t pid;",
            "\t\t/*",
            "\t\t * Use CLONE_PARENT to reparent it to kthreadd; we do not",
            "\t\t * want to pollute current->children, and we need a parent",
            "\t\t * that always ignores SIGCHLD to ensure auto-reaping.",
            "\t\t */",
            "\t\tpid = user_mode_thread(call_usermodehelper_exec_async, sub_info,",
            "\t\t\t\t       CLONE_PARENT | SIGCHLD);",
            "\t\tif (pid < 0) {",
            "\t\t\tsub_info->retval = pid;",
            "\t\t\tumh_complete(sub_info);",
            "\t\t}",
            "\t}",
            "}",
            "int usermodehelper_read_trylock(void)",
            "{",
            "\tDEFINE_WAIT(wait);",
            "\tint ret = 0;",
            "",
            "\tdown_read(&umhelper_sem);",
            "\tfor (;;) {",
            "\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,",
            "\t\t\t\tTASK_INTERRUPTIBLE);",
            "\t\tif (!usermodehelper_disabled)",
            "\t\t\tbreak;",
            "",
            "\t\tif (usermodehelper_disabled == UMH_DISABLED)",
            "\t\t\tret = -EAGAIN;",
            "",
            "\t\tup_read(&umhelper_sem);",
            "",
            "\t\tif (ret)",
            "\t\t\tbreak;",
            "",
            "\t\tschedule();",
            "\t\ttry_to_freeze();",
            "",
            "\t\tdown_read(&umhelper_sem);",
            "\t}",
            "\tfinish_wait(&usermodehelper_disabled_waitq, &wait);",
            "\treturn ret;",
            "}",
            "long usermodehelper_read_lock_wait(long timeout)",
            "{",
            "\tDEFINE_WAIT(wait);",
            "",
            "\tif (timeout < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\tdown_read(&umhelper_sem);",
            "\tfor (;;) {",
            "\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,",
            "\t\t\t\tTASK_UNINTERRUPTIBLE);",
            "\t\tif (!usermodehelper_disabled)",
            "\t\t\tbreak;",
            "",
            "\t\tup_read(&umhelper_sem);",
            "",
            "\t\ttimeout = schedule_timeout(timeout);",
            "\t\tif (!timeout)",
            "\t\t\tbreak;",
            "",
            "\t\tdown_read(&umhelper_sem);",
            "\t}",
            "\tfinish_wait(&usermodehelper_disabled_waitq, &wait);",
            "\treturn timeout;",
            "}",
            "void usermodehelper_read_unlock(void)",
            "{",
            "\tup_read(&umhelper_sem);",
            "}",
            "void __usermodehelper_set_disable_depth(enum umh_disable_depth depth)",
            "{",
            "\tdown_write(&umhelper_sem);",
            "\tusermodehelper_disabled = depth;",
            "\twake_up(&usermodehelper_disabled_waitq);",
            "\tup_write(&umhelper_sem);",
            "}",
            "int __usermodehelper_disable(enum umh_disable_depth depth)",
            "{",
            "\tlong retval;",
            "",
            "\tif (!depth)",
            "\t\treturn -EINVAL;",
            "",
            "\tdown_write(&umhelper_sem);",
            "\tusermodehelper_disabled = depth;",
            "\tup_write(&umhelper_sem);",
            "",
            "\t/*",
            "\t * From now on call_usermodehelper_exec() won't start any new",
            "\t * helpers, so it is sufficient if running_helpers turns out to",
            "\t * be zero at one point (it may be increased later, but that",
            "\t * doesn't matter).",
            "\t */",
            "\tretval = wait_event_timeout(running_helpers_waitq,",
            "\t\t\t\t\tatomic_read(&running_helpers) == 0,",
            "\t\t\t\t\tRUNNING_HELPERS_TIMEOUT);",
            "\tif (retval)",
            "\t\treturn 0;",
            "",
            "\t__usermodehelper_set_disable_depth(UMH_ENABLED);",
            "\treturn -EAGAIN;",
            "}"
          ],
          "function_name": "call_usermodehelper_exec_work, usermodehelper_read_trylock, usermodehelper_read_lock_wait, usermodehelper_read_unlock, __usermodehelper_set_disable_depth, __usermodehelper_disable",
          "description": "提供读锁操作、深度禁用状态设置及禁用控制接口，用于协调用户模式帮助程序的启用状态和资源竞争管理。",
          "similarity": 0.49885934591293335
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/umh.c",
          "start_line": 575,
          "end_line": 579,
          "content": [
            "static int __init init_umh_sysctls(void)",
            "{",
            "\tregister_sysctl_init(\"kernel/usermodehelper\", usermodehelper_table);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "init_umh_sysctls",
          "description": "注册用户模式帮助程序的sysctl接口，用于暴露和管理系统范围的用户模式帮助程序能力配置参数。",
          "similarity": 0.4814733564853668
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/umh.c",
          "start_line": 1,
          "end_line": 43,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * umh - the kernel usermode helper",
            " */",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/unistd.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/cred.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/resource.h>",
            "#include <linux/notifier.h>",
            "#include <linux/suspend.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/async.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/initrd.h>",
            "#include <linux/freezer.h>",
            "",
            "#include <trace/events/module.h>",
            "",
            "#ifdef CONFIG_CREDP",
            "#include <asm/iee-cred.h>",
            "#endif",
            "",
            "static kernel_cap_t usermodehelper_bset = CAP_FULL_SET;",
            "static kernel_cap_t usermodehelper_inheritable = CAP_FULL_SET;",
            "static DEFINE_SPINLOCK(umh_sysctl_lock);",
            "static DECLARE_RWSEM(umhelper_sem);",
            ""
          ],
          "function_name": null,
          "description": "声明用户模式帮助程序的能力集合、锁及同步机制，用于控制用户模式辅助程序的权限和并发访问。",
          "similarity": 0.46455636620521545
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/umh.c",
          "start_line": 44,
          "end_line": 145,
          "content": [
            "static void call_usermodehelper_freeinfo(struct subprocess_info *info)",
            "{",
            "\tif (info->cleanup)",
            "\t\t(*info->cleanup)(info);",
            "\tkfree(info);",
            "}",
            "static void umh_complete(struct subprocess_info *sub_info)",
            "{",
            "\tstruct completion *comp = xchg(&sub_info->complete, NULL);",
            "\t/*",
            "\t * See call_usermodehelper_exec(). If xchg() returns NULL",
            "\t * we own sub_info, the UMH_KILLABLE caller has gone away",
            "\t * or the caller used UMH_NO_WAIT.",
            "\t */",
            "\tif (comp)",
            "\t\tcomplete(comp);",
            "\telse",
            "\t\tcall_usermodehelper_freeinfo(sub_info);",
            "}",
            "static int call_usermodehelper_exec_async(void *data)",
            "{",
            "\tstruct subprocess_info *sub_info = data;",
            "\tstruct cred *new;",
            "\tint retval;",
            "",
            "\tspin_lock_irq(&current->sighand->siglock);",
            "\tflush_signal_handlers(current, 1);",
            "\tspin_unlock_irq(&current->sighand->siglock);",
            "",
            "\t/*",
            "\t * Initial kernel threads share ther FS with init, in order to",
            "\t * get the init root directory. But we've now created a new",
            "\t * thread that is going to execve a user process and has its own",
            "\t * 'struct fs_struct'. Reset umask to the default.",
            "\t */",
            "\tcurrent->fs->umask = 0022;",
            "",
            "\t/*",
            "\t * Our parent (unbound workqueue) runs with elevated scheduling",
            "\t * priority. Avoid propagating that into the userspace child.",
            "\t */",
            "\tset_user_nice(current, 0);",
            "",
            "\tretval = -ENOMEM;",
            "\tnew = prepare_kernel_cred(current);",
            "\tif (!new)",
            "\t\tgoto out;",
            "",
            "\tspin_lock(&umh_sysctl_lock);",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_cap_bset(new, cap_intersect(usermodehelper_bset, new->cap_bset));",
            "\tiee_set_cred_cap_inheritable(new, cap_intersect(usermodehelper_inheritable,",
            "\t\t\t\t\t     new->cap_inheritable));",
            "\t#else",
            "\tnew->cap_bset = cap_intersect(usermodehelper_bset, new->cap_bset);",
            "\tnew->cap_inheritable = cap_intersect(usermodehelper_inheritable,",
            "\t\t\t\t\t     new->cap_inheritable);",
            "\t#endif",
            "\tspin_unlock(&umh_sysctl_lock);",
            "",
            "\tif (sub_info->init) {",
            "\t\tretval = sub_info->init(sub_info, new);",
            "\t\tif (retval) {",
            "\t\t\tabort_creds(new);",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t}",
            "",
            "\tcommit_creds(new);",
            "",
            "\twait_for_initramfs();",
            "\tretval = kernel_execve(sub_info->path,",
            "\t\t\t       (const char *const *)sub_info->argv,",
            "\t\t\t       (const char *const *)sub_info->envp);",
            "out:",
            "\tsub_info->retval = retval;",
            "\t/*",
            "\t * call_usermodehelper_exec_sync() will call umh_complete",
            "\t * if UHM_WAIT_PROC.",
            "\t */",
            "\tif (!(sub_info->wait & UMH_WAIT_PROC))",
            "\t\tumh_complete(sub_info);",
            "\tif (!retval)",
            "\t\treturn 0;",
            "\tdo_exit(0);",
            "}",
            "static void call_usermodehelper_exec_sync(struct subprocess_info *sub_info)",
            "{",
            "\tpid_t pid;",
            "",
            "\t/* If SIGCLD is ignored do_wait won't populate the status. */",
            "\tkernel_sigaction(SIGCHLD, SIG_DFL);",
            "\tpid = user_mode_thread(call_usermodehelper_exec_async, sub_info, SIGCHLD);",
            "\tif (pid < 0)",
            "\t\tsub_info->retval = pid;",
            "\telse",
            "\t\tkernel_wait(pid, &sub_info->retval);",
            "",
            "\t/* Restore default kernel sig handler */",
            "\tkernel_sigaction(SIGCHLD, SIG_IGN);",
            "\tumh_complete(sub_info);",
            "}"
          ],
          "function_name": "call_usermodehelper_freeinfo, umh_complete, call_usermodehelper_exec_async, call_usermodehelper_exec_sync",
          "description": "实现用户模式帮助程序的子进程清理、完成通知及异步/同步执行逻辑，包括权限调整、执行路径切换和结果返回处理。",
          "similarity": 0.4588918089866638
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/umh.c",
          "start_line": 331,
          "end_line": 467,
          "content": [
            "static void helper_lock(void)",
            "{",
            "\tatomic_inc(&running_helpers);",
            "\tsmp_mb__after_atomic();",
            "}",
            "static void helper_unlock(void)",
            "{",
            "\tif (atomic_dec_and_test(&running_helpers))",
            "\t\twake_up(&running_helpers_waitq);",
            "}",
            "int call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)",
            "{",
            "\tunsigned int state = TASK_UNINTERRUPTIBLE;",
            "\tDECLARE_COMPLETION_ONSTACK(done);",
            "\tint retval = 0;",
            "",
            "\tif (!sub_info->path) {",
            "\t\tcall_usermodehelper_freeinfo(sub_info);",
            "\t\treturn -EINVAL;",
            "\t}",
            "\thelper_lock();",
            "\tif (usermodehelper_disabled) {",
            "\t\tretval = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\t/*",
            "\t * If there is no binary for us to call, then just return and get out of",
            "\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and",
            "\t * disable all call_usermodehelper() calls.",
            "\t */",
            "\tif (strlen(sub_info->path) == 0)",
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * Set the completion pointer only if there is a waiter.",
            "\t * This makes it possible to use umh_complete to free",
            "\t * the data structure in case of UMH_NO_WAIT.",
            "\t */",
            "\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;",
            "\tsub_info->wait = wait;",
            "",
            "\tqueue_work(system_unbound_wq, &sub_info->work);",
            "\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */",
            "\t\tgoto unlock;",
            "",
            "\tif (wait & UMH_FREEZABLE)",
            "\t\tstate |= TASK_FREEZABLE;",
            "",
            "\tif (wait & UMH_KILLABLE) {",
            "\t\tretval = wait_for_completion_state(&done, state | TASK_KILLABLE);",
            "\t\tif (!retval)",
            "\t\t\tgoto wait_done;",
            "",
            "\t\t/* umh_complete() will see NULL and free sub_info */",
            "\t\tif (xchg(&sub_info->complete, NULL))",
            "\t\t\tgoto unlock;",
            "",
            "\t\t/*",
            "\t\t * fallthrough; in case of -ERESTARTSYS now do uninterruptible",
            "\t\t * wait_for_completion_state(). Since umh_complete() shall call",
            "\t\t * complete() in a moment if xchg() above returned NULL, this",
            "\t\t * uninterruptible wait_for_completion_state() will not block",
            "\t\t * SIGKILL'ed processes for long.",
            "\t\t */",
            "\t}",
            "\twait_for_completion_state(&done, state);",
            "",
            "wait_done:",
            "\tretval = sub_info->retval;",
            "out:",
            "\tcall_usermodehelper_freeinfo(sub_info);",
            "unlock:",
            "\thelper_unlock();",
            "\treturn retval;",
            "}",
            "int call_usermodehelper(const char *path, char **argv, char **envp, int wait)",
            "{",
            "\tstruct subprocess_info *info;",
            "\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;",
            "",
            "\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask,",
            "\t\t\t\t\t NULL, NULL, NULL);",
            "\tif (info == NULL)",
            "\t\treturn -ENOMEM;",
            "",
            "\treturn call_usermodehelper_exec(info, wait);",
            "}",
            "static int proc_cap_handler(struct ctl_table *table, int write,",
            "\t\t\t void *buffer, size_t *lenp, loff_t *ppos)",
            "{",
            "\tstruct ctl_table t;",
            "\tunsigned long cap_array[2];",
            "\tkernel_cap_t new_cap, *cap;",
            "\tint err;",
            "",
            "\tif (write && (!capable(CAP_SETPCAP) ||",
            "\t\t      !capable(CAP_SYS_MODULE)))",
            "\t\treturn -EPERM;",
            "",
            "\t/*",
            "\t * convert from the global kernel_cap_t to the ulong array to print to",
            "\t * userspace if this is a read.",
            "\t *",
            "\t * Legacy format: capabilities are exposed as two 32-bit values",
            "\t */",
            "\tcap = table->data;",
            "\tspin_lock(&umh_sysctl_lock);",
            "\tcap_array[0] = (u32) cap->val;",
            "\tcap_array[1] = cap->val >> 32;",
            "\tspin_unlock(&umh_sysctl_lock);",
            "",
            "\tt = *table;",
            "\tt.data = &cap_array;",
            "",
            "\t/*",
            "\t * actually read or write and array of ulongs from userspace.  Remember",
            "\t * these are least significant 32 bits first",
            "\t */",
            "\terr = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);",
            "\tif (err < 0)",
            "\t\treturn err;",
            "",
            "\tnew_cap.val = (u32)cap_array[0];",
            "\tnew_cap.val += (u64)cap_array[1] << 32;",
            "",
            "\t/*",
            "\t * Drop everything not in the new_cap (but don't add things)",
            "\t */",
            "\tif (write) {",
            "\t\tspin_lock(&umh_sysctl_lock);",
            "\t\t*cap = cap_intersect(*cap, new_cap);",
            "\t\tspin_unlock(&umh_sysctl_lock);",
            "\t}",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "helper_lock, helper_unlock, call_usermodehelper_exec, call_usermodehelper, proc_cap_handler",
          "description": "实现用户模式帮助程序执行核心API，包含运行计数器管理、能力交集计算及系统调参处理，支持动态能力限制配置。",
          "similarity": 0.44058895111083984
        }
      ]
    },
    {
      "source_file": "kernel/time/test_udelay.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:46:49\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `time\\test_udelay.c`\n\n---\n\n# `time/test_udelay.c` 技术文档\n\n## 1. 文件概述\n\n`test_udelay.c` 是一个用于测试内核中 `udelay()` 函数精度和行为的调试模块。该模块通过 debugfs 接口 `/sys/kernel/debug/udelay_test` 提供用户空间交互能力：用户可写入延迟微秒数（USECS）和迭代次数（ITERATIONS）来配置测试参数，通过读取同一文件触发测试执行并获取结果。若写入的 USECS 为 0 或负数，则显示帮助信息和当前系统时间戳。该模块主要用于验证 `udelay()` 在不同硬件平台和内核配置下的延迟准确性。\n\n## 2. 核心功能\n\n### 主要函数\n- **`udelay_test_single()`**：执行单次 udelay 测试，多次调用 `udelay()` 并统计实际延迟时间（最小值、最大值、平均值、失败次数）。\n- **`udelay_test_show()`**：debugfs 文件的读回调函数，根据配置参数决定是执行测试还是显示帮助信息。\n- **`udelay_test_open()`**：debugfs 文件的打开回调，使用 `single_open` 简化 seq_file 实现。\n- **`udelay_test_write()`**：debugfs 文件的写回调函数，解析用户输入的 USECS 和 ITERATIONS 参数。\n- **`udelay_test_init()`**：模块初始化函数，创建 debugfs 文件。\n- **`udelay_test_exit()`**：模块卸载函数，移除 debugfs 文件。\n\n### 关键数据结构与变量\n- **`udelay_test_lock`**：互斥锁，保护全局测试参数的并发访问。\n- **`udelay_test_usecs`**：用户配置的延迟微秒数（USECS）。\n- **`udelay_test_iterations`**：用户配置的测试迭代次数，默认为 `DEFAULT_ITERATIONS`（100 次）。\n- **`udelay_test_debugfs_ops`**：debugfs 文件操作结构体，定义文件读写行为。\n\n## 3. 关键实现\n\n- **延迟精度验证**：  \n  在 `udelay_test_single()` 中，每次调用 `udelay(usecs)` 前后使用 `ktime_get_ns()` 获取高精度时间戳，计算实际延迟时间（纳秒）。允许 `udelay()` 最多快 0.5%（即实际延迟 ≥ `usecs * 1000 - usecs * 5` 纳秒），否则计为失败。\n\n- **统计信息收集**：  \n  对每次迭代的延迟时间记录最小值（`min`）、最大值（`max`）、总和（`sum`），并计算平均值（`avg`）。失败次数（`fail_count`）统计实际延迟低于允许误差阈值的次数。\n\n- **用户交互设计**：  \n  - 写入格式：`echo USECS [ITERS] > /sys/kernel/debug/udelay_test`，ITERS 可选，默认 100。\n  - 读取行为：若 USECS > 0 则执行测试；若 USECS ≤ 0 则显示帮助信息及当前时间戳（含 `loops_per_jiffy` 和 `ktime`）。\n\n- **并发安全**：  \n  所有对全局变量 `udelay_test_usecs` 和 `udelay_test_iterations` 的读写均通过 `udelay_test_lock` 互斥锁保护，确保多线程环境下的数据一致性。\n\n- **错误处理**：  \n  - 写入缓冲区长度超过 32 字节返回 `-EINVAL`。\n  - 用户输入解析失败（`sscanf` 返回值 < 1）返回 `-EINVAL`。\n  - 使用 `WARN_ON(time_passed < 0)` 检测时间回退异常。\n\n## 4. 依赖关系\n\n- **内核头文件**：\n  - `<linux/debugfs.h>`：提供 debugfs 文件系统接口（`debugfs_create_file`、`debugfs_lookup_and_remove`）。\n  - `<linux/delay.h>`：提供 `udelay()` 函数声明。\n  - `<linux/ktime.h>`：提供高精度时间获取函数（`ktime_get_ns()`、`ktime_get_ts64()`）。\n  - `<linux/uaccess.h>`：提供用户空间内存拷贝函数（`copy_from_user`）。\n  - `<linux/module.h>`：模块初始化/卸载宏（`module_init`、`module_exit`）及许可证声明。\n- **内核机制**：\n  - **seq_file**：用于简化 debugfs 文件的顺序读取实现。\n  - **互斥锁（mutex）**：确保全局参数的线程安全。\n  - **loops_per_jiffy**：全局变量，反映 CPU 每 jiffy 的循环次数，用于 `udelay()` 的底层实现。\n\n## 5. 使用场景\n\n- **内核开发与调试**：  \n  在移植或优化 `udelay()` 实现时，验证其在不同架构（如 ARM、x86）或时钟源配置下的延迟精度。\n  \n- **硬件平台验证**：  \n  在新硬件平台上运行此模块，确认 `udelay()` 是否满足设备驱动对微秒级延迟的时序要求（如 GPIO 操作、I2C 时序）。\n\n- **性能分析**：  \n  通过多次迭代测试，分析 `udelay()` 的延迟抖动（min/max 差异）及系统负载对其精度的影响。\n\n- **回归测试**：  \n  作为内核测试套件的一部分，确保内核版本升级或补丁合入后 `udelay()` 行为未发生退化。",
      "similarity": 0.5181475877761841,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/time/test_udelay.c",
          "start_line": 1,
          "end_line": 26,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * udelay() test kernel module",
            " *",
            " * Test is executed by writing and reading to /sys/kernel/debug/udelay_test",
            " * Tests are configured by writing: USECS ITERATIONS",
            " * Tests are executed by reading from the same file.",
            " * Specifying usecs of 0 or negative values will run multiples tests.",
            " *",
            " * Copyright (C) 2014 Google, Inc.",
            " */",
            "",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/ktime.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "",
            "#define DEFAULT_ITERATIONS 100",
            "",
            "#define DEBUGFS_FILENAME \"udelay_test\"",
            "",
            "static DEFINE_MUTEX(udelay_test_lock);",
            "static int udelay_test_usecs;",
            "static int udelay_test_iterations = DEFAULT_ITERATIONS;",
            ""
          ],
          "function_name": null,
          "description": "定义UDelay测试模块的全局变量和调试文件系统名称，包含必要的头文件并设置默认迭代次数。",
          "similarity": 0.473374605178833
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/time/test_udelay.c",
          "start_line": 27,
          "end_line": 132,
          "content": [
            "static int udelay_test_single(struct seq_file *s, int usecs, uint32_t iters)",
            "{",
            "\tint min = 0, max = 0, fail_count = 0;",
            "\tuint64_t sum = 0;",
            "\tuint64_t avg;",
            "\tint i;",
            "\t/* Allow udelay to be up to 0.5% fast */",
            "\tint allowed_error_ns = usecs * 5;",
            "",
            "\tfor (i = 0; i < iters; ++i) {",
            "\t\ts64 kt1, kt2;",
            "\t\tint time_passed;",
            "",
            "\t\tkt1 = ktime_get_ns();",
            "\t\tudelay(usecs);",
            "\t\tkt2 = ktime_get_ns();",
            "\t\ttime_passed = kt2 - kt1;",
            "",
            "\t\tif (i == 0 || time_passed < min)",
            "\t\t\tmin = time_passed;",
            "\t\tif (i == 0 || time_passed > max)",
            "\t\t\tmax = time_passed;",
            "\t\tif ((time_passed + allowed_error_ns) / 1000 < usecs)",
            "\t\t\t++fail_count;",
            "\t\tWARN_ON(time_passed < 0);",
            "\t\tsum += time_passed;",
            "\t}",
            "",
            "\tavg = sum;",
            "\tdo_div(avg, iters);",
            "\tseq_printf(s, \"%d usecs x %d: exp=%d allowed=%d min=%d avg=%lld max=%d\",",
            "\t\t\tusecs, iters, usecs * 1000,",
            "\t\t\t(usecs * 1000) - allowed_error_ns, min, avg, max);",
            "\tif (fail_count)",
            "\t\tseq_printf(s, \" FAIL=%d\", fail_count);",
            "\tseq_puts(s, \"\\n\");",
            "",
            "\treturn 0;",
            "}",
            "static int udelay_test_show(struct seq_file *s, void *v)",
            "{",
            "\tint usecs;",
            "\tint iters;",
            "\tint ret = 0;",
            "",
            "\tmutex_lock(&udelay_test_lock);",
            "\tusecs = udelay_test_usecs;",
            "\titers = udelay_test_iterations;",
            "\tmutex_unlock(&udelay_test_lock);",
            "",
            "\tif (usecs > 0 && iters > 0) {",
            "\t\treturn udelay_test_single(s, usecs, iters);",
            "\t} else if (usecs == 0) {",
            "\t\tstruct timespec64 ts;",
            "",
            "\t\tktime_get_ts64(&ts);",
            "\t\tseq_printf(s, \"udelay() test (lpj=%ld kt=%lld.%09ld)\\n\",",
            "\t\t\t\tloops_per_jiffy, (s64)ts.tv_sec, ts.tv_nsec);",
            "\t\tseq_puts(s, \"usage:\\n\");",
            "\t\tseq_puts(s, \"echo USECS [ITERS] > \" DEBUGFS_FILENAME \"\\n\");",
            "\t\tseq_puts(s, \"cat \" DEBUGFS_FILENAME \"\\n\");",
            "\t}",
            "",
            "\treturn ret;",
            "}",
            "static int udelay_test_open(struct inode *inode, struct file *file)",
            "{",
            "\treturn single_open(file, udelay_test_show, inode->i_private);",
            "}",
            "static ssize_t udelay_test_write(struct file *file, const char __user *buf,",
            "\t\tsize_t count, loff_t *pos)",
            "{",
            "\tchar lbuf[32];",
            "\tint ret;",
            "\tint usecs;",
            "\tint iters;",
            "",
            "\tif (count >= sizeof(lbuf))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (copy_from_user(lbuf, buf, count))",
            "\t\treturn -EFAULT;",
            "\tlbuf[count] = '\\0';",
            "",
            "\tret = sscanf(lbuf, \"%d %d\", &usecs, &iters);",
            "\tif (ret < 1)",
            "\t\treturn -EINVAL;",
            "\telse if (ret < 2)",
            "\t\titers = DEFAULT_ITERATIONS;",
            "",
            "\tmutex_lock(&udelay_test_lock);",
            "\tudelay_test_usecs = usecs;",
            "\tudelay_test_iterations = iters;",
            "\tmutex_unlock(&udelay_test_lock);",
            "",
            "\treturn count;",
            "}",
            "static int __init udelay_test_init(void)",
            "{",
            "\tmutex_lock(&udelay_test_lock);",
            "\tdebugfs_create_file(DEBUGFS_FILENAME, S_IRUSR, NULL, NULL,",
            "\t\t\t    &udelay_test_debugfs_ops);",
            "\tmutex_unlock(&udelay_test_lock);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "udelay_test_single, udelay_test_show, udelay_test_open, udelay_test_write, udelay_test_init",
          "description": "实现UDelay测试核心逻辑，包含执行延时测试、统计结果展示、文件操作及调试接口注册等功能。",
          "similarity": 0.4394773542881012
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/time/test_udelay.c",
          "start_line": 149,
          "end_line": 154,
          "content": [
            "static void __exit udelay_test_exit(void)",
            "{",
            "\tmutex_lock(&udelay_test_lock);",
            "\tdebugfs_lookup_and_remove(DEBUGFS_FILENAME, NULL);",
            "\tmutex_unlock(&udelay_test_lock);",
            "}"
          ],
          "function_name": "udelay_test_exit",
          "description": "模块退出时通过debugfs_lookup_and_remove安全移除调试文件节点，确保资源正确释放。",
          "similarity": 0.4365365207195282
        }
      ]
    }
  ]
}