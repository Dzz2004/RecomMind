{
  "query": "libc functions",
  "timestamp": "2025-12-26 02:06:59",
  "retrieved_files": [
    {
      "source_file": "kernel/compat.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:52:31\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `compat.c`\n\n---\n\n# compat.c 技术文档\n\n## 文件概述\n\n`compat.c` 是 Linux 内核中用于提供 32 位系统调用兼容性支持的核心文件，主要运行在 64 位内核上。该文件实现了将 32 位用户空间程序发出的系统调用转换为内核内部 64 位数据结构和接口所需的适配逻辑，确保 32 位应用程序能够在 64 位系统上正常运行。其核心功能包括信号处理、资源使用统计（rusage）、CPU 亲和性设置、位图操作以及信号集转换等兼容层封装。\n\n## 核心功能\n\n### 主要函数\n\n- `compat_sigprocmask`：32 位兼容版的 `sigprocmask` 系统调用，用于操作进程的信号掩码。\n- `put_compat_rusage`：将内核的 `struct rusage` 转换为 32 位兼容格式并复制到用户空间。\n- `compat_get_user_cpu_mask`：从用户空间读取 32 位 CPU 亲和性位图并转换为内核 `cpumask`。\n- `compat_sched_setaffinity` / `compat_sched_getaffinity`：32 位兼容的 CPU 亲和性设置与获取系统调用。\n- `get_compat_sigevent`：将 32 位 `sigevent` 结构从用户空间复制并转换为内核格式。\n- `compat_get_bitmap` / `compat_put_bitmap`：在 32 位用户空间与 64 位内核之间安全地传输位图数据。\n- `get_compat_sigset`：将 32 位信号集（`compat_sigset_t`）转换为内核内部的 `sigset_t`。\n\n### 关键数据结构\n\n- `compat_sigset_t`：32 位信号集表示。\n- `compat_rusage`：32 位资源使用统计结构。\n- `compat_sigevent`：32 位信号事件描述结构。\n- `compat_ulong_t`：32 位无符号长整型（通常为 `u32`）。\n\n## 关键实现\n\n### 信号掩码处理（`compat_sigprocmask`）\n\n该函数仅操作信号掩码的第一个字（32 位），通过 `compat_sig_setmask` 直接内存拷贝实现 `SIG_SETMASK` 行为。对于 `SIG_BLOCK` 和 `SIG_UNBLOCK`，则调用内核通用的 `sigaddsetmask` 和 `sigdelsetmask` 辅助函数。特别地，它会自动屏蔽 `SIGKILL` 和 `SIGSTOP`，因为这两个信号不可被阻塞。\n\n### 位图转换（`compat_get_bitmap` / `compat_put_bitmap`）\n\n由于 64 位内核中 `unsigned long` 为 64 位，而 32 位用户空间使用 32 位 `compat_ulong_t`，位图需进行高低位重组：\n- **读取**：每两个 32 位值组合成一个 64 位内核值（低位在前，高位在后）。\n- **写入**：将一个 64 位内核值拆分为两个 32 位值写回用户空间。\n使用 `user_read_access_begin`/`user_write_access_end` 配合 `unsafe_get/put_user` 实现高效、安全的批量访问。\n\n### 字节序处理（`get_compat_sigset`）\n\n在大端（Big-Endian）架构上，32 位信号集的高低 32 位在内存中的排列与小端不同，需显式重组为 64 位内核信号字。小端架构可直接内存拷贝。\n\n### CPU 亲和性兼容（`sched_setaffinity`/`getaffinity`）\n\n- **设置**：通过 `compat_get_user_cpu_mask` 将用户传入的 32 位位图转换为内核 `cpumask`，再调用通用 `sched_setaffinity`。\n- **获取**：先调用通用接口获取内核 `cpumask`，再通过 `compat_put_bitmap` 转换回 32 位格式返回给用户。返回长度为实际写入的字节数。\n\n### 资源使用统计（`put_compat_rusage`）\n\n逐字段将 64 位 `rusage` 中的时间（`tv_sec`/`tv_usec`）及其他统计值复制到 32 位结构体，确保字段对齐和截断安全，最后通过 `copy_to_user` 返回。\n\n## 依赖关系\n\n- **头文件依赖**：\n  - `<linux/compat.h>`：提供兼容层宏定义和类型（如 `COMPAT_SYSCALL_DEFINE`）。\n  - `<linux/uaccess.h>`：用户空间内存访问接口（`get_user`、`put_user` 等）。\n  - `<linux/sched.h>`、`<linux/cpumask.h>`：调度和 CPU 亲和性相关 API。\n  - `<linux/signal.h>`：信号处理核心接口。\n  - `<linux/posix-timers.h>`：`sigevent` 相关定义。\n- **内核模块依赖**：\n  - 调度子系统（`kernel/sched/`）：`sched_setaffinity`/`getaffinity` 实现。\n  - 信号子系统（`kernel/signal.c`）：信号掩码操作函数。\n  - 内存管理：`GFP_KERNEL` 内存分配。\n- **架构依赖**：通过 `__ARCH_WANT_SYS_SIGPROCMASK` 宏控制是否编译 `sigprocmask` 兼容实现，依赖 `__BIG_ENDIAN` 处理字节序差异。\n\n## 使用场景\n\n1. **32 位应用程序在 64 位内核上运行**：当 32 位 ELF 程序执行系统调用（如 `sigprocmask`、`sched_setaffinity`）时，内核通过此文件中的兼容层函数处理参数转换。\n2. **跨架构二进制兼容**：在 x86_64、ARM64 等支持 32 位兼容模式的架构上，该文件是运行旧版 32 位软件的关键组件。\n3. **系统调用拦截与转换**：安全模块（如 SELinux）或容器运行时可能依赖此兼容层正确解析 32 位进程的系统调用参数。\n4. **性能监控工具**：32 位 `getrusage` 调用通过 `put_compat_rusage` 获取资源统计信息。\n5. **实时/多线程应用**：32 位程序使用 `timer_create` 等 POSIX 定时器接口时，`sigevent` 结构通过 `get_compat_sigevent` 转换。",
      "similarity": 0.5424714088439941,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/compat.c",
          "start_line": 35,
          "end_line": 144,
          "content": [
            "static inline void compat_sig_setmask(sigset_t *blocked, compat_sigset_word set)",
            "{",
            "\tmemcpy(blocked->sig, &set, sizeof(set));",
            "}",
            "int put_compat_rusage(const struct rusage *r, struct compat_rusage __user *ru)",
            "{",
            "\tstruct compat_rusage r32;",
            "\tmemset(&r32, 0, sizeof(r32));",
            "\tr32.ru_utime.tv_sec = r->ru_utime.tv_sec;",
            "\tr32.ru_utime.tv_usec = r->ru_utime.tv_usec;",
            "\tr32.ru_stime.tv_sec = r->ru_stime.tv_sec;",
            "\tr32.ru_stime.tv_usec = r->ru_stime.tv_usec;",
            "\tr32.ru_maxrss = r->ru_maxrss;",
            "\tr32.ru_ixrss = r->ru_ixrss;",
            "\tr32.ru_idrss = r->ru_idrss;",
            "\tr32.ru_isrss = r->ru_isrss;",
            "\tr32.ru_minflt = r->ru_minflt;",
            "\tr32.ru_majflt = r->ru_majflt;",
            "\tr32.ru_nswap = r->ru_nswap;",
            "\tr32.ru_inblock = r->ru_inblock;",
            "\tr32.ru_oublock = r->ru_oublock;",
            "\tr32.ru_msgsnd = r->ru_msgsnd;",
            "\tr32.ru_msgrcv = r->ru_msgrcv;",
            "\tr32.ru_nsignals = r->ru_nsignals;",
            "\tr32.ru_nvcsw = r->ru_nvcsw;",
            "\tr32.ru_nivcsw = r->ru_nivcsw;",
            "\tif (copy_to_user(ru, &r32, sizeof(r32)))",
            "\t\treturn -EFAULT;",
            "\treturn 0;",
            "}",
            "static int compat_get_user_cpu_mask(compat_ulong_t __user *user_mask_ptr,",
            "\t\t\t\t    unsigned len, struct cpumask *new_mask)",
            "{",
            "\tunsigned long *k;",
            "",
            "\tif (len < cpumask_size())",
            "\t\tmemset(new_mask, 0, cpumask_size());",
            "\telse if (len > cpumask_size())",
            "\t\tlen = cpumask_size();",
            "",
            "\tk = cpumask_bits(new_mask);",
            "\treturn compat_get_bitmap(k, user_mask_ptr, len * 8);",
            "}",
            "int get_compat_sigevent(struct sigevent *event,",
            "\t\tconst struct compat_sigevent __user *u_event)",
            "{",
            "\tmemset(event, 0, sizeof(*event));",
            "\treturn (!access_ok(u_event, sizeof(*u_event)) ||",
            "\t\t__get_user(event->sigev_value.sival_int,",
            "\t\t\t&u_event->sigev_value.sival_int) ||",
            "\t\t__get_user(event->sigev_signo, &u_event->sigev_signo) ||",
            "\t\t__get_user(event->sigev_notify, &u_event->sigev_notify) ||",
            "\t\t__get_user(event->sigev_notify_thread_id,",
            "\t\t\t&u_event->sigev_notify_thread_id))",
            "\t\t? -EFAULT : 0;",
            "}",
            "long compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,",
            "\t\t       unsigned long bitmap_size)",
            "{",
            "\tunsigned long nr_compat_longs;",
            "",
            "\t/* align bitmap up to nearest compat_long_t boundary */",
            "\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);",
            "\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);",
            "",
            "\tif (!user_read_access_begin(umask, bitmap_size / 8))",
            "\t\treturn -EFAULT;",
            "",
            "\twhile (nr_compat_longs > 1) {",
            "\t\tcompat_ulong_t l1, l2;",
            "\t\tunsafe_get_user(l1, umask++, Efault);",
            "\t\tunsafe_get_user(l2, umask++, Efault);",
            "\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;",
            "\t\tnr_compat_longs -= 2;",
            "\t}",
            "\tif (nr_compat_longs)",
            "\t\tunsafe_get_user(*mask, umask++, Efault);",
            "\tuser_read_access_end();",
            "\treturn 0;",
            "",
            "Efault:",
            "\tuser_read_access_end();",
            "\treturn -EFAULT;",
            "}",
            "long compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,",
            "\t\t       unsigned long bitmap_size)",
            "{",
            "\tunsigned long nr_compat_longs;",
            "",
            "\t/* align bitmap up to nearest compat_long_t boundary */",
            "\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);",
            "\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);",
            "",
            "\tif (!user_write_access_begin(umask, bitmap_size / 8))",
            "\t\treturn -EFAULT;",
            "",
            "\twhile (nr_compat_longs > 1) {",
            "\t\tunsigned long m = *mask++;",
            "\t\tunsafe_put_user((compat_ulong_t)m, umask++, Efault);",
            "\t\tunsafe_put_user(m >> BITS_PER_COMPAT_LONG, umask++, Efault);",
            "\t\tnr_compat_longs -= 2;",
            "\t}",
            "\tif (nr_compat_longs)",
            "\t\tunsafe_put_user((compat_ulong_t)*mask, umask++, Efault);",
            "\tuser_write_access_end();",
            "\treturn 0;",
            "Efault:",
            "\tuser_write_access_end();",
            "\treturn -EFAULT;",
            "}"
          ],
          "function_name": "compat_sig_setmask, put_compat_rusage, compat_get_user_cpu_mask, get_compat_sigevent, compat_get_bitmap, compat_put_bitmap",
          "description": "实现多个兼容性转换函数，包括将rusage结构体转换为32位格式、处理CPU掩码位图转换、提取sigevent事件信息以及双向转换信号集位图，核心功能是解决64位内核与32位用户态数据类型的差异。",
          "similarity": 0.45472314953804016
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/compat.c",
          "start_line": 1,
          "end_line": 34,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " *  linux/kernel/compat.c",
            " *",
            " *  Kernel compatibililty routines for e.g. 32 bit syscall support",
            " *  on 64 bit kernels.",
            " *",
            " *  Copyright (C) 2002-2003 Stephen Rothwell, IBM Corporation",
            " */",
            "",
            "#include <linux/linkage.h>",
            "#include <linux/compat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/signal.h>",
            "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
            "#include <linux/syscalls.h>",
            "#include <linux/unistd.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/times.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/gfp.h>",
            "",
            "#include <linux/uaccess.h>",
            "",
            "#ifdef __ARCH_WANT_SYS_SIGPROCMASK",
            "",
            "/*",
            " * sys_sigprocmask SIG_SETMASK sets the first (compat) word of the",
            " * blocked set of signals to the supplied signal set",
            " */"
          ],
          "function_name": null,
          "description": "此代码块包含兼容性支持所需的基础头文件和注释，定义了处理32位系统调用兼容性的框架，主要用于实现64位内核对32位进程的信号集操作等兼容逻辑。",
          "similarity": 0.424706369638443
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/compat.c",
          "start_line": 249,
          "end_line": 270,
          "content": [
            "int",
            "get_compat_sigset(sigset_t *set, const compat_sigset_t __user *compat)",
            "{",
            "#ifdef __BIG_ENDIAN",
            "\tcompat_sigset_t v;",
            "\tif (copy_from_user(&v, compat, sizeof(compat_sigset_t)))",
            "\t\treturn -EFAULT;",
            "\tswitch (_NSIG_WORDS) {",
            "\tcase 4: set->sig[3] = v.sig[6] | (((long)v.sig[7]) << 32 );",
            "\t\tfallthrough;",
            "\tcase 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );",
            "\t\tfallthrough;",
            "\tcase 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );",
            "\t\tfallthrough;",
            "\tcase 1: set->sig[0] = v.sig[0] | (((long)v.sig[1]) << 32 );",
            "\t}",
            "#else",
            "\tif (copy_from_user(set, compat, sizeof(compat_sigset_t)))",
            "\t\treturn -EFAULT;",
            "#endif",
            "\treturn 0;",
            "}"
          ],
          "function_name": "get_compat_sigset",
          "description": "将用户态的兼容信号集（compat_sigset_t）转换为内核态sigset_t结构，在大端架构下通过字节序调整确保信号掩码的正确解析，实现信号集的跨字节序兼容转换。",
          "similarity": 0.3911329507827759
        }
      ]
    },
    {
      "source_file": "kernel/bpf/token.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:36:08\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\token.c`\n\n---\n\n# `bpf/token.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/token.c` 实现了 BPF（Berkeley Packet Filter）令牌（token）机制，用于在受限环境中安全地委托 BPF 操作权限。该机制允许用户空间程序通过文件描述符形式的令牌，将特定的 BPF 命令、映射类型、程序类型和附加类型权限委托给其他进程，同时结合用户命名空间（user namespace）和 LSM（Linux Security Module）安全策略进行细粒度访问控制。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `bpf_ns_capable()`：检查用户命名空间是否具备指定能力，或具备 `CAP_SYS_ADMIN`（除 `CAP_SYS_ADMIN` 自身外）。\n- `bpf_token_capable()`：结合用户命名空间能力和 LSM 安全钩子，判断令牌是否具备指定能力。\n- `bpf_token_inc()` / `bpf_token_put()`：引用计数管理，支持延迟释放。\n- `bpf_token_free()`：释放令牌资源，包括用户命名空间引用和安全模块数据。\n- `bpf_token_create()`：创建 BPF 令牌文件描述符，基于挂载在 BPF 文件系统上的委托配置。\n- `bpf_token_get_from_fd()`：从文件描述符获取并增加引用计数的 `bpf_token` 结构。\n- `bpf_token_allow_cmd()` / `bpf_token_allow_map_type()` / `bpf_token_allow_prog_type()`：检查令牌是否允许执行特定 BPF 操作。\n\n### 关键数据结构\n\n- `struct bpf_token`：表示 BPF 令牌，包含：\n  - `refcnt`：引用计数（`atomic64_t`）\n  - `userns`：关联的用户命名空间\n  - `allowed_cmds` / `allowed_maps` / `allowed_progs` / `allowed_attachs`：位掩码，分别表示允许的 BPF 命令、映射类型、程序类型和附加类型\n  - `work`：用于延迟释放的工作队列项\n\n### 文件操作接口\n\n- `bpf_token_fops`：定义了 `release` 和 `show_fdinfo` 回调，用于文件关闭和 `/proc/pid/fdinfo/` 信息展示。\n\n## 3. 关键实现\n\n### 令牌创建流程 (`bpf_token_create`)\n\n1. **验证输入**：检查传入的 `bpffs_fd` 是否指向 BPF 文件系统的根目录。\n2. **权限校验**：\n   - 要求调用者与 BPF 文件系统实例处于同一用户命名空间。\n   - 必须具备 `CAP_BPF` 能力。\n   - 禁止在 `init_user_ns` 中创建令牌。\n3. **委托配置检查**：确保 BPF 文件系统挂载时已通过挂载选项设置了至少一项委托权限（`delegate_*` 字段非零）。\n4. **资源分配**：\n   - 创建匿名 inode 和文件。\n   - 分配 `bpf_token` 结构并初始化引用计数为 1。\n   - 复制挂载选项中的委托位掩码到令牌。\n5. **安全模块集成**：调用 `security_bpf_token_create()` 允许 LSM 进行额外策略检查。\n6. **返回文件描述符**：安装文件到进程 fd 表并返回。\n\n### 安全能力检查 (`bpf_token_capable`)\n\n- 默认允许 `CAP_SYS_ADMIN` 作为“超级能力”覆盖其他能力检查（但 `CAP_SYS_ADMIN` 本身仍需显式授权）。\n- 调用 `security_bpf_token_capable()` 允许 LSM 对令牌能力进行二次验证。\n\n### 引用计数与延迟释放\n\n- 使用 `atomic64_t refcnt` 管理生命周期。\n- 当引用计数归零时，通过 `schedule_work()` 将释放操作推迟到工作队列执行，避免在中断或原子上下文中调用可能睡眠的 `put_user_ns()` 和 `kfree()`。\n\n### `/proc/pid/fdinfo/` 支持\n\n- `bpf_token_show_fdinfo()` 将令牌的委托权限以十六进制或 \"any\" 形式输出，便于调试和审计。\n\n### 权限位掩码设计\n\n- 所有委托权限（命令、映射、程序、附加类型）均使用 64 位无符号整数位掩码表示。\n- 通过 `BUILD_BUG_ON()` 确保枚举类型数量不超过 64，防止位移溢出。\n- 若掩码全为 1，则显示为 \"any\"，表示无限制。\n\n## 4. 依赖关系\n\n- **BPF 子系统**：依赖 `bpf_super_ops`、`bpf_get_inode()` 等 BPF 文件系统接口。\n- **用户命名空间**：通过 `user_namespace` 和 `ns_capable()` 实现能力隔离。\n- **安全模块 (LSM)**：集成 `security_bpf_token_*` 钩子，支持 SELinux、AppArmor 等策略扩展。\n- **VFS 层**：使用 `inode`、`file`、`path`、`fdtable` 等通用文件系统抽象。\n- **内存管理**：使用 `kzalloc()`/`kfree()` 和 `vmalloc.h`（虽未直接使用，但为潜在扩展预留）。\n- **工作队列**：通过 `schedule_work()` 实现延迟释放。\n\n## 5. 使用场景\n\n- **容器化环境中的 BPF 权限委托**：在用户命名空间隔离的容器中，特权进程可创建 BPF 令牌并传递给非特权子进程，使其在受限范围内使用 BPF 功能（如 eBPF 程序加载、映射操作）。\n- **安全沙箱**：应用程序可通过令牌机制将特定 BPF 操作权限委托给插件或子模块，避免授予完整 `CAP_BPF` 或 `CAP_SYS_ADMIN`。\n- **审计与调试**：通过 `/proc/pid/fdinfo/` 查看进程持有的 BPF 令牌权限，辅助安全分析。\n- **LSM 策略集成**：安全模块可基于令牌内容实施更细粒度的访问控制，例如限制特定程序类型只能在特定挂载点使用。",
      "similarity": 0.5299833416938782,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/token.c",
          "start_line": 12,
          "end_line": 195,
          "content": [
            "static bool bpf_ns_capable(struct user_namespace *ns, int cap)",
            "{",
            "\treturn ns_capable(ns, cap) || (cap != CAP_SYS_ADMIN && ns_capable(ns, CAP_SYS_ADMIN));",
            "}",
            "bool bpf_token_capable(const struct bpf_token *token, int cap)",
            "{",
            "\tstruct user_namespace *userns;",
            "",
            "\t/* BPF token allows ns_capable() level of capabilities */",
            "\tuserns = token ? token->userns : &init_user_ns;",
            "\tif (!bpf_ns_capable(userns, cap))",
            "\t\treturn false;",
            "\tif (token && security_bpf_token_capable(token, cap) < 0)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "void bpf_token_inc(struct bpf_token *token)",
            "{",
            "\tatomic64_inc(&token->refcnt);",
            "}",
            "static void bpf_token_free(struct bpf_token *token)",
            "{",
            "\tsecurity_bpf_token_free(token);",
            "\tput_user_ns(token->userns);",
            "\tkfree(token);",
            "}",
            "static void bpf_token_put_deferred(struct work_struct *work)",
            "{",
            "\tstruct bpf_token *token = container_of(work, struct bpf_token, work);",
            "",
            "\tbpf_token_free(token);",
            "}",
            "void bpf_token_put(struct bpf_token *token)",
            "{",
            "\tif (!token)",
            "\t\treturn;",
            "",
            "\tif (!atomic64_dec_and_test(&token->refcnt))",
            "\t\treturn;",
            "",
            "\tINIT_WORK(&token->work, bpf_token_put_deferred);",
            "\tschedule_work(&token->work);",
            "}",
            "static int bpf_token_release(struct inode *inode, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "",
            "\tbpf_token_put(token);",
            "\treturn 0;",
            "}",
            "static void bpf_token_show_fdinfo(struct seq_file *m, struct file *filp)",
            "{",
            "\tstruct bpf_token *token = filp->private_data;",
            "\tu64 mask;",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_CMD >= 64);",
            "\tmask = (1ULL << __MAX_BPF_CMD) - 1;",
            "\tif ((token->allowed_cmds & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_cmds:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_cmds:\\t0x%llx\\n\", token->allowed_cmds);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_MAP_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_MAP_TYPE) - 1;",
            "\tif ((token->allowed_maps & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_maps:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_maps:\\t0x%llx\\n\", token->allowed_maps);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_PROG_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_PROG_TYPE) - 1;",
            "\tif ((token->allowed_progs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_progs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_progs:\\t0x%llx\\n\", token->allowed_progs);",
            "",
            "\tBUILD_BUG_ON(__MAX_BPF_ATTACH_TYPE >= 64);",
            "\tmask = (1ULL << __MAX_BPF_ATTACH_TYPE) - 1;",
            "\tif ((token->allowed_attachs & mask) == mask)",
            "\t\tseq_printf(m, \"allowed_attachs:\\tany\\n\");",
            "\telse",
            "\t\tseq_printf(m, \"allowed_attachs:\\t0x%llx\\n\", token->allowed_attachs);",
            "}",
            "int bpf_token_create(union bpf_attr *attr)",
            "{",
            "\tstruct bpf_mount_opts *mnt_opts;",
            "\tstruct bpf_token *token = NULL;",
            "\tstruct user_namespace *userns;",
            "\tstruct inode *inode;",
            "\tstruct file *file;",
            "\tCLASS(fd, f)(attr->token_create.bpffs_fd);",
            "\tstruct path path;",
            "\tstruct super_block *sb;",
            "\tumode_t mode;",
            "\tint err, fd;",
            "",
            "\tif (fd_empty(f))",
            "\t\treturn -EBADF;",
            "",
            "\tpath = fd_file(f)->f_path;",
            "\tsb = path.dentry->d_sb;",
            "",
            "\tif (path.dentry != sb->s_root)",
            "\t\treturn -EINVAL;",
            "\tif (sb->s_op != &bpf_super_ops)",
            "\t\treturn -EINVAL;",
            "\terr = path_permission(&path, MAY_ACCESS);",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tuserns = sb->s_user_ns;",
            "\t/*",
            "\t * Enforce that creators of BPF tokens are in the same user",
            "\t * namespace as the BPF FS instance. This makes reasoning about",
            "\t * permissions a lot easier and we can always relax this later.",
            "\t */",
            "\tif (current_user_ns() != userns)",
            "\t\treturn -EPERM;",
            "\tif (!ns_capable(userns, CAP_BPF))",
            "\t\treturn -EPERM;",
            "",
            "\t/* Creating BPF token in init_user_ns doesn't make much sense. */",
            "\tif (current_user_ns() == &init_user_ns)",
            "\t\treturn -EOPNOTSUPP;",
            "",
            "\tmnt_opts = sb->s_fs_info;",
            "\tif (mnt_opts->delegate_cmds == 0 &&",
            "\t    mnt_opts->delegate_maps == 0 &&",
            "\t    mnt_opts->delegate_progs == 0 &&",
            "\t    mnt_opts->delegate_attachs == 0)",
            "\t\treturn -ENOENT; /* no BPF token delegation is set up */",
            "",
            "\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());",
            "\tinode = bpf_get_inode(sb, NULL, mode);",
            "\tif (IS_ERR(inode))",
            "\t\treturn PTR_ERR(inode);",
            "",
            "\tinode->i_op = &bpf_token_iops;",
            "\tinode->i_fop = &bpf_token_fops;",
            "\tclear_nlink(inode); /* make sure it is unlinked */",
            "",
            "\tfile = alloc_file_pseudo(inode, path.mnt, BPF_TOKEN_INODE_NAME, O_RDWR, &bpf_token_fops);",
            "\tif (IS_ERR(file)) {",
            "\t\tiput(inode);",
            "\t\treturn PTR_ERR(file);",
            "\t}",
            "",
            "\ttoken = kzalloc(sizeof(*token), GFP_USER);",
            "\tif (!token) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto out_file;",
            "\t}",
            "",
            "\tatomic64_set(&token->refcnt, 1);",
            "",
            "\t/* remember bpffs owning userns for future ns_capable() checks */",
            "\ttoken->userns = get_user_ns(userns);",
            "",
            "\ttoken->allowed_cmds = mnt_opts->delegate_cmds;",
            "\ttoken->allowed_maps = mnt_opts->delegate_maps;",
            "\ttoken->allowed_progs = mnt_opts->delegate_progs;",
            "\ttoken->allowed_attachs = mnt_opts->delegate_attachs;",
            "",
            "\terr = security_bpf_token_create(token, attr, &path);",
            "\tif (err)",
            "\t\tgoto out_token;",
            "",
            "\tfd = get_unused_fd_flags(O_CLOEXEC);",
            "\tif (fd < 0) {",
            "\t\terr = fd;",
            "\t\tgoto out_token;",
            "\t}",
            "",
            "\tfile->private_data = token;",
            "\tfd_install(fd, file);",
            "",
            "\treturn fd;",
            "",
            "out_token:",
            "\tbpf_token_free(token);",
            "out_file:",
            "\tfput(file);",
            "\treturn err;",
            "}"
          ],
          "function_name": "bpf_ns_capable, bpf_token_capable, bpf_token_inc, bpf_token_free, bpf_token_put_deferred, bpf_token_put, bpf_token_release, bpf_token_show_fdinfo, bpf_token_create",
          "description": "实现BPF令牌的权限检查、引用计数管理、延迟释放及创建逻辑，包括基于挂载选项的令牌初始化和安全策略校验。",
          "similarity": 0.48752695322036743
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/token.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "#include <linux/bpf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            ""
          ],
          "function_name": null,
          "description": "包含BPF令牌功能所需的各种内核头文件，如用户命名空间、安全策略、文件操作及BPF相关定义。",
          "similarity": 0.4573131501674652
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/token.c",
          "start_line": 230,
          "end_line": 254,
          "content": [
            "bool bpf_token_allow_cmd(const struct bpf_token *token, enum bpf_cmd cmd)",
            "{",
            "\tif (!token)",
            "\t\treturn false;",
            "\tif (!(token->allowed_cmds & (1ULL << cmd)))",
            "\t\treturn false;",
            "\treturn security_bpf_token_cmd(token, cmd) == 0;",
            "}",
            "bool bpf_token_allow_map_type(const struct bpf_token *token, enum bpf_map_type type)",
            "{",
            "\tif (!token || type >= __MAX_BPF_MAP_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn token->allowed_maps & (1ULL << type);",
            "}",
            "bool bpf_token_allow_prog_type(const struct bpf_token *token,",
            "\t\t\t       enum bpf_prog_type prog_type,",
            "\t\t\t       enum bpf_attach_type attach_type)",
            "{",
            "\tif (!token || prog_type >= __MAX_BPF_PROG_TYPE || attach_type >= __MAX_BPF_ATTACH_TYPE)",
            "\t\treturn false;",
            "",
            "\treturn (token->allowed_progs & (1ULL << prog_type)) &&",
            "\t       (token->allowed_attachs & (1ULL << attach_type));",
            "}"
          ],
          "function_name": "bpf_token_allow_cmd, bpf_token_allow_map_type, bpf_token_allow_prog_type",
          "description": "提供对BPF命令、映射类型和程序类型的访问控制检查，通过位掩码匹配并结合安全模块验证权限。",
          "similarity": 0.43346065282821655
        }
      ]
    },
    {
      "source_file": "kernel/seccomp.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:23:11\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `seccomp.c`\n\n---\n\n# seccomp.c 技术文档\n\n## 文件概述\n\n`seccomp.c` 是 Linux 内核中实现安全计算（Secure Computing，简称 seccomp）机制的核心文件。该机制用于限制进程可执行的系统调用，从而提升系统安全性。文件支持两种主要模式：\n\n- **Mode 1（严格模式）**：仅允许 `read`、`write`、`exit` 和 `sigreturn` 四个系统调用。\n- **Mode 2（过滤器模式）**：允许用户通过 Berkeley Packet Filter（BPF）形式定义自定义的系统调用过滤规则。\n\n此外，该文件还实现了 **用户空间通知（user-space notification）** 功能，允许内核在遇到特定系统调用时暂停执行并通知用户态监听器进行处理。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`struct seccomp_filter`**  \n  表示一个 seccomp BPF 过滤器实例，包含：\n  - 引用计数（`refs` 和 `users`）\n  - BPF 程序指针（`prog`）\n  - 通知相关结构（`notif`、`notify_lock`、`wqh`）\n  - 动作缓存（`cache`）\n  - 指向前一个过滤器的指针（`prev`），构成过滤器链\n\n- **`struct notification`**  \n  管理用户空间通知的容器，包含请求计数器、标志位、下一个通知 ID 和通知链表。\n\n- **`struct seccomp_knotif`**  \n  表示一个待处理的用户通知请求，记录触发通知的任务、系统调用数据、状态（INIT/SENT/REPLIED）、返回值及完成信号量。\n\n- **`struct seccomp_kaddfd`**  \n  用于 `SECCOMP_IOCTL_NOTIF_ADDFD` 操作，允许监听器向目标进程注入文件描述符。\n\n- **`struct action_cache`**（条件编译）  \n  针对原生和兼容架构的系统调用动作缓存，用于快速判断是否允许某系统调用，避免重复执行 BPF 程序。\n\n### 关键枚举与常量\n\n- **`enum notify_state`**：通知状态机（INIT → SENT → REPLIED）\n- **`SECCOMP_MODE_DEAD`**：内部使用的特殊模式，表示进程已进入不可恢复的 seccomp 状态\n- **`MAX_INSNS_PER_PATH`**：限制 BPF 指令路径总长度不超过 256KB，防止资源耗尽\n\n### 特殊兼容性处理\n\n- **`SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR`**：为兼容早期错误的 ioctl 命令方向而保留的旧定义\n\n## 关键实现\n\n### 过滤器生命周期管理\n\n- 使用双重引用计数机制：\n  - `refs`：控制对象内存释放（包括任务引用、依赖过滤器、通知监听器）\n  - `users`：跟踪直接或间接使用该过滤器的任务数量，用于判断是否还能被新任务继承\n- 过滤器一旦附加到任务，除引用计数外不可修改，确保并发安全\n\n### 用户空间通知机制\n\n- 当 BPF 程序返回 `SECCOMP_RET_USER_NOTIF` 时，内核创建 `seccomp_knotif` 并加入通知队列\n- 用户态通过文件描述符读取通知，内核将状态置为 `SENT`\n- 监听器通过 `ioctl` 回复结果，状态转为 `REPLIED`，触发 `completion` 使原任务继续执行\n- 支持通过 `SECCOMP_IOCTL_NOTIF_ADDFD` 向目标进程注入文件描述符\n\n### 动作缓存优化（`action_cache`）\n\n- 在支持 `SECCOMP_ARCH_NATIVE` 的架构上，为每个系统调用编号维护一个“始终允许”位图\n- 若缓存命中（即该系统调用在所有路径下均返回 `ALLOW`），可跳过 BPF 执行，提升性能\n- 分别处理原生（native）和兼容（compat）系统调用空间\n\n### 安全与资源限制\n\n- 限制 BPF 指令总路径长度，防止深度嵌套或循环导致 DoS\n- 通知机制使用互斥锁（`notify_lock`）和完成量（`completion`）保证状态一致性\n- 支持 `wait_killable_recv` 选项，使等待通知回复的进程可被信号中断\n\n## 依赖关系\n\n- **BPF 子系统**：依赖 `linux/filter.h` 提供的 socket filter/BPF 执行引擎\n- **进程管理**：与 `sched.h`、`task_struct` 紧密集成，管理 per-task seccomp 状态\n- **文件系统与 fd 管理**：通过 `file.h`、`uaccess.h` 实现跨进程 fd 注入\n- **审计与日志**：集成 `audit.h` 支持 seccomp 事件审计\n- **架构相关代码**：通过 `asm/syscall.h` 获取系统调用号和参数\n- **能力机制**：依赖 `capability.h` 检查特权操作权限\n- **内存管理**：使用 `slab.h` 分配过滤器和通知结构\n\n## 使用场景\n\n1. **容器安全**：Docker、LXC 等容器运行时使用 seccomp 过滤器限制容器内进程的系统调用，防止逃逸\n2. **沙箱应用**：Chromium、Firefox 等浏览器使用 seccomp 构建渲染进程沙箱\n3. **最小权限原则**：特权服务（如 systemd、sshd）在初始化后启用 seccomp 以减少攻击面\n4. **动态策略执行**：通过 `SECCOMP_RET_USER_NOTIF` 实现用户态代理系统调用（如 ptrace 替代方案）\n5. **安全审计**：结合 `SECCOMP_RET_LOG` 记录所有被拦截或允许的系统调用行为\n6. **系统加固**：在不可信环境中运行程序时，强制限制其系统调用能力",
      "similarity": 0.5297021865844727,
      "chunks": [
        {
          "chunk_id": 7,
          "file_path": "kernel/seccomp.c",
          "start_line": 1215,
          "end_line": 1338,
          "content": [
            "static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,",
            "\t\t\t    const bool recheck_after_trace)",
            "{",
            "\tu32 filter_ret, action;",
            "\tstruct seccomp_filter *match = NULL;",
            "\tint data;",
            "\tstruct seccomp_data sd_local;",
            "",
            "\t/*",
            "\t * Make sure that any changes to mode from another thread have",
            "\t * been seen after SYSCALL_WORK_SECCOMP was seen.",
            "\t */",
            "\tsmp_rmb();",
            "",
            "\tif (!sd) {",
            "\t\tpopulate_seccomp_data(&sd_local);",
            "\t\tsd = &sd_local;",
            "\t}",
            "",
            "\tfilter_ret = seccomp_run_filters(sd, &match);",
            "\tdata = filter_ret & SECCOMP_RET_DATA;",
            "\taction = filter_ret & SECCOMP_RET_ACTION_FULL;",
            "",
            "\tswitch (action) {",
            "\tcase SECCOMP_RET_ERRNO:",
            "\t\t/* Set low-order bits as an errno, capped at MAX_ERRNO. */",
            "\t\tif (data > MAX_ERRNO)",
            "\t\t\tdata = MAX_ERRNO;",
            "\t\tsyscall_set_return_value(current, current_pt_regs(),",
            "\t\t\t\t\t -data, 0);",
            "\t\tgoto skip;",
            "",
            "\tcase SECCOMP_RET_TRAP:",
            "\t\t/* Show the handler the original registers. */",
            "\t\tsyscall_rollback(current, current_pt_regs());",
            "\t\t/* Let the filter pass back 16 bits of data. */",
            "\t\tforce_sig_seccomp(this_syscall, data, false);",
            "\t\tgoto skip;",
            "",
            "\tcase SECCOMP_RET_TRACE:",
            "\t\t/* We've been put in this state by the ptracer already. */",
            "\t\tif (recheck_after_trace)",
            "\t\t\treturn 0;",
            "",
            "\t\t/* ENOSYS these calls if there is no tracer attached. */",
            "\t\tif (!ptrace_event_enabled(current, PTRACE_EVENT_SECCOMP)) {",
            "\t\t\tsyscall_set_return_value(current,",
            "\t\t\t\t\t\t current_pt_regs(),",
            "\t\t\t\t\t\t -ENOSYS, 0);",
            "\t\t\tgoto skip;",
            "\t\t}",
            "",
            "\t\t/* Allow the BPF to provide the event message */",
            "\t\tptrace_event(PTRACE_EVENT_SECCOMP, data);",
            "\t\t/*",
            "\t\t * The delivery of a fatal signal during event",
            "\t\t * notification may silently skip tracer notification,",
            "\t\t * which could leave us with a potentially unmodified",
            "\t\t * syscall that the tracer would have liked to have",
            "\t\t * changed. Since the process is about to die, we just",
            "\t\t * force the syscall to be skipped and let the signal",
            "\t\t * kill the process and correctly handle any tracer exit",
            "\t\t * notifications.",
            "\t\t */",
            "\t\tif (fatal_signal_pending(current))",
            "\t\t\tgoto skip;",
            "\t\t/* Check if the tracer forced the syscall to be skipped. */",
            "\t\tthis_syscall = syscall_get_nr(current, current_pt_regs());",
            "\t\tif (this_syscall < 0)",
            "\t\t\tgoto skip;",
            "",
            "\t\t/*",
            "\t\t * Recheck the syscall, since it may have changed. This",
            "\t\t * intentionally uses a NULL struct seccomp_data to force",
            "\t\t * a reload of all registers. This does not goto skip since",
            "\t\t * a skip would have already been reported.",
            "\t\t */",
            "\t\tif (__seccomp_filter(this_syscall, NULL, true))",
            "\t\t\treturn -1;",
            "",
            "\t\treturn 0;",
            "",
            "\tcase SECCOMP_RET_USER_NOTIF:",
            "\t\tif (seccomp_do_user_notification(this_syscall, match, sd))",
            "\t\t\tgoto skip;",
            "",
            "\t\treturn 0;",
            "",
            "\tcase SECCOMP_RET_LOG:",
            "\t\tseccomp_log(this_syscall, 0, action, true);",
            "\t\treturn 0;",
            "",
            "\tcase SECCOMP_RET_ALLOW:",
            "\t\t/*",
            "\t\t * Note that the \"match\" filter will always be NULL for",
            "\t\t * this action since SECCOMP_RET_ALLOW is the starting",
            "\t\t * state in seccomp_run_filters().",
            "\t\t */",
            "\t\treturn 0;",
            "",
            "\tcase SECCOMP_RET_KILL_THREAD:",
            "\tcase SECCOMP_RET_KILL_PROCESS:",
            "\tdefault:",
            "\t\tcurrent->seccomp.mode = SECCOMP_MODE_DEAD;",
            "\t\tseccomp_log(this_syscall, SIGSYS, action, true);",
            "\t\t/* Dump core only if this is the last remaining thread. */",
            "\t\tif (action != SECCOMP_RET_KILL_THREAD ||",
            "\t\t    (atomic_read(&current->signal->live) == 1)) {",
            "\t\t\t/* Show the original registers in the dump. */",
            "\t\t\tsyscall_rollback(current, current_pt_regs());",
            "\t\t\t/* Trigger a coredump with SIGSYS */",
            "\t\t\tforce_sig_seccomp(this_syscall, data, true);",
            "\t\t} else {",
            "\t\t\tdo_exit(SIGSYS);",
            "\t\t}",
            "\t\treturn -1; /* skip the syscall go directly to signal handling */",
            "\t}",
            "",
            "\tunreachable();",
            "",
            "skip:",
            "\tseccomp_log(this_syscall, 0, action, match ? match->log : false);",
            "\treturn -1;",
            "}"
          ],
          "function_name": "__seccomp_filter",
          "description": "核心过滤器执行函数，根据BPF过滤规则决定系统调用处理方式，处理TRACE/LOG/USER_NOTIF等特殊动作",
          "similarity": 0.49711835384368896
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/seccomp.c",
          "start_line": 179,
          "end_line": 286,
          "content": [
            "static inline bool seccomp_cache_check_allow(const struct seccomp_filter *sfilter,",
            "\t\t\t\t\t     const struct seccomp_data *sd)",
            "{",
            "\treturn false;",
            "}",
            "static inline void seccomp_cache_prepare(struct seccomp_filter *sfilter)",
            "{",
            "}",
            "static void populate_seccomp_data(struct seccomp_data *sd)",
            "{",
            "\t/*",
            "\t * Instead of using current_pt_reg(), we're already doing the work",
            "\t * to safely fetch \"current\", so just use \"task\" everywhere below.",
            "\t */",
            "\tstruct task_struct *task = current;",
            "\tstruct pt_regs *regs = task_pt_regs(task);",
            "\tunsigned long args[6];",
            "",
            "\tsd->nr = syscall_get_nr(task, regs);",
            "\tsd->arch = syscall_get_arch(task);",
            "\tsyscall_get_arguments(task, regs, args);",
            "\tsd->args[0] = args[0];",
            "\tsd->args[1] = args[1];",
            "\tsd->args[2] = args[2];",
            "\tsd->args[3] = args[3];",
            "\tsd->args[4] = args[4];",
            "\tsd->args[5] = args[5];",
            "\tsd->instruction_pointer = KSTK_EIP(task);",
            "}",
            "static int seccomp_check_filter(struct sock_filter *filter, unsigned int flen)",
            "{",
            "\tint pc;",
            "\tfor (pc = 0; pc < flen; pc++) {",
            "\t\tstruct sock_filter *ftest = &filter[pc];",
            "\t\tu16 code = ftest->code;",
            "\t\tu32 k = ftest->k;",
            "",
            "\t\tswitch (code) {",
            "\t\tcase BPF_LD | BPF_W | BPF_ABS:",
            "\t\t\tftest->code = BPF_LDX | BPF_W | BPF_ABS;",
            "\t\t\t/* 32-bit aligned and not out of bounds. */",
            "\t\t\tif (k >= sizeof(struct seccomp_data) || k & 3)",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\tcontinue;",
            "\t\tcase BPF_LD | BPF_W | BPF_LEN:",
            "\t\t\tftest->code = BPF_LD | BPF_IMM;",
            "\t\t\tftest->k = sizeof(struct seccomp_data);",
            "\t\t\tcontinue;",
            "\t\tcase BPF_LDX | BPF_W | BPF_LEN:",
            "\t\t\tftest->code = BPF_LDX | BPF_IMM;",
            "\t\t\tftest->k = sizeof(struct seccomp_data);",
            "\t\t\tcontinue;",
            "\t\t/* Explicitly include allowed calls. */",
            "\t\tcase BPF_RET | BPF_K:",
            "\t\tcase BPF_RET | BPF_A:",
            "\t\tcase BPF_ALU | BPF_ADD | BPF_K:",
            "\t\tcase BPF_ALU | BPF_ADD | BPF_X:",
            "\t\tcase BPF_ALU | BPF_SUB | BPF_K:",
            "\t\tcase BPF_ALU | BPF_SUB | BPF_X:",
            "\t\tcase BPF_ALU | BPF_MUL | BPF_K:",
            "\t\tcase BPF_ALU | BPF_MUL | BPF_X:",
            "\t\tcase BPF_ALU | BPF_DIV | BPF_K:",
            "\t\tcase BPF_ALU | BPF_DIV | BPF_X:",
            "\t\tcase BPF_ALU | BPF_AND | BPF_K:",
            "\t\tcase BPF_ALU | BPF_AND | BPF_X:",
            "\t\tcase BPF_ALU | BPF_OR | BPF_K:",
            "\t\tcase BPF_ALU | BPF_OR | BPF_X:",
            "\t\tcase BPF_ALU | BPF_XOR | BPF_K:",
            "\t\tcase BPF_ALU | BPF_XOR | BPF_X:",
            "\t\tcase BPF_ALU | BPF_LSH | BPF_K:",
            "\t\tcase BPF_ALU | BPF_LSH | BPF_X:",
            "\t\tcase BPF_ALU | BPF_RSH | BPF_K:",
            "\t\tcase BPF_ALU | BPF_RSH | BPF_X:",
            "\t\tcase BPF_ALU | BPF_NEG:",
            "\t\tcase BPF_LD | BPF_IMM:",
            "\t\tcase BPF_LDX | BPF_IMM:",
            "\t\tcase BPF_MISC | BPF_TAX:",
            "\t\tcase BPF_MISC | BPF_TXA:",
            "\t\tcase BPF_LD | BPF_MEM:",
            "\t\tcase BPF_LDX | BPF_MEM:",
            "\t\tcase BPF_ST:",
            "\t\tcase BPF_STX:",
            "\t\tcase BPF_JMP | BPF_JA:",
            "\t\tcase BPF_JMP | BPF_JEQ | BPF_K:",
            "\t\tcase BPF_JMP | BPF_JEQ | BPF_X:",
            "\t\tcase BPF_JMP | BPF_JGE | BPF_K:",
            "\t\tcase BPF_JMP | BPF_JGE | BPF_X:",
            "\t\tcase BPF_JMP | BPF_JGT | BPF_K:",
            "\t\tcase BPF_JMP | BPF_JGT | BPF_X:",
            "\t\tcase BPF_JMP | BPF_JSET | BPF_K:",
            "\t\tcase BPF_JMP | BPF_JSET | BPF_X:",
            "\t\t\tcontinue;",
            "\t\tdefault:",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}",
            "static inline bool seccomp_cache_check_allow_bitmap(const void *bitmap,",
            "\t\t\t\t\t\t    size_t bitmap_size,",
            "\t\t\t\t\t\t    int syscall_nr)",
            "{",
            "\tif (unlikely(syscall_nr < 0 || syscall_nr >= bitmap_size))",
            "\t\treturn false;",
            "\tsyscall_nr = array_index_nospec(syscall_nr, bitmap_size);",
            "",
            "\treturn test_bit(syscall_nr, bitmap);",
            "}"
          ],
          "function_name": "seccomp_cache_check_allow, seccomp_cache_prepare, populate_seccomp_data, seccomp_check_filter, seccomp_cache_check_allow_bitmap",
          "description": "实现seccomp过滤器校验逻辑，包括填充系统调用数据的populate_seccomp_data函数、验证BPF指令有效性的seccomp_check_filter函数，以及基于位图的syscall允许检查的seccomp_cache_check_allow_bitmap函数。",
          "similarity": 0.48406440019607544
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/seccomp.c",
          "start_line": 811,
          "end_line": 914,
          "content": [
            "static void seccomp_cache_prepare_bitmap(struct seccomp_filter *sfilter,",
            "\t\t\t\t\t void *bitmap, const void *bitmap_prev,",
            "\t\t\t\t\t size_t bitmap_size, int arch)",
            "{",
            "\tstruct sock_fprog_kern *fprog = sfilter->prog->orig_prog;",
            "\tstruct seccomp_data sd;",
            "\tint nr;",
            "",
            "\tif (bitmap_prev) {",
            "\t\t/* The new filter must be as restrictive as the last. */",
            "\t\tbitmap_copy(bitmap, bitmap_prev, bitmap_size);",
            "\t} else {",
            "\t\t/* Before any filters, all syscalls are always allowed. */",
            "\t\tbitmap_fill(bitmap, bitmap_size);",
            "\t}",
            "",
            "\tfor (nr = 0; nr < bitmap_size; nr++) {",
            "\t\t/* No bitmap change: not a cacheable action. */",
            "\t\tif (!test_bit(nr, bitmap))",
            "\t\t\tcontinue;",
            "",
            "\t\tsd.nr = nr;",
            "\t\tsd.arch = arch;",
            "",
            "\t\t/* No bitmap change: continue to always allow. */",
            "\t\tif (seccomp_is_const_allow(fprog, &sd))",
            "\t\t\tcontinue;",
            "",
            "\t\t/*",
            "\t\t * Not a cacheable action: always run filters.",
            "\t\t * atomic clear_bit() not needed, filter not visible yet.",
            "\t\t */",
            "\t\t__clear_bit(nr, bitmap);",
            "\t}",
            "}",
            "static void seccomp_cache_prepare(struct seccomp_filter *sfilter)",
            "{",
            "\tstruct action_cache *cache = &sfilter->cache;",
            "\tconst struct action_cache *cache_prev =",
            "\t\tsfilter->prev ? &sfilter->prev->cache : NULL;",
            "",
            "\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_native,",
            "\t\t\t\t     cache_prev ? cache_prev->allow_native : NULL,",
            "\t\t\t\t     SECCOMP_ARCH_NATIVE_NR,",
            "\t\t\t\t     SECCOMP_ARCH_NATIVE);",
            "",
            "#ifdef SECCOMP_ARCH_COMPAT",
            "\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_compat,",
            "\t\t\t\t     cache_prev ? cache_prev->allow_compat : NULL,",
            "\t\t\t\t     SECCOMP_ARCH_COMPAT_NR,",
            "\t\t\t\t     SECCOMP_ARCH_COMPAT);",
            "#endif /* SECCOMP_ARCH_COMPAT */",
            "}",
            "static long seccomp_attach_filter(unsigned int flags,",
            "\t\t\t\t  struct seccomp_filter *filter)",
            "{",
            "\tunsigned long total_insns;",
            "\tstruct seccomp_filter *walker;",
            "",
            "\tassert_spin_locked(&current->sighand->siglock);",
            "",
            "\t/* Validate resulting filter length. */",
            "\ttotal_insns = filter->prog->len;",
            "\tfor (walker = current->seccomp.filter; walker; walker = walker->prev)",
            "\t\ttotal_insns += walker->prog->len + 4;  /* 4 instr penalty */",
            "\tif (total_insns > MAX_INSNS_PER_PATH)",
            "\t\treturn -ENOMEM;",
            "",
            "\t/* If thread sync has been requested, check that it is possible. */",
            "\tif (flags & SECCOMP_FILTER_FLAG_TSYNC) {",
            "\t\tint ret;",
            "",
            "\t\tret = seccomp_can_sync_threads();",
            "\t\tif (ret) {",
            "\t\t\tif (flags & SECCOMP_FILTER_FLAG_TSYNC_ESRCH)",
            "\t\t\t\treturn -ESRCH;",
            "\t\t\telse",
            "\t\t\t\treturn ret;",
            "\t\t}",
            "\t}",
            "",
            "\t/* Set log flag, if present. */",
            "\tif (flags & SECCOMP_FILTER_FLAG_LOG)",
            "\t\tfilter->log = true;",
            "",
            "\t/* Set wait killable flag, if present. */",
            "\tif (flags & SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV)",
            "\t\tfilter->wait_killable_recv = true;",
            "",
            "\t/*",
            "\t * If there is an existing filter, make it the prev and don't drop its",
            "\t * task reference.",
            "\t */",
            "\tfilter->prev = current->seccomp.filter;",
            "\tseccomp_cache_prepare(filter);",
            "\tcurrent->seccomp.filter = filter;",
            "\tatomic_inc(&current->seccomp.filter_count);",
            "",
            "\t/* Now that the new filter is in place, synchronize to all threads. */",
            "\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)",
            "\t\tseccomp_sync_threads(flags);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "seccomp_cache_prepare_bitmap, seccomp_cache_prepare, seccomp_attach_filter",
          "description": "实现过滤器预处理逻辑，seccomp_cache_prepare_bitmap构建允许位图，seccomp_cache_prepare初始化缓存，seccomp_attach_filter附加新过滤器并进行参数验证及线程同步。",
          "similarity": 0.46402496099472046
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/seccomp.c",
          "start_line": 523,
          "end_line": 695,
          "content": [
            "static inline void seccomp_filter_free(struct seccomp_filter *filter)",
            "{",
            "\tif (filter) {",
            "\t\tbpf_prog_destroy(filter->prog);",
            "\t\tkfree(filter);",
            "\t}",
            "}",
            "static void __seccomp_filter_orphan(struct seccomp_filter *orig)",
            "{",
            "\twhile (orig && refcount_dec_and_test(&orig->users)) {",
            "\t\tif (waitqueue_active(&orig->wqh))",
            "\t\t\twake_up_poll(&orig->wqh, EPOLLHUP);",
            "\t\torig = orig->prev;",
            "\t}",
            "}",
            "static void __put_seccomp_filter(struct seccomp_filter *orig)",
            "{",
            "\t/* Clean up single-reference branches iteratively. */",
            "\twhile (orig && refcount_dec_and_test(&orig->refs)) {",
            "\t\tstruct seccomp_filter *freeme = orig;",
            "\t\torig = orig->prev;",
            "\t\tseccomp_filter_free(freeme);",
            "\t}",
            "}",
            "static void __seccomp_filter_release(struct seccomp_filter *orig)",
            "{",
            "\t/* Notify about any unused filters in the task's former filter tree. */",
            "\t__seccomp_filter_orphan(orig);",
            "\t/* Finally drop all references to the task's former tree. */",
            "\t__put_seccomp_filter(orig);",
            "}",
            "void seccomp_filter_release(struct task_struct *tsk)",
            "{",
            "\tstruct seccomp_filter *orig = tsk->seccomp.filter;",
            "",
            "\t/* We are effectively holding the siglock by not having any sighand. */",
            "\tWARN_ON(tsk->sighand != NULL);",
            "",
            "\t/* Detach task from its filter tree. */",
            "\ttsk->seccomp.filter = NULL;",
            "\t__seccomp_filter_release(orig);",
            "}",
            "static inline void seccomp_sync_threads(unsigned long flags)",
            "{",
            "\tstruct task_struct *thread, *caller;",
            "",
            "\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));",
            "\tassert_spin_locked(&current->sighand->siglock);",
            "",
            "\t/* Synchronize all threads. */",
            "\tcaller = current;",
            "\tfor_each_thread(caller, thread) {",
            "\t\t/* Skip current, since it needs no changes. */",
            "\t\tif (thread == caller)",
            "\t\t\tcontinue;",
            "",
            "\t\t/* Get a task reference for the new leaf node. */",
            "\t\tget_seccomp_filter(caller);",
            "",
            "\t\t/*",
            "\t\t * Drop the task reference to the shared ancestor since",
            "\t\t * current's path will hold a reference.  (This also",
            "\t\t * allows a put before the assignment.)",
            "\t\t */",
            "\t\t__seccomp_filter_release(thread->seccomp.filter);",
            "",
            "\t\t/* Make our new filter tree visible. */",
            "\t\tsmp_store_release(&thread->seccomp.filter,",
            "\t\t\t\t  caller->seccomp.filter);",
            "\t\tatomic_set(&thread->seccomp.filter_count,",
            "\t\t\t   atomic_read(&caller->seccomp.filter_count));",
            "",
            "\t\t/*",
            "\t\t * Don't let an unprivileged task work around",
            "\t\t * the no_new_privs restriction by creating",
            "\t\t * a thread that sets it up, enters seccomp,",
            "\t\t * then dies.",
            "\t\t */",
            "\t\tif (task_no_new_privs(caller))",
            "\t\t\ttask_set_no_new_privs(thread);",
            "",
            "\t\t/*",
            "\t\t * Opt the other thread into seccomp if needed.",
            "\t\t * As threads are considered to be trust-realm",
            "\t\t * equivalent (see ptrace_may_access), it is safe to",
            "\t\t * allow one thread to transition the other.",
            "\t\t */",
            "\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED)",
            "\t\t\tseccomp_assign_mode(thread, SECCOMP_MODE_FILTER,",
            "\t\t\t\t\t    flags);",
            "\t}",
            "}",
            "static bool seccomp_is_const_allow(struct sock_fprog_kern *fprog,",
            "\t\t\t\t   struct seccomp_data *sd)",
            "{",
            "\tunsigned int reg_value = 0;",
            "\tunsigned int pc;",
            "\tbool op_res;",
            "",
            "\tif (WARN_ON_ONCE(!fprog))",
            "\t\treturn false;",
            "",
            "\t/* Our single exception to filtering. */",
            "#ifdef __NR_uretprobe",
            "#ifdef SECCOMP_ARCH_COMPAT",
            "\tif (sd->arch == SECCOMP_ARCH_NATIVE)",
            "#endif",
            "\t\tif (sd->nr == __NR_uretprobe)",
            "\t\t\treturn true;",
            "#endif",
            "",
            "\tfor (pc = 0; pc < fprog->len; pc++) {",
            "\t\tstruct sock_filter *insn = &fprog->filter[pc];",
            "\t\tu16 code = insn->code;",
            "\t\tu32 k = insn->k;",
            "",
            "\t\tswitch (code) {",
            "\t\tcase BPF_LD | BPF_W | BPF_ABS:",
            "\t\t\tswitch (k) {",
            "\t\t\tcase offsetof(struct seccomp_data, nr):",
            "\t\t\t\treg_value = sd->nr;",
            "\t\t\t\tbreak;",
            "\t\t\tcase offsetof(struct seccomp_data, arch):",
            "\t\t\t\treg_value = sd->arch;",
            "\t\t\t\tbreak;",
            "\t\t\tdefault:",
            "\t\t\t\t/* can't optimize (non-constant value load) */",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\tcase BPF_RET | BPF_K:",
            "\t\t\t/* reached return with constant values only, check allow */",
            "\t\t\treturn k == SECCOMP_RET_ALLOW;",
            "\t\tcase BPF_JMP | BPF_JA:",
            "\t\t\tpc += insn->k;",
            "\t\t\tbreak;",
            "\t\tcase BPF_JMP | BPF_JEQ | BPF_K:",
            "\t\tcase BPF_JMP | BPF_JGE | BPF_K:",
            "\t\tcase BPF_JMP | BPF_JGT | BPF_K:",
            "\t\tcase BPF_JMP | BPF_JSET | BPF_K:",
            "\t\t\tswitch (BPF_OP(code)) {",
            "\t\t\tcase BPF_JEQ:",
            "\t\t\t\top_res = reg_value == k;",
            "\t\t\t\tbreak;",
            "\t\t\tcase BPF_JGE:",
            "\t\t\t\top_res = reg_value >= k;",
            "\t\t\t\tbreak;",
            "\t\t\tcase BPF_JGT:",
            "\t\t\t\top_res = reg_value > k;",
            "\t\t\t\tbreak;",
            "\t\t\tcase BPF_JSET:",
            "\t\t\t\top_res = !!(reg_value & k);",
            "\t\t\t\tbreak;",
            "\t\t\tdefault:",
            "\t\t\t\t/* can't optimize (unknown jump) */",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "",
            "\t\t\tpc += op_res ? insn->jt : insn->jf;",
            "\t\t\tbreak;",
            "\t\tcase BPF_ALU | BPF_AND | BPF_K:",
            "\t\t\treg_value &= k;",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\t/* can't optimize (unknown insn) */",
            "\t\t\treturn false;",
            "\t\t}",
            "\t}",
            "",
            "\t/* ran off the end of the filter?! */",
            "\tWARN_ON(1);",
            "\treturn false;",
            "}"
          ],
          "function_name": "seccomp_filter_free, __seccomp_filter_orphan, __put_seccomp_filter, __seccomp_filter_release, seccomp_filter_release, seccomp_sync_threads, seccomp_is_const_allow",
          "description": "实现过滤器生命周期管理，seccomp_filter_free释放资源，__seccomp_filter_orphan/__put_seccomp_filter处理引用计数，seccomp_filter_release完成任务过滤器释放，seccomp_sync_threads同步线程安全配置。",
          "similarity": 0.458362340927124
        },
        {
          "chunk_id": 14,
          "file_path": "kernel/seccomp.c",
          "start_line": 2367,
          "end_line": 2499,
          "content": [
            "static int write_actions_logged(struct ctl_table *ro_table, void *buffer,",
            "\t\t\t\tsize_t *lenp, loff_t *ppos, u32 *actions_logged)",
            "{",
            "\tchar names[sizeof(seccomp_actions_avail)];",
            "\tstruct ctl_table table;",
            "\tint ret;",
            "",
            "\tif (!capable(CAP_SYS_ADMIN))",
            "\t\treturn -EPERM;",
            "",
            "\tmemset(names, 0, sizeof(names));",
            "",
            "\ttable = *ro_table;",
            "\ttable.data = names;",
            "\ttable.maxlen = sizeof(names);",
            "\tret = proc_dostring(&table, 1, buffer, lenp, ppos);",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\tif (!seccomp_actions_logged_from_names(actions_logged, table.data))",
            "\t\treturn -EINVAL;",
            "",
            "\tif (*actions_logged & SECCOMP_LOG_ALLOW)",
            "\t\treturn -EINVAL;",
            "",
            "\tseccomp_actions_logged = *actions_logged;",
            "\treturn 0;",
            "}",
            "static void audit_actions_logged(u32 actions_logged, u32 old_actions_logged,",
            "\t\t\t\t int ret)",
            "{",
            "\tchar names[sizeof(seccomp_actions_avail)];",
            "\tchar old_names[sizeof(seccomp_actions_avail)];",
            "\tconst char *new = names;",
            "\tconst char *old = old_names;",
            "",
            "\tif (!audit_enabled)",
            "\t\treturn;",
            "",
            "\tmemset(names, 0, sizeof(names));",
            "\tmemset(old_names, 0, sizeof(old_names));",
            "",
            "\tif (ret)",
            "\t\tnew = \"?\";",
            "\telse if (!actions_logged)",
            "\t\tnew = \"(none)\";",
            "\telse if (!seccomp_names_from_actions_logged(names, sizeof(names),",
            "\t\t\t\t\t\t    actions_logged, \",\"))",
            "\t\tnew = \"?\";",
            "",
            "\tif (!old_actions_logged)",
            "\t\told = \"(none)\";",
            "\telse if (!seccomp_names_from_actions_logged(old_names,",
            "\t\t\t\t\t\t    sizeof(old_names),",
            "\t\t\t\t\t\t    old_actions_logged, \",\"))",
            "\t\told = \"?\";",
            "",
            "\treturn audit_seccomp_actions_logged(new, old, !ret);",
            "}",
            "static int seccomp_actions_logged_handler(struct ctl_table *ro_table, int write,",
            "\t\t\t\t\t  void *buffer, size_t *lenp,",
            "\t\t\t\t\t  loff_t *ppos)",
            "{",
            "\tint ret;",
            "",
            "\tif (write) {",
            "\t\tu32 actions_logged = 0;",
            "\t\tu32 old_actions_logged = seccomp_actions_logged;",
            "",
            "\t\tret = write_actions_logged(ro_table, buffer, lenp, ppos,",
            "\t\t\t\t\t   &actions_logged);",
            "\t\taudit_actions_logged(actions_logged, old_actions_logged, ret);",
            "\t} else",
            "\t\tret = read_actions_logged(ro_table, buffer, lenp, ppos);",
            "",
            "\treturn ret;",
            "}",
            "static int __init seccomp_sysctl_init(void)",
            "{",
            "\tregister_sysctl_init(\"kernel/seccomp\", seccomp_sysctl_table);",
            "\treturn 0;",
            "}",
            "static void proc_pid_seccomp_cache_arch(struct seq_file *m, const char *name,",
            "\t\t\t\t\tconst void *bitmap, size_t bitmap_size)",
            "{",
            "\tint nr;",
            "",
            "\tfor (nr = 0; nr < bitmap_size; nr++) {",
            "\t\tbool cached = test_bit(nr, bitmap);",
            "\t\tchar *status = cached ? \"ALLOW\" : \"FILTER\";",
            "",
            "\t\tseq_printf(m, \"%s %d %s\\n\", name, nr, status);",
            "\t}",
            "}",
            "int proc_pid_seccomp_cache(struct seq_file *m, struct pid_namespace *ns,",
            "\t\t\t   struct pid *pid, struct task_struct *task)",
            "{",
            "\tstruct seccomp_filter *f;",
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * We don't want some sandboxed process to know what their seccomp",
            "\t * filters consist of.",
            "\t */",
            "\tif (!file_ns_capable(m->file, &init_user_ns, CAP_SYS_ADMIN))",
            "\t\treturn -EACCES;",
            "",
            "\tif (!lock_task_sighand(task, &flags))",
            "\t\treturn -ESRCH;",
            "",
            "\tf = READ_ONCE(task->seccomp.filter);",
            "\tif (!f) {",
            "\t\tunlock_task_sighand(task, &flags);",
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/* prevent filter from being freed while we are printing it */",
            "\t__get_seccomp_filter(f);",
            "\tunlock_task_sighand(task, &flags);",
            "",
            "\tproc_pid_seccomp_cache_arch(m, SECCOMP_ARCH_NATIVE_NAME,",
            "\t\t\t\t    f->cache.allow_native,",
            "\t\t\t\t    SECCOMP_ARCH_NATIVE_NR);",
            "",
            "#ifdef SECCOMP_ARCH_COMPAT",
            "\tproc_pid_seccomp_cache_arch(m, SECCOMP_ARCH_COMPAT_NAME,",
            "\t\t\t\t    f->cache.allow_compat,",
            "\t\t\t\t    SECCOMP_ARCH_COMPAT_NR);",
            "#endif /* SECCOMP_ARCH_COMPAT */",
            "",
            "\t__put_seccomp_filter(f);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "write_actions_logged, audit_actions_logged, seccomp_actions_logged_handler, seccomp_sysctl_init, proc_pid_seccomp_cache_arch, proc_pid_seccomp_cache",
          "description": "该代码段实现了SECCOMP动作日志配置的 sysctl 接口及审计功能，支持通过 /proc/sys/kernel/seccomp 配置允许的动作类型，并在修改时触发审计日志记录。  \n`write_actions_logged` 处理对动作白名单的写入操作，验证输入有效性并更新全局策略；`audit_actions_logged` 将动作位掩码转换为可读字符串以供审计追踪。  \n`seccomp_actions_logged_handler` 作为 sysctl 处理函数协调配置写入与审计逻辑，`proc_pid_seccomp_cache*` 系列函数用于序列化进程级 SECCOMP 过滤器缓存状态（需 CAP_SYS_ADMIN 权限），但 `read_actions_logged` 函数定义缺失导致上下文不完整。",
          "similarity": 0.4533381462097168
        }
      ]
    }
  ]
}