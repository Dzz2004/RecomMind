{
  "query": "日志文件系统",
  "timestamp": "2025-12-26 00:24:53",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/log.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:15:45\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\log.c`\n\n---\n\n# bpf/log.c 技术文档\n\n## 1. 文件概述\n\n`bpf/log.c` 是 Linux 内核 BPF（Berkeley Packet Filter）子系统中负责日志记录的核心实现文件。该文件为 BPF 验证器（verifier）提供灵活、高效的日志输出机制，支持将验证过程中的诊断信息输出到用户空间缓冲区或内核日志（`pr_err`）。日志系统支持两种模式：**固定模式**（`BPF_LOG_FIXED`）和**循环缓冲模式**（默认），并能处理大容量日志的截断、回绕和最终整理，确保用户获得连续、有效的验证日志。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`bpf_verifier_log_attr_valid()`**  \n  验证 `bpf_verifier_log` 结构体的属性是否合法，包括用户缓冲区指针与大小的一致性、日志级别有效性等。\n\n- **`bpf_vlog_init()`**  \n  初始化 `bpf_verifier_log` 结构体，设置日志级别、用户缓冲区指针和大小，并进行合法性校验。\n\n- **`bpf_verifier_vlog()`**  \n  核心日志写入函数，接收格式化字符串和可变参数列表，根据日志模式（固定/循环）将内容写入内核临时缓冲区并复制到用户空间，或直接输出到内核日志。\n\n- **`bpf_vlog_reset()`**  \n  重置日志写入位置（用于回溯验证路径时清理无效日志），并更新用户缓冲区对应位置为 `\\0`。\n\n- **`bpf_vlog_finalize()`**  \n  在验证结束时整理日志内容：若使用循环缓冲且发生回绕，则通过三次反转算法将日志内容原地旋转为从缓冲区开头开始的连续字符串。\n\n- **`bpf_vlog_reverse_kbuf()` / `bpf_vlog_reverse_ubuf()`**  \n  辅助函数，分别用于反转内核临时缓冲区和用户空间日志缓冲区的指定区段，支撑 `bpf_vlog_finalize()` 中的原地旋转算法。\n\n### 关键数据结构\n\n- **`struct bpf_verifier_log`**（定义在 `bpf_verifier.h` 中）  \n  包含日志级别（`level`）、用户缓冲区指针（`ubuf`）、缓冲区总大小（`len_total`）、当前写入结束位置（`end_pos`）、循环缓冲起始位置（`start_pos`）、最大日志长度（`len_max`）以及内核临时缓冲区（`kbuf`）等字段。\n\n## 3. 关键实现\n\n### 日志模式\n\n- **固定模式（`BPF_LOG_FIXED`）**：日志从缓冲区开头顺序写入，超出部分被丢弃。适用于需要完整前缀日志的场景。\n- **循环缓冲模式（默认）**：当日志超出缓冲区大小时，覆盖最早写入的内容，始终保持最新的日志。适用于关注最新错误信息的场景。\n\n### 日志写入流程\n\n1. 使用 `vscnprintf` 将格式化日志写入内核临时缓冲区 `kbuf`（大小为 `BPF_VERIFIER_TMP_LOG_SIZE`）。\n2. 若日志级别为 `BPF_LOG_KERNEL`，直接通过 `pr_err` 输出到内核日志。\n3. 否则，根据日志模式：\n   - **固定模式**：计算可写入用户缓冲区的字节数，调用 `copy_to_user`。\n   - **循环模式**：计算写入位置（可能回绕），分一或两个片段调用 `copy_to_user`。\n\n### 日志最终整理（`bpf_vlog_finalize`）\n\n当使用循环缓冲且日志发生回绕（`start_pos != 0`）时，需将日志整理为从缓冲区开头开始的连续字符串。采用**三次反转原地旋转算法**：\n1. 反转整个缓冲区；\n2. 反转前 `sublen` 字节（原尾部）；\n3. 反转后 `len_total - sublen` 字节（原头部）。  \n该算法避免了大内存分配，仅使用固定大小的内核临时缓冲区 `kbuf` 分块处理用户空间内存。\n\n### 安全与健壮性\n\n- 所有 `copy_to_user`/`copy_from_user` 操作均检查返回值，失败时置空 `ubuf` 指针以禁用后续写入。\n- 对日志长度进行溢出检查（`len_total > UINT_MAX >> 2`）。\n- 使用 `WARN_ON_ONCE` 检测非法重置位置。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<uapi/linux/btf.h>`：BTF（BPF Type Format）相关定义。\n  - `<linux/bpf.h>`：BPF 核心数据结构和常量（如 `BPF_LOG_MASK`、`BPF_LOG_KERNEL`、`BPF_LOG_FIXED`）。\n  - `<linux/bpf_verifier.h>`：`struct bpf_verifier_log` 定义及辅助宏（如 `bpf_verifier_log_needed`）。\n  - `<linux/math64.h>`：提供 `div_u64_rem` 等 64 位除法函数。\n- **内核子系统**：\n  - **BPF 验证器**：作为验证器的输出后端，由 `bpf_verifier.c` 调用。\n  - **用户空间交互**：通过 `copy_to_user`/`copy_from_user` 与用户态 BPF 加载程序（如 `libbpf`）通信。\n\n## 5. 使用场景\n\n- **BPF 程序加载验证**：当用户通过 `bpf(BPF_PROG_LOAD, ...)` 系统调用加载 BPF 程序时，内核验证器在检查程序安全性过程中调用本文件的日志函数，将详细错误或警告信息写入用户提供的日志缓冲区。\n- **调试与诊断**：开发者通过设置 `log_level` 和提供足够大的 `log_buf`，获取验证失败的具体原因（如无效指针访问、未初始化寄存器等）。\n- **内核日志输出**：当 `log_level` 设为 `BPF_LOG_KERNEL` 时，日志直接输出到内核日志（`dmesg`），用于内核开发者调试 BPF 验证器本身。\n- **资源受限环境**：循环缓冲模式允许在有限缓冲区大小下捕获最新的验证日志，适用于嵌入式或内存受限系统。",
      "similarity": 0.5891063809394836,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/log.c",
          "start_line": 15,
          "end_line": 143,
          "content": [
            "static bool bpf_verifier_log_attr_valid(const struct bpf_verifier_log *log)",
            "{",
            "\t/* ubuf and len_total should both be specified (or not) together */",
            "\tif (!!log->ubuf != !!log->len_total)",
            "\t\treturn false;",
            "\t/* log buf without log_level is meaningless */",
            "\tif (log->ubuf && log->level == 0)",
            "\t\treturn false;",
            "\tif (log->level & ~BPF_LOG_MASK)",
            "\t\treturn false;",
            "\tif (log->len_total > UINT_MAX >> 2)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "int bpf_vlog_init(struct bpf_verifier_log *log, u32 log_level,",
            "\t\t  char __user *log_buf, u32 log_size)",
            "{",
            "\tlog->level = log_level;",
            "\tlog->ubuf = log_buf;",
            "\tlog->len_total = log_size;",
            "",
            "\t/* log attributes have to be sane */",
            "\tif (!bpf_verifier_log_attr_valid(log))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static void bpf_vlog_update_len_max(struct bpf_verifier_log *log, u32 add_len)",
            "{",
            "\t/* add_len includes terminal \\0, so no need for +1. */",
            "\tu64 len = log->end_pos + add_len;",
            "",
            "\t/* log->len_max could be larger than our current len due to",
            "\t * bpf_vlog_reset() calls, so we maintain the max of any length at any",
            "\t * previous point",
            "\t */",
            "\tif (len > UINT_MAX)",
            "\t\tlog->len_max = UINT_MAX;",
            "\telse if (len > log->len_max)",
            "\t\tlog->len_max = len;",
            "}",
            "void bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,",
            "\t\t       va_list args)",
            "{",
            "\tu64 cur_pos;",
            "\tu32 new_n, n;",
            "",
            "\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);",
            "",
            "\tif (log->level == BPF_LOG_KERNEL) {",
            "\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';",
            "",
            "\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tn += 1; /* include terminating zero */",
            "\tbpf_vlog_update_len_max(log, n);",
            "",
            "\tif (log->level & BPF_LOG_FIXED) {",
            "\t\t/* check if we have at least something to put into user buf */",
            "\t\tnew_n = 0;",
            "\t\tif (log->end_pos < log->len_total) {",
            "\t\t\tnew_n = min_t(u32, log->len_total - log->end_pos, n);",
            "\t\t\tlog->kbuf[new_n - 1] = '\\0';",
            "\t\t}",
            "",
            "\t\tcur_pos = log->end_pos;",
            "\t\tlog->end_pos += n - 1; /* don't count terminating '\\0' */",
            "",
            "\t\tif (log->ubuf && new_n &&",
            "\t\t    copy_to_user(log->ubuf + cur_pos, log->kbuf, new_n))",
            "\t\t\tgoto fail;",
            "\t} else {",
            "\t\tu64 new_end, new_start;",
            "\t\tu32 buf_start, buf_end, new_n;",
            "",
            "\t\tnew_end = log->end_pos + n;",
            "\t\tif (new_end - log->start_pos >= log->len_total)",
            "\t\t\tnew_start = new_end - log->len_total;",
            "\t\telse",
            "\t\t\tnew_start = log->start_pos;",
            "",
            "\t\tlog->start_pos = new_start;",
            "\t\tlog->end_pos = new_end - 1; /* don't count terminating '\\0' */",
            "",
            "\t\tif (!log->ubuf)",
            "\t\t\treturn;",
            "",
            "\t\tnew_n = min(n, log->len_total);",
            "\t\tcur_pos = new_end - new_n;",
            "\t\tdiv_u64_rem(cur_pos, log->len_total, &buf_start);",
            "\t\tdiv_u64_rem(new_end, log->len_total, &buf_end);",
            "\t\t/* new_end and buf_end are exclusive indices, so if buf_end is",
            "\t\t * exactly zero, then it actually points right to the end of",
            "\t\t * ubuf and there is no wrap around",
            "\t\t */",
            "\t\tif (buf_end == 0)",
            "\t\t\tbuf_end = log->len_total;",
            "",
            "\t\t/* if buf_start > buf_end, we wrapped around;",
            "\t\t * if buf_start == buf_end, then we fill ubuf completely; we",
            "\t\t * can't have buf_start == buf_end to mean that there is",
            "\t\t * nothing to write, because we always write at least",
            "\t\t * something, even if terminal '\\0'",
            "\t\t */",
            "\t\tif (buf_start < buf_end) {",
            "\t\t\t/* message fits within contiguous chunk of ubuf */",
            "\t\t\tif (copy_to_user(log->ubuf + buf_start,",
            "\t\t\t\t\t log->kbuf + n - new_n,",
            "\t\t\t\t\t buf_end - buf_start))",
            "\t\t\t\tgoto fail;",
            "\t\t} else {",
            "\t\t\t/* message wraps around the end of ubuf, copy in two chunks */",
            "\t\t\tif (copy_to_user(log->ubuf + buf_start,",
            "\t\t\t\t\t log->kbuf + n - new_n,",
            "\t\t\t\t\t log->len_total - buf_start))",
            "\t\t\t\tgoto fail;",
            "\t\t\tif (copy_to_user(log->ubuf,",
            "\t\t\t\t\t log->kbuf + n - buf_end,",
            "\t\t\t\t\t buf_end))",
            "\t\t\t\tgoto fail;",
            "\t\t}",
            "\t}",
            "",
            "\treturn;",
            "fail:",
            "\tlog->ubuf = NULL;",
            "}"
          ],
          "function_name": "bpf_verifier_log_attr_valid, bpf_vlog_init, bpf_vlog_update_len_max, bpf_verifier_vlog",
          "description": "实现日志属性校验、初始化、长度更新及日志写入逻辑，负责管理日志缓冲区的有效性和数据写入操作。",
          "similarity": 0.6798018217086792
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/log.c",
          "start_line": 148,
          "end_line": 294,
          "content": [
            "void bpf_vlog_reset(struct bpf_verifier_log *log, u64 new_pos)",
            "{",
            "\tchar zero = 0;",
            "\tu32 pos;",
            "",
            "\tif (WARN_ON_ONCE(new_pos > log->end_pos))",
            "\t\treturn;",
            "",
            "\tif (!bpf_verifier_log_needed(log) || log->level == BPF_LOG_KERNEL)",
            "\t\treturn;",
            "",
            "\t/* if position to which we reset is beyond current log window,",
            "\t * then we didn't preserve any useful content and should adjust",
            "\t * start_pos to end up with an empty log (start_pos == end_pos)",
            "\t */",
            "\tlog->end_pos = new_pos;",
            "\tif (log->end_pos < log->start_pos)",
            "\t\tlog->start_pos = log->end_pos;",
            "",
            "\tif (!log->ubuf)",
            "\t\treturn;",
            "",
            "\tif (log->level & BPF_LOG_FIXED)",
            "\t\tpos = log->end_pos + 1;",
            "\telse",
            "\t\tdiv_u64_rem(new_pos, log->len_total, &pos);",
            "",
            "\tif (pos < log->len_total && put_user(zero, log->ubuf + pos))",
            "\t\tlog->ubuf = NULL;",
            "}",
            "static void bpf_vlog_reverse_kbuf(char *buf, int len)",
            "{",
            "\tint i, j;",
            "",
            "\tfor (i = 0, j = len - 1; i < j; i++, j--)",
            "\t\tswap(buf[i], buf[j]);",
            "}",
            "static int bpf_vlog_reverse_ubuf(struct bpf_verifier_log *log, int start, int end)",
            "{",
            "\t/* we split log->kbuf into two equal parts for both ends of array */",
            "\tint n = sizeof(log->kbuf) / 2, nn;",
            "\tchar *lbuf = log->kbuf, *rbuf = log->kbuf + n;",
            "",
            "\t/* Read ubuf's section [start, end) two chunks at a time, from left",
            "\t * and right side; within each chunk, swap all the bytes; after that",
            "\t * reverse the order of lbuf and rbuf and write result back to ubuf.",
            "\t * This way we'll end up with swapped contents of specified",
            "\t * [start, end) ubuf segment.",
            "\t */",
            "\twhile (end - start > 1) {",
            "\t\tnn = min(n, (end - start ) / 2);",
            "",
            "\t\tif (copy_from_user(lbuf, log->ubuf + start, nn))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (copy_from_user(rbuf, log->ubuf + end - nn, nn))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbpf_vlog_reverse_kbuf(lbuf, nn);",
            "\t\tbpf_vlog_reverse_kbuf(rbuf, nn);",
            "",
            "\t\t/* we write lbuf to the right end of ubuf, while rbuf to the",
            "\t\t * left one to end up with properly reversed overall ubuf",
            "\t\t */",
            "\t\tif (copy_to_user(log->ubuf + start, rbuf, nn))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (copy_to_user(log->ubuf + end - nn, lbuf, nn))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tstart += nn;",
            "\t\tend -= nn;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int bpf_vlog_finalize(struct bpf_verifier_log *log, u32 *log_size_actual)",
            "{",
            "\tu32 sublen;",
            "\tint err;",
            "",
            "\t*log_size_actual = 0;",
            "\tif (!log || log->level == 0 || log->level == BPF_LOG_KERNEL)",
            "\t\treturn 0;",
            "",
            "\tif (!log->ubuf)",
            "\t\tgoto skip_log_rotate;",
            "\t/* If we never truncated log, there is nothing to move around. */",
            "\tif (log->start_pos == 0)",
            "\t\tgoto skip_log_rotate;",
            "",
            "\t/* Otherwise we need to rotate log contents to make it start from the",
            "\t * buffer beginning and be a continuous zero-terminated string. Note",
            "\t * that if log->start_pos != 0 then we definitely filled up entire log",
            "\t * buffer with no gaps, and we just need to shift buffer contents to",
            "\t * the left by (log->start_pos % log->len_total) bytes.",
            "\t *",
            "\t * Unfortunately, user buffer could be huge and we don't want to",
            "\t * allocate temporary kernel memory of the same size just to shift",
            "\t * contents in a straightforward fashion. Instead, we'll be clever and",
            "\t * do in-place array rotation. This is a leetcode-style problem, which",
            "\t * could be solved by three rotations.",
            "\t *",
            "\t * Let's say we have log buffer that has to be shifted left by 7 bytes",
            "\t * (spaces and vertical bar is just for demonstrative purposes):",
            "\t *   E F G H I J K | A B C D",
            "\t *",
            "\t * First, we reverse entire array:",
            "\t *   D C B A | K J I H G F E",
            "\t *",
            "\t * Then we rotate first 4 bytes (DCBA) and separately last 7 bytes",
            "\t * (KJIHGFE), resulting in a properly rotated array:",
            "\t *   A B C D | E F G H I J K",
            "\t *",
            "\t * We'll utilize log->kbuf to read user memory chunk by chunk, swap",
            "\t * bytes, and write them back. Doing it byte-by-byte would be",
            "\t * unnecessarily inefficient. Altogether we are going to read and",
            "\t * write each byte twice, for total 4 memory copies between kernel and",
            "\t * user space.",
            "\t */",
            "",
            "\t/* length of the chopped off part that will be the beginning;",
            "\t * len(ABCD) in the example above",
            "\t */",
            "\tdiv_u64_rem(log->start_pos, log->len_total, &sublen);",
            "\tsublen = log->len_total - sublen;",
            "",
            "\terr = bpf_vlog_reverse_ubuf(log, 0, log->len_total);",
            "\terr = err ?: bpf_vlog_reverse_ubuf(log, 0, sublen);",
            "\terr = err ?: bpf_vlog_reverse_ubuf(log, sublen, log->len_total);",
            "\tif (err)",
            "\t\tlog->ubuf = NULL;",
            "",
            "skip_log_rotate:",
            "\t*log_size_actual = log->len_max;",
            "",
            "\t/* properly initialized log has either both ubuf!=NULL and len_total>0",
            "\t * or ubuf==NULL and len_total==0, so if this condition doesn't hold,",
            "\t * we got a fault somewhere along the way, so report it back",
            "\t */",
            "\tif (!!log->ubuf != !!log->len_total)",
            "\t\treturn -EFAULT;",
            "",
            "\t/* did truncation actually happen? */",
            "\tif (log->ubuf && log->len_max > log->len_total)",
            "\t\treturn -ENOSPC;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_vlog_reset, bpf_vlog_reverse_kbuf, bpf_vlog_reverse_ubuf, bpf_vlog_finalize",
          "description": "提供日志重置、缓冲区反转及最终化功能，通过旋转日志缓冲区实现连续日志存储并保证数据完整性。",
          "similarity": 0.6527267694473267
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/log.c",
          "start_line": 303,
          "end_line": 462,
          "content": [
            "__printf(2, 3) void bpf_verifier_log_write(struct bpf_verifier_env *env,",
            "\t\t\t\t\t   const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "",
            "\tif (!bpf_verifier_log_needed(&env->log))",
            "\t\treturn;",
            "",
            "\tva_start(args, fmt);",
            "\tbpf_verifier_vlog(&env->log, fmt, args);",
            "\tva_end(args);",
            "}",
            "__printf(2, 3) void bpf_log(struct bpf_verifier_log *log,",
            "\t\t\t    const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "",
            "\tif (!bpf_verifier_log_needed(log))",
            "\t\treturn;",
            "",
            "\tva_start(args, fmt);",
            "\tbpf_verifier_vlog(log, fmt, args);",
            "\tva_end(args);",
            "}",
            "__printf(3, 4) void verbose_linfo(struct bpf_verifier_env *env,",
            "\t\t\t\t  u32 insn_off,",
            "\t\t\t\t  const char *prefix_fmt, ...)",
            "{",
            "\tconst struct bpf_line_info *linfo;",
            "",
            "\tif (!bpf_verifier_log_needed(&env->log))",
            "\t\treturn;",
            "",
            "\tlinfo = find_linfo(env, insn_off);",
            "\tif (!linfo || linfo == env->prev_linfo)",
            "\t\treturn;",
            "",
            "\tif (prefix_fmt) {",
            "\t\tva_list args;",
            "",
            "\t\tva_start(args, prefix_fmt);",
            "\t\tbpf_verifier_vlog(&env->log, prefix_fmt, args);",
            "\t\tva_end(args);",
            "\t}",
            "",
            "\tverbose(env, \"%s\\n\",",
            "\t\tltrim(btf_name_by_offset(env->prog->aux->btf,",
            "\t\t\t\t\t linfo->line_off)));",
            "",
            "\tenv->prev_linfo = linfo;",
            "}",
            "static void print_liveness(struct bpf_verifier_env *env,",
            "\t\t\t   enum bpf_reg_liveness live)",
            "{",
            "\tif (live & (REG_LIVE_READ | REG_LIVE_WRITTEN | REG_LIVE_DONE))",
            "\t    verbose(env, \"_\");",
            "\tif (live & REG_LIVE_READ)",
            "\t\tverbose(env, \"r\");",
            "\tif (live & REG_LIVE_WRITTEN)",
            "\t\tverbose(env, \"w\");",
            "\tif (live & REG_LIVE_DONE)",
            "\t\tverbose(env, \"D\");",
            "}",
            "static bool is_unum_decimal(u64 num)",
            "{",
            "\treturn num <= UNUM_MAX_DECIMAL;",
            "}",
            "static bool is_snum_decimal(s64 num)",
            "{",
            "\treturn num >= SNUM_MIN_DECIMAL && num <= SNUM_MAX_DECIMAL;",
            "}",
            "static void verbose_unum(struct bpf_verifier_env *env, u64 num)",
            "{",
            "\tif (is_unum_decimal(num))",
            "\t\tverbose(env, \"%llu\", num);",
            "\telse",
            "\t\tverbose(env, \"%#llx\", num);",
            "}",
            "static void verbose_snum(struct bpf_verifier_env *env, s64 num)",
            "{",
            "\tif (is_snum_decimal(num))",
            "\t\tverbose(env, \"%lld\", num);",
            "\telse",
            "\t\tverbose(env, \"%#llx\", num);",
            "}",
            "int tnum_strn(char *str, size_t size, struct tnum a)",
            "{",
            "\t/* print as a constant, if tnum is fully known */",
            "\tif (a.mask == 0) {",
            "\t\tif (is_unum_decimal(a.value))",
            "\t\t\treturn snprintf(str, size, \"%llu\", a.value);",
            "\t\telse",
            "\t\t\treturn snprintf(str, size, \"%#llx\", a.value);",
            "\t}",
            "\treturn snprintf(str, size, \"(%#llx; %#llx)\", a.value, a.mask);",
            "}",
            "static void print_scalar_ranges(struct bpf_verifier_env *env,",
            "\t\t\t\tconst struct bpf_reg_state *reg,",
            "\t\t\t\tconst char **sep)",
            "{",
            "\t/* For signed ranges, we want to unify 64-bit and 32-bit values in the",
            "\t * output as much as possible, but there is a bit of a complication.",
            "\t * If we choose to print values as decimals, this is natural to do,",
            "\t * because negative 64-bit and 32-bit values >= -S32_MIN have the same",
            "\t * representation due to sign extension. But if we choose to print",
            "\t * them in hex format (see is_snum_decimal()), then sign extension is",
            "\t * misleading.",
            "\t * E.g., smin=-2 and smin32=-2 are exactly the same in decimal, but in",
            "\t * hex they will be smin=0xfffffffffffffffe and smin32=0xfffffffe, two",
            "\t * very different numbers.",
            "\t * So we avoid sign extension if we choose to print values in hex.",
            "\t */",
            "\tstruct {",
            "\t\tconst char *name;",
            "\t\tu64 val;",
            "\t\tbool omit;",
            "\t} minmaxs[] = {",
            "\t\t{\"smin\",   reg->smin_value,         reg->smin_value == S64_MIN},",
            "\t\t{\"smax\",   reg->smax_value,         reg->smax_value == S64_MAX},",
            "\t\t{\"umin\",   reg->umin_value,         reg->umin_value == 0},",
            "\t\t{\"umax\",   reg->umax_value,         reg->umax_value == U64_MAX},",
            "\t\t{\"smin32\",",
            "\t\t is_snum_decimal((s64)reg->s32_min_value)",
            "\t\t\t ? (s64)reg->s32_min_value",
            "\t\t\t : (u32)reg->s32_min_value, reg->s32_min_value == S32_MIN},",
            "\t\t{\"smax32\",",
            "\t\t is_snum_decimal((s64)reg->s32_max_value)",
            "\t\t\t ? (s64)reg->s32_max_value",
            "\t\t\t : (u32)reg->s32_max_value, reg->s32_max_value == S32_MAX},",
            "\t\t{\"umin32\", reg->u32_min_value,      reg->u32_min_value == 0},",
            "\t\t{\"umax32\", reg->u32_max_value,      reg->u32_max_value == U32_MAX},",
            "\t}, *m1, *m2, *mend = &minmaxs[ARRAY_SIZE(minmaxs)];",
            "\tbool neg1, neg2;",
            "",
            "\tfor (m1 = &minmaxs[0]; m1 < mend; m1++) {",
            "\t\tif (m1->omit)",
            "\t\t\tcontinue;",
            "",
            "\t\tneg1 = m1->name[0] == 's' && (s64)m1->val < 0;",
            "",
            "\t\tverbose(env, \"%s%s=\", *sep, m1->name);",
            "\t\t*sep = \",\";",
            "",
            "\t\tfor (m2 = m1 + 2; m2 < mend; m2 += 2) {",
            "\t\t\tif (m2->omit || m2->val != m1->val)",
            "\t\t\t\tcontinue;",
            "\t\t\t/* don't mix negatives with positives */",
            "\t\t\tneg2 = m2->name[0] == 's' && (s64)m2->val < 0;",
            "\t\t\tif (neg2 != neg1)",
            "\t\t\t\tcontinue;",
            "\t\t\tm2->omit = true;",
            "\t\t\tverbose(env, \"%s=\", m2->name);",
            "\t\t}",
            "",
            "\t\tif (m1->name[0] == 's')",
            "\t\t\tverbose_snum(env, m1->val);",
            "\t\telse",
            "\t\t\tverbose_unum(env, m1->val);",
            "\t}",
            "}"
          ],
          "function_name": "bpf_verifier_log_write, bpf_log, verbose_linfo, print_liveness, is_unum_decimal, is_snum_decimal, verbose_unum, verbose_snum, tnum_strn, print_scalar_ranges",
          "description": "包含日志格式化辅助函数，支持指令信息打印、寄存器存活状态显示及数值范围解析等多样化日志输出需求。",
          "similarity": 0.6502608060836792
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/log.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com",
            " * Copyright (c) 2016 Facebook",
            " * Copyright (c) 2018 Covalent IO, Inc. http://covalent.io",
            " */",
            "#include <uapi/linux/btf.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/math64.h>",
            "",
            "#define verbose(env, fmt, args...) bpf_verifier_log_write(env, fmt, ##args)",
            ""
          ],
          "function_name": null,
          "description": "定义了BPF验证器日志相关的头文件和宏，其中`verbose`宏用于向内核日志写入验证器相关信息。",
          "similarity": 0.5612764358520508
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/log.c",
          "start_line": 814,
          "end_line": 830,
          "content": [
            "static inline u32 vlog_alignment(u32 pos)",
            "{",
            "\treturn round_up(max(pos + BPF_LOG_MIN_ALIGNMENT / 2, BPF_LOG_ALIGNMENT),",
            "\t\t\tBPF_LOG_MIN_ALIGNMENT) - pos - 1;",
            "}",
            "void print_insn_state(struct bpf_verifier_env *env, const struct bpf_verifier_state *vstate,",
            "\t\t      u32 frameno)",
            "{",
            "\tif (env->prev_log_pos && env->prev_log_pos == env->log.end_pos) {",
            "\t\t/* remove new line character */",
            "\t\tbpf_vlog_reset(&env->log, env->prev_log_pos - 1);",
            "\t\tverbose(env, \"%*c;\", vlog_alignment(env->prev_insn_print_pos), ' ');",
            "\t} else {",
            "\t\tverbose(env, \"%d:\", env->insn_idx);",
            "\t}",
            "\tprint_verifier_state(env, vstate, frameno, false);",
            "}"
          ],
          "function_name": "vlog_alignment, print_insn_state",
          "description": "该代码片段实现BPF验证日志的格式化输出控制。vlog_alignment函数计算日志记录时所需的对齐空格数量，通过取当前位置到下一个对齐边界的距离实现。print_insn_state函数负责在验证过程中按需输出指令状态信息，通过判断日志位置状态决定是否重置日志并添加对齐符号，但存在依赖未展示的宏定义和print_verifier_state函数，上下文不完整。",
          "similarity": 0.523931622505188
        }
      ]
    },
    {
      "source_file": "kernel/tsacct.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:42:02\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `tsacct.c`\n\n---\n\n# tsacct.c 技术文档\n\n## 1. 文件概述\n\n`tsacct.c` 是 Linux 内核中实现任务统计（taskstats）接口下系统记账（accounting）功能的核心文件。它负责收集进程/任务的资源使用信息，包括基本记账（basic accounting）和扩展记账（extended accounting）两类数据。这些数据通过 `taskstats` 接口暴露给用户空间，用于系统监控、资源审计和性能分析等用途。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`bacct_add_tsk()`**  \n  填充任务的基本记账信息到 `struct taskstats` 结构体中，包括进程 ID、父进程 ID、用户/组 ID、CPU 时间、启动时间、退出码、调度策略、nice 值、缺页次数、命令名等。\n\n- **`xacct_add_tsk()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  填充任务的扩展记账信息，包括内存使用积分（RSS/VM）、I/O 字节数、系统调用次数等。\n\n- **`acct_update_integrals()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  在中断上下文中安全地更新任务的内存使用积分（RSS 和虚拟内存的时间积分）。\n\n- **`acct_account_cputime()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  在已知 CPU 时间更新后，直接调用内部函数更新内存积分，避免重复获取时间。\n\n- **`acct_clear_integrals()`**（仅当 `CONFIG_TASK_XACCT` 启用时）  \n  清除任务结构体中的内存积分字段，通常在进程创建或复用时调用。\n\n### 关键数据结构\n\n- **`struct taskstats`**  \n  用户空间通过 netlink 接口获取的统计信息结构体，包含 `ac_*` 前缀的各类记账字段。\n\n- **`struct task_struct` 中的扩展字段**（仅当 `CONFIG_TASK_XACCT` 启用时）：\n  - `acct_rss_mem1`：RSS 内存使用的时间积分（单位：页·纳秒 / 1024）\n  - `acct_vm_mem1`：虚拟内存使用的时间积分（单位：页·纳秒 / 1024）\n  - `acct_timexpd`：上次更新积分时的累计 CPU 时间（纳秒）\n\n## 3. 关键实现\n\n### 基本记账实现细节\n\n- **时间计算**：\n  - `ac_etime`：任务自启动以来的经过时间（微秒）。\n  - `ac_tgetime`：整个线程组自组长启动以来的经过时间（微秒）。\n  - `ac_btime` / `ac_btime64`：任务启动的绝对时间（Unix 时间戳），前者限制为 32 位以兼容旧接口。\n\n- **身份与关系信息**：\n  - 使用 `from_kuid_munged()` 和 `from_kgid_munged()` 将内核 UID/GID 映射到指定用户命名空间。\n  - 父进程 ID（`ac_ppid`）通过 RCU 读取 `real_parent`，并在进程已退出时设为 0。\n\n- **CPU 时间**：\n  - 使用 `task_cputime()` 获取任务及其子线程的累计用户态和内核态 CPU 时间（纳秒）。\n  - 同时提供原始时间和按 CPU 频率缩放后的时间（`ac_utimescaled` / `ac_stimescaled`）。\n\n- **退出与特权标志**：\n  - 根据任务标志（如 `PF_EXITING`、`PF_SUPERPRIV` 等）设置 `ac_flag` 中的对应位（`AXSIG`、`ASU` 等）。\n\n### 扩展记账实现细节（`CONFIG_TASK_XACCT`）\n\n- **内存积分算法**：\n  - 通过 `__acct_update_integrals()` 定期累积 `RSS × 时间` 和 `VM × 时间`。\n  - 积分单位为“页·纳秒”，右移 10 位（即除以 1024）防止溢出。\n  - 最终在 `xacct_add_tsk()` 中转换为 **MB·微秒**（通过 `PAGE_SIZE / (1000 * KB)`）。\n\n- **高水位内存统计**：\n  - 从 `mm_struct` 中获取历史最高 RSS 和 VM 值，并转换为 KB 单位。\n\n- **I/O 统计**：\n  - 从 `task_struct->ioac` 获取字符级和字节级的读写统计。\n  - 使用 `KB_MASK` 对结果向下对齐到 KB 边界（即清除低 10 位）。\n  - 若未启用 `CONFIG_TASK_IO_ACCOUNTING`，则 I/O 字节字段置零。\n\n- **中断安全更新**：\n  - `acct_update_integrals()` 使用 `local_irq_save/restore` 禁用本地中断，确保在中断上下文中安全更新。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/tsacct_kern.h>`：定义 `taskstats` 结构和相关接口。\n  - `<linux/acct.h>`：提供记账相关的常量和类型。\n  - `<linux/sched/*.h>`：访问任务调度、CPU 时间、凭证等信息。\n  - `<linux/mm.h>`：访问内存管理结构（如 `mm_struct`）。\n  - `<linux/jiffies.h>` 和 `<linux/kernel.h>`：时间转换和基础宏。\n\n- **配置依赖**：\n  - 基本记账功能始终编译。\n  - 扩展记账功能（`xacct_add_tsk` 及相关函数）依赖 `CONFIG_TASK_XACCT`。\n  - I/O 字节统计依赖 `CONFIG_TASK_IO_ACCOUNTING`。\n\n- **与其他子系统交互**：\n  - **调度子系统**：通过 `task_cputime()` 获取 CPU 时间。\n  - **内存管理子系统**：通过 `get_task_mm()` 和 `get_mm_hiwater_*` 获取内存使用情况。\n  - **用户命名空间**：通过 `user_ns` 参数进行 UID/GID 映射。\n  - **进程管理**：访问 `task_struct` 的各种字段（如 `start_time`、`exit_code`、`flags` 等）。\n\n## 5. 使用场景\n\n- **用户空间监控工具**：如 `nmon`、`atop`、`sadc` 等通过 taskstats netlink 接口获取进程资源使用详情。\n- **作业调度系统**：HPC 或容器平台（如 Slurm、Kubernetes）利用扩展记账数据进行资源配额和计费。\n- **系统审计**：记录进程的 CPU、内存、I/O 消耗，用于安全分析或性能瓶颈定位。\n- **内核自身记账**：在进程退出或通过 `TASKSTATS_CMD_ATTR_PID` 查询时，填充并返回 `taskstats` 数据。\n- **cgroup v1/v2 集成**：部分记账数据可被 cgroup 控制器复用或聚合。",
      "similarity": 0.5513586401939392,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/tsacct.c",
          "start_line": 1,
          "end_line": 19,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * tsacct.c - System accounting over taskstats interface",
            " *",
            " * Copyright (C) Jay Lan,\t<jlan@sgi.com>",
            " */",
            "",
            "#include <linux/kernel.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/mm.h>",
            "",
            "/*",
            " * fill in basic accounting fields",
            " */"
          ],
          "function_name": null,
          "description": "定义系统任务统计（taskstats）接口的会计模块，包含基础头文件和注释，声明TS_COMM_LEN常量，为后续会计字段填充提供上下文；上下文不完整",
          "similarity": 0.5021703839302063
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/tsacct.c",
          "start_line": 20,
          "end_line": 133,
          "content": [
            "void bacct_add_tsk(struct user_namespace *user_ns,",
            "\t\t   struct pid_namespace *pid_ns,",
            "\t\t   struct taskstats *stats, struct task_struct *tsk)",
            "{",
            "\tconst struct cred *tcred;",
            "\tu64 utime, stime, utimescaled, stimescaled;",
            "\tu64 now_ns, delta;",
            "\ttime64_t btime;",
            "",
            "\tBUILD_BUG_ON(TS_COMM_LEN < TASK_COMM_LEN);",
            "",
            "\t/* calculate task elapsed time in nsec */",
            "\tnow_ns = ktime_get_ns();",
            "\t/* store whole group time first */",
            "\tdelta = now_ns - tsk->group_leader->start_time;",
            "\t/* Convert to micro seconds */",
            "\tdo_div(delta, NSEC_PER_USEC);",
            "\tstats->ac_tgetime = delta;",
            "\tdelta = now_ns - tsk->start_time;",
            "\tdo_div(delta, NSEC_PER_USEC);",
            "\tstats->ac_etime = delta;",
            "\t/* Convert to seconds for btime (note y2106 limit) */",
            "\tbtime = ktime_get_real_seconds() - div_u64(delta, USEC_PER_SEC);",
            "\tstats->ac_btime = clamp_t(time64_t, btime, 0, U32_MAX);",
            "\tstats->ac_btime64 = btime;",
            "",
            "\tif (tsk->flags & PF_EXITING)",
            "\t\tstats->ac_exitcode = tsk->exit_code;",
            "\tif (thread_group_leader(tsk) && (tsk->flags & PF_FORKNOEXEC))",
            "\t\tstats->ac_flag |= AFORK;",
            "\tif (tsk->flags & PF_SUPERPRIV)",
            "\t\tstats->ac_flag |= ASU;",
            "\tif (tsk->flags & PF_DUMPCORE)",
            "\t\tstats->ac_flag |= ACORE;",
            "\tif (tsk->flags & PF_SIGNALED)",
            "\t\tstats->ac_flag |= AXSIG;",
            "\tstats->ac_nice\t = task_nice(tsk);",
            "\tstats->ac_sched\t = tsk->policy;",
            "\tstats->ac_pid\t = task_pid_nr_ns(tsk, pid_ns);",
            "\tstats->ac_tgid   = task_tgid_nr_ns(tsk, pid_ns);",
            "\trcu_read_lock();",
            "\ttcred = __task_cred(tsk);",
            "\tstats->ac_uid\t = from_kuid_munged(user_ns, tcred->uid);",
            "\tstats->ac_gid\t = from_kgid_munged(user_ns, tcred->gid);",
            "\tstats->ac_ppid\t = pid_alive(tsk) ?",
            "\t\ttask_tgid_nr_ns(rcu_dereference(tsk->real_parent), pid_ns) : 0;",
            "\trcu_read_unlock();",
            "",
            "\ttask_cputime(tsk, &utime, &stime);",
            "\tstats->ac_utime = div_u64(utime, NSEC_PER_USEC);",
            "\tstats->ac_stime = div_u64(stime, NSEC_PER_USEC);",
            "",
            "\ttask_cputime_scaled(tsk, &utimescaled, &stimescaled);",
            "\tstats->ac_utimescaled = div_u64(utimescaled, NSEC_PER_USEC);",
            "\tstats->ac_stimescaled = div_u64(stimescaled, NSEC_PER_USEC);",
            "",
            "\tstats->ac_minflt = tsk->min_flt;",
            "\tstats->ac_majflt = tsk->maj_flt;",
            "",
            "\tstrscpy_pad(stats->ac_comm, tsk->comm);",
            "}",
            "void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)",
            "{",
            "\tstruct mm_struct *mm;",
            "",
            "\t/* convert pages-nsec/1024 to Mbyte-usec, see __acct_update_integrals */",
            "\tstats->coremem = p->acct_rss_mem1 * PAGE_SIZE;",
            "\tdo_div(stats->coremem, 1000 * KB);",
            "\tstats->virtmem = p->acct_vm_mem1 * PAGE_SIZE;",
            "\tdo_div(stats->virtmem, 1000 * KB);",
            "\tmm = get_task_mm(p);",
            "\tif (mm) {",
            "\t\t/* adjust to KB unit */",
            "\t\tstats->hiwater_rss   = get_mm_hiwater_rss(mm) * PAGE_SIZE / KB;",
            "\t\tstats->hiwater_vm    = get_mm_hiwater_vm(mm)  * PAGE_SIZE / KB;",
            "\t\tmmput(mm);",
            "\t}",
            "\tstats->read_char\t= p->ioac.rchar & KB_MASK;",
            "\tstats->write_char\t= p->ioac.wchar & KB_MASK;",
            "\tstats->read_syscalls\t= p->ioac.syscr & KB_MASK;",
            "\tstats->write_syscalls\t= p->ioac.syscw & KB_MASK;",
            "#ifdef CONFIG_TASK_IO_ACCOUNTING",
            "\tstats->read_bytes\t= p->ioac.read_bytes & KB_MASK;",
            "\tstats->write_bytes\t= p->ioac.write_bytes & KB_MASK;",
            "\tstats->cancelled_write_bytes = p->ioac.cancelled_write_bytes & KB_MASK;",
            "#else",
            "\tstats->read_bytes\t= 0;",
            "\tstats->write_bytes\t= 0;",
            "\tstats->cancelled_write_bytes = 0;",
            "#endif",
            "}",
            "static void __acct_update_integrals(struct task_struct *tsk,",
            "\t\t\t\t    u64 utime, u64 stime)",
            "{",
            "\tu64 time, delta;",
            "",
            "\tif (!likely(tsk->mm))",
            "\t\treturn;",
            "",
            "\ttime = stime + utime;",
            "\tdelta = time - tsk->acct_timexpd;",
            "",
            "\tif (delta < TICK_NSEC)",
            "\t\treturn;",
            "",
            "\ttsk->acct_timexpd = time;",
            "\t/*",
            "\t * Divide by 1024 to avoid overflow, and to avoid division.",
            "\t * The final unit reported to userspace is Mbyte-usecs,",
            "\t * the rest of the math is done in xacct_add_tsk.",
            "\t */",
            "\ttsk->acct_rss_mem1 += delta * get_mm_rss(tsk->mm) >> 10;",
            "\ttsk->acct_vm_mem1 += delta * READ_ONCE(tsk->mm->total_vm) >> 10;",
            "}"
          ],
          "function_name": "bacct_add_tsk, xacct_add_tsk, __acct_update_integrals",
          "description": "bacct_add_tsk填充任务基本信息（如PID、用户UID/GID、调度策略、时间戳等），xacct_add_tsk统计内存及I/O数据，__acct_update_integrals计算并累加CPU时间与内存使用积分",
          "similarity": 0.46463191509246826
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/tsacct.c",
          "start_line": 152,
          "end_line": 171,
          "content": [
            "void acct_update_integrals(struct task_struct *tsk)",
            "{",
            "\tu64 utime, stime;",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "\ttask_cputime(tsk, &utime, &stime);",
            "\t__acct_update_integrals(tsk, utime, stime);",
            "\tlocal_irq_restore(flags);",
            "}",
            "void acct_account_cputime(struct task_struct *tsk)",
            "{",
            "\t__acct_update_integrals(tsk, tsk->utime, tsk->stime);",
            "}",
            "void acct_clear_integrals(struct task_struct *tsk)",
            "{",
            "\ttsk->acct_timexpd = 0;",
            "\ttsk->acct_rss_mem1 = 0;",
            "\ttsk->acct_vm_mem1 = 0;",
            "}"
          ],
          "function_name": "acct_update_integrals, acct_account_cputime, acct_clear_integrals",
          "description": "acct_update_integrals获取当前CPU时间并更新积分数据，acct_account_cputime直接记录任务CPU时间到积分，acct_clear_integrals重置任务积分相关统计变量",
          "similarity": 0.45344996452331543
        }
      ]
    },
    {
      "source_file": "kernel/printk/index.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:30:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `printk\\index.c`\n\n---\n\n# printk/index.c 技术文档\n\n## 1. 文件概述\n\n`printk/index.c` 实现了对内核中所有 `printk` 格式字符串的用户空间索引功能。该文件通过 debugfs 接口暴露一个结构化的视图，使得用户空间工具可以查询每个 `printk` 调用的位置（文件名、行号、函数名）、日志级别、标志以及完整的格式字符串。此功能主要用于日志分析、调试信息提取和内核日志格式的静态分析。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct pi_entry`：表示单个 `printk` 调用的元数据条目，包含格式字符串、文件路径、行号、函数名、日志级别前缀等信息（定义在 `internal.h` 中）。\n- `dfs_index_sops`：`seq_operations` 结构体，定义了 debugfs 文件的序列化读取操作。\n- `dfs_index_fops`：通过 `DEFINE_SEQ_ATTRIBUTE` 宏生成的文件操作结构，用于 debugfs 文件访问。\n\n### 主要函数\n- `pi_get_entry()`：根据模块指针和位置索引获取对应的 `pi_entry` 条目。\n- `pi_start()` / `pi_next()` / `pi_stop()` / `pi_show()`：实现 `seq_file` 接口，用于按行遍历并格式化输出索引内容。\n- `pi_create_file()`：为指定模块（或 vmlinux）在 debugfs 中创建对应的索引文件。\n- `pi_remove_file()`：移除模块卸载时对应的 debugfs 索引文件（仅在 `CONFIG_MODULES` 启用时）。\n- `pi_module_notify()`：模块状态通知回调，用于动态管理模块加载/卸载时的索引文件。\n- `pi_init()`：初始化 debugfs 目录结构并注册初始索引文件。\n\n## 3. 关键实现\n\n### printk 索引数据来源\n- **内核镜像（vmlinux）**：通过链接器生成的符号 `__start_printk_index` 和 `__stop_printk_index` 访问编译时收集的 `pi_entry` 数组。\n- **内核模块**：每个模块在加载时会携带自己的 `printk_index_start` 和 `printk_index_size` 字段，指向其私有的 `pi_entry` 数组。\n\n### 序列化输出格式\n- 每行输出格式为：`<level/flags> filename:line function \"format\"`\n- 日志级别和标志通过 `printk_parse_prefix()` 解析：\n  - 若存在 `LOG_CONT` 标志，输出 `<c>` 或 `<level,c>`\n  - 否则输出 `<level>`\n- 格式字符串经过转义处理（使用 `seq_escape_str()`），确保双引号和反斜杠被正确转义，避免破坏输出格式。\n\n### 动态模块支持\n- 通过 `register_module_notifier()` 注册模块状态监听器。\n- 模块加载（`MODULE_STATE_COMING`）时自动创建其 debugfs 索引文件。\n- 模块卸载（`MODULE_STATE_GOING`）时自动删除对应文件。\n\n### 初始化时机\n- 使用 `postcore_initcall()` 确保在 core 初始化阶段早期执行，早于大多数模块加载，以保证 debugfs 结构可用。\n\n## 4. 依赖关系\n\n- **内核配置**：\n  - 依赖 `CONFIG_PRINTK_INDEX`（隐含在编译此文件的条件中）\n  - 可选依赖 `CONFIG_MODULES`（启用模块动态索引管理）\n- **头文件**：\n  - `linux/debugfs.h`：提供 debugfs 接口\n  - `linux/printk.h` 和 `internal.h`：提供 `pi_entry` 和 `printk_parse_prefix()` 等内部接口\n  - `linux/module.h`：模块通知机制\n- **链接器支持**：依赖链接脚本生成 `__start_printk_index` / `__stop_printk_index` 符号\n\n## 5. 使用场景\n\n- **内核日志分析工具**：如 `crash`、`trace-cmd` 等工具可读取此索引，将二进制日志中的格式字符串 ID 映射回原始格式，实现日志解码。\n- **静态分析与验证**：安全或合规工具可扫描所有 `printk` 格式，检查是否存在敏感信息泄露或格式错误。\n- **调试辅助**：开发者可通过 `/sys/kernel/debug/printk/index/` 目录快速定位内核中所有日志输出点及其上下文。\n- **模块热插拔支持**：动态加载的模块也能被索引，确保运行时新增的日志点可被工具识别。",
      "similarity": 0.5510684847831726,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/printk/index.c",
          "start_line": 73,
          "end_line": 157,
          "content": [
            "static int pi_show(struct seq_file *s, void *v)",
            "{",
            "\tconst struct pi_entry *entry = v;",
            "\tint level = LOGLEVEL_DEFAULT;",
            "\tenum printk_info_flags flags = 0;",
            "\tu16 prefix_len = 0;",
            "",
            "\tif (v == SEQ_START_TOKEN) {",
            "\t\tseq_puts(s, \"# <level/flags> filename:line function \\\"format\\\"\\n\");",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tif (!entry->fmt)",
            "\t\treturn 0;",
            "",
            "\tif (entry->level)",
            "\t\tprintk_parse_prefix(entry->level, &level, &flags);",
            "\telse",
            "\t\tprefix_len = printk_parse_prefix(entry->fmt, &level, &flags);",
            "",
            "",
            "\tif (flags & LOG_CONT) {",
            "\t\t/*",
            "\t\t * LOGLEVEL_DEFAULT here means \"use the same level as the",
            "\t\t * message we're continuing from\", not the default message",
            "\t\t * loglevel, so don't display it as such.",
            "\t\t */",
            "\t\tif (level == LOGLEVEL_DEFAULT)",
            "\t\t\tseq_puts(s, \"<c>\");",
            "\t\telse",
            "\t\t\tseq_printf(s, \"<%d,c>\", level);",
            "\t} else",
            "\t\tseq_printf(s, \"<%d>\", level);",
            "",
            "\tseq_printf(s, \" %s:%d %s \\\"\", entry->file, entry->line, entry->func);",
            "\tif (entry->subsys_fmt_prefix)",
            "\t\tseq_escape_printf_format(s, entry->subsys_fmt_prefix);",
            "\tseq_escape_printf_format(s, entry->fmt + prefix_len);",
            "\tseq_puts(s, \"\\\"\\n\");",
            "",
            "\treturn 0;",
            "}",
            "static void pi_stop(struct seq_file *p, void *v) { }",
            "static void pi_create_file(struct module *mod)",
            "{",
            "\tdebugfs_create_file(pi_get_module_name(mod), 0444, dfs_index,",
            "\t\t\t\t       mod, &dfs_index_fops);",
            "}",
            "static void pi_remove_file(struct module *mod)",
            "{",
            "\tdebugfs_lookup_and_remove(pi_get_module_name(mod), dfs_index);",
            "}",
            "static int pi_module_notify(struct notifier_block *nb, unsigned long op,",
            "\t\t\t    void *data)",
            "{",
            "\tstruct module *mod = data;",
            "",
            "\tswitch (op) {",
            "\tcase MODULE_STATE_COMING:",
            "\t\tpi_create_file(mod);",
            "\t\tbreak;",
            "\tcase MODULE_STATE_GOING:",
            "\t\tpi_remove_file(mod);",
            "\t\tbreak;",
            "\tdefault: /* we don't care about other module states */",
            "\t\tbreak;",
            "\t}",
            "",
            "\treturn NOTIFY_OK;",
            "}",
            "static void __init pi_setup_module_notifier(void)",
            "{",
            "\tregister_module_notifier(&module_printk_fmts_nb);",
            "}",
            "static inline void __init pi_setup_module_notifier(void) { }",
            "static int __init pi_init(void)",
            "{",
            "\tstruct dentry *dfs_root = debugfs_create_dir(\"printk\", NULL);",
            "",
            "\tdfs_index = debugfs_create_dir(\"index\", dfs_root);",
            "\tpi_setup_module_notifier();",
            "\tpi_create_file(NULL);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "pi_show, pi_stop, pi_create_file, pi_remove_file, pi_module_notify, pi_setup_module_notifier, pi_setup_module_notifier, pi_init",
          "description": "实现 printk 格式索引的 debugfs 显示逻辑，包含模块加载/卸载时的文件创建与删除操作，支持通过 seq_file 遍历格式条目并安全转义敏感字符",
          "similarity": 0.5162473917007446
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/printk/index.c",
          "start_line": 1,
          "end_line": 72,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Userspace indexing of printk formats",
            " */",
            "",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/string_helpers.h>",
            "",
            "#include \"internal.h\"",
            "",
            "extern struct pi_entry *__start_printk_index[];",
            "extern struct pi_entry *__stop_printk_index[];",
            "",
            "/* The base dir for module formats, typically debugfs/printk/index/ */",
            "static struct dentry *dfs_index;",
            "",
            "static struct pi_entry *pi_get_entry(const struct module *mod, loff_t pos)",
            "{",
            "\tstruct pi_entry **entries;",
            "\tunsigned int nr_entries;",
            "",
            "#ifdef CONFIG_MODULES",
            "\tif (mod) {",
            "\t\tentries = mod->printk_index_start;",
            "\t\tnr_entries = mod->printk_index_size;",
            "\t} else",
            "#endif",
            "\t{",
            "\t\t/* vmlinux, comes from linker symbols */",
            "\t\tentries = __start_printk_index;",
            "\t\tnr_entries = __stop_printk_index - __start_printk_index;",
            "\t}",
            "",
            "\tif (pos >= nr_entries)",
            "\t\treturn NULL;",
            "",
            "\treturn entries[pos];",
            "}",
            "",
            "static void *pi_next(struct seq_file *s, void *v, loff_t *pos)",
            "{",
            "\tconst struct module *mod = s->file->f_inode->i_private;",
            "\tstruct pi_entry *entry = pi_get_entry(mod, *pos);",
            "",
            "\t(*pos)++;",
            "",
            "\treturn entry;",
            "}",
            "",
            "static void *pi_start(struct seq_file *s, loff_t *pos)",
            "{",
            "\t/*",
            "\t * Make show() print the header line. Do not update *pos because",
            "\t * pi_next() still has to return the entry at index 0 later.",
            "\t */",
            "\tif (*pos == 0)",
            "\t\treturn SEQ_START_TOKEN;",
            "",
            "\treturn pi_next(s, NULL, pos);",
            "}",
            "",
            "/*",
            " * We need both ESCAPE_ANY and explicit characters from ESCAPE_SPECIAL in @only",
            " * because otherwise ESCAPE_NAP will cause double quotes and backslashes to be",
            " * ignored for quoting.",
            " */",
            "#define seq_escape_printf_format(s, src) \\",
            "\tseq_escape_str(s, src, ESCAPE_ANY | ESCAPE_NAP | ESCAPE_APPEND, \"\\\"\\\\\")",
            ""
          ],
          "function_name": null,
          "description": "定义用于模块 printk 格式索引的辅助函数，通过模块或内核镜像的符号表获取 printk 条目，实现基于 debugfs 的格式信息遍历接口",
          "similarity": 0.47721534967422485
        }
      ]
    }
  ]
}