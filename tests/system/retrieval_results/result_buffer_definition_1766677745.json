{
  "query": "buffer definition",
  "timestamp": "2025-12-25 23:49:05",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/ringbuf.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:29:46\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\ringbuf.c`\n\n---\n\n# `bpf/ringbuf.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/ringbuf.c` 实现了 BPF（Berkeley Packet Filter）子系统中的**环形缓冲区（Ring Buffer）**机制，用于在内核与用户空间之间高效、安全地传递数据。该机制支持两种生产者模式：**内核生产者**（如 BPF 程序）和**用户空间生产者**，并提供内存映射（`mmap`）、等待队列通知、并发控制等核心功能，是 BPF 数据输出（如 perf event 替代方案）的关键基础设施。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bpf_ringbuf`**  \n  环形缓冲区的核心结构体，包含：\n  - `waitq`：等待队列，用于通知用户空间有新数据\n  - `work`：IRQ 工作项，用于异步唤醒等待队列\n  - `mask`：环形缓冲区大小掩码（`data_sz - 1`），用于快速取模\n  - `pages` / `nr_pages`：物理页数组，支持双映射\n  - `spinlock`：用于内核生产者的自旋锁（SMP 对齐）\n  - `busy`：原子变量，用于用户空间生产者的互斥访问（避免持有自旋锁过久）\n  - `consumer_pos` / `producer_pos` / `pending_pos`：消费者、生产者和待提交位置（各自独占一页，支持不同 mmap 权限）\n  - `data[]`：实际数据存储区域（页对齐）\n\n- **`struct bpf_ringbuf_map`**  \n  封装标准 `bpf_map`，关联一个 `bpf_ringbuf` 实例。\n\n- **`struct bpf_ringbuf_hdr`**  \n  8 字节记录头，包含：\n  - `len`：记录有效载荷长度\n  - `pg_off`：记录在页内的偏移（用于跨页处理）\n\n### 主要函数\n\n- **`bpf_ringbuf_area_alloc()`**  \n  分配并初始化环形缓冲区的虚拟内存区域，采用**双映射数据页**技术简化环绕处理。\n\n- **`bpf_ringbuf_alloc()`**  \n  初始化 `bpf_ringbuf` 结构体，设置锁、等待队列、IRQ 工作项及初始位置。\n\n- **`bpf_ringbuf_free()`**  \n  释放环形缓冲区占用的虚拟内存和物理页。\n\n- **`ringbuf_map_alloc()`**  \n  BPF map 分配器回调，验证参数并创建 `bpf_ringbuf_map`。\n\n- **`ringbuf_map_free()`**  \n  BPF map 释放器回调，清理资源。\n\n- **`ringbuf_map_*_elem()` / `ringbuf_map_get_next_key()`**  \n  禁用标准 map 操作（返回 `-ENOTSUPP`），因为 ringbuf 不支持键值操作。\n\n- **`bpf_ringbuf_notify()`**  \n  IRQ 工作回调，唤醒所有等待数据的用户进程。\n\n## 3. 关键实现\n\n### 双映射数据页（Double-Mapped Data Pages）\n\n为简化环形缓冲区**环绕（wrap-around）**时的数据读取逻辑，数据页被**连续映射两次**：\n```\n[meta pages][data pages][data pages (same as first copy)]\n```\n当读取跨越缓冲区末尾时，可直接线性读取第二份映射，无需特殊处理。此设计同时适用于内核和用户空间 `mmap`。\n\n### 权限隔离与安全\n\n- **`consumer_pos` 和 `producer_pos` 各占独立页**，允许通过 `mmap` 设置不同权限：\n  - **内核生产者模式**：`producer_pos` 和数据页对用户空间为**只读**，防止篡改。\n  - **用户空间生产者模式**：仅 `consumer_pos` 对用户空间为**只读**，内核需严格验证用户提交的记录。\n\n### 并发控制策略\n\n- **内核生产者**：使用 `raw_spinlock_t` 保证多生产者安全。\n- **用户空间生产者**：使用 `atomic_t busy` 原子变量，避免在 BPF 程序回调期间长期持有 IRQ 自旋锁（可能导致死锁或延迟）。若 `busy` 被占用，`__bpf_user_ringbuf_peek()` 返回 `-EBUSY`。\n\n### 内存布局与对齐\n\n- 非 `mmap` 部分（`waitq` 到 `pending_pos`）大小由 `RINGBUF_PGOFF` 定义。\n- `consumer_pos`、`producer_pos` 和 `data` 均按 `PAGE_SIZE` 对齐，确保可独立映射。\n- 总元数据页数：`RINGBUF_NR_META_PAGES = RINGBUF_PGOFF + 2`（含 consumer/producer 页）。\n\n### 大小限制\n\n- 最大记录大小：`RINGBUF_MAX_RECORD_SZ = UINT_MAX / 4`（约 1GB）。\n- 最大缓冲区大小受 `bpf_ringbuf_hdr.pg_off`（32 位页偏移）限制，理论最大约 **64GB**。\n\n## 4. 依赖关系\n\n- **BPF 子系统**：依赖 `bpf_map` 基础设施（`bpf_map_area_alloc/free`、`bpf_map_init_from_attr`）。\n- **内存管理**：使用 `alloc_pages_node`、`vmap`/`vunmap`、`__free_page` 管理物理页和虚拟映射。\n- **同步机制**：依赖 `wait_queue`、`irq_work`、`raw_spinlock` 和 `atomic_t`。\n- **BTF（BPF Type Format）**：包含 BTF 相关头文件，可能用于未来类型验证（当前未直接使用）。\n- **用户 API**：与 `uapi/linux/bpf.h` 中的 `BPF_F_NUMA_NODE` 等标志交互。\n\n## 5. 使用场景\n\n- **BPF 程序输出数据**：替代 `bpf_perf_event_output()`，提供更低开销、更高吞吐的内核到用户空间数据通道。\n- **用户空间主动提交数据**：允许用户程序通过 ringbuf 向内核提交样本（需内核验证）。\n- **实时监控与追踪**：用于 eBPF 监控工具（如 `bpftrace`、`libbpf` 应用）高效收集内核事件。\n- **NUMA 感知分配**：支持通过 `BPF_F_NUMA_NODE` 标志在指定 NUMA 节点分配内存，优化性能。",
      "similarity": 0.5486310720443726,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/ringbuf.c",
          "start_line": 1,
          "end_line": 149,
          "content": [
            "#include <linux/bpf.h>",
            "#include <linux/btf.h>",
            "#include <linux/err.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/kmemleak.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/btf_ids.h>",
            "",
            "#define RINGBUF_CREATE_FLAG_MASK (BPF_F_NUMA_NODE)",
            "",
            "/* non-mmap()'able part of bpf_ringbuf (everything up to consumer page) */",
            "#define RINGBUF_PGOFF \\",
            "\t(offsetof(struct bpf_ringbuf, consumer_pos) >> PAGE_SHIFT)",
            "/* consumer page and producer page */",
            "#define RINGBUF_POS_PAGES 2",
            "#define RINGBUF_NR_META_PAGES (RINGBUF_PGOFF + RINGBUF_POS_PAGES)",
            "",
            "#define RINGBUF_MAX_RECORD_SZ (UINT_MAX/4)",
            "",
            "struct bpf_ringbuf {",
            "\twait_queue_head_t waitq;",
            "\tstruct irq_work work;",
            "\tu64 mask;",
            "\tstruct page **pages;",
            "\tint nr_pages;",
            "\traw_spinlock_t spinlock ____cacheline_aligned_in_smp;",
            "\t/* For user-space producer ring buffers, an atomic_t busy bit is used",
            "\t * to synchronize access to the ring buffers in the kernel, rather than",
            "\t * the spinlock that is used for kernel-producer ring buffers. This is",
            "\t * done because the ring buffer must hold a lock across a BPF program's",
            "\t * callback:",
            "\t *",
            "\t *    __bpf_user_ringbuf_peek() // lock acquired",
            "\t * -> program callback_fn()",
            "\t * -> __bpf_user_ringbuf_sample_release() // lock released",
            "\t *",
            "\t * It is unsafe and incorrect to hold an IRQ spinlock across what could",
            "\t * be a long execution window, so we instead simply disallow concurrent",
            "\t * access to the ring buffer by kernel consumers, and return -EBUSY from",
            "\t * __bpf_user_ringbuf_peek() if the busy bit is held by another task.",
            "\t */",
            "\tatomic_t busy ____cacheline_aligned_in_smp;",
            "\t/* Consumer and producer counters are put into separate pages to",
            "\t * allow each position to be mapped with different permissions.",
            "\t * This prevents a user-space application from modifying the",
            "\t * position and ruining in-kernel tracking. The permissions of the",
            "\t * pages depend on who is producing samples: user-space or the",
            "\t * kernel. Note that the pending counter is placed in the same",
            "\t * page as the producer, so that it shares the same cache line.",
            "\t *",
            "\t * Kernel-producer",
            "\t * ---------------",
            "\t * The producer position and data pages are mapped as r/o in",
            "\t * userspace. For this approach, bits in the header of samples are",
            "\t * used to signal to user-space, and to other producers, whether a",
            "\t * sample is currently being written.",
            "\t *",
            "\t * User-space producer",
            "\t * -------------------",
            "\t * Only the page containing the consumer position is mapped r/o in",
            "\t * user-space. User-space producers also use bits of the header to",
            "\t * communicate to the kernel, but the kernel must carefully check and",
            "\t * validate each sample to ensure that they're correctly formatted, and",
            "\t * fully contained within the ring buffer.",
            "\t */",
            "\tunsigned long consumer_pos __aligned(PAGE_SIZE);",
            "\tunsigned long producer_pos __aligned(PAGE_SIZE);",
            "\tunsigned long pending_pos;",
            "\tchar data[] __aligned(PAGE_SIZE);",
            "};",
            "",
            "struct bpf_ringbuf_map {",
            "\tstruct bpf_map map;",
            "\tstruct bpf_ringbuf *rb;",
            "};",
            "",
            "/* 8-byte ring buffer record header structure */",
            "struct bpf_ringbuf_hdr {",
            "\tu32 len;",
            "\tu32 pg_off;",
            "};",
            "",
            "static struct bpf_ringbuf *bpf_ringbuf_area_alloc(size_t data_sz, int numa_node)",
            "{",
            "\tconst gfp_t flags = GFP_KERNEL_ACCOUNT | __GFP_RETRY_MAYFAIL |",
            "\t\t\t    __GFP_NOWARN | __GFP_ZERO;",
            "\tint nr_meta_pages = RINGBUF_NR_META_PAGES;",
            "\tint nr_data_pages = data_sz >> PAGE_SHIFT;",
            "\tint nr_pages = nr_meta_pages + nr_data_pages;",
            "\tstruct page **pages, *page;",
            "\tstruct bpf_ringbuf *rb;",
            "\tsize_t array_size;",
            "\tint i;",
            "",
            "\t/* Each data page is mapped twice to allow \"virtual\"",
            "\t * continuous read of samples wrapping around the end of ring",
            "\t * buffer area:",
            "\t * ------------------------------------------------------",
            "\t * | meta pages |  real data pages  |  same data pages  |",
            "\t * ------------------------------------------------------",
            "\t * |            | 1 2 3 4 5 6 7 8 9 | 1 2 3 4 5 6 7 8 9 |",
            "\t * ------------------------------------------------------",
            "\t * |            | TA             DA | TA             DA |",
            "\t * ------------------------------------------------------",
            "\t *                               ^^^^^^^",
            "\t *                                  |",
            "\t * Here, no need to worry about special handling of wrapped-around",
            "\t * data due to double-mapped data pages. This works both in kernel and",
            "\t * when mmap()'ed in user-space, simplifying both kernel and",
            "\t * user-space implementations significantly.",
            "\t */",
            "\tarray_size = (nr_meta_pages + 2 * nr_data_pages) * sizeof(*pages);",
            "\tpages = bpf_map_area_alloc(array_size, numa_node);",
            "\tif (!pages)",
            "\t\treturn NULL;",
            "",
            "\tfor (i = 0; i < nr_pages; i++) {",
            "\t\tpage = alloc_pages_node(numa_node, flags, 0);",
            "\t\tif (!page) {",
            "\t\t\tnr_pages = i;",
            "\t\t\tgoto err_free_pages;",
            "\t\t}",
            "\t\tpages[i] = page;",
            "\t\tif (i >= nr_meta_pages)",
            "\t\t\tpages[nr_data_pages + i] = page;",
            "\t}",
            "",
            "\trb = vmap(pages, nr_meta_pages + 2 * nr_data_pages,",
            "\t\t  VM_MAP | VM_USERMAP, PAGE_KERNEL);",
            "\tif (rb) {",
            "\t\tkmemleak_not_leak(pages);",
            "\t\trb->pages = pages;",
            "\t\trb->nr_pages = nr_pages;",
            "\t\treturn rb;",
            "\t}",
            "",
            "err_free_pages:",
            "\tfor (i = 0; i < nr_pages; i++)",
            "\t\t__free_page(pages[i]);",
            "\tbpf_map_area_free(pages);",
            "\treturn NULL;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义了bpf_ringbuf结构体及其相关宏，用于管理BPF环形缓冲区的元数据和数据区域。通过页面数组实现环形缓冲区的虚拟连续读取，支持用户态和内核态生产者的差异化权限控制，其中包含消费者/生产者位置指针、忙位原子变量及锁保护的元数据。",
          "similarity": 0.5062546730041504
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/ringbuf.c",
          "start_line": 335,
          "end_line": 447,
          "content": [
            "static u64 ringbuf_map_mem_usage(const struct bpf_map *map)",
            "{",
            "\tstruct bpf_ringbuf *rb;",
            "\tint nr_data_pages;",
            "\tint nr_meta_pages;",
            "\tu64 usage = sizeof(struct bpf_ringbuf_map);",
            "",
            "\trb = container_of(map, struct bpf_ringbuf_map, map)->rb;",
            "\tusage += (u64)rb->nr_pages << PAGE_SHIFT;",
            "\tnr_meta_pages = RINGBUF_NR_META_PAGES;",
            "\tnr_data_pages = map->max_entries >> PAGE_SHIFT;",
            "\tusage += (nr_meta_pages + 2 * nr_data_pages) * sizeof(struct page *);",
            "\treturn usage;",
            "}",
            "static size_t bpf_ringbuf_rec_pg_off(struct bpf_ringbuf *rb,",
            "\t\t\t\t     struct bpf_ringbuf_hdr *hdr)",
            "{",
            "\treturn ((void *)hdr - (void *)rb) >> PAGE_SHIFT;",
            "}",
            "static void bpf_ringbuf_commit(void *sample, u64 flags, bool discard)",
            "{",
            "\tunsigned long rec_pos, cons_pos;",
            "\tstruct bpf_ringbuf_hdr *hdr;",
            "\tstruct bpf_ringbuf *rb;",
            "\tu32 new_len;",
            "",
            "\thdr = sample - BPF_RINGBUF_HDR_SZ;",
            "\trb = bpf_ringbuf_restore_from_rec(hdr);",
            "\tnew_len = hdr->len ^ BPF_RINGBUF_BUSY_BIT;",
            "\tif (discard)",
            "\t\tnew_len |= BPF_RINGBUF_DISCARD_BIT;",
            "",
            "\t/* update record header with correct final size prefix */",
            "\txchg(&hdr->len, new_len);",
            "",
            "\t/* if consumer caught up and is waiting for our record, notify about",
            "\t * new data availability",
            "\t */",
            "\trec_pos = (void *)hdr - (void *)rb->data;",
            "\tcons_pos = smp_load_acquire(&rb->consumer_pos) & rb->mask;",
            "",
            "\tif (flags & BPF_RB_FORCE_WAKEUP)",
            "\t\tirq_work_queue(&rb->work);",
            "\telse if (cons_pos == rec_pos && !(flags & BPF_RB_NO_WAKEUP))",
            "\t\tirq_work_queue(&rb->work);",
            "}",
            "static int __bpf_user_ringbuf_peek(struct bpf_ringbuf *rb, void **sample, u32 *size)",
            "{",
            "\tint err;",
            "\tu32 hdr_len, sample_len, total_len, flags, *hdr;",
            "\tu64 cons_pos, prod_pos;",
            "",
            "\t/* Synchronizes with smp_store_release() in user-space producer. */",
            "\tprod_pos = smp_load_acquire(&rb->producer_pos);",
            "\tif (prod_pos % 8)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* Synchronizes with smp_store_release() in __bpf_user_ringbuf_sample_release() */",
            "\tcons_pos = smp_load_acquire(&rb->consumer_pos);",
            "\tif (cons_pos >= prod_pos)",
            "\t\treturn -ENODATA;",
            "",
            "\thdr = (u32 *)((uintptr_t)rb->data + (uintptr_t)(cons_pos & rb->mask));",
            "\t/* Synchronizes with smp_store_release() in user-space producer. */",
            "\thdr_len = smp_load_acquire(hdr);",
            "\tflags = hdr_len & (BPF_RINGBUF_BUSY_BIT | BPF_RINGBUF_DISCARD_BIT);",
            "\tsample_len = hdr_len & ~flags;",
            "\ttotal_len = round_up(sample_len + BPF_RINGBUF_HDR_SZ, 8);",
            "",
            "\t/* The sample must fit within the region advertised by the producer position. */",
            "\tif (total_len > prod_pos - cons_pos)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* The sample must fit within the data region of the ring buffer. */",
            "\tif (total_len > ringbuf_total_data_sz(rb))",
            "\t\treturn -E2BIG;",
            "",
            "\t/* The sample must fit into a struct bpf_dynptr. */",
            "\terr = bpf_dynptr_check_size(sample_len);",
            "\tif (err)",
            "\t\treturn -E2BIG;",
            "",
            "\tif (flags & BPF_RINGBUF_DISCARD_BIT) {",
            "\t\t/* If the discard bit is set, the sample should be skipped.",
            "\t\t *",
            "\t\t * Update the consumer pos, and return -EAGAIN so the caller",
            "\t\t * knows to skip this sample and try to read the next one.",
            "\t\t */",
            "\t\tsmp_store_release(&rb->consumer_pos, cons_pos + total_len);",
            "\t\treturn -EAGAIN;",
            "\t}",
            "",
            "\tif (flags & BPF_RINGBUF_BUSY_BIT)",
            "\t\treturn -ENODATA;",
            "",
            "\t*sample = (void *)((uintptr_t)rb->data +",
            "\t\t\t   (uintptr_t)((cons_pos + BPF_RINGBUF_HDR_SZ) & rb->mask));",
            "\t*size = sample_len;",
            "\treturn 0;",
            "}",
            "static void __bpf_user_ringbuf_sample_release(struct bpf_ringbuf *rb, size_t size, u64 flags)",
            "{",
            "\tu64 consumer_pos;",
            "\tu32 rounded_size = round_up(size + BPF_RINGBUF_HDR_SZ, 8);",
            "",
            "\t/* Using smp_load_acquire() is unnecessary here, as the busy-bit",
            "\t * prevents another task from writing to consumer_pos after it was read",
            "\t * by this task with smp_load_acquire() in __bpf_user_ringbuf_peek().",
            "\t */",
            "\tconsumer_pos = rb->consumer_pos;",
            "\t /* Synchronizes with smp_load_acquire() in user-space producer. */",
            "\tsmp_store_release(&rb->consumer_pos, consumer_pos + rounded_size);",
            "}"
          ],
          "function_name": "ringbuf_map_mem_usage, bpf_ringbuf_rec_pg_off, bpf_ringbuf_commit, __bpf_user_ringbuf_peek, __bpf_user_ringbuf_sample_release",
          "description": "提供了环形缓冲区的内存占用统计、记录位置转换、样本提交及消费操作。包含用户态生产者与消费者的同步机制，通过忙位防止竞态条件，确保样本数据完整性校验和消费进度更新的有序性。",
          "similarity": 0.3945031762123108
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/ringbuf.c",
          "start_line": 150,
          "end_line": 258,
          "content": [
            "static void bpf_ringbuf_notify(struct irq_work *work)",
            "{",
            "\tstruct bpf_ringbuf *rb = container_of(work, struct bpf_ringbuf, work);",
            "",
            "\twake_up_all(&rb->waitq);",
            "}",
            "static void bpf_ringbuf_free(struct bpf_ringbuf *rb)",
            "{",
            "\t/* copy pages pointer and nr_pages to local variable, as we are going",
            "\t * to unmap rb itself with vunmap() below",
            "\t */",
            "\tstruct page **pages = rb->pages;",
            "\tint i, nr_pages = rb->nr_pages;",
            "",
            "\tvunmap(rb);",
            "\tfor (i = 0; i < nr_pages; i++)",
            "\t\t__free_page(pages[i]);",
            "\tbpf_map_area_free(pages);",
            "}",
            "static void ringbuf_map_free(struct bpf_map *map)",
            "{",
            "\tstruct bpf_ringbuf_map *rb_map;",
            "",
            "\trb_map = container_of(map, struct bpf_ringbuf_map, map);",
            "\tbpf_ringbuf_free(rb_map->rb);",
            "\tbpf_map_area_free(rb_map);",
            "}",
            "static long ringbuf_map_update_elem(struct bpf_map *map, void *key, void *value,",
            "\t\t\t\t    u64 flags)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "static long ringbuf_map_delete_elem(struct bpf_map *map, void *key)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "static int ringbuf_map_get_next_key(struct bpf_map *map, void *key,",
            "\t\t\t\t    void *next_key)",
            "{",
            "\treturn -ENOTSUPP;",
            "}",
            "static int ringbuf_map_mmap_kern(struct bpf_map *map, struct vm_area_struct *vma)",
            "{",
            "\tstruct bpf_ringbuf_map *rb_map;",
            "",
            "\trb_map = container_of(map, struct bpf_ringbuf_map, map);",
            "",
            "\tif (vma->vm_flags & VM_WRITE) {",
            "\t\t/* allow writable mapping for the consumer_pos only */",
            "\t\tif (vma->vm_pgoff != 0 || vma->vm_end - vma->vm_start != PAGE_SIZE)",
            "\t\t\treturn -EPERM;",
            "\t}",
            "\t/* remap_vmalloc_range() checks size and offset constraints */",
            "\treturn remap_vmalloc_range(vma, rb_map->rb,",
            "\t\t\t\t   vma->vm_pgoff + RINGBUF_PGOFF);",
            "}",
            "static int ringbuf_map_mmap_user(struct bpf_map *map, struct vm_area_struct *vma)",
            "{",
            "\tstruct bpf_ringbuf_map *rb_map;",
            "",
            "\trb_map = container_of(map, struct bpf_ringbuf_map, map);",
            "",
            "\tif (vma->vm_flags & VM_WRITE) {",
            "\t\tif (vma->vm_pgoff == 0)",
            "\t\t\t/* Disallow writable mappings to the consumer pointer,",
            "\t\t\t * and allow writable mappings to both the producer",
            "\t\t\t * position, and the ring buffer data itself.",
            "\t\t\t */",
            "\t\t\treturn -EPERM;",
            "\t}",
            "\t/* remap_vmalloc_range() checks size and offset constraints */",
            "\treturn remap_vmalloc_range(vma, rb_map->rb, vma->vm_pgoff + RINGBUF_PGOFF);",
            "}",
            "static unsigned long ringbuf_avail_data_sz(struct bpf_ringbuf *rb)",
            "{",
            "\tunsigned long cons_pos, prod_pos;",
            "",
            "\tcons_pos = smp_load_acquire(&rb->consumer_pos);",
            "\tprod_pos = smp_load_acquire(&rb->producer_pos);",
            "\treturn prod_pos - cons_pos;",
            "}",
            "static u32 ringbuf_total_data_sz(const struct bpf_ringbuf *rb)",
            "{",
            "\treturn rb->mask + 1;",
            "}",
            "static __poll_t ringbuf_map_poll_kern(struct bpf_map *map, struct file *filp,",
            "\t\t\t\t      struct poll_table_struct *pts)",
            "{",
            "\tstruct bpf_ringbuf_map *rb_map;",
            "",
            "\trb_map = container_of(map, struct bpf_ringbuf_map, map);",
            "\tpoll_wait(filp, &rb_map->rb->waitq, pts);",
            "",
            "\tif (ringbuf_avail_data_sz(rb_map->rb))",
            "\t\treturn EPOLLIN | EPOLLRDNORM;",
            "\treturn 0;",
            "}",
            "static __poll_t ringbuf_map_poll_user(struct bpf_map *map, struct file *filp,",
            "\t\t\t\t      struct poll_table_struct *pts)",
            "{",
            "\tstruct bpf_ringbuf_map *rb_map;",
            "",
            "\trb_map = container_of(map, struct bpf_ringbuf_map, map);",
            "\tpoll_wait(filp, &rb_map->rb->waitq, pts);",
            "",
            "\tif (ringbuf_avail_data_sz(rb_map->rb) < ringbuf_total_data_sz(rb_map->rb))",
            "\t\treturn EPOLLOUT | EPOLLWRNORM;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_ringbuf_notify, bpf_ringbuf_free, ringbuf_map_free, ringbuf_map_update_elem, ringbuf_map_delete_elem, ringbuf_map_get_next_key, ringbuf_map_mmap_kern, ringbuf_map_mmap_user, ringbuf_avail_data_sz, ringbuf_total_data_sz, ringbuf_map_poll_kern, ringbuf_map_poll_user",
          "description": "实现了环形缓冲区的事件通知、资源释放、内存映射控制及I/O监控功能。包含针对用户态和内核态的差异化mmap处理逻辑，通过spinlock和atomic_t实现并发控制，提供poll接口检测缓冲区可用数据状态。",
          "similarity": 0.34224724769592285
        }
      ]
    },
    {
      "source_file": "kernel/bpf/bpf_iter.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:58:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bpf_iter.c`\n\n---\n\n# bpf/bpf_iter.c 技术文档\n\n## 1. 文件概述\n\n`bpf_iter.c` 是 Linux 内核中 BPF（Berkeley Packet Filter）子系统的一部分，实现了 **BPF 迭代器（BPF Iterator）** 的核心机制。BPF 迭代器是一种特殊的 BPF 程序类型，允许用户空间通过文件接口（如 `/sys/fs/bpf/` 下的文件）安全、高效地遍历内核中的数据结构（如任务、映射、网络连接等），而无需引入新的系统调用或暴露原始内核指针。\n\n该文件负责：\n- 管理 BPF 迭代器目标（target）的注册与注销\n- 实现自定义的 `seq_file` 读取逻辑（`bpf_seq_read`）\n- 管理迭代器会话的私有数据和生命周期\n- 提供文件操作接口（`file_operations`）供用户空间读取\n\n## 2. 核心功能\n\n### 主要数据结构\n\n| 结构体 | 说明 |\n|--------|------|\n| `struct bpf_iter_target_info` | 表示一个 BPF 迭代器目标的注册信息，包含 `bpf_iter_reg` 和缓存的 BTF ID |\n| `struct bpf_iter_link` | 继承自 `bpf_link`，用于将 BPF 程序与特定迭代器目标关联 |\n| `struct bpf_iter_priv_data` | `seq_file` 的私有数据，包含目标信息、BPF 程序、会话 ID、序列号等状态 |\n\n### 主要函数\n\n| 函数 | 功能 |\n|------|------|\n| `bpf_iter_reg_target()` | 注册一个新的 BPF 迭代器目标类型 |\n| `bpf_iter_unreg_target()` | 注销已注册的 BPF 迭代器目标 |\n| `bpf_iter_prog_supported()` | 检查 BPF 程序是否为有效的迭代器程序（基于函数名前缀和 BTF ID 匹配） |\n| `bpf_seq_read()` | 自定义的 `seq_file` 读取实现，支持 BPF 程序在 `start/next/show/stop` 回调中执行 |\n| `iter_open()` / `iter_release()` | 文件打开/释放回调，初始化和清理迭代器会话 |\n| `bpf_iter_inc_seq_num()` / `bpf_iter_dec_seq_num()` | 管理当前迭代对象的序列号（用于跳过对象时回退） |\n| `bpf_iter_done_stop()` | 标记迭代已正常结束 |\n\n### 全局变量\n\n- `targets`：已注册迭代器目标的链表\n- `session_id`：全局递增的会话 ID，用于区分不同迭代会话\n- `bpf_iter_fops`：提供给 VFS 的文件操作接口\n\n## 3. 关键实现\n\n### BPF 迭代器工作流程\n1. **注册**：内核子系统（如 `task_iter`、`map_iter`）通过 `bpf_iter_reg_target()` 注册其迭代器实现（`bpf_iter_reg`）。\n2. **程序加载**：用户加载 BPF 程序时，若其 `attach_func_name` 以 `bpf_iter_` 开头，则调用 `bpf_iter_prog_supported()` 验证并绑定到对应目标。\n3. **文件打开**：用户打开 BPF 迭代器链接创建的文件时，`iter_open()` 调用 `prepare_seq_file()` 初始化 `seq_file`。\n4. **数据读取**：`bpf_seq_read()` 驱动迭代过程：\n   - 调用 `seq->op->start()` 获取首个对象\n   - 循环调用 `next()` 和 `show()`，其中 `show()` 可能执行 BPF 程序生成输出\n   - 支持在 `show()` 中返回 `>0` 跳过当前对象（通过 `bpf_iter_dec_seq_num()` 回退序列号）\n   - 限制最大迭代对象数（`MAX_ITER_OBJECTS = 1,000,000`）防止无限循环\n   - 支持可抢占目标（`BPF_ITER_RESCHED` 特性）在循环中调用 `cond_resched()`\n5. **结束**：`stop()` 回调被调用，可能再次执行 BPF 程序进行清理。\n\n### 安全与健壮性机制\n- **溢出保护**：检查 `seq_has_overflowed()` 防止缓冲区溢出，返回 `-E2BIG`\n- **对象数量限制**：防止恶意程序导致内核长时间占用 CPU\n- **序列号管理**：精确跟踪当前迭代位置，支持对象跳过\n- **会话隔离**：每个文件打开对应独立的 `session_id` 和私有数据\n\n### BTF ID 缓存优化\n- 首次匹配目标时，将程序的 `attach_btf_id` 缓存到 `tinfo->btf_id`\n- 后续程序可直接通过 BTF ID 快速匹配，避免字符串比较\n\n## 4. 依赖关系\n\n- **BPF 核心**：依赖 `linux/bpf.h`、`bpf_link` 机制和 BPF 程序管理（`bpf_prog_put`）\n- **VFS/seq_file**：基于 `linux/fs.h` 和 `seq_file` 框架实现迭代输出\n- **内存管理**：使用 `kvmalloc` 分配大缓冲区（`PAGE_SIZE << 3`）\n- **RCU/锁机制**：使用 `mutex`（`targets_mutex`, `link_mutex`）保护全局链表\n- **BTF（BPF Type Format）**：通过 `attach_btf_id` 和函数名匹配程序与目标\n- **调度器**：支持可抢占目标时调用 `cond_resched()`\n\n## 5. 使用场景\n\n1. **内核数据遍历**：用户空间安全读取内核内部数据结构，例如：\n   - 遍历所有进程（`bpf_iter_task`）\n   - 遍历 BPF 映射内容（`bpf_iter_map_elem`）\n   - 遍历网络连接（`bpf_iter_tcp`）\n2. **调试与监控**：替代 `/proc` 或 `debugfs` 接口，提供更灵活、可编程的数据导出\n3. **性能分析**：高效收集内核状态快照，避免频繁系统调用开销\n4. **安全审计**：以只读方式检查内核对象，无需暴露原始指针或增加系统调用\n\n> **注**：该文件被截断，实际 `bpf_iter_prog_supported()` 函数未完整显示，但核心逻辑已涵盖。完整实现还需处理 `ctx_arg_info` 等上下文参数配置。",
      "similarity": 0.5328927040100098,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 1,
          "end_line": 43,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2020 Facebook */",
            "",
            "#include <linux/fs.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/rcupdate_trace.h>",
            "",
            "struct bpf_iter_target_info {",
            "\tstruct list_head list;",
            "\tconst struct bpf_iter_reg *reg_info;",
            "\tu32 btf_id;\t/* cached value */",
            "};",
            "",
            "struct bpf_iter_link {",
            "\tstruct bpf_link link;",
            "\tstruct bpf_iter_aux_info aux;",
            "\tstruct bpf_iter_target_info *tinfo;",
            "};",
            "",
            "struct bpf_iter_priv_data {",
            "\tstruct bpf_iter_target_info *tinfo;",
            "\tconst struct bpf_iter_seq_info *seq_info;",
            "\tstruct bpf_prog *prog;",
            "\tu64 session_id;",
            "\tu64 seq_num;",
            "\tbool done_stop;",
            "\tu8 target_private[] __aligned(8);",
            "};",
            "",
            "static struct list_head targets = LIST_HEAD_INIT(targets);",
            "static DEFINE_MUTEX(targets_mutex);",
            "",
            "/* protect bpf_iter_link changes */",
            "static DEFINE_MUTEX(link_mutex);",
            "",
            "/* incremented on every opened seq_file */",
            "static atomic64_t session_id;",
            "",
            "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,",
            "\t\t\t    const struct bpf_iter_seq_info *seq_info);",
            ""
          ],
          "function_name": null,
          "description": "声明BPF迭代器相关结构体及全局变量，定义用于管理迭代器目标信息、链接和私有数据的结构体，并初始化保护目标列表的互斥锁和会话ID原子变量。",
          "similarity": 0.47615668177604675
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 256,
          "end_line": 360,
          "content": [
            "static int iter_open(struct inode *inode, struct file *file)",
            "{",
            "\tstruct bpf_iter_link *link = inode->i_private;",
            "",
            "\treturn prepare_seq_file(file, link, __get_seq_info(link));",
            "}",
            "static int iter_release(struct inode *inode, struct file *file)",
            "{",
            "\tstruct bpf_iter_priv_data *iter_priv;",
            "\tstruct seq_file *seq;",
            "",
            "\tseq = file->private_data;",
            "\tif (!seq)",
            "\t\treturn 0;",
            "",
            "\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,",
            "\t\t\t\t target_private);",
            "",
            "\tif (iter_priv->seq_info->fini_seq_private)",
            "\t\titer_priv->seq_info->fini_seq_private(seq->private);",
            "",
            "\tbpf_prog_put(iter_priv->prog);",
            "\tseq->private = iter_priv;",
            "",
            "\treturn seq_release_private(inode, file);",
            "}",
            "int bpf_iter_reg_target(const struct bpf_iter_reg *reg_info)",
            "{",
            "\tstruct bpf_iter_target_info *tinfo;",
            "",
            "\ttinfo = kzalloc(sizeof(*tinfo), GFP_KERNEL);",
            "\tif (!tinfo)",
            "\t\treturn -ENOMEM;",
            "",
            "\ttinfo->reg_info = reg_info;",
            "\tINIT_LIST_HEAD(&tinfo->list);",
            "",
            "\tmutex_lock(&targets_mutex);",
            "\tlist_add(&tinfo->list, &targets);",
            "\tmutex_unlock(&targets_mutex);",
            "",
            "\treturn 0;",
            "}",
            "void bpf_iter_unreg_target(const struct bpf_iter_reg *reg_info)",
            "{",
            "\tstruct bpf_iter_target_info *tinfo;",
            "\tbool found = false;",
            "",
            "\tmutex_lock(&targets_mutex);",
            "\tlist_for_each_entry(tinfo, &targets, list) {",
            "\t\tif (reg_info == tinfo->reg_info) {",
            "\t\t\tlist_del(&tinfo->list);",
            "\t\t\tkfree(tinfo);",
            "\t\t\tfound = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&targets_mutex);",
            "",
            "\tWARN_ON(found == false);",
            "}",
            "static void cache_btf_id(struct bpf_iter_target_info *tinfo,",
            "\t\t\t struct bpf_prog *prog)",
            "{",
            "\ttinfo->btf_id = prog->aux->attach_btf_id;",
            "}",
            "int bpf_iter_prog_supported(struct bpf_prog *prog)",
            "{",
            "\tconst char *attach_fname = prog->aux->attach_func_name;",
            "\tstruct bpf_iter_target_info *tinfo = NULL, *iter;",
            "\tu32 prog_btf_id = prog->aux->attach_btf_id;",
            "\tconst char *prefix = BPF_ITER_FUNC_PREFIX;",
            "\tint prefix_len = strlen(prefix);",
            "",
            "\tif (strncmp(attach_fname, prefix, prefix_len))",
            "\t\treturn -EINVAL;",
            "",
            "\tmutex_lock(&targets_mutex);",
            "\tlist_for_each_entry(iter, &targets, list) {",
            "\t\tif (iter->btf_id && iter->btf_id == prog_btf_id) {",
            "\t\t\ttinfo = iter;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (!strcmp(attach_fname + prefix_len, iter->reg_info->target)) {",
            "\t\t\tcache_btf_id(iter, prog);",
            "\t\t\ttinfo = iter;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&targets_mutex);",
            "",
            "\tif (!tinfo)",
            "\t\treturn -EINVAL;",
            "",
            "\treturn bpf_prog_ctx_arg_info_init(prog, tinfo->reg_info->ctx_arg_info,",
            "\t\t\t\t\t  tinfo->reg_info->ctx_arg_info_size);",
            "}",
            "static void bpf_iter_link_release(struct bpf_link *link)",
            "{",
            "\tstruct bpf_iter_link *iter_link =",
            "\t\tcontainer_of(link, struct bpf_iter_link, link);",
            "",
            "\tif (iter_link->tinfo->reg_info->detach_target)",
            "\t\titer_link->tinfo->reg_info->detach_target(&iter_link->aux);",
            "}"
          ],
          "function_name": "iter_open, iter_release, bpf_iter_reg_target, bpf_iter_unreg_target, cache_btf_id, bpf_iter_prog_supported, bpf_iter_link_release",
          "description": "提供BPF迭代器目标注册/注销接口，实现BTF ID缓存、程序兼容性校验及链接释放逻辑，用于管理迭代器目标信息和清理资源。",
          "similarity": 0.4492308497428894
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 577,
          "end_line": 699,
          "content": [
            "static void init_seq_meta(struct bpf_iter_priv_data *priv_data,",
            "\t\t\t  struct bpf_iter_target_info *tinfo,",
            "\t\t\t  const struct bpf_iter_seq_info *seq_info,",
            "\t\t\t  struct bpf_prog *prog)",
            "{",
            "\tpriv_data->tinfo = tinfo;",
            "\tpriv_data->seq_info = seq_info;",
            "\tpriv_data->prog = prog;",
            "\tpriv_data->session_id = atomic64_inc_return(&session_id);",
            "\tpriv_data->seq_num = 0;",
            "\tpriv_data->done_stop = false;",
            "}",
            "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,",
            "\t\t\t    const struct bpf_iter_seq_info *seq_info)",
            "{",
            "\tstruct bpf_iter_priv_data *priv_data;",
            "\tstruct bpf_iter_target_info *tinfo;",
            "\tstruct bpf_prog *prog;",
            "\tu32 total_priv_dsize;",
            "\tstruct seq_file *seq;",
            "\tint err = 0;",
            "",
            "\tmutex_lock(&link_mutex);",
            "\tprog = link->link.prog;",
            "\tbpf_prog_inc(prog);",
            "\tmutex_unlock(&link_mutex);",
            "",
            "\ttinfo = link->tinfo;",
            "\ttotal_priv_dsize = offsetof(struct bpf_iter_priv_data, target_private) +",
            "\t\t\t   seq_info->seq_priv_size;",
            "\tpriv_data = __seq_open_private(file, seq_info->seq_ops,",
            "\t\t\t\t       total_priv_dsize);",
            "\tif (!priv_data) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto release_prog;",
            "\t}",
            "",
            "\tif (seq_info->init_seq_private) {",
            "\t\terr = seq_info->init_seq_private(priv_data->target_private, &link->aux);",
            "\t\tif (err)",
            "\t\t\tgoto release_seq_file;",
            "\t}",
            "",
            "\tinit_seq_meta(priv_data, tinfo, seq_info, prog);",
            "\tseq = file->private_data;",
            "\tseq->private = priv_data->target_private;",
            "",
            "\treturn 0;",
            "",
            "release_seq_file:",
            "\tseq_release_private(file->f_inode, file);",
            "\tfile->private_data = NULL;",
            "release_prog:",
            "\tbpf_prog_put(prog);",
            "\treturn err;",
            "}",
            "int bpf_iter_new_fd(struct bpf_link *link)",
            "{",
            "\tstruct bpf_iter_link *iter_link;",
            "\tstruct file *file;",
            "\tunsigned int flags;",
            "\tint err, fd;",
            "",
            "\tif (link->ops != &bpf_iter_link_lops)",
            "\t\treturn -EINVAL;",
            "",
            "\tflags = O_RDONLY | O_CLOEXEC;",
            "\tfd = get_unused_fd_flags(flags);",
            "\tif (fd < 0)",
            "\t\treturn fd;",
            "",
            "\tfile = anon_inode_getfile(\"bpf_iter\", &bpf_iter_fops, NULL, flags);",
            "\tif (IS_ERR(file)) {",
            "\t\terr = PTR_ERR(file);",
            "\t\tgoto free_fd;",
            "\t}",
            "",
            "\titer_link = container_of(link, struct bpf_iter_link, link);",
            "\terr = prepare_seq_file(file, iter_link, __get_seq_info(iter_link));",
            "\tif (err)",
            "\t\tgoto free_file;",
            "",
            "\tfd_install(fd, file);",
            "\treturn fd;",
            "",
            "free_file:",
            "\tfput(file);",
            "free_fd:",
            "\tput_unused_fd(fd);",
            "\treturn err;",
            "}",
            "int bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)",
            "{",
            "\tstruct bpf_run_ctx run_ctx, *old_run_ctx;",
            "\tint ret;",
            "",
            "\tif (prog->sleepable) {",
            "\t\trcu_read_lock_trace();",
            "\t\tmigrate_disable();",
            "\t\tmight_fault();",
            "\t\told_run_ctx = bpf_set_run_ctx(&run_ctx);",
            "\t\tret = bpf_prog_run(prog, ctx);",
            "\t\tbpf_reset_run_ctx(old_run_ctx);",
            "\t\tmigrate_enable();",
            "\t\trcu_read_unlock_trace();",
            "\t} else {",
            "\t\trcu_read_lock();",
            "\t\tmigrate_disable();",
            "\t\told_run_ctx = bpf_set_run_ctx(&run_ctx);",
            "\t\tret = bpf_prog_run(prog, ctx);",
            "\t\tbpf_reset_run_ctx(old_run_ctx);",
            "\t\tmigrate_enable();",
            "\t\trcu_read_unlock();",
            "\t}",
            "",
            "\t/* bpf program can only return 0 or 1:",
            "\t *  0 : okay",
            "\t *  1 : retry the same object",
            "\t * The bpf_iter_run_prog() return value",
            "\t * will be seq_ops->show() return value.",
            "\t */",
            "\treturn ret == 0 ? 0 : -EAGAIN;",
            "}"
          ],
          "function_name": "init_seq_meta, prepare_seq_file, bpf_iter_new_fd, bpf_iter_run_prog",
          "description": "实现序列文件元数据初始化、迭代器文件创建和BPF程序执行逻辑，通过prepare_seq_file准备序列上下文，bpf_iter_run_prog执行程序并根据返回值控制迭代行为。",
          "similarity": 0.4462071359157562
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 786,
          "end_line": 821,
          "content": [
            "__bpf_kfunc int bpf_iter_num_new(struct bpf_iter_num *it, int start, int end)",
            "{",
            "\tstruct bpf_iter_num_kern *s = (void *)it;",
            "",
            "\tBUILD_BUG_ON(sizeof(struct bpf_iter_num_kern) != sizeof(struct bpf_iter_num));",
            "\tBUILD_BUG_ON(__alignof__(struct bpf_iter_num_kern) != __alignof__(struct bpf_iter_num));",
            "",
            "\t/* start == end is legit, it's an empty range and we'll just get NULL",
            "\t * on first (and any subsequent) bpf_iter_num_next() call",
            "\t */",
            "\tif (start > end) {",
            "\t\ts->cur = s->end = 0;",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* avoid overflows, e.g., if start == INT_MIN and end == INT_MAX */",
            "\tif ((s64)end - (s64)start > BPF_MAX_LOOPS) {",
            "\t\ts->cur = s->end = 0;",
            "\t\treturn -E2BIG;",
            "\t}",
            "",
            "\t/* user will call bpf_iter_num_next() first,",
            "\t * which will set s->cur to exactly start value;",
            "\t * underflow shouldn't matter",
            "\t */",
            "\ts->cur = start - 1;",
            "\ts->end = end;",
            "",
            "\treturn 0;",
            "}",
            "__bpf_kfunc void bpf_iter_num_destroy(struct bpf_iter_num *it)",
            "{",
            "\tstruct bpf_iter_num_kern *s = (void *)it;",
            "",
            "\ts->cur = s->end = 0;",
            "}"
          ],
          "function_name": "bpf_iter_num_new, bpf_iter_num_destroy",
          "description": "该代码段实现了BPF数值范围迭代器的创建与销毁功能。`bpf_iter_num_new`用于初始化一个指定起始/终止值的迭代器对象并进行边界检查，`bpf_iter_num_destroy`负责清空迭代器状态。因上下文不完整，未展示迭代器实际遍历逻辑及配套API。",
          "similarity": 0.41871094703674316
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/bpf_iter.c",
          "start_line": 44,
          "end_line": 226,
          "content": [
            "static void bpf_iter_inc_seq_num(struct seq_file *seq)",
            "{",
            "\tstruct bpf_iter_priv_data *iter_priv;",
            "",
            "\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,",
            "\t\t\t\t target_private);",
            "\titer_priv->seq_num++;",
            "}",
            "static void bpf_iter_dec_seq_num(struct seq_file *seq)",
            "{",
            "\tstruct bpf_iter_priv_data *iter_priv;",
            "",
            "\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,",
            "\t\t\t\t target_private);",
            "\titer_priv->seq_num--;",
            "}",
            "static void bpf_iter_done_stop(struct seq_file *seq)",
            "{",
            "\tstruct bpf_iter_priv_data *iter_priv;",
            "",
            "\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,",
            "\t\t\t\t target_private);",
            "\titer_priv->done_stop = true;",
            "}",
            "static inline bool bpf_iter_target_support_resched(const struct bpf_iter_target_info *tinfo)",
            "{",
            "\treturn tinfo->reg_info->feature & BPF_ITER_RESCHED;",
            "}",
            "static bool bpf_iter_support_resched(struct seq_file *seq)",
            "{",
            "\tstruct bpf_iter_priv_data *iter_priv;",
            "",
            "\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,",
            "\t\t\t\t target_private);",
            "\treturn bpf_iter_target_support_resched(iter_priv->tinfo);",
            "}",
            "static ssize_t bpf_seq_read(struct file *file, char __user *buf, size_t size,",
            "\t\t\t    loff_t *ppos)",
            "{",
            "\tstruct seq_file *seq = file->private_data;",
            "\tsize_t n, offs, copied = 0;",
            "\tint err = 0, num_objs = 0;",
            "\tbool can_resched;",
            "\tvoid *p;",
            "",
            "\tmutex_lock(&seq->lock);",
            "",
            "\tif (!seq->buf) {",
            "\t\tseq->size = PAGE_SIZE << 3;",
            "\t\tseq->buf = kvmalloc(seq->size, GFP_KERNEL);",
            "\t\tif (!seq->buf) {",
            "\t\t\terr = -ENOMEM;",
            "\t\t\tgoto done;",
            "\t\t}",
            "\t}",
            "",
            "\tif (seq->count) {",
            "\t\tn = min(seq->count, size);",
            "\t\terr = copy_to_user(buf, seq->buf + seq->from, n);",
            "\t\tif (err) {",
            "\t\t\terr = -EFAULT;",
            "\t\t\tgoto done;",
            "\t\t}",
            "\t\tseq->count -= n;",
            "\t\tseq->from += n;",
            "\t\tcopied = n;",
            "\t\tgoto done;",
            "\t}",
            "",
            "\tseq->from = 0;",
            "\tp = seq->op->start(seq, &seq->index);",
            "\tif (!p)",
            "\t\tgoto stop;",
            "\tif (IS_ERR(p)) {",
            "\t\terr = PTR_ERR(p);",
            "\t\tseq->op->stop(seq, p);",
            "\t\tseq->count = 0;",
            "\t\tgoto done;",
            "\t}",
            "",
            "\terr = seq->op->show(seq, p);",
            "\tif (err > 0) {",
            "\t\t/* object is skipped, decrease seq_num, so next",
            "\t\t * valid object can reuse the same seq_num.",
            "\t\t */",
            "\t\tbpf_iter_dec_seq_num(seq);",
            "\t\tseq->count = 0;",
            "\t} else if (err < 0 || seq_has_overflowed(seq)) {",
            "\t\tif (!err)",
            "\t\t\terr = -E2BIG;",
            "\t\tseq->op->stop(seq, p);",
            "\t\tseq->count = 0;",
            "\t\tgoto done;",
            "\t}",
            "",
            "\tcan_resched = bpf_iter_support_resched(seq);",
            "\twhile (1) {",
            "\t\tloff_t pos = seq->index;",
            "",
            "\t\tnum_objs++;",
            "\t\toffs = seq->count;",
            "\t\tp = seq->op->next(seq, p, &seq->index);",
            "\t\tif (pos == seq->index) {",
            "\t\t\tpr_info_ratelimited(\"buggy seq_file .next function %ps \"",
            "\t\t\t\t\"did not updated position index\\n\",",
            "\t\t\t\tseq->op->next);",
            "\t\t\tseq->index++;",
            "\t\t}",
            "",
            "\t\tif (IS_ERR_OR_NULL(p))",
            "\t\t\tbreak;",
            "",
            "\t\t/* got a valid next object, increase seq_num */",
            "\t\tbpf_iter_inc_seq_num(seq);",
            "",
            "\t\tif (seq->count >= size)",
            "\t\t\tbreak;",
            "",
            "\t\tif (num_objs >= MAX_ITER_OBJECTS) {",
            "\t\t\tif (offs == 0) {",
            "\t\t\t\terr = -EAGAIN;",
            "\t\t\t\tseq->op->stop(seq, p);",
            "\t\t\t\tgoto done;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\terr = seq->op->show(seq, p);",
            "\t\tif (err > 0) {",
            "\t\t\tbpf_iter_dec_seq_num(seq);",
            "\t\t\tseq->count = offs;",
            "\t\t} else if (err < 0 || seq_has_overflowed(seq)) {",
            "\t\t\tseq->count = offs;",
            "\t\t\tif (offs == 0) {",
            "\t\t\t\tif (!err)",
            "\t\t\t\t\terr = -E2BIG;",
            "\t\t\t\tseq->op->stop(seq, p);",
            "\t\t\t\tgoto done;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\tif (can_resched)",
            "\t\t\tcond_resched();",
            "\t}",
            "stop:",
            "\toffs = seq->count;",
            "\tif (IS_ERR(p)) {",
            "\t\tseq->op->stop(seq, NULL);",
            "\t\terr = PTR_ERR(p);",
            "\t\tgoto done;",
            "\t}",
            "\t/* bpf program called if !p */",
            "\tseq->op->stop(seq, p);",
            "\tif (!p) {",
            "\t\tif (!seq_has_overflowed(seq)) {",
            "\t\t\tbpf_iter_done_stop(seq);",
            "\t\t} else {",
            "\t\t\tseq->count = offs;",
            "\t\t\tif (offs == 0) {",
            "\t\t\t\terr = -E2BIG;",
            "\t\t\t\tgoto done;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tn = min(seq->count, size);",
            "\terr = copy_to_user(buf, seq->buf, n);",
            "\tif (err) {",
            "\t\terr = -EFAULT;",
            "\t\tgoto done;",
            "\t}",
            "\tcopied = n;",
            "\tseq->count -= n;",
            "\tseq->from = n;",
            "done:",
            "\tif (!copied)",
            "\t\tcopied = err;",
            "\telse",
            "\t\t*ppos += copied;",
            "\tmutex_unlock(&seq->lock);",
            "\treturn copied;",
            "}"
          ],
          "function_name": "bpf_iter_inc_seq_num, bpf_iter_dec_seq_num, bpf_iter_done_stop, bpf_iter_target_support_resched, bpf_iter_support_resched, bpf_seq_read",
          "description": "实现BPF迭代器的序列文件操作辅助函数，包含计数器增减、支持重新调度判断和seq_read方法，通过维护seq_num和done_stop标志控制迭代流程并处理对象展示。",
          "similarity": 0.4048153758049011
        }
      ]
    },
    {
      "source_file": "kernel/bpf/bpf_local_storage.c",
      "md_summary": "> 自动生成时间: 2025-10-25 11:58:54\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\bpf_local_storage.c`\n\n---\n\n# bpf_local_storage.c 技术文档\n\n## 文件概述\n\n`bpf_local_storage.c` 实现了 BPF（Berkeley Packet Filter）本地存储（local storage）机制的核心功能。该机制允许 BPF 程序为内核对象（如 socket、task 等）动态关联私有数据，实现高效、安全的 per-object 存储管理。文件提供了存储元素（`bpf_local_storage_elem`）和存储容器（`bpf_local_storage`）的分配、释放、链接管理以及内存回收机制，并支持与 BPF 内存分配器（`bpf_mem_alloc`）集成以提升性能。\n\n## 核心功能\n\n### 主要数据结构\n- `struct bpf_local_storage_elem`：BPF 本地存储元素，包含指向 map、owner 和实际数据的指针\n- `struct bpf_local_storage`：BPF 本地存储容器，用于管理特定 owner 的所有存储元素\n- `struct bpf_local_storage_map`：扩展的 BPF map 类型，用于管理本地存储\n\n### 主要函数\n- `bpf_selem_alloc()`：分配并初始化 BPF 本地存储元素\n- `bpf_selem_free()`：释放 BPF 本地存储元素\n- `bpf_local_storage_free()`：释放 BPF 本地存储容器\n- `select_bucket()`：根据存储元素选择哈希桶\n- `mem_charge()` / `mem_uncharge()`：内存资源计费/释放\n- `owner_storage()`：获取 owner 对象的存储指针\n- `selem_linked_to_*()`：检查存储元素的链接状态\n\n## 关键实现\n\n### 内存管理策略\n- 支持两种内存分配模式：传统 `bpf_map_kzalloc` 和高性能 `bpf_mem_cache_alloc`\n- 通过 `smap->bpf_ma` 标志区分是否使用 BPF 内存分配器\n- 实现了精细的内存计费机制，通过 `map_local_storage_charge/uncharge` 回调\n\n### RCU 安全回收机制\n- 针对不同场景实现多种 RCU 回收策略：\n  - 普通 RCU (`call_rcu`)\n  - RCU Tasks Trace (`call_rcu_tasks_trace`)\n  - 直接释放（`reuse_now` 模式）\n- 根据 `rcu_trace_implies_rcu_gp()` 动态选择合适的释放方式\n- 支持立即重用模式（`reuse_now`），在对象销毁时直接回收内存\n\n### 存储元素管理\n- 使用哈希表组织存储元素，通过 `hash_ptr()` 计算桶位置\n- 通过 `hlist_unhashed()` 检查元素是否已链接到存储结构\n- 实现了安全的双向链接管理（map 链和 storage 链）\n\n### 对象生命周期管理\n- 在分配时支持值初始化和 uptr 交换\n- 释放时正确处理 BPF 对象字段的清理（`bpf_obj_free_fields`）\n- 支持克隆操作（通过 `BPF_F_CLONE` 标志）\n\n## 依赖关系\n\n### 内核头文件依赖\n- **RCU 相关**：`<linux/rculist.h>`, `<linux/rcupdate.h>`, `<linux/rcupdate_trace.h>`\n- **数据结构**：`<linux/list.h>`, `<linux/hash.h>`, `<linux/spinlock.h>`\n- **BPF 核心**：`<linux/bpf.h>`, `<linux/bpf_local_storage.h>`, `<linux/btf_ids.h>`\n- **网络子系统**：`<net/sock.h>`, `<uapi/linux/sock_diag.h>`\n- **内存管理**：`<linux/bpf_mem_alloc.h>`（隐式通过 bpf_mem_cache_* 函数）\n\n### 功能依赖\n- 依赖 BPF map 操作接口（`map->ops->map_owner_storage_ptr` 等）\n- 依赖 BPF 内存分配器（`bpf_mem_cache_*` 系列函数）\n- 依赖 BPF 对象引用管理（`bpf_obj_free_fields`, `bpf_obj_swap_uptrs`）\n\n## 使用场景\n\n### BPF 程序数据存储\n- BPF 程序需要为特定内核对象（如 socket、task）维护私有状态信息\n- 通过 `bpf_sk_storage_get()` 等 helper 函数访问本地存储\n\n### 网络监控和跟踪\n- Socket 本地存储用于网络连接的 per-socket 状态跟踪\n- Task 本地存储用于进程级别的监控和策略实施\n\n### 性能关键路径\n- 在高性能网络数据路径中，通过预分配和内存池减少分配开销\n- 利用 RCU Tasks Trace 实现低延迟的内存回收\n\n### 资源隔离和计费\n- 为不同 BPF map 实例提供独立的内存计费\n- 防止恶意 BPF 程序耗尽系统内存资源\n\n### 对象生命周期集成\n- 与内核对象（socket、task）的销毁流程紧密集成\n- 确保在对象销毁时正确清理关联的 BPF 存储数据",
      "similarity": 0.5202521681785583,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/bpf_local_storage.c",
          "start_line": 1,
          "end_line": 26,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Copyright (c) 2019 Facebook  */",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bpf.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <net/sock.h>",
            "#include <uapi/linux/sock_diag.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate_wait.h>",
            "",
            "#define BPF_LOCAL_STORAGE_CREATE_FLAG_MASK (BPF_F_NO_PREALLOC | BPF_F_CLONE)",
            "",
            "static struct bpf_local_storage_map_bucket *",
            "select_bucket(struct bpf_local_storage_map *smap,",
            "\t      struct bpf_local_storage_elem *selem)",
            "{",
            "\treturn &smap->buckets[hash_ptr(selem, smap->bucket_log)];",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义BPF本地存储相关头文件和宏，提供`select_bucket`函数用于根据元素哈希值选择对应的桶结构。",
          "similarity": 0.552768886089325
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/bpf_local_storage.c",
          "start_line": 730,
          "end_line": 892,
          "content": [
            "static void bpf_local_storage_cache_idx_free(struct bpf_local_storage_cache *cache,",
            "\t\t\t\t\t     u16 idx)",
            "{",
            "\tspin_lock(&cache->idx_lock);",
            "\tcache->idx_usage_counts[idx]--;",
            "\tspin_unlock(&cache->idx_lock);",
            "}",
            "int bpf_local_storage_map_alloc_check(union bpf_attr *attr)",
            "{",
            "\tif (attr->map_flags & ~BPF_LOCAL_STORAGE_CREATE_FLAG_MASK ||",
            "\t    !(attr->map_flags & BPF_F_NO_PREALLOC) ||",
            "\t    attr->max_entries ||",
            "\t    attr->key_size != sizeof(int) || !attr->value_size ||",
            "\t    /* Enforce BTF for userspace sk dumping */",
            "\t    !attr->btf_key_type_id || !attr->btf_value_type_id)",
            "\t\treturn -EINVAL;",
            "",
            "\tif (attr->value_size > BPF_LOCAL_STORAGE_MAX_VALUE_SIZE)",
            "\t\treturn -E2BIG;",
            "",
            "\treturn 0;",
            "}",
            "int bpf_local_storage_map_check_btf(const struct bpf_map *map,",
            "\t\t\t\t    const struct btf *btf,",
            "\t\t\t\t    const struct btf_type *key_type,",
            "\t\t\t\t    const struct btf_type *value_type)",
            "{",
            "\tu32 int_data;",
            "",
            "\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_INT)",
            "\t\treturn -EINVAL;",
            "",
            "\tint_data = *(u32 *)(key_type + 1);",
            "\tif (BTF_INT_BITS(int_data) != 32 || BTF_INT_OFFSET(int_data))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "void bpf_local_storage_destroy(struct bpf_local_storage *local_storage)",
            "{",
            "\tstruct bpf_local_storage_map *storage_smap;",
            "\tstruct bpf_local_storage_elem *selem;",
            "\tbool bpf_ma, free_storage = false;",
            "\tHLIST_HEAD(free_selem_list);",
            "\tstruct hlist_node *n;",
            "\tunsigned long flags;",
            "",
            "\tstorage_smap = rcu_dereference_check(local_storage->smap, bpf_rcu_lock_held());",
            "\tbpf_ma = check_storage_bpf_ma(local_storage, storage_smap, NULL);",
            "",
            "\t/* Neither the bpf_prog nor the bpf_map's syscall",
            "\t * could be modifying the local_storage->list now.",
            "\t * Thus, no elem can be added to or deleted from the",
            "\t * local_storage->list by the bpf_prog or by the bpf_map's syscall.",
            "\t *",
            "\t * It is racing with bpf_local_storage_map_free() alone",
            "\t * when unlinking elem from the local_storage->list and",
            "\t * the map's bucket->list.",
            "\t */",
            "\traw_spin_lock_irqsave(&local_storage->lock, flags);",
            "\thlist_for_each_entry_safe(selem, n, &local_storage->list, snode) {",
            "\t\t/* Always unlink from map before unlinking from",
            "\t\t * local_storage.",
            "\t\t */",
            "\t\tbpf_selem_unlink_map(selem);",
            "\t\t/* If local_storage list has only one element, the",
            "\t\t * bpf_selem_unlink_storage_nolock() will return true.",
            "\t\t * Otherwise, it will return false. The current loop iteration",
            "\t\t * intends to remove all local storage. So the last iteration",
            "\t\t * of the loop will set the free_cgroup_storage to true.",
            "\t\t */",
            "\t\tfree_storage = bpf_selem_unlink_storage_nolock(",
            "\t\t\tlocal_storage, selem, true, &free_selem_list);",
            "\t}",
            "\traw_spin_unlock_irqrestore(&local_storage->lock, flags);",
            "",
            "\tbpf_selem_free_list(&free_selem_list, true);",
            "",
            "\tif (free_storage)",
            "\t\tbpf_local_storage_free(local_storage, storage_smap, bpf_ma, true);",
            "}",
            "u64 bpf_local_storage_map_mem_usage(const struct bpf_map *map)",
            "{",
            "\tstruct bpf_local_storage_map *smap = (struct bpf_local_storage_map *)map;",
            "\tu64 usage = sizeof(*smap);",
            "",
            "\t/* The dynamically callocated selems are not counted currently. */",
            "\tusage += sizeof(*smap->buckets) * (1ULL << smap->bucket_log);",
            "\treturn usage;",
            "}",
            "void bpf_local_storage_map_free(struct bpf_map *map,",
            "\t\t\t\tstruct bpf_local_storage_cache *cache,",
            "\t\t\t\tint __percpu *busy_counter)",
            "{",
            "\tstruct bpf_local_storage_map_bucket *b;",
            "\tstruct bpf_local_storage_elem *selem;",
            "\tstruct bpf_local_storage_map *smap;",
            "\tunsigned int i;",
            "",
            "\tsmap = (struct bpf_local_storage_map *)map;",
            "\tbpf_local_storage_cache_idx_free(cache, smap->cache_idx);",
            "",
            "\t/* Note that this map might be concurrently cloned from",
            "\t * bpf_sk_storage_clone. Wait for any existing bpf_sk_storage_clone",
            "\t * RCU read section to finish before proceeding. New RCU",
            "\t * read sections should be prevented via bpf_map_inc_not_zero.",
            "\t */",
            "\tsynchronize_rcu();",
            "",
            "\t/* bpf prog and the userspace can no longer access this map",
            "\t * now.  No new selem (of this map) can be added",
            "\t * to the owner->storage or to the map bucket's list.",
            "\t *",
            "\t * The elem of this map can be cleaned up here",
            "\t * or when the storage is freed e.g.",
            "\t * by bpf_sk_storage_free() during __sk_destruct().",
            "\t */",
            "\tfor (i = 0; i < (1U << smap->bucket_log); i++) {",
            "\t\tb = &smap->buckets[i];",
            "",
            "\t\trcu_read_lock();",
            "\t\t/* No one is adding to b->list now */",
            "\t\twhile ((selem = hlist_entry_safe(",
            "\t\t\t\trcu_dereference_raw(hlist_first_rcu(&b->list)),",
            "\t\t\t\tstruct bpf_local_storage_elem, map_node))) {",
            "\t\t\tif (busy_counter) {",
            "\t\t\t\tmigrate_disable();",
            "\t\t\t\tthis_cpu_inc(*busy_counter);",
            "\t\t\t}",
            "\t\t\tbpf_selem_unlink(selem, true);",
            "\t\t\tif (busy_counter) {",
            "\t\t\t\tthis_cpu_dec(*busy_counter);",
            "\t\t\t\tmigrate_enable();",
            "\t\t\t}",
            "\t\t\tcond_resched_rcu();",
            "\t\t}",
            "\t\trcu_read_unlock();",
            "\t}",
            "",
            "\t/* While freeing the storage we may still need to access the map.",
            "\t *",
            "\t * e.g. when bpf_sk_storage_free() has unlinked selem from the map",
            "\t * which then made the above while((selem = ...)) loop",
            "\t * exit immediately.",
            "\t *",
            "\t * However, while freeing the storage one still needs to access the",
            "\t * smap->elem_size to do the uncharging in",
            "\t * bpf_selem_unlink_storage_nolock().",
            "\t *",
            "\t * Hence, wait another rcu grace period for the storage to be freed.",
            "\t */",
            "\tsynchronize_rcu();",
            "",
            "\tif (smap->bpf_ma) {",
            "\t\trcu_barrier_tasks_trace();",
            "\t\tif (!rcu_trace_implies_rcu_gp())",
            "\t\t\trcu_barrier();",
            "\t\tbpf_mem_alloc_destroy(&smap->selem_ma);",
            "\t\tbpf_mem_alloc_destroy(&smap->storage_ma);",
            "\t}",
            "\tkvfree(smap->buckets);",
            "\tbpf_map_area_free(smap);",
            "}"
          ],
          "function_name": "bpf_local_storage_cache_idx_free, bpf_local_storage_map_alloc_check, bpf_local_storage_map_check_btf, bpf_local_storage_destroy, bpf_local_storage_map_mem_usage, bpf_local_storage_map_free",
          "description": "该代码块实现BPF本地存储模块的内存管理和资源释放逻辑，核心功能包含参数校验、BTF类型验证、元素清理及内存统计。  \n`bpf_local_storage_map_alloc_check` 和 `bpf_local_storage_map_check_btf` 分别用于验证创建参数合法性及BTF类型约束，而 `bpf_local_storage_destroy` 通过RCU机制安全遍历并销毁存储元素。  \n部分函数依赖未展示的辅助函数（如 `bpf_selem_unlink_map`），且涉及复杂RCU同步策略，上下文存在一定缺失。",
          "similarity": 0.4179713726043701
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/bpf_local_storage.c",
          "start_line": 499,
          "end_line": 605,
          "content": [
            "static int check_flags(const struct bpf_local_storage_data *old_sdata,",
            "\t\t       u64 map_flags)",
            "{",
            "\tif (old_sdata && (map_flags & ~BPF_F_LOCK) == BPF_NOEXIST)",
            "\t\t/* elem already exists */",
            "\t\treturn -EEXIST;",
            "",
            "\tif (!old_sdata && (map_flags & ~BPF_F_LOCK) == BPF_EXIST)",
            "\t\t/* elem doesn't exist, cannot update it */",
            "\t\treturn -ENOENT;",
            "",
            "\treturn 0;",
            "}",
            "int bpf_local_storage_alloc(void *owner,",
            "\t\t\t    struct bpf_local_storage_map *smap,",
            "\t\t\t    struct bpf_local_storage_elem *first_selem,",
            "\t\t\t    gfp_t gfp_flags)",
            "{",
            "\tstruct bpf_local_storage *prev_storage, *storage;",
            "\tstruct bpf_local_storage **owner_storage_ptr;",
            "\tint err;",
            "",
            "\terr = mem_charge(smap, owner, sizeof(*storage));",
            "\tif (err)",
            "\t\treturn err;",
            "",
            "\tif (smap->bpf_ma) {",
            "\t\tmigrate_disable();",
            "\t\tstorage = bpf_mem_cache_alloc_flags(&smap->storage_ma, gfp_flags);",
            "\t\tmigrate_enable();",
            "\t} else {",
            "\t\tstorage = bpf_map_kzalloc(&smap->map, sizeof(*storage),",
            "\t\t\t\t\t  gfp_flags | __GFP_NOWARN);",
            "\t}",
            "",
            "\tif (!storage) {",
            "\t\terr = -ENOMEM;",
            "\t\tgoto uncharge;",
            "\t}",
            "",
            "\tRCU_INIT_POINTER(storage->smap, smap);",
            "\tINIT_HLIST_HEAD(&storage->list);",
            "\traw_spin_lock_init(&storage->lock);",
            "\tstorage->owner = owner;",
            "",
            "\tbpf_selem_link_storage_nolock(storage, first_selem);",
            "\tbpf_selem_link_map(smap, first_selem);",
            "",
            "\towner_storage_ptr =",
            "\t\t(struct bpf_local_storage **)owner_storage(smap, owner);",
            "\t/* Publish storage to the owner.",
            "\t * Instead of using any lock of the kernel object (i.e. owner),",
            "\t * cmpxchg will work with any kernel object regardless what",
            "\t * the running context is, bh, irq...etc.",
            "\t *",
            "\t * From now on, the owner->storage pointer (e.g. sk->sk_bpf_storage)",
            "\t * is protected by the storage->lock.  Hence, when freeing",
            "\t * the owner->storage, the storage->lock must be held before",
            "\t * setting owner->storage ptr to NULL.",
            "\t */",
            "\tprev_storage = cmpxchg(owner_storage_ptr, NULL, storage);",
            "\tif (unlikely(prev_storage)) {",
            "\t\tbpf_selem_unlink_map(first_selem);",
            "\t\terr = -EAGAIN;",
            "\t\tgoto uncharge;",
            "",
            "\t\t/* Note that even first_selem was linked to smap's",
            "\t\t * bucket->list, first_selem can be freed immediately",
            "\t\t * (instead of kfree_rcu) because",
            "\t\t * bpf_local_storage_map_free() does a",
            "\t\t * synchronize_rcu_mult (waiting for both sleepable and",
            "\t\t * normal programs) before walking the bucket->list.",
            "\t\t * Hence, no one is accessing selem from the",
            "\t\t * bucket->list under rcu_read_lock().",
            "\t\t */",
            "\t}",
            "",
            "\treturn 0;",
            "",
            "uncharge:",
            "\tbpf_local_storage_free(storage, smap, smap->bpf_ma, true);",
            "\tmem_uncharge(smap, owner, sizeof(*storage));",
            "\treturn err;",
            "}",
            "static u16 bpf_local_storage_cache_idx_get(struct bpf_local_storage_cache *cache)",
            "{",
            "\tu64 min_usage = U64_MAX;",
            "\tu16 i, res = 0;",
            "",
            "\tspin_lock(&cache->idx_lock);",
            "",
            "\tfor (i = 0; i < BPF_LOCAL_STORAGE_CACHE_SIZE; i++) {",
            "\t\tif (cache->idx_usage_counts[i] < min_usage) {",
            "\t\t\tmin_usage = cache->idx_usage_counts[i];",
            "\t\t\tres = i;",
            "",
            "\t\t\t/* Found a free cache_idx */",
            "\t\t\tif (!min_usage)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\tcache->idx_usage_counts[res]++;",
            "",
            "\tspin_unlock(&cache->idx_lock);",
            "",
            "\treturn res;",
            "}"
          ],
          "function_name": "check_flags, bpf_local_storage_alloc, bpf_local_storage_cache_idx_get",
          "description": "提供本地存储分配接口和缓存索引分配算法，包含冲突检测逻辑和基于内存缓存的分配实现。",
          "similarity": 0.3884555399417877
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/bpf_local_storage.c",
          "start_line": 343,
          "end_line": 449,
          "content": [
            "static bool check_storage_bpf_ma(struct bpf_local_storage *local_storage,",
            "\t\t\t\t struct bpf_local_storage_map *storage_smap,",
            "\t\t\t\t struct bpf_local_storage_elem *selem)",
            "{",
            "",
            "\tstruct bpf_local_storage_map *selem_smap;",
            "",
            "\t/* local_storage->smap may be NULL. If it is, get the bpf_ma",
            "\t * from any selem in the local_storage->list. The bpf_ma of all",
            "\t * local_storage and selem should have the same value",
            "\t * for the same map type.",
            "\t *",
            "\t * If the local_storage->list is already empty, the caller will not",
            "\t * care about the bpf_ma value also because the caller is not",
            "\t * responsibile to free the local_storage.",
            "\t */",
            "",
            "\tif (storage_smap)",
            "\t\treturn storage_smap->bpf_ma;",
            "",
            "\tif (!selem) {",
            "\t\tstruct hlist_node *n;",
            "",
            "\t\tn = rcu_dereference_check(hlist_first_rcu(&local_storage->list),",
            "\t\t\t\t\t  bpf_rcu_lock_held());",
            "\t\tif (!n)",
            "\t\t\treturn false;",
            "",
            "\t\tselem = hlist_entry(n, struct bpf_local_storage_elem, snode);",
            "\t}",
            "\tselem_smap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());",
            "",
            "\treturn selem_smap->bpf_ma;",
            "}",
            "static void bpf_selem_unlink_storage(struct bpf_local_storage_elem *selem,",
            "\t\t\t\t     bool reuse_now)",
            "{",
            "\tstruct bpf_local_storage_map *storage_smap;",
            "\tstruct bpf_local_storage *local_storage;",
            "\tbool bpf_ma, free_local_storage = false;",
            "\tHLIST_HEAD(selem_free_list);",
            "\tunsigned long flags;",
            "",
            "\tif (unlikely(!selem_linked_to_storage_lockless(selem)))",
            "\t\t/* selem has already been unlinked from sk */",
            "\t\treturn;",
            "",
            "\tlocal_storage = rcu_dereference_check(selem->local_storage,",
            "\t\t\t\t\t      bpf_rcu_lock_held());",
            "\tstorage_smap = rcu_dereference_check(local_storage->smap,",
            "\t\t\t\t\t     bpf_rcu_lock_held());",
            "\tbpf_ma = check_storage_bpf_ma(local_storage, storage_smap, selem);",
            "",
            "\traw_spin_lock_irqsave(&local_storage->lock, flags);",
            "\tif (likely(selem_linked_to_storage(selem)))",
            "\t\tfree_local_storage = bpf_selem_unlink_storage_nolock(",
            "\t\t\tlocal_storage, selem, true, &selem_free_list);",
            "\traw_spin_unlock_irqrestore(&local_storage->lock, flags);",
            "",
            "\tbpf_selem_free_list(&selem_free_list, reuse_now);",
            "",
            "\tif (free_local_storage)",
            "\t\tbpf_local_storage_free(local_storage, storage_smap, bpf_ma, reuse_now);",
            "}",
            "void bpf_selem_link_storage_nolock(struct bpf_local_storage *local_storage,",
            "\t\t\t\t   struct bpf_local_storage_elem *selem)",
            "{",
            "\tRCU_INIT_POINTER(selem->local_storage, local_storage);",
            "\thlist_add_head_rcu(&selem->snode, &local_storage->list);",
            "}",
            "static void bpf_selem_unlink_map(struct bpf_local_storage_elem *selem)",
            "{",
            "\tstruct bpf_local_storage_map *smap;",
            "\tstruct bpf_local_storage_map_bucket *b;",
            "\tunsigned long flags;",
            "",
            "\tif (unlikely(!selem_linked_to_map_lockless(selem)))",
            "\t\t/* selem has already be unlinked from smap */",
            "\t\treturn;",
            "",
            "\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());",
            "\tb = select_bucket(smap, selem);",
            "\traw_spin_lock_irqsave(&b->lock, flags);",
            "\tif (likely(selem_linked_to_map(selem)))",
            "\t\thlist_del_init_rcu(&selem->map_node);",
            "\traw_spin_unlock_irqrestore(&b->lock, flags);",
            "}",
            "void bpf_selem_link_map(struct bpf_local_storage_map *smap,",
            "\t\t\tstruct bpf_local_storage_elem *selem)",
            "{",
            "\tstruct bpf_local_storage_map_bucket *b = select_bucket(smap, selem);",
            "\tunsigned long flags;",
            "",
            "\traw_spin_lock_irqsave(&b->lock, flags);",
            "\tRCU_INIT_POINTER(SDATA(selem)->smap, smap);",
            "\thlist_add_head_rcu(&selem->map_node, &b->list);",
            "\traw_spin_unlock_irqrestore(&b->lock, flags);",
            "}",
            "void bpf_selem_unlink(struct bpf_local_storage_elem *selem, bool reuse_now)",
            "{",
            "\t/* Always unlink from map before unlinking from local_storage",
            "\t * because selem will be freed after successfully unlinked from",
            "\t * the local_storage.",
            "\t */",
            "\tbpf_selem_unlink_map(selem);",
            "\tbpf_selem_unlink_storage(selem, reuse_now);",
            "}"
          ],
          "function_name": "check_storage_bpf_ma, bpf_selem_unlink_storage, bpf_selem_link_storage_nolock, bpf_selem_unlink_map, bpf_selem_link_map, bpf_selem_unlink",
          "description": "实现元素与存储结构的绑定/解除绑定操作，包含RCU锁保护的链表操作和存储结构生命周期管理。",
          "similarity": 0.33722779154777527
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/bpf_local_storage.c",
          "start_line": 203,
          "end_line": 332,
          "content": [
            "static void __bpf_selem_free(struct bpf_local_storage_elem *selem,",
            "\t\t\t     bool vanilla_rcu)",
            "{",
            "\tif (vanilla_rcu)",
            "\t\tkfree_rcu(selem, rcu);",
            "\telse",
            "\t\tcall_rcu_tasks_trace(&selem->rcu, __bpf_selem_free_trace_rcu);",
            "}",
            "static void bpf_selem_free_rcu(struct rcu_head *rcu)",
            "{",
            "\tstruct bpf_local_storage_elem *selem;",
            "\tstruct bpf_local_storage_map *smap;",
            "",
            "\tselem = container_of(rcu, struct bpf_local_storage_elem, rcu);",
            "\t/* The bpf_local_storage_map_free will wait for rcu_barrier */",
            "\tsmap = rcu_dereference_check(SDATA(selem)->smap, 1);",
            "\tbpf_obj_free_fields(smap->map.record, SDATA(selem)->data);",
            "\tbpf_mem_cache_raw_free(selem);",
            "}",
            "static void bpf_selem_free_trace_rcu(struct rcu_head *rcu)",
            "{",
            "\tif (rcu_trace_implies_rcu_gp())",
            "\t\tbpf_selem_free_rcu(rcu);",
            "\telse",
            "\t\tcall_rcu(rcu, bpf_selem_free_rcu);",
            "}",
            "void bpf_selem_free(struct bpf_local_storage_elem *selem,",
            "\t\t    struct bpf_local_storage_map *smap,",
            "\t\t    bool reuse_now)",
            "{",
            "\tif (!smap->bpf_ma) {",
            "\t\t/* Only task storage has uptrs and task storage",
            "\t\t * has moved to bpf_mem_alloc. Meaning smap->bpf_ma == true",
            "\t\t * for task storage, so this bpf_obj_free_fields() won't unpin",
            "\t\t * any uptr.",
            "\t\t */",
            "\t\tbpf_obj_free_fields(smap->map.record, SDATA(selem)->data);",
            "\t\t__bpf_selem_free(selem, reuse_now);",
            "\t\treturn;",
            "\t}",
            "",
            "\tif (reuse_now) {",
            "\t\t/* reuse_now == true only happens when the storage owner",
            "\t\t * (e.g. task_struct) is being destructed or the map itself",
            "\t\t * is being destructed (ie map_free). In both cases,",
            "\t\t * no bpf prog can have a hold on the selem. It is",
            "\t\t * safe to unpin the uptrs and free the selem now.",
            "\t\t */",
            "\t\tbpf_obj_free_fields(smap->map.record, SDATA(selem)->data);",
            "\t\t/* Instead of using the vanilla call_rcu(),",
            "\t\t * bpf_mem_cache_free will be able to reuse selem",
            "\t\t * immediately.",
            "\t\t */",
            "\t\tmigrate_disable();",
            "\t\tbpf_mem_cache_free(&smap->selem_ma, selem);",
            "\t\tmigrate_enable();",
            "\t\treturn;",
            "\t}",
            "",
            "\tcall_rcu_tasks_trace(&selem->rcu, bpf_selem_free_trace_rcu);",
            "}",
            "static void bpf_selem_free_list(struct hlist_head *list, bool reuse_now)",
            "{",
            "\tstruct bpf_local_storage_elem *selem;",
            "\tstruct bpf_local_storage_map *smap;",
            "\tstruct hlist_node *n;",
            "",
            "\t/* The \"_safe\" iteration is needed.",
            "\t * The loop is not removing the selem from the list",
            "\t * but bpf_selem_free will use the selem->rcu_head",
            "\t * which is union-ized with the selem->free_node.",
            "\t */",
            "\thlist_for_each_entry_safe(selem, n, list, free_node) {",
            "\t\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());",
            "\t\tbpf_selem_free(selem, smap, reuse_now);",
            "\t}",
            "}",
            "static bool bpf_selem_unlink_storage_nolock(struct bpf_local_storage *local_storage,",
            "\t\t\t\t\t    struct bpf_local_storage_elem *selem,",
            "\t\t\t\t\t    bool uncharge_mem, struct hlist_head *free_selem_list)",
            "{",
            "\tstruct bpf_local_storage_map *smap;",
            "\tbool free_local_storage;",
            "\tvoid *owner;",
            "",
            "\tsmap = rcu_dereference_check(SDATA(selem)->smap, bpf_rcu_lock_held());",
            "\towner = local_storage->owner;",
            "",
            "\t/* All uncharging on the owner must be done first.",
            "\t * The owner may be freed once the last selem is unlinked",
            "\t * from local_storage.",
            "\t */",
            "\tif (uncharge_mem)",
            "\t\tmem_uncharge(smap, owner, smap->elem_size);",
            "",
            "\tfree_local_storage = hlist_is_singular_node(&selem->snode,",
            "\t\t\t\t\t\t    &local_storage->list);",
            "\tif (free_local_storage) {",
            "\t\tmem_uncharge(smap, owner, sizeof(struct bpf_local_storage));",
            "\t\tlocal_storage->owner = NULL;",
            "",
            "\t\t/* After this RCU_INIT, owner may be freed and cannot be used */",
            "\t\tRCU_INIT_POINTER(*owner_storage(smap, owner), NULL);",
            "",
            "\t\t/* local_storage is not freed now.  local_storage->lock is",
            "\t\t * still held and raw_spin_unlock_bh(&local_storage->lock)",
            "\t\t * will be done by the caller.",
            "\t\t *",
            "\t\t * Although the unlock will be done under",
            "\t\t * rcu_read_lock(),  it is more intuitive to",
            "\t\t * read if the freeing of the storage is done",
            "\t\t * after the raw_spin_unlock_bh(&local_storage->lock).",
            "\t\t *",
            "\t\t * Hence, a \"bool free_local_storage\" is returned",
            "\t\t * to the caller which then calls then frees the storage after",
            "\t\t * all the RCU grace periods have expired.",
            "\t\t */",
            "\t}",
            "\thlist_del_init_rcu(&selem->snode);",
            "\tif (rcu_access_pointer(local_storage->cache[smap->cache_idx]) ==",
            "\t    SDATA(selem))",
            "\t\tRCU_INIT_POINTER(local_storage->cache[smap->cache_idx], NULL);",
            "",
            "\thlist_add_head(&selem->free_node, free_selem_list);",
            "",
            "\tif (rcu_access_pointer(local_storage->smap) == smap)",
            "\t\tRCU_INIT_POINTER(local_storage->smap, NULL);",
            "",
            "\treturn free_local_storage;",
            "}"
          ],
          "function_name": "__bpf_selem_free, bpf_selem_free_rcu, bpf_selem_free_trace_rcu, bpf_selem_free, bpf_selem_free_list, bpf_selem_unlink_storage_nolock",
          "description": "处理元素对象的销毁流程，包含RCU回调函数、缓存复用逻辑及与存储结构的解关联操作。",
          "similarity": 0.33318984508514404
        }
      ]
    }
  ]
}