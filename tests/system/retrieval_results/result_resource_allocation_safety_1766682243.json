{
  "query": "resource allocation safety",
  "timestamp": "2025-12-26 01:04:03",
  "retrieved_files": [
    {
      "source_file": "kernel/cgroup/rdma.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:50:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `cgroup\\rdma.c`\n\n---\n\n# cgroup/rdma.c 技术文档\n\n## 文件概述\n\n`cgroup/rdma.c` 实现了 RDMA（Remote Direct Memory Access）资源限制控制器，作为 cgroup 子系统的一部分。该模块用于限制 cgroup 层级结构中的进程在达到指定资源上限后无法继续消耗额外的 RDMA 资源。通过为每个 cgroup 和每个 RDMA 设备维护资源池，实现对 RDMA 资源（如 HCA 句柄和对象）的精细化配额管理与层级化计费（charge/uncharge）。\n\n## 核心功能\n\n### 主要数据结构\n\n- **`rdmacg_resource`**  \n  表示单个 RDMA 资源类型的使用情况，包含 `max`（最大限额）和 `usage`（当前使用量）。\n\n- **`rdmacg_resource_pool`**  \n  表示一个 cgroup 在特定 RDMA 设备上的资源池，包含：\n  - 指向 `rdmacg_device` 的指针\n  - 各类资源的 `rdmacg_resource` 数组\n  - 双向链表节点（分别链接到 cgroup 和设备的资源池列表）\n  - `usage_sum`：该池中所有资源的总使用计数\n  - `num_max_cnt`：设置为 `S32_MAX`（即无限制）的资源项数量\n\n- **`rdmacg_resource_names`**  \n  用户可见的资源名称映射表，当前支持：\n  - `\"hca_handle\"` → `RDMACG_RESOURCE_HCA_HANDLE`\n  - `\"hca_object\"` → `RDMACG_RESOURCE_HCA_OBJECT`\n\n### 主要函数\n\n- **`rdmacg_try_charge()`**  \n  尝试在 cgroup 层级中为指定 RDMA 设备和资源类型进行资源计费。从当前 cgroup 向上遍历至根，逐级检查并增加使用量。若任一层级超出限额，则回滚并返回 `-EAGAIN`。\n\n- **`rdmacg_uncharge()`**  \n  在 cgroup 层级中释放指定资源的使用量，从当前 cgroup 向上遍历至根，逐级减少使用量。\n\n- **`rdmacg_uncharge_hierarchy()`**  \n  支持在指定停止点（`stop_cg`）前的层级范围内执行资源释放，用于更灵活的资源回收场景。\n\n- **`get_cg_rpool_locked()` / `find_cg_rpool_locked()`**  \n  在加锁状态下查找或创建指定 cgroup 与设备对应的资源池。\n\n- **`free_cg_rpool_locked()`**  \n  当资源池的 `usage_sum` 为 0 且所有资源均设为 `max`（即未显式限制）时，安全释放该资源池。\n\n## 关键实现\n\n### 层级化资源计费机制\n\nRDMA cgroup 采用**自底向上计费、自顶向下限制**的策略：\n- **计费（charge）**：从当前任务所属 cgroup 开始，逐级向上（至根 cgroup）尝试增加资源使用量。任一祖先 cgroup 超限即失败。\n- **释放（uncharge）**：同样沿层级向上释放，确保资源使用量始终反映实际占用。\n\n### 资源池生命周期管理\n\n- 每个 `(cgroup, device)` 对应一个 `rdmacg_resource_pool`。\n- 资源池在首次计费时按需创建（`get_cg_rpool_locked`）。\n- 当 `usage_sum == 0` 且所有资源项均为 `max`（即无显式限制）时，自动释放资源池以节省内存。\n\n### 限额表示\n\n- 使用 `S32_MAX` 表示“无限制”（即 `max` 值）。\n- `num_max_cnt` 用于快速判断是否所有资源均为无限制状态，从而决定是否可安全释放资源池。\n\n### 并发控制\n\n- 全局互斥锁 `rdmacg_mutex` 保护：\n  - 所有 cgroup 的资源池链表（`cg->rpools`）\n  - 所有 RDMA 设备的资源池链表（`device->rpools`）\n  - 全局设备列表 `rdmacg_devices`\n- 所有资源池操作（创建、查找、释放）均在锁保护下进行。\n\n## 依赖关系\n\n- **内核头文件依赖**：\n  - `<linux/cgroup.h>`：cgroup 核心框架\n  - `<linux/cgroup_rdma.h>`：RDMA cgroup 接口定义（如 `rdma_cgroup`、`rdmacg_device` 等）\n  - `<linux/ib_verbs.h>`（隐含）：RDMA 资源类型定义（如 `RDMACG_RESOURCE_HCA_HANDLE`）\n- **导出符号**：\n  - `rdmacg_uncharge()`：供 RDMA 驱动（如 InfiniBand、RoCE 驱动）在释放资源时调用\n- **cgroup 子系统集成**：\n  - 通过 `rdma_cgrp_id` 获取当前任务的 cgroup 上下文\n  - 依赖 cgroup 的层级遍历机制（`css.parent`）\n\n## 使用场景\n\n1. **RDMA 驱动资源分配**  \n   当用户空间应用通过 verbs API 创建 QP、CQ、MR 等对象时，底层驱动调用 `rdmacg_try_charge()` 检查是否允许分配。若成功，则在对象销毁时调用 `rdmacg_uncharge()` 释放配额。\n\n2. **多租户 RDMA 资源隔离**  \n   在容器化或虚拟化环境中，管理员可通过 cgroup v1/v2 接口为不同租户设置 RDMA 资源上限（如最大 HCA 对象数），防止资源耗尽攻击。\n\n3. **动态资源回收**  \n   当 cgroup 中所有任务退出且无 RDMA 资源占用时，自动清理对应的资源池，避免内存泄漏。\n\n4. **层级配额继承**  \n   子 cgroup 的资源使用量计入所有祖先 cgroup，确保父级配额对整个子树生效，实现严格的资源隔离。",
      "similarity": 0.5056235194206238,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/cgroup/rdma.c",
          "start_line": 316,
          "end_line": 464,
          "content": [
            "void rdmacg_register_device(struct rdmacg_device *device)",
            "{",
            "\tINIT_LIST_HEAD(&device->dev_node);",
            "\tINIT_LIST_HEAD(&device->rpools);",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "\tlist_add_tail(&device->dev_node, &rdmacg_devices);",
            "\tmutex_unlock(&rdmacg_mutex);",
            "}",
            "void rdmacg_unregister_device(struct rdmacg_device *device)",
            "{",
            "\tstruct rdmacg_resource_pool *rpool, *tmp;",
            "",
            "\t/*",
            "\t * Synchronize with any active resource settings,",
            "\t * usage query happening via configfs.",
            "\t */",
            "\tmutex_lock(&rdmacg_mutex);",
            "\tlist_del_init(&device->dev_node);",
            "",
            "\t/*",
            "\t * Now that this device is off the cgroup list, its safe to free",
            "\t * all the rpool resources.",
            "\t */",
            "\tlist_for_each_entry_safe(rpool, tmp, &device->rpools, dev_node)",
            "\t\tfree_cg_rpool_locked(rpool);",
            "",
            "\tmutex_unlock(&rdmacg_mutex);",
            "}",
            "static int parse_resource(char *c, int *intval)",
            "{",
            "\tsubstring_t argstr;",
            "\tchar *name, *value = c;",
            "\tsize_t len;",
            "\tint ret, i;",
            "",
            "\tname = strsep(&value, \"=\");",
            "\tif (!name || !value)",
            "\t\treturn -EINVAL;",
            "",
            "\ti = match_string(rdmacg_resource_names, RDMACG_RESOURCE_MAX, name);",
            "\tif (i < 0)",
            "\t\treturn i;",
            "",
            "\tlen = strlen(value);",
            "",
            "\targstr.from = value;",
            "\targstr.to = value + len;",
            "",
            "\tret = match_int(&argstr, intval);",
            "\tif (ret >= 0) {",
            "\t\tif (*intval < 0)",
            "\t\t\treturn -EINVAL;",
            "\t\treturn i;",
            "\t}",
            "\tif (strncmp(value, RDMACG_MAX_STR, len) == 0) {",
            "\t\t*intval = S32_MAX;",
            "\t\treturn i;",
            "\t}",
            "\treturn -EINVAL;",
            "}",
            "static int rdmacg_parse_limits(char *options,",
            "\t\t\t       int *new_limits, unsigned long *enables)",
            "{",
            "\tchar *c;",
            "\tint err = -EINVAL;",
            "",
            "\t/* parse resource options */",
            "\twhile ((c = strsep(&options, \" \")) != NULL) {",
            "\t\tint index, intval;",
            "",
            "\t\tindex = parse_resource(c, &intval);",
            "\t\tif (index < 0)",
            "\t\t\tgoto err;",
            "",
            "\t\tnew_limits[index] = intval;",
            "\t\t*enables |= BIT(index);",
            "\t}",
            "\treturn 0;",
            "",
            "err:",
            "\treturn err;",
            "}",
            "static ssize_t rdmacg_resource_set_max(struct kernfs_open_file *of,",
            "\t\t\t\t       char *buf, size_t nbytes, loff_t off)",
            "{",
            "\tstruct rdma_cgroup *cg = css_rdmacg(of_css(of));",
            "\tconst char *dev_name;",
            "\tstruct rdmacg_resource_pool *rpool;",
            "\tstruct rdmacg_device *device;",
            "\tchar *options = strstrip(buf);",
            "\tint *new_limits;",
            "\tunsigned long enables = 0;",
            "\tint i = 0, ret = 0;",
            "",
            "\t/* extract the device name first */",
            "\tdev_name = strsep(&options, \" \");",
            "\tif (!dev_name) {",
            "\t\tret = -EINVAL;",
            "\t\tgoto err;",
            "\t}",
            "",
            "\tnew_limits = kcalloc(RDMACG_RESOURCE_MAX, sizeof(int), GFP_KERNEL);",
            "\tif (!new_limits) {",
            "\t\tret = -ENOMEM;",
            "\t\tgoto err;",
            "\t}",
            "",
            "\tret = rdmacg_parse_limits(options, new_limits, &enables);",
            "\tif (ret)",
            "\t\tgoto parse_err;",
            "",
            "\t/* acquire lock to synchronize with hot plug devices */",
            "\tmutex_lock(&rdmacg_mutex);",
            "",
            "\tdevice = rdmacg_get_device_locked(dev_name);",
            "\tif (!device) {",
            "\t\tret = -ENODEV;",
            "\t\tgoto dev_err;",
            "\t}",
            "",
            "\trpool = get_cg_rpool_locked(cg, device);",
            "\tif (IS_ERR(rpool)) {",
            "\t\tret = PTR_ERR(rpool);",
            "\t\tgoto dev_err;",
            "\t}",
            "",
            "\t/* now set the new limits of the rpool */",
            "\tfor_each_set_bit(i, &enables, RDMACG_RESOURCE_MAX)",
            "\t\tset_resource_limit(rpool, i, new_limits[i]);",
            "",
            "\tif (rpool->usage_sum == 0 &&",
            "\t    rpool->num_max_cnt == RDMACG_RESOURCE_MAX) {",
            "\t\t/*",
            "\t\t * No user of the rpool and all entries are set to max, so",
            "\t\t * safe to delete this rpool.",
            "\t\t */",
            "\t\tfree_cg_rpool_locked(rpool);",
            "\t}",
            "",
            "dev_err:",
            "\tmutex_unlock(&rdmacg_mutex);",
            "",
            "parse_err:",
            "\tkfree(new_limits);",
            "",
            "err:",
            "\treturn ret ?: nbytes;",
            "}"
          ],
          "function_name": "rdmacg_register_device, rdmacg_unregister_device, parse_resource, rdmacg_parse_limits, rdmacg_resource_set_max",
          "description": "实现设备注册注销流程、资源参数解析及限制设置功能，通过parse_resource解析资源名与数值，rdmacg_parse_limits组织限制定义，rdmacg_resource_set_max应用新限制并触发资源池清理。",
          "similarity": 0.49936285614967346
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/cgroup/rdma.c",
          "start_line": 82,
          "end_line": 214,
          "content": [
            "static void set_resource_limit(struct rdmacg_resource_pool *rpool,",
            "\t\t\t       int index, int new_max)",
            "{",
            "\tif (new_max == S32_MAX) {",
            "\t\tif (rpool->resources[index].max != S32_MAX)",
            "\t\t\trpool->num_max_cnt++;",
            "\t} else {",
            "\t\tif (rpool->resources[index].max == S32_MAX)",
            "\t\t\trpool->num_max_cnt--;",
            "\t}",
            "\trpool->resources[index].max = new_max;",
            "}",
            "static void set_all_resource_max_limit(struct rdmacg_resource_pool *rpool)",
            "{",
            "\tint i;",
            "",
            "\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++)",
            "\t\tset_resource_limit(rpool, i, S32_MAX);",
            "}",
            "static void free_cg_rpool_locked(struct rdmacg_resource_pool *rpool)",
            "{",
            "\tlockdep_assert_held(&rdmacg_mutex);",
            "",
            "\tlist_del(&rpool->cg_node);",
            "\tlist_del(&rpool->dev_node);",
            "\tkfree(rpool);",
            "}",
            "static void",
            "uncharge_cg_locked(struct rdma_cgroup *cg,",
            "\t\t   struct rdmacg_device *device,",
            "\t\t   enum rdmacg_resource_type index)",
            "{",
            "\tstruct rdmacg_resource_pool *rpool;",
            "",
            "\trpool = find_cg_rpool_locked(cg, device);",
            "",
            "\t/*",
            "\t * rpool cannot be null at this stage. Let kernel operate in case",
            "\t * if there a bug in IB stack or rdma controller, instead of crashing",
            "\t * the system.",
            "\t */",
            "\tif (unlikely(!rpool)) {",
            "\t\tpr_warn(\"Invalid device %p or rdma cgroup %p\\n\", cg, device);",
            "\t\treturn;",
            "\t}",
            "",
            "\trpool->resources[index].usage--;",
            "",
            "\t/*",
            "\t * A negative count (or overflow) is invalid,",
            "\t * it indicates a bug in the rdma controller.",
            "\t */",
            "\tWARN_ON_ONCE(rpool->resources[index].usage < 0);",
            "\trpool->usage_sum--;",
            "\tif (rpool->usage_sum == 0 &&",
            "\t    rpool->num_max_cnt == RDMACG_RESOURCE_MAX) {",
            "\t\t/*",
            "\t\t * No user of the rpool and all entries are set to max, so",
            "\t\t * safe to delete this rpool.",
            "\t\t */",
            "\t\tfree_cg_rpool_locked(rpool);",
            "\t}",
            "}",
            "static void rdmacg_uncharge_hierarchy(struct rdma_cgroup *cg,",
            "\t\t\t\t     struct rdmacg_device *device,",
            "\t\t\t\t     struct rdma_cgroup *stop_cg,",
            "\t\t\t\t     enum rdmacg_resource_type index)",
            "{",
            "\tstruct rdma_cgroup *p;",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "",
            "\tfor (p = cg; p != stop_cg; p = parent_rdmacg(p))",
            "\t\tuncharge_cg_locked(p, device, index);",
            "",
            "\tmutex_unlock(&rdmacg_mutex);",
            "",
            "\tcss_put(&cg->css);",
            "}",
            "void rdmacg_uncharge(struct rdma_cgroup *cg,",
            "\t\t     struct rdmacg_device *device,",
            "\t\t     enum rdmacg_resource_type index)",
            "{",
            "\tif (index >= RDMACG_RESOURCE_MAX)",
            "\t\treturn;",
            "",
            "\trdmacg_uncharge_hierarchy(cg, device, NULL, index);",
            "}",
            "int rdmacg_try_charge(struct rdma_cgroup **rdmacg,",
            "\t\t      struct rdmacg_device *device,",
            "\t\t      enum rdmacg_resource_type index)",
            "{",
            "\tstruct rdma_cgroup *cg, *p;",
            "\tstruct rdmacg_resource_pool *rpool;",
            "\ts64 new;",
            "\tint ret = 0;",
            "",
            "\tif (index >= RDMACG_RESOURCE_MAX)",
            "\t\treturn -EINVAL;",
            "",
            "\t/*",
            "\t * hold on to css, as cgroup can be removed but resource",
            "\t * accounting happens on css.",
            "\t */",
            "\tcg = get_current_rdmacg();",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "\tfor (p = cg; p; p = parent_rdmacg(p)) {",
            "\t\trpool = get_cg_rpool_locked(p, device);",
            "\t\tif (IS_ERR(rpool)) {",
            "\t\t\tret = PTR_ERR(rpool);",
            "\t\t\tgoto err;",
            "\t\t} else {",
            "\t\t\tnew = rpool->resources[index].usage + 1;",
            "\t\t\tif (new > rpool->resources[index].max) {",
            "\t\t\t\tret = -EAGAIN;",
            "\t\t\t\tgoto err;",
            "\t\t\t} else {",
            "\t\t\t\trpool->resources[index].usage = new;",
            "\t\t\t\trpool->usage_sum++;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tmutex_unlock(&rdmacg_mutex);",
            "",
            "\t*rdmacg = cg;",
            "\treturn 0;",
            "",
            "err:",
            "\tmutex_unlock(&rdmacg_mutex);",
            "\trdmacg_uncharge_hierarchy(cg, device, p, index);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "set_resource_limit, set_all_resource_max_limit, free_cg_rpool_locked, uncharge_cg_locked, rdmacg_uncharge_hierarchy, rdmacg_uncharge, rdmacg_try_charge",
          "description": "实现资源限制调整、资源释放及充电逻辑，包含设置资源上限、释放资源池、递归层级资源释放、尝试充电检查及错误恢复机制，维护资源使用计数和最大值统计。",
          "similarity": 0.47841721773147583
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/cgroup/rdma.c",
          "start_line": 494,
          "end_line": 562,
          "content": [
            "static void print_rpool_values(struct seq_file *sf,",
            "\t\t\t       struct rdmacg_resource_pool *rpool)",
            "{",
            "\tenum rdmacg_file_type sf_type;",
            "\tint i;",
            "\tu32 value;",
            "",
            "\tsf_type = seq_cft(sf)->private;",
            "",
            "\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++) {",
            "\t\tseq_puts(sf, rdmacg_resource_names[i]);",
            "\t\tseq_putc(sf, '=');",
            "\t\tif (sf_type == RDMACG_RESOURCE_TYPE_MAX) {",
            "\t\t\tif (rpool)",
            "\t\t\t\tvalue = rpool->resources[i].max;",
            "\t\t\telse",
            "\t\t\t\tvalue = S32_MAX;",
            "\t\t} else {",
            "\t\t\tif (rpool)",
            "\t\t\t\tvalue = rpool->resources[i].usage;",
            "\t\t\telse",
            "\t\t\t\tvalue = 0;",
            "\t\t}",
            "",
            "\t\tif (value == S32_MAX)",
            "\t\t\tseq_puts(sf, RDMACG_MAX_STR);",
            "\t\telse",
            "\t\t\tseq_printf(sf, \"%d\", value);",
            "\t\tseq_putc(sf, ' ');",
            "\t}",
            "}",
            "static int rdmacg_resource_read(struct seq_file *sf, void *v)",
            "{",
            "\tstruct rdmacg_device *device;",
            "\tstruct rdmacg_resource_pool *rpool;",
            "\tstruct rdma_cgroup *cg = css_rdmacg(seq_css(sf));",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "",
            "\tlist_for_each_entry(device, &rdmacg_devices, dev_node) {",
            "\t\tseq_printf(sf, \"%s \", device->name);",
            "",
            "\t\trpool = find_cg_rpool_locked(cg, device);",
            "\t\tprint_rpool_values(sf, rpool);",
            "",
            "\t\tseq_putc(sf, '\\n');",
            "\t}",
            "",
            "\tmutex_unlock(&rdmacg_mutex);",
            "\treturn 0;",
            "}",
            "static void rdmacg_css_free(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct rdma_cgroup *cg = css_rdmacg(css);",
            "",
            "\tkfree(cg);",
            "}",
            "static void rdmacg_css_offline(struct cgroup_subsys_state *css)",
            "{",
            "\tstruct rdma_cgroup *cg = css_rdmacg(css);",
            "\tstruct rdmacg_resource_pool *rpool;",
            "",
            "\tmutex_lock(&rdmacg_mutex);",
            "",
            "\tlist_for_each_entry(rpool, &cg->rpools, cg_node)",
            "\t\tset_all_resource_max_limit(rpool);",
            "",
            "\tmutex_unlock(&rdmacg_mutex);",
            "}"
          ],
          "function_name": "print_rpool_values, rdmacg_resource_read, rdmacg_css_free, rdmacg_css_offline",
          "description": "实现资源状态序列化输出、CSS销毁时资源强制设为最大及子系统离线处理，包含资源使用量打印函数和cgroup子系统状态清理逻辑。",
          "similarity": 0.4686024785041809
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/cgroup/rdma.c",
          "start_line": 1,
          "end_line": 81,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * RDMA resource limiting controller for cgroups.",
            " *",
            " * Used to allow a cgroup hierarchy to stop processes from consuming",
            " * additional RDMA resources after a certain limit is reached.",
            " *",
            " * Copyright (C) 2016 Parav Pandit <pandit.parav@gmail.com>",
            " */",
            "",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup_rdma.h>",
            "",
            "#define RDMACG_MAX_STR \"max\"",
            "",
            "/*",
            " * Protects list of resource pools maintained on per cgroup basis",
            " * and rdma device list.",
            " */",
            "static DEFINE_MUTEX(rdmacg_mutex);",
            "static LIST_HEAD(rdmacg_devices);",
            "",
            "enum rdmacg_file_type {",
            "\tRDMACG_RESOURCE_TYPE_MAX,",
            "\tRDMACG_RESOURCE_TYPE_STAT,",
            "};",
            "",
            "/*",
            " * resource table definition as to be seen by the user.",
            " * Need to add entries to it when more resources are",
            " * added/defined at IB verb/core layer.",
            " */",
            "static char const *rdmacg_resource_names[] = {",
            "\t[RDMACG_RESOURCE_HCA_HANDLE]\t= \"hca_handle\",",
            "\t[RDMACG_RESOURCE_HCA_OBJECT]\t= \"hca_object\",",
            "};",
            "",
            "/* resource tracker for each resource of rdma cgroup */",
            "struct rdmacg_resource {",
            "\tint max;",
            "\tint usage;",
            "};",
            "",
            "/*",
            " * resource pool object which represents per cgroup, per device",
            " * resources. There are multiple instances of this object per cgroup,",
            " * therefore it cannot be embedded within rdma_cgroup structure. It",
            " * is maintained as list.",
            " */",
            "struct rdmacg_resource_pool {",
            "\tstruct rdmacg_device\t*device;",
            "\tstruct rdmacg_resource\tresources[RDMACG_RESOURCE_MAX];",
            "",
            "\tstruct list_head\tcg_node;",
            "\tstruct list_head\tdev_node;",
            "",
            "\t/* count active user tasks of this pool */",
            "\tu64\t\t\tusage_sum;",
            "\t/* total number counts which are set to max */",
            "\tint\t\t\tnum_max_cnt;",
            "};",
            "",
            "static struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)",
            "{",
            "\treturn container_of(css, struct rdma_cgroup, css);",
            "}",
            "",
            "static struct rdma_cgroup *parent_rdmacg(struct rdma_cgroup *cg)",
            "{",
            "\treturn css_rdmacg(cg->css.parent);",
            "}",
            "",
            "static inline struct rdma_cgroup *get_current_rdmacg(void)",
            "{",
            "\treturn css_rdmacg(task_get_css(current, rdma_cgrp_id));",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义RDMA cgroup资源管理的基础结构，包括互斥锁保护的设备列表、资源类型枚举、资源名称映射及rdmacg_resource_pool结构体，提供从css获取rdma_cgroup的辅助函数。",
          "similarity": 0.4444257318973541
        }
      ]
    },
    {
      "source_file": "kernel/resource.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:53:12\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `resource.c`\n\n---\n\n# resource.c 技术文档\n\n## 1. 文件概述\n\n`resource.c` 是 Linux 内核中用于管理和分配系统资源（如 I/O 端口和内存区域）的核心实现文件。它提供了一套通用的资源树管理机制，支持资源的申请、释放、查找和冲突检测。该文件维护了两个全局根资源节点：`ioport_resource`（用于 I/O 端口空间）和 `iomem_resource`（用于内存映射 I/O 空间），并通过树形结构组织所有已分配的子资源，确保资源分配的唯一性和安全性。\n\n## 2. 核心功能\n\n### 主要全局数据结构\n- `struct resource ioport_resource`：I/O 端口资源的根节点，范围为 `[0, IO_SPACE_LIMIT]`，标志为 `IORESOURCE_IO`。\n- `struct resource iomem_resource`：内存映射 I/O 资源的根节点，范围为 `[0, -1]`（即全地址空间），标志为 `IORESOURCE_MEM`。\n- `struct resource_constraint`：用于描述资源分配时的约束条件（最小/最大地址、对齐要求及自定义对齐函数）。\n\n### 关键函数\n- `request_resource(struct resource *root, struct resource *new)`：尝试在指定根资源下申请一段新资源，成功返回 0，冲突返回 `-EBUSY`。\n- `request_resource_conflict(...)`：与 `request_resource` 类似，但冲突时直接返回冲突的资源指针。\n- `release_resource(struct resource *old)`：释放已分配的资源。\n- `release_child_resources(struct resource *r)`：递归释放指定资源的所有子资源。\n- `find_next_iomem_res(...)`：在 `iomem_resource` 树中查找与指定区间 `[start, end]` 重叠且满足标志和描述符条件的下一个内存资源。\n- `for_each_resource` 宏：遍历资源树的通用宏，支持是否跳过子树的选项。\n\n### /proc 接口（条件编译）\n- 通过 `CONFIG_PROC_FS` 启用时，注册 `/proc/ioports` 和 `/proc/iomem` 文件，以树形格式展示当前系统中已分配的 I/O 端口和内存资源（仅对 `CAP_SYS_ADMIN` 权限用户显示实际地址）。\n\n## 3. 关键实现\n\n### 资源树结构\n- 资源以多叉树形式组织，每个 `struct resource` 包含 `child`（第一个子节点）、`sibling`（下一个兄弟节点）和 `parent` 指针。\n- 树内节点按起始地址升序排列，便于快速查找和插入。\n\n### 资源申请（`__request_resource`）\n- 在持有写锁 `resource_lock` 的前提下，遍历根节点的子链表。\n- 若新资源与现有节点无重叠，则按地址顺序插入；若存在重叠，则返回冲突节点。\n- 插入操作维护树的有序性：新节点插入到第一个起始地址大于其结束地址的节点之前。\n\n### 资源释放（`__release_resource`）\n- 支持两种模式：完全释放（含子资源）或仅提升子资源（当 `release_child=false` 时，将子节点直接挂到父节点下）。\n- 释放时调整兄弟链表指针，确保树结构完整性。\n\n### 资源遍历\n- `next_resource()`：深度优先遍历（先子节点，再兄弟节点）。\n- `next_resource_skip_children()`：仅遍历同级兄弟节点，跳过子树。\n- `/proc` 显示使用深度优先遍历，并限制最大显示层级（`MAX_IORES_LEVEL=5`）以避免过深嵌套。\n\n### 内存管理\n- 资源结构体通过 `alloc_resource()`（即 `kzalloc`）分配，通过 `free_resource()` 释放。\n- 注释指出：若资源由早期 `memblock` 分配，则无法安全释放（因非页对齐），会轻微泄漏，这是有意为之的简化设计。\n\n### 并发控制\n- 使用读写锁 `resource_lock` 保护全局资源树：\n  - 读操作（如 `/proc` 显示、`find_next_iomem_res`）使用 `read_lock`。\n  - 写操作（申请/释放资源）使用 `write_lock`。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/ioport.h>`：定义 `struct resource` 及相关宏（如 `IORESOURCE_IO`）。\n  - `<linux/proc_fs.h>`、`<linux/seq_file.h>`：实现 `/proc` 接口。\n  - `<linux/slab.h>`：资源结构体的动态分配。\n  - `<linux/spinlock.h>`：读写锁 `resource_lock` 的实现。\n  - `<asm/io.h>`：架构相关的 I/O 定义（如 `IO_SPACE_LIMIT`）。\n- **导出符号**：\n  - `ioport_resource`、`iomem_resource`、`request_resource`、`release_resource` 通过 `EXPORT_SYMBOL` 导出，供其他内核模块（如 PCI、platform_device 驱动）使用。\n- **配置依赖**：\n  - `/proc` 接口依赖 `CONFIG_PROC_FS`。\n\n## 5. 使用场景\n\n- **设备驱动资源管理**：PCI、platform 等总线驱动在探测设备时，调用 `request_resource()` 申请 I/O 端口或内存区域，防止资源冲突。\n- **固件/ACPI 资源解析**：内核解析 ACPI 表或 EFI 内存映射时，将保留区域注册到 `iomem_resource` 树中。\n- **系统调试与监控**：用户空间通过 `/proc/ioports` 和 `/proc/iomem` 查看硬件资源分配情况（需 root 权限）。\n- **内核子系统协作**：内存管理子系统（如 `devm_request_mem_region`）、DMA 引擎等依赖此机制确保物理地址资源的独占使用。\n- **热插拔支持**：设备移除时调用 `release_resource()` 释放资源，供后续设备重用。",
      "similarity": 0.4989139437675476,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/resource.c",
          "start_line": 637,
          "end_line": 763,
          "content": [
            "int region_intersects(resource_size_t start, size_t size, unsigned long flags,",
            "\t\t      unsigned long desc)",
            "{",
            "\tint ret;",
            "",
            "\tread_lock(&resource_lock);",
            "\tret = __region_intersects(&iomem_resource, start, size, flags, desc);",
            "\tread_unlock(&resource_lock);",
            "",
            "\treturn ret;",
            "}",
            "void __weak arch_remove_reservations(struct resource *avail)",
            "{",
            "}",
            "static resource_size_t simple_align_resource(void *data,",
            "\t\t\t\t\t     const struct resource *avail,",
            "\t\t\t\t\t     resource_size_t size,",
            "\t\t\t\t\t     resource_size_t align)",
            "{",
            "\treturn avail->start;",
            "}",
            "static void resource_clip(struct resource *res, resource_size_t min,",
            "\t\t\t  resource_size_t max)",
            "{",
            "\tif (res->start < min)",
            "\t\tres->start = min;",
            "\tif (res->end > max)",
            "\t\tres->end = max;",
            "}",
            "static int __find_resource(struct resource *root, struct resource *old,",
            "\t\t\t struct resource *new,",
            "\t\t\t resource_size_t  size,",
            "\t\t\t struct resource_constraint *constraint)",
            "{",
            "\tstruct resource *this = root->child;",
            "\tstruct resource tmp = *new, avail, alloc;",
            "",
            "\ttmp.start = root->start;",
            "\t/*",
            "\t * Skip past an allocated resource that starts at 0, since the assignment",
            "\t * of this->start - 1 to tmp->end below would cause an underflow.",
            "\t */",
            "\tif (this && this->start == root->start) {",
            "\t\ttmp.start = (this == old) ? old->start : this->end + 1;",
            "\t\tthis = this->sibling;",
            "\t}",
            "\tfor(;;) {",
            "\t\tif (this)",
            "\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;",
            "\t\telse",
            "\t\t\ttmp.end = root->end;",
            "",
            "\t\tif (tmp.end < tmp.start)",
            "\t\t\tgoto next;",
            "",
            "\t\tresource_clip(&tmp, constraint->min, constraint->max);",
            "\t\tarch_remove_reservations(&tmp);",
            "",
            "\t\t/* Check for overflow after ALIGN() */",
            "\t\tavail.start = ALIGN(tmp.start, constraint->align);",
            "\t\tavail.end = tmp.end;",
            "\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;",
            "\t\tif (avail.start >= tmp.start) {",
            "\t\t\talloc.flags = avail.flags;",
            "\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,",
            "\t\t\t\t\tsize, constraint->align);",
            "\t\t\talloc.end = alloc.start + size - 1;",
            "\t\t\tif (alloc.start <= alloc.end &&",
            "\t\t\t    resource_contains(&avail, &alloc)) {",
            "\t\t\t\tnew->start = alloc.start;",
            "\t\t\t\tnew->end = alloc.end;",
            "\t\t\t\treturn 0;",
            "\t\t\t}",
            "\t\t}",
            "",
            "next:\t\tif (!this || this->end == root->end)",
            "\t\t\tbreak;",
            "",
            "\t\tif (this != old)",
            "\t\t\ttmp.start = this->end + 1;",
            "\t\tthis = this->sibling;",
            "\t}",
            "\treturn -EBUSY;",
            "}",
            "static int find_resource(struct resource *root, struct resource *new,",
            "\t\t\tresource_size_t size,",
            "\t\t\tstruct resource_constraint  *constraint)",
            "{",
            "\treturn  __find_resource(root, NULL, new, size, constraint);",
            "}",
            "static int reallocate_resource(struct resource *root, struct resource *old,",
            "\t\t\t       resource_size_t newsize,",
            "\t\t\t       struct resource_constraint *constraint)",
            "{",
            "\tint err=0;",
            "\tstruct resource new = *old;",
            "\tstruct resource *conflict;",
            "",
            "\twrite_lock(&resource_lock);",
            "",
            "\tif ((err = __find_resource(root, old, &new, newsize, constraint)))",
            "\t\tgoto out;",
            "",
            "\tif (resource_contains(&new, old)) {",
            "\t\told->start = new.start;",
            "\t\told->end = new.end;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (old->child) {",
            "\t\terr = -EBUSY;",
            "\t\tgoto out;",
            "\t}",
            "",
            "\tif (resource_contains(old, &new)) {",
            "\t\told->start = new.start;",
            "\t\told->end = new.end;",
            "\t} else {",
            "\t\t__release_resource(old, true);",
            "\t\t*old = new;",
            "\t\tconflict = __request_resource(root, old);",
            "\t\tBUG_ON(conflict);",
            "\t}",
            "out:",
            "\twrite_unlock(&resource_lock);",
            "\treturn err;",
            "}"
          ],
          "function_name": "region_intersects, arch_remove_reservations, simple_align_resource, resource_clip, __find_resource, find_resource, reallocate_resource",
          "description": "实现资源分配策略核心逻辑，包含资源位置查找、尺寸调整、冲突检测等关键功能，支持带约束条件的资源重新分配与位置确定。",
          "similarity": 0.5390067100524902
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/resource.c",
          "start_line": 802,
          "end_line": 912,
          "content": [
            "int allocate_resource(struct resource *root, struct resource *new,",
            "\t\t      resource_size_t size, resource_size_t min,",
            "\t\t      resource_size_t max, resource_size_t align,",
            "\t\t      resource_size_t (*alignf)(void *,",
            "\t\t\t\t\t\tconst struct resource *,",
            "\t\t\t\t\t\tresource_size_t,",
            "\t\t\t\t\t\tresource_size_t),",
            "\t\t      void *alignf_data)",
            "{",
            "\tint err;",
            "\tstruct resource_constraint constraint;",
            "",
            "\tif (!alignf)",
            "\t\talignf = simple_align_resource;",
            "",
            "\tconstraint.min = min;",
            "\tconstraint.max = max;",
            "\tconstraint.align = align;",
            "\tconstraint.alignf = alignf;",
            "\tconstraint.alignf_data = alignf_data;",
            "",
            "\tif ( new->parent ) {",
            "\t\t/* resource is already allocated, try reallocating with",
            "\t\t   the new constraints */",
            "\t\treturn reallocate_resource(root, new, size, &constraint);",
            "\t}",
            "",
            "\twrite_lock(&resource_lock);",
            "\terr = find_resource(root, new, size, &constraint);",
            "\tif (err >= 0 && __request_resource(root, new))",
            "\t\terr = -EBUSY;",
            "\twrite_unlock(&resource_lock);",
            "\treturn err;",
            "}",
            "int insert_resource(struct resource *parent, struct resource *new)",
            "{",
            "\tstruct resource *conflict;",
            "",
            "\tconflict = insert_resource_conflict(parent, new);",
            "\treturn conflict ? -EBUSY : 0;",
            "}",
            "void insert_resource_expand_to_fit(struct resource *root, struct resource *new)",
            "{",
            "\tif (new->parent)",
            "\t\treturn;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tfor (;;) {",
            "\t\tstruct resource *conflict;",
            "",
            "\t\tconflict = __insert_resource(root, new);",
            "\t\tif (!conflict)",
            "\t\t\tbreak;",
            "\t\tif (conflict == root)",
            "\t\t\tbreak;",
            "",
            "\t\t/* Ok, expand resource to cover the conflict, then try again .. */",
            "\t\tif (conflict->start < new->start)",
            "\t\t\tnew->start = conflict->start;",
            "\t\tif (conflict->end > new->end)",
            "\t\t\tnew->end = conflict->end;",
            "",
            "\t\tpr_info(\"Expanded resource %s due to conflict with %s\\n\", new->name, conflict->name);",
            "\t}",
            "\twrite_unlock(&resource_lock);",
            "}",
            "int remove_resource(struct resource *old)",
            "{",
            "\tint retval;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tretval = __release_resource(old, false);",
            "\twrite_unlock(&resource_lock);",
            "\treturn retval;",
            "}",
            "static int __adjust_resource(struct resource *res, resource_size_t start,",
            "\t\t\t\tresource_size_t size)",
            "{",
            "\tstruct resource *tmp, *parent = res->parent;",
            "\tresource_size_t end = start + size - 1;",
            "\tint result = -EBUSY;",
            "",
            "\tif (!parent)",
            "\t\tgoto skip;",
            "",
            "\tif ((start < parent->start) || (end > parent->end))",
            "\t\tgoto out;",
            "",
            "\tif (res->sibling && (res->sibling->start <= end))",
            "\t\tgoto out;",
            "",
            "\ttmp = parent->child;",
            "\tif (tmp != res) {",
            "\t\twhile (tmp->sibling != res)",
            "\t\t\ttmp = tmp->sibling;",
            "\t\tif (start <= tmp->end)",
            "\t\t\tgoto out;",
            "\t}",
            "",
            "skip:",
            "\tfor (tmp = res->child; tmp; tmp = tmp->sibling)",
            "\t\tif ((tmp->start < start) || (tmp->end > end))",
            "\t\t\tgoto out;",
            "",
            "\tres->start = start;",
            "\tres->end = end;",
            "\tresult = 0;",
            "",
            " out:",
            "\treturn result;",
            "}"
          ],
          "function_name": "allocate_resource, insert_resource, insert_resource_expand_to_fit, remove_resource, __adjust_resource",
          "description": "实现资源分配逻辑，支持带约束条件的资源查找与申请，处理资源冲突及扩展调整，提供基础资源管理框架。",
          "similarity": 0.5127695798873901
        },
        {
          "chunk_id": 7,
          "file_path": "kernel/resource.c",
          "start_line": 1208,
          "end_line": 1327,
          "content": [
            "static void revoke_iomem(struct resource *res)",
            "{",
            "\t/* pairs with smp_store_release() in iomem_init_inode() */",
            "\tstruct inode *inode = smp_load_acquire(&iomem_inode);",
            "",
            "\t/*",
            "\t * Check that the initialization has completed. Losing the race",
            "\t * is ok because it means drivers are claiming resources before",
            "\t * the fs_initcall level of init and prevent iomem_get_mapping users",
            "\t * from establishing mappings.",
            "\t */",
            "\tif (!inode)",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * The expectation is that the driver has successfully marked",
            "\t * the resource busy by this point, so devmem_is_allowed()",
            "\t * should start returning false, however for performance this",
            "\t * does not iterate the entire resource range.",
            "\t */",
            "\tif (devmem_is_allowed(PHYS_PFN(res->start)) &&",
            "\t    devmem_is_allowed(PHYS_PFN(res->end))) {",
            "\t\t/*",
            "\t\t * *cringe* iomem=relaxed says \"go ahead, what's the",
            "\t\t * worst that can happen?\"",
            "\t\t */",
            "\t\treturn;",
            "\t}",
            "",
            "\tunmap_mapping_range(inode->i_mapping, res->start, resource_size(res), 1);",
            "}",
            "static void revoke_iomem(struct resource *res) {}",
            "static int __request_region_locked(struct resource *res, struct resource *parent,",
            "\t\t\t\t   resource_size_t start, resource_size_t n,",
            "\t\t\t\t   const char *name, int flags)",
            "{",
            "\tDECLARE_WAITQUEUE(wait, current);",
            "",
            "\tres->name = name;",
            "\tres->start = start;",
            "\tres->end = start + n - 1;",
            "",
            "\tfor (;;) {",
            "\t\tstruct resource *conflict;",
            "",
            "\t\tres->flags = resource_type(parent) | resource_ext_type(parent);",
            "\t\tres->flags |= IORESOURCE_BUSY | flags;",
            "\t\tres->desc = parent->desc;",
            "",
            "\t\tconflict = __request_resource(parent, res);",
            "\t\tif (!conflict)",
            "\t\t\tbreak;",
            "\t\t/*",
            "\t\t * mm/hmm.c reserves physical addresses which then",
            "\t\t * become unavailable to other users.  Conflicts are",
            "\t\t * not expected.  Warn to aid debugging if encountered.",
            "\t\t */",
            "\t\tif (parent == &iomem_resource &&",
            "\t\t    conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY) {",
            "\t\t\tpr_warn(\"Unaddressable device %s %pR conflicts with %pR\\n\",",
            "\t\t\t\tconflict->name, conflict, res);",
            "\t\t}",
            "\t\tif (conflict != parent) {",
            "\t\t\tif (!(conflict->flags & IORESOURCE_BUSY)) {",
            "\t\t\t\tparent = conflict;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (conflict->flags & flags & IORESOURCE_MUXED) {",
            "\t\t\tadd_wait_queue(&muxed_resource_wait, &wait);",
            "\t\t\twrite_unlock(&resource_lock);",
            "\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);",
            "\t\t\tschedule();",
            "\t\t\tremove_wait_queue(&muxed_resource_wait, &wait);",
            "\t\t\twrite_lock(&resource_lock);",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\t/* Uhhuh, that didn't work out.. */",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "void __release_region(struct resource *parent, resource_size_t start,",
            "\t\t      resource_size_t n)",
            "{",
            "\tstruct resource **p;",
            "\tresource_size_t end;",
            "",
            "\tp = &parent->child;",
            "\tend = start + n - 1;",
            "",
            "\twrite_lock(&resource_lock);",
            "",
            "\tfor (;;) {",
            "\t\tstruct resource *res = *p;",
            "",
            "\t\tif (!res)",
            "\t\t\tbreak;",
            "\t\tif (res->start <= start && res->end >= end) {",
            "\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {",
            "\t\t\t\tp = &res->child;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tif (res->start != start || res->end != end)",
            "\t\t\t\tbreak;",
            "\t\t\t*p = res->sibling;",
            "\t\t\twrite_unlock(&resource_lock);",
            "\t\t\tif (res->flags & IORESOURCE_MUXED)",
            "\t\t\t\twake_up(&muxed_resource_wait);",
            "\t\t\tfree_resource(res);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tp = &res->sibling;",
            "\t}",
            "",
            "\twrite_unlock(&resource_lock);",
            "",
            "\tpr_warn(\"Trying to free nonexistent resource <%pa-%pa>\\n\", &start, &end);",
            "}"
          ],
          "function_name": "revoke_iomem, revoke_iomem, __request_region_locked, __release_region",
          "description": "实现IOMEM资源撤销机制，包含受保护的区域请求锁管理、资源释放及冲突处理逻辑，维护资源树结构。",
          "similarity": 0.5047375559806824
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/resource.c",
          "start_line": 1072,
          "end_line": 1180,
          "content": [
            "int adjust_resource(struct resource *res, resource_size_t start,",
            "\t\t    resource_size_t size)",
            "{",
            "\tint result;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tresult = __adjust_resource(res, start, size);",
            "\twrite_unlock(&resource_lock);",
            "\treturn result;",
            "}",
            "static void __init",
            "__reserve_region_with_split(struct resource *root, resource_size_t start,",
            "\t\t\t    resource_size_t end, const char *name)",
            "{",
            "\tstruct resource *parent = root;",
            "\tstruct resource *conflict;",
            "\tstruct resource *res = alloc_resource(GFP_ATOMIC);",
            "\tstruct resource *next_res = NULL;",
            "\tint type = resource_type(root);",
            "",
            "\tif (!res)",
            "\t\treturn;",
            "",
            "\tres->name = name;",
            "\tres->start = start;",
            "\tres->end = end;",
            "\tres->flags = type | IORESOURCE_BUSY;",
            "\tres->desc = IORES_DESC_NONE;",
            "",
            "\twhile (1) {",
            "",
            "\t\tconflict = __request_resource(parent, res);",
            "\t\tif (!conflict) {",
            "\t\t\tif (!next_res)",
            "\t\t\t\tbreak;",
            "\t\t\tres = next_res;",
            "\t\t\tnext_res = NULL;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\t/* conflict covered whole area */",
            "\t\tif (conflict->start <= res->start &&",
            "\t\t\t\tconflict->end >= res->end) {",
            "\t\t\tfree_resource(res);",
            "\t\t\tWARN_ON(next_res);",
            "\t\t\tbreak;",
            "\t\t}",
            "",
            "\t\t/* failed, split and try again */",
            "\t\tif (conflict->start > res->start) {",
            "\t\t\tend = res->end;",
            "\t\t\tres->end = conflict->start - 1;",
            "\t\t\tif (conflict->end < end) {",
            "\t\t\t\tnext_res = alloc_resource(GFP_ATOMIC);",
            "\t\t\t\tif (!next_res) {",
            "\t\t\t\t\tfree_resource(res);",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tnext_res->name = name;",
            "\t\t\t\tnext_res->start = conflict->end + 1;",
            "\t\t\t\tnext_res->end = end;",
            "\t\t\t\tnext_res->flags = type | IORESOURCE_BUSY;",
            "\t\t\t\tnext_res->desc = IORES_DESC_NONE;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tres->start = conflict->end + 1;",
            "\t\t}",
            "\t}",
            "",
            "}",
            "void __init",
            "reserve_region_with_split(struct resource *root, resource_size_t start,",
            "\t\t\t  resource_size_t end, const char *name)",
            "{",
            "\tint abort = 0;",
            "",
            "\twrite_lock(&resource_lock);",
            "\tif (root->start > start || root->end < end) {",
            "\t\tpr_err(\"requested range [0x%llx-0x%llx] not in root %pr\\n\",",
            "\t\t       (unsigned long long)start, (unsigned long long)end,",
            "\t\t       root);",
            "\t\tif (start > root->end || end < root->start)",
            "\t\t\tabort = 1;",
            "\t\telse {",
            "\t\t\tif (end > root->end)",
            "\t\t\t\tend = root->end;",
            "\t\t\tif (start < root->start)",
            "\t\t\t\tstart = root->start;",
            "\t\t\tpr_err(\"fixing request to [0x%llx-0x%llx]\\n\",",
            "\t\t\t       (unsigned long long)start,",
            "\t\t\t       (unsigned long long)end);",
            "\t\t}",
            "\t\tdump_stack();",
            "\t}",
            "\tif (!abort)",
            "\t\t__reserve_region_with_split(root, start, end, name);",
            "\twrite_unlock(&resource_lock);",
            "}",
            "resource_size_t resource_alignment(struct resource *res)",
            "{",
            "\tswitch (res->flags & (IORESOURCE_SIZEALIGN | IORESOURCE_STARTALIGN)) {",
            "\tcase IORESOURCE_SIZEALIGN:",
            "\t\treturn resource_size(res);",
            "\tcase IORESOURCE_STARTALIGN:",
            "\t\treturn res->start;",
            "\tdefault:",
            "\t\treturn 0;",
            "\t}",
            "}"
          ],
          "function_name": "adjust_resource, __reserve_region_with_split, reserve_region_with_split, resource_alignment",
          "description": "实现资源区域分裂分配逻辑，处理大范围资源请求时的冲突分裂与重叠区域处理，提供资源对齐策略查询接口。",
          "similarity": 0.5041795969009399
        },
        {
          "chunk_id": 9,
          "file_path": "kernel/resource.c",
          "start_line": 1561,
          "end_line": 1661,
          "content": [
            "static void devm_resource_release(struct device *dev, void *ptr)",
            "{",
            "\tstruct resource **r = ptr;",
            "",
            "\trelease_resource(*r);",
            "}",
            "int devm_request_resource(struct device *dev, struct resource *root,",
            "\t\t\t  struct resource *new)",
            "{",
            "\tstruct resource *conflict, **ptr;",
            "",
            "\tptr = devres_alloc(devm_resource_release, sizeof(*ptr), GFP_KERNEL);",
            "\tif (!ptr)",
            "\t\treturn -ENOMEM;",
            "",
            "\t*ptr = new;",
            "",
            "\tconflict = request_resource_conflict(root, new);",
            "\tif (conflict) {",
            "\t\tdev_err(dev, \"resource collision: %pR conflicts with %s %pR\\n\",",
            "\t\t\tnew, conflict->name, conflict);",
            "\t\tdevres_free(ptr);",
            "\t\treturn -EBUSY;",
            "\t}",
            "",
            "\tdevres_add(dev, ptr);",
            "\treturn 0;",
            "}",
            "static int devm_resource_match(struct device *dev, void *res, void *data)",
            "{",
            "\tstruct resource **ptr = res;",
            "",
            "\treturn *ptr == data;",
            "}",
            "void devm_release_resource(struct device *dev, struct resource *new)",
            "{",
            "\tWARN_ON(devres_release(dev, devm_resource_release, devm_resource_match,",
            "\t\t\t       new));",
            "}",
            "static void devm_region_release(struct device *dev, void *res)",
            "{",
            "\tstruct region_devres *this = res;",
            "",
            "\t__release_region(this->parent, this->start, this->n);",
            "}",
            "static int devm_region_match(struct device *dev, void *res, void *match_data)",
            "{",
            "\tstruct region_devres *this = res, *match = match_data;",
            "",
            "\treturn this->parent == match->parent &&",
            "\t\tthis->start == match->start && this->n == match->n;",
            "}",
            "void __devm_release_region(struct device *dev, struct resource *parent,",
            "\t\t\t   resource_size_t start, resource_size_t n)",
            "{",
            "\tstruct region_devres match_data = { parent, start, n };",
            "",
            "\t__release_region(parent, start, n);",
            "\tWARN_ON(devres_destroy(dev, devm_region_release, devm_region_match,",
            "\t\t\t       &match_data));",
            "}",
            "static int __init reserve_setup(char *str)",
            "{",
            "\tstatic int reserved;",
            "\tstatic struct resource reserve[MAXRESERVE];",
            "",
            "\tfor (;;) {",
            "\t\tunsigned int io_start, io_num;",
            "\t\tint x = reserved;",
            "\t\tstruct resource *parent;",
            "",
            "\t\tif (get_option(&str, &io_start) != 2)",
            "\t\t\tbreak;",
            "\t\tif (get_option(&str, &io_num) == 0)",
            "\t\t\tbreak;",
            "\t\tif (x < MAXRESERVE) {",
            "\t\t\tstruct resource *res = reserve + x;",
            "",
            "\t\t\t/*",
            "\t\t\t * If the region starts below 0x10000, we assume it's",
            "\t\t\t * I/O port space; otherwise assume it's memory.",
            "\t\t\t */",
            "\t\t\tif (io_start < 0x10000) {",
            "\t\t\t\tres->flags = IORESOURCE_IO;",
            "\t\t\t\tparent = &ioport_resource;",
            "\t\t\t} else {",
            "\t\t\t\tres->flags = IORESOURCE_MEM;",
            "\t\t\t\tparent = &iomem_resource;",
            "\t\t\t}",
            "\t\t\tres->name = \"reserved\";",
            "\t\t\tres->start = io_start;",
            "\t\t\tres->end = io_start + io_num - 1;",
            "\t\t\tres->flags |= IORESOURCE_BUSY;",
            "\t\t\tres->desc = IORES_DESC_NONE;",
            "\t\t\tres->child = NULL;",
            "\t\t\tif (request_resource(parent, res) == 0)",
            "\t\t\t\treserved = x+1;",
            "\t\t}",
            "\t}",
            "\treturn 1;",
            "}"
          ],
          "function_name": "devm_resource_release, devm_request_resource, devm_resource_match, devm_release_resource, devm_region_release, devm_region_match, __devm_release_region, reserve_setup",
          "description": "实现设备资源管理器（devm）的资源申请/释放机制，包含预留资源初始化及设备资源生命周期绑定功能。",
          "similarity": 0.48627424240112305
        }
      ]
    },
    {
      "source_file": "kernel/bpf/memalloc.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:19:22\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\memalloc.c`\n\n---\n\n# `bpf/memalloc.c` 技术文档\n\n## 1. 文件概述\n\n`bpf/memalloc.c` 实现了一个专用于 BPF（Berkeley Packet Filter）程序的内存分配器，支持在任意上下文（包括 NMI、中断、不可抢占上下文等）中安全地分配和释放小块内存。该分配器通过每 CPU 的多级缓存桶（per-CPU per-bucket free list）机制，避免在 BPF 程序执行路径中直接调用可能不安全的 `kmalloc()`。缓存桶的填充和回收由 `irq_work` 异步完成，确保主执行路径的低延迟和高可靠性。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct bpf_mem_cache`**  \n  每个缓存桶的核心结构，包含：\n  - `free_llist` / `free_llist_extra`：无锁链表（llist），用于存储空闲对象。\n  - `active`：本地原子计数器，用于保护对 `free_llist` 的并发访问。\n  - `refill_work`：`irq_work` 结构，用于触发异步填充。\n  - `objcg`：对象 cgroup 指针，用于内存记账。\n  - `unit_size`：该缓存桶中对象的固定大小。\n  - `free_cnt`、`low_watermark`、`high_watermark`、`batch`：缓存管理参数。\n  - `percpu_size`：标识是否为 per-CPU 分配。\n  - RCU 相关字段（`free_by_rcu`、`rcu` 等）：用于延迟释放内存，避免在不可睡眠上下文中调用 `kfree`。\n\n- **`struct bpf_mem_caches`**  \n  包含 `NUM_CACHES`（11 个）不同大小的 `bpf_mem_cache` 实例，对应预定义的内存块尺寸。\n\n- **`sizes[NUM_CACHES]`**  \n  定义了 11 种支持的分配尺寸：`{96, 192, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096}` 字节。\n\n- **`size_index[24]`**  \n  查找表，将请求大小（≤192 字节）映射到对应的缓存桶索引。\n\n### 主要函数\n\n- **`bpf_mem_cache_idx(size_t size)`**  \n  根据请求大小返回对应的缓存桶索引（0~10），超出 `BPF_MEM_ALLOC_SIZE_MAX`（4096）则返回 -1。\n\n- **`__alloc()`**  \n  底层分配函数，根据是否为 per-CPU 类型调用 `kmalloc_node` 或 `__alloc_percpu_gfp`。\n\n- **`add_obj_to_free_list()`**  \n  将对象安全地加入当前 CPU 的空闲链表，使用 `active` 计数器保护。\n\n- **`alloc_bulk()`**  \n  批量分配对象并填充缓存桶，优先从延迟释放队列（如 `free_by_rcu_ttrace`）回收，再尝试从全局分配器分配。\n\n- **`free_one()` / `free_all()`**  \n  释放单个或多个对象，区分普通和 per-CPU 类型。\n\n- **`__free_rcu()` / `__free_rcu_tasks_trace()`**  \n  RCU 回调函数，用于在宽限期结束后真正释放内存。\n\n- **`enque_to_free()` / `do_call_rcu_ttrace()`**  \n  将待释放对象加入 RCU 延迟队列，并触发 RCU 宽限期。\n\n## 3. 关键实现\n\n### 内存布局与对齐\n- 每个分配的对象末尾附加 8 字节的 `struct llist_node`，用于无锁链表管理。\n- 所有分配均对齐至 8 字节边界。\n\n### 并发控制\n- 使用 `local_t active` 计数器保护对 `free_llist` 的访问。在分配/释放时，通过 `inc_active()`/`dec_active()` 禁用中断（尤其在 `CONFIG_PREEMPT_RT` 下），确保 NMI 或中断上下文不会破坏链表结构。\n- `free_llist_extra` 用于在 `active` 忙时暂存释放对象，避免失败。\n\n### 异步填充机制\n- 当缓存桶水位低于 `low_watermark` 时，通过 `irq_work` 触发 `alloc_bulk()`。\n- `alloc_bulk()` 优先从 RCU 延迟释放队列中回收对象，减少全局分配压力。\n- 使用 `set_active_memcg()` 确保内存分配计入正确的 memcg。\n\n### RCU 延迟释放\n- 在不可睡眠上下文（如 NMI）中释放内存时，对象被加入 `free_by_rcu_ttrace` 队列。\n- 通过 `call_rcu_tasks_trace()` 或 `call_rcu()` 触发宽限期，之后在软中断上下文中真正释放。\n- 支持 `rcu_trace_implies_rcu_gp()` 优化，避免双重 RCU 调用。\n\n### 尺寸映射策略\n- 对 ≤192 字节的请求，使用 `size_index` 查找表快速定位桶。\n- 对 >192 字节的请求，使用 `fls(size - 1) - 2` 计算桶索引，覆盖 256~4096 字节范围。\n\n## 4. 依赖关系\n\n- **内存管理**：依赖 `<linux/mm.h>`、`<linux/memcontrol.h>` 进行底层分配和 memcg 记账。\n- **BPF 子系统**：通过 `<linux/bpf.h>` 和 `<linux/bpf_mem_alloc.h>` 与 BPF 运行时集成。\n- **无锁数据结构**：使用 `<linux/llist.h>` 提供的无锁链表。\n- **中断与延迟执行**：依赖 `<linux/irq_work.h>` 实现异步填充。\n- **RCU 机制**：使用 RCU 和 RCU Tasks Trace 宽限期实现安全延迟释放。\n- **架构相关**：使用 `<asm/local.h>` 的 per-CPU 原子操作。\n\n## 5. 使用场景\n\n- **BPF tracing 程序**：当 BPF 程序 attach 到 `kprobe`、`fentry` 等 hook 点时，可能运行在任意内核上下文（包括 NMI、中断、不可抢占区域）。此时标准 `kmalloc` 不安全，必须使用本分配器。\n- **高可靠性内存分配**：在不允许睡眠、不能触发内存回收的上下文中，提供确定性的内存分配能力。\n- **低延迟要求**：通过 per-CPU 缓存避免锁竞争和全局分配器开销，满足 BPF 程序对性能的严苛要求。\n- **内存隔离与记账**：支持通过 `objcg` 将 BPF 内存消耗计入特定 cgroup，便于资源控制。",
      "similarity": 0.47870510816574097,
      "chunks": [
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/memalloc.c",
          "start_line": 266,
          "end_line": 373,
          "content": [
            "static int free_all(struct llist_node *llnode, bool percpu)",
            "{",
            "\tstruct llist_node *pos, *t;",
            "\tint cnt = 0;",
            "",
            "\tllist_for_each_safe(pos, t, llnode) {",
            "\t\tfree_one(pos, percpu);",
            "\t\tcnt++;",
            "\t}",
            "\treturn cnt;",
            "}",
            "static void __free_rcu(struct rcu_head *head)",
            "{",
            "\tstruct bpf_mem_cache *c = container_of(head, struct bpf_mem_cache, rcu_ttrace);",
            "",
            "\tfree_all(llist_del_all(&c->waiting_for_gp_ttrace), !!c->percpu_size);",
            "\tatomic_set(&c->call_rcu_ttrace_in_progress, 0);",
            "}",
            "static void __free_rcu_tasks_trace(struct rcu_head *head)",
            "{",
            "\t/* If RCU Tasks Trace grace period implies RCU grace period,",
            "\t * there is no need to invoke call_rcu().",
            "\t */",
            "\tif (rcu_trace_implies_rcu_gp())",
            "\t\t__free_rcu(head);",
            "\telse",
            "\t\tcall_rcu(head, __free_rcu);",
            "}",
            "static void enque_to_free(struct bpf_mem_cache *c, void *obj)",
            "{",
            "\tstruct llist_node *llnode = obj;",
            "",
            "\t/* bpf_mem_cache is a per-cpu object. Freeing happens in irq_work.",
            "\t * Nothing races to add to free_by_rcu_ttrace list.",
            "\t */",
            "\tllist_add(llnode, &c->free_by_rcu_ttrace);",
            "}",
            "static void do_call_rcu_ttrace(struct bpf_mem_cache *c)",
            "{",
            "\tstruct llist_node *llnode, *t;",
            "",
            "\tif (atomic_xchg(&c->call_rcu_ttrace_in_progress, 1)) {",
            "\t\tif (unlikely(READ_ONCE(c->draining))) {",
            "\t\t\tllnode = llist_del_all(&c->free_by_rcu_ttrace);",
            "\t\t\tfree_all(llnode, !!c->percpu_size);",
            "\t\t}",
            "\t\treturn;",
            "\t}",
            "",
            "\tWARN_ON_ONCE(!llist_empty(&c->waiting_for_gp_ttrace));",
            "\tllist_for_each_safe(llnode, t, llist_del_all(&c->free_by_rcu_ttrace))",
            "\t\tllist_add(llnode, &c->waiting_for_gp_ttrace);",
            "",
            "\tif (unlikely(READ_ONCE(c->draining))) {",
            "\t\t__free_rcu(&c->rcu_ttrace);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* Use call_rcu_tasks_trace() to wait for sleepable progs to finish.",
            "\t * If RCU Tasks Trace grace period implies RCU grace period, free",
            "\t * these elements directly, else use call_rcu() to wait for normal",
            "\t * progs to finish and finally do free_one() on each element.",
            "\t */",
            "\tcall_rcu_tasks_trace(&c->rcu_ttrace, __free_rcu_tasks_trace);",
            "}",
            "static void free_bulk(struct bpf_mem_cache *c)",
            "{",
            "\tstruct bpf_mem_cache *tgt = c->tgt;",
            "\tstruct llist_node *llnode, *t;",
            "\tunsigned long flags;",
            "\tint cnt;",
            "",
            "\tWARN_ON_ONCE(tgt->unit_size != c->unit_size);",
            "",
            "\tdo {",
            "\t\tinc_active(c, &flags);",
            "\t\tllnode = __llist_del_first(&c->free_llist);",
            "\t\tif (llnode)",
            "\t\t\tcnt = --c->free_cnt;",
            "\t\telse",
            "\t\t\tcnt = 0;",
            "\t\tdec_active(c, &flags);",
            "\t\tif (llnode)",
            "\t\t\tenque_to_free(tgt, llnode);",
            "\t} while (cnt > (c->high_watermark + c->low_watermark) / 2);",
            "",
            "\t/* and drain free_llist_extra */",
            "\tllist_for_each_safe(llnode, t, llist_del_all(&c->free_llist_extra))",
            "\t\tenque_to_free(tgt, llnode);",
            "\tdo_call_rcu_ttrace(tgt);",
            "}",
            "static void __free_by_rcu(struct rcu_head *head)",
            "{",
            "\tstruct bpf_mem_cache *c = container_of(head, struct bpf_mem_cache, rcu);",
            "\tstruct bpf_mem_cache *tgt = c->tgt;",
            "\tstruct llist_node *llnode;",
            "",
            "\tllnode = llist_del_all(&c->waiting_for_gp);",
            "\tif (!llnode)",
            "\t\tgoto out;",
            "",
            "\tllist_add_batch(llnode, c->waiting_for_gp_tail, &tgt->free_by_rcu_ttrace);",
            "",
            "\t/* Objects went through regular RCU GP. Send them to RCU tasks trace */",
            "\tdo_call_rcu_ttrace(tgt);",
            "out:",
            "\tatomic_set(&c->call_rcu_in_progress, 0);",
            "}"
          ],
          "function_name": "free_all, __free_rcu, __free_rcu_tasks_trace, enque_to_free, do_call_rcu_ttrace, free_bulk, __free_by_rcu",
          "description": "提供RCU安全的对象释放机制，包含延迟释放回调函数、任务追踪RCU回调、对象入队到待释放链表及触发RCU回调的逻辑。支持两种释放路径：直接释放和等待RCU grace period后释放。",
          "similarity": 0.505279541015625
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/memalloc.c",
          "start_line": 689,
          "end_line": 807,
          "content": [
            "static void free_mem_alloc(struct bpf_mem_alloc *ma)",
            "{",
            "\t/* waiting_for_gp[_ttrace] lists were drained, but RCU callbacks",
            "\t * might still execute. Wait for them.",
            "\t *",
            "\t * rcu_barrier_tasks_trace() doesn't imply synchronize_rcu_tasks_trace(),",
            "\t * but rcu_barrier_tasks_trace() and rcu_barrier() below are only used",
            "\t * to wait for the pending __free_rcu_tasks_trace() and __free_rcu(),",
            "\t * so if call_rcu(head, __free_rcu) is skipped due to",
            "\t * rcu_trace_implies_rcu_gp(), it will be OK to skip rcu_barrier() by",
            "\t * using rcu_trace_implies_rcu_gp() as well.",
            "\t */",
            "\trcu_barrier(); /* wait for __free_by_rcu */",
            "\trcu_barrier_tasks_trace(); /* wait for __free_rcu */",
            "\tif (!rcu_trace_implies_rcu_gp())",
            "\t\trcu_barrier();",
            "\tfree_mem_alloc_no_barrier(ma);",
            "}",
            "static void free_mem_alloc_deferred(struct work_struct *work)",
            "{",
            "\tstruct bpf_mem_alloc *ma = container_of(work, struct bpf_mem_alloc, work);",
            "",
            "\tfree_mem_alloc(ma);",
            "\tkfree(ma);",
            "}",
            "static void destroy_mem_alloc(struct bpf_mem_alloc *ma, int rcu_in_progress)",
            "{",
            "\tstruct bpf_mem_alloc *copy;",
            "",
            "\tif (!rcu_in_progress) {",
            "\t\t/* Fast path. No callbacks are pending, hence no need to do",
            "\t\t * rcu_barrier-s.",
            "\t\t */",
            "\t\tfree_mem_alloc_no_barrier(ma);",
            "\t\treturn;",
            "\t}",
            "",
            "\tcopy = kmemdup(ma, sizeof(*ma), GFP_KERNEL);",
            "\tif (!copy) {",
            "\t\t/* Slow path with inline barrier-s */",
            "\t\tfree_mem_alloc(ma);",
            "\t\treturn;",
            "\t}",
            "",
            "\t/* Defer barriers into worker to let the rest of map memory to be freed */",
            "\tmemset(ma, 0, sizeof(*ma));",
            "\tINIT_WORK(&copy->work, free_mem_alloc_deferred);",
            "\tqueue_work(system_unbound_wq, &copy->work);",
            "}",
            "void bpf_mem_alloc_destroy(struct bpf_mem_alloc *ma)",
            "{",
            "\tstruct bpf_mem_caches *cc;",
            "\tstruct bpf_mem_cache *c;",
            "\tint cpu, i, rcu_in_progress;",
            "",
            "\tif (ma->cache) {",
            "\t\trcu_in_progress = 0;",
            "\t\tfor_each_possible_cpu(cpu) {",
            "\t\t\tc = per_cpu_ptr(ma->cache, cpu);",
            "\t\t\tWRITE_ONCE(c->draining, true);",
            "\t\t\tirq_work_sync(&c->refill_work);",
            "\t\t\tdrain_mem_cache(c);",
            "\t\t\trcu_in_progress += atomic_read(&c->call_rcu_ttrace_in_progress);",
            "\t\t\trcu_in_progress += atomic_read(&c->call_rcu_in_progress);",
            "\t\t}",
            "\t\tobj_cgroup_put(ma->objcg);",
            "\t\tdestroy_mem_alloc(ma, rcu_in_progress);",
            "\t}",
            "\tif (ma->caches) {",
            "\t\trcu_in_progress = 0;",
            "\t\tfor_each_possible_cpu(cpu) {",
            "\t\t\tcc = per_cpu_ptr(ma->caches, cpu);",
            "\t\t\tfor (i = 0; i < NUM_CACHES; i++) {",
            "\t\t\t\tc = &cc->cache[i];",
            "\t\t\t\tWRITE_ONCE(c->draining, true);",
            "\t\t\t\tirq_work_sync(&c->refill_work);",
            "\t\t\t\tdrain_mem_cache(c);",
            "\t\t\t\trcu_in_progress += atomic_read(&c->call_rcu_ttrace_in_progress);",
            "\t\t\t\trcu_in_progress += atomic_read(&c->call_rcu_in_progress);",
            "\t\t\t}",
            "\t\t}",
            "\t\tobj_cgroup_put(ma->objcg);",
            "\t\tdestroy_mem_alloc(ma, rcu_in_progress);",
            "\t}",
            "}",
            "static void notrace unit_free(struct bpf_mem_cache *c, void *ptr)",
            "{",
            "\tstruct llist_node *llnode = ptr - LLIST_NODE_SZ;",
            "\tunsigned long flags;",
            "\tint cnt = 0;",
            "",
            "\tBUILD_BUG_ON(LLIST_NODE_SZ > 8);",
            "",
            "\t/*",
            "\t * Remember bpf_mem_cache that allocated this object.",
            "\t * The hint is not accurate.",
            "\t */",
            "\tc->tgt = *(struct bpf_mem_cache **)llnode;",
            "",
            "\tlocal_irq_save(flags);",
            "\tif (local_inc_return(&c->active) == 1) {",
            "\t\t__llist_add(llnode, &c->free_llist);",
            "\t\tcnt = ++c->free_cnt;",
            "\t} else {",
            "\t\t/* unit_free() cannot fail. Therefore add an object to atomic",
            "\t\t * llist. free_bulk() will drain it. Though free_llist_extra is",
            "\t\t * a per-cpu list we have to use atomic llist_add here, since",
            "\t\t * it also can be interrupted by bpf nmi prog that does another",
            "\t\t * unit_free() into the same free_llist_extra.",
            "\t\t */",
            "\t\tllist_add(llnode, &c->free_llist_extra);",
            "\t}",
            "\tlocal_dec(&c->active);",
            "\tlocal_irq_restore(flags);",
            "",
            "\tif (cnt > c->high_watermark)",
            "\t\t/* free few objects from current cpu into global kmalloc pool */",
            "\t\tirq_work_raise(c);",
            "}"
          ],
          "function_name": "free_mem_alloc, free_mem_alloc_deferred, destroy_mem_alloc, bpf_mem_alloc_destroy, unit_free",
          "description": "实现BPF内存分配销毁逻辑，通过RCU屏障等待回调完成并安全释放资源，deferred路径利用workqueue异步释放，destroy_mem_alloc处理缓存清理和RCU状态同步。",
          "similarity": 0.4956551790237427
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/bpf/memalloc.c",
          "start_line": 859,
          "end_line": 938,
          "content": [
            "static void notrace unit_free_rcu(struct bpf_mem_cache *c, void *ptr)",
            "{",
            "\tstruct llist_node *llnode = ptr - LLIST_NODE_SZ;",
            "\tunsigned long flags;",
            "",
            "\tc->tgt = *(struct bpf_mem_cache **)llnode;",
            "",
            "\tlocal_irq_save(flags);",
            "\tif (local_inc_return(&c->active) == 1) {",
            "\t\tif (__llist_add(llnode, &c->free_by_rcu))",
            "\t\t\tc->free_by_rcu_tail = llnode;",
            "\t} else {",
            "\t\tllist_add(llnode, &c->free_llist_extra_rcu);",
            "\t}",
            "\tlocal_dec(&c->active);",
            "\tlocal_irq_restore(flags);",
            "",
            "\tif (!atomic_read(&c->call_rcu_in_progress))",
            "\t\tirq_work_raise(c);",
            "}",
            "void notrace bpf_mem_free(struct bpf_mem_alloc *ma, void *ptr)",
            "{",
            "\tstruct bpf_mem_cache *c;",
            "\tint idx;",
            "",
            "\tif (!ptr)",
            "\t\treturn;",
            "",
            "\tc = *(void **)(ptr - LLIST_NODE_SZ);",
            "\tidx = bpf_mem_cache_idx(c->unit_size);",
            "\tif (WARN_ON_ONCE(idx < 0))",
            "\t\treturn;",
            "",
            "\tunit_free(this_cpu_ptr(ma->caches)->cache + idx, ptr);",
            "}",
            "void notrace bpf_mem_free_rcu(struct bpf_mem_alloc *ma, void *ptr)",
            "{",
            "\tstruct bpf_mem_cache *c;",
            "\tint idx;",
            "",
            "\tif (!ptr)",
            "\t\treturn;",
            "",
            "\tc = *(void **)(ptr - LLIST_NODE_SZ);",
            "\tidx = bpf_mem_cache_idx(c->unit_size);",
            "\tif (WARN_ON_ONCE(idx < 0))",
            "\t\treturn;",
            "",
            "\tunit_free_rcu(this_cpu_ptr(ma->caches)->cache + idx, ptr);",
            "}",
            "void notrace bpf_mem_cache_free(struct bpf_mem_alloc *ma, void *ptr)",
            "{",
            "\tif (!ptr)",
            "\t\treturn;",
            "",
            "\tunit_free(this_cpu_ptr(ma->cache), ptr);",
            "}",
            "void notrace bpf_mem_cache_free_rcu(struct bpf_mem_alloc *ma, void *ptr)",
            "{",
            "\tif (!ptr)",
            "\t\treturn;",
            "",
            "\tunit_free_rcu(this_cpu_ptr(ma->cache), ptr);",
            "}",
            "void bpf_mem_cache_raw_free(void *ptr)",
            "{",
            "\tif (!ptr)",
            "\t\treturn;",
            "",
            "\tkfree(ptr - LLIST_NODE_SZ);",
            "}",
            "int bpf_mem_alloc_check_size(bool percpu, size_t size)",
            "{",
            "\t/* The size of percpu allocation doesn't have LLIST_NODE_SZ overhead */",
            "\tif ((percpu && size > BPF_MEM_ALLOC_SIZE_MAX) ||",
            "\t    (!percpu && size > BPF_MEM_ALLOC_SIZE_MAX - LLIST_NODE_SZ))",
            "\t\treturn -E2BIG;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "unit_free_rcu, bpf_mem_free, bpf_mem_free_rcu, bpf_mem_cache_free, bpf_mem_cache_free_rcu, bpf_mem_cache_raw_free, bpf_mem_alloc_check_size",
          "description": "提供基于RCU的内存释放接口，unit_free系列函数将对象加入链表实现批量回收，bpf_mem_free系列根据上下文选择普通或RCU释放路径，check_size验证分配尺寸合法性",
          "similarity": 0.4550313651561737
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/memalloc.c",
          "start_line": 68,
          "end_line": 168,
          "content": [
            "static int bpf_mem_cache_idx(size_t size)",
            "{",
            "\tif (!size || size > BPF_MEM_ALLOC_SIZE_MAX)",
            "\t\treturn -1;",
            "",
            "\tif (size <= 192)",
            "\t\treturn size_index[(size - 1) / 8] - 1;",
            "",
            "\treturn fls(size - 1) - 2;",
            "}",
            "static void inc_active(struct bpf_mem_cache *c, unsigned long *flags)",
            "{",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT))",
            "\t\t/* In RT irq_work runs in per-cpu kthread, so disable",
            "\t\t * interrupts to avoid preemption and interrupts and",
            "\t\t * reduce the chance of bpf prog executing on this cpu",
            "\t\t * when active counter is busy.",
            "\t\t */",
            "\t\tlocal_irq_save(*flags);",
            "\t/* alloc_bulk runs from irq_work which will not preempt a bpf",
            "\t * program that does unit_alloc/unit_free since IRQs are",
            "\t * disabled there. There is no race to increment 'active'",
            "\t * counter. It protects free_llist from corruption in case NMI",
            "\t * bpf prog preempted this loop.",
            "\t */",
            "\tWARN_ON_ONCE(local_inc_return(&c->active) != 1);",
            "}",
            "static void dec_active(struct bpf_mem_cache *c, unsigned long *flags)",
            "{",
            "\tlocal_dec(&c->active);",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT))",
            "\t\tlocal_irq_restore(*flags);",
            "}",
            "static void add_obj_to_free_list(struct bpf_mem_cache *c, void *obj)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tinc_active(c, &flags);",
            "\t__llist_add(obj, &c->free_llist);",
            "\tc->free_cnt++;",
            "\tdec_active(c, &flags);",
            "}",
            "static void alloc_bulk(struct bpf_mem_cache *c, int cnt, int node, bool atomic)",
            "{",
            "\tstruct mem_cgroup *memcg = NULL, *old_memcg;",
            "\tgfp_t gfp;",
            "\tvoid *obj;",
            "\tint i;",
            "",
            "\tgfp = __GFP_NOWARN | __GFP_ACCOUNT;",
            "\tgfp |= atomic ? GFP_NOWAIT : GFP_KERNEL;",
            "",
            "\tfor (i = 0; i < cnt; i++) {",
            "\t\t/*",
            "\t\t * For every 'c' llist_del_first(&c->free_by_rcu_ttrace); is",
            "\t\t * done only by one CPU == current CPU. Other CPUs might",
            "\t\t * llist_add() and llist_del_all() in parallel.",
            "\t\t */",
            "\t\tobj = llist_del_first(&c->free_by_rcu_ttrace);",
            "\t\tif (!obj)",
            "\t\t\tbreak;",
            "\t\tadd_obj_to_free_list(c, obj);",
            "\t}",
            "\tif (i >= cnt)",
            "\t\treturn;",
            "",
            "\tfor (; i < cnt; i++) {",
            "\t\tobj = llist_del_first(&c->waiting_for_gp_ttrace);",
            "\t\tif (!obj)",
            "\t\t\tbreak;",
            "\t\tadd_obj_to_free_list(c, obj);",
            "\t}",
            "\tif (i >= cnt)",
            "\t\treturn;",
            "",
            "\tmemcg = get_memcg(c);",
            "\told_memcg = set_active_memcg(memcg);",
            "\tfor (; i < cnt; i++) {",
            "\t\t/* Allocate, but don't deplete atomic reserves that typical",
            "\t\t * GFP_ATOMIC would do. irq_work runs on this cpu and kmalloc",
            "\t\t * will allocate from the current numa node which is what we",
            "\t\t * want here.",
            "\t\t */",
            "\t\tobj = __alloc(c, node, gfp);",
            "\t\tif (!obj)",
            "\t\t\tbreak;",
            "\t\tadd_obj_to_free_list(c, obj);",
            "\t}",
            "\tset_active_memcg(old_memcg);",
            "\tmem_cgroup_put(memcg);",
            "}",
            "static void free_one(void *obj, bool percpu)",
            "{",
            "\tif (percpu) {",
            "\t\tfree_percpu(((void __percpu **)obj)[1]);",
            "\t\tkfree(obj);",
            "\t\treturn;",
            "\t}",
            "",
            "\tkfree(obj);",
            "}"
          ],
          "function_name": "bpf_mem_cache_idx, inc_active, dec_active, add_obj_to_free_list, alloc_bulk, free_one",
          "description": "实现BPF内存缓存核心控制逻辑，包含大小索引计算、活跃计数器管理、对象回收到自由链表、批量分配与释放流程。通过irq_work异步补充缓存，处理多CPU间的内存对象迁移与回收。",
          "similarity": 0.44368085265159607
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/bpf/memalloc.c",
          "start_line": 576,
          "end_line": 682,
          "content": [
            "int bpf_mem_alloc_percpu_init(struct bpf_mem_alloc *ma, struct obj_cgroup *objcg)",
            "{",
            "\tstruct bpf_mem_caches __percpu *pcc;",
            "",
            "\tpcc = __alloc_percpu_gfp(sizeof(struct bpf_mem_caches), 8, GFP_KERNEL);",
            "\tif (!pcc)",
            "\t\treturn -ENOMEM;",
            "",
            "\tma->caches = pcc;",
            "\tma->objcg = objcg;",
            "\tma->percpu = true;",
            "\treturn 0;",
            "}",
            "int bpf_mem_alloc_percpu_unit_init(struct bpf_mem_alloc *ma, int size)",
            "{",
            "\tstruct bpf_mem_caches *cc; struct bpf_mem_caches __percpu *pcc;",
            "\tint cpu, i, unit_size, percpu_size;",
            "\tstruct obj_cgroup *objcg;",
            "\tstruct bpf_mem_cache *c;",
            "",
            "\ti = bpf_mem_cache_idx(size);",
            "\tif (i < 0)",
            "\t\treturn -EINVAL;",
            "",
            "\t/* room for llist_node and per-cpu pointer */",
            "\tpercpu_size = LLIST_NODE_SZ + sizeof(void *);",
            "",
            "\tunit_size = sizes[i];",
            "\tobjcg = ma->objcg;",
            "\tpcc = ma->caches;",
            "",
            "\tfor_each_possible_cpu(cpu) {",
            "\t\tcc = per_cpu_ptr(pcc, cpu);",
            "\t\tc = &cc->cache[i];",
            "\t\tif (cpu == 0 && c->unit_size)",
            "\t\t\tbreak;",
            "",
            "\t\tc->unit_size = unit_size;",
            "\t\tc->objcg = objcg;",
            "\t\tc->percpu_size = percpu_size;",
            "\t\tc->tgt = c;",
            "",
            "\t\tinit_refill_work(c);",
            "\t\tprefill_mem_cache(c, cpu);",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static void drain_mem_cache(struct bpf_mem_cache *c)",
            "{",
            "\tbool percpu = !!c->percpu_size;",
            "",
            "\t/* No progs are using this bpf_mem_cache, but htab_map_free() called",
            "\t * bpf_mem_cache_free() for all remaining elements and they can be in",
            "\t * free_by_rcu_ttrace or in waiting_for_gp_ttrace lists, so drain those lists now.",
            "\t *",
            "\t * Except for waiting_for_gp_ttrace list, there are no concurrent operations",
            "\t * on these lists, so it is safe to use __llist_del_all().",
            "\t */",
            "\tfree_all(llist_del_all(&c->free_by_rcu_ttrace), percpu);",
            "\tfree_all(llist_del_all(&c->waiting_for_gp_ttrace), percpu);",
            "\tfree_all(__llist_del_all(&c->free_llist), percpu);",
            "\tfree_all(__llist_del_all(&c->free_llist_extra), percpu);",
            "\tfree_all(__llist_del_all(&c->free_by_rcu), percpu);",
            "\tfree_all(__llist_del_all(&c->free_llist_extra_rcu), percpu);",
            "\tfree_all(llist_del_all(&c->waiting_for_gp), percpu);",
            "}",
            "static void check_mem_cache(struct bpf_mem_cache *c)",
            "{",
            "\tWARN_ON_ONCE(!llist_empty(&c->free_by_rcu_ttrace));",
            "\tWARN_ON_ONCE(!llist_empty(&c->waiting_for_gp_ttrace));",
            "\tWARN_ON_ONCE(!llist_empty(&c->free_llist));",
            "\tWARN_ON_ONCE(!llist_empty(&c->free_llist_extra));",
            "\tWARN_ON_ONCE(!llist_empty(&c->free_by_rcu));",
            "\tWARN_ON_ONCE(!llist_empty(&c->free_llist_extra_rcu));",
            "\tWARN_ON_ONCE(!llist_empty(&c->waiting_for_gp));",
            "}",
            "static void check_leaked_objs(struct bpf_mem_alloc *ma)",
            "{",
            "\tstruct bpf_mem_caches *cc;",
            "\tstruct bpf_mem_cache *c;",
            "\tint cpu, i;",
            "",
            "\tif (ma->cache) {",
            "\t\tfor_each_possible_cpu(cpu) {",
            "\t\t\tc = per_cpu_ptr(ma->cache, cpu);",
            "\t\t\tcheck_mem_cache(c);",
            "\t\t}",
            "\t}",
            "\tif (ma->caches) {",
            "\t\tfor_each_possible_cpu(cpu) {",
            "\t\t\tcc = per_cpu_ptr(ma->caches, cpu);",
            "\t\t\tfor (i = 0; i < NUM_CACHES; i++) {",
            "\t\t\t\tc = &cc->cache[i];",
            "\t\t\t\tcheck_mem_cache(c);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
            "static void free_mem_alloc_no_barrier(struct bpf_mem_alloc *ma)",
            "{",
            "\tcheck_leaked_objs(ma);",
            "\tfree_percpu(ma->cache);",
            "\tfree_percpu(ma->caches);",
            "\tma->cache = NULL;",
            "\tma->caches = NULL;",
            "}"
          ],
          "function_name": "bpf_mem_alloc_percpu_init, bpf_mem_alloc_percpu_unit_init, drain_mem_cache, check_mem_cache, check_leaked_objs, free_mem_alloc_no_barrier",
          "description": "实现Per-CPU内存分配器的初始化与清理逻辑，包含Per-CPU缓存初始化、对象回收链表遍历、内存泄漏检测及资源释放。提供模块卸载时的强制清理接口，确保所有残留对象被正确释放。",
          "similarity": 0.40904054045677185
        }
      ]
    }
  ]
}