{
  "query": "从而影响磁盘空间的使用 日志文件系统",
  "timestamp": "2025-12-26 00:24:53",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/log.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:15:45\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\log.c`\n\n---\n\n# bpf/log.c 技术文档\n\n## 1. 文件概述\n\n`bpf/log.c` 是 Linux 内核 BPF（Berkeley Packet Filter）子系统中负责日志记录的核心实现文件。该文件为 BPF 验证器（verifier）提供灵活、高效的日志输出机制，支持将验证过程中的诊断信息输出到用户空间缓冲区或内核日志（`pr_err`）。日志系统支持两种模式：**固定模式**（`BPF_LOG_FIXED`）和**循环缓冲模式**（默认），并能处理大容量日志的截断、回绕和最终整理，确保用户获得连续、有效的验证日志。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`bpf_verifier_log_attr_valid()`**  \n  验证 `bpf_verifier_log` 结构体的属性是否合法，包括用户缓冲区指针与大小的一致性、日志级别有效性等。\n\n- **`bpf_vlog_init()`**  \n  初始化 `bpf_verifier_log` 结构体，设置日志级别、用户缓冲区指针和大小，并进行合法性校验。\n\n- **`bpf_verifier_vlog()`**  \n  核心日志写入函数，接收格式化字符串和可变参数列表，根据日志模式（固定/循环）将内容写入内核临时缓冲区并复制到用户空间，或直接输出到内核日志。\n\n- **`bpf_vlog_reset()`**  \n  重置日志写入位置（用于回溯验证路径时清理无效日志），并更新用户缓冲区对应位置为 `\\0`。\n\n- **`bpf_vlog_finalize()`**  \n  在验证结束时整理日志内容：若使用循环缓冲且发生回绕，则通过三次反转算法将日志内容原地旋转为从缓冲区开头开始的连续字符串。\n\n- **`bpf_vlog_reverse_kbuf()` / `bpf_vlog_reverse_ubuf()`**  \n  辅助函数，分别用于反转内核临时缓冲区和用户空间日志缓冲区的指定区段，支撑 `bpf_vlog_finalize()` 中的原地旋转算法。\n\n### 关键数据结构\n\n- **`struct bpf_verifier_log`**（定义在 `bpf_verifier.h` 中）  \n  包含日志级别（`level`）、用户缓冲区指针（`ubuf`）、缓冲区总大小（`len_total`）、当前写入结束位置（`end_pos`）、循环缓冲起始位置（`start_pos`）、最大日志长度（`len_max`）以及内核临时缓冲区（`kbuf`）等字段。\n\n## 3. 关键实现\n\n### 日志模式\n\n- **固定模式（`BPF_LOG_FIXED`）**：日志从缓冲区开头顺序写入，超出部分被丢弃。适用于需要完整前缀日志的场景。\n- **循环缓冲模式（默认）**：当日志超出缓冲区大小时，覆盖最早写入的内容，始终保持最新的日志。适用于关注最新错误信息的场景。\n\n### 日志写入流程\n\n1. 使用 `vscnprintf` 将格式化日志写入内核临时缓冲区 `kbuf`（大小为 `BPF_VERIFIER_TMP_LOG_SIZE`）。\n2. 若日志级别为 `BPF_LOG_KERNEL`，直接通过 `pr_err` 输出到内核日志。\n3. 否则，根据日志模式：\n   - **固定模式**：计算可写入用户缓冲区的字节数，调用 `copy_to_user`。\n   - **循环模式**：计算写入位置（可能回绕），分一或两个片段调用 `copy_to_user`。\n\n### 日志最终整理（`bpf_vlog_finalize`）\n\n当使用循环缓冲且日志发生回绕（`start_pos != 0`）时，需将日志整理为从缓冲区开头开始的连续字符串。采用**三次反转原地旋转算法**：\n1. 反转整个缓冲区；\n2. 反转前 `sublen` 字节（原尾部）；\n3. 反转后 `len_total - sublen` 字节（原头部）。  \n该算法避免了大内存分配，仅使用固定大小的内核临时缓冲区 `kbuf` 分块处理用户空间内存。\n\n### 安全与健壮性\n\n- 所有 `copy_to_user`/`copy_from_user` 操作均检查返回值，失败时置空 `ubuf` 指针以禁用后续写入。\n- 对日志长度进行溢出检查（`len_total > UINT_MAX >> 2`）。\n- 使用 `WARN_ON_ONCE` 检测非法重置位置。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<uapi/linux/btf.h>`：BTF（BPF Type Format）相关定义。\n  - `<linux/bpf.h>`：BPF 核心数据结构和常量（如 `BPF_LOG_MASK`、`BPF_LOG_KERNEL`、`BPF_LOG_FIXED`）。\n  - `<linux/bpf_verifier.h>`：`struct bpf_verifier_log` 定义及辅助宏（如 `bpf_verifier_log_needed`）。\n  - `<linux/math64.h>`：提供 `div_u64_rem` 等 64 位除法函数。\n- **内核子系统**：\n  - **BPF 验证器**：作为验证器的输出后端，由 `bpf_verifier.c` 调用。\n  - **用户空间交互**：通过 `copy_to_user`/`copy_from_user` 与用户态 BPF 加载程序（如 `libbpf`）通信。\n\n## 5. 使用场景\n\n- **BPF 程序加载验证**：当用户通过 `bpf(BPF_PROG_LOAD, ...)` 系统调用加载 BPF 程序时，内核验证器在检查程序安全性过程中调用本文件的日志函数，将详细错误或警告信息写入用户提供的日志缓冲区。\n- **调试与诊断**：开发者通过设置 `log_level` 和提供足够大的 `log_buf`，获取验证失败的具体原因（如无效指针访问、未初始化寄存器等）。\n- **内核日志输出**：当 `log_level` 设为 `BPF_LOG_KERNEL` 时，日志直接输出到内核日志（`dmesg`），用于内核开发者调试 BPF 验证器本身。\n- **资源受限环境**：循环缓冲模式允许在有限缓冲区大小下捕获最新的验证日志，适用于嵌入式或内存受限系统。",
      "similarity": 0.5458983182907104,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/log.c",
          "start_line": 15,
          "end_line": 143,
          "content": [
            "static bool bpf_verifier_log_attr_valid(const struct bpf_verifier_log *log)",
            "{",
            "\t/* ubuf and len_total should both be specified (or not) together */",
            "\tif (!!log->ubuf != !!log->len_total)",
            "\t\treturn false;",
            "\t/* log buf without log_level is meaningless */",
            "\tif (log->ubuf && log->level == 0)",
            "\t\treturn false;",
            "\tif (log->level & ~BPF_LOG_MASK)",
            "\t\treturn false;",
            "\tif (log->len_total > UINT_MAX >> 2)",
            "\t\treturn false;",
            "\treturn true;",
            "}",
            "int bpf_vlog_init(struct bpf_verifier_log *log, u32 log_level,",
            "\t\t  char __user *log_buf, u32 log_size)",
            "{",
            "\tlog->level = log_level;",
            "\tlog->ubuf = log_buf;",
            "\tlog->len_total = log_size;",
            "",
            "\t/* log attributes have to be sane */",
            "\tif (!bpf_verifier_log_attr_valid(log))",
            "\t\treturn -EINVAL;",
            "",
            "\treturn 0;",
            "}",
            "static void bpf_vlog_update_len_max(struct bpf_verifier_log *log, u32 add_len)",
            "{",
            "\t/* add_len includes terminal \\0, so no need for +1. */",
            "\tu64 len = log->end_pos + add_len;",
            "",
            "\t/* log->len_max could be larger than our current len due to",
            "\t * bpf_vlog_reset() calls, so we maintain the max of any length at any",
            "\t * previous point",
            "\t */",
            "\tif (len > UINT_MAX)",
            "\t\tlog->len_max = UINT_MAX;",
            "\telse if (len > log->len_max)",
            "\t\tlog->len_max = len;",
            "}",
            "void bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,",
            "\t\t       va_list args)",
            "{",
            "\tu64 cur_pos;",
            "\tu32 new_n, n;",
            "",
            "\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);",
            "",
            "\tif (log->level == BPF_LOG_KERNEL) {",
            "\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';",
            "",
            "\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");",
            "\t\treturn;",
            "\t}",
            "",
            "\tn += 1; /* include terminating zero */",
            "\tbpf_vlog_update_len_max(log, n);",
            "",
            "\tif (log->level & BPF_LOG_FIXED) {",
            "\t\t/* check if we have at least something to put into user buf */",
            "\t\tnew_n = 0;",
            "\t\tif (log->end_pos < log->len_total) {",
            "\t\t\tnew_n = min_t(u32, log->len_total - log->end_pos, n);",
            "\t\t\tlog->kbuf[new_n - 1] = '\\0';",
            "\t\t}",
            "",
            "\t\tcur_pos = log->end_pos;",
            "\t\tlog->end_pos += n - 1; /* don't count terminating '\\0' */",
            "",
            "\t\tif (log->ubuf && new_n &&",
            "\t\t    copy_to_user(log->ubuf + cur_pos, log->kbuf, new_n))",
            "\t\t\tgoto fail;",
            "\t} else {",
            "\t\tu64 new_end, new_start;",
            "\t\tu32 buf_start, buf_end, new_n;",
            "",
            "\t\tnew_end = log->end_pos + n;",
            "\t\tif (new_end - log->start_pos >= log->len_total)",
            "\t\t\tnew_start = new_end - log->len_total;",
            "\t\telse",
            "\t\t\tnew_start = log->start_pos;",
            "",
            "\t\tlog->start_pos = new_start;",
            "\t\tlog->end_pos = new_end - 1; /* don't count terminating '\\0' */",
            "",
            "\t\tif (!log->ubuf)",
            "\t\t\treturn;",
            "",
            "\t\tnew_n = min(n, log->len_total);",
            "\t\tcur_pos = new_end - new_n;",
            "\t\tdiv_u64_rem(cur_pos, log->len_total, &buf_start);",
            "\t\tdiv_u64_rem(new_end, log->len_total, &buf_end);",
            "\t\t/* new_end and buf_end are exclusive indices, so if buf_end is",
            "\t\t * exactly zero, then it actually points right to the end of",
            "\t\t * ubuf and there is no wrap around",
            "\t\t */",
            "\t\tif (buf_end == 0)",
            "\t\t\tbuf_end = log->len_total;",
            "",
            "\t\t/* if buf_start > buf_end, we wrapped around;",
            "\t\t * if buf_start == buf_end, then we fill ubuf completely; we",
            "\t\t * can't have buf_start == buf_end to mean that there is",
            "\t\t * nothing to write, because we always write at least",
            "\t\t * something, even if terminal '\\0'",
            "\t\t */",
            "\t\tif (buf_start < buf_end) {",
            "\t\t\t/* message fits within contiguous chunk of ubuf */",
            "\t\t\tif (copy_to_user(log->ubuf + buf_start,",
            "\t\t\t\t\t log->kbuf + n - new_n,",
            "\t\t\t\t\t buf_end - buf_start))",
            "\t\t\t\tgoto fail;",
            "\t\t} else {",
            "\t\t\t/* message wraps around the end of ubuf, copy in two chunks */",
            "\t\t\tif (copy_to_user(log->ubuf + buf_start,",
            "\t\t\t\t\t log->kbuf + n - new_n,",
            "\t\t\t\t\t log->len_total - buf_start))",
            "\t\t\t\tgoto fail;",
            "\t\t\tif (copy_to_user(log->ubuf,",
            "\t\t\t\t\t log->kbuf + n - buf_end,",
            "\t\t\t\t\t buf_end))",
            "\t\t\t\tgoto fail;",
            "\t\t}",
            "\t}",
            "",
            "\treturn;",
            "fail:",
            "\tlog->ubuf = NULL;",
            "}"
          ],
          "function_name": "bpf_verifier_log_attr_valid, bpf_vlog_init, bpf_vlog_update_len_max, bpf_verifier_vlog",
          "description": "实现日志属性校验、初始化、长度更新及日志写入逻辑，负责管理日志缓冲区的有效性和数据写入操作。",
          "similarity": 0.6231868267059326
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/log.c",
          "start_line": 148,
          "end_line": 294,
          "content": [
            "void bpf_vlog_reset(struct bpf_verifier_log *log, u64 new_pos)",
            "{",
            "\tchar zero = 0;",
            "\tu32 pos;",
            "",
            "\tif (WARN_ON_ONCE(new_pos > log->end_pos))",
            "\t\treturn;",
            "",
            "\tif (!bpf_verifier_log_needed(log) || log->level == BPF_LOG_KERNEL)",
            "\t\treturn;",
            "",
            "\t/* if position to which we reset is beyond current log window,",
            "\t * then we didn't preserve any useful content and should adjust",
            "\t * start_pos to end up with an empty log (start_pos == end_pos)",
            "\t */",
            "\tlog->end_pos = new_pos;",
            "\tif (log->end_pos < log->start_pos)",
            "\t\tlog->start_pos = log->end_pos;",
            "",
            "\tif (!log->ubuf)",
            "\t\treturn;",
            "",
            "\tif (log->level & BPF_LOG_FIXED)",
            "\t\tpos = log->end_pos + 1;",
            "\telse",
            "\t\tdiv_u64_rem(new_pos, log->len_total, &pos);",
            "",
            "\tif (pos < log->len_total && put_user(zero, log->ubuf + pos))",
            "\t\tlog->ubuf = NULL;",
            "}",
            "static void bpf_vlog_reverse_kbuf(char *buf, int len)",
            "{",
            "\tint i, j;",
            "",
            "\tfor (i = 0, j = len - 1; i < j; i++, j--)",
            "\t\tswap(buf[i], buf[j]);",
            "}",
            "static int bpf_vlog_reverse_ubuf(struct bpf_verifier_log *log, int start, int end)",
            "{",
            "\t/* we split log->kbuf into two equal parts for both ends of array */",
            "\tint n = sizeof(log->kbuf) / 2, nn;",
            "\tchar *lbuf = log->kbuf, *rbuf = log->kbuf + n;",
            "",
            "\t/* Read ubuf's section [start, end) two chunks at a time, from left",
            "\t * and right side; within each chunk, swap all the bytes; after that",
            "\t * reverse the order of lbuf and rbuf and write result back to ubuf.",
            "\t * This way we'll end up with swapped contents of specified",
            "\t * [start, end) ubuf segment.",
            "\t */",
            "\twhile (end - start > 1) {",
            "\t\tnn = min(n, (end - start ) / 2);",
            "",
            "\t\tif (copy_from_user(lbuf, log->ubuf + start, nn))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (copy_from_user(rbuf, log->ubuf + end - nn, nn))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tbpf_vlog_reverse_kbuf(lbuf, nn);",
            "\t\tbpf_vlog_reverse_kbuf(rbuf, nn);",
            "",
            "\t\t/* we write lbuf to the right end of ubuf, while rbuf to the",
            "\t\t * left one to end up with properly reversed overall ubuf",
            "\t\t */",
            "\t\tif (copy_to_user(log->ubuf + start, rbuf, nn))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (copy_to_user(log->ubuf + end - nn, lbuf, nn))",
            "\t\t\treturn -EFAULT;",
            "",
            "\t\tstart += nn;",
            "\t\tend -= nn;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "int bpf_vlog_finalize(struct bpf_verifier_log *log, u32 *log_size_actual)",
            "{",
            "\tu32 sublen;",
            "\tint err;",
            "",
            "\t*log_size_actual = 0;",
            "\tif (!log || log->level == 0 || log->level == BPF_LOG_KERNEL)",
            "\t\treturn 0;",
            "",
            "\tif (!log->ubuf)",
            "\t\tgoto skip_log_rotate;",
            "\t/* If we never truncated log, there is nothing to move around. */",
            "\tif (log->start_pos == 0)",
            "\t\tgoto skip_log_rotate;",
            "",
            "\t/* Otherwise we need to rotate log contents to make it start from the",
            "\t * buffer beginning and be a continuous zero-terminated string. Note",
            "\t * that if log->start_pos != 0 then we definitely filled up entire log",
            "\t * buffer with no gaps, and we just need to shift buffer contents to",
            "\t * the left by (log->start_pos % log->len_total) bytes.",
            "\t *",
            "\t * Unfortunately, user buffer could be huge and we don't want to",
            "\t * allocate temporary kernel memory of the same size just to shift",
            "\t * contents in a straightforward fashion. Instead, we'll be clever and",
            "\t * do in-place array rotation. This is a leetcode-style problem, which",
            "\t * could be solved by three rotations.",
            "\t *",
            "\t * Let's say we have log buffer that has to be shifted left by 7 bytes",
            "\t * (spaces and vertical bar is just for demonstrative purposes):",
            "\t *   E F G H I J K | A B C D",
            "\t *",
            "\t * First, we reverse entire array:",
            "\t *   D C B A | K J I H G F E",
            "\t *",
            "\t * Then we rotate first 4 bytes (DCBA) and separately last 7 bytes",
            "\t * (KJIHGFE), resulting in a properly rotated array:",
            "\t *   A B C D | E F G H I J K",
            "\t *",
            "\t * We'll utilize log->kbuf to read user memory chunk by chunk, swap",
            "\t * bytes, and write them back. Doing it byte-by-byte would be",
            "\t * unnecessarily inefficient. Altogether we are going to read and",
            "\t * write each byte twice, for total 4 memory copies between kernel and",
            "\t * user space.",
            "\t */",
            "",
            "\t/* length of the chopped off part that will be the beginning;",
            "\t * len(ABCD) in the example above",
            "\t */",
            "\tdiv_u64_rem(log->start_pos, log->len_total, &sublen);",
            "\tsublen = log->len_total - sublen;",
            "",
            "\terr = bpf_vlog_reverse_ubuf(log, 0, log->len_total);",
            "\terr = err ?: bpf_vlog_reverse_ubuf(log, 0, sublen);",
            "\terr = err ?: bpf_vlog_reverse_ubuf(log, sublen, log->len_total);",
            "\tif (err)",
            "\t\tlog->ubuf = NULL;",
            "",
            "skip_log_rotate:",
            "\t*log_size_actual = log->len_max;",
            "",
            "\t/* properly initialized log has either both ubuf!=NULL and len_total>0",
            "\t * or ubuf==NULL and len_total==0, so if this condition doesn't hold,",
            "\t * we got a fault somewhere along the way, so report it back",
            "\t */",
            "\tif (!!log->ubuf != !!log->len_total)",
            "\t\treturn -EFAULT;",
            "",
            "\t/* did truncation actually happen? */",
            "\tif (log->ubuf && log->len_max > log->len_total)",
            "\t\treturn -ENOSPC;",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_vlog_reset, bpf_vlog_reverse_kbuf, bpf_vlog_reverse_ubuf, bpf_vlog_finalize",
          "description": "提供日志重置、缓冲区反转及最终化功能，通过旋转日志缓冲区实现连续日志存储并保证数据完整性。",
          "similarity": 0.612321138381958
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/log.c",
          "start_line": 303,
          "end_line": 462,
          "content": [
            "__printf(2, 3) void bpf_verifier_log_write(struct bpf_verifier_env *env,",
            "\t\t\t\t\t   const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "",
            "\tif (!bpf_verifier_log_needed(&env->log))",
            "\t\treturn;",
            "",
            "\tva_start(args, fmt);",
            "\tbpf_verifier_vlog(&env->log, fmt, args);",
            "\tva_end(args);",
            "}",
            "__printf(2, 3) void bpf_log(struct bpf_verifier_log *log,",
            "\t\t\t    const char *fmt, ...)",
            "{",
            "\tva_list args;",
            "",
            "\tif (!bpf_verifier_log_needed(log))",
            "\t\treturn;",
            "",
            "\tva_start(args, fmt);",
            "\tbpf_verifier_vlog(log, fmt, args);",
            "\tva_end(args);",
            "}",
            "__printf(3, 4) void verbose_linfo(struct bpf_verifier_env *env,",
            "\t\t\t\t  u32 insn_off,",
            "\t\t\t\t  const char *prefix_fmt, ...)",
            "{",
            "\tconst struct bpf_line_info *linfo;",
            "",
            "\tif (!bpf_verifier_log_needed(&env->log))",
            "\t\treturn;",
            "",
            "\tlinfo = find_linfo(env, insn_off);",
            "\tif (!linfo || linfo == env->prev_linfo)",
            "\t\treturn;",
            "",
            "\tif (prefix_fmt) {",
            "\t\tva_list args;",
            "",
            "\t\tva_start(args, prefix_fmt);",
            "\t\tbpf_verifier_vlog(&env->log, prefix_fmt, args);",
            "\t\tva_end(args);",
            "\t}",
            "",
            "\tverbose(env, \"%s\\n\",",
            "\t\tltrim(btf_name_by_offset(env->prog->aux->btf,",
            "\t\t\t\t\t linfo->line_off)));",
            "",
            "\tenv->prev_linfo = linfo;",
            "}",
            "static void print_liveness(struct bpf_verifier_env *env,",
            "\t\t\t   enum bpf_reg_liveness live)",
            "{",
            "\tif (live & (REG_LIVE_READ | REG_LIVE_WRITTEN | REG_LIVE_DONE))",
            "\t    verbose(env, \"_\");",
            "\tif (live & REG_LIVE_READ)",
            "\t\tverbose(env, \"r\");",
            "\tif (live & REG_LIVE_WRITTEN)",
            "\t\tverbose(env, \"w\");",
            "\tif (live & REG_LIVE_DONE)",
            "\t\tverbose(env, \"D\");",
            "}",
            "static bool is_unum_decimal(u64 num)",
            "{",
            "\treturn num <= UNUM_MAX_DECIMAL;",
            "}",
            "static bool is_snum_decimal(s64 num)",
            "{",
            "\treturn num >= SNUM_MIN_DECIMAL && num <= SNUM_MAX_DECIMAL;",
            "}",
            "static void verbose_unum(struct bpf_verifier_env *env, u64 num)",
            "{",
            "\tif (is_unum_decimal(num))",
            "\t\tverbose(env, \"%llu\", num);",
            "\telse",
            "\t\tverbose(env, \"%#llx\", num);",
            "}",
            "static void verbose_snum(struct bpf_verifier_env *env, s64 num)",
            "{",
            "\tif (is_snum_decimal(num))",
            "\t\tverbose(env, \"%lld\", num);",
            "\telse",
            "\t\tverbose(env, \"%#llx\", num);",
            "}",
            "int tnum_strn(char *str, size_t size, struct tnum a)",
            "{",
            "\t/* print as a constant, if tnum is fully known */",
            "\tif (a.mask == 0) {",
            "\t\tif (is_unum_decimal(a.value))",
            "\t\t\treturn snprintf(str, size, \"%llu\", a.value);",
            "\t\telse",
            "\t\t\treturn snprintf(str, size, \"%#llx\", a.value);",
            "\t}",
            "\treturn snprintf(str, size, \"(%#llx; %#llx)\", a.value, a.mask);",
            "}",
            "static void print_scalar_ranges(struct bpf_verifier_env *env,",
            "\t\t\t\tconst struct bpf_reg_state *reg,",
            "\t\t\t\tconst char **sep)",
            "{",
            "\t/* For signed ranges, we want to unify 64-bit and 32-bit values in the",
            "\t * output as much as possible, but there is a bit of a complication.",
            "\t * If we choose to print values as decimals, this is natural to do,",
            "\t * because negative 64-bit and 32-bit values >= -S32_MIN have the same",
            "\t * representation due to sign extension. But if we choose to print",
            "\t * them in hex format (see is_snum_decimal()), then sign extension is",
            "\t * misleading.",
            "\t * E.g., smin=-2 and smin32=-2 are exactly the same in decimal, but in",
            "\t * hex they will be smin=0xfffffffffffffffe and smin32=0xfffffffe, two",
            "\t * very different numbers.",
            "\t * So we avoid sign extension if we choose to print values in hex.",
            "\t */",
            "\tstruct {",
            "\t\tconst char *name;",
            "\t\tu64 val;",
            "\t\tbool omit;",
            "\t} minmaxs[] = {",
            "\t\t{\"smin\",   reg->smin_value,         reg->smin_value == S64_MIN},",
            "\t\t{\"smax\",   reg->smax_value,         reg->smax_value == S64_MAX},",
            "\t\t{\"umin\",   reg->umin_value,         reg->umin_value == 0},",
            "\t\t{\"umax\",   reg->umax_value,         reg->umax_value == U64_MAX},",
            "\t\t{\"smin32\",",
            "\t\t is_snum_decimal((s64)reg->s32_min_value)",
            "\t\t\t ? (s64)reg->s32_min_value",
            "\t\t\t : (u32)reg->s32_min_value, reg->s32_min_value == S32_MIN},",
            "\t\t{\"smax32\",",
            "\t\t is_snum_decimal((s64)reg->s32_max_value)",
            "\t\t\t ? (s64)reg->s32_max_value",
            "\t\t\t : (u32)reg->s32_max_value, reg->s32_max_value == S32_MAX},",
            "\t\t{\"umin32\", reg->u32_min_value,      reg->u32_min_value == 0},",
            "\t\t{\"umax32\", reg->u32_max_value,      reg->u32_max_value == U32_MAX},",
            "\t}, *m1, *m2, *mend = &minmaxs[ARRAY_SIZE(minmaxs)];",
            "\tbool neg1, neg2;",
            "",
            "\tfor (m1 = &minmaxs[0]; m1 < mend; m1++) {",
            "\t\tif (m1->omit)",
            "\t\t\tcontinue;",
            "",
            "\t\tneg1 = m1->name[0] == 's' && (s64)m1->val < 0;",
            "",
            "\t\tverbose(env, \"%s%s=\", *sep, m1->name);",
            "\t\t*sep = \",\";",
            "",
            "\t\tfor (m2 = m1 + 2; m2 < mend; m2 += 2) {",
            "\t\t\tif (m2->omit || m2->val != m1->val)",
            "\t\t\t\tcontinue;",
            "\t\t\t/* don't mix negatives with positives */",
            "\t\t\tneg2 = m2->name[0] == 's' && (s64)m2->val < 0;",
            "\t\t\tif (neg2 != neg1)",
            "\t\t\t\tcontinue;",
            "\t\t\tm2->omit = true;",
            "\t\t\tverbose(env, \"%s=\", m2->name);",
            "\t\t}",
            "",
            "\t\tif (m1->name[0] == 's')",
            "\t\t\tverbose_snum(env, m1->val);",
            "\t\telse",
            "\t\t\tverbose_unum(env, m1->val);",
            "\t}",
            "}"
          ],
          "function_name": "bpf_verifier_log_write, bpf_log, verbose_linfo, print_liveness, is_unum_decimal, is_snum_decimal, verbose_unum, verbose_snum, tnum_strn, print_scalar_ranges",
          "description": "包含日志格式化辅助函数，支持指令信息打印、寄存器存活状态显示及数值范围解析等多样化日志输出需求。",
          "similarity": 0.5985101461410522
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/log.c",
          "start_line": 1,
          "end_line": 14,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com",
            " * Copyright (c) 2016 Facebook",
            " * Copyright (c) 2018 Covalent IO, Inc. http://covalent.io",
            " */",
            "#include <uapi/linux/btf.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/math64.h>",
            "",
            "#define verbose(env, fmt, args...) bpf_verifier_log_write(env, fmt, ##args)",
            ""
          ],
          "function_name": null,
          "description": "定义了BPF验证器日志相关的头文件和宏，其中`verbose`宏用于向内核日志写入验证器相关信息。",
          "similarity": 0.5113041996955872
        },
        {
          "chunk_id": 5,
          "file_path": "kernel/bpf/log.c",
          "start_line": 814,
          "end_line": 830,
          "content": [
            "static inline u32 vlog_alignment(u32 pos)",
            "{",
            "\treturn round_up(max(pos + BPF_LOG_MIN_ALIGNMENT / 2, BPF_LOG_ALIGNMENT),",
            "\t\t\tBPF_LOG_MIN_ALIGNMENT) - pos - 1;",
            "}",
            "void print_insn_state(struct bpf_verifier_env *env, const struct bpf_verifier_state *vstate,",
            "\t\t      u32 frameno)",
            "{",
            "\tif (env->prev_log_pos && env->prev_log_pos == env->log.end_pos) {",
            "\t\t/* remove new line character */",
            "\t\tbpf_vlog_reset(&env->log, env->prev_log_pos - 1);",
            "\t\tverbose(env, \"%*c;\", vlog_alignment(env->prev_insn_print_pos), ' ');",
            "\t} else {",
            "\t\tverbose(env, \"%d:\", env->insn_idx);",
            "\t}",
            "\tprint_verifier_state(env, vstate, frameno, false);",
            "}"
          ],
          "function_name": "vlog_alignment, print_insn_state",
          "description": "该代码片段实现BPF验证日志的格式化输出控制。vlog_alignment函数计算日志记录时所需的对齐空格数量，通过取当前位置到下一个对齐边界的距离实现。print_insn_state函数负责在验证过程中按需输出指令状态信息，通过判断日志位置状态决定是否重置日志并添加对齐符号，但存在依赖未展示的宏定义和print_verifier_state函数，上下文不完整。",
          "similarity": 0.5022830367088318
        }
      ]
    },
    {
      "source_file": "kernel/user.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:45:58\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `user.c`\n\n---\n\n# user.c 技术文档\n\n## 1. 文件概述\n\n`user.c` 实现了 Linux 内核中的 **用户缓存（user cache）** 机制，用于跟踪每个用户（以 UID 标识）所占用的系统资源（如进程数、打开文件数等），从而支持基于用户的资源限制（per-user limits）。该文件维护了一个全局的哈希表，用于快速查找和管理 `user_struct` 结构体实例，并提供了用户结构的分配、引用计数管理和释放接口。此外，文件还定义了初始用户命名空间 `init_user_ns` 和根用户结构 `root_user`，为系统启动和用户命名空间功能提供基础支持。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`init_user_ns`**：全局初始用户命名空间（`struct user_namespace`），作为所有用户命名空间的根，包含完整的 UID/GID/ProjID 映射（0~2³²-1），引用计数初始化为 3。\n- **`root_user`**：代表 UID 为 0 的根用户的 `struct user_struct` 实例，引用计数初始化为 1（供 init 进程使用）。\n- **`uidhash_table`**：大小为 `2^UIDHASH_BITS`（通常为 128）的哈希表，用于存储 `user_struct` 实例，实现 O(1) 平均查找复杂度。\n- **`uid_cachep`**：SLAB 缓存，用于高效分配和释放 `struct user_struct` 对象。\n\n### 主要函数\n\n- **`alloc_uid(kuid_t uid)`**：根据 UID 查找或创建对应的 `user_struct`。若不存在则分配新结构体，初始化资源计数器（如 epoll watches），并插入哈希表；若已存在则增加引用计数。处理并发创建的竞争条件。\n- **`find_user(kuid_t uid)`**：在哈希表中查找指定 UID 的 `user_struct`，若找到则增加引用计数并返回，否则返回 NULL。\n- **`free_uid(struct user_struct *up)`**：减少 `user_struct` 的引用计数，若计数归零则调用 `free_user` 释放资源。\n- **`free_user(struct user_struct *up, unsigned long flags)`**：内部函数，从哈希表中移除用户结构，释放 epoll 计数器，并通过 SLAB 缓存回收内存。\n- **`uid_cache_init(void)`**：初始化函数（通过 `subsys_initcall` 注册），创建 SLAB 缓存、初始化哈希表、为 `root_user` 分配 epoll 计数器，并将 `root_user` 插入哈希表。\n\n### 辅助函数\n\n- **`uid_hash_insert/remove/find`**：哈希表操作的内部封装，必须在持有 `uidhash_lock` 自旋锁时调用。\n- **`user_epoll_alloc/free`**：条件编译函数，用于初始化/销毁 `user_struct` 中的 epoll watches per-CPU 计数器（仅当 `CONFIG_EPOLL` 启用时有效）。\n\n## 3. 关键实现\n\n### 哈希表设计与并发控制\n\n- **哈希函数**：使用 `__uidhashfn(uid) = ((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK`，将 32 位 UID 映射到 `UIDHASH_SZ`（默认 128）个桶中，减少冲突。\n- **锁机制**：使用 `DEFINE_SPINLOCK(uidhash_lock)` 保护哈希表操作。该锁需 **软中断安全（softirq-safe）**，因为 `free_uid()` 可能在 RCU 回调（软中断上下文）中被调用。\n- **中断处理**：所有哈希表操作均使用 `spin_lock_irqsave/restore` 或 `spin_lock_irq/unlock`，确保在中断上下文和进程上下文间的正确同步。\n\n### 引用计数与资源管理\n\n- **引用计数**：`user_struct.__count` 使用 `refcount_t` 类型，确保原子操作。`alloc_uid` 返回时已持有引用，调用者必须通过 `free_uid` 释放。\n- **延迟释放**：`free_uid` 使用 `refcount_dec_and_lock_irqsave` 原子地减少计数并在归零时获取锁，避免竞态条件。\n- **资源初始化**：新创建的 `user_struct` 会初始化速率限制器（`ratelimit`）和 epoll watches 计数器（若启用）。\n\n### 初始化与竞态处理\n\n- **`root_user` 预置**：在 `uid_cache_init` 中预先将 `root_user` 插入哈希表，确保 init 进程可直接使用。\n- **双重检查**：`alloc_uid` 在分配新结构后再次检查哈希表，防止多线程同时创建同一 UID 的 `user_struct`，确保唯一性。\n\n### 用户命名空间支持\n\n- **`init_user_ns`**：作为初始用户命名空间，其 UID/GID 映射覆盖全范围（0 到 2³²-1），标志位 `USERNS_INIT_FLAGS` 启用特定行为（如允许 setgroups）。\n- **密钥环支持**：若启用 `CONFIG_KEYS`，`init_user_ns` 包含密钥环名称列表和读写信号量。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/sched/user.h>`：定义 `struct user_struct`。\n  - `<linux/user_namespace.h>`：定义 `struct user_namespace` 和相关操作。\n  - `<linux/key.h>`：提供密钥环支持（条件编译）。\n  - `<linux/percpu_counter.h>`（隐含）：用于 epoll watches 计数（通过 `CONFIG_EPOLL`）。\n- **内核配置依赖**：\n  - `CONFIG_EPOLL`：控制 epoll watches 计数器的编译。\n  - `CONFIG_USER_NS`：控制用户命名空间操作函数的绑定。\n  - `CONFIG_KEYS`：控制密钥环相关字段的初始化。\n- **子系统依赖**：\n  - **进程调度子系统**：`user_struct` 被嵌入到进程凭证（`cred`）中，用于资源统计。\n  - **用户命名空间子系统**：`init_user_ns` 是用户命名空间层次结构的根。\n  - **内存管理子系统**：依赖 SLAB 分配器管理 `user_struct` 对象。\n\n## 5. 使用场景\n\n- **进程凭证管理**：当进程通过 `setuid()`、`setreuid()` 等系统调用切换用户身份时，内核调用 `alloc_uid` 获取目标 UID 的 `user_struct`，并更新进程凭证中的用户引用。\n- **资源限制实施**：内核在创建进程、打开文件、分配内存等操作时，通过 `current_uid()` 获取当前用户的 `user_struct`，检查并更新资源使用计数（如 `processes`、`files` 字段），确保不超过 `ulimit` 限制。\n- **用户命名空间创建**：新用户命名空间的创建依赖 `init_user_ns` 作为父命名空间，并继承其映射逻辑。\n- **系统初始化**：在内核启动早期（`subsys_initcall` 阶段），初始化用户缓存和根用户结构，为 init 进程（PID 1）提供用户上下文。\n- **资源回收**：当进程退出或切换用户时，通过 `free_uid` 释放不再需要的 `user_struct` 引用，最终在引用计数归零时回收内存和相关资源（如 epoll 计数器）。",
      "similarity": 0.5378890037536621,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/user.c",
          "start_line": 1,
          "end_line": 107,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * The \"user cache\".",
            " *",
            " * (C) Copyright 1991-2000 Linus Torvalds",
            " *",
            " * We have a per-user structure to keep track of how many",
            " * processes, files etc the user has claimed, in order to be",
            " * able to have per-user limits for system resources. ",
            " */",
            "",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/proc_ns.h>",
            "",
            "/*",
            " * userns count is 1 for root user, 1 for init_uts_ns,",
            " * and 1 for... ?",
            " */",
            "struct user_namespace init_user_ns = {",
            "\t.uid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.gid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.projid_map = {",
            "\t\t.nr_extents = 1,",
            "\t\t{",
            "\t\t\t.extent[0] = {",
            "\t\t\t\t.first = 0,",
            "\t\t\t\t.lower_first = 0,",
            "\t\t\t\t.count = 4294967295U,",
            "\t\t\t},",
            "\t\t},",
            "\t},",
            "\t.ns.count = REFCOUNT_INIT(3),",
            "\t.owner = GLOBAL_ROOT_UID,",
            "\t.group = GLOBAL_ROOT_GID,",
            "\t.ns.inum = PROC_USER_INIT_INO,",
            "#ifdef CONFIG_USER_NS",
            "\t.ns.ops = &userns_operations,",
            "#endif",
            "\t.flags = USERNS_INIT_FLAGS,",
            "#ifdef CONFIG_KEYS",
            "\t.keyring_name_list = LIST_HEAD_INIT(init_user_ns.keyring_name_list),",
            "\t.keyring_sem = __RWSEM_INITIALIZER(init_user_ns.keyring_sem),",
            "#endif",
            "};",
            "EXPORT_SYMBOL_GPL(init_user_ns);",
            "",
            "/*",
            " * UID task count cache, to get fast user lookup in \"alloc_uid\"",
            " * when changing user ID's (ie setuid() and friends).",
            " */",
            "",
            "#define UIDHASH_BITS\t(CONFIG_BASE_SMALL ? 3 : 7)",
            "#define UIDHASH_SZ\t(1 << UIDHASH_BITS)",
            "#define UIDHASH_MASK\t\t(UIDHASH_SZ - 1)",
            "#define __uidhashfn(uid)\t(((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK)",
            "#define uidhashentry(uid)\t(uidhash_table + __uidhashfn((__kuid_val(uid))))",
            "",
            "static struct kmem_cache *uid_cachep;",
            "static struct hlist_head uidhash_table[UIDHASH_SZ];",
            "",
            "/*",
            " * The uidhash_lock is mostly taken from process context, but it is",
            " * occasionally also taken from softirq/tasklet context, when",
            " * task-structs get RCU-freed. Hence all locking must be softirq-safe.",
            " * But free_uid() is also called with local interrupts disabled, and running",
            " * local_bh_enable() with local interrupts disabled is an error - we'll run",
            " * softirq callbacks, and they can unconditionally enable interrupts, and",
            " * the caller of free_uid() didn't expect that..",
            " */",
            "static DEFINE_SPINLOCK(uidhash_lock);",
            "",
            "/* root_user.__count is 1, for init task cred */",
            "struct user_struct root_user = {",
            "\t.__count\t= REFCOUNT_INIT(1),",
            "\t.uid\t\t= GLOBAL_ROOT_UID,",
            "\t.ratelimit\t= RATELIMIT_STATE_INIT(root_user.ratelimit, 0, 0),",
            "};",
            "",
            "/*",
            " * These routines must be called with the uidhash spinlock held!",
            " */"
          ],
          "function_name": null,
          "description": "定义初始用户命名空间init_user_ns，配置UID/GID/PROJID映射关系并初始化引用计数，建立全局根用户user_struct结构，通过uidhash_table构建基于哈希的UID快速查找表，设置UID哈希锁及缓存参数",
          "similarity": 0.5106077194213867
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/user.c",
          "start_line": 108,
          "end_line": 167,
          "content": [
            "static void uid_hash_insert(struct user_struct *up, struct hlist_head *hashent)",
            "{",
            "\thlist_add_head(&up->uidhash_node, hashent);",
            "}",
            "static void uid_hash_remove(struct user_struct *up)",
            "{",
            "\thlist_del_init(&up->uidhash_node);",
            "}",
            "static int user_epoll_alloc(struct user_struct *up)",
            "{",
            "#ifdef CONFIG_EPOLL",
            "\treturn percpu_counter_init(&up->epoll_watches, 0, GFP_KERNEL);",
            "#else",
            "\treturn 0;",
            "#endif",
            "}",
            "static void user_epoll_free(struct user_struct *up)",
            "{",
            "#ifdef CONFIG_EPOLL",
            "\tpercpu_counter_destroy(&up->epoll_watches);",
            "#endif",
            "}",
            "static void free_user(struct user_struct *up, unsigned long flags)",
            "\t__releases(&uidhash_lock)",
            "{",
            "\tuid_hash_remove(up);",
            "\tspin_unlock_irqrestore(&uidhash_lock, flags);",
            "\tuser_epoll_free(up);",
            "\tkmem_cache_free(uid_cachep, up);",
            "}",
            "void free_uid(struct user_struct *up)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (!up)",
            "\t\treturn;",
            "",
            "\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))",
            "\t\tfree_user(up, flags);",
            "}",
            "static int __init uid_cache_init(void)",
            "{",
            "\tint n;",
            "",
            "\tuid_cachep = kmem_cache_create(\"uid_cache\", sizeof(struct user_struct),",
            "\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);",
            "",
            "\tfor(n = 0; n < UIDHASH_SZ; ++n)",
            "\t\tINIT_HLIST_HEAD(uidhash_table + n);",
            "",
            "\tif (user_epoll_alloc(&root_user))",
            "\t\tpanic(\"root_user epoll percpu counter alloc failed\");",
            "",
            "\t/* Insert the root user immediately (init already runs as root) */",
            "\tspin_lock_irq(&uidhash_lock);",
            "\tuid_hash_insert(&root_user, uidhashentry(GLOBAL_ROOT_UID));",
            "\tspin_unlock_irq(&uidhash_lock);",
            "",
            "\treturn 0;",
            "}"
          ],
          "function_name": "uid_hash_insert, uid_hash_remove, user_epoll_alloc, user_epoll_free, free_user, free_uid, uid_cache_init",
          "description": "实现用户结构体在UID哈希表中的增删操作，管理epoll计数器资源分配释放，提供free_user/free_uid接口完成用户结构销毁流程，初始化uid_cache缓存及哈希表基础结构并注册根用户",
          "similarity": 0.4830266237258911
        }
      ]
    },
    {
      "source_file": "kernel/ucount.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:42:48\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `ucount.c`\n\n---\n\n# ucount.c 技术文档\n\n## 1. 文件概述\n\n`ucount.c` 是 Linux 内核中用于实现用户资源计数（user counts）管理的核心模块。该文件提供了一套机制，用于跟踪和限制每个用户（在特定用户命名空间中）所使用的各种系统资源（如命名空间数量、inotify 实例等）的上限。它通过引用计数、哈希表和 RCU（Read-Copy-Update）机制，高效地管理跨用户命名空间层级的资源使用统计，并支持与 `sysctl` 接口集成，允许用户空间动态配置资源限制。\n\n## 2. 核心功能\n\n### 主要数据结构\n\n- **`struct ucounts`**：表示一个用户（UID）在特定用户命名空间（`user_namespace`）下的资源使用计数器集合。\n  - `ns`：所属的用户命名空间。\n  - `uid`：关联的用户 ID。\n  - `count`：该 `ucounts` 实例自身的引用计数（使用 `rcuref`）。\n  - `ucount[]`：按 `enum ucount_type` 索引的原子计数器，用于跟踪各类命名空间等资源的使用量。\n  - `rlimit[]`：按 `enum rlimit_type` 索引的原子计数器，用于跟踪与 rlimit 相关的资源（如进程数）。\n  - `node`：用于链接到全局哈希表的链表节点。\n  - `rcu`：用于 RCU 释放的回调字段。\n\n- **`init_ucounts`**：全局初始化的 `ucounts` 实例，代表初始用户命名空间中的 root 用户。\n\n- **`ucounts_hashtable`**：全局哈希表，用于快速查找特定 `(ns, uid)` 对应的 `ucounts` 实例。\n\n### 主要函数\n\n- **资源计数管理**\n  - `alloc_ucounts()`：为指定 `(ns, uid)` 分配或查找对应的 `ucounts` 实例。\n  - `put_ucounts()`：减少 `ucounts` 引用计数，若为零则释放资源。\n  - `get_ucounts()`（隐含在 `rcuref_get` 中）：增加 `ucounts` 引用计数。\n\n- **资源使用量增减**\n  - `inc_ucount()` / `dec_ucount()`：增加/减少指定类型（`ucount_type`）的资源使用计数，自动遍历用户命名空间层级。\n  - `inc_rlimit_ucounts()` / `dec_rlimit_ucounts()`：增加/减少指定类型（`rlimit_type`）的 rlimit 相关资源计数。\n  - `inc_rlimit_get_ucounts()` / `dec_rlimit_put_ucounts()`：在增减 rlimit 计数的同时管理 `ucounts` 引用（用于资源首次使用/完全释放时）。\n\n- **Sysctl 接口**\n  - `setup_userns_sysctls()`：为新创建的用户命名空间注册 sysctl 表项。\n  - `retire_userns_sysctls()`：销毁用户命名空间时注销 sysctl 表项。\n\n## 3. 关键实现\n\n### 哈希表与并发控制\n- 使用大小为 `2^10` 的哈希表 (`ucounts_hashtable`) 存储所有 `ucounts` 实例。\n- 哈希函数 `ucounts_hashfn` 结合用户命名空间指针和 UID 值进行散列。\n- 读操作（`find_ucounts`）使用 RCU 保护，无需加锁，提高并发性能。\n- 写操作（插入、删除）使用自旋锁 `ucounts_lock` 保证原子性，并配合 RCU 安全释放内存。\n\n### 用户命名空间层级遍历\n- 资源计数（`ucount[]` 和 `rlimit[]`）在用户命名空间层级中自底向上累加。\n- `inc_ucount` 等函数从当前命名空间开始，逐级向上遍历父命名空间（通过 `iter->ns->ucounts`），确保所有祖先命名空间的资源限制都被检查和更新。\n\n### 资源限制检查\n- `atomic_long_inc_below()` 使用原子比较交换（CAS）循环，在增加计数前检查是否超过上限，避免竞态条件。\n- 若在层级遍历中任一命名空间的资源超限，会回滚已增加的计数并返回失败。\n\n### Sysctl 集成\n- 每个用户命名空间拥有独立的 sysctl 表（`ns->sysctls`），通过 `set_root` 和 `set_lookup` 机制动态绑定。\n- 权限控制：拥有 `CAP_SYS_RESOURCE` 的进程可读写，其他进程仅可读。\n- sysctl 表项（如 `max_user_namespaces`）直接映射到 `ns->ucount_max[]` 数组，供资源计数函数使用。\n\n### 内存安全\n- 使用 `kmemleak` 注解避免内存泄漏误报。\n- 通过 `get_user_ns()` / `put_user_ns()` 管理用户命名空间生命周期，防止 `ucounts` 持有已销毁的命名空间引用。\n- 使用 `kfree_rcu()` 安全释放 `ucounts` 结构体。\n\n## 4. 依赖关系\n\n- **`<linux/user_namespace.h>`**：核心依赖，提供用户命名空间结构和操作函数（如 `get_user_ns`, `put_user_ns`）。\n- **`<linux/sysctl.h>`**：用于实现用户命名空间特定的 sysctl 接口。\n- **`<linux/rcupdate.h>`**（隐含）：通过 `rcuref` 和 RCU 链表实现无锁读取。\n- **`<linux/atomic.h>`**：提供原子操作（`atomic_long_*`）用于资源计数。\n- **命名空间子系统**：与 PID、UTS、IPC、NET、MNT、CGROUP、TIME 等命名空间的创建/销毁逻辑紧密集成。\n- **文件监控子系统**：与 `inotify` 和 `fanotify` 集成，限制其实例和监视项数量。\n\n## 5. 使用场景\n\n- **命名空间创建限制**：当进程尝试创建新的用户、PID、网络等命名空间时，内核调用 `inc_ucount()` 检查并增加对应计数，防止资源耗尽。\n- **文件监控资源管理**：`inotify_init()` 和 `fanotify_init()` 调用 `inc_ucount()` 限制每个用户的监控实例和监视项总数。\n- **进程/线程数限制**：通过 `rlimit` 相关计数器（如 `RLIMIT_NPROC`）跟踪用户进程数，结合 `inc_rlimit_ucounts()` 实现。\n- **动态资源调优**：系统管理员可通过 `/proc/sys/user/` 下的 sysctl 接口（如 `max_user_namespaces`）调整各用户命名空间的资源上限。\n- **容器环境隔离**：在容器运行时（如 Docker、LXC）中，每个容器通常运行在独立的用户命名空间内，`ucounts` 机制确保容器间的资源使用相互隔离且受控。",
      "similarity": 0.5377594232559204,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/ucount.c",
          "start_line": 37,
          "end_line": 149,
          "content": [
            "static int set_is_seen(struct ctl_table_set *set)",
            "{",
            "\treturn &current_user_ns()->set == set;",
            "}",
            "static int set_permissions(struct ctl_table_header *head,",
            "\t\t\t\t  struct ctl_table *table)",
            "{",
            "\tstruct user_namespace *user_ns =",
            "\t\tcontainer_of(head->set, struct user_namespace, set);",
            "\tint mode;",
            "",
            "\t/* Allow users with CAP_SYS_RESOURCE unrestrained access */",
            "\tif (ns_capable(user_ns, CAP_SYS_RESOURCE))",
            "\t\tmode = (table->mode & S_IRWXU) >> 6;",
            "\telse",
            "\t/* Allow all others at most read-only access */",
            "\t\tmode = table->mode & S_IROTH;",
            "\treturn (mode << 6) | (mode << 3) | mode;",
            "}",
            "bool setup_userns_sysctls(struct user_namespace *ns)",
            "{",
            "#ifdef CONFIG_SYSCTL",
            "\tstruct ctl_table *tbl;",
            "",
            "\tBUILD_BUG_ON(ARRAY_SIZE(user_table) != UCOUNT_COUNTS);",
            "\tsetup_sysctl_set(&ns->set, &set_root, set_is_seen);",
            "\ttbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);",
            "\tif (tbl) {",
            "\t\tint i;",
            "\t\tfor (i = 0; i < UCOUNT_COUNTS; i++) {",
            "\t\t\ttbl[i].data = &ns->ucount_max[i];",
            "\t\t}",
            "\t\tns->sysctls = __register_sysctl_table(&ns->set, \"user\", tbl,",
            "\t\t\t\t\t\t      ARRAY_SIZE(user_table));",
            "\t}",
            "\tif (!ns->sysctls) {",
            "\t\tkfree(tbl);",
            "\t\tretire_sysctl_set(&ns->set);",
            "\t\treturn false;",
            "\t}",
            "#endif",
            "\treturn true;",
            "}",
            "void retire_userns_sysctls(struct user_namespace *ns)",
            "{",
            "#ifdef CONFIG_SYSCTL",
            "\tstruct ctl_table *tbl;",
            "",
            "\ttbl = ns->sysctls->ctl_table_arg;",
            "\tunregister_sysctl_table(ns->sysctls);",
            "\tretire_sysctl_set(&ns->set);",
            "\tkfree(tbl);",
            "#endif",
            "}",
            "static void hlist_add_ucounts(struct ucounts *ucounts)",
            "{",
            "\tstruct hlist_nulls_head *hashent = ucounts_hashentry(ucounts->ns, ucounts->uid);",
            "",
            "\tspin_lock_irq(&ucounts_lock);",
            "\thlist_nulls_add_head_rcu(&ucounts->node, hashent);",
            "\tspin_unlock_irq(&ucounts_lock);",
            "}",
            "void put_ucounts(struct ucounts *ucounts)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (rcuref_put(&ucounts->count)) {",
            "\t\tspin_lock_irqsave(&ucounts_lock, flags);",
            "\t\thlist_nulls_del_rcu(&ucounts->node);",
            "\t\tspin_unlock_irqrestore(&ucounts_lock, flags);",
            "",
            "\t\tput_user_ns(ucounts->ns);",
            "\t\tkfree_rcu(ucounts, rcu);",
            "\t}",
            "}",
            "static inline bool atomic_long_inc_below(atomic_long_t *v, long u)",
            "{",
            "\tlong c, old;",
            "\tc = atomic_long_read(v);",
            "\tfor (;;) {",
            "\t\tif (unlikely(c >= u))",
            "\t\t\treturn false;",
            "\t\told = atomic_long_cmpxchg(v, c, c+1);",
            "\t\tif (likely(old == c))",
            "\t\t\treturn true;",
            "\t\tc = old;",
            "\t}",
            "}",
            "void dec_ucount(struct ucounts *ucounts, enum ucount_type type)",
            "{",
            "\tstruct ucounts *iter;",
            "\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {",
            "\t\tlong dec = atomic_long_dec_if_positive(&iter->ucount[type]);",
            "\t\tWARN_ON_ONCE(dec < 0);",
            "\t}",
            "\tput_ucounts(ucounts);",
            "}",
            "long inc_rlimit_ucounts(struct ucounts *ucounts, enum rlimit_type type, long v)",
            "{",
            "\tstruct ucounts *iter;",
            "\tlong max = LONG_MAX;",
            "\tlong ret = 0;",
            "",
            "\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {",
            "\t\tlong new = atomic_long_add_return(v, &iter->rlimit[type]);",
            "\t\tif (new < 0 || new > max)",
            "\t\t\tret = LONG_MAX;",
            "\t\telse if (iter == ucounts)",
            "\t\t\tret = new;",
            "\t\tmax = get_userns_rlimit_max(iter->ns, type);",
            "\t}",
            "\treturn ret;",
            "}"
          ],
          "function_name": "set_is_seen, set_permissions, setup_userns_sysctls, retire_userns_sysctls, hlist_add_ucounts, put_ucounts, atomic_long_inc_below, dec_ucount, inc_rlimit_ucounts",
          "description": "set_is_seen判断当前用户命名空间是否属于目标set；set_permissions根据用户权限设置sysctl参数访问模式；setup_userns_sysctls为用户命名空间注册sysctl表并绑定最大值；retire_userns_sysctls清理用户命名空间sysctl表；hlist_add_ucounts将计数器节点加入哈希链表；put_ucounts减少引用计数并释放资源；atomic_long_inc_below原子递增小于阈值；dec_ucount减少特定类型计数器；inc_rlimit_ucounts增加RLIMIT相关计数器。",
          "similarity": 0.5132656097412109
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/ucount.c",
          "start_line": 266,
          "end_line": 358,
          "content": [
            "bool dec_rlimit_ucounts(struct ucounts *ucounts, enum rlimit_type type, long v)",
            "{",
            "\tstruct ucounts *iter;",
            "\tlong new = -1; /* Silence compiler warning */",
            "\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {",
            "\t\tlong dec = atomic_long_sub_return(v, &iter->rlimit[type]);",
            "\t\tWARN_ON_ONCE(dec < 0);",
            "\t\tif (iter == ucounts)",
            "\t\t\tnew = dec;",
            "\t}",
            "\treturn (new == 0);",
            "}",
            "static void do_dec_rlimit_put_ucounts(struct ucounts *ucounts,",
            "\t\t\t\tstruct ucounts *last, enum rlimit_type type)",
            "{",
            "\tstruct ucounts *iter, *next;",
            "\tfor (iter = ucounts; iter != last; iter = next) {",
            "\t\tlong dec = atomic_long_sub_return(1, &iter->rlimit[type]);",
            "\t\tWARN_ON_ONCE(dec < 0);",
            "\t\tnext = iter->ns->ucounts;",
            "\t\tif (dec == 0)",
            "\t\t\tput_ucounts(iter);",
            "\t}",
            "}",
            "void dec_rlimit_put_ucounts(struct ucounts *ucounts, enum rlimit_type type)",
            "{",
            "\tdo_dec_rlimit_put_ucounts(ucounts, NULL, type);",
            "}",
            "long inc_rlimit_get_ucounts(struct ucounts *ucounts, enum rlimit_type type,",
            "\t\t\t    bool override_rlimit)",
            "{",
            "\t/* Caller must hold a reference to ucounts */",
            "\tstruct ucounts *iter;",
            "\tlong max = LONG_MAX;",
            "\tlong dec, ret = 0;",
            "",
            "\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {",
            "\t\tlong new = atomic_long_add_return(1, &iter->rlimit[type]);",
            "\t\tif (new < 0 || new > max)",
            "\t\t\tgoto dec_unwind;",
            "\t\tif (iter == ucounts)",
            "\t\t\tret = new;",
            "\t\tif (!override_rlimit)",
            "\t\t\tmax = get_userns_rlimit_max(iter->ns, type);",
            "\t\t/*",
            "\t\t * Grab an extra ucount reference for the caller when",
            "\t\t * the rlimit count was previously 0.",
            "\t\t */",
            "\t\tif (new != 1)",
            "\t\t\tcontinue;",
            "\t\tif (!get_ucounts(iter))",
            "\t\t\tgoto dec_unwind;",
            "\t}",
            "\treturn ret;",
            "dec_unwind:",
            "\tdec = atomic_long_sub_return(1, &iter->rlimit[type]);",
            "\tWARN_ON_ONCE(dec < 0);",
            "\tdo_dec_rlimit_put_ucounts(ucounts, iter, type);",
            "\treturn 0;",
            "}",
            "bool is_rlimit_overlimit(struct ucounts *ucounts, enum rlimit_type type, unsigned long rlimit)",
            "{",
            "\tstruct ucounts *iter;",
            "\tlong max = rlimit;",
            "\tif (rlimit > LONG_MAX)",
            "\t\tmax = LONG_MAX;",
            "\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {",
            "\t\tlong val = get_rlimit_value(iter, type);",
            "\t\tif (val < 0 || val > max)",
            "\t\t\treturn true;",
            "\t\tmax = get_userns_rlimit_max(iter->ns, type);",
            "\t}",
            "\treturn false;",
            "}",
            "static __init int user_namespace_sysctl_init(void)",
            "{",
            "#ifdef CONFIG_SYSCTL",
            "\tstatic struct ctl_table_header *user_header;",
            "\tstatic struct ctl_table empty[1];",
            "\t/*",
            "\t * It is necessary to register the user directory in the",
            "\t * default set so that registrations in the child sets work",
            "\t * properly.",
            "\t */",
            "\tuser_header = register_sysctl_sz(\"user\", empty, 0);",
            "\tkmemleak_ignore(user_header);",
            "\tBUG_ON(!user_header);",
            "\tBUG_ON(!setup_userns_sysctls(&init_user_ns));",
            "#endif",
            "\thlist_add_ucounts(&init_ucounts);",
            "\tinc_rlimit_ucounts(&init_ucounts, UCOUNT_RLIMIT_NPROC, 1);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "dec_rlimit_ucounts, do_dec_rlimit_put_ucounts, dec_rlimit_put_ucounts, inc_rlimit_get_ucounts, is_rlimit_overlimit, user_namespace_sysctl_init",
          "description": "dec_rlimit_ucounts减少RLIMIT计数器并返回是否归零；do_dec_rlimit_put_ucounts遍历链表减少计数器并释放空闲节点；dec_rlimit_put_ucounts执行RLIMIT计数器释放；inc_rlimit_get_ucounts尝试增加RLIMIT计数器并处理软限制；is_rlimit_overlimit检查RLIMIT是否超出各层级限制；user_namespace_sysctl_init注册用户命名空间sysctl目录并初始化初始计数器。",
          "similarity": 0.4815007150173187
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/ucount.c",
          "start_line": 1,
          "end_line": 36,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "",
            "#include <linux/stat.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/hash.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "",
            "struct ucounts init_ucounts = {",
            "\t.ns    = &init_user_ns,",
            "\t.uid   = GLOBAL_ROOT_UID,",
            "\t.count = RCUREF_INIT(1),",
            "};",
            "",
            "#define UCOUNTS_HASHTABLE_BITS 10",
            "#define UCOUNTS_HASHTABLE_ENTRIES (1 << UCOUNTS_HASHTABLE_BITS)",
            "static struct hlist_nulls_head ucounts_hashtable[UCOUNTS_HASHTABLE_ENTRIES] = {",
            "\t[0 ... UCOUNTS_HASHTABLE_ENTRIES - 1] = HLIST_NULLS_HEAD_INIT(0)",
            "};",
            "static DEFINE_SPINLOCK(ucounts_lock);",
            "",
            "#define ucounts_hashfn(ns, uid)\t\t\t\t\t\t\\",
            "\thash_long((unsigned long)__kuid_val(uid) + (unsigned long)(ns), \\",
            "\t\t  UCOUNTS_HASHTABLE_BITS)",
            "#define ucounts_hashentry(ns, uid)\t\\",
            "\t(ucounts_hashtable + ucounts_hashfn(ns, uid))",
            "",
            "#ifdef CONFIG_SYSCTL",
            "static struct ctl_table_set *",
            "set_lookup(struct ctl_table_root *root)",
            "{",
            "\treturn &current_user_ns()->set;",
            "}",
            ""
          ],
          "function_name": null,
          "description": "定义用户命名空间计数器全局初始结构init_ucounts，初始化用户命名空间、全局根UID和计数器引用。创建UCOUNTS_HASHTABLE_BITS位宽的哈希表数组ucounts_hashtable，初始化为NULL链表头，并声明互斥锁ucounts_lock。定义哈希计算宏ucounts_hashfn和获取哈希表项宏ucounts_hashentry，用于后续计数器哈希表操作。",
          "similarity": 0.47479143738746643
        }
      ]
    }
  ]
}