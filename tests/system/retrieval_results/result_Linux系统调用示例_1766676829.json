{
  "query": "Linux系统调用示例",
  "timestamp": "2025-12-25 23:33:49",
  "retrieved_files": [
    {
      "source_file": "kernel/sys.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:30:52\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sys.c`\n\n---\n\n# `sys.c` 内核源码技术文档\n\n## 1. 文件概述\n\n`sys.c` 是 Linux 内核中实现系统调用（system calls）的核心源文件之一，位于 `kernel/` 目录下。该文件主要负责处理与进程调度优先级、用户/组 ID 溢出处理、系统信息查询等相关的通用系统调用。其历史可追溯至 Linus Torvalds 早期开发阶段，是内核中提供 POSIX 兼容性的重要组成部分。当前文档所涵盖的代码片段聚焦于 `setpriority` 和 `getpriority` 系统调用的实现，以及与 UID/GID 溢出相关的全局变量定义。\n\n## 2. 核心功能\n\n### 全局变量\n- `overflowuid` / `overflowgid`：用于在 32 位 UID/GID 架构中表示无法表示的旧式 16 位 UID/GID 的回退值，默认为 `DEFAULT_OVERFLOWUID`/`DEFAULT_OVERFLOWGID`。\n- `fs_overflowuid` / `fs_overflowgid`：专用于仅支持 16 位 UID/GID 的文件系统的溢出回退值，适用于所有架构。\n\n### 主要函数\n- `set_one_prio_perm(struct task_struct *p)`：检查当前进程是否有权限修改目标进程 `p` 的调度优先级（nice 值）。\n- `set_one_prio(struct task_struct *p, int niceval, int error)`：在权限检查通过后，实际设置目标进程的 nice 值。\n- `SYSCALL_DEFINE3(setpriority, int, which, int, who, int, niceval)`：实现 `setpriority(2)` 系统调用，支持按进程、进程组或用户 ID 修改一组进程的优先级。\n- `SYSCALL_DEFINE2(getpriority, int, which, int, who)`：实现 `getpriority(2)` 系统调用，返回指定范围（进程、进程组、用户）内最高优先级（即最小 nice 值）对应的兼容值。\n\n## 3. 关键实现\n\n### 权限控制机制\n- `set_one_prio_perm()` 函数通过比较当前进程的有效 UID（`euid`）与目标进程的 UID 或有效 UID 是否相等来判断基本权限。\n- 若不满足 UID 匹配，则检查当前进程是否在目标进程所属的用户命名空间（`user_ns`）中拥有 `CAP_SYS_NICE` 能力。\n- 所有凭证（`cred`）访问均在 RCU 读锁保护下进行，确保并发安全。\n\n### 优先级设置逻辑\n- `setpriority` 系统调用首先将用户传入的 `niceval` 限制在 `[MIN_NICE, MAX_NICE]` 范围内（通常为 -20 到 19）。\n- 根据 `which` 参数（`PRIO_PROCESS`、`PRIO_PGRP` 或 `PRIO_USER`）分别处理：\n  - **进程**：通过 `find_task_by_vpid()` 查找目标进程。\n  - **进程组**：使用 `do_each_pid_thread()` 遍历指定进程组内的所有线程。\n  - **用户**：遍历所有进程，筛选 UID 匹配的进程；若目标 UID 非当前用户，则通过 `find_user()` 获取用户结构并最终 `free_uid()` 释放引用。\n- 实际设置前调用 LSM（Linux Security Module）钩子 `security_task_setnice()` 进行安全策略检查。\n\n### 优先级获取的兼容性处理\n- `getpriority` 返回值采用历史兼容格式：将实际 nice 值（-20~19）转换为 `20 - nice`，即返回 1~40 的正整数。\n- 该转换通过 `nice_to_rlimit()` 宏实现（定义在 `<linux/resource.h>` 中）。\n- 返回的是指定范围内**最高优先级**（即最大 `nice_to_rlimit` 值，对应最小实际 nice 值）。\n\n### 架构无关性处理\n- 文件开头通过一系列 `#ifndef` 宏定义（如 `SET_UNALIGN_CTL`、`GET_FP_MODE` 等）为不支持特定 CPU 控制功能的架构提供默认 `-EINVAL` 返回值，避免编译错误。\n\n## 4. 依赖关系\n\n### 头文件依赖\n- **调度子系统**：`<linux/sched.h>` 及其子头文件（如 `sched/task.h`、`sched/cputime.h`）提供任务结构、nice 值操作和遍历接口。\n- **用户/组管理**：`<linux/cred.h>`、`<linux/uidgid.h>`、`<linux/user_namespace.h>` 处理凭证、UID/GID 映射及命名空间。\n- **安全模块**：`<linux/security.h>`、`<linux/capability.h>` 提供 LSM 钩子和能力检查。\n- **进程管理**：`<linux/pid.h>`（通过 `find_vpid` 等）、`<linux/rcupdate.h>`（RCU 锁）、`<linux/task_io_accounting_ops.h>`。\n- **系统调用框架**：`<linux/syscalls.h>`、`<linux/uaccess.h>`。\n- **其他**：`<linux/resource.h>`（`nice_to_rlimit`）、`<linux/utsname.h>`（系统信息）、`<generated/utsrelease.h>`（内核版本）。\n\n### 内核子系统交互\n- **调度器**：通过 `set_user_nice()` 和 `task_nice()` 与核心调度逻辑交互。\n- **用户命名空间**：在 UID 比较和能力检查中依赖用户命名空间隔离机制。\n- **LSM 框架**：调用 `security_task_setnice()` 允许安全模块（如 SELinux、AppArmor）拦截优先级修改。\n- **进程遍历机制**：使用 `for_each_process_thread()` 和 `do_each_pid_thread()` 安全遍历进程列表。\n\n## 5. 使用场景\n\n- **用户空间程序调用 `setpriority()`/`getpriority()`**：如 `nice`、`renice` 命令，或应用程序动态调整自身/子进程 CPU 调度优先级。\n- **系统初始化**：`overflowuid`/`overflowgid` 等变量在内核启动时初始化，供 VFS 和 IPC 子系统在处理旧式 16 位 UID/GID 时使用。\n- **容器与命名空间环境**：在用户命名空间中，`setpriority` 的权限检查基于目标进程的用户命名空间，确保容器内进程无法越权修改宿主机进程优先级。\n- **安全审计与限制**：通过 LSM 钩子，系统可记录或阻止非特权进程提升优先级的行为。\n- **跨架构兼容**：为不支持浮点控制、对齐控制等特性的 CPU 架构提供统一的系统调用接口，避免架构特定代码污染通用逻辑。",
      "similarity": 0.5930299162864685,
      "chunks": [
        {
          "chunk_id": 7,
          "file_path": "kernel/sys.c",
          "start_line": 1755,
          "end_line": 1795,
          "content": [
            "static void rlim64_to_rlim(const struct rlimit64 *rlim64, struct rlimit *rlim)",
            "{",
            "\tif (rlim64_is_infinity(rlim64->rlim_cur))",
            "\t\trlim->rlim_cur = RLIM_INFINITY;",
            "\telse",
            "\t\trlim->rlim_cur = (unsigned long)rlim64->rlim_cur;",
            "\tif (rlim64_is_infinity(rlim64->rlim_max))",
            "\t\trlim->rlim_max = RLIM_INFINITY;",
            "\telse",
            "\t\trlim->rlim_max = (unsigned long)rlim64->rlim_max;",
            "}",
            "static int check_prlimit_permission(struct task_struct *task,",
            "\t\t\t\t    unsigned int flags)",
            "{",
            "\tconst struct cred *cred = current_cred(), *tcred;",
            "\tbool id_match;",
            "",
            "\tif (current == task)",
            "\t\treturn 0;",
            "",
            "\ttcred = __task_cred(task);",
            "\tid_match = (uid_eq(cred->uid, tcred->euid) &&",
            "\t\t    uid_eq(cred->uid, tcred->suid) &&",
            "\t\t    uid_eq(cred->uid, tcred->uid)  &&",
            "\t\t    gid_eq(cred->gid, tcred->egid) &&",
            "\t\t    gid_eq(cred->gid, tcred->sgid) &&",
            "\t\t    gid_eq(cred->gid, tcred->gid));",
            "\tif (!id_match && !ns_capable(tcred->user_ns, CAP_SYS_RESOURCE))",
            "\t\treturn -EPERM;",
            "",
            "\treturn security_task_prlimit(cred, tcred, flags);",
            "}",
            "static void accumulate_thread_rusage(struct task_struct *t, struct rusage *r)",
            "{",
            "\tr->ru_nvcsw += t->nvcsw;",
            "\tr->ru_nivcsw += t->nivcsw;",
            "\tr->ru_minflt += t->min_flt;",
            "\tr->ru_majflt += t->maj_flt;",
            "\tr->ru_inblock += task_io_get_inblock(t);",
            "\tr->ru_oublock += task_io_get_oublock(t);",
            "}"
          ],
          "function_name": "rlim64_to_rlim, check_prlimit_permission, accumulate_thread_rusage",
          "description": "该代码块包含三个辅助函数：  \n1. `rlim64_to_rlim` 实现从64位资源限制结构体到传统32位`struct rlimit`的类型转换，处理无穷大的边界条件；  \n2. `check_prlimit_permission` 检查当前进程对目标任务执行`prlimit`系统调用的权限，通过对比有效UID/GID及命名空间能力进行访问控制；  \n3. `accumulate_thread_rusage` 累加子线程的资源使用统计信息至父线程的`rusage`结构，用于进程资源消耗追踪。  \n\n所有函数均基于完整上下文实现，未引入额外API或机制。",
          "similarity": 0.5094587802886963
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/sys.c",
          "start_line": 458,
          "end_line": 628,
          "content": [
            "long __sys_setgid(gid_t gid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkgid_t kgid;",
            "",
            "\tkgid = make_kgid(ns, gid);",
            "\tif (!gid_valid(kgid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_sgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t\tiee_set_cred_gid(new, kgid);",
            "\t}",
            "\t\t#else",
            "\t\tnew->gid = new->egid = new->sgid = new->fsgid = kgid;",
            "\t\t#endif",
            "\telse if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t}",
            "\t\t#else",
            "\t\tnew->egid = new->fsgid = kgid;",
            "\t\t#endif",
            "\telse",
            "\t\tgoto error;",
            "",
            "\tretval = security_task_fix_setgid(new, old, LSM_SETID_ID);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}",
            "\telse if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t{",
            "\t\tiee_set_cred_fsgid(new, kgid);",
            "\t\tiee_set_cred_egid(new, kgid);",
            "\t}",
            "static int set_user(struct cred *new)",
            "{",
            "\tstruct user_struct *new_user;",
            "",
            "\tnew_user = alloc_uid(new->uid);",
            "\tif (!new_user)",
            "\t\treturn -EAGAIN;",
            "",
            "\tfree_uid(new->user);",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_user(new, new_user);",
            "\t#else",
            "\tnew->user = new_user;",
            "\t#endif",
            "\treturn 0;",
            "}",
            "static void flag_nproc_exceeded(struct cred *new)",
            "{",
            "\tif (new->ucounts == current_ucounts())",
            "\t\treturn;",
            "",
            "\t/*",
            "\t * We don't fail in case of NPROC limit excess here because too many",
            "\t * poorly written programs don't check set*uid() return code, assuming",
            "\t * it never fails if called by root.  We may still enforce NPROC limit",
            "\t * for programs doing set*uid()+execve() by harmlessly deferring the",
            "\t * failure to the execve() stage.",
            "\t */",
            "\tif (is_rlimit_overlimit(new->ucounts, UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC)) &&",
            "\t\t\tnew->user != INIT_USER)",
            "\t\tcurrent->flags |= PF_NPROC_EXCEEDED;",
            "\telse",
            "\t\tcurrent->flags &= ~PF_NPROC_EXCEEDED;",
            "}",
            "long __sys_setreuid(uid_t ruid, uid_t euid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkuid_t kruid, keuid;",
            "",
            "\tkruid = make_kuid(ns, ruid);",
            "\tkeuid = make_kuid(ns, euid);",
            "",
            "\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))",
            "\t\treturn -EINVAL;",
            "\tif ((euid != (uid_t) -1) && !uid_valid(keuid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (ruid != (uid_t) -1) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_uid(new, kruid);",
            "\t\t#else",
            "\t\tnew->uid = kruid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(old->uid, kruid) &&",
            "\t\t    !uid_eq(old->euid, kruid) &&",
            "\t\t    !ns_capable_setid(old->user_ns, CAP_SETUID))",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tif (euid != (uid_t) -1) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_euid(new, keuid);",
            "\t\t#else",
            "\t\tnew->euid = keuid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(old->uid, keuid) &&",
            "\t\t    !uid_eq(old->euid, keuid) &&",
            "\t\t    !uid_eq(old->suid, keuid) &&",
            "\t\t    !ns_capable_setid(old->user_ns, CAP_SETUID))",
            "\t\t\tgoto error;",
            "\t}",
            "",
            "\tif (!uid_eq(new->uid, old->uid)) {",
            "\t\tretval = set_user(new);",
            "\t\tif (retval < 0)",
            "\t\t\tgoto error;",
            "\t}",
            "\tif (ruid != (uid_t) -1 ||",
            "\t    (euid != (uid_t) -1 && !uid_eq(keuid, old->uid)))",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_suid(new, new->euid);",
            "\t\t#else",
            "\t\tnew->suid = new->euid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsuid(new, new->euid);",
            "\t#else",
            "\tnew->fsuid = new->euid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setuid(new, old, LSM_SETID_RE);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tretval = set_cred_ucounts(new);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tflag_nproc_exceeded(new);",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "__sys_setgid, if, set_user, flag_nproc_exceeded, __sys_setreuid",
          "description": "实现用户ID调整逻辑，包含用户结构体分配、NPROC限制检测及用户命名空间权限校验，更新进程的有效/实始用户ID。",
          "similarity": 0.48544842004776
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/sys.c",
          "start_line": 666,
          "end_line": 811,
          "content": [
            "long __sys_setuid(uid_t uid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkuid_t kuid;",
            "",
            "\tkuid = make_kuid(ns, uid);",
            "\tif (!uid_valid(kuid))",
            "\t\treturn -EINVAL;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "\told = current_cred();",
            "",
            "\tretval = -EPERM;",
            "\tif (ns_capable_setid(old->user_ns, CAP_SETUID)) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_uid(new, kuid);",
            "\t\tiee_set_cred_suid(new, kuid);",
            "\t\t#else",
            "\t\tnew->suid = new->uid = kuid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(kuid, old->uid)) {",
            "\t\t\tretval = set_user(new);",
            "\t\t\tif (retval < 0)",
            "\t\t\t\tgoto error;",
            "\t\t}",
            "\t} else if (!uid_eq(kuid, old->uid) && !uid_eq(kuid, new->suid)) {",
            "\t\tgoto error;",
            "\t}",
            "",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_euid(new, kuid);",
            "\tiee_set_cred_fsuid(new, kuid);",
            "\t#else",
            "\tnew->fsuid = new->euid = kuid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setuid(new, old, LSM_SETID_ID);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tretval = set_cred_ucounts(new);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tflag_nproc_exceeded(new);",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}",
            "long __sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkuid_t kruid, keuid, ksuid;",
            "\tbool ruid_new, euid_new, suid_new;",
            "",
            "\tkruid = make_kuid(ns, ruid);",
            "\tkeuid = make_kuid(ns, euid);",
            "\tksuid = make_kuid(ns, suid);",
            "",
            "\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((euid != (uid_t) -1) && !uid_valid(keuid))",
            "\t\treturn -EINVAL;",
            "",
            "\tif ((suid != (uid_t) -1) && !uid_valid(ksuid))",
            "\t\treturn -EINVAL;",
            "",
            "\told = current_cred();",
            "",
            "\t/* check for no-op */",
            "\tif ((ruid == (uid_t) -1 || uid_eq(kruid, old->uid)) &&",
            "\t    (euid == (uid_t) -1 || (uid_eq(keuid, old->euid) &&",
            "\t\t\t\t    uid_eq(keuid, old->fsuid))) &&",
            "\t    (suid == (uid_t) -1 || uid_eq(ksuid, old->suid)))",
            "\t\treturn 0;",
            "",
            "\truid_new = ruid != (uid_t) -1        && !uid_eq(kruid, old->uid) &&",
            "\t\t   !uid_eq(kruid, old->euid) && !uid_eq(kruid, old->suid);",
            "\teuid_new = euid != (uid_t) -1        && !uid_eq(keuid, old->uid) &&",
            "\t\t   !uid_eq(keuid, old->euid) && !uid_eq(keuid, old->suid);",
            "\tsuid_new = suid != (uid_t) -1        && !uid_eq(ksuid, old->uid) &&",
            "\t\t   !uid_eq(ksuid, old->euid) && !uid_eq(ksuid, old->suid);",
            "\tif ((ruid_new || euid_new || suid_new) &&",
            "\t    !ns_capable_setid(old->user_ns, CAP_SETUID))",
            "\t\treturn -EPERM;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (ruid != (uid_t) -1) {",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_uid(new, kruid);",
            "\t\t#else",
            "\t\tnew->uid = kruid;",
            "\t\t#endif",
            "\t\tif (!uid_eq(kruid, old->uid)) {",
            "\t\t\tretval = set_user(new);",
            "\t\t\tif (retval < 0)",
            "\t\t\t\tgoto error;",
            "\t\t}",
            "\t}",
            "\tif (euid != (uid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_euid(new, keuid);",
            "\t\t#else",
            "\t\tnew->euid = keuid;",
            "\t\t#endif",
            "\tif (suid != (uid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_suid(new, ksuid);",
            "\t\t#else",
            "\t\tnew->suid = ksuid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsuid(new, new->euid);",
            "\t#else",
            "\tnew->fsuid = new->euid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setuid(new, old, LSM_SETID_RES);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tretval = set_cred_ucounts(new);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\tflag_nproc_exceeded(new);",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}"
          ],
          "function_name": "__sys_setuid, __sys_setresuid",
          "description": "实现用户ID调整接口，支持基础UID设置与资源管理UID设置，包含完整性校验和用户结构体更新操作。",
          "similarity": 0.4806475043296814
        },
        {
          "chunk_id": 4,
          "file_path": "kernel/sys.c",
          "start_line": 851,
          "end_line": 966,
          "content": [
            "long __sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid)",
            "{",
            "\tstruct user_namespace *ns = current_user_ns();",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tint retval;",
            "\tkgid_t krgid, kegid, ksgid;",
            "\tbool rgid_new, egid_new, sgid_new;",
            "",
            "\tkrgid = make_kgid(ns, rgid);",
            "\tkegid = make_kgid(ns, egid);",
            "\tksgid = make_kgid(ns, sgid);",
            "",
            "\tif ((rgid != (gid_t) -1) && !gid_valid(krgid))",
            "\t\treturn -EINVAL;",
            "\tif ((egid != (gid_t) -1) && !gid_valid(kegid))",
            "\t\treturn -EINVAL;",
            "\tif ((sgid != (gid_t) -1) && !gid_valid(ksgid))",
            "\t\treturn -EINVAL;",
            "",
            "\told = current_cred();",
            "",
            "\t/* check for no-op */",
            "\tif ((rgid == (gid_t) -1 || gid_eq(krgid, old->gid)) &&",
            "\t    (egid == (gid_t) -1 || (gid_eq(kegid, old->egid) &&",
            "\t\t\t\t    gid_eq(kegid, old->fsgid))) &&",
            "\t    (sgid == (gid_t) -1 || gid_eq(ksgid, old->sgid)))",
            "\t\treturn 0;",
            "",
            "\trgid_new = rgid != (gid_t) -1        && !gid_eq(krgid, old->gid) &&",
            "\t\t   !gid_eq(krgid, old->egid) && !gid_eq(krgid, old->sgid);",
            "\tegid_new = egid != (gid_t) -1        && !gid_eq(kegid, old->gid) &&",
            "\t\t   !gid_eq(kegid, old->egid) && !gid_eq(kegid, old->sgid);",
            "\tsgid_new = sgid != (gid_t) -1        && !gid_eq(ksgid, old->gid) &&",
            "\t\t   !gid_eq(ksgid, old->egid) && !gid_eq(ksgid, old->sgid);",
            "\tif ((rgid_new || egid_new || sgid_new) &&",
            "\t    !ns_capable_setid(old->user_ns, CAP_SETGID))",
            "\t\treturn -EPERM;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn -ENOMEM;",
            "",
            "\tif (rgid != (gid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_gid(new, krgid);",
            "\t\t#else",
            "\t\tnew->gid = krgid;",
            "\t\t#endif",
            "\tif (egid != (gid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_egid(new, kegid);",
            "\t\t#else",
            "\t\tnew->egid = kegid;",
            "\t\t#endif",
            "\tif (sgid != (gid_t) -1)",
            "\t\t#ifdef CONFIG_CREDP",
            "\t\tiee_set_cred_sgid(new, ksgid);",
            "\t\t#else",
            "\t\tnew->sgid = ksgid;",
            "\t\t#endif",
            "\t#ifdef CONFIG_CREDP",
            "\tiee_set_cred_fsgid(new, new->egid);",
            "\t#else",
            "\tnew->fsgid = new->egid;",
            "\t#endif",
            "",
            "\tretval = security_task_fix_setgid(new, old, LSM_SETID_RES);",
            "\tif (retval < 0)",
            "\t\tgoto error;",
            "",
            "\treturn commit_creds(new);",
            "",
            "error:",
            "\tabort_creds(new);",
            "\treturn retval;",
            "}",
            "long __sys_setfsuid(uid_t uid)",
            "{",
            "\tconst struct cred *old;",
            "\tstruct cred *new;",
            "\tuid_t old_fsuid;",
            "\tkuid_t kuid;",
            "",
            "\told = current_cred();",
            "\told_fsuid = from_kuid_munged(old->user_ns, old->fsuid);",
            "",
            "\tkuid = make_kuid(old->user_ns, uid);",
            "\tif (!uid_valid(kuid))",
            "\t\treturn old_fsuid;",
            "",
            "\tnew = prepare_creds();",
            "\tif (!new)",
            "\t\treturn old_fsuid;",
            "",
            "\tif (uid_eq(kuid, old->uid)  || uid_eq(kuid, old->euid)  ||",
            "\t    uid_eq(kuid, old->suid) || uid_eq(kuid, old->fsuid) ||",
            "\t    ns_capable_setid(old->user_ns, CAP_SETUID)) {",
            "\t\tif (!uid_eq(kuid, old->fsuid)) {",
            "\t\t\t#ifdef CONFIG_CREDP",
            "\t\t\tiee_set_cred_fsuid(new, kuid);",
            "\t\t\t#else",
            "\t\t\tnew->fsuid = kuid;",
            "\t\t\t#endif",
            "\t\t\tif (security_task_fix_setuid(new, old, LSM_SETID_FS) == 0)",
            "\t\t\t\tgoto change_okay;",
            "\t\t}",
            "\t}",
            "",
            "\tabort_creds(new);",
            "\treturn old_fsuid;",
            "",
            "change_okay:",
            "\tcommit_creds(new);",
            "\treturn old_fsuid;",
            "}"
          ],
          "function_name": "__sys_setresgid, __sys_setfsuid",
          "description": "实现组ID资源管理接口及文件系统用户ID设置，包含组ID字段更新和文件系统用户ID的权限控制逻辑。",
          "similarity": 0.4698273241519928
        },
        {
          "chunk_id": 6,
          "file_path": "kernel/sys.c",
          "start_line": 1386,
          "end_line": 1491,
          "content": [
            "static int override_release(char __user *release, size_t len)",
            "{",
            "\tint ret = 0;",
            "",
            "\tif (current->personality & UNAME26) {",
            "\t\tconst char *rest = UTS_RELEASE;",
            "\t\tchar buf[65] = { 0 };",
            "\t\tint ndots = 0;",
            "\t\tunsigned v;",
            "\t\tsize_t copy;",
            "",
            "\t\twhile (*rest) {",
            "\t\t\tif (*rest == '.' && ++ndots >= 3)",
            "\t\t\t\tbreak;",
            "\t\t\tif (!isdigit(*rest) && *rest != '.')",
            "\t\t\t\tbreak;",
            "\t\t\trest++;",
            "\t\t}",
            "\t\tv = LINUX_VERSION_PATCHLEVEL + 60;",
            "\t\tcopy = clamp_t(size_t, len, 1, sizeof(buf));",
            "\t\tcopy = scnprintf(buf, copy, \"2.6.%u%s\", v, rest);",
            "\t\tret = copy_to_user(release, buf, copy + 1);",
            "\t}",
            "\treturn ret;",
            "}",
            "static int do_prlimit(struct task_struct *tsk, unsigned int resource,",
            "\t\t      struct rlimit *new_rlim, struct rlimit *old_rlim)",
            "{",
            "\tstruct rlimit *rlim;",
            "\tint retval = 0;",
            "",
            "\tif (resource >= RLIM_NLIMITS)",
            "\t\treturn -EINVAL;",
            "\tresource = array_index_nospec(resource, RLIM_NLIMITS);",
            "",
            "\tif (new_rlim) {",
            "\t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)",
            "\t\t\treturn -EINVAL;",
            "\t\tif (resource == RLIMIT_NOFILE &&",
            "\t\t\t\tnew_rlim->rlim_max > sysctl_nr_open)",
            "\t\t\treturn -EPERM;",
            "\t}",
            "",
            "\t/* Holding a refcount on tsk protects tsk->signal from disappearing. */",
            "\trlim = tsk->signal->rlim + resource;",
            "\ttask_lock(tsk->group_leader);",
            "\tif (new_rlim) {",
            "\t\t/*",
            "\t\t * Keep the capable check against init_user_ns until cgroups can",
            "\t\t * contain all limits.",
            "\t\t */",
            "\t\tif (new_rlim->rlim_max > rlim->rlim_max &&",
            "\t\t\t\t!capable(CAP_SYS_RESOURCE))",
            "\t\t\tretval = -EPERM;",
            "\t\tif (!retval)",
            "\t\t\tretval = security_task_setrlimit(tsk, resource, new_rlim);",
            "\t}",
            "\tif (!retval) {",
            "\t\tif (old_rlim)",
            "\t\t\t*old_rlim = *rlim;",
            "\t\tif (new_rlim)",
            "\t\t\t*rlim = *new_rlim;",
            "\t}",
            "\ttask_unlock(tsk->group_leader);",
            "",
            "\t/*",
            "\t * RLIMIT_CPU handling. Arm the posix CPU timer if the limit is not",
            "\t * infinite. In case of RLIM_INFINITY the posix CPU timer code",
            "\t * ignores the rlimit.",
            "\t */",
            "\tif (!retval && new_rlim && resource == RLIMIT_CPU &&",
            "\t    new_rlim->rlim_cur != RLIM_INFINITY &&",
            "\t    IS_ENABLED(CONFIG_POSIX_TIMERS)) {",
            "\t\t/*",
            "\t\t * update_rlimit_cpu can fail if the task is exiting, but there",
            "\t\t * may be other tasks in the thread group that are not exiting,",
            "\t\t * and they need their cpu timers adjusted.",
            "\t\t *",
            "\t\t * The group_leader is the last task to be released, so if we",
            "\t\t * cannot update_rlimit_cpu on it, then the entire process is",
            "\t\t * exiting and we do not need to update at all.",
            "\t\t */",
            "\t\tupdate_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);",
            "\t}",
            "",
            "\treturn retval;",
            "}",
            "static inline bool rlim64_is_infinity(__u64 rlim64)",
            "{",
            "#if BITS_PER_LONG < 64",
            "\treturn rlim64 >= ULONG_MAX;",
            "#else",
            "\treturn rlim64 == RLIM64_INFINITY;",
            "#endif",
            "}",
            "static void rlim_to_rlim64(const struct rlimit *rlim, struct rlimit64 *rlim64)",
            "{",
            "\tif (rlim->rlim_cur == RLIM_INFINITY)",
            "\t\trlim64->rlim_cur = RLIM64_INFINITY;",
            "\telse",
            "\t\trlim64->rlim_cur = rlim->rlim_cur;",
            "\tif (rlim->rlim_max == RLIM_INFINITY)",
            "\t\trlim64->rlim_max = RLIM64_INFINITY;",
            "\telse",
            "\t\trlim64->rlim_max = rlim->rlim_max;",
            "}"
          ],
          "function_name": "override_release, do_prlimit, rlim64_is_infinity, rlim_to_rlim64",
          "description": "该代码段主要实现三个功能：  \n1. **`override_release`** 函数用于覆盖内核版本字符串，在 `UNAME26` 人格模式下强制替换 `UTS_RELEASE` 字符串为自定义格式（如 `2.6.xxxx`），并复制至用户空间。  \n2. **`do_prlimit`** 函数负责处理进程资源限制（如文件数、CPU时间等），执行有效性校验、权限检查，并通过安全钩子更新限制值，同时对 CPU 资源触发 POSIX 定时器。  \n3. **`rlim64_is_infinity` 和 `rlim_to_rlim64`** 分别用于判断 64 位资源限制是否为无穷大，以及将传统 32 位 `rlimit` 结构转换为 64 位版本以适配更大数值范围。",
          "similarity": 0.4660533666610718
        }
      ]
    },
    {
      "source_file": "kernel/static_call_inline.c",
      "md_summary": "> 自动生成时间: 2025-10-25 16:29:06\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `static_call_inline.c`\n\n---\n\n# static_call_inline.c 技术文档\n\n## 1. 文件概述\n\n`static_call_inline.c` 是 Linux 内核中实现 **静态调用（Static Call）** 机制的核心文件之一。静态调用是一种运行时可动态更新的函数调用优化技术，它在编译时将函数调用点内联为对跳板（trampoline）的直接跳转，而在运行时可通过 `__static_call_update()` 动态修改所有调用点，使其跳转到新的目标函数，从而避免传统函数指针调用的间接开销。该机制常用于性能敏感路径（如调度、RCU、tracepoint 等），同时支持模块热插拔和初始化阶段的特殊处理。\n\n## 2. 核心功能\n\n### 主要函数\n\n- `static_call_force_reinit(void)`  \n  强制重新初始化静态调用机制，用于调试或特殊场景，必须在 `early_initcall()` 之前调用。\n\n- `__static_call_update(struct static_call_key *key, void *tramp, void *func)`  \n  核心更新函数：将指定 `key` 对应的所有静态调用点更新为调用 `func`，并更新跳板 `tramp`。支持内核和模块中的调用点。\n\n- `__static_call_init(struct module *mod, struct static_call_site *start, struct static_call_site *stop)`  \n  初始化静态调用站点，对站点按 `key` 排序，并建立 `key` 到站点的映射关系，同时执行首次 `arch_static_call_transform`。\n\n- `__static_call_text_reserved(...)`  \n  检查指定代码区间是否与活跃的静态调用站点冲突，用于内存热插拔或代码修改前的安全校验。\n\n### 主要数据结构\n\n- `struct static_call_site`  \n  描述一个静态调用点的位置（`addr`）和关联的 `key`（带标志位）。\n\n- `struct static_call_key`  \n  静态调用的“键”，用于将多个调用点分组。包含当前函数指针 `func` 和类型/模块信息。\n\n- `struct static_call_mod`  \n  用于模块场景下，将模块与该模块中属于某 `key` 的调用点列表关联。\n\n- 全局符号：\n  - `__start_static_call_sites[]` / `__stop_static_call_sites[]`：内核镜像中所有静态调用点的链接器生成数组。\n  - `__start_static_call_tramp_key[]` / `__stop_static_call_tramp_key[]`：跳板与 key 的映射。\n\n### 辅助函数与宏\n\n- `static_call_addr(site)`：计算调用点的实际地址（处理重定位）。\n- `static_call_key(site)`：从站点中提取 `static_call_key*`（忽略标志位）。\n- `static_call_is_init(site)` / `static_call_is_tail(site)`：检查站点是否位于 `__init` 段或是否为尾调用。\n- `static_call_sort_entries()`：对站点按 `key` 排序，便于批量处理。\n- `static_call_key_has_mods()` / `static_call_key_sites()`：判断 key 是否关联模块或直接站点。\n\n## 3. 关键实现\n\n### 地址重定位处理\n由于静态调用站点在编译时使用相对地址存储，`static_call_addr()` 和 `__static_call_key()` 通过 `(long)field + (long)&field` 的方式计算出运行时绝对地址，这是处理位置无关代码（PIC）和内核重定位的关键技巧。\n\n### 站点组织与模块支持\n- **内核（vmlinux）场景**：为节省内存和避免早期内存分配，将首个站点指针直接编码到 `key->type` 的低有效位中（通过 `| 1` 标记）。\n- **模块场景**：使用 `static_call_mod` 链表管理不同模块中属于同一 `key` 的站点，支持模块加载/卸载时的动态注册。\n\n### 初始化与更新流程\n1. **初始化**（`__static_call_init`）：\n   - 对站点按 `key` 排序。\n   - 标记位于 `__init` 段的站点（后续更新可跳过）。\n   - 建立 `key` 到站点的映射。\n   - 调用架构相关 `arch_static_call_transform` 执行首次转换（通常设为跳板）。\n\n2. **更新**（`__static_call_update`）：\n   - 更新 `key->func`。\n   - 更新跳板 `tramp` 指向新函数。\n   - 遍历所有关联站点（包括模块），调用 `arch_static_call_transform` 修改调用点指令（如 x86 的 `jmp` 目标）。\n   - 跳过 `__init` 段中已初始化的站点（因不会被执行）。\n\n### 安全与并发控制\n- 使用 `cpus_read_lock()` 防止 CPU 热插拔期间的并发问题。\n- 使用 `static_call_mutex` 保护 `key` 和站点数据结构的修改。\n- 通过 `kernel_text_address()` 验证调用点是否在可执行内核文本段，避免修改无效地址。\n\n## 4. 依赖关系\n\n- **架构依赖**：依赖 `asm/sections.h` 和 `arch_static_call_transform()`（由各架构实现，如 x86、ARM64）。\n- **内核子系统**：\n  - `linux/module.h`：模块加载/卸载时的静态调用站点管理。\n  - `linux/cpu.h` / `linux/smp.h`：CPU 热插拔和并发控制。\n  - `linux/sort.h`：站点排序。\n  - `linux/slab.h`：模块场景下的动态内存分配。\n- **链接器脚本**：依赖链接器生成的 `__start/stop_static_call_sites` 等符号，这些在 `vmlinux.lds` 中定义。\n\n## 5. 使用场景\n\n- **内核核心优化**：在调度器、RCU、中断处理等高频路径中替代函数指针，减少间接调用开销。\n- **动态追踪（ftrace）**：作为 tracepoint 或 kprobe 的底层机制，实现零开销探针。\n- **模块热插拔**：模块加载时注册其静态调用站点，卸载时自动清理，确保调用点始终有效。\n- **初始化优化**：`__init` 段的调用点在初始化完成后可被安全忽略，减少运行时开销。\n- **安全代码修改**：在 livepatch 或内核热补丁中，安全地替换函数实现而不影响运行中的调用。",
      "similarity": 0.5856809616088867,
      "chunks": [
        {
          "chunk_id": 4,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 453,
          "end_line": 552,
          "content": [
            "static int static_call_module_notify(struct notifier_block *nb,",
            "\t\t\t\t     unsigned long val, void *data)",
            "{",
            "\tstruct module *mod = data;",
            "\tint ret = 0;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "",
            "\tswitch (val) {",
            "\tcase MODULE_STATE_COMING:",
            "\t\tret = static_call_add_module(mod);",
            "\t\tif (ret) {",
            "\t\t\tpr_warn(\"Failed to allocate memory for static calls\\n\");",
            "\t\t\tstatic_call_del_module(mod);",
            "\t\t}",
            "\t\tbreak;",
            "\tcase MODULE_STATE_GOING:",
            "\t\tstatic_call_del_module(mod);",
            "\t\tbreak;",
            "\t}",
            "",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "",
            "\treturn notifier_from_errno(ret);",
            "}",
            "int klp_static_call_register(struct module *mod)",
            "{",
            "\tint ret;",
            "",
            "\tret = static_call_module_notify(&static_call_module_nb, MODULE_STATE_COMING, mod);",
            "\treturn notifier_to_errno(ret);",
            "}",
            "static inline int __static_call_mod_text_reserved(void *start, void *end)",
            "{",
            "\treturn 0;",
            "}",
            "int static_call_text_reserved(void *start, void *end)",
            "{",
            "\tbool init = system_state < SYSTEM_RUNNING;",
            "\tint ret = __static_call_text_reserved(__start_static_call_sites,",
            "\t\t\t__stop_static_call_sites, start, end, init);",
            "",
            "\tif (ret)",
            "\t\treturn ret;",
            "",
            "\treturn __static_call_mod_text_reserved(start, end);",
            "}",
            "int __init static_call_init(void)",
            "{",
            "\tint ret;",
            "",
            "\t/* See static_call_force_reinit(). */",
            "\tif (static_call_initialized == 1)",
            "\t\treturn 0;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "\tret = __static_call_init(NULL, __start_static_call_sites,",
            "\t\t\t\t __stop_static_call_sites);",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "",
            "\tif (ret) {",
            "\t\tpr_err(\"Failed to allocate memory for static_call!\\n\");",
            "\t\tBUG();",
            "\t}",
            "",
            "#ifdef CONFIG_MODULES",
            "\tif (!static_call_initialized)",
            "\t\tregister_module_notifier(&static_call_module_nb);",
            "#endif",
            "",
            "\tstatic_call_initialized = 1;",
            "\treturn 0;",
            "}",
            "static int func_a(int x)",
            "{",
            "\treturn x+1;",
            "}",
            "static int func_b(int x)",
            "{",
            "\treturn x+2;",
            "}",
            "static int __init test_static_call_init(void)",
            "{",
            "      int i;",
            "",
            "      for (i = 0; i < ARRAY_SIZE(static_call_data); i++ ) {",
            "\t      struct static_call_data *scd = &static_call_data[i];",
            "",
            "              if (scd->func)",
            "                      static_call_update(sc_selftest, scd->func);",
            "",
            "              WARN_ON(static_call(sc_selftest)(scd->val) != scd->expect);",
            "      }",
            "",
            "      return 0;",
            "}"
          ],
          "function_name": "static_call_module_notify, klp_static_call_register, __static_call_mod_text_reserved, static_call_text_reserved, static_call_init, func_a, func_b, test_static_call_init",
          "description": "实现模块状态变更通知机制，完成静态调用系统的初始化注册，包含测试函数用于验证静态调用逻辑的正确性。",
          "similarity": 0.5786886811256409
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 23,
          "end_line": 176,
          "content": [
            "void static_call_force_reinit(void)",
            "{",
            "\tif (WARN_ON_ONCE(!static_call_initialized))",
            "\t\treturn;",
            "",
            "\tstatic_call_initialized++;",
            "}",
            "static void static_call_lock(void)",
            "{",
            "\tmutex_lock(&static_call_mutex);",
            "}",
            "static void static_call_unlock(void)",
            "{",
            "\tmutex_unlock(&static_call_mutex);",
            "}",
            "static inline unsigned long __static_call_key(const struct static_call_site *site)",
            "{",
            "\treturn (long)site->key + (long)&site->key;",
            "}",
            "static inline bool static_call_is_init(struct static_call_site *site)",
            "{",
            "\treturn __static_call_key(site) & STATIC_CALL_SITE_INIT;",
            "}",
            "static inline bool static_call_is_tail(struct static_call_site *site)",
            "{",
            "\treturn __static_call_key(site) & STATIC_CALL_SITE_TAIL;",
            "}",
            "static inline void static_call_set_init(struct static_call_site *site)",
            "{",
            "\tsite->key = (__static_call_key(site) | STATIC_CALL_SITE_INIT) -",
            "\t\t    (long)&site->key;",
            "}",
            "static int static_call_site_cmp(const void *_a, const void *_b)",
            "{",
            "\tconst struct static_call_site *a = _a;",
            "\tconst struct static_call_site *b = _b;",
            "\tconst struct static_call_key *key_a = static_call_key(a);",
            "\tconst struct static_call_key *key_b = static_call_key(b);",
            "",
            "\tif (key_a < key_b)",
            "\t\treturn -1;",
            "",
            "\tif (key_a > key_b)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static void static_call_site_swap(void *_a, void *_b, int size)",
            "{",
            "\tlong delta = (unsigned long)_a - (unsigned long)_b;",
            "\tstruct static_call_site *a = _a;",
            "\tstruct static_call_site *b = _b;",
            "\tstruct static_call_site tmp = *a;",
            "",
            "\ta->addr = b->addr  - delta;",
            "\ta->key  = b->key   - delta;",
            "",
            "\tb->addr = tmp.addr + delta;",
            "\tb->key  = tmp.key  + delta;",
            "}",
            "static inline void static_call_sort_entries(struct static_call_site *start,",
            "\t\t\t\t\t    struct static_call_site *stop)",
            "{",
            "\tsort(start, stop - start, sizeof(struct static_call_site),",
            "\t     static_call_site_cmp, static_call_site_swap);",
            "}",
            "static inline bool static_call_key_has_mods(struct static_call_key *key)",
            "{",
            "\treturn !(key->type & 1);",
            "}",
            "void __static_call_update(struct static_call_key *key, void *tramp, void *func)",
            "{",
            "\tstruct static_call_site *site, *stop;",
            "\tstruct static_call_mod *site_mod, first;",
            "",
            "\tcpus_read_lock();",
            "\tstatic_call_lock();",
            "",
            "\tif (key->func == func)",
            "\t\tgoto done;",
            "",
            "\tkey->func = func;",
            "",
            "\tarch_static_call_transform(NULL, tramp, func, false);",
            "",
            "\t/*",
            "\t * If uninitialized, we'll not update the callsites, but they still",
            "\t * point to the trampoline and we just patched that.",
            "\t */",
            "\tif (WARN_ON_ONCE(!static_call_initialized))",
            "\t\tgoto done;",
            "",
            "\tfirst = (struct static_call_mod){",
            "\t\t.next = static_call_key_next(key),",
            "\t\t.mod = NULL,",
            "\t\t.sites = static_call_key_sites(key),",
            "\t};",
            "",
            "\tfor (site_mod = &first; site_mod; site_mod = site_mod->next) {",
            "\t\tbool init = system_state < SYSTEM_RUNNING;",
            "\t\tstruct module *mod = site_mod->mod;",
            "",
            "\t\tif (!site_mod->sites) {",
            "\t\t\t/*",
            "\t\t\t * This can happen if the static call key is defined in",
            "\t\t\t * a module which doesn't use it.",
            "\t\t\t *",
            "\t\t\t * It also happens in the has_mods case, where the",
            "\t\t\t * 'first' entry has no sites associated with it.",
            "\t\t\t */",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tstop = __stop_static_call_sites;",
            "",
            "\t\tif (mod) {",
            "#ifdef CONFIG_MODULES",
            "\t\t\tstop = mod->static_call_sites +",
            "\t\t\t       mod->num_static_call_sites;",
            "\t\t\tinit = mod->state == MODULE_STATE_COMING;",
            "#endif",
            "\t\t}",
            "",
            "\t\tfor (site = site_mod->sites;",
            "\t\t     site < stop && static_call_key(site) == key; site++) {",
            "\t\t\tvoid *site_addr = static_call_addr(site);",
            "",
            "\t\t\tif (!init && static_call_is_init(site))",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tif (!kernel_text_address((unsigned long)site_addr)) {",
            "\t\t\t\t/*",
            "\t\t\t\t * This skips patching built-in __exit, which",
            "\t\t\t\t * is part of init_section_contains() but is",
            "\t\t\t\t * not part of kernel_text_address().",
            "\t\t\t\t *",
            "\t\t\t\t * Skipping built-in __exit is fine since it",
            "\t\t\t\t * will never be executed.",
            "\t\t\t\t */",
            "\t\t\t\tWARN_ONCE(!static_call_is_init(site),",
            "\t\t\t\t\t  \"can't patch static call site at %pS\",",
            "\t\t\t\t\t  site_addr);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "",
            "\t\t\tarch_static_call_transform(site_addr, NULL, func,",
            "\t\t\t\t\t\t   static_call_is_tail(site));",
            "\t\t}",
            "\t}",
            "",
            "done:",
            "\tstatic_call_unlock();",
            "\tcpus_read_unlock();",
            "}"
          ],
          "function_name": "static_call_force_reinit, static_call_lock, static_call_unlock, __static_call_key, static_call_is_init, static_call_is_tail, static_call_set_init, static_call_site_cmp, static_call_site_swap, static_call_sort_entries, static_call_key_has_mods, __static_call_update",
          "description": "实现静态调用的互斥锁控制、键值计算、站点排序及更新逻辑，包含地址冲突检测和模块间调用关系维护功能。",
          "similarity": 0.5454326868057251
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 220,
          "end_line": 340,
          "content": [
            "static int __static_call_init(struct module *mod,",
            "\t\t\t      struct static_call_site *start,",
            "\t\t\t      struct static_call_site *stop)",
            "{",
            "\tstruct static_call_site *site;",
            "\tstruct static_call_key *key, *prev_key = NULL;",
            "\tstruct static_call_mod *site_mod;",
            "",
            "\tif (start == stop)",
            "\t\treturn 0;",
            "",
            "\tstatic_call_sort_entries(start, stop);",
            "",
            "\tfor (site = start; site < stop; site++) {",
            "\t\tvoid *site_addr = static_call_addr(site);",
            "",
            "\t\tif ((mod && within_module_init((unsigned long)site_addr, mod)) ||",
            "\t\t    (!mod && init_section_contains(site_addr, 1)))",
            "\t\t\tstatic_call_set_init(site);",
            "",
            "\t\tkey = static_call_key(site);",
            "\t\tif (key != prev_key) {",
            "\t\t\tprev_key = key;",
            "",
            "\t\t\t/*",
            "\t\t\t * For vmlinux (!mod) avoid the allocation by storing",
            "\t\t\t * the sites pointer in the key itself. Also see",
            "\t\t\t * __static_call_update()'s @first.",
            "\t\t\t *",
            "\t\t\t * This allows architectures (eg. x86) to call",
            "\t\t\t * static_call_init() before memory allocation works.",
            "\t\t\t */",
            "\t\t\tif (!mod) {",
            "\t\t\t\tkey->sites = site;",
            "\t\t\t\tkey->type |= 1;",
            "\t\t\t\tgoto do_transform;",
            "\t\t\t}",
            "",
            "\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);",
            "\t\t\tif (!site_mod)",
            "\t\t\t\treturn -ENOMEM;",
            "",
            "\t\t\t/*",
            "\t\t\t * When the key has a direct sites pointer, extract",
            "\t\t\t * that into an explicit struct static_call_mod, so we",
            "\t\t\t * can have a list of modules.",
            "\t\t\t */",
            "\t\t\tif (static_call_key_sites(key)) {",
            "\t\t\t\tsite_mod->mod = NULL;",
            "\t\t\t\tsite_mod->next = NULL;",
            "\t\t\t\tsite_mod->sites = static_call_key_sites(key);",
            "",
            "\t\t\t\tkey->mods = site_mod;",
            "",
            "\t\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);",
            "\t\t\t\tif (!site_mod)",
            "\t\t\t\t\treturn -ENOMEM;",
            "\t\t\t}",
            "",
            "\t\t\tsite_mod->mod = mod;",
            "\t\t\tsite_mod->sites = site;",
            "\t\t\tsite_mod->next = static_call_key_next(key);",
            "\t\t\tkey->mods = site_mod;",
            "\t\t}",
            "",
            "do_transform:",
            "\t\tarch_static_call_transform(site_addr, NULL, key->func,",
            "\t\t\t\tstatic_call_is_tail(site));",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int addr_conflict(struct static_call_site *site, void *start, void *end)",
            "{",
            "\tunsigned long addr = (unsigned long)static_call_addr(site);",
            "",
            "\tif (addr <= (unsigned long)end &&",
            "\t    addr + CALL_INSN_SIZE > (unsigned long)start)",
            "\t\treturn 1;",
            "",
            "\treturn 0;",
            "}",
            "static int __static_call_text_reserved(struct static_call_site *iter_start,",
            "\t\t\t\t       struct static_call_site *iter_stop,",
            "\t\t\t\t       void *start, void *end, bool init)",
            "{",
            "\tstruct static_call_site *iter = iter_start;",
            "",
            "\twhile (iter < iter_stop) {",
            "\t\tif (init || !static_call_is_init(iter)) {",
            "\t\t\tif (addr_conflict(iter, start, end))",
            "\t\t\t\treturn 1;",
            "\t\t}",
            "\t\titer++;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int __static_call_mod_text_reserved(void *start, void *end)",
            "{",
            "\tstruct module *mod;",
            "\tint ret;",
            "",
            "\tpreempt_disable();",
            "\tmod = __module_text_address((unsigned long)start);",
            "\tWARN_ON_ONCE(__module_text_address((unsigned long)end) != mod);",
            "\tif (!try_module_get(mod))",
            "\t\tmod = NULL;",
            "\tpreempt_enable();",
            "",
            "\tif (!mod)",
            "\t\treturn 0;",
            "",
            "\tret = __static_call_text_reserved(mod->static_call_sites,",
            "\t\t\tmod->static_call_sites + mod->num_static_call_sites,",
            "\t\t\tstart, end, mod->state == MODULE_STATE_COMING);",
            "",
            "\tmodule_put(mod);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "__static_call_init, addr_conflict, __static_call_text_reserved, __static_call_mod_text_reserved",
          "description": "执行静态调用初始化流程，分配模块关联结构体并进行地址转换，实现文本区域预留检查以避免内存覆盖。",
          "similarity": 0.544765293598175
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 1,
          "end_line": 22,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "#include <linux/init.h>",
            "#include <linux/static_call.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/cpu.h>",
            "#include <linux/processor.h>",
            "#include <asm/sections.h>",
            "",
            "extern struct static_call_site __start_static_call_sites[],",
            "\t\t\t       __stop_static_call_sites[];",
            "extern struct static_call_tramp_key __start_static_call_tramp_key[],",
            "\t\t\t\t    __stop_static_call_tramp_key[];",
            "",
            "int static_call_initialized;",
            "",
            "/*",
            " * Must be called before early_initcall() to be effective.",
            " */"
          ],
          "function_name": null,
          "description": "声明静态调用相关的全局变量和外部符号，定义静态调用初始化标志位，为后续静态调用站点管理和地址转换提供基础结构。",
          "similarity": 0.5424334406852722
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/static_call_inline.c",
          "start_line": 347,
          "end_line": 449,
          "content": [
            "static unsigned long tramp_key_lookup(unsigned long addr)",
            "{",
            "\tstruct static_call_tramp_key *start = __start_static_call_tramp_key;",
            "\tstruct static_call_tramp_key *stop = __stop_static_call_tramp_key;",
            "\tstruct static_call_tramp_key *tramp_key;",
            "",
            "\tfor (tramp_key = start; tramp_key != stop; tramp_key++) {",
            "\t\tunsigned long tramp;",
            "",
            "\t\ttramp = (long)tramp_key->tramp + (long)&tramp_key->tramp;",
            "\t\tif (tramp == addr)",
            "\t\t\treturn (long)tramp_key->key + (long)&tramp_key->key;",
            "\t}",
            "",
            "\treturn 0;",
            "}",
            "static int static_call_add_module(struct module *mod)",
            "{",
            "\tstruct static_call_site *start = mod->static_call_sites;",
            "\tstruct static_call_site *stop = start + mod->num_static_call_sites;",
            "\tstruct static_call_site *site;",
            "",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (unlikely(!mod_klp_rel_completed(mod)))",
            "\t\treturn 0;",
            "#endif",
            "",
            "\tfor (site = start; site != stop; site++) {",
            "\t\tunsigned long s_key = __static_call_key(site);",
            "\t\tunsigned long addr = s_key & ~STATIC_CALL_SITE_FLAGS;",
            "\t\tunsigned long key;",
            "",
            "\t\t/*",
            "\t\t * Is the key is exported, 'addr' points to the key, which",
            "\t\t * means modules are allowed to call static_call_update() on",
            "\t\t * it.",
            "\t\t *",
            "\t\t * Otherwise, the key isn't exported, and 'addr' points to the",
            "\t\t * trampoline so we need to lookup the key.",
            "\t\t *",
            "\t\t * We go through this dance to prevent crazy modules from",
            "\t\t * abusing sensitive static calls.",
            "\t\t */",
            "\t\tif (!kernel_text_address(addr))",
            "\t\t\tcontinue;",
            "",
            "\t\tkey = tramp_key_lookup(addr);",
            "\t\tif (!key) {",
            "\t\t\tpr_warn(\"Failed to fixup __raw_static_call() usage at: %ps\\n\",",
            "\t\t\t\tstatic_call_addr(site));",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "",
            "\t\tkey |= s_key & STATIC_CALL_SITE_FLAGS;",
            "\t\tsite->key = key - (long)&site->key;",
            "\t}",
            "",
            "\treturn __static_call_init(mod, start, stop);",
            "}",
            "static void static_call_del_module(struct module *mod)",
            "{",
            "\tstruct static_call_site *start = mod->static_call_sites;",
            "\tstruct static_call_site *stop = mod->static_call_sites +",
            "\t\t\t\t\tmod->num_static_call_sites;",
            "\tstruct static_call_key *key, *prev_key = NULL;",
            "\tstruct static_call_mod *site_mod, **prev;",
            "\tstruct static_call_site *site;",
            "",
            "#ifdef CONFIG_LIVEPATCH_WO_FTRACE",
            "\tif (unlikely(!mod_klp_rel_completed(mod)))",
            "\t\treturn;",
            "#endif",
            "",
            "\tfor (site = start; site < stop; site++) {",
            "\t\tkey = static_call_key(site);",
            "",
            "\t\t/*",
            "\t\t * If the key was not updated due to a memory allocation",
            "\t\t * failure in __static_call_init() then treating key::sites",
            "\t\t * as key::mods in the code below would cause random memory",
            "\t\t * access and #GP. In that case all subsequent sites have",
            "\t\t * not been touched either, so stop iterating.",
            "\t\t */",
            "\t\tif (!static_call_key_has_mods(key))",
            "\t\t\tbreak;",
            "",
            "\t\tif (key == prev_key)",
            "\t\t\tcontinue;",
            "",
            "\t\tprev_key = key;",
            "",
            "\t\tfor (prev = &key->mods, site_mod = key->mods;",
            "\t\t     site_mod && site_mod->mod != mod;",
            "\t\t     prev = &site_mod->next, site_mod = site_mod->next)",
            "\t\t\t;",
            "",
            "\t\tif (!site_mod)",
            "\t\t\tcontinue;",
            "",
            "\t\t*prev = site_mod->next;",
            "\t\tkfree(site_mod);",
            "\t}",
            "}"
          ],
          "function_name": "tramp_key_lookup, static_call_add_module, static_call_del_module",
          "description": "处理模块动态加载/卸载时的静态调用更新，通过键查找机制确保跨模块调用正确性，并维护静态调用站点的模块绑定关系。",
          "similarity": 0.4997715651988983
        }
      ]
    },
    {
      "source_file": "kernel/exec_domain.c",
      "md_summary": "> 自动生成时间: 2025-10-25 13:26:24\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `exec_domain.c`\n\n---\n\n# exec_domain.c 技术文档\n\n## 1. 文件概述\n\n`exec_domain.c` 是 Linux 内核中用于管理不同 ABI（Application Binary Interface，应用程序二进制接口）执行域（execution domains）的核心文件。该文件实现了对“personality”机制的支持，允许进程在运行时切换其行为模式，以兼容不同操作系统或 ABI 的语义，例如信号处理、系统调用编号映射等。当前实现主要保留了基础框架，并默认仅支持标准 Linux personality。\n\n## 2. 核心功能\n\n### 主要函数\n\n- **`SYSCALL_DEFINE1(personality, unsigned int, personality)`**  \n  系统调用入口，用于获取或设置当前进程的 personality。若传入参数不为 `0xffffffff`，则调用 `set_personality()` 更新当前进程的 personality；无论是否更新，均返回旧值。\n\n- **`execdomains_proc_show(struct seq_file *m, void *v)`**（条件编译）  \n  在 `/proc/execdomains` 文件中输出当前内核支持的执行域列表。当前仅输出标准 Linux 执行域（ID 0-0）。\n\n- **`proc_execdomains_init(void)`**（条件编译）  \n  初始化 `/proc/execdomains` 接口，仅在 `CONFIG_PROC_FS` 配置启用时编译。\n\n## 3. 关键实现\n\n- **Personality 机制**：  \n  每个进程的 `task_struct` 中包含 `personality` 字段，用于标识其当前的执行域行为。通过 `personality()` 系统调用可动态切换该值，从而影响内核对信号、路径解析、系统调用等行为的处理方式。\n\n- **执行域注册与查询**：  \n  历史上 Linux 支持多种执行域（如 SVr4、BSD、OSF 等），但现代内核已移除大部分实现，仅保留 Linux 原生执行域（ID 0）。`/proc/execdomains` 接口静态返回 `\"0-0\\tLinux\\t[kernel]\\n\"`，表明当前仅支持标准 Linux ABI。\n\n- **系统调用接口**：  \n  `personality()` 系统调用是用户空间与内核 personality 机制交互的唯一入口。传入 `0xffffffff` 可用于仅查询当前值而不修改。\n\n- **模块初始化**：  \n  若启用了 `CONFIG_PROC_FS`，则在内核初始化阶段通过 `module_init()` 注册 `/proc/execdomains` 文件，供用户空间查询支持的执行域。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/personality.h>`：定义 personality 相关常量和 `set_personality()` 函数。\n  - `<linux/sched.h>`：访问 `current` 宏以获取当前进程的 `task_struct`。\n  - `<linux/proc_fs.h>` 和 `<linux/seq_file.h>`：用于实现 `/proc/execdomains` 接口。\n  - `<linux/syscalls.h>`：用于定义系统调用。\n  - 其他通用内核头文件（如 `init.h`, `kernel.h`, `module.h` 等）。\n\n- **内核配置依赖**：\n  - `CONFIG_PROC_FS`：控制是否编译 `/proc/execdomains` 接口。\n\n- **外部模块交互**：\n  - 该文件不导出符号供其他模块使用，属于内核核心 ABI 支持层。\n  - `set_personality()` 的具体实现位于 `kernel/sys.c` 中。\n\n## 5. 使用场景\n\n- **兼容性运行环境**：  \n  在早期 Linux 中，用于运行非 Linux 二进制程序（如通过 binfmt 模块加载的 SVr4 或 BSD 程序），通过设置特定 personality 使内核模拟目标系统的 ABI 行为。\n\n- **调试与沙箱**：  \n  用户空间程序可通过 `personality(PER_LINUX)` 或其他标志（如 `ADDR_NO_RANDOMIZE`）临时修改进程行为，例如禁用 ASLR 以辅助调试。\n\n- **系统信息查询**：  \n  用户可通过读取 `/proc/execdomains` 了解当前内核支持的执行域类型（尽管现代系统通常仅显示 Linux）。\n\n- **容器与虚拟化**：  \n  在某些轻量级虚拟化场景中，可通过 personality 机制微调进程的系统调用行为，但现代方案更多依赖 seccomp 或 namespaces。",
      "similarity": 0.5842055082321167,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/exec_domain.c",
          "start_line": 24,
          "end_line": 33,
          "content": [
            "static int execdomains_proc_show(struct seq_file *m, void *v)",
            "{",
            "\tseq_puts(m, \"0-0\\tLinux           \\t[kernel]\\n\");",
            "\treturn 0;",
            "}",
            "static int __init proc_execdomains_init(void)",
            "{",
            "\tproc_create_single(\"execdomains\", 0, NULL, execdomains_proc_show);",
            "\treturn 0;",
            "}"
          ],
          "function_name": "execdomains_proc_show, proc_execdomains_init",
          "description": "定义用于 /proc/execdomains 文件的读取回调函数及初始化函数，通过 proc_create_single 创建 proc 文件节点以暴露当前系统运行的执行域标识及其关联的 ABI 类型信息",
          "similarity": 0.46880078315734863
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/exec_domain.c",
          "start_line": 1,
          "end_line": 23,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/*",
            " * Handling of different ABIs (personalities).",
            " *",
            " * We group personalities into execution domains which have their",
            " * own handlers for kernel entry points, signal mapping, etc...",
            " *",
            " * 2001-05-06\tComplete rewrite,  Christoph Hellwig (hch@infradead.org)",
            " */",
            "",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kmod.h>",
            "#include <linux/module.h>",
            "#include <linux/personality.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/types.h>",
            "",
            "#ifdef CONFIG_PROC_FS"
          ],
          "function_name": null,
          "description": "此代码块包含执行域（exec domain）相关的头文件声明，启用对 PROC_FS 的支持以实现 ABI 特性处理，因代码片段未展示核心逻辑故标记上下文不完整",
          "similarity": 0.4673954248428345
        }
      ]
    }
  ]
}