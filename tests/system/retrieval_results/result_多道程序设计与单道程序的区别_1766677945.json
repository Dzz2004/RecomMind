{
  "query": "多道程序设计与单道程序的区别",
  "timestamp": "2025-12-25 23:52:25",
  "retrieved_files": [
    {
      "source_file": "kernel/bpf/mprog.c",
      "md_summary": "> 自动生成时间: 2025-10-25 12:20:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `bpf\\mprog.c`\n\n---\n\n# bpf/mprog.c 技术文档\n\n## 1. 文件概述\n\n`bpf/mprog.c` 是 Linux 内核中用于管理 **BPF 多程序（multi-program）挂载点** 的核心实现文件。该文件提供了一套机制，允许在同一个挂载点上按顺序组织多个 BPF 程序（或通过 BPF link 关联的程序），并支持在运行时对这些程序进行 **插入、替换、删除** 等原子操作。此机制主要用于支持 **BPF 程序链（program chains）**，例如在 tc（traffic control）、XDP 或 cgroup 等子系统中实现多个 BPF 程序的有序执行。\n\n## 2. 核心功能\n\n### 主要数据结构\n- `struct bpf_tuple`：封装一个 BPF 程序及其关联的 link（可选），用于统一表示待操作的目标程序。\n- `struct bpf_mprog_entry`：表示一个多程序挂载点的当前状态，包含程序数组、引用计数、版本号等。\n- `struct bpf_mprog_fp` / `struct bpf_mprog_cp`：分别表示程序的“快路径”（fast path）和“控制路径”（control path）数据，用于 RCU 安全的读写分离。\n\n### 主要函数\n\n| 函数 | 功能 |\n|------|------|\n| `bpf_mprog_link()` | 从 ID 或 FD 解析 BPF link，并验证程序类型 |\n| `bpf_mprog_prog()` | 从 ID 或 FD 解析 BPF program，并验证程序类型 |\n| `bpf_mprog_tuple_relative()` | 根据 flags（如 `BPF_F_ID`, `BPF_F_LINK`）统一解析用户传入的 `id_or_fd` 为 `bpf_tuple` |\n| `bpf_mprog_tuple_put()` | 释放 `bpf_tuple` 中持有的 program 或 link 引用 |\n| `bpf_mprog_replace()` | 在指定索引位置替换现有程序 |\n| `bpf_mprog_insert()` | 在指定位置（支持 `BPF_F_BEFORE` / `BPF_F_AFTER`）插入新程序 |\n| `bpf_mprog_delete()` | 删除指定位置的程序（支持首尾删除：`idx = -1` 或 `idx = total`） |\n| `bpf_mprog_pos_exact()` | 查找与给定 tuple 完全匹配的程序位置 |\n| `bpf_mprog_pos_before()` / `bpf_mprog_pos_after()` | 根据相对位置语义计算插入/删除目标索引 |\n| `bpf_mprog_attach()` | **核心入口函数**：根据用户 flags 执行 attach、replace 或 insert 操作 |\n| `bpf_mprog_fetch()` | （未完整实现）用于获取指定索引处的程序信息 |\n\n## 3. 关键实现\n\n### 3.1 程序与 Link 的统一抽象（`bpf_tuple`）\n通过 `bpf_tuple` 结构，将直接使用 BPF program FD/ID 与通过 BPF link 引用程序两种方式统一处理。`BPF_F_LINK` 标志决定是否从 link 解析，`BPF_F_ID` 决定输入是 ID 还是 FD。\n\n### 3.2 RCU 安全的多程序管理\n- 使用 `bpf_mprog_entry` 的 peer 机制实现 **写时复制（Copy-on-Write）**：\n  - 修改操作（insert/replace/delete）先复制当前 entry 到 peer\n  - 在 peer 上修改，最后原子切换指针\n  - 旧 entry 通过 RCU 回收，确保并发读安全\n- `bpf_mprog_read()` / `bpf_mprog_write()` 封装了对 `fp`（fast path）和 `cp`（control path）的访问\n\n### 3.3 相对位置语义支持\n- `BPF_F_BEFORE` / `BPF_F_AFTER` 允许用户指定相对于某个已有程序的位置\n- `bpf_mprog_pos_before()` / `bpf_mprog_pos_after()` 遍历当前程序列表，查找参考程序位置并返回目标索引\n- 特殊情况：当 `id_or_fd = 0` 且无 flags 时，表示在末尾插入（`idx = total`）\n\n### 3.4 原子性与一致性保障\n- `revision` 参数用于防止并发修改冲突（类似乐观锁）\n- `bpf_mprog_exists()` 检查避免重复添加同一程序\n- 所有修改操作最终通过 `*entry_new` 返回新 entry，由调用者负责发布\n\n### 3.5 边界处理\n- 插入到末尾：`idx == total`\n- 删除首元素：`idx = -1` → 转换为 `0`\n- 删除尾元素：`idx = total` → 转换为 `total - 1`\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/bpf.h>`：BPF 核心定义（`bpf_prog`, `bpf_link` 等）\n  - `<linux/bpf_mprog.h>`：多程序管理相关 API 和数据结构声明\n- **内核子系统依赖**：\n  - BPF 核心子系统（程序/链接生命周期管理）\n  - RCU 机制（用于无锁读取）\n  - 内存管理（`kmalloc`/`kfree` 用于 entry 复制）\n- **被调用方**：\n  - BPF 系统调用处理函数（如 `bpf(BPF_PROG_ATTACH, ...)` 的多程序扩展）\n  - 网络子系统（如 tc BPF 多程序支持）\n\n## 5. 使用场景\n\n1. **tc BPF 多程序链**：在同一个网络 qdisc 上挂载多个 BPF 程序，按顺序执行分类/过滤/修改操作\n2. **cgroup BPF 程序链**：在 cgroup 层级上组合多个安全或资源控制策略\n3. **动态策略更新**：运行时替换某个中间策略程序，而不中断整个链的执行\n4. **模块化 BPF 应用**：将复杂逻辑拆分为多个小程序，通过 attach 顺序组合\n5. **调试与热补丁**：临时插入诊断程序或替换有缺陷的程序版本\n\n该机制为 BPF 提供了类似“插件链”或“中间件栈”的能力，增强了 BPF 程序的组合性和动态管理能力。",
      "similarity": 0.5213929414749146,
      "chunks": [
        {
          "chunk_id": 1,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 7,
          "end_line": 116,
          "content": [
            "static int bpf_mprog_link(struct bpf_tuple *tuple,",
            "\t\t\t  u32 id_or_fd, u32 flags,",
            "\t\t\t  enum bpf_prog_type type)",
            "{",
            "\tstruct bpf_link *link = ERR_PTR(-EINVAL);",
            "\tbool id = flags & BPF_F_ID;",
            "",
            "\tif (id)",
            "\t\tlink = bpf_link_by_id(id_or_fd);",
            "\telse if (id_or_fd)",
            "\t\tlink = bpf_link_get_from_fd(id_or_fd);",
            "\tif (IS_ERR(link))",
            "\t\treturn PTR_ERR(link);",
            "\tif (type && link->prog->type != type) {",
            "\t\tbpf_link_put(link);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttuple->link = link;",
            "\ttuple->prog = link->prog;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_prog(struct bpf_tuple *tuple,",
            "\t\t\t  u32 id_or_fd, u32 flags,",
            "\t\t\t  enum bpf_prog_type type)",
            "{",
            "\tstruct bpf_prog *prog = ERR_PTR(-EINVAL);",
            "\tbool id = flags & BPF_F_ID;",
            "",
            "\tif (id)",
            "\t\tprog = bpf_prog_by_id(id_or_fd);",
            "\telse if (id_or_fd)",
            "\t\tprog = bpf_prog_get(id_or_fd);",
            "\tif (IS_ERR(prog))",
            "\t\treturn PTR_ERR(prog);",
            "\tif (type && prog->type != type) {",
            "\t\tbpf_prog_put(prog);",
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\ttuple->link = NULL;",
            "\ttuple->prog = prog;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_tuple_relative(struct bpf_tuple *tuple,",
            "\t\t\t\t    u32 id_or_fd, u32 flags,",
            "\t\t\t\t    enum bpf_prog_type type)",
            "{",
            "\tbool link = flags & BPF_F_LINK;",
            "\tbool id = flags & BPF_F_ID;",
            "",
            "\tmemset(tuple, 0, sizeof(*tuple));",
            "\tif (link)",
            "\t\treturn bpf_mprog_link(tuple, id_or_fd, flags, type);",
            "\t/* If no relevant flag is set and no id_or_fd was passed, then",
            "\t * tuple link/prog is just NULLed. This is the case when before/",
            "\t * after selects first/last position without passing fd.",
            "\t */",
            "\tif (!id && !id_or_fd)",
            "\t\treturn 0;",
            "\treturn bpf_mprog_prog(tuple, id_or_fd, flags, type);",
            "}",
            "static void bpf_mprog_tuple_put(struct bpf_tuple *tuple)",
            "{",
            "\tif (tuple->link)",
            "\t\tbpf_link_put(tuple->link);",
            "\telse if (tuple->prog)",
            "\t\tbpf_prog_put(tuple->prog);",
            "}",
            "static int bpf_mprog_replace(struct bpf_mprog_entry *entry,",
            "\t\t\t     struct bpf_mprog_entry **entry_new,",
            "\t\t\t     struct bpf_tuple *ntuple, int idx)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tstruct bpf_prog *oprog;",
            "",
            "\tbpf_mprog_read(entry, idx, &fp, &cp);",
            "\toprog = READ_ONCE(fp->prog);",
            "\tbpf_mprog_write(fp, cp, ntuple);",
            "\tif (!ntuple->link) {",
            "\t\tWARN_ON_ONCE(cp->link);",
            "\t\tbpf_prog_put(oprog);",
            "\t}",
            "\t*entry_new = entry;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_insert(struct bpf_mprog_entry *entry,",
            "\t\t\t    struct bpf_mprog_entry **entry_new,",
            "\t\t\t    struct bpf_tuple *ntuple, int idx, u32 flags)",
            "{",
            "\tint total = bpf_mprog_total(entry);",
            "\tstruct bpf_mprog_entry *peer;",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "",
            "\tpeer = bpf_mprog_peer(entry);",
            "\tbpf_mprog_entry_copy(peer, entry);",
            "\tif (idx == total)",
            "\t\tgoto insert;",
            "\telse if (flags & BPF_F_BEFORE)",
            "\t\tidx += 1;",
            "\tbpf_mprog_entry_grow(peer, idx);",
            "insert:",
            "\tbpf_mprog_read(peer, idx, &fp, &cp);",
            "\tbpf_mprog_write(fp, cp, ntuple);",
            "\tbpf_mprog_inc(peer);",
            "\t*entry_new = peer;",
            "\treturn 0;",
            "}"
          ],
          "function_name": "bpf_mprog_link, bpf_mprog_prog, bpf_mprog_tuple_relative, bpf_mprog_tuple_put, bpf_mprog_replace, bpf_mprog_insert",
          "description": "实现多程序链接与程序绑定逻辑，通过不同标志位选择性设置tuple中的link或prog字段，进行类型校验和引用计数管理",
          "similarity": 0.5247042775154114
        },
        {
          "chunk_id": 2,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 151,
          "end_line": 284,
          "content": [
            "static int bpf_mprog_delete(struct bpf_mprog_entry *entry,",
            "\t\t\t    struct bpf_mprog_entry **entry_new,",
            "\t\t\t    struct bpf_tuple *dtuple, int idx)",
            "{",
            "\tint total = bpf_mprog_total(entry);",
            "\tstruct bpf_mprog_entry *peer;",
            "",
            "\tpeer = bpf_mprog_peer(entry);",
            "\tbpf_mprog_entry_copy(peer, entry);",
            "\tif (idx == -1)",
            "\t\tidx = 0;",
            "\telse if (idx == total)",
            "\t\tidx = total - 1;",
            "\tbpf_mprog_entry_shrink(peer, idx);",
            "\tbpf_mprog_dec(peer);",
            "\tbpf_mprog_mark_for_release(peer, dtuple);",
            "\t*entry_new = peer;",
            "\treturn 0;",
            "}",
            "static int bpf_mprog_pos_exact(struct bpf_mprog_entry *entry,",
            "\t\t\t       struct bpf_tuple *tuple)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < bpf_mprog_total(entry); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tif (tuple->prog == READ_ONCE(fp->prog))",
            "\t\t\treturn tuple->link == cp->link ? i : -EBUSY;",
            "\t}",
            "\treturn -ENOENT;",
            "}",
            "static int bpf_mprog_pos_before(struct bpf_mprog_entry *entry,",
            "\t\t\t\tstruct bpf_tuple *tuple)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < bpf_mprog_total(entry); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tif (tuple->prog == READ_ONCE(fp->prog) &&",
            "\t\t    (!tuple->link || tuple->link == cp->link))",
            "\t\t\treturn i - 1;",
            "\t}",
            "\treturn tuple->prog ? -ENOENT : -1;",
            "}",
            "static int bpf_mprog_pos_after(struct bpf_mprog_entry *entry,",
            "\t\t\t       struct bpf_tuple *tuple)",
            "{",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tint i;",
            "",
            "\tfor (i = 0; i < bpf_mprog_total(entry); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tif (tuple->prog == READ_ONCE(fp->prog) &&",
            "\t\t    (!tuple->link || tuple->link == cp->link))",
            "\t\t\treturn i + 1;",
            "\t}",
            "\treturn tuple->prog ? -ENOENT : bpf_mprog_total(entry);",
            "}",
            "int bpf_mprog_attach(struct bpf_mprog_entry *entry,",
            "\t\t     struct bpf_mprog_entry **entry_new,",
            "\t\t     struct bpf_prog *prog_new, struct bpf_link *link,",
            "\t\t     struct bpf_prog *prog_old,",
            "\t\t     u32 flags, u32 id_or_fd, u64 revision)",
            "{",
            "\tstruct bpf_tuple rtuple, ntuple = {",
            "\t\t.prog = prog_new,",
            "\t\t.link = link,",
            "\t}, otuple = {",
            "\t\t.prog = prog_old,",
            "\t\t.link = link,",
            "\t};",
            "\tint ret, idx = -ERANGE, tidx;",
            "",
            "\tif (revision && revision != bpf_mprog_revision(entry))",
            "\t\treturn -ESTALE;",
            "\tif (bpf_mprog_exists(entry, prog_new))",
            "\t\treturn -EEXIST;",
            "\tret = bpf_mprog_tuple_relative(&rtuple, id_or_fd,",
            "\t\t\t\t       flags & ~BPF_F_REPLACE,",
            "\t\t\t\t       prog_new->type);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tif (flags & BPF_F_REPLACE) {",
            "\t\ttidx = bpf_mprog_pos_exact(entry, &otuple);",
            "\t\tif (tidx < 0) {",
            "\t\t\tret = tidx;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t} else if (bpf_mprog_total(entry) == bpf_mprog_max()) {",
            "\t\tret = -ERANGE;",
            "\t\tgoto out;",
            "\t}",
            "\tif (flags & BPF_F_BEFORE) {",
            "\t\ttidx = bpf_mprog_pos_before(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < -1 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (flags & BPF_F_AFTER) {",
            "\t\ttidx = bpf_mprog_pos_after(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < 0 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (idx < -1) {",
            "\t\tif (rtuple.prog || flags) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = bpf_mprog_total(entry);",
            "\t\tflags = BPF_F_AFTER;",
            "\t}",
            "\tif (idx >= bpf_mprog_max()) {",
            "\t\tret = -ERANGE;",
            "\t\tgoto out;",
            "\t}",
            "\tif (flags & BPF_F_REPLACE)",
            "\t\tret = bpf_mprog_replace(entry, entry_new, &ntuple, idx);",
            "\telse",
            "\t\tret = bpf_mprog_insert(entry, entry_new, &ntuple, idx, flags);",
            "out:",
            "\tbpf_mprog_tuple_put(&rtuple);",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpf_mprog_delete, bpf_mprog_pos_exact, bpf_mprog_pos_before, bpf_mprog_pos_after, bpf_mprog_attach",
          "description": "实现多程序条目删除、精确匹配位置查找、前后位置确定等功能，支持基于程序和链接的条件匹配与索引计算",
          "similarity": 0.5107452869415283
        },
        {
          "chunk_id": 3,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 297,
          "end_line": 450,
          "content": [
            "static int bpf_mprog_fetch(struct bpf_mprog_entry *entry,",
            "\t\t\t   struct bpf_tuple *tuple, int idx)",
            "{",
            "\tint total = bpf_mprog_total(entry);",
            "\tstruct bpf_mprog_cp *cp;",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_prog *prog;",
            "\tstruct bpf_link *link;",
            "",
            "\tif (idx == -1)",
            "\t\tidx = 0;",
            "\telse if (idx == total)",
            "\t\tidx = total - 1;",
            "\tbpf_mprog_read(entry, idx, &fp, &cp);",
            "\tprog = READ_ONCE(fp->prog);",
            "\tlink = cp->link;",
            "\t/* The deletion request can either be without filled tuple in which",
            "\t * case it gets populated here based on idx, or with filled tuple",
            "\t * where the only thing we end up doing is the WARN_ON_ONCE() assert.",
            "\t * If we hit a BPF link at the given index, it must not be removed",
            "\t * from opts path.",
            "\t */",
            "\tif (link && !tuple->link)",
            "\t\treturn -EBUSY;",
            "\tWARN_ON_ONCE(tuple->prog && tuple->prog != prog);",
            "\tWARN_ON_ONCE(tuple->link && tuple->link != link);",
            "\ttuple->prog = prog;",
            "\ttuple->link = link;",
            "\treturn 0;",
            "}",
            "int bpf_mprog_detach(struct bpf_mprog_entry *entry,",
            "\t\t     struct bpf_mprog_entry **entry_new,",
            "\t\t     struct bpf_prog *prog, struct bpf_link *link,",
            "\t\t     u32 flags, u32 id_or_fd, u64 revision)",
            "{",
            "\tstruct bpf_tuple rtuple, dtuple = {",
            "\t\t.prog = prog,",
            "\t\t.link = link,",
            "\t};",
            "\tint ret, idx = -ERANGE, tidx;",
            "",
            "\tif (flags & BPF_F_REPLACE)",
            "\t\treturn -EINVAL;",
            "\tif (revision && revision != bpf_mprog_revision(entry))",
            "\t\treturn -ESTALE;",
            "\tif (!bpf_mprog_total(entry))",
            "\t\treturn -ENOENT;",
            "\tret = bpf_mprog_tuple_relative(&rtuple, id_or_fd, flags,",
            "\t\t\t\t       prog ? prog->type :",
            "\t\t\t\t       BPF_PROG_TYPE_UNSPEC);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tif (dtuple.prog) {",
            "\t\ttidx = bpf_mprog_pos_exact(entry, &dtuple);",
            "\t\tif (tidx < 0) {",
            "\t\t\tret = tidx;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (flags & BPF_F_BEFORE) {",
            "\t\ttidx = bpf_mprog_pos_before(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < -1 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (flags & BPF_F_AFTER) {",
            "\t\ttidx = bpf_mprog_pos_after(entry, &rtuple);",
            "\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {",
            "\t\t\tret = tidx < 0 ? tidx : -ERANGE;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = tidx;",
            "\t}",
            "\tif (idx < -1) {",
            "\t\tif (rtuple.prog || flags) {",
            "\t\t\tret = -EINVAL;",
            "\t\t\tgoto out;",
            "\t\t}",
            "\t\tidx = bpf_mprog_total(entry);",
            "\t\tflags = BPF_F_AFTER;",
            "\t}",
            "\tif (idx >= bpf_mprog_max()) {",
            "\t\tret = -ERANGE;",
            "\t\tgoto out;",
            "\t}",
            "\tret = bpf_mprog_fetch(entry, &dtuple, idx);",
            "\tif (ret)",
            "\t\tgoto out;",
            "\tret = bpf_mprog_delete(entry, entry_new, &dtuple, idx);",
            "out:",
            "\tbpf_mprog_tuple_put(&rtuple);",
            "\treturn ret;",
            "}",
            "int bpf_mprog_query(const union bpf_attr *attr, union bpf_attr __user *uattr,",
            "\t\t    struct bpf_mprog_entry *entry)",
            "{",
            "\tu32 __user *uprog_flags, *ulink_flags;",
            "\tu32 __user *uprog_id, *ulink_id;",
            "\tstruct bpf_mprog_fp *fp;",
            "\tstruct bpf_mprog_cp *cp;",
            "\tstruct bpf_prog *prog;",
            "\tconst u32 flags = 0;",
            "\tu32 id, count = 0;",
            "\tu64 revision = 1;",
            "\tint i, ret = 0;",
            "",
            "\tif (attr->query.query_flags || attr->query.attach_flags)",
            "\t\treturn -EINVAL;",
            "\tif (entry) {",
            "\t\trevision = bpf_mprog_revision(entry);",
            "\t\tcount = bpf_mprog_total(entry);",
            "\t}",
            "\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))",
            "\t\treturn -EFAULT;",
            "\tif (copy_to_user(&uattr->query.revision, &revision, sizeof(revision)))",
            "\t\treturn -EFAULT;",
            "\tif (copy_to_user(&uattr->query.count, &count, sizeof(count)))",
            "\t\treturn -EFAULT;",
            "\tuprog_id = u64_to_user_ptr(attr->query.prog_ids);",
            "\tuprog_flags = u64_to_user_ptr(attr->query.prog_attach_flags);",
            "\tulink_id = u64_to_user_ptr(attr->query.link_ids);",
            "\tulink_flags = u64_to_user_ptr(attr->query.link_attach_flags);",
            "\tif (attr->query.count == 0 || !uprog_id || !count)",
            "\t\treturn 0;",
            "\tif (attr->query.count < count) {",
            "\t\tcount = attr->query.count;",
            "\t\tret = -ENOSPC;",
            "\t}",
            "\tfor (i = 0; i < bpf_mprog_max(); i++) {",
            "\t\tbpf_mprog_read(entry, i, &fp, &cp);",
            "\t\tprog = READ_ONCE(fp->prog);",
            "\t\tif (!prog)",
            "\t\t\tbreak;",
            "\t\tid = prog->aux->id;",
            "\t\tif (copy_to_user(uprog_id + i, &id, sizeof(id)))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (uprog_flags &&",
            "\t\t    copy_to_user(uprog_flags + i, &flags, sizeof(flags)))",
            "\t\t\treturn -EFAULT;",
            "\t\tid = cp->link ? cp->link->id : 0;",
            "\t\tif (ulink_id &&",
            "\t\t    copy_to_user(ulink_id + i, &id, sizeof(id)))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (ulink_flags &&",
            "\t\t    copy_to_user(ulink_flags + i, &flags, sizeof(flags)))",
            "\t\t\treturn -EFAULT;",
            "\t\tif (i + 1 == count)",
            "\t\t\tbreak;",
            "\t}",
            "\treturn ret;",
            "}"
          ],
          "function_name": "bpf_mprog_fetch, bpf_mprog_detach, bpf_mprog_query",
          "description": "实现多程序条目查询接口，支持根据索引获取运行时状态、执行删除操作，并向用户空间导出程序ID和链接ID等元信息",
          "similarity": 0.4976785182952881
        },
        {
          "chunk_id": 0,
          "file_path": "kernel/bpf/mprog.c",
          "start_line": 1,
          "end_line": 6,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0",
            "/* Copyright (c) 2023 Isovalent */",
            "",
            "#include <linux/bpf.h>",
            "#include <linux/bpf_mprog.h>",
            ""
          ],
          "function_name": null,
          "description": "声明GPL许可证并包含BPF相关头文件，为后续多程序模块实现提供基础",
          "similarity": 0.4890531599521637
        }
      ]
    },
    {
      "source_file": "kernel/up.c",
      "md_summary": "> 自动生成时间: 2025-10-25 17:44:43\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `up.c`\n\n---\n\n# up.c 技术文档\n\n## 1. 文件概述\n\n`up.c` 是 Linux 内核中专为单处理器（Uniprocessor, UP）系统实现的 SMP（对称多处理）相关函数的兼容层。在单处理器配置下，真正的多核调度和跨 CPU 调用机制不存在，因此该文件提供与 `kernel/smp.c` 中多处理器版本语义一致但行为简化的替代实现，确保内核代码在 UP 和 SMP 构建下均可正常编译和运行。\n\n## 2. 核心功能\n\n文件中定义了以下关键函数：\n\n- `smp_call_function_single()`：在指定 CPU 上同步执行一个函数（UP 下仅支持 CPU 0）。\n- `smp_call_function_single_async()`：异步形式的单 CPU 函数调用（UP 下立即执行）。\n- `on_each_cpu_cond_mask()`：根据条件函数和 CPU 掩码，在满足条件的 CPU 上执行指定函数（UP 下仅检查 CPU 0）。\n- `smp_call_on_cpu()`：在指定 CPU 上执行一个返回整型值的函数，支持可选的物理 CPU 固定（pinning）操作（用于虚拟化环境）。\n\n## 3. 关键实现\n\n- **CPU 有效性检查**：所有函数在 UP 模式下仅接受 `cpu == 0`，否则返回 `-ENXIO`，因为单处理器系统只有一个逻辑 CPU（编号为 0）。\n- **中断保护**：在执行用户传入的回调函数前，使用 `local_irq_save()`/`local_irq_restore()` 禁用本地中断，模拟 SMP 环境下 IPI（处理器间中断）执行上下文的原子性。\n- **抢占控制**：`on_each_cpu_cond_mask()` 使用 `preempt_disable()`/`preempt_enable()` 禁用内核抢占，确保条件判断和函数执行过程不会被调度器打断，从而在 UP 与 SMP 下行为一致。\n- **虚拟化支持**：`smp_call_on_cpu()` 在 `phys == true` 时调用 `hypervisor_pin_vcpu()`，用于在虚拟化环境中将当前 vCPU 固定到物理 CPU，执行完后再解除绑定。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - `<linux/interrupt.h>`：提供 `local_irq_save()`/`local_irq_restore()`。\n  - `<linux/smp.h>`：定义 SMP 相关类型（如 `smp_call_func_t`、`smp_cond_func_t`）和函数原型。\n  - `<linux/hypervisor.h>`：提供 `hypervisor_pin_vcpu()` 接口，用于虚拟化环境下的 vCPU 固定。\n  - `<linux/kernel.h>` 和 `<linux/export.h>`：基础内核功能和符号导出支持。\n- **构建条件**：该文件通常在 `CONFIG_SMP=n`（即单处理器配置）时被编译，作为 SMP 接口的降级实现。\n\n## 5. 使用场景\n\n- **内核通用代码兼容性**：当内核子系统（如内存管理、电源管理、设备驱动等）编写时使用了 `smp_call_function_single()` 等接口，无论系统是否支持 SMP，都能正确运行。\n- **虚拟化环境中的 CPU 绑定操作**：`smp_call_on_cpu()` 被用于需要在特定 CPU 上执行且可能涉及底层硬件或虚拟化特性的场景（如某些固件调用或性能关键路径）。\n- **调试与测试**：在单核开发板或模拟环境中验证原本为多核设计的内核逻辑是否具备良好的可移植性。",
      "similarity": 0.5060016512870789,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/up.c",
          "start_line": 1,
          "end_line": 11,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * Uniprocessor-only support functions.  The counterpart to kernel/smp.c",
            " */",
            "",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>",
            "#include <linux/hypervisor.h>",
            ""
          ],
          "function_name": null,
          "description": "此代码块定义了单处理器（UP）架构的支持函数，包含必要的头文件并声明与多处理器（SMP）模块对应的UP专用函数，用于处理非对称多处理场景下的核心逻辑。",
          "similarity": 0.5289391279220581
        },
        {
          "chunk_id": 1,
          "file_path": "kernel/up.c",
          "start_line": 12,
          "end_line": 62,
          "content": [
            "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,",
            "\t\t\t\tint wait)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tif (cpu != 0)",
            "\t\treturn -ENXIO;",
            "",
            "\tlocal_irq_save(flags);",
            "\tfunc(info);",
            "\tlocal_irq_restore(flags);",
            "",
            "\treturn 0;",
            "}",
            "int smp_call_function_single_async(int cpu, struct __call_single_data *csd)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tlocal_irq_save(flags);",
            "\tcsd->func(csd->info);",
            "\tlocal_irq_restore(flags);",
            "\treturn 0;",
            "}",
            "void on_each_cpu_cond_mask(smp_cond_func_t cond_func, smp_call_func_t func,",
            "\t\t\t   void *info, bool wait, const struct cpumask *mask)",
            "{",
            "\tunsigned long flags;",
            "",
            "\tpreempt_disable();",
            "\tif ((!cond_func || cond_func(0, info)) && cpumask_test_cpu(0, mask)) {",
            "\t\tlocal_irq_save(flags);",
            "\t\tfunc(info);",
            "\t\tlocal_irq_restore(flags);",
            "\t}",
            "\tpreempt_enable();",
            "}",
            "int smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par, bool phys)",
            "{",
            "\tint ret;",
            "",
            "\tif (cpu != 0)",
            "\t\treturn -ENXIO;",
            "",
            "\tif (phys)",
            "\t\thypervisor_pin_vcpu(0);",
            "\tret = func(par);",
            "\tif (phys)",
            "\t\thypervisor_pin_vcpu(-1);",
            "",
            "\treturn ret;",
            "}"
          ],
          "function_name": "smp_call_function_single, smp_call_function_single_async, on_each_cpu_cond_mask, smp_call_on_cpu",
          "description": "提供了UP架构下SMP接口的模拟实现，其中smp_call_function_single强制在CPU0执行目标函数，smp_call_function_single_async通过csd结构传递参数，on_each_cpu_cond_mask限制仅对CPU0进行条件处理，smp_call_on_cpu通过hypervisor接口绑定VCPU到物理CPU。",
          "similarity": 0.4471224248409271
        }
      ]
    },
    {
      "source_file": "kernel/sched/build_policy.c",
      "md_summary": "> 自动生成时间: 2025-10-25 15:56:50\n> \n> 生成工具: 通义千问 API (qwen3-max)\n> \n> 原始文件: `sched\\build_policy.c`\n\n---\n\n# `sched/build_policy.c` 技术文档\n\n## 1. 文件概述\n\n`build_policy.c` 是 Linux 内核调度子系统中的一个构建辅助文件，其主要作用是将多个与调度策略相关的源代码模块（如实时调度、截止时间调度、CPU 时间统计等）合并到一个编译单元中进行编译。这种设计并非用于实现具体调度逻辑，而是出于**构建效率优化**的目的：通过减少重复包含头文件的开销、平衡各编译单元的大小，从而缩短整体内核编译时间。该文件本身不包含任何函数或数据结构定义，仅通过 `#include` 指令聚合其他 `.c` 文件。\n\n## 2. 核心功能\n\n该文件本身**不定义任何函数或数据结构**，其“功能”体现在所包含的源文件模块中，主要包括：\n\n- **调度策略实现模块**：\n  - `idle.c`：空闲任务（idle task）的调度逻辑\n  - `rt.c`：实时调度类（SCHED_FIFO / SCHED_RR）的实现\n  - `deadline.c`：截止时间调度类（SCHED_DEADLINE）的实现\n  - `cpudeadline.c`（仅在 `CONFIG_SMP` 下）：SMP 架构下截止时间调度的 CPU 负载管理\n  - `ext.c`（仅在 `CONFIG_SCHED_CLASS_EXT` 下）：可扩展调度类支持\n\n- **辅助功能模块**：\n  - `cputime.c`：CPU 时间统计与账户管理\n  - `pelt.c`（仅在 `CONFIG_SMP` 下）：Per-Entity Load Tracking（PELT）负载跟踪机制\n  - `syscalls.c`：调度相关的系统调用（如 `sched_setattr`, `sched_getattr` 等）\n\n## 3. 关键实现\n\n- **单一编译单元聚合**：  \n  通过在一个 `.c` 文件中包含多个功能相关的 `.c` 文件，将原本分散的调度策略代码合并为一个较大的编译单元。这减少了每个源文件单独包含大量公共头文件（如 `sched.h`, `linux/sched/*.h` 等）所带来的重复解析开销。\n\n- **条件编译控制**：  \n  使用 `#ifdef CONFIG_SMP` 和 `#ifdef CONFIG_SCHED_CLASS_EXT` 等宏，确保仅在对应内核配置启用时才包含特定功能模块（如 `cpudeadline.c`、`pelt.c`、`ext.c`），保证构建的灵活性和配置适应性。\n\n- **构建时间平衡**：  \n  注释中明确指出，此编译单元的大小与 `core.c`（调度核心）和 `fair.c`（CFS 完全公平调度器）相当，有助于在并行编译时更均匀地分配工作负载，避免某些编译任务过重而拖慢整体构建速度。\n\n## 4. 依赖关系\n\n- **头文件依赖**：\n  - 调度子系统内部头文件：`\"sched.h\"`, `\"smp.h\"`, `\"autogroup.h\"`, `\"stats.h\"`, `\"pelt.h\"`\n  - 内核通用子系统：`<linux/sched/*.h>`, `<linux/cpuidle.h>`, `<linux/psi.h>`, `<linux/rhashtable.h>` 等\n  - 用户态接口：`<uapi/linux/sched/types.h>`\n\n- **模块依赖**：\n  - 依赖 `core.c` 和 `fair.c` 提供的调度核心框架和 CFS 调度器（但这两者被单独编译）\n  - 所包含的模块（如 `rt.c`, `deadline.c`）依赖调度类注册机制、运行队列管理、负载均衡等核心调度基础设施\n  - `pelt.c` 依赖 SMP 架构下的负载跟踪和迁移逻辑\n\n## 5. 使用场景\n\n- **内核构建阶段**：  \n  该文件仅在内核编译过程中被使用，用于高效地编译调度策略相关代码。最终生成的内核镜像中不包含此文件的独立实体。\n\n- **调度策略运行时**：  \n  虽然 `build_policy.c` 本身不参与运行时逻辑，但它所聚合的模块（如实时调度、截止时间调度、CPU 时间统计等）在以下场景中被激活：\n  - 用户进程使用 `SCHED_FIFO`、`SCHED_RR` 或 `SCHED_DEADLINE` 策略\n  - 系统调用如 `sched_setattr()` 被调用以配置高级调度参数\n  - 内核进行 CPU 负载跟踪（PELT）、空闲 CPU 管理、CPU 热插拔时的调度状态迁移\n  - 能耗管理（如 cpuidle、suspend）与调度器协同工作时\n\n该文件是 Linux 内核构建系统优化的一个典型示例，体现了在大型项目中通过源码组织方式提升编译效率的设计思想。",
      "similarity": 0.49486660957336426,
      "chunks": [
        {
          "chunk_id": 0,
          "file_path": "kernel/sched/build_policy.c",
          "start_line": 1,
          "end_line": 66,
          "content": [
            "// SPDX-License-Identifier: GPL-2.0-only",
            "/*",
            " * These are the scheduling policy related scheduler files, built",
            " * in a single compilation unit for build efficiency reasons.",
            " *",
            " * ( Incidentally, the size of the compilation unit is roughly",
            " *   comparable to core.c and fair.c, the other two big",
            " *   compilation units. This helps balance build time, while",
            " *   coalescing source files to amortize header inclusion",
            " *   cost. )",
            " *",
            " * core.c and fair.c are built separately.",
            " */",
            "",
            "/* Headers: */",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/posix-timers.h>",
            "#include <linux/sched/rt.h>",
            "",
            "#include <linux/cpuidle.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kobject.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/pm.h>",
            "#include <linux/psi.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/seqlock_api.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/vtime.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/percpu-rwsem.h>",
            "",
            "#include <uapi/linux/sched/types.h>",
            "",
            "#include \"sched.h\"",
            "#include \"smp.h\"",
            "",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include \"pelt.h\"",
            "",
            "/* Source code modules: */",
            "",
            "#include \"idle.c\"",
            "",
            "#include \"rt.c\"",
            "",
            "#ifdef CONFIG_SMP",
            "# include \"cpudeadline.c\"",
            "# include \"pelt.c\"",
            "#endif",
            "",
            "#include \"cputime.c\"",
            "#include \"deadline.c\"",
            "",
            "#ifdef CONFIG_SCHED_CLASS_EXT",
            "# include \"ext.c\"",
            "#endif",
            "",
            "#include \"syscalls.c\""
          ],
          "function_name": null,
          "description": "此代码段是Linux内核调度器中与调度策略相关的编译单元，核心功能是整合多个调度类（如实时调度、截止时间调度等）的实现，通过条件编译包含不同模块（如`idle.c`、`rt.c`、`deadline.c`等）以提升构建效率。该文件作为调度策略逻辑的聚合点，协调各子模块的实现并管理其依赖关系。",
          "similarity": 0.4708174467086792
        }
      ]
    }
  ]
}